// ////////////////////////////////////////////////////////////////////////// //
//   if a shader has all variables in set, use literal code provided by set
//   intstead of generating simple accessors.
//   there is no "best fit", preprocessor will use first matched set.
// ////////////////////////////////////////////////////////////////////////// //

Set PureLightmapSTSet {
  forbidden uniform float TexIW;
  forbidden uniform float TexIH;

  uniform vec3 SAxis;
  uniform vec3 TAxis;
  uniform float SOffs;
  uniform float TOffs;
  uniform float TexMinS;
  uniform float TexMinT;
  uniform float CacheS;
  uniform float CacheT;

  code [[
    inline void SetLMapOnly (const texinfo_t *textr, const surface_t *surf, const surfcache_t *cache) {
      if (loc_SAxis >= 0) owner->p_glUniform3fvARB(loc_SAxis, 1, &textr->saxis.x);
      if (loc_SOffs >= 0) owner->p_glUniform1fARB(loc_SOffs, textr->soffs);
      if (loc_TAxis >= 0) owner->p_glUniform3fvARB(loc_TAxis, 1, &textr->taxis.x);
      if (loc_TOffs >= 0) owner->p_glUniform1fARB(loc_TOffs, textr->toffs);
      if (loc_TexMinS >= 0) owner->p_glUniform1fARB(loc_TexMinS, surf->texturemins[0]);
      if (loc_TexMinT >= 0) owner->p_glUniform1fARB(loc_TexMinT, surf->texturemins[1]);
      if (loc_CacheS >= 0) owner->p_glUniform1fARB(loc_CacheS, cache->s);
      if (loc_CacheT >= 0) owner->p_glUniform1fARB(loc_CacheT, cache->t);
    }
  ]]
}


Set TextureSTSet {
  uniform vec3 SAxis;
  uniform vec3 TAxis;
  uniform float SOffs;
  uniform float TOffs;
  uniform float TexIW;
  uniform float TexIH;

  code [[
    inline void SetTex (const texinfo_t *textr) {
      if (loc_SAxis >= 0) owner->p_glUniform3fvARB(loc_SAxis, 1, &textr->saxis.x);
      if (loc_SOffs >= 0) owner->p_glUniform1fARB(loc_SOffs, textr->soffs);
      if (loc_TexIW >= 0) owner->p_glUniform1fARB(loc_TexIW, owner->tex_iw);
      if (loc_TAxis >= 0) owner->p_glUniform3fvARB(loc_TAxis, 1, &textr->taxis.x);
      if (loc_TOffs >= 0) owner->p_glUniform1fARB(loc_TOffs, textr->toffs);
      if (loc_TexIH >= 0) owner->p_glUniform1fARB(loc_TexIH, owner->tex_ih);
    }
  ]]
}


Set TextureSTSetNoSize {
  forbidden set PureLightmapSTSet;

  forbidden uniform float TexIW;
  forbidden uniform float TexIH;

  uniform vec3 SAxis;
  uniform vec3 TAxis;
  uniform float SOffs;
  uniform float TOffs;

  code [[
    inline void SetTexNoSize (const texinfo_t *textr) {
      if (loc_SAxis >= 0) owner->p_glUniform3fvARB(loc_SAxis, 1, &textr->saxis.x);
      if (loc_SOffs >= 0) owner->p_glUniform1fARB(loc_SOffs, textr->soffs);
      if (loc_TAxis >= 0) owner->p_glUniform3fvARB(loc_TAxis, 1, &textr->taxis.x);
      if (loc_TOffs >= 0) owner->p_glUniform1fARB(loc_TOffs, textr->toffs);
    }
  ]]
}


Set LightmapSTSet {
  forbidden set PureLightmapSTSet;

  uniform float TexMinS;
  uniform float TexMinT;
  uniform float CacheS;
  uniform float CacheT;

  code [[
    inline void SetLMap (const surface_t *surf, const surfcache_t *cache) {
      if (loc_TexMinS >= 0) owner->p_glUniform1fARB(loc_TexMinS, surf->texturemins[0]);
      if (loc_TexMinT >= 0) owner->p_glUniform1fARB(loc_TexMinT, surf->texturemins[1]);
      if (loc_CacheS >= 0) owner->p_glUniform1fARB(loc_CacheS, cache->s);
      if (loc_CacheT >= 0) owner->p_glUniform1fARB(loc_CacheT, cache->t);
    }
  ]]
}


Set FogSet {
  uniform bool FogEnabled;
  uniform vec4 FogColour;
  uniform float FogStart;
  uniform float FogEnd;

  code [[
    inline void SetFogFade (vuint32 Fade, float Alpha) {
      if (Fade) {
        if (loc_FogEnabled >= 0) owner->p_glUniform1iARB(loc_FogEnabled, GL_TRUE);
        owner->p_glUniform4fARB(loc_FogColour,
          ((Fade>>16)&255)/255.0f,
          ((Fade>>8)&255)/255.0f,
          (Fade&255)/255.0f, Alpha);
        owner->p_glUniform1fARB(loc_FogStart, Fade == FADE_LIGHT ? 1.0f : r_fog_start);
        owner->p_glUniform1fARB(loc_FogEnd, Fade == FADE_LIGHT ? 1024.0f*r_fade_factor : r_fog_end);
      } else {
        if (loc_FogEnabled >= 0) owner->p_glUniform1iARB(loc_FogEnabled, GL_FALSE);
      }
    }
  ]]
}


Set SimpleFogSet {
  forbidden uniform bool FogEnabled;

  uniform vec4 FogColour;
  uniform float FogStart;
  uniform float FogEnd;

  code [[
    inline void SetFogFade (vuint32 Fade, float Alpha) {
      owner->p_glUniform4fARB(loc_FogColour,
        ((Fade>>16)&255)/255.0f,
        ((Fade>>8)&255)/255.0f,
        (Fade&255)/255.0f, Alpha);
      owner->p_glUniform1fARB(loc_FogStart, Fade == FADE_LIGHT ? 1.0f : r_fog_start);
      owner->p_glUniform1fARB(loc_FogEnd, Fade == FADE_LIGHT ? 1024.0f*r_fade_factor : r_fog_end);
    }
  ]]
}


// ////////////////////////////////////////////////////////////////////////// //
ShaderList basedir="basev/common/glshaders" {
  Shader DrawFixedCol both="draw_fixed_col";
  Shader DrawSimple both="draw_simple";
  Shader DrawShadow vertex="draw_simple" fragment="draw_shadow";
  Shader DrawAutomap both="draw_automap";

  Shader SurfZBuf both="surf_zbuf";
  Shader [advanced] SurfShadowVolume vertex="surf_svol" fragment="surf_zbuf";

  Shader SurfDecalNoLMap both="surf_decal_nolmap";
  Shader SurfDecalLMap both="surf_decal_lmap";
  Shader SurfAdvDecal both="surf_decal_adv";

  Shader SurfSimple both="surf_simple";
  Shader SurfLightmap both="surf_lightmap";
  Shader SurfSimpleBrightmap both="surf_simple" { define "VV_SIMPLE_BRIGHTMAP"; }
  Shader SurfLightmapBrightmap both="surf_lightmap" { define "VV_LIGHTMAP_BRIGHTMAP"; }

  Shader SurfSky both="surf_sky";
  Shader SurfDSky both="surf_dsky";

  Shader SurfMasked both="surf_masked";
  Shader SurfMaskedBrightmap both="surf_masked" { define "VV_MASKED_BRIGHTMAP"; }
  Shader SurfMaskedGlow both="surf_masked" { define "VV_MASKED_GLOW"; }
  Shader SurfMaskedBrightmapGlow both="surf_masked" { defines { "VV_MASKED_BRIGHTMAP", "VV_MASKED_GLOW" } }

  Shader SurfPartSq vertex="particle" fragment="particle_sq";
  Shader SurfPartSm vertex="particle" fragment="particle_sm";

  Shader [advanced] ShadowsAmbient both="shadows_surf_ambient";
  Shader [advanced] ShadowsAmbientMasked both="shadows_surf_ambient" { define "VV_AMBIENT_MASKED_WALL"; }
  Shader [advanced] ShadowsAmbientBrightmap both="shadows_surf_ambient" { define "VV_AMBIENT_BRIGHTMAP_WALL"; }
  /*
  Shader [advanced] ShadowsAmbientGlow both="shadows_surf_ambient" { defines { "VV_AMBIENT_GLOW" } }
  Shader [advanced] ShadowsAmbientMaskedGlow both="shadows_surf_ambient" { defines { "VV_AMBIENT_MASKED_WALL", "VV_AMBIENT_GLOW" } }
  Shader [advanced] ShadowsAmbientBrightmapGlow both="shadows_surf_ambient" { defines { "VV_AMBIENT_BRIGHTMAP_WALL", "VV_AMBIENT_GLOW" } }
  */
  Shader [advanced] ShadowsTexture both="shadows_surf_texture";
  Shader [advanced] ShadowsTextureMasked both="shadows_surf_texture" { define "VV_TEXTURED_MASKED_WALL"; }
  Shader [advanced] ShadowsFog both="shadows_surf_fog";
  Shader [advanced] ShadowsFogMasked both="shadows_surf_fog" { defines { "VV_MASKED_FOG" } }
  Shader [advanced] ShadowsLight both="shadows_surf_light";
  Shader [advanced] ShadowsLightSpot both="shadows_surf_light" { define "VV_SPOTLIGHT"; }
  Shader [advanced] ShadowsLightDbg both="shadows_surf_light" { define "VV_DEBUG_LIGHT"; }
  Shader [advanced] ShadowsLightSpotDbg both="shadows_surf_light" { defines { "VV_DEBUG_LIGHT", "VV_SPOTLIGHT" } }

  Shader SurfModel both="surf_model";
  Shader [advanced] ShadowsModelAmbient both="shadows_model_ambient";
  Shader [advanced] ShadowsModelTextures both="shadows_model_textures";
  Shader [advanced] ShadowsModelLight both="shadows_model_light";
  Shader [advanced] ShadowsModelShadow both="shadows_model_shadow";
  Shader [advanced] ShadowsModelFog both="shadows_model_fog";
}
