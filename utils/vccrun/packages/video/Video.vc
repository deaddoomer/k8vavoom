class Video : Object abstract native;

// default mode is `BlendNormal`
enum {
  BlendNormal, // glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  BlendBlend, // glBlendFunc(GL_SRC_ALPHA, GL_ONE)
  BlendFilter, // glBlendFunc(GL_DST_COLOR, GL_SRC_COLOR)
  BlendInvert, // glBlendFunc(GL_ONE_MINUS_DST_COLOR, GL_ZERO)
}


native final static bool canInit ();
native final static bool hasOpenGL ();
native final static bool isInitialized ();
native final static int screenWidth ();
native final static int screenHeight ();

native final static void setScale (float sx, float sy);

native final static int getFrameTime ();
native final static void setFrameTime (int newframetime); // in msecs

native final static bool openScreen (string winname, int width, int height);
native final static void closeScreen ();

native final static void clearScreen ();
native final static void clearScreenRGB (int r, int g, int b);

native final static void runEventLoop ();

native final static void requestRefresh ();
native final static void requestQuit ();

// aborts if font cannot be loaded
native final static void loadFont (name fontname, string fnameIni, string fnameTexture);

native final static void setSmoothLine (bool v);

// color: aarrggbb
// WARNING: "a" is inverted, and actually means "transparency"
//          i.e. a==0 is completely opaque
//          it is easier this way, even if it may look conunterintuitive for you
native final static int getColorARGB ();
native final static void setColorARGB (int argb);

// BlendXXX
native final static int getBlendMode ();
native final static void setBlendMode (int v);

native final static name getFont ();
native final static void setFont (name fontname);
native final static int fontHeight ();
native final static int spaceWidth ();
native final static int charWidth (int ch);
native final static int textWidth (string text);
native final static int textHeight (string text);
native final static void drawTextAt (int x, int y, string text);

native final static void drawLine (int x0, int y0, int x1, int y1);
native final static void drawRect (int x0, int y0, int w, int h);
native final static void fillRect (int x0, int y0, int w, int h);


// ////////////////////////////////////////////////////////////////////////// //
struct ScissorRect {
  int x, y, w, h;
  int enabled;
}


native final static bool getScissorEnabled ();
native final static void setScissorEnabled (bool v);
native final static void getScissor (ScissorRect *sr);
native final static void setScissor (ScissorRect *sr);

native final static void copyScissor (ScissorRect *dest, ScissorRect *src);


// returns `false` if no area left
final static bool scissorCombine (int x0, int y0, int w, int h) {
  ScissorRect sr;
  getScissor(&sr);
  if (!sr.enabled) {
    sr.x = 0;
    sr.y = 0;
    sr.w = screenWidth;
    sr.h = screenHeight;
    sr.enabled = true;
  }
  if (sr.w < 1 || sr.h < 1) return false; // nothing to do
  if (w < 1 || h < 1) {
    sr.w = 0;
    sr.h = 0;
  } else {
    int sx1 = sr.x+sr.w-1;
    int sy1 = sr.y+sr.h-1;
    int x1 = x0+w-1;
    int y1 = y0+h-1;
    // check for overlapping rects
    if (x0 > sx1 || y0 > sy1 || x1 < sr.x || y1 < sr.y) {
      // no overlap
      sr.w = 0;
      sr.h = 0;
    } else {
      // overlaps
      if (x0 > sr.x) sr.x = x0;
      if (y0 > sr.y) sr.y = y0;
      if (x1 < sx1) sx1 = x1;
      if (y1 < sy1) sy1 = y1;
      sr.w = sx1-sr.x+1;
      sr.h = sy1-sr.y+1;
    }
  }
  setScissor(&sr);
  return (sr.w > 0 && sr.h > 0);
}


final static void drawBevel (int x0, int y0, int awidth, int aheight, int argbUp, int argbDown) {
  setColorARGB(argbUp);
  drawLine(x0, y0, x0+awidth, y0);
  drawLine(x0, y0+1, x0, y0+aheight);
  setColorARGB(argbDown);
  drawLine(x0+1, y0+aheight-1, x0+awidth, y0+aheight-1);
  drawLine(x0+awidth-1, y0+1, x0+awidth-1, y0+aheight-1);
}


// ////////////////////////////////////////////////////////////////////////// //
/*
// will set alpha to opaque, and return alpha as 0
final int colorRGB {
  get { return Video.getColorARGB()&0xff_ff_ff; }
  set { Video.setColorARGB(value|(value&0xff_00_00_00 ? 0 : 0xff_00_00_00)); }
}
*/
final int colorARGB {
  get { return getColorARGB(); }
  set { setColorARGB(value); }
}
alias colorRGB = colorARGB;
alias color = colorARGB;

final int blendMode {
  get { return getBlendMode(); }
  set { setBlendMode(value); }
}


final name fontName {
  get { return getFont(); }
  set { setFont(value); }
}

final bool scissorEnabled {
  get { return Video.getScissorEnabled(); }
  set { Video.setScissorEnabled(value); }
}
