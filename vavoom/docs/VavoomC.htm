<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.78 [en] (Win98; U) [Netscape]">
   <title>VavoomC Language Reference</title>
</head>
<body link="#0000FF" vlink="#800080">

<h1>
VavoomC Language Reference</h1>

<address>
Janis Legzdinsh</address>

<br>vavoom@vavoom-engine.com
<br><a href="http://www.vavoom-engine.com/">http://www.vavoom-engine.com/</a>
<p>$Id$
<h2>
Variables</h2>

<h3>
Simple Variables</h3>
Here are some examples of instance variable declarations in VavoomC:
<pre>int a; // Declare an integer variable named "a".</pre>

<pre>float f; // Declare a floating-point variable named "f".

int Table[64]; // Declare an array of 64 integers named "Table".</pre>

<pre>int *p; // Declare a pointer to int named "p".

string PlayerName; // Declare a string pointer.

Actor Other; // Declare a variable referencing an actor.</pre>
Variables can appear in three kinds of places in VavoomC: global variables,
which are accessible from everywhere. Instance variables, which apply to
an entire object, appear immediately after the class declarations. Local
variables appear within a function, and are only active while that function
executes.
<p>Here are the basic variable types supported in VavoomC:
<ul>
<li>
int: A 32-bit integer value.</li>

<li>
bool: A boolean value: either "true" or "false".</li>

<li>
float: A 32-bit floating point number.</li>

<li>
string: A string of characters.</li>

<li>
name: The name of an item in Vavoom (such as the name of a function, state,
class, etc). Names are stored as a 16-bit index into the global name table.
Names correspond to simple strings of 1-31 characters. Names are not like
strings: strings can be modified dynamically, but names can only take on
predefined name values.</li>

<li>
classid: Represents a class. The actual value is a reference to an object
describing class, but currently you can't use it as a Class object.</li>

<li>
Pointers.</li>

<li>
Class references: A variable that refers to another object or actor in
the world. Object and actor references are very powerful tools, because
they enable you to access the variables and functions of another actor.
Object references may also contain a special value called "none", which
is the equivalent of the C "NULL" pointer: it says "this variable doesn’t
refer to any object".</li>

<li>
Structs: Same as C structures.</li>
</ul>
Arrays are declared using the following syntax:
<pre>int MyArray[20]; // Declares an array of 20 ints.</pre>
VavoomC supports multidimensional arrays.
<h3>
Pointers</h3>
You can declare a pointer variable like this:
<pre>int *p; // A pointer to integer.</pre>
The variable "p" above is a pointer to an integer. Pointers to structs
or classes can refer to any object that belongs to a subclass of this struct
or class.
<p>There's a special pointer constant NULL which points to "nowhere".
<p>Pointers of type void* also are handled specially - any pointer can
be assigned to void* and void* can be assigned to any pointer.
<h3>
Reference variables</h3>
You can declare a variable that refers to an object like this:
<pre>Actor A; // An actor reference.</pre>
The variable "A" above is a reference to an object in the Actor class.
Such a variable can refer to any object that belongs to a subclass of Actor.
<p>When you have a variable that refers to an actor, you can access that
actor’s variables, and call its functions.
<p>Variables that refer to actors always either refer to a valid actor
(any actor that actually exists in the level), or they contain the value
"none". none is equivalent to the C/C++ "NULL" pointer.
<p>Note that an object or actor reference "points to" another actor or
object, it doesn’t "contain" an actor or object. The C equivalent of an
actor reference is a pointer to an object.
<h3>
Enumerations</h3>
Enumerations exist in VavoomC as a convenient way to declare a bunch of
keywords.
<p>Here is sample code that declares enumerations.
<pre>// Declare an enumeration, with three values.

enum

{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CO_Red,

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CO_Green,

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CO_Blue

};</pre>

<h3>
Structs</h3>
An Vavoom struct is a way of cramming a bunch of variables together into
a new kind of super-variable called a struct. VavoomC structs are just
like C structs, in that they can contain any simple variables or arrays.
<p>You can declare a struct as follows:
<pre>// A structure describing a plane</pre>

<pre>struct TPlane</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; TVec normal;</pre>

<pre>&nbsp;&nbsp;&nbsp; float dist;</pre>

<pre>&nbsp;&nbsp;&nbsp; int __type;</pre>

<pre>&nbsp;&nbsp;&nbsp; int __signbits;</pre>

<pre>&nbsp;&nbsp;&nbsp; int __reserved1;</pre>

<pre>&nbsp;&nbsp;&nbsp; int __reserved2;</pre>

<pre>};</pre>
In VavoomC structures can have a parent structure, just like classes. For
example:
<br>&nbsp;
<pre>struct sec_plane_t:TPlane</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; float minz;</pre>

<pre>&nbsp;&nbsp;&nbsp; float maxz;</pre>

<pre>&nbsp;&nbsp;&nbsp; int pic;</pre>

<pre>&nbsp;&nbsp;&nbsp; int __base_pic;</pre>

<pre>&nbsp;&nbsp;&nbsp; float xoffs;</pre>

<pre>&nbsp;&nbsp;&nbsp; float yoffs;</pre>

<pre>&nbsp;&nbsp;&nbsp; int flags;</pre>

<pre>&nbsp;&nbsp;&nbsp; int translucency;</pre>

<pre>};</pre>

<p><br>Once you declare a struct, you are ready to start declaring specific
variables of that struct type:
<pre>// Declare a pointer variable of type TPlane.</pre>

<pre>sec_plane_t *floor;</pre>
To access a component of a struct, use code like the following.
<pre>void MyFunction(void)</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; // Scroll texture</pre>

<pre>&nbsp;&nbsp;&nbsp; floor->xoffs += 8.0;</pre>

<pre>&nbsp;&nbsp;&nbsp; floor->yoffs += 4.0;</pre>

<pre>&nbsp;&nbsp;&nbsp; // Pass floor to a function.</pre>

<pre>&nbsp;&nbsp;&nbsp; SomeFunction(floor);</pre>

<pre>}</pre>

<h3>
Classes</h3>
A class is declared like this:
<pre>class MyClass:MyParentClass</pre>

<pre>&nbsp;&nbsp;&nbsp; // Class specifiers.</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; // Declaration of class variables and functions goes here</pre>

<pre>}</pre>
Here I am declaring a new class named "MyClass", which inherets the functionality
of "MyParentClass".
<p>Object is the parent class of all objects in Vavoom. Object is an abstract
base class, in that it doesn’t do anything useful.
<p>Each class inherets all of the variables and functions&nbsp; from its
parent class. It can then add new variable declarations, add new functions
(or override the existing functions).
<p>The class declaration can take several optional specifiers that affect
the class:
<ul>
<li>
native: Says "this class uses behind-the-scenes C++ support". Vavoom expects
native classes to contain a C++ implementation in the EXE file.</li>

<li>
abstract: Declares the class as an "abstract base class". This prevents
the user from spawning actors of this class, because the class isn’t meaningful
on its own.</li>

<li>
__mobjinfo__(a): Adds this class to the mobjinfo table.</li>
</ul>

<h3>
Structure and class prototypes</h3>
VavoomC Compiler is one-pass compiler, that means that if you want to create
a pointer to a struct or a pointer or reference to a class, it must be
already declared or prototyped. Prototypes lloks like this:
<pre>struct sec_plane_t;</pre>

<pre>class MyClass;</pre>

<h2>
Expressions</h2>

<h3>
Constants</h3>
In VavoomC, you can specify constant values of nearly all data types:
<ul>
<li>
Integer constants are specified with simple numbers, for example: 123</li>

<li>
If you must specify an integer constant in hexidecimal format, use i.e.:
0x123</li>

<li>
Floating point constants are specified with decimal numbers like: 456.789</li>

<li>
String constants must be enclosed in double quotes, for example: "MyString"</li>

<li>
Name constants must be enclosed in single quotes, for example 'MyName'</li>

<li>
Vector constants contain X, Y, and Z values like this: vector(1.0,2.0,4.0)</li>

<li>
The "NULL" constant points to "nothing".</li>

<li>
The "none" constant refers to "no object".</li>

<li>
The "this" constant points to and "self" constant refers to "this object",
i.e. the object whose script is executing.</li>
</ul>

<h3>
Expressions</h3>
To assign a value to a variable, use "=" like this:
<pre>void Test(void)</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; int i;</pre>

<pre>&nbsp;&nbsp;&nbsp; float f;</pre>

<pre>&nbsp;&nbsp;&nbsp; string s;</pre>

<pre>&nbsp;&nbsp;&nbsp; TVec v, q;</pre>

<pre>&nbsp;&nbsp;&nbsp; i = 10; // Assign a value to integer variable i.</pre>

<pre>&nbsp;&nbsp;&nbsp; f = 2.7; // Assign a value to floating-point variable f.</pre>

<pre>&nbsp;&nbsp;&nbsp; s = "Hello!"; // Assign a value to string variable s.</pre>

<pre>&nbsp;&nbsp;&nbsp; v = q; // Copy value of vector q to v.</pre>

<pre>}</pre>
VavoomC is strongly typed language, that means that attempts to assign
a value of incompatible type will result in compiler error.
<h2>
Functions</h2>

<h3>
Declaring Functions</h3>
Current version of VavoomC supports two types of functions: global functions
and class member functions. Class member functions can be declared inside
class declaration as whell as ouside class declaration.
<p>In VavoomC, you can declare new functions and write new versions of
existing functions. Functions can take one or more parameters, and can
optionally return a value. The parameter and return value type mus be of
size 4 (i.e. integers, floats, pointers, references) or vectors. Some functions
are implemented in C++, they are called builtin functions.
<p>Here are some simple function declarations:
<pre>float fabs(float val)</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; return (val &lt; 0.0) ? -val : val;</pre>

<pre>}</pre>

<pre>class MyClass:MyParentClass</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; int MyVariable;</pre>

<pre>&nbsp;&nbsp;&nbsp; int GetMyVariable(void)</pre>

<pre>&nbsp;&nbsp;&nbsp; {</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MyVariable;</pre>

<pre>&nbsp;&nbsp;&nbsp; }</pre>

<pre>}</pre>

<pre>class SomeOtherClass:SomeOtherBase</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; int OtherVariable;</pre>

<pre>&nbsp;&nbsp;&nbsp; int GetOtherVariable(void);</pre>

<pre>}</pre>

<pre>int SomeOtherClass::GetOtherVariable(void)</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; return OtherVariable;</pre>

<pre>}</pre>

<p><br>When a function is called, the code within the brackets is executed.
Inside the function, you can declare local variables, and execute any VavoomC
code. The optional "return" keyword causes the function to immediately
return a value.
<p>WARNING! Local variables you declare in a function are not initialized.
<p>Function calls can be recursive. For example, the following function
computes the factorial of a number:
<pre>// Function to compute the factorial of a number.</pre>

<pre>int Factorial(int Number)</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; if (Number &lt;= 0)</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;</pre>

<pre>&nbsp;&nbsp;&nbsp; else</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Number * Factorial( Number – 1 );</pre>

<pre>}</pre>

<h3>
Function prototypes</h3>
VavoomC Compiler is one-pass compiler, that means that all functions must
be already declared or prototyped before they can be used. Function prototypes
lloks like this:
<pre>float fabs(float val);</pre>

<pre>class MyClass:MyParentClass</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; int MyFunction(void);</pre>

<pre>}</pre>

<h3>
Function overriding</h3>
"Function overriding" refers to writing a new version of a function in
a subclass.
<p>To override a function, just cut and paste the function definition from
the parent class into your new class. For example, for OnMapSpawn, you
could add this to your Demon class.
<pre>// New Demon class version of the OnMapSpawn function.</pre>

<pre>void OnMapSpawn(mthing_t *mthing)</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; // If monsters are disabled, then destroy this actor immediately</pre>

<pre>&nbsp;&nbsp;&nbsp; if (nomonsters)</pre>

<pre>&nbsp;&nbsp;&nbsp; {</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RemoveMobjThinker(this);</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</pre>

<pre>&nbsp;&nbsp;&nbsp; }</pre>

<pre>&nbsp;&nbsp;&nbsp; // Call parent class version of OnMapSpawn</pre>

<pre>&nbsp;&nbsp;&nbsp; ::OnMapSpawn(mthing);</pre>

<pre>}</pre>
Function overriding is the key to creating new VavoomC classes efficiently.
You can create a new class that expands on an existing class. Then, all
you need to do is override the functions which you want to be handled differently.
This enables you to create new kinds of objects without writing gigantic
amounts of code.
<h3>
Advanced function specifiers</h3>
native: You can declare VavoomC functions as "native", which means that
the function is callable from VavoomC, but is actually written (elsewhere)
in C++. For example:
<pre>native float sin(float angle);</pre>

<h2>
Program Structure</h2>
VavoomC supports all the standard flow-control statements of C/C++/Java:
<h3>
For Loops</h3>
"for" loops let you cycle through a loop as long as some condition is met.
For example:
<pre>// Example of "for" loop.</pre>

<pre>void ForExample(void)</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; int i;</pre>

<pre>&nbsp;&nbsp;&nbsp; print("Demonstrating the for loop");</pre>

<pre>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 4; i++)</pre>

<pre>&nbsp;&nbsp;&nbsp; {</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("The value of i is %d\n", i);</pre>

<pre>&nbsp;&nbsp;&nbsp; }</pre>

<pre>&nbsp;&nbsp;&nbsp; print("Completed with i=%d\n", i);</pre>

<pre>}</pre>
The output of this loop is:
<pre>Demonstrating the for loop

The value of i is 0

The value of i is 1

The value of i is 2

The value of i is 3

Completed with i=4</pre>
In a for loop, you must specify three expressions separated by semicolons.
The first expression is for initializing a variable to its starting value.
The second expression gives a condition which is checked before each iteration
of the loop executes; if this expression is true, the loop executes. If
it’s false, the loop terminates. The third condition gives an expression
which increments the loop counter.
<p>Though most "for" loop expressions just update a counter, you can also
use "for" loops for more advanced things like traversing linked lists,
by using the appropriate initialization, termination, and increment expressions.
<p>In all of the flow control statements, you can either execute a single
statement, without brackets, as follows:
<pre>for (i = 0; i &lt; 4; i++)</pre>

<pre>&nbsp;&nbsp;&nbsp; print("The value of i is %d", i);</pre>
Or you can execute multiple statements, surrounded by brackets, like this:
<pre>for (i = 0; i &lt; 4; i++)</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; print("The value of i is");</pre>

<pre>&nbsp;&nbsp;&nbsp; print("%d\n", i);</pre>

<pre>}</pre>

<h3>
Do-While Loops</h3>
"do"-"whilel" loops let you cycle through a loop while some ending expression
is true.
<pre>// Example of "do" loop.</pre>

<pre>void DoExample(void)</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; int i;</pre>

<pre>&nbsp;&nbsp;&nbsp; print("Demonstrating the do loop");</pre>

<pre>&nbsp;&nbsp;&nbsp; i = 0;</pre>

<pre>&nbsp;&nbsp;&nbsp; do</pre>

<pre>&nbsp;&nbsp;&nbsp; {</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("The value of i is %d\n", i);</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 1;</pre>

<pre>&nbsp;&nbsp;&nbsp; } while (i &lt; 4);</pre>

<pre>&nbsp;&nbsp;&nbsp; print("Completed with i=%d\n", i);</pre>

<pre>}</pre>
The output of this loop is:
<pre>Demonstrating the do loop

The value of i is 0

The value of i is 1

The value of i is 2

The value of i is 3

Completed with i=4</pre>

<h3>
While Loops</h3>
"While" loops let you cycle through a loop while some starting expression
is true.
<pre>// Example of "while" loop.

void WhileExample(void)

{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i = 0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("Demonstrating the while loop");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (i &lt; 4)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print( "The value of i is %d\n", i);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = i + 1;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("Completed with i=%d\n", i);

}</pre>
The output of this loop is:
<pre>Demonstrating the do loop

The value of i is 0

The value of i is 1

The value of i is 2

The value of i is 3

Completed with i=4</pre>

<h3>
Break</h3>
The "break" command exits out of the nearest loop ("for", "do", or "while").
<pre>// Example of "while" loop.

void WhileExample(void)</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; int i;</pre>

<pre>&nbsp;&nbsp;&nbsp; print("Demonstrating break");</pre>

<pre>&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; 10; i++)</pre>

<pre>&nbsp;&nbsp;&nbsp; {</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i == 3)</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("The value of i is %d\n", i);</pre>

<pre>&nbsp;&nbsp;&nbsp; }</pre>

<pre>&nbsp;&nbsp;&nbsp; print("Completed with i=%d\n", i);</pre>

<pre>}</pre>
The output of this loop is:
<pre>Demonstrating break

The value of i is 0

The value of i is 1

The value of i is 2

Completed with i=3</pre>

<h3>
Conditional Statements</h3>
"if" and "else" let you execute code if certain conditions are met.
<pre>// Example of simple "if".</pre>

<pre>if (LightBrightness &lt; 20)</pre>

<pre>&nbsp;&nbsp;&nbsp; print("My light is dim\n");

&nbsp;

// Example of "if-else".</pre>

<pre>if (LightBrightness &lt; 20)</pre>

<pre>&nbsp;&nbsp;&nbsp; print("My light is dim\n");</pre>

<pre>else</pre>

<pre>&nbsp;&nbsp;&nbsp; print("My light is bright\n");</pre>

<h3>
Case Statements</h3>
"switch", "case", "default", and "break" let you handle lists of conditions
easily.
<pre>// Example of switch-case.</pre>

<pre>void TestSwitch(void)</pre>

<pre>{</pre>

<pre>&nbsp;&nbsp;&nbsp; // Executed one of the case statements below, based on</pre>

<pre>&nbsp;&nbsp;&nbsp; // the value in LightType.</pre>

<pre>&nbsp;&nbsp;&nbsp; switch (LightType)</pre>

<pre>&nbsp;&nbsp;&nbsp; {</pre>

<pre>&nbsp;&nbsp;&nbsp; case LT_None:</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("There is no lighting\n");</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</pre>

<pre>&nbsp;&nbsp;&nbsp; case LT_Steady:</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("There is steady lighting\n");</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</pre>

<pre>&nbsp;&nbsp;&nbsp; case LT_Backdrop:</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("There is backdrop lighting\n");</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</pre>

<pre>&nbsp;&nbsp;&nbsp; default:</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("There is dynamic\n");</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</pre>

<pre>&nbsp;&nbsp;&nbsp; }</pre>

<pre>}</pre>
A "switch" statement consists of one or more "case" statements, and an
optional "default" statement. After a switch statement, execution goes
to the matching "case" statement if there is one; otherwise execution goes
to the "default" statement; otherwise execution continues past the end
of the "select" statement.
<p>After you write code following a "case" label, you must use a "break"
statement to cause execution to go past the end of the "switch" statement.
If you don’t use a "break", execution "falls through" to the next "case"
handler.
<h2>
Language Functionality</h2>

<h3>
Built-in operators and their precedence</h3>
VavoomC provides a wide variety of C/C++/Java-style operators for such
operations as adding numbers together, comaring values, and incrementing
variables. Note that all of the operators have the same precedence as they
do in C.
<br>&nbsp;
<table BORDER CELLPADDING=7 WIDTH="637" bordercolor="#000000" >
<tr>
<td VALIGN=TOP WIDTH="13%">Operator</td>

<td VALIGN=TOP WIDTH="36%">Types it applies to</td>

<td VALIGN=TOP WIDTH="51%">Meaning</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">*=</td>

<td VALIGN=TOP WIDTH="36%">int, float, vector</td>

<td VALIGN=TOP WIDTH="51%">Multiply and assign</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">/=</td>

<td VALIGN=TOP WIDTH="36%">int, float, vector</td>

<td VALIGN=TOP WIDTH="51%">Divide and assign</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">+=</td>

<td VALIGN=TOP WIDTH="36%">int, float, vector</td>

<td VALIGN=TOP WIDTH="51%">Add and assign</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">-=</td>

<td VALIGN=TOP WIDTH="36%">int, float, vector</td>

<td VALIGN=TOP WIDTH="51%">Subtract and assign</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">||</td>

<td VALIGN=TOP WIDTH="36%">bool</td>

<td VALIGN=TOP WIDTH="51%">Logical or</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">&amp;&amp;</td>

<td VALIGN=TOP WIDTH="36%">bool</td>

<td VALIGN=TOP WIDTH="51%">Logical and</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">&amp;</td>

<td VALIGN=TOP WIDTH="36%">int</td>

<td VALIGN=TOP WIDTH="51%">Bitwise and</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">|</td>

<td VALIGN=TOP WIDTH="36%">int</td>

<td VALIGN=TOP WIDTH="51%">Bitwise or</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">^</td>

<td VALIGN=TOP WIDTH="36%">int</td>

<td VALIGN=TOP WIDTH="51%">Bitwise exlusive or</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">!=</td>

<td VALIGN=TOP WIDTH="36%">All</td>

<td VALIGN=TOP WIDTH="51%">Compare for inequality</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">==</td>

<td VALIGN=TOP WIDTH="36%">All</td>

<td VALIGN=TOP WIDTH="51%">Compare for equality</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">&lt;</td>

<td VALIGN=TOP WIDTH="36%">int, float</td>

<td VALIGN=TOP WIDTH="51%">Less than</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">></td>

<td VALIGN=TOP WIDTH="36%">int, float</td>

<td VALIGN=TOP WIDTH="51%">Greater than</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">&lt;=</td>

<td VALIGN=TOP WIDTH="36%">int, float</td>

<td VALIGN=TOP WIDTH="51%">Less than or equal to</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">>=</td>

<td VALIGN=TOP WIDTH="36%">int, float</td>

<td VALIGN=TOP WIDTH="51%">Greater than or equal to</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">&lt;&lt;</td>

<td VALIGN=TOP WIDTH="36%">int</td>

<td VALIGN=TOP WIDTH="51%">Left shift</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">>></td>

<td VALIGN=TOP WIDTH="36%">int</td>

<td VALIGN=TOP WIDTH="51%">Right shift</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">+</td>

<td VALIGN=TOP WIDTH="36%">int, float</td>

<td VALIGN=TOP WIDTH="51%">Add</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">-</td>

<td VALIGN=TOP WIDTH="36%">int, float</td>

<td VALIGN=TOP WIDTH="51%">Subtract</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">%</td>

<td VALIGN=TOP WIDTH="36%">int</td>

<td VALIGN=TOP WIDTH="51%">Modulo (remainder after division)</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">*</td>

<td VALIGN=TOP WIDTH="36%">int, float, vector</td>

<td VALIGN=TOP WIDTH="51%">Multiply</td>
</tr>

<tr>
<td VALIGN=TOP WIDTH="13%">/</td>

<td VALIGN=TOP WIDTH="36%">int, float, vector</td>

<td VALIGN=TOP WIDTH="51%">Divide</td>
</tr>
</table>

<p>The above table lists the operators in order of precedence (with operators
of the same precedence grouped together). When you type in a complex expression
like "1*2+3*4", VavoomC automatically groups the operators by precedence.
Since multiplication has a higher precedence than addition, the expression
is evaluated as "(1*2)+(3*4)".
<p>The "&amp;&amp;" (logical and) and "||" (logical or) operators are short-circuited:
if the result of the expression can be determined solely from the first
expression (for example, if the first argument of &amp;&amp; is false),
the second expression is not evaluated.
<p>In addition, VavoomC supports the following unary operators:
<ul>
<li>
! (bool) Logical not.</li>

<li>
- (int, float) negation.</li>

<li>
~ (int) bitwise negation.</li>

<li>
++, -- Decrement (either before or after a variable).</li>
</ul>

</body>
</html>
