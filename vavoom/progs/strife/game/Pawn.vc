//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class Pawn : Actor
	abstract;

state IdleRightState;
state IdleLeftState;
state WalkState;
bool bCkeckNoMonsters;

//==========================================================================
//
//	OnMapSpawn
//
//==========================================================================

void OnMapSpawn(mthing_t *mthing)
{
	if (bCkeckNoMonsters && Level.Game.nomonsters)
	{
		Remove();
		return;
	}
	::OnMapSpawn(mthing);
}

//==========================================================================
//
//	Activate
//
//==========================================================================

bool Activate()
{
	// Monster
	if (bDormant)
	{
		bDormant = false;
		StateTime = 0.1;
		return true;
	}
	return false;
}

//==========================================================================
//
//	Deactivate
//
//==========================================================================

bool Deactivate()
{
	// Monster
	if (!bDormant)
	{
		bDormant = true;
		StateTime = -1.0;
		return true;
	}
	return false;
}

//==========================================================================
//
//  SpawnMissile
//
//==========================================================================

Actor SpawnMissile(Actor dest, classid type)
{
	Actor A;
	TVec dir;

	A = Spawn(type, Origin + vector(0.0, 0.0, 32.0));

	if (A.SightSound)
		A.PlaySound(A.SightSound, CHAN_VOICE);

	A.Instigator = self;	// where it came from

	dir = dest.Origin - Origin;
	// fuzzy player
	if (dest.Translucency)
	{
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
	}
	dir = Normalise(dir);
	A.Velocity = dir * A.Speed;

	VectorAngles(&dir, &A.Angles);

	A.CheckMissileSpawn();

	return A;
}

//==========================================================================
//
//  SpawnMissileZ
//
//==========================================================================

Actor SpawnMissileZ(float z, Actor dest, classid type)
{
	Actor A;
	TVec dir;

	A = Spawn(type, Origin + vector(0.0, 0.0, z));

	if (A.SightSound)
		A.PlaySound(A.SightSound, CHAN_VOICE);

	A.Instigator = self;	// where it came from

	dir = dest.Origin - Origin;
	// fuzzy player
	if (dest.Translucency)
	{
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
	}
	dir = Normalise(dir);
	A.Velocity = dir * A.Speed;

	VectorAngles(&dir, &A.Angles);

	A.CheckMissileSpawn();

	return A;
}

//==========================================================================
//
//  SpawnMissileZAimed
//
//==========================================================================

Actor SpawnMissileZAimed(float z, Actor dest, classid type)
{
	Actor A;
	TVec dir;
	float dist;

	A = Spawn(type, Origin + vector(0.0, 0.0, z));

	if (A.SightSound)
		A.PlaySound(A.SightSound, CHAN_VOICE);

	A.Instigator = self;	// where it came from

	dist = DistTo2(Enemy);
	dir.x = cos(Angles.yaw);
	dir.y = sin(Angles.yaw);
	dir.z = dist != 0.0 ? (dest.Origin.z - Origin.z) / dist : A.Speed;
	// fuzzy player
	if (dest.Translucency)
	{
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
	}
	dir = Normalise(dir);
	A.Velocity = dir * A.Speed;

	VectorAngles(&dir, &A.Angles);

	A.CheckMissileSpawn();

	return A;
}

//==========================================================================
//
//  CheckMeleeRange
//
//==========================================================================

bool CheckMeleeRange()
{
	float dist;

	if (!Enemy)
	{
		return false;
	}

	dist = DistTo(Enemy);

	if (dist >= MELEERANGE - 20.0 + Enemy.Radius)
	{
		return false;
	}

	if (!CanSee(Enemy))
	{
		return false;
	}

	return true;
}

//==========================================================================
//
//  CheckMissileRange
//
//==========================================================================

bool CheckMissileRange()
{
	float dist;

	if (!CanSee(Enemy))
	{
		return false;
	}

	if (bJustHit)
	{
		// the target just hit the enemy,
		// so fight back!
		bJustHit = false;
		return true;
	}

	if (ReactionCount)
	{
		return false;	// do not attack yet
	}

	// OPTIMIZE: get this from a global checksight
	dist = DistTo(Enemy) - 64.0;

	if (!MeleeState)
		dist -= 128.0;	// no melee attack, so fire more

	if (dist > 200.0)
		dist = 200.0;

	if (Random() * 256.0 < dist)
		return false;

	return true;
}

//==========================================================================
//
//  StepMove
//
//  Move in the current direction, returns false if the move is blocked.
//
//==========================================================================

bool StepMove()
{
	float tryx;
	float tryy;

	line_t *ld;
	bool good;

	if (MoveDir == DI_NODIR)
		return false;

#ifdef RANGECHECK
	if (MoveDir >= 8 || MoveDir < 0)
		I_Error("Weird MoveDir!");
#endif

	tryx = Origin.x + StepSpeed * MainGameInfo(Level.Game).xspeed[MoveDir];
	tryy = Origin.y + StepSpeed * MainGameInfo(Level.Game).yspeed[MoveDir];

	if (!TryMove(vector(tryx, tryy, Origin.z)))
	{
		// open any specials
		if (bFloat && Level.Game.tmtrace->bFloatOk)
		{
			// must adjust height
			if (Origin.z < Level.Game.tmtrace->FloorZ)
				Origin.z += FLOATSPEED * Level.Game.frametime;
			else
				Origin.z -= FLOATSPEED * Level.Game.frametime;

			bInFloat = true;
			return true;
		}

		if (!Level.Game.tmtrace->NumSpecHit)
			return false;

		MoveDir = DI_NODIR;
		good = false;
		while (Level.Game.tmtrace->NumSpecHit--)
		{
			ld = Level.Game.tmtrace->SpecHit[Level.Game.tmtrace->NumSpecHit];
			// if the special is not a door
			// that can be opened,
			// return false
			if (StrifeLevelInfo(Level).ActivateLine(ld, self, 0, SPAC_USE))
			{
				good = true;
			}
		}
		return good;
	}
	else
	{
		bInFloat = false;
	}

	if (!bFloat && !bNoGravity)
	{
		Origin.z = FloorZ;
	}
	return true;
}

//==========================================================================
//
//  TryWalk
//
//  Attempts to move actor on in its current (ob->moveangle) direction.
// If blocked by either a wall or an actor returns FALSE
// If move is either clear or blocked only by a door, returns TRUE and sets...
// If a door is in the way, an OpenDoor call is made to start it opening.
//
//==========================================================================

bool TryWalk()
{
	if (!StepMove())
	{
		return false;
	}

	MoveCount = P_Random() & 15;
	return true;
}

//==========================================================================
//
//  NewChaseDir
//
//==========================================================================

void NewChaseDir()
{
	float deltax;
	float deltay;

	int d[3];

	int tdir;
	int olddir;

	int turnaround;

	if (!Enemy)
	{
		Error("P_NewChaseDir: called with no target");
	}

	olddir = MoveDir;
	turnaround = MainGameInfo(Level.Game).opposite[olddir];

	deltax = Enemy.Origin.x - Origin.x;
	deltay = Enemy.Origin.y - Origin.y;

	if (deltax > 10.0)
		d[1] = DI_EAST;
	else if (deltax < -10.0)
		d[1] = DI_WEST;
	else
		d[1] = DI_NODIR;

	if (deltay < -10.0)
		d[2] = DI_SOUTH;
	else if (deltay > 10.0)
		d[2] = DI_NORTH;
	else
		d[2] = DI_NODIR;

	// try direct route
	if (d[1] != DI_NODIR && d[2] != DI_NODIR)
	{
		MoveDir = MainGameInfo(Level.Game).diags[((deltay < 0.0) << 1) + (deltax > 0.0)];
		if (MoveDir != turnaround && TryWalk())
			return;
	}

	// try other directions
	if (P_Random() > 200 || fabs(deltay) > fabs(deltax))
	{
		tdir = d[1];
		d[1] = d[2];
		d[2] = tdir;
	}

	if (d[1] == turnaround)
		d[1] = DI_NODIR;
	if (d[2] == turnaround)
		d[2] = DI_NODIR;

	if (d[1] != DI_NODIR)
	{
		MoveDir = d[1];
		if (TryWalk())
		{
			// either moved forward or attacked
			return;
		}
	}

	if (d[2] != DI_NODIR)
	{
		MoveDir = d[2];

		if (TryWalk())
			return;
	}

	// there is no direct path to the player,
	// so pick another direction.
	if (olddir != DI_NODIR)
	{
		MoveDir = olddir;

		if (TryWalk())
			return;
	}

	// randomly determine direction of search
	if (P_Random() & 1)
	{
		for (tdir = DI_EAST; tdir <= DI_SOUTHEAST; tdir++)
		{
			if (tdir != turnaround)
			{
				MoveDir = tdir;

				if (TryWalk())
					return;
			}
		}
	}
	else
	{
		for (tdir = DI_SOUTHEAST; tdir != (DI_EAST - 1); tdir--)
		{
			if (tdir != turnaround)
			{
				MoveDir = tdir;

				if (TryWalk())
					return;
			}
		}
	}

	if (turnaround != DI_NODIR)
	{
		MoveDir = turnaround;
		if (TryWalk())
			return;
	}

	MoveDir = DI_NODIR;	// can not move
}

//==========================================================================
//
//  RandomChaseDir
//
//==========================================================================

void RandomChaseDir()
{
	int olddir;
	int turnaround;
	int tdir;

	olddir = MoveDir;
	turnaround = MainGameInfo(Level.Game).opposite[olddir];

	if (P_Random() & 1)
	{
		for (tdir = DI_WEST; tdir <= DI_NORTHWEST; tdir++)
		{
			if (tdir != turnaround)
			{
				MoveDir = tdir;

				if (TryWalk())
					return;
			}
		}
	}
	else
	{
		for (tdir = DI_NORTHWEST; tdir >= DI_WEST; tdir--)
		{
			if (tdir != turnaround)
			{
				MoveDir = tdir;

				if (TryWalk())
					return;
			}
		}
	}

	if (turnaround != DI_NODIR)
	{
		MoveDir = turnaround;
		if (TryWalk())
		{
			MoveCount = P_Random() & 15;
			return;
		}
	}

	MoveDir = DI_NODIR;	// can not move
}

//==========================================================================
//
//	CheckRobotRange
//
//==========================================================================

bool CheckRobotRange()
{
	return ReactionCount == 0 && Enemy && !(bFriendly && Enemy.bFriendly) &&
		(DistTo2(Enemy) < ROBOTRANGE - 20.0 + Enemy.Radius) &&
    	CanSee(Enemy);
}

//==========================================================================
//
//	A_Stand
//
//==========================================================================

void A_Stand()
{
	Actor targ;

	Threshold = 0;	// any shot will wake up
	targ = Actor(Sector->SoundTarget);

	if (!bNeutral && targ && targ.bShootable)
	{
		if (bFriendly != targ.bFriendly ||
			!strcmp(ARR2STR(Level.Game.level->mapname), "MAP03") ||
			!strcmp(ARR2STR(Level.Game.level->mapname), "MAP34"))
		{
			Enemy = targ;
			if (!bCountItem || CanSee(targ))
			{
				Threshold = 10;
				SetState(SeeState);
				return;
			}
		}
		else
		{
			if (LookForPlayers(bLookAllAround))
			{
				SetState(SeeState);
				bInCombat = true;
				return;
			}
		}
	}
	if (P_Random() < 30)
	{
		if (!(P_Random() & 1))
			SetState(IdleRightState);
		else
			SetState(IdleLeftState);
	}
	if (!bStanding && P_Random() < 40)
	{
		SetState(WalkState);
	}
}

//==========================================================================
//
//	A_Walk
//
//==========================================================================

void A_Walk()
{
	float delta;

	if (bStanding)
		return;

	if (Threshold != 0)
	{
		Threshold--;
		return;
	}

	// turn towards movement direction if not there yet
	if (MoveDir < DI_NODIR)
	{
		Angles.yaw = itof(ftoi(Angles.yaw / 45.0)) * 45.0;
		delta = AngleMod180(Angles.yaw - itof(MoveDir) * 45.0);

		if (delta > 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw - 45.0);
		}
		else if (delta < 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw + 45.0);
		}
	}

	if (--MoveCount < 0 || !StepMove())
	{
		RandomChaseDir();
		MoveCount += 5;
	}
}

//==========================================================================
//
//  A_Chase
//
//  Actor has a melee attack, so it tries to close as fast as possible
//
//==========================================================================

void A_Chase()
{
	float delta;

	if (ReactionCount)
	{
		ReactionCount--;
	}

	// modify target threshold
	if (Threshold)
	{
		if (!Enemy || Enemy.Health <= 0)
		{
			Threshold = 0;
		}
		else
		{
			Threshold--;
		}
	}

	// turn towards movement direction if not there yet
	if (MoveDir < 8)
	{
		Angles.yaw = itof(ftoi(Angles.yaw / 45.0)) * 45.0;
		delta = AngleMod180(Angles.yaw - itof(MoveDir) * 45.0);

		if (delta > 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw - 45.0);
		}
		else if (delta < 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw + 45.0);
		}
	}

	if (!Enemy || !Enemy.bShootable)
	{
		// look for a new target
		if (LookForPlayers(true))
		{
			return;	// got a new target
		}
		SetState(IdleState);
		return;
	}

	// do not attack twice in a row
	if (bJustAttacked)
	{
		bJustAttacked = false;
		if (!Level.Game.fastparm)
		{
			NewChaseDir();
		}
		return;
	}

	// check for melee attack
	if (MeleeState && CheckMeleeRange())
	{
		if (AttackSound)
		{
			PlaySound(AttackSound, CHAN_WEAPON);
		}
		SetState(MeleeState);
		return;
	}

	// check for missile attack
	if (MissileState)
	{
		if (Level.Game.fastparm || !MoveCount)
		{
			if (CheckMissileRange())
			{
				SetState(MissileState);
				bJustAttacked = true;
				return;
			}
		}
	}

	// possibly choose another target
	if (Level.Game.netgame && !Threshold)
	{
		if (!CanSee(Enemy))
		{
			if (LookForPlayers(true))
				return;	// got a new target
		}
	}

	// chase towards player
	if (--MoveCount < 0 || !StepMove())
	{
		NewChaseDir();
	}

	// make active sound
	if (ActiveSound && P_Random() < 3)
	{
		PlaySound(ActiveSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//  A_FaceTarget
//
//==========================================================================

void A_FaceTarget()
{
	if (!Enemy)
		return;

	Angles.yaw = atan2(Enemy.Origin.y - Origin.y,
		Enemy.Origin.x - Origin.x);

	if (Enemy.Translucency)
	{
		Angles.yaw = AngleMod360(Angles.yaw + (Random() - Random()) * 45.0);
	}
}

//==========================================================================
//
//  A_XScream
//
//  Explode death sound.
//
//==========================================================================

void A_XScream()
{
	if (bNoBlood && DeathSound)
	{
		PlaySound(DeathSound, CHAN_VOICE);
	}
	else
	{
		PlaySound('misc/gibbed', CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_RiffleAttack
//
//==========================================================================

void A_RiffleAttack()
{
	int damage;
	TVec dir;

	if (!Enemy)
		return;

	PlaySound('monsters/rifle', CHAN_WEAPON);
	A_FaceTarget();
	dir = AimLineAttack(Angles, MISSILERANGE);
	VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
	damage = ((P_Random() % 5) + 1) * 3;
	LineAttack(dir, MISSILERANGE, damage, Puff);
}

//==========================================================================
//
//	A_CheckRefire
//
//==========================================================================

void A_CheckRefire()
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 30)
		return;

	if (!Enemy || Enemy.Health <= 0 || !CanSee(Enemy) || P_Random() < 40)
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//	A_Dying
//
//==========================================================================

void A_Dying()
{
	bInCombat = true;
	if ((P_Random() % 5) == 0)
	{
		PlaySound(PainSound, CHAN_VOICE);
		Health--;
	}
	if (Health <= 0)
	{
		Died(Enemy);
	}
}

//==========================================================================
//
//	A_RobotMelee
//
//==========================================================================

void A_RobotMelee()
{
	int damage;

	if (!Enemy)
		return;

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		PlaySound('reaver/blade', CHAN_WEAPON);
		damage = ((P_Random() % 8) + 1) * 3;
		Enemy.Damage(self, self, damage);
	}
}

//==========================================================================
//
//	A_RobotMissile
//
//==========================================================================

void A_RobotMissile()
{
	int i;
	int damage;
	TVec aimDir;
	TVec dir;

	if (!Enemy)
		return;

	A_FaceTarget();
	PlaySound('reaver/attack', CHAN_WEAPON);
	aimDir = AimLineAttack(Angles, MISSILERANGE);
	for (i = 0; i < 3; i++)
	{
		dir = aimDir;
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
		damage = ((P_Random() % 8) + 1) * 3;
		LineAttack(dir, MISSILERANGE, damage, Puff);
	}
}

//==========================================================================
//
//	A_FlightChase
//
//==========================================================================

void A_FlightChase()
{
	float minz, maxz;

	if (Threshold || bInFloat)
		return;

	maxz = CeilingZ - Height - 16.0;
	minz = FloorZ + 96.0;
	if (minz > maxz)
	{
		minz = maxz;
	}
	if (minz < Origin.z)
	{
		Velocity.z -= 1.0 * 35.0;
	}
	else
	{
		Velocity.z += 1.0 * 35.0;
	}
	ReactionCount = (minz >= Origin.z) ? 4 : 0;
}

//==========================================================================
//
//	A_BurnScream
//
//==========================================================================

void A_BurnScream()
{
	DeathSound = 'human/imonfire';
	A_Scream();
}

//==========================================================================
//
//	A_Burn
//
//==========================================================================

void A_Burn()
{
	Actor A = Spawn(FireFoot, Origin + vector(0.0, 0.0, 24.0));
	A.Velocity.z = -35.0;
	RadiusAttack(64, 64, false);
}

//==========================================================================
//
//	A_BossDeath
//
//	This most likely is boss death.
//
//==========================================================================

void A_BossDeath()
{
	int i;
	Actor Other;
	int VoiceNum;

	// make sure there is a player alive for victory
	for (i = 0; i < MAXPLAYERS; i++)
		if (Level.Game.Players[i] && Level.Game.Players[i].bSpawned && Level.Game.Players[i].Health > 0)
			break;

	if (i == MAXPLAYERS)
		return;	// no one left alive, so do not end game

	// scan the remaining thinkers to see if all bosses are dead
	FOREACH(Actor, Other)
	{
		if (Other != self && Other.Class == Class && Other.Health > 0)
		{
			// other boss not dead
			return;
		}
	}

	// victory!
	if (Class == Crusader)
	{
		A_Fall();
		StrifeLevelInfo(Level).EV_DoFloor(667, 8, 0, 0, 0, FLOOREV_LowerToLowest, NULL);
	}
	else if (Class == Inquisitor)
	{
		//	It's also called by inquisitors. What he does?
	}
	else if (Class == Programmer)
	{
		//	Call death script.
		StartACS(250, 0, 0, 0, 0, self, NULL, 0, false, false);
	}
	else if (Class == Specter1)
	{
		//	Specter in ruined temple.
		StrifeLevelInfo(Level).EV_DoFloor(999, 8, 0, 0, 0, FLOOREV_LowerToLowest, NULL);
		Player(Enemy.Player).SetObjectives(95);
		MSG_Select(MSG_SV_RELIABLE);
		MSG_WriteByte(StrifeDefs::svc_voice);
		MSG_WriteShort(95);
	}
	else if (Class == Specter2)
	{
		//	Bishop's specter
		if (!Enemy)
			return;

		Player(Enemy.Player).GiveSigilPiece();
		Player(Enemy.Player).GiveQuest(QUEST_KilledBishop);
		Player(Enemy.Player).SetObjectives(74);
		MSG_Select(MSG_SV_RELIABLE);
		MSG_WriteByte(StrifeDefs::svc_voice);
		MSG_WriteShort(74);
	}
	else if (Class == Specter3)
	{
		//	Oracle's specter
		if (!Enemy)
			return;

		Player(Enemy.Player).GiveSigilPiece();
		Player(Enemy.Player).GiveQuest(QUEST_KilledOracle);
		if (Player(Enemy.Player).Quests & (1 << QUEST_KilledBishop))
		{
			//	If the Bishop is dead, set quest item 22
			Player(Enemy.Player).GiveQuest(QUEST_KillMacil);
		}
		if (Player(Enemy.Player).Quests & (1 << QUEST_KilledLoremaster))
		{
			Player(Enemy.Player).SetObjectives(85);
			MSG_Select(MSG_SV_RELIABLE);
			MSG_WriteByte(StrifeDefs::svc_voice);
			MSG_WriteShort(85);
		}
		else
		{
			Player(Enemy.Player).SetObjectives(87);
			MSG_Select(MSG_SV_RELIABLE);
			MSG_WriteByte(StrifeDefs::svc_voice);
			MSG_WriteShort(87);
		}
		Level.ExecuteActionSpecial(LNSPEC_DoorOpen, 222, 256, 0, 0, 0, NULL, 0, none);
	}
	else if (Class == Specter4)
	{
		//	Macil's specter
		if (!Enemy)
			return;

		Player(Enemy.Player).GiveSigilPiece();
		Player(Enemy.Player).GiveQuest(QUEST_KilledMacil);
		if (Player(Enemy.Player).Quests & (1 << QUEST_Factory))
		{
			Player(Enemy.Player).SetObjectives(106);
			MSG_Select(MSG_SV_RELIABLE);
			MSG_WriteByte(StrifeDefs::svc_voice);
			MSG_WriteShort(106);
		}
		else
		{
			Player(Enemy.Player).SetObjectives(79);
			MSG_Select(MSG_SV_RELIABLE);
			MSG_WriteByte(StrifeDefs::svc_voice);
			MSG_WriteShort(79);
		}
	}
	else if (Class == Specter5)
	{
		//	Loremaster's specter
		if (!Enemy)
			return;

		Player(Enemy.Player).GiveSigilPiece();
		Player(Enemy.Player).GiveQuest(QUEST_KilledLoremaster);
		Player(Enemy.Player).Accuracy += 10;
		Player(Enemy.Player).Stamina += 10;
		Player(Enemy.Player).GiveBody(200);
		if (Player(Enemy.Player).Sigil == 4)
		{
			Player(Enemy.Player).SetObjectives(85);
			MSG_Select(MSG_SV_RELIABLE);
			MSG_WriteByte(StrifeDefs::svc_voice);
			MSG_WriteShort(85);
		}
		else
		{
			Player(Enemy.Player).SetObjectives(83);
			MSG_Select(MSG_SV_RELIABLE);
			MSG_WriteByte(StrifeDefs::svc_voice);
			MSG_WriteShort(83);
		}
		StrifeLevelInfo(Level).EV_DoFloor(666, 8, 0, 0, 0, FLOOREV_LowerToLowest, NULL);
	}
	else if (Class == SubEntity)
	{
		if (!Enemy)
			return;

		if (Player(Enemy.Player).Quests & (1 << QUEST_Factory))
		{
			MSG_Select(MSG_SV_RELIABLE);
			MSG_WriteByte(StrifeDefs::svc_finale_type);
			MSG_WriteByte(0);
		}
		else
		{
			MSG_Select(MSG_SV_RELIABLE);
			MSG_WriteByte(StrifeDefs::svc_finale_type);
			MSG_WriteByte(2);
		}
		G_Completed(-1, -1, 0);
	}
}

//==========================================================================
//
//	A_SpecterMelee
//
//==========================================================================

void A_SpecterMelee()
{
	if (!Enemy)
		return;

	A_FaceTarget();

	if (CheckMeleeRange())
	{
		Enemy.Damage(self, self, ((P_Random() % 10) + 1) * 12);
	}
}

//==========================================================================
//
//	A_SpecterAttack
//
//	Used by Specter1 and Programmer.
//
//==========================================================================

void A_SpecterAttack()
{
	Actor		A;

	if (!Enemy)
		return;

	A_FaceTarget();

	A = Spawn(SigilFloor, Enemy.Origin);
	A.Origin.z = A.FloorZ;
	A.Velocity = vector(0.0, 0.0, 0.0);
	A.Instigator = self;
	if (A.SightSound)
	{
		A.PlaySound(A.SightSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_Specter2Attack
//
//==========================================================================

void A_Specter2Attack()
{
	Actor A;

	if (!Enemy)
		return;

	A_FaceTarget();

	A = SpawnMissile(Enemy, SigilFX1);
	A.bSpectral = false;
}

//==========================================================================
//
//	A_Specter3Attack
//
//==========================================================================

void A_Specter3Attack()
{
	Actor spread;
	int i;

	if (!Enemy)
		return;

	A_FaceTarget();

	for (i = 0; i < 20; i++)
	{
		spread = SpawnMissile(Enemy, SpecterFX2);
		spread.bSpectral = false;
		spread.Angles.yaw = AngleMod360(spread.Angles.yaw - 90.0 + itof(i) * (45.0 / 4.0));
		spread.Velocity.x = spread.Speed * cos(spread.Angles.yaw);
		spread.Velocity.y = spread.Speed * sin(spread.Angles.yaw);
	}

	spread = Spawn(SigilFX4, Origin + vector(0.0, 0.0, -Height));
	spread.bNoGravity = false;
	spread.bSpectral = false;
	spread.Instigator = self;
	spread.Velocity.x = 0.001;
	spread.Velocity.y = 0.001;
	spread.CheckMissileSpawn();
}

//==========================================================================
//
//	A_Specter4Attack
//
//==========================================================================

void A_Specter4Attack()
{
	Actor A;

	if (!Enemy)
		return;

	A_FaceTarget();

	A = SpawnMissile(Enemy, SpecterFX5);
	A.bSpectral = false;
}

//==========================================================================
//
//	A_Specter5Attack
//
//==========================================================================

void A_Specter5Attack()
{
	Actor A;

	if (!Enemy)
		return;

	A_FaceTarget();

	A = SpawnMissile(Enemy, SpecterFX3);
	A.bSpectral = false;
}

//==========================================================================
//
//	A_SpecterTossChunk
//
//==========================================================================

void A_SpecterTossChunk()
{
	TossUpObject(SpecterChunk);
}

//==========================================================================
//
//	A_SpecterTossHead
//
//==========================================================================

void A_SpecterTossHead()
{
	TossUpObject(SpecterHead);
}

__states__
{
	S_BURN1('BURN', 0, 3.0 / 35.0, S_BURN2) { A_BurnScream(); }
	S_BURN2('BURN', 1, 3.0 / 35.0, S_BURN3) { A_Burn(); }
	S_BURN3('BURN', 2, 3.0 / 35.0, S_BURN4) { A_Walk(); }
	S_BURN4('BURN', 3, 3.0 / 35.0, S_BURN5) { A_Fall(); }
	S_BURN5('BURN', 4, 5.0 / 35.0, S_BURN6) { A_Burn(); }
	S_BURN6('BURN', 5, 5.0 / 35.0, S_BURN7) { A_Walk(); }
	S_BURN7('BURN', 6, 5.0 / 35.0, S_BURN8) { A_Walk(); }
	S_BURN8('BURN', 7, 5.0 / 35.0, S_BURN9) { A_Walk(); }
	S_BURN9('BURN', 8, 5.0 / 35.0, S_BURN10) { A_Burn(); }
	S_BURN10('BURN', 9, 5.0 / 35.0, S_BURN11) { A_Walk(); }
	S_BURN11('BURN', 10, 5.0 / 35.0, S_BURN12) { A_Walk(); }
	S_BURN12('BURN', 11, 5.0 / 35.0, S_BURN13) { A_Walk(); }
	S_BURN13('BURN', 12, 3.0 / 35.0, S_BURN14) { A_Burn(); }
	S_BURN14('BURN', 13, 3.0 / 35.0, S_BURN15) { }
	S_BURN15('BURN', 14, 5.0 / 35.0, S_BURN16) { }
	S_BURN16('BURN', 15, 5.0 / 35.0, S_BURN17) { }
	S_BURN17('BURN', 16, 5.0 / 35.0, S_BURN18) { }
	S_BURN18('BURN', 15, 5.0 / 35.0, S_BURN19) { }
	S_BURN19('BURN', 16, 5.0 / 35.0, S_BURN20) { }
	S_BURN20('BURN', 17, 7.0 / 35.0, S_BURN21) { }
	S_BURN21('BURN', 18, 7.0 / 35.0, S_BURN22) { }
	S_BURN22('BURN', 19, 7.0 / 35.0, S_BURN23) { }
	S_BURN23('BURN', 20, 7.0 / 35.0, S_BURN24) { }
	S_BURN24('BURN', 21, 700.0 / 35.0, none) { /*FIXME A_Dying();*/ }

	S_DISRUPT1('DISR', 0, 5.0 / 35.0, S_DISRUPT2) { }
	S_DISRUPT2('DISR', 1, 5.0 / 35.0, S_DISRUPT3) { }
	S_DISRUPT3('DISR', 2, 5.0 / 35.0, S_DISRUPT4) { }
	S_DISRUPT4('DISR', 3, 5.0 / 35.0, S_DISRUPT5) { A_Fall(); }
	S_DISRUPT5('DISR', 4, 5.0 / 35.0, S_DISRUPT6) { }
	S_DISRUPT6('DISR', 5, 5.0 / 35.0, S_DISRUPT7) { }
	S_DISRUPT7('DISR', 6, 4.0 / 35.0, S_DISRUPT8) { }
	S_DISRUPT8('DISR', 7, 4.0 / 35.0, S_DISRUPT9) { }
	S_DISRUPT9('DISR', 8, 4.0 / 35.0, S_DISRUPT10) { }
	S_DISRUPT10('DISR', 9, 4.0 / 35.0, S_DISRUPT11) { }
	S_DISRUPT11('MEAT', 3, 700.0 / 35.0, none) { }
}

defaultproperties
{
	Health = 0;
	Radius = 0.0;
	Height = 0.0;
	Mass = 0.0;
	bSolid = true;
	bShootable = true;
	bCountKill = true;
	bCkeckNoMonsters = true;
	bActivateMCross = true;
	bActivatePushWall = true;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.24  2006/04/06 11:48:52  dj_jl
//  Fixed several bugs.
//
//  Revision 1.23  2006/03/28 15:04:53  firebrand_kh
//  Fixes for Inquisitor decide method
//
//  Revision 1.22  2006/03/12 20:01:24  dj_jl
//  States as objects, added state variable type.
//
//  Revision 1.21  2006/03/02 18:36:30  dj_jl
//  Don't use game specific classes in common.
//
//  Revision 1.20  2006/02/17 19:06:53  dj_jl
//  Moved common defs to classes.
//
//  Revision 1.19  2006/02/15 23:34:27  dj_jl
//  Moved all server progs global variables to classes.
//
//  Revision 1.18  2006/02/05 18:50:55  dj_jl
//  Moved common utils to level info class or built-in.
//
//  Revision 1.17  2006/01/10 19:54:01  dj_jl
//  Many bug fixes.
//
//  Revision 1.16  2005/12/27 22:22:28  dj_jl
//  Created level info class, moved action special handling to it.
//
//  Revision 1.15  2005/12/25 17:13:08  dj_jl
//  Some fixes.
//
//  Revision 1.14  2005/12/11 21:31:40  dj_jl
//  Made path traversal callbacks class members.
//
//  Revision 1.13  2005/11/19 13:43:51  dj_jl
//  Renamed sounds.
//
//  Revision 1.12  2005/04/04 07:36:37  dj_jl
//  Several fixes of quests.
//
//  Revision 1.11  2005/03/28 07:45:29  dj_jl
//  Some Boom line specials, fixed multiple bugs.
//
//  Revision 1.10  2005/03/16 15:04:42  dj_jl
//  More work on line specials.
//
//  Revision 1.9  2005/03/01 14:39:33  dj_jl
//  Big update of line specials.
//
//  Revision 1.8  2005/01/25 17:45:17  dj_jl
//  Constants for common line specials
//  Updated special utilites.
//
//  Revision 1.7  2004/12/27 12:23:14  dj_jl
//  Multiple small changes for version 1.16
//
//  Revision 1.6  2004/12/22 07:56:47  dj_jl
//  Fully working Strife support.
//
//  Revision 1.5  2004/11/01 07:38:23  dj_jl
//  Almost all Hexen line specials are available in all games.
//
//  Revision 1.4  2004/10/18 06:35:21  dj_jl
//  Implemented many monsters, sigil and some more.
//
//  Revision 1.3  2004/10/14 06:22:38  dj_jl
//  Implemented several objects amd monsters.
//
//  Revision 1.2  2004/01/30 17:45:33  dj_jl
//  Implemented many action functions.
//
//  Revision 1.1  2002/11/02 08:20:56  dj_jl
//  New style classes.
//
//**************************************************************************
