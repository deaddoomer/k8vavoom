//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class Pawn : Actor
	abstract;

//==========================================================================
//
//	CheckRobotRange
//
//==========================================================================

bool CheckRobotRange()
{
	return ReactionCount == 0 && Target && !(bFriendly && Actor(Target).bFriendly) &&
		(DistTo2(Target) < ROBOTRANGE - 20.0 + Target.Radius) &&
    	CanSee(Target);
}

//==========================================================================
//
//	A_RiffleAttack
//
//==========================================================================

final void A_RiffleAttack()
{
	int damage;
	TVec dir;

	if (!Target)
		return;

	PlaySound('monsters/rifle', CHAN_WEAPON);
	A_FaceTarget();
	AimLineAttack(dir, Angles, MISSILERANGE);
	VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
	damage = ((P_Random() % 5) + 1) * 3;
	LineAttack(dir, MISSILERANGE, damage, StrifePuff);
	bMuzzleFlash = true;
}

//==========================================================================
//
//	A_CheckRefire
//
//==========================================================================

final void A_CheckRefire()
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 30)
		return;

	if (!Target || Target.Health <= 0 || !CanSee(Target) || P_Random() < 40)
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//	A_Dying
//
//==========================================================================

final void A_Dying()
{
	bInCombat = true;
	if ((P_Random() % 5) == 0)
	{
		PlaySound(PainSound, CHAN_VOICE);
		Health--;
	}
	if (Health <= 0)
	{
		Died(Target, none);
	}
}

//==========================================================================
//
//	A_RobotMelee
//
//==========================================================================

final void A_RobotMelee()
{
	int damage;

	if (!Target)
		return;

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		PlaySound('reaver/blade', CHAN_WEAPON);
		damage = ((P_Random() % 8) + 1) * 3;
		Target.Damage(self, self, damage);
	}
}

//==========================================================================
//
//	A_RobotMissile
//
//==========================================================================

final void A_RobotMissile()
{
	int i;
	int damage;
	TVec aimDir;
	TVec dir;

	if (!Target)
		return;

	A_FaceTarget();
	PlaySound('reaver/attack', CHAN_WEAPON);
	AimLineAttack(aimDir, Angles, MISSILERANGE);
	for (i = 0; i < 3; i++)
	{
		dir = aimDir;
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
		damage = ((P_Random() % 8) + 1) * 3;
		LineAttack(dir, MISSILERANGE, damage, StrifePuff);
	}
	bMuzzleFlash = true;
}

//==========================================================================
//
//	A_FlightChase
//
//==========================================================================

final void A_FlightChase()
{
	float minz, maxz;

	if (bInFloat)
	{
		Velocity.z = 0.0;
		return;
	}

	if (Threshold)
		return;

	maxz = CeilingZ - Height - 16.0;
	minz = FloorZ + 96.0;
	if (minz > maxz)
	{
		minz = maxz;
	}

	if(TestMobjZ())
	{
		if (minz < Origin.z)
		{
			Velocity.z -= 1.0 * 35.0;
		}
		else
		{
			Velocity.z += 1.0 * 35.0;
		}
	}
	else
	{
		Velocity.z = 0.0;
		return;
	}
	ReactionCount = (minz >= Origin.z) ? 4 : 0;
}

//==========================================================================
//
//	A_BurnScream
//
//==========================================================================

final void A_BurnScream()
{
	DeathSound = 'human/imonfire';
	A_Scream();
	if (bIsPlayer)
	{
		Player.SetViewState(ps_weapon,
			StrifeWeapon(Player.ViewEnt).FireDeathWaveState);
		Player.SetViewState(ps_flash, none);
	}
}

//==========================================================================
//
//	A_Burn
//
//==========================================================================

final void A_Burn()
{
	Actor A = Spawn(FireDroplet, Origin + vector(0.0, 0.0, 24.0));
	A.Velocity.z = -35.0;
	RadiusAttack(Target, 64, 64.0, false);
}

//==========================================================================
//
//	A_BossDeath
//
//	This most likely is boss death.
//
//==========================================================================

final void A_BossDeath()
{
	int i;
	Actor Other;
	int VoiceNum;

	// make sure there is a player alive for victory
	for (i = 0; i < MAXPLAYERS; i++)
		if (Level.Game.Players[i] && Level.Game.Players[i].bSpawned && Level.Game.Players[i].Health > 0)
			break;

	if (i == MAXPLAYERS)
		return;	// no one left alive, so do not end game

	// scan the remaining thinkers to see if all bosses are dead
	foreach AllThinkers(Actor, Other)
	{
		if (Other != self && Other.Class == Class && Other.Health > 0)
		{
			// other boss not dead
			return;
		}
	}

	// victory!
	if (Class == Crusader)
	{
		A_Fall();
		StrifeLevelInfo(Level).EV_DoFloor(667, 8, 0, 0, 0,
			FloorMover::FLOOREV_LowerToLowest, NULL);
	}
	else if (Class == Inquisitor)
	{
		//	It's also called by inquisitors. What he does?
	}
	else if (Class == Programmer)
	{
		//	Call death script.
		XLevel.StartACS(250, 0, 0, 0, 0, self, NULL, 0, false, false);
	}
	else if (Class == AlienSpectre1)
	{
		//	Specter in ruined temple.
		StrifeLevelInfo(Level).EV_DoFloor(999, 8, 0, 0, 0,
			FloorMover::FLOOREV_LowerToLowest, NULL);
		Player(Target.Player).SetObjectives(95);
		Player(Target.Player).ClientVoice(95);
	}
	else if (Class == AlienSpectre2)
	{
		//	Bishop's specter
		if (!Target)
			return;

		Target.Player.cprint("$txt_killed_bishop");
		Target.GiveInventoryType(QuestItem21);
		Player(Target.Player).SetObjectives(74);
		Player(Target.Player).ClientVoice(74);
	}
	else if (Class == AlienSpectre3)
	{
		//	Oracle's specter
		if (!Target)
			return;

		Target.Player.cprint("$txt_killed_oracle");
		Target.GiveInventoryType(QuestItem23);
		if (Target.FindInventory(QuestItem21))
		{
			//	If the Bishop is dead, set quest item 22
			Target.GiveInventoryType(QuestItem22);
		}
		if (Target.FindInventory(QuestItem24))
		{
			Player(Target.Player).SetObjectives(85);
			Player(Target.Player).ClientVoice(85);
		}
		else
		{
			Player(Target.Player).SetObjectives(87);
			Player(Target.Player).ClientVoice(87);
		}
		Level.ExecuteActionSpecial(LNSPEC_DoorOpen, 222, 256, 0, 0, 0, NULL, 0, none);
	}
	else if (Class == AlienSpectre4)
	{
		//	Macil's specter
		if (!Target)
			return;

		Target.Player.cprint("$txt_killed_macil");
		Target.GiveInventoryType(QuestItem24);
		if (Target.FindInventory(QuestItem25))
		{
			Player(Target.Player).SetObjectives(106);
			Player(Target.Player).ClientVoice(106);
		}
		else
		{
			Player(Target.Player).SetObjectives(79);
			Player(Target.Player).ClientVoice(79);
		}
	}
	else if (Class == AlienSpectre5)
	{
		//	Loremaster's specter
		if (!Target)
			return;

		Target.Player.cprint("$txt_killed_loremaster");
		Target.GiveInventoryType(QuestItem26);
		Target.GiveInventoryType(UpgradeAccuracy);
		Target.GiveInventoryType(UpgradeStamina);
		if (GetSigilPieces() == 5)
		{
			Player(Target.Player).SetObjectives(85);
			Player(Target.Player).ClientVoice(85);
		}
		else
		{
			Player(Target.Player).SetObjectives(83);
			Player(Target.Player).ClientVoice(83);
		}
		StrifeLevelInfo(Level).EV_DoFloor(666, 8, 0, 0, 0,
			FloorMover::FLOOREV_LowerToLowest, NULL);
	}
	else if (Class == EntitySecond)
	{
		if (!Target)
			return;

		if (Target.FindInventory(QuestItem25))
		{
			Player(Target.Player).ClientFinaleType(0);
		}
		else
		{
			Player(Target.Player).ClientFinaleType(2);
		}
		Level.Completed(-1, -1, 0);
	}
}

//==========================================================================
//
//	A_SpecterMelee
//
//==========================================================================

final void A_SpecterMelee()
{
	if (!Target)
		return;

	A_FaceTarget();

	if (CheckMeleeRange())
	{
		Target.Damage(self, self, ((P_Random() % 10) + 1) * 12);
	}
}

//==========================================================================
//
//	A_SpecterAttack
//
//	Used by Specter1 and Programmer.
//
//==========================================================================

final void A_SpecterAttack()
{
	Actor		A;

	if (!Target)
		return;

	A_FaceTarget();

	A = Spawn(SpectralLightningSpot, Target.Origin);
	A.Origin.z = A.FloorZ;
	A.Velocity = vector(0.0, 0.0, 0.0);
	A.Target = self;
	if (A.SightSound)
	{
		A.PlaySound(A.SightSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_Specter2Attack
//
//==========================================================================

final void A_Specter2Attack()
{
	EntityEx A;

	if (!Target)
		return;

	A_FaceTarget();

	A = SpawnMissile(Target, SpectralLightningH2);
	if (A)
	{
		A.bSpectral = false;
	}
}

//==========================================================================
//
//	A_Specter3Attack
//
//==========================================================================

final void A_Specter3Attack()
{
	EntityEx spread;
	int i;

	if (!Target)
		return;

	A_FaceTarget();

	for (i = 0; i < 20; i++)
	{
		spread = SpawnMissile(Target, SpectralLightningBall2);
		if (spread)
		{
			spread.bSpectral = false;
			spread.Angles.yaw = AngleMod360(spread.Angles.yaw - 90.0 + itof(i) * (45.0 / 4.0));
			spread.Velocity.x = spread.Speed * cos(spread.Angles.yaw);
			spread.Velocity.y = spread.Speed * sin(spread.Angles.yaw);
		}
	}

	spread = Spawn(SpectralLightningV1, Origin + vector(0.0, 0.0, -Height));
	spread.bNoGravity = false;
	spread.bSpectral = false;
	spread.Target = self;
	spread.Velocity.x = 0.001;
	spread.Velocity.y = 0.001;
	spread.CheckMissileSpawn();
}

//==========================================================================
//
//	A_Specter4Attack
//
//==========================================================================

final void A_Specter4Attack()
{
	EntityEx A;

	if (!Target)
		return;

	A_FaceTarget();

	A = SpawnMissile(Target, SpectralLightningBigV2);
	if (A)
	{
		A.bSpectral = false;
	}
}

//==========================================================================
//
//	A_Specter5Attack
//
//==========================================================================

final void A_Specter5Attack()
{
	EntityEx A;

	if (!Target)
		return;

	A_FaceTarget();

	A = SpawnMissile(Target, SpectralLightningBigBall2);
	if (A)
	{
		A.bSpectral = false;
	}
}

//==========================================================================
//
//	A_SpecterTossChunk
//
//==========================================================================

final void A_SpecterTossChunk()
{
	TossUpObject(AlienChunkSmall);
}

//==========================================================================
//
//	A_SpecterTossHead
//
//==========================================================================

final void A_SpecterTossHead()
{
	TossUpObject(AlienChunkLarge);
}

__states__
{
	S_BURN1('BURN', 0, 3.0 / 35.0, S_BURN2) = A_BurnScream
	S_BURN2('BURN', 1, 3.0 / 35.0, S_BURN3) = A_Burn
	S_BURN3('BURN', 2, 3.0 / 35.0, S_BURN4) = A_Walk
	S_BURN4('BURN', 3, 3.0 / 35.0, S_BURN5) = A_Fall
	S_BURN5('BURN', 4, 5.0 / 35.0, S_BURN6) = A_Burn
	S_BURN6('BURN', 5, 5.0 / 35.0, S_BURN7) = A_Walk
	S_BURN7('BURN', 6, 5.0 / 35.0, S_BURN8) = A_Walk
	S_BURN8('BURN', 7, 5.0 / 35.0, S_BURN9) = A_Walk
	S_BURN9('BURN', 8, 5.0 / 35.0, S_BURN10) = A_Burn
	S_BURN10('BURN', 9, 5.0 / 35.0, S_BURN11) = A_Walk
	S_BURN11('BURN', 10, 5.0 / 35.0, S_BURN12) = A_Walk
	S_BURN12('BURN', 11, 5.0 / 35.0, S_BURN13) = A_Walk
	S_BURN13('BURN', 12, 3.0 / 35.0, S_BURN14) = A_Burn
	S_BURN14('BURN', 13, 3.0 / 35.0, S_BURN15) = none
	S_BURN15('BURN', 14, 5.0 / 35.0, S_BURN16) = none
	S_BURN16('BURN', 15, 5.0 / 35.0, S_BURN17) = none
	S_BURN17('BURN', 16, 5.0 / 35.0, S_BURN18) = none
	S_BURN18('BURN', 15, 5.0 / 35.0, S_BURN19) = none
	S_BURN19('BURN', 16, 5.0 / 35.0, S_BURN20) = none
	S_BURN20('BURN', 17, 7.0 / 35.0, S_BURN21) = none
	S_BURN21('BURN', 18, 7.0 / 35.0, S_BURN22) = none
	S_BURN22('BURN', 19, 7.0 / 35.0, S_BURN23) = none
	S_BURN23('BURN', 20, 7.0 / 35.0, S_BURN24) = none
	S_BURN24('BURN', 21, 700.0 / 35.0, none) { /*FIXME A_Dying();*/ }

	S_DISRUPT1('DISR', 0, 5.0 / 35.0, S_DISRUPT2)
	{
		PlaySound('human/disrupt', CHAN_BODY);
	}
	S_DISRUPT2('DISR', 1, 5.0 / 35.0, S_DISRUPT3) = none
	S_DISRUPT3('DISR', 2, 5.0 / 35.0, S_DISRUPT4) = none
	S_DISRUPT4('DISR', 3, 5.0 / 35.0, S_DISRUPT5) = A_Fall
	S_DISRUPT5('DISR', 4, 5.0 / 35.0, S_DISRUPT6) = none
	S_DISRUPT6('DISR', 5, 5.0 / 35.0, S_DISRUPT7) = none
	S_DISRUPT7('DISR', 6, 4.0 / 35.0, S_DISRUPT8) = none
	S_DISRUPT8('DISR', 7, 4.0 / 35.0, S_DISRUPT9) = none
	S_DISRUPT9('DISR', 8, 4.0 / 35.0, S_DISRUPT10) = none
	S_DISRUPT10('DISR', 9, 4.0 / 35.0, S_DISRUPT11) = none
	S_DISRUPT11('MEAT', 3, 700.0 / 35.0, none) = none
}

defaultproperties
{
	Health = 0;
	Radius = 0.0;
	Height = 0.0;
	Mass = 0.0;
	bSolid = true;
	bShootable = true;
	bCountKill = true;
	bMonster = true;
	bActivateMCross = true;
	bActivatePushWall = true;
	bFloorClip = true;
}
