//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class Pawn : Actor
	abstract;

//==========================================================================
//
//	CheckRobotRange
//
//==========================================================================

bool CheckRobotRange()
{
	return ReactionCount == 0 && Target && !(bFriendly && Actor(Target).bFriendly) &&
		(DistTo2(Target) < ROBOTRANGE - 20.0 + Target.Radius) &&
    	CanSee(Target);
}

//==========================================================================
//
//	A_RiffleAttack
//
//==========================================================================

final void A_RiffleAttack()
{
	int damage;
	TVec dir;

	if (!Target)
		return;

	PlaySound('monsters/rifle', CHAN_WEAPON);
	A_FaceTarget();
	AimLineAttack(dir, Angles, MISSILERANGE);
	VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
	damage = ((P_Random() % 5) + 1) * 3;
	LineAttack(dir, MISSILERANGE, damage, StrifePuff);
	bMuzzleFlash = true;
}

//==========================================================================
//
//	A_CheckRefire
//
//==========================================================================

final void A_CheckRefire()
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 30)
		return;

	if (!Target || Target.Health <= 0 || !CanSee(Target) || P_Random() < 40)
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//	A_Dying
//
//==========================================================================

final void A_Dying()
{
	bInCombat = true;
	if ((P_Random() % 5) == 0)
	{
		PlaySound(PainSound, CHAN_VOICE);
		Health--;
	}
	if (Health <= 0)
	{
		Died(Target, none);
	}
}

//==========================================================================
//
//	A_RobotMelee
//
//==========================================================================

final void A_RobotMelee()
{
	int damage;

	if (!Target)
		return;

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		PlaySound('reaver/blade', CHAN_WEAPON);
		damage = ((P_Random() % 8) + 1) * 3;
		Target.Damage(self, self, damage);
	}
}

//==========================================================================
//
//	A_RobotMissile
//
//==========================================================================

final void A_RobotMissile()
{
	int i;
	int damage;
	TVec aimDir;
	TVec dir;

	if (!Target)
		return;

	A_FaceTarget();
	PlaySound('reaver/attack', CHAN_WEAPON);
	AimLineAttack(aimDir, Angles, MISSILERANGE);
	for (i = 0; i < 3; i++)
	{
		dir = aimDir;
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
		damage = ((P_Random() % 8) + 1) * 3;
		LineAttack(dir, MISSILERANGE, damage, StrifePuff);
	}
	bMuzzleFlash = true;
}

//==========================================================================
//
//	A_FlightChase
//
//==========================================================================

final void A_FlightChase()
{
	float minz, maxz;

	if (bInFloat)
	{
		Velocity.z = 0.0;
		return;
	}

	if (Threshold)
		return;

	maxz = CeilingZ - Height - 16.0;
	minz = FloorZ + 96.0;
	if (minz > maxz)
	{
		minz = maxz;
	}

	if (minz < Origin.z)
	{
		Velocity.z -= 1.0 * 35.0;
	}
	else
	{
		Velocity.z += 1.0 * 35.0;
	}
	ReactionCount = (minz >= Origin.z) ? 4 : 0;
}

//==========================================================================
//
//	A_BurnScream
//
//==========================================================================

final void A_BurnScream()
{
	DeathSound = 'human/imonfire';
	A_Scream();
	if (bIsPlayer)
	{
		Player.SetViewState(ps_weapon,
			PlayerEx(Player).ReadyWeapon.FindState('BurnWave'));
		Player.SetViewState(ps_flash, none);
	}
}

//==========================================================================
//
//	A_Burn
//
//==========================================================================

final void A_Burn()
{
	bMuzzleFlash = true;
	Actor A = Spawn(FireDroplet, Origin + vector(0.0, 0.0, 24.0));
	A.Velocity.z = -35.0;
	RadiusAttack(Target, 64, 64.0, false);
}

//==========================================================================
//
//	A_SpecterMelee
//
//==========================================================================

final void A_SpecterMelee()
{
	if (!Target)
		return;

	A_FaceTarget();

	if (CheckMeleeRange())
	{
		Target.Damage(self, self, ((P_Random() % 10) + 1) * 12);
	}
}

//==========================================================================
//
//	A_SpecterAttack
//
//	Used by Specter1 and Programmer.
//
//==========================================================================

final void A_SpecterAttack()
{
	Actor		A;

	if (!Target)
		return;

	A_FaceTarget();

	A = Spawn(SpectralLightningSpot, Target.Origin);
	A.Origin.z = A.FloorZ;
	A.Velocity = vector(0.0, 0.0, 0.0);
	A.Target = self;
	if (A.SightSound)
	{
		A.PlaySound(A.SightSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_Specter2Attack
//
//==========================================================================

final void A_Specter2Attack()
{
	EntityEx A;

	if (!Target)
		return;

	A_FaceTarget();

	A = SpawnMissile(Target, SpectralLightningH2);
	if (A)
	{
		A.bSpectral = false;
	}
}

//==========================================================================
//
//	A_Specter3Attack
//
//==========================================================================

final void A_Specter3Attack()
{
	EntityEx spread;
	int i;

	if (!Target)
		return;

	A_FaceTarget();

	for (i = 0; i < 20; i++)
	{
		spread = SpawnMissile(Target, SpectralLightningBall2);
		if (spread)
		{
			spread.bSpectral = false;
			spread.Angles.yaw = AngleMod360(spread.Angles.yaw - 90.0 + itof(i) * (45.0 / 4.0));
			spread.Velocity.x = spread.Speed * cos(spread.Angles.yaw);
			spread.Velocity.y = spread.Speed * sin(spread.Angles.yaw);
		}
	}

	spread = Spawn(SpectralLightningV1, Origin + vector(0.0, 0.0, -Height));
	spread.bNoGravity = false;
	spread.bSpectral = false;
	spread.Target = self;
	spread.Velocity.x = 0.001;
	spread.Velocity.y = 0.001;
	spread.CheckMissileSpawn();
}

//==========================================================================
//
//	A_Specter4Attack
//
//==========================================================================

final void A_Specter4Attack()
{
	EntityEx A;

	if (!Target)
		return;

	A_FaceTarget();

	A = SpawnMissile(Target, SpectralLightningBigV2);
	if (A)
	{
		A.bSpectral = false;
	}
}

//==========================================================================
//
//	A_Specter5Attack
//
//==========================================================================

final void A_Specter5Attack()
{
	EntityEx A;

	if (!Target)
		return;

	A_FaceTarget();

	A = SpawnMissile(Target, SpectralLightningBigBall2);
	if (A)
	{
		A.bSpectral = false;
	}
}

//==========================================================================
//
//	A_SpecterTossChunk
//
//==========================================================================

final void A_SpecterTossChunk()
{
	TossUpObject(AlienChunkSmall);
}

//==========================================================================
//
//	A_SpecterTossHead
//
//==========================================================================

final void A_SpecterTossHead()
{
	TossUpObject(AlienChunkLarge);
}

//==========================================================================
//
//	A_Yeargh
//
//==========================================================================

final void A_Yeargh()
{
	PlaySound('human/disrupt', CHAN_VOICE);
}

defaultproperties
{
	Health = 0;
	Radius = 0.0;
	Height = 0.0;
	Mass = 0.0;
	bSolid = true;
	bShootable = true;
	bCountKill = true;
	bMonster = true;
	bActivateMCross = true;
	bActivatePushWall = true;
	bFloorClip = true;
	bPassMobj = true;
}
