//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class StrifeLevelInfo : LineSpecialLevelInfo;

//
// Map things flags
//
const int
	MTF_EASY		= 0x0001,	// Skill flags.
	MTF_NORMAL		= 0x0002,
	MTF_HARD		= 0x0004,
	MTF_AMBUSH		= 0x0008,	// Deaf monsters/do not react to sound.
	MTF_DORMANT		= 0x0010,	// The thing is dormant
	MTF_FIGHTER		= 0x0020,	// Thing appearing in player classes
	MTF_CLERIC		= 0x0040,
	MTF_MAGE		= 0x0080,
	MTF_GSINGLE		= 0x0100,	// Appearing in game modes
	MTF_GCOOP		= 0x0200,
	MTF_GDEATHMATCH	= 0x0400;

const int BODYQUESIZE	= 32;

Actor bodyque[BODYQUESIZE];
int bodyqueslot;

//==========================================================================
//
//  PolyThrustMobj
//
//==========================================================================

void PolyThrustMobj(Entity A, TVec thrustDir, polyobj_t * po)
{
	float force;
	PolyobjThinker pe;

	if (!Actor(A).bShootable && !A.bIsPlayer)
	{
		return;
	}

	pe = PolyobjThinker(po->SpecialData);
	if (pe)
	{
		force = pe.thrust_force;
		if (force < 1.0)
		{
			force = 1.0;
		}
		else if (force > 128.0)
		{
			force = 128.0;
		}
	}
	else
	{
		force = 1.0;
	}

	A.Velocity += force * thrustDir;
	if (po->bCrush)
	{
		TVec testPos;

		testPos = A.Origin + force * thrustDir * Game.frametime;
		if (!A.CheckPosition(testPos))
		{
			Actor(A).Damage(none, none, 3);
		}
	}
}

//==========================================================================
//
//  PolyBusy
//
//==========================================================================

bool PolyBusy(int polyobj)
{
	polyobj_t *poly;

	poly = XLevel.GetPolyobj(polyobj);
	if (!poly->SpecialData)
	{
		return false;
	}
	else
	{
		return true;
	}
}

//==========================================================================
//
//	ThingCount
//
//==========================================================================

int ThingCount(int type, int tid)
{
	int count;
	int searcher;
	Actor Ent;
	class moType;

	if (!(type + tid))
	{
		// Nothing to count
		return 0;
	}
	moType = FindClassFromScriptId(type);
	count = 0;
	searcher = -1;
	if (tid)
	{
		// Count TID things
		for (Ent = Actor(FindMobjFromTID(tid, &searcher)); Ent != none;
			Ent = Actor(FindMobjFromTID(tid, &searcher)))
		{
			if (type == 0)
			{
				// Just count TIDs
				count++;
			}
			else if (moType == Ent.Class)
			{
				if (Ent.bCountKill && Ent.Health <= 0)
				{
					// Don't count dead monsters
					continue;
				}
				count++;
			}
		}
	}
	else
	{
		// Count only types
		FOREACH(Actor, Ent)
		{
			if (Ent.Class != moType)
			{
				// Doesn't match
				continue;
			}
			if (Ent.bCountKill && Ent.Health <= 0)
			{
				// Don't count dead monsters
				continue;
			}
			count++;
		}
	}
	return count;
}

//==========================================================================
//
//  ExecuteActionSpecial
//
//==========================================================================

bool ExecuteActionSpecial(int Special, int Arg1, int Arg2, int Arg3,
	int Arg4, int Arg5, line_t* Line, int Side, Entity E)
{
	bool buttonSuccess;
	Actor A;

	A = Actor(E);
	buttonSuccess = false;
	switch (Special)
	{
	case LNSPEC_QuakeTremor:
		buttonSuccess = A_LocalQuake(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
/*	case LNSPEC_UsePuzzleItem:
		buttonSuccess = EV_LineSearchForPuzzleItem(Line, Arg1, Arg2, Arg3,
			Arg4, Arg5, mo);
		break;*/

	case 49:	//	Break glass.
		buttonSuccess = EV_BreakGlass(Arg1, Arg2, Arg3, Arg4, Arg5,
			Line, A);
		break;
	case 174:	//	SendToCommunicator.
		buttonSuccess = EV_SendToCommunicator(A, Arg1, Arg2, Arg3, Arg4,
			Arg5, Side);
		break;

	// Inert Line specials
	default:
		buttonSuccess = ::ExecuteActionSpecial(Special, Arg1, Arg2, Arg3,
			Arg4, Arg5, Line, Side, E);
		break;
	}
	return buttonSuccess;
}

//==========================================================================
//
//  CheckActivation
//
//==========================================================================

bool CheckActivation(int activationType, line_t * line, Actor A)
{
	int lineActivation;
	bool noway;

	noway = true;
	lineActivation = GET_SPAC(line->flags);
	if (lineActivation == SPAC_PTOUCH &&
		(activationType == SPAC_PCROSS || activationType == SPAC_IMPACT))
	{
		lineActivation = activationType;
	}
	else if (lineActivation == SPAC_USETHROUGH)
	{
		lineActivation = SPAC_USE;
	}
	else if (line->special == LNSPEC_Teleport &&
		lineActivation == SPAC_CROSS && activationType == SPAC_PCROSS &&
		A && A.bMissile)
	{
		// Let missiles use regular player teleports
		lineActivation = SPAC_PCROSS;
	}
	if (lineActivation != activationType &&
		!(activationType == SPAC_MCROSS && lineActivation == SPAC_CROSS))
	{
		return false;
	}
	if (!A.bIsPlayer && !A.bMissile)
	{
		if ((activationType == SPAC_USE || activationType == SPAC_PUSH)
			&& (line->flags & ML_SECRET))
			return false;	// never open secret doors

		switch (lineActivation)
		{
		case SPAC_IMPACT:
		case SPAC_PCROSS:
			// shouldn't really be here if not a missile
		case SPAC_MCROSS:
			noway = false;
			break;

		case SPAC_CROSS:
			switch (line->special)
			{
			case LNSPEC_DoorRaise:
			case LNSPEC_PlatDownWaitUpStay:
			case LNSPEC_Teleport:
			case LNSPEC_TeleportNoFog:
			case LNSPEC_PlatDownWaitUpStayLip:
			case LNSPEC_TeleportLine:
				noway = false;
			}
			break;

		case SPAC_USE:
		case SPAC_PUSH:
			switch (line->special)
			{
			case LNSPEC_DoorRaise:
				if (line->arg1 == 0)
					noway = false;
				break;
			case LNSPEC_Teleport:
			case LNSPEC_TeleportNoFog:
				noway = false;
			}
			break;
		}
		if (noway)
			return false;
	}
	return true;
}

//==========================================================================
//
//  ActivateLine
//
//==========================================================================

bool ActivateLine(line_t* Line, Actor A, int Side, int ActivationType)
{
	int lineActivation;
	bool repeat;
	bool buttonSuccess;
	bool changeBack;

	if (!CheckActivation(ActivationType, Line, A))
	{
		return false;
	}

	lineActivation = GET_SPAC(Line->flags);
	if (lineActivation == SPAC_PTOUCH)
	{
		lineActivation = ActivationType;
	}
	repeat = Line->flags & ML_REPEAT_SPECIAL;
	buttonSuccess = ExecuteActionSpecial(Line->special, Line->arg1,
		Line->arg2, Line->arg3, Line->arg4, Line->arg5, Line, Side, A);
	changeBack = Line->special == 49 && (Line->flags & ML_TWOSIDED) && buttonSuccess;
	if ((lineActivation == SPAC_USE || lineActivation == SPAC_IMPACT ||
		lineActivation == SPAC_USETHROUGH) && buttonSuccess)
	{
		P_ChangeSwitchTexture(Line, repeat,
			Line->special == LNSPEC_ExitNormal ||
			Line->special == LNSPEC_ExitSecret ||
			Line->special == LNSPEC_TeleportNewMap ||
			Line->special == LNSPEC_TeleportEndGame
			? 'switches/exitbutn' : 'switches/normbutn');
	}
	if (changeBack)
	{
		XLevel.SetLineTexture(Line->sidenum[1], 1, XLevel.Sides[Line->sidenum[0]].midtexture);
	}
	if (!repeat && buttonSuccess)
	{
		// clear the special on non-retriggerable lines
		Line->special = 0;
	}
	return true;
}

//==========================================================================
//
//  CheckLock
//
//==========================================================================

bool CheckLock(Entity user, int lock, bool door)
{
	if (!user.bIsPlayer)
	{
		return false;
	}
	if (!lock)
	{
		return true;
	}

	if (lock <= 32)
	{
		//	Regular keys.
		if (!(Player(user.Player).Keys & (1 << (lock - 1))))
		{
			user.Player.centreprint("$txt_needkey");
			user.PlaySound('*grunt', CHAN_VOICE);
			return false;
		}
	}
	else if (lock == 102)
	{
		user.Player.centreprint("That doesn\'t seem to work");
		user.PlaySound('*grunt', CHAN_VOICE);
		return false;
	}
	else if (lock == 103)
	{
		user.Player.centreprint(
			"THIS AREA IS ONLY AVAILABLE IN THE RETAIL VERSION OF STRIFE");
		user.PlaySound('*grunt', CHAN_VOICE);
		return false;
	}

	return true;
}

//==========================================================================
//
//  EV_SendToCommunicator
//
//==========================================================================

bool EV_SendToCommunicator(Actor A, int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5, int side)
{
	if (Arg2 && side)
		return false;

	if (A && A.bIsPlayer && Player(A.Player).Communicator)
	{
		if (!Arg4)
		{
			Player(A.Player).SetObjectives(Arg1);
		}

		MSG_Select(MSG_SV_RELIABLE);
		MSG_WriteByte(StrifeDefs::svc_voice);
		MSG_WriteShort(Arg1);

		if (Arg3 == 0)
		{
			A.Player.cprint("Incoming Message");
		}
		else if (Arg3 == 1)
		{
			A.Player.cprint("Incoming Message from BlackBird");
		}
		return true;
	}
	return false;
}

//==========================================================================
//
//  EV_BreakGlass
//
//==========================================================================

bool EV_BreakGlass(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	line_t* Line, Actor A)
{
	bool	switched;
	bool	quest1;
	bool	quest2;
	float	x;
	float	y;
	int		i;
	Actor	glass;
	float	an;
	float	speed;

	if (Line->flags & ML_TWOSIDED)
	{
		Line->flags &= ~(ML_BLOCKING | ML_BLOCKEVERYTHING);
	}
	quest1 = false;
	if (XLevel.Sides[Line->sidenum[0]].midtexture == TextureNumForName('brnscn01'))
		quest1 = true;
	P_ChangeSwitchTexture(Line, false, 'switches/normbutn');
	switched = true;
	Line->special = 0;
	if (Line->sidenum[1] != -1)
	{
		//switched |= P_ChangeSwitchTexture(&sides[ln->sidenum[1]], false, 0, &quest2);
		XLevel.SetLineTexture(Line->sidenum[1], 1, XLevel.Sides[Line->sidenum[0]].midtexture);
		quest2 = quest1;
	}
	else
	{
		quest2 = quest1;
	}
	if (switched)
	{
		// Break some glass
		x = Line->v1->x + (Line->v2->x - Line->v1->x) / 2.0;
		y = Line->v1->y + (Line->v2->y - Line->v1->y) / 2.0;
		x += (Line->frontsector->soundorg.x - x) / 5.0;
		y += (Line->frontsector->soundorg.y - y) / 5.0;

		for (i = 0; i < 7; i++)
		{
			glass = Spawn(Blood, vector(x, y, Actor::ONFLOORZ));
			glass.bColideWithThings = false;
			glass.bColideWithWorld = false;
			glass.Origin.z += 24.0;
			switch (P_Random() % 3)
			{
			case 0: glass.SetState(Actor::S_SHARD_4); break;
			case 1: glass.SetState(Actor::S_SHARD_5); break;
			case 2: glass.SetState(Actor::S_SHARD_6); break;
			}
			an = Random() * 360.0;
			glass.Angles.yaw = an;
			speed = Random() * 4.0 * 35.0;
			glass.Velocity.x = cos(an) * speed;
			glass.Velocity.y = sin(an) * speed;
			glass.Velocity.z = Random() * 8.0 * 35.0;
		}
		if (quest1 || quest2)
		{
			// Up stats and signal this mission is complete
			if (!A)
			{
				for (i = 0; i < MAXPLAYERS; ++i)
				{
					if (Game.Players[i] && Game.Players[i].bSpawned)
					{
						A = Actor(Game.Players[i].MO);
						break;
					}
				}
			}
			if (A && A.bIsPlayer)
			{
				Player(A.Player).GiveQuest(QUEST_FreedWorkers);
				Player(A.Player).Accuracy += 10;
				Player(A.Player).Stamina += 10;
				Player(A.Player).GiveBody(200);
			}
		}
	}
	//	We already changed the switch texture, so don't make the main code
	// switch it back.
	return false;
}

//==========================================================================
//
//	SpawnTeleportFog
//
//==========================================================================

void SpawnTeleportFog(TVec Org)
{
	Actor fogAct;

	fogAct = Spawn(TeleportFog, Org);
	fogAct.PlaySound('Teleport', CHAN_VOICE);
}

//===========================================================================
// Quake variables
//
//      Arg1     Intensity on richter scale (2..9)
//      Arg2     Duration in tics
//      Arg3     Radius for damage, in tile units (64 pixels)
//      Arg4     Radius for tremor in tile units (64 pixels)
//      Arg5     TID of map thing for focus of quake
//
//===========================================================================

//===========================================================================
//
//	A_LocalQuake
//
//===========================================================================

bool A_LocalQuake(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	QuakeFocus focus;
	Actor target;
	int lastfound = 0;
	int success = false;

	// Find all quake foci
	do
	{
		target = Actor(FindMobjFromTID(Arg5, &lastfound));
		if (target)
		{
			focus = QuakeFocus(Spawn(QuakeFocus, target.Origin));
			if (focus)
			{
				focus.Richters = Arg1;
				focus.QuakeDuration = Arg2 >> 1;	// decremented every 2 tics
				focus.DamageRadius = itof(Arg3) * 64.0;
				focus.TremorRadius = itof(Arg4) * 64.0;
				success = true;
			}
		}
	}
	while (target);

	return success;
}

//==========================================================================
//
//  SpawnMapThing
//
//  The fields of the mapthing should already be in host byte order.
//
//==========================================================================

void SpawnMapThing(mthing_t * mthing)
{
	int bit;
	Actor A;
	int spawnMask;
	class<Actor> moClass;

	if (mthing->type <= 0)
		return;

	// count deathmatch start positions
	if (mthing->type == 11)
	{
		if (NumDeathmatchStarts < MAXDEATHMATCHSTARTS)
		{
			CopyMThing(mthing, &DeathmatchStarts[NumDeathmatchStarts]);
			NumDeathmatchStarts++;
		}
		return;
	}

	// check for players specially
	if (mthing->type <= 8)
	{
		// save spots for respawning in network games
		CopyMThing(mthing, &PlayerStarts[mthing->arg1 * MAXPLAYERS +
			mthing->type - 1]);
		return;
	}

	if (mthing->type >= 1400 && mthing->type < 1410)
	{
		XLevel.PointInSector(vector(mthing->x,
			mthing->y, 0.0))->seqType = mthing->type - 1400;
		return;
	}

	// Check current game type with spawn flags
	if (Game.netgame == false)
	{
		spawnMask = MTF_GSINGLE;
	}
	else if (Game.deathmatch)
	{
		spawnMask = MTF_GDEATHMATCH;
	}
	else
	{
		spawnMask = MTF_GCOOP;
	}
	if (!(mthing->options & spawnMask))
	{
		return;
	}

	// check for apropriate skill level
	if (Game.gameskill == sk_baby)
		bit = 1;
	else if (Game.gameskill == sk_nightmare)
		bit = 4;
	else
		bit = 1 << (Game.gameskill - 1);

	if (!(mthing->options & bit))
		return;

	// find which type to spawn
	moClass = class<Actor>(FindClassFromEditorId(mthing->type));
	if (moClass)
	{
		// spawn it
		A = Spawn(moClass,,, mthing);
	}
	else
	{
		dprint("SpawnMapThing: Unknown type %d at (%f, %f)",
			mthing->type, mthing->x, mthing->y);
	}
}

//**************************************************************************
//
//	CONVERSATION STUFF
//
//**************************************************************************

Actor CurrentSpeaker;
Actor CurrentSpeakingTo;
float OldSpeakerAngle;
int CurrentSpeechIndex;
bool ConversationSlideshow;

//==========================================================================
//
//	StartConversation
//
//==========================================================================

bool StartConversation(Actor User, Actor UseOn)
{
	int SpeechNum;

	if (Game.netgame)
	{
		return false;
	}
	if (!User || !User.bIsPlayer || User.Health <= 0)
	{
		return false;
	}
	if (!UseOn || UseOn.Health <= 0)
	{
		return false;
	}
	if (UseOn.bInCombat)
	{
		//	This dude is too busy to talk right now.
		return false;
	}
	if (!UseOn.ConversationID)
	{
		return false;
	}
	SpeechNum = UseOn.GetSpeech();
	if (SpeechNum)
	{
		CurrentSpeaker = UseOn;
		CurrentSpeakingTo = User;
		OldSpeakerAngle = UseOn.Angles.yaw;
		UseOn.Angles.yaw = atan2(User.Origin.y - UseOn.Origin.y,
			User.Origin.x - UseOn.Origin.x);
		User.PlaySound('misc/chat', CHAN_VOICE);
		StartSpeech(SpeechNum);
	}
	return true;
}

//==========================================================================
//
//	StartSpeech
//
//==========================================================================

void StartSpeech(int SpeechNum)
{
	RogueConSpeech *Speech;
	bool conJumped;

	do
	{
		conJumped = false;
		if (!SpeechNum)
		{
			StopSpeech();
			return;
		}
		if (SpeechNum < 0)
		{
			Speech = &XLevel.GenericSpeeches[-SpeechNum - 1];
		}
		else
		{
			Speech = &XLevel.LevelSpeeches[SpeechNum - 1];
		}
		if (Speech->JumpToConv &&
			CheckForNeededItem(CurrentSpeakingTo, Speech->CheckItem1, 1) != -2 &&
			CheckForNeededItem(CurrentSpeakingTo, Speech->CheckItem2, 1) != -2 &&
			CheckForNeededItem(CurrentSpeakingTo, Speech->CheckItem3, 1) != -2)
		{
			CurrentSpeaker.CurrentSpeech = Speech->JumpToConv;
			SpeechNum = CurrentSpeaker.GetSpeech();
			conJumped = true;
		}
	}
	while (conJumped);
	CurrentSpeechIndex = SpeechNum;

	MSG_Select(MSG_SV_RELIABLE);
	MSG_WriteByte(StrifeDefs::svc_speech);
	MSG_WriteShort(SpeechNum);
}

//==========================================================================
//
//	GetClassFromID
//
//==========================================================================

class<Actor> GetClassFromID(int ID)
{
	switch (ID)
	{
	case 125:	return MedPatch;
	case 126:	return MedicalKit;
	case 127:	return SurgeryKit;
	case 128:	return DegninOre;
	case 129:	return MetalArmor;
	case 130:	return LeatherArmor;
	case 133:	return ItemBaseKey;
	case 134:	return ItemGovsKey;
	case 135:	return ItemPasscard;
	case 136:	return ItemIDBadge;
	case 137:	return ItemPrisonKey;
	case 138:	return ItemSeveredHand;
	case 139:	return ItemPower1Key;
	case 140:	return ItemPower2Key;
	case 141:	return ItemPower3Key;
	case 142:	return ItemGoldKey;
	case 143:	return ItemIDCard;
	case 144:	return ItemSilverKey;
	case 145:	return ItemOracleKey;
	case 146:	return ItemMilitaryID;
	case 147:	return ItemOrderKey;
	case 148:	return ItemWarehouseKey;
	case 149:	return ItemBrassKey;
	case 150:	return ItemRedCrystalKey;
	case 151:	return ItemBlueCrystalKey;
	case 152:	return ItemChapelKey;
	case 153:	return ItemCatacombKey;
	case 154:	return ItemSecurityKey;
	case 155:	return ItemCoreKey;
	case 156:	return ItemMaulerKey;
	case 157:	return ItemFactoryKey;
	case 158:	return ItemMineKey;
	case 159:	return ItemNewKey5;
	case 160:	return Shadow_armor;
	case 161:	return Environmental_Suit;
	case 162:	return Guard_Uniform;
	case 163:	return Officers_Uniform;
	case 164:	return Map;
	case 165:	return Scanner;
	case 166:	return Teleporter_Beacon;
	case 167:	return Targeter;
	case 168:	return Coin;
	case 169:	return Gold10;
	case 170:	return Gold25;
	case 171:	return Gold50;
	case 172:	return Gold300;
	case 173:	return Ring;
	case 174:	return Offering_Chalice;
	case 175:	return Ear;
	case 176:	return Communicator;
	case 177:	return ItemAmmoHEGrenadeRounds;
	case 178:	return ItemAmmoPhosphorusGrenadeRounds;
	case 179:	return ItemAmmoClipOfBullets;
	case 180:	return ItemAmmoBoxOfBullets;
	case 181:	return ItemAmmoMiniMissiles;
	case 182:	return ItemAmmoCrateOfMissiles;
	case 183:	return ItemAmmoEnergyPod;
	case 184:	return ItemAmmoEnergyPack;
	case 185:	return ItemAmmoPoisonBolts;
	case 186:	return ItemAmmoElectricBolts;
	case 187:	return Ammo_satchel;
	case 188:	return ItemWeaponAssaultGun;
	case 189:	return ItemWeaponAssaultGun2;
	case 190:	return ItemWeaponFlameThrower;
	case 191:	return Flame_thrower_Parts;
	case 192:	return ItemWeaponMiniMissileLauncher;
	case 193:	return ItemWeaponMauler;
	case 194:	return ItemWeaponCrossbow;
	case 195:	return ItemWeaponGrenadeLauncher;
	case 196:	return ItemWeaponSigil1;
	case 197:	return ItemWeaponSigil2;
	case 198:	return ItemWeaponSigil3;
	case 199:	return ItemWeaponSigil4;
	case 200:	return ItemWeaponSigil5;
	case 289:	return BrokenPowerCoupling;
	case 298:	return Ammo2;
	case 299:	return Health1;
	case 300:	return Info1;
	case 301:	return Alarm1;
	case 302:	return ConversationItem302;
	case 303:	return ConversationItem303;
	case 304:	return Prison_pass;
	case 305:	return ConversationItem305;
	case 306:	return ConversationItem306;
	case 307:	return ConversationItem307;
	case 308:	return Report;
	case 309:	return Toughness;
	case 310:	return Accuracy;
	case 311:	return Oracle_Pass;
	case 312:	return Quest1;
	case 313:	return Quest2;
	case 314:	return Quest3;
	case 315:	return Quest4;
	case 316:	return Quest5;
	case 317:	return Quest6;
	case 318:	return Quest7;
	case 319:	return Quest8;
	case 320:	return Quest9;
	case 321:	return Quest10;
	case 322:	return Quest11;
	case 323:	return Quest12;
	case 324:	return Quest13;
	case 325:	return Quest14;
	case 326:	return Quest15;
	case 327:	return Quest16;
	case 328:	return Quest17;
	case 329:	return Quest18;
	case 330:	return Quest19;
	case 331:	return Quest20;
	case 332:	return Quest21;
	case 333:	return Quest22;
	case 334:	return Quest23;
	case 335:	return Quest24;
	case 336:	return Quest25;
	case 337:	return Quest26;
	case 338:	return Quest27;
	case 339:	return Quest28;
	case 340:	return Quest29;
	case 341:	return Quest30;
	case 342:	return Quest31;
	case 343:	return ConversationItem343;
	}
	if (ID)
	{
		print("Unknown item %d", ID);
	}
	return none;
}

//==========================================================================
//
//	CheckForNeededItem
//
//==========================================================================

int CheckForNeededItem(Actor A, int ID, int Amount)
{
	class<Actor> CID;
	int i;

	//	Get class ID.
	CID = GetClassFromID(ID);
	//	Check inventory items.
	for (i = 0; i < StrifeDefs::NUMINVITEMS; i++)
	{
		if (MainGameInfo(Game).InvItemCID[i] == CID)
		{
			return Player(A.Player).Inventory[i] < Amount ? -2 : i;
		}
	}
	//	Check keys.
	for (i = 0; i < StrifeDefs::NUMKEYS; i++)
	{
		if (MainGameInfo(Game).KeyCID[i] == CID)
		{
			return Player(A.Player).Keys & (1 << i) ? -1 : -2;
		}
	}
	//	Check quests.
	if (ID >= 312 && ID <= 342)
	{
		return Player(A.Player).Quests & (1 << (ID - 312)) ? -1 : -2;
	}
	//	Check Communicator.
	if (CID == Communicator)
	{
		return Player(A.Player).Communicator ? -1 : -2;
	}
	return -1;
}

//==========================================================================
//
//	StopSpeech
//
//==========================================================================

void StopSpeech()
{
	CurrentSpeaker.Angles.yaw = OldSpeakerAngle;
	CurrentSpeaker = none;
	CurrentSpeakingTo = none;
	CurrentSpeechIndex = 0;
}

//==========================================================================
//
//	ConChoiceImpulse
//
//==========================================================================

void ConChoiceImpulse(int ChoiceNum)
{
	RogueConSpeech *Speech;
	RogueConChoice *Choice;
	int SpeechNum;
	int Item1;
	int Item2;
	int Item3;
	class<Actor> ItemType;
	Pickup Item;
	bool GaveItem;

	if (ConversationSlideshow)
	{
		//	Resume conversation after slideshow.
		StartSpeech(CurrentSpeaker.GetSpeech());
		ConversationSlideshow = false;
		return;
	}
	if (!CurrentSpeaker || !CurrentSpeechIndex)
	{
		return;
	}
	if (!ChoiceNum)
	{
		StopSpeech();
		return;
	}
	if (CurrentSpeechIndex < 0)
	{
		Speech = &XLevel.GenericSpeeches[-CurrentSpeechIndex - 1];
	}
	else
	{
		Speech = &XLevel.LevelSpeeches[CurrentSpeechIndex - 1];
	}
	Choice = &Speech->Choices[ChoiceNum - 1];
	//	Check if player has needed items.
	Item1 = CheckForNeededItem(CurrentSpeakingTo, Choice->NeedItem1, Choice->NeedAmount1);
	Item2 = CheckForNeededItem(CurrentSpeakingTo, Choice->NeedItem2, Choice->NeedAmount2);
	Item3 = CheckForNeededItem(CurrentSpeakingTo, Choice->NeedItem3, Choice->NeedAmount3);
	if (Item1 == -2 || Item2 == -2 || Item3 == -2)
	{
		CurrentSpeakingTo.Player.cprint(Choice->TextNo);
		StopSpeech();
		return;
	}
	GaveItem = true;
	if (Choice->GiveItem > 0)
	{
		ItemType = GetClassFromID(Choice->GiveItem);
		if (ItemType)
		{
			Item = Pickup(Spawn(ItemType, vector(0.0, 0.0, 0.0)));
			GaveItem = Item.GiveItemTo(CurrentSpeakingTo);
			Item.Destroy();
		}
	}
	if (GaveItem)
	{
		if (Item1 != -1)
			Player(CurrentSpeakingTo.Player).RemoveInvItem(Item1, Choice->NeedAmount1);
		if (Item2 != -1)
			Player(CurrentSpeakingTo.Player).RemoveInvItem(Item2, Choice->NeedAmount2);
		if (Item3 != -1)
			Player(CurrentSpeakingTo.Player).RemoveInvItem(Item3, Choice->NeedAmount3);
	}
	if (Choice->Objectives)
	{
		Player(CurrentSpeakingTo.Player).SetObjectives(Choice->Objectives);
	}
	if (!GaveItem)
	{
		CurrentSpeakingTo.Player.cprint(Choice->TextNo);
	}
	else if (strcmp(Choice->TextOK, "") && strcmp(Choice->TextOK, "_"))
	{
		CurrentSpeakingTo.Player.cprint(Choice->TextOK);
	}
	if (Choice->Next < 0)
	{
		CurrentSpeaker.CurrentSpeech = -Choice->Next;
		if (!ConversationSlideshow)
		{
			StartSpeech(CurrentSpeaker.GetSpeech());
		}
	}
	else
	{
		if (Choice->Next)
		{
			CurrentSpeaker.CurrentSpeech = Choice->Next;
		}
		StopSpeech();
		ConversationSlideshow = false;
	}
}

//==========================================================================
//
//  GetDefaultDoorSound
//
//==========================================================================

name GetDefaultDoorSound(sector_t* Sector)
{
	int			i;
	name		SeqName = DefaultDoorSound;

	//	Search the front top textures of 2-sided lines on the door sector
	// for a door sound to use.
	for (i = 0; i < Sector->linecount; i++)
	{
		if (!Sector->lines[i]->backsector)
			continue;

		string TexName = va("%n", GetTextureName(XLevel.Sides[
			Sector->lines[i]->sidenum[0]].toptexture));
		if (StrStartsWith(TexName, "dors"))
		{
			SeqName = 'DoorStone';
		}
		else if (StrStartsWith(TexName, "dorml"))
		{
			SeqName = 'DoorLargeMetal';
		}
		else if (StrStartsWith(TexName, "dorwl"))
		{
			SeqName = 'DoorLargeWood';
		}
		else if (StrStartsWith(TexName, "dorw"))
		{
			SeqName = 'DoorSmallWood';
		}
	}

	return SeqName;
}

defaultproperties
{
	DefaultDoorSound = 'DoorSmallMetal';
	DefaultCeilingSound = 'CeilingNormal';
	DefaultSilentCeilingSound = 'CeilingSemiSilent';
	DefaultFloorSound = 'Floor';
	DefaultFloorAltSound = 'Floor';
	DefaultStairStepSound = 'Floor';
	DefaultPlatformSound = 'Platform';
	bTeleportNewMapBothSides = true;
}
