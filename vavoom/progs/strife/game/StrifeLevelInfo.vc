//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class StrifeLevelInfo : LineSpecialLevelInfo;

const int BODYQUESIZE	= 32;

EntityEx bodyque[BODYQUESIZE];
int bodyqueslot;

//==========================================================================
//
//  ExecuteActionSpecial
//
//==========================================================================

bool ExecuteActionSpecial(int Special, int Arg1, int Arg2, int Arg3,
	int Arg4, int Arg5, line_t* Line, int Side, Entity E)
{
	bool buttonSuccess;
	EntityEx A;

	A = EntityEx(E);
	buttonSuccess = false;
	switch (Special)
	{
	case LNSPEC_QuakeTremor:
		buttonSuccess = A_LocalQuake(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
/*	case LNSPEC_UsePuzzleItem:
		buttonSuccess = EV_LineSearchForPuzzleItem(Line, Arg1, Arg2, Arg3,
			Arg4, Arg5, mo);
		break;*/

	case LNSPEC_BreakGlass:
		buttonSuccess = EV_BreakGlass(Arg1, Arg2, Arg3, Arg4, Arg5,
			Line, A);
		break;
	case 174:	//	SendToCommunicator.
		buttonSuccess = EV_SendToCommunicator(A, Arg1, Arg2, Arg3, Arg4,
			Arg5, Side);
		break;

	// Inert Line specials
	default:
		buttonSuccess = ::ExecuteActionSpecial(Special, Arg1, Arg2, Arg3,
			Arg4, Arg5, Line, Side, E);
		break;
	}
	return buttonSuccess;
}

//==========================================================================
//
//  CheckActivation
//
//==========================================================================

bool CheckActivation(int activationType, line_t * line, EntityEx A)
{
	int lineActivation;
	bool noway;

	noway = true;
	lineActivation = GET_SPAC(line->flags);
	if (lineActivation == SPAC_PTOUCH &&
		(activationType == SPAC_PCROSS || activationType == SPAC_IMPACT))
	{
		lineActivation = activationType;
	}
	else if (lineActivation == SPAC_USETHROUGH)
	{
		lineActivation = SPAC_USE;
	}
	else if (line->special == LNSPEC_Teleport &&
		lineActivation == SPAC_CROSS && activationType == SPAC_PCROSS &&
		A && A.bMissile)
	{
		// Let missiles use regular player teleports
		lineActivation = SPAC_PCROSS;
	}
	if (lineActivation != activationType &&
		!(activationType == SPAC_MCROSS && lineActivation == SPAC_CROSS))
	{
		return false;
	}
	if (!A.bIsPlayer && !A.bMissile)
	{
		if ((activationType == SPAC_USE || activationType == SPAC_PUSH)
			&& (line->flags & ML_SECRET))
			return false;	// never open secret doors

		switch (lineActivation)
		{
		case SPAC_IMPACT:
		case SPAC_PCROSS:
			// shouldn't really be here if not a missile
		case SPAC_MCROSS:
			noway = false;
			break;

		case SPAC_CROSS:
			switch (line->special)
			{
			case LNSPEC_DoorRaise:
			case LNSPEC_PlatDownWaitUpStay:
			case LNSPEC_Teleport:
			case LNSPEC_TeleportNoFog:
			case LNSPEC_PlatDownWaitUpStayLip:
			case LNSPEC_TeleportLine:
				noway = false;
			}
			break;

		case SPAC_USE:
		case SPAC_PUSH:
			switch (line->special)
			{
			case LNSPEC_DoorRaise:
				if (line->arg1 == 0)
					noway = false;
				break;
			case LNSPEC_Teleport:
			case LNSPEC_TeleportNoFog:
				noway = false;
			}
			break;
		}
		if (noway)
			return false;
	}
	return true;
}

//==========================================================================
//
//  CheckLock
//
//==========================================================================

bool CheckLock(Entity user, int lock, bool door)
{
	if (!user.bIsPlayer)
	{
		return false;
	}
	if (!lock)
	{
		return true;
	}

	if (lock <= 32)
	{
		//	Regular keys.
		if (!(Player(user.Player).Keys & (1 << (lock - 1))))
		{
			user.Player.centreprint("$txt_needkey");
			user.PlaySound('*grunt', CHAN_VOICE);
			return false;
		}
	}
	else if (lock == 102)
	{
		user.Player.centreprint("That doesn\'t seem to work");
		user.PlaySound('*grunt', CHAN_VOICE);
		return false;
	}
	else if (lock == 103)
	{
		user.Player.centreprint(
			"THIS AREA IS ONLY AVAILABLE IN THE RETAIL VERSION OF STRIFE");
		user.PlaySound('*grunt', CHAN_VOICE);
		return false;
	}

	return true;
}

//==========================================================================
//
//  EV_SendToCommunicator
//
//==========================================================================

bool EV_SendToCommunicator(EntityEx A, int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5, int side)
{
	if (Arg2 && side)
		return false;

	if (A && A.bIsPlayer && Player(A.Player).Communicator)
	{
		if (!Arg4)
		{
			Player(A.Player).SetObjectives(Arg1);
		}

		Player(A.Player).ClientVoice(Arg1);

		if (Arg3 == 0)
		{
			A.Player.cprint("Incoming Message");
		}
		else if (Arg3 == 1)
		{
			A.Player.cprint("Incoming Message from BlackBird");
		}
		return true;
	}
	return false;
}

//==========================================================================
//
//  EV_BreakGlass
//
//==========================================================================

bool EV_BreakGlass(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	line_t* Line, EntityEx A)
{
	bool	switched;
	bool	quest1;
	bool	quest2;
	float	x;
	float	y;
	int		i;
	EntityEx	glass;
	float	an;
	float	speed;

	if (Line->flags & ML_TWOSIDED)
	{
		Line->flags &= ~(ML_BLOCKING | ML_BLOCKEVERYTHING);
	}
	quest1 = false;
	if (XLevel.Sides[Line->sidenum[0]].midtexture == TextureNumForName('brnscn01'))
		quest1 = true;
	ChangeSwitchTexture(Line, false, 'switches/normbutn');
	switched = true;
	Line->special = 0;
	if (Line->sidenum[1] != -1)
	{
		//switched |= P_ChangeSwitchTexture(&sides[ln->sidenum[1]], false, 0, &quest2);
		XLevel.Sides[Line->sidenum[1]].midtexture = XLevel.Sides[Line->sidenum[0]].midtexture;
		quest2 = quest1;
	}
	else
	{
		quest2 = quest1;
	}
	if (switched)
	{
		// Break some glass
		x = Line->v1->x + (Line->v2->x - Line->v1->x) / 2.0;
		y = Line->v1->y + (Line->v2->y - Line->v1->y) / 2.0;
		x += (Line->frontsector->soundorg.x - x) / 5.0;
		y += (Line->frontsector->soundorg.y - y) / 5.0;

		for (i = 0; i < 7; i++)
		{
			glass = Spawn(Blood, vector(x, y, EntityEx::ONFLOORZ));
			glass.bColideWithThings = false;
			glass.bColideWithWorld = false;
			glass.Origin.z += 24.0;
			switch (P_Random() % 3)
			{
			case 0: glass.SetState(Actor::S_SHARD_4); break;
			case 1: glass.SetState(Actor::S_SHARD_5); break;
			case 2: glass.SetState(Actor::S_SHARD_6); break;
			}
			an = Random() * 360.0;
			glass.Angles.yaw = an;
			speed = Random() * 4.0 * 35.0;
			glass.Velocity.x = cos(an) * speed;
			glass.Velocity.y = sin(an) * speed;
			glass.Velocity.z = Random() * 8.0 * 35.0;
		}
		if (quest1 || quest2)
		{
			// Up stats and signal this mission is complete
			if (!A)
			{
				for (i = 0; i < MAXPLAYERS; ++i)
				{
					if (Game.Players[i] && Game.Players[i].bSpawned)
					{
						A = EntityEx(Game.Players[i].MO);
						break;
					}
				}
			}
			if (A && A.bIsPlayer)
			{
				Player(A.Player).GiveQuest(QUEST_FreedWorkers);
				Player(A.Player).Accuracy += 10;
				Player(A.Player).Stamina += 10;
				Player(A.Player).GiveBody(200);
			}
		}
	}
	//	We already changed the switch texture, so don't make the main code
	// switch it back.
	return false;
}

//===========================================================================
// Quake variables
//
//      Arg1     Intensity on richter scale (2..9)
//      Arg2     Duration in tics
//      Arg3     Radius for damage, in tile units (64 pixels)
//      Arg4     Radius for tremor in tile units (64 pixels)
//      Arg5     TID of map thing for focus of quake
//
//===========================================================================

//===========================================================================
//
//	A_LocalQuake
//
//===========================================================================

bool A_LocalQuake(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	QuakeFocus focus;
	EntityEx target;
	int lastfound = 0;
	int success = false;

	// Find all quake foci
	do
	{
		target = EntityEx(FindMobjFromTID(Arg5, &lastfound));
		if (target)
		{
			focus = QuakeFocus(Spawn(QuakeFocus, target.Origin));
			if (focus)
			{
				focus.Richters = Arg1;
				focus.QuakeDuration = Arg2 >> 1;	// decremented every 2 tics
				focus.DamageRadius = itof(Arg3) * 64.0;
				focus.TremorRadius = itof(Arg4) * 64.0;
				success = true;
			}
		}
	}
	while (target);

	return success;
}

//**************************************************************************
//
//	CONVERSATION STUFF
//
//**************************************************************************

EntityEx CurrentSpeaker;
EntityEx CurrentSpeakingTo;
float OldSpeakerAngle;
int CurrentSpeechIndex;
bool ConversationSlideshow;

//==========================================================================
//
//	StartConversation
//
//==========================================================================

bool StartConversation(EntityEx User, EntityEx UseOn)
{
	int SpeechNum;

	if (Game.netgame)
	{
		return false;
	}
	if (!User || !User.bIsPlayer || User.Health <= 0)
	{
		return false;
	}
	if (!UseOn || UseOn.Health <= 0)
	{
		return false;
	}
	if (UseOn.bInCombat)
	{
		//	This dude is too busy to talk right now.
		return false;
	}
	if (!UseOn.ConversationID)
	{
		return false;
	}
	SpeechNum = UseOn.GetSpeech();
	if (SpeechNum)
	{
		CurrentSpeaker = UseOn;
		CurrentSpeakingTo = User;
		OldSpeakerAngle = UseOn.Angles.yaw;
		UseOn.Angles.yaw = atan2(User.Origin.y - UseOn.Origin.y,
			User.Origin.x - UseOn.Origin.x);
		User.PlaySound('misc/chat', CHAN_VOICE);
		StartSpeech(SpeechNum);
	}
	return true;
}

//==========================================================================
//
//	StartSpeech
//
//==========================================================================

void StartSpeech(int SpeechNum)
{
	RogueConSpeech *Speech;
	bool conJumped;

	do
	{
		conJumped = false;
		if (!SpeechNum)
		{
			StopSpeech();
			return;
		}
		if (SpeechNum < 0)
		{
			Speech = &XLevel.GenericSpeeches[-SpeechNum - 1];
		}
		else
		{
			Speech = &XLevel.LevelSpeeches[SpeechNum - 1];
		}
		if (Speech->JumpToConv &&
			CheckForNeededItem(CurrentSpeakingTo, Speech->CheckItem1, 1) != -2 &&
			CheckForNeededItem(CurrentSpeakingTo, Speech->CheckItem2, 1) != -2 &&
			CheckForNeededItem(CurrentSpeakingTo, Speech->CheckItem3, 1) != -2)
		{
			CurrentSpeaker.CurrentSpeech = Speech->JumpToConv;
			SpeechNum = CurrentSpeaker.GetSpeech();
			conJumped = true;
		}
	}
	while (conJumped);
	CurrentSpeechIndex = SpeechNum;

	Player(CurrentSpeakingTo.Player).ClientSpeech(SpeechNum);
}

//==========================================================================
//
//	GetClassFromID
//
//==========================================================================

class<EntityEx> GetClassFromID(int ID)
{
	switch (ID)
	{
	case 125:	return MedPatch;
	case 126:	return MedicalKit;
	case 127:	return SurgeryKit;
	case 128:	return DegninOre;
	case 129:	return MetalArmor;
	case 130:	return LeatherArmor;
	case 133:	return BaseKey;
	case 134:	return GovsKey;
	case 135:	return Passcard;
	case 136:	return IDBadge;
	case 137:	return PrisonKey;
	case 138:	return SeveredHand;
	case 139:	return Power1Key;
	case 140:	return Power2Key;
	case 141:	return Power3Key;
	case 142:	return GoldKey;
	case 143:	return IDCard;
	case 144:	return SilverKey;
	case 145:	return OracleKey;
	case 146:	return MilitaryID;
	case 147:	return OrderKey;
	case 148:	return WarehouseKey;
	case 149:	return BrassKey;
	case 150:	return RedCrystalKey;
	case 151:	return BlueCrystalKey;
	case 152:	return ChapelKey;
	case 153:	return CatacombKey;
	case 154:	return SecurityKey;
	case 155:	return CoreKey;
	case 156:	return MaulerKey;
	case 157:	return FactoryKey;
	case 158:	return MineKey;
	case 159:	return NewKey5;
	case 160:	return ShadowArmor;
	case 161:	return EnvironmentalSuit;
	case 162:	return GuardUniform;
	case 163:	return OfficersUniform;
	case 164:	return StrifeMap;
	case 165:	return Scanner;
	case 166:	return TeleporterBeacon;
	case 167:	return Targeter;
	case 168:	return Coin;
	case 169:	return Gold10;
	case 170:	return Gold25;
	case 171:	return Gold50;
	case 172:	return Gold300;
	case 173:	return BeldinsRing;
	case 174:	return OfferingChalice;
	case 175:	return Ear;
	case 176:	return Communicator;
	case 177:	return HEGrenadeRounds;
	case 178:	return PhosphorusGrenadeRounds;
	case 179:	return ClipOfBullets;
	case 180:	return BoxOfBullets;
	case 181:	return MiniMissiles;
	case 182:	return CrateOfMissiles;
	case 183:	return EnergyPod;
	case 184:	return EnergyPack;
	case 185:	return PoisonBolts;
	case 186:	return ElectricBolts;
	case 187:	return AmmoSatchel;
	case 188:	return AssaultGun;
	case 189:	return AssaultGunStanding;
	case 190:	return FlameThrower;
	case 191:	return FlameThrowerParts;
	case 192:	return MiniMissileLauncher;
	case 193:	return Mauler;
	case 194:	return StrifeCrossbow;
	case 195:	return StrifeGrenadeLauncher;
	case 196:	return Sigil1;
	case 197:	return Sigil2;
	case 198:	return Sigil3;
	case 199:	return Sigil4;
	case 200:	return Sigil5;
	case 289:	return BrokenPowerCoupling;
	case 298:	return AmmoFillup;
	case 299:	return HealthFillup;
	case 300:	return Info;
	case 301:	return RaiseAlarm;
	case 302:	return OpenDoor222;
	case 303:	return CloseDoor222;
	case 304:	return PrisonPass;
	case 305:	return OpenDoor224;
	case 306:	return UpgradeStamina;
	case 307:	return UpgradeAccuracy;
	case 308:	return InterrogatorReport;
	case 309:	return HealthTraining;
	case 310:	return GunTraining;
	case 311:	return OraclePass;
	case 312:	return QuestItem1;
	case 313:	return QuestItem2;
	case 314:	return QuestItem3;
	case 315:	return QuestItem4;
	case 316:	return QuestItem5;
	case 317:	return QuestItem6;
	case 318:	return QuestItem7;
	case 319:	return QuestItem8;
	case 320:	return QuestItem9;
	case 321:	return QuestItem10;
	case 322:	return QuestItem11;
	case 323:	return QuestItem12;
	case 324:	return QuestItem13;
	case 325:	return QuestItem14;
	case 326:	return QuestItem15;
	case 327:	return QuestItem16;
	case 328:	return QuestItem17;
	case 329:	return QuestItem18;
	case 330:	return QuestItem19;
	case 331:	return QuestItem20;
	case 332:	return QuestItem21;
	case 333:	return QuestItem22;
	case 334:	return QuestItem23;
	case 335:	return QuestItem24;
	case 336:	return QuestItem25;
	case 337:	return QuestItem26;
	case 338:	return QuestItem27;
	case 339:	return QuestItem28;
	case 340:	return QuestItem29;
	case 341:	return QuestItem30;
	case 342:	return QuestItem31;
	case 343:	return SlideshowStarter;
	}
	if (ID)
	{
		print("Unknown item %d", ID);
	}
	return none;
}

//==========================================================================
//
//	CheckForNeededItem
//
//==========================================================================

int CheckForNeededItem(EntityEx A, int ID, int Amount)
{
	class<EntityEx> CID;
	int i;

	//	Get class ID.
	CID = GetClassFromID(ID);
	//	Check inventory items.
	for (i = 0; i < StrifeDefs::NUMINVITEMS; i++)
	{
		if (MainGameInfo(Game).InvItemCID[i] == CID)
		{
			return !Player(A.Player).Inventory[i] ||
				Player(A.Player).Inventory[i].Amount < Amount ? -2 : i;
		}
	}
	//	Check keys.
	for (i = 0; i < StrifeDefs::NUMKEYS; i++)
	{
		if (MainGameInfo(Game).KeyCID[i] == CID)
		{
			return Player(A.Player).Keys & (1 << i) ? -1 : -2;
		}
	}
	//	Check quests.
	if (ID >= 312 && ID <= 342)
	{
		return Player(A.Player).Quests & (1 << (ID - 312)) ? -1 : -2;
	}
	//	Check Communicator.
	if (CID == Communicator)
	{
		return Player(A.Player).Communicator ? -1 : -2;
	}
	return -1;
}

//==========================================================================
//
//	StopSpeech
//
//==========================================================================

void StopSpeech()
{
	CurrentSpeaker.Angles.yaw = OldSpeakerAngle;
	CurrentSpeaker = none;
	CurrentSpeakingTo = none;
	CurrentSpeechIndex = 0;
}

//==========================================================================
//
//	ConChoiceImpulse
//
//==========================================================================

void ConChoiceImpulse(int ChoiceNum)
{
	RogueConSpeech *Speech;
	RogueConChoice *Choice;
	int SpeechNum;
	int Item1;
	int Item2;
	int Item3;
	class<EntityEx> ItemType;
	Inventory Item;
	bool GaveItem;

	if (ConversationSlideshow)
	{
		//	Resume conversation after slideshow.
		StartSpeech(CurrentSpeaker.GetSpeech());
		ConversationSlideshow = false;
		return;
	}
	if (!CurrentSpeaker || !CurrentSpeechIndex)
	{
		return;
	}
	if (!ChoiceNum)
	{
		StopSpeech();
		return;
	}
	if (CurrentSpeechIndex < 0)
	{
		Speech = &XLevel.GenericSpeeches[-CurrentSpeechIndex - 1];
	}
	else
	{
		Speech = &XLevel.LevelSpeeches[CurrentSpeechIndex - 1];
	}
	Choice = &Speech->Choices[ChoiceNum - 1];
	//	Check if player has needed items.
	Item1 = CheckForNeededItem(CurrentSpeakingTo, Choice->NeedItem1, Choice->NeedAmount1);
	Item2 = CheckForNeededItem(CurrentSpeakingTo, Choice->NeedItem2, Choice->NeedAmount2);
	Item3 = CheckForNeededItem(CurrentSpeakingTo, Choice->NeedItem3, Choice->NeedAmount3);
	if (Item1 == -2 || Item2 == -2 || Item3 == -2)
	{
		CurrentSpeakingTo.Player.cprint(Choice->TextNo);
		StopSpeech();
		return;
	}
	GaveItem = true;
	if (Choice->GiveItem > 0)
	{
		ItemType = GetClassFromID(Choice->GiveItem);
		if (ItemType)
		{
			Item = Inventory(Spawn(ItemType));
			GaveItem = Item.TryPickup(CurrentSpeakingTo);
			if (!GaveItem)
			{
				Item.Destroy();
			}
		}
	}
	if (GaveItem)
	{
		if (Item1 != -1)
			Player(CurrentSpeakingTo.Player).RemoveInvItem(Player(CurrentSpeakingTo.Player).Inventory[Item1], Choice->NeedAmount1);
		if (Item2 != -1)
			Player(CurrentSpeakingTo.Player).RemoveInvItem(Player(CurrentSpeakingTo.Player).Inventory[Item2], Choice->NeedAmount2);
		if (Item3 != -1)
			Player(CurrentSpeakingTo.Player).RemoveInvItem(Player(CurrentSpeakingTo.Player).Inventory[Item3], Choice->NeedAmount3);
	}
	if (Choice->Objectives)
	{
		Player(CurrentSpeakingTo.Player).SetObjectives(Choice->Objectives);
	}
	if (!GaveItem)
	{
		CurrentSpeakingTo.Player.cprint(Choice->TextNo);
	}
	else if (strcmp(Choice->TextOK, "") && strcmp(Choice->TextOK, "_"))
	{
		CurrentSpeakingTo.Player.cprint(Choice->TextOK);
	}
	if (Choice->Next < 0)
	{
		CurrentSpeaker.CurrentSpeech = -Choice->Next;
		if (!ConversationSlideshow)
		{
			StartSpeech(CurrentSpeaker.GetSpeech());
		}
	}
	else
	{
		if (Choice->Next)
		{
			CurrentSpeaker.CurrentSpeech = Choice->Next;
		}
		StopSpeech();
		ConversationSlideshow = false;
	}
}

//==========================================================================
//
//  GetDefaultDoorSound
//
//==========================================================================

name GetDefaultDoorSound(sector_t* Sector)
{
	int			i;
	name		SeqName = DefaultDoorSound;

	//	Search the front top textures of 2-sided lines on the door sector
	// for a door sound to use.
	for (i = 0; i < Sector->linecount; i++)
	{
		if (!Sector->lines[i]->backsector)
			continue;

		string TexName = va("%n", GetTextureName(XLevel.Sides[
			Sector->lines[i]->sidenum[0]].toptexture));
		if (StrStartsWith(TexName, "dors"))
		{
			SeqName = 'DoorStone';
		}
		else if (StrStartsWith(TexName, "dorml"))
		{
			SeqName = 'DoorLargeMetal';
		}
		else if (StrStartsWith(TexName, "dorwl"))
		{
			SeqName = 'DoorLargeWood';
		}
		else if (StrStartsWith(TexName, "dorw"))
		{
			SeqName = 'DoorSmallWood';
		}
	}

	return SeqName;
}

defaultproperties
{
	DefaultDoorSound = 'DoorSmallMetal';
	DefaultCeilingSound = 'CeilingNormal';
	DefaultSilentCeilingSound = 'CeilingSemiSilent';
	DefaultFloorSound = 'Floor';
	DefaultFloorAltSound = 'Floor';
	DefaultStairStepSound = 'Floor';
	DefaultPlatformSound = 'Platform';
	bTeleportNewMapBothSides = true;
	bCheckStrifeStartSpots = true;
	ExtPlayersBase = 5;
}
