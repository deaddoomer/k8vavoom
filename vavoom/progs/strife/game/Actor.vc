//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class Actor : Entity
	abstract;

// follow a player exlusively for 3 seconds
const int BASETHRESHOLD		= 100;

const float ONFLOORZ		= -99999.0;
const float ONCEILINGZ		= 99999.0;

const float
	MELEERANGE		= 64.0,
	PUNCHRANGE		= 80.0,
	MISSILERANGE	= (32.0 * 64.0),
	MAULERRANGE		= (33.0 * 64.0),
	ROBOTRANGE		= 264.0;

const float
	MAXMOVE			= 1050.0,
	STOPSPEED		= 2.1875,
	FRICTION		= 3.28125,
	FRICTION_LOW	= 0.95703125,
	FRICTION_WATER	= 3.0,

	BOUNCE_VAL		= 1.5,

	FLOATSPEED		= 140.0;

//  States
state IdleState;
state SeeState;
state MeleeState;
state MissileState;
state PainState;
state DyingState;
state DeathState;
state GibsDeathState;
state FireDeathState;
state DisruptDeathState;

//  Sounds
name SightSound;
name ActiveSound;
name AttackSound;
name PainSound;
name DeathSound;

//	Flags
bool bSpecial;			// call P_SpecialThing when touched
bool bShootable;		// Can be hit.
bool bStanding;			// Don't walk around.
bool bJustHit;			// try to attack right back
bool bJustAttacked;		// take at least one step before attacking
bool bSpawnCeiling;		// hang from ceiling instead of floor
// movement flags
bool bNeutral;			// Neutral characters (peasants and beggars)
bool bSlide;			// keep info about sliding along walls
bool bMissile;			// don't hit same species, explode on block
bool bDropped;			// dropped by a demon, not level spawned
bool bNoBlood;			// don't bleed when shot (use puff)
bool bCorpse;			// don't stop moving halfway off a step
bool bInFloat;			// floating to a height for a move, don't
						// auto float to target's height
bool bSkullFly;			// skull in flight
bool bCountKill;		// count towards intermission kill total
bool bFloorBounce;		// bounces off the floor
bool bCountItem;		//COUNTITEM	800000
bool bFriendly;			// Will fight on player's side
bool bUnknown2;			//8000000
bool bSpectral;			// Can be killed only with Sigil
bool bOnMobj;
bool bActivateImpact;	// an MF_MISSILE mobj can activate
						// SPAC_IMPACT
bool bActivatePushWall;	// mobj can push walls
bool bActivateMCross;	// can activate monster cross lines
bool bActivatePCross;	// can activate projectile cross lines
bool bDormant;			// thing is dormant
bool bWaterJump;
bool bNoDeathmatch;
bool bSpawnFlag8;
bool bSpawnFlag9;
bool bWindThrust;
bool bNoTeleport;
bool bPoisonDamage;		// Does poison damage (doesn't gib enemies).
bool bFireDamage;		// Causes fire damage.
bool bDisruptDamage;	// Disrupts enemies.
bool bInCombat;			// Actors in combat won't talk
bool bLookAllAround;	// Actor can see all around.
bool bStaticLight;		// Static light source.

//  Params
float Speed;
float StepSpeed;
float PainChance;
int SpawnHealth;
int GibsHealth;
name ClassName;

// Thing being chased/attacked (or NULL),
Actor Enemy;
// also the originator for missiles.
Actor Instigator;

int MissileDamage;	// For missiles

// Player number last looked for.
int LastLook;

// For nightmare respawn.
mthing_t SpawnSpot;

// Reaction time: if non 0, don't attack yet.
int ReactionCount;
// Used by player to freeze a bit after teleporting.
float ReactionTime;

// If >0, the target will be chased
// no matter what (even if shot)
int Threshold;

// Movement direction, movement generation (zig-zagging).
int MoveDir;	// 0-7
int MoveCount;	// when 0, select a new dir

// Identifier in conversation scripts, originaly index into mobjinfo.
int ConversationID;
int CurrentSpeech;	// Current speech index.

float bombdamage;

float teleport_x;
float teleport_y;

// Height if not aiming up or down
// ???: use slope for monsters?
float aim_z;
float aim_range;
float aim_slope;
TVec aim_dir;
float aim_topslope;
float aim_bottomslope;	// slopes to top and bottom of target
Actor linetarget;	// who got hit (or NULL)
float aim_range2d;

float shoot_range;
TVec shoot_origin;
TVec shoot_dir;
int la_damage;
classid shootPuffType;
TVec shoot_linestart;
TVec shoot_lineend;

// Static light parameters.
TVec LightOffset;
int LightColour;
float LightRadius;
int ExplodeEffect;

//===========================================================================
//
//  Spawn
//
//===========================================================================

Actor Spawn(classid type, TVec AOrigin)
{
	Actor A;

	A = Actor(NewMobjThinker(type));

	A.Origin = AOrigin;
	A.OnMapSpawn(NULL);
	return A;
}

//==========================================================================
//
//  TouchSpecial
//
//==========================================================================

void TouchSpecial(Actor Toucher)
{
}

//==========================================================================
//
//  SetOrigin2
//
//==========================================================================

void SetOrigin2(TVec origin)
{
	Origin = origin;

	// set subsector and/or block links
	LinkToWorld();

	if (origin.z == ONFLOORZ)
	{
		Origin.z = FloorZ;
	}
	else if (origin.z == ONCEILINGZ)
	{
		Origin.z = CeilingZ - Height;
	}

	if (bFloorClip && TerrainType(Floor->pic) == 3 && Origin.z == FloorZ)
	{
		FloorClip = 12.0;
	}
	else
	{
		FloorClip = 0.0;
	}
}

//==========================================================================
//
//	OnMapSpawn
//
//==========================================================================

void OnMapSpawn(mthing_t * mthing)
{
	if (bNoDeathmatch && Level.Game.deathmatch)
	{
		Remove();
		return;
	}

	SpawnHealth = Health;
	bCheckLineBlocking = false;
	bCheckLineBlockMonsters = false;
	if (!bMissile)
	{
		bCheckLineBlocking = true;
		if (Class != StrifePlayer && !bSpectral)
		{
			bCheckLineBlockMonsters = true;
		}
	}

	if (bMissile)
	{
		MaxStepHeight = 4.0;
	}
	else if (bNoBlood)
	{
		MaxStepHeight = 24.0;
	}

	if (Level.Game.gameskill == sk_nightmare)
	{
		ReactionCount = 0;
	}

	LastLook = P_Random() % MAXPLAYERS;
	// do not set the state with P_SetMobjState,
	// because action routines can not be called yet
	SetInitialState(IdleState);

	if (mthing)
	{
		float x;
		float y;
		float z;

		Level.CopyMThing(mthing, &SpawnSpot);

		x = mthing->x;
		y = mthing->y;
		if (bSpawnCeiling)
			z = ONCEILINGZ;
		else
			z = ONFLOORZ;
		SetOrigin2(vector(x, y, z));
		if (z == ONFLOORZ)
		{
			Origin.z += mthing->height;
		}
		else if (z == ONCEILINGZ)
		{
			Origin.z -= mthing->height;
		}
		LinkToWorld();

		TID = mthing->tid;
		Special = mthing->special;
		Args[0] = mthing->arg1;
		Args[1] = mthing->arg2;
		Args[2] = mthing->arg3;
		Args[3] = mthing->arg4;
		Args[4] = mthing->arg5;
		if (StateTime > 0.0)
			StateTime = 0.1 + Random() * StateTime;
		if (bCountKill)
			Level.Game.level->totalkills++;

		Angles.yaw = itof(45 * (mthing->angle / 45));
		if (mthing->options & StrifeLevelInfo::MTF_AMBUSH)
		{
			bStanding = true;
		}
		if (mthing->options & StrifeLevelInfo::MTF_DORMANT)
		{
			bDormant = true;
			StateTime = -1.0;
		}
	}
	else
	{
		SetOrigin2(Origin);
	}

	if (bStaticLight && mthing && !TID)
	{
		if (LightColour == 0xffffffff)
		{
			Level.AddStaticLight(Origin + LightOffset, mthing->arg1 ?
				itof(mthing->arg1) * 8.0 : LightRadius);
		}
		else
		{
			Level.AddStaticLightRGB(Origin + LightOffset, mthing->arg1 ?
				itof(mthing->arg1) * 8.0 : LightRadius, LightColour);
		}
	}
}

//==========================================================================
//
//  ExplodeMissile
//
//==========================================================================

void ExplodeMissile()
{
	Velocity = vector(0.0, 0.0, 0.0);

	SetState(DeathState);

	StateTime -= Random() * 0.1;

	if (StateTime < 0.1)
		StateTime = 0.1;

	bMissile = false;
	if (bFloorBounce)
		bFloorBounce = false;

	if (DeathSound)
		PlaySound(DeathSound, CHAN_VOICE);

	if (Effects & StrifeDefs::EF_DLIGHT_MASK)
	{
		MSG_Select(MSG_SV_DATAGRAM);
		MSG_WriteByte(StrifeDefs::svc_explosion);
		MSG_WriteByte(Effects & StrifeDefs::EF_DLIGHT_MASK);
		MSG_WriteShort(ftoi(Origin.x));
		MSG_WriteShort(ftoi(Origin.y));
		MSG_WriteShort(ftoi(Origin.z));
		Effects &= ~StrifeDefs::EF_DLIGHT_MASK;
	}
}

//==========================================================================
//
//  CheckMissileSpawn
//
//  Moves the missile forward a bit and possibly explodes it right there.
//
//==========================================================================

bool CheckMissileSpawn()
{
	StateTime -= Random() * 0.1;
	if (StateTime < 0.1)
		StateTime = 0.1;

	// move a little forward so an angle can
	// be computed if it immediately explodes
	Origin += Velocity * 0.0142857143;

	if (!TryMove(Origin))
	{
		ExplodeMissile();
		return false;
	}
	return true;
}

//==========================================================================
//
//	Died
//
//==========================================================================

void Died(Actor source)
{
	int SpeechNum;
	RogueConSpeech *Speech;
	classid DropItemType;
	Actor A;

	if (bIsPlayer && !strcmp(ARR2STR(Level.Game.level->mapname), "MAP29"))
	{
		//	Start sad finale.
		MSG_Select(MSG_SV_RELIABLE);
		MSG_WriteByte(StrifeDefs::svc_finale_type);
		MSG_WriteByte(1);
		G_Completed(-1, -1, 0);
	}

	bShootable = false;
	bFloat = false;
	bSkullFly = false;

	if (!bSpawnCeiling)
		bNoGravity = false;

	bDropOff = true;
	bCorpse = true;
	Height /= 4.0;

	if (bCountKill && Special)
	{
		// Initiate monster death actions
		Level.ExecuteActionSpecial(Special, Args[0], Args[1], Args[2], Args[3],
			Args[4], NULL, 0, self);
	}
	if (source && source.bIsPlayer)
	{
		// count for intermission
		if (bCountKill)
			source.Player.KillCount++;

		if (bIsPlayer)
		{
			source.Player.FragsStats[P_GetPlayerNum(Player)]++;
			if (source == self)
			{
				Player.Frags--;
			}
			else
			{
				source.Player.Frags++;
			}
		}
	}
	else if (!Level.Game.netgame && bCountKill)
	{
		// count all monster deaths,
		// even those caused by other monsters
		Level.Game.Players[0].KillCount++;
	}
	if (bCountKill)
		Level.Game.level->currentkills++;

	if (bIsPlayer)
	{
		// count environment kills against you
		if (!source)
		{
			Player.FragsStats[P_GetPlayerNum(Player)]++;
			Player.Frags--;
		}

		bSolid = false;
		Player.PlayerState = PST_DEAD;
		Player(Player).DropWeapon();
#ifdef FIXME
		if (Player == Level.Game.Players[consoleplayer] && automapactive)
		{
			// don't die in auto map,
			// switch view prior to dying
			AM_Stop();
		}
#endif
	}

	if (bFireDamage && FireDeathState)
	{
		SetState(FireDeathState);
		if (bIsPlayer)
		{
			Player.ViewEnts[0].SetState(
				Weapon(Player.ViewEnts[0]).FireDeathWaveState);
		}
	}
	else if (bDisruptDamage && DisruptDeathState)
	{
		SetState(DisruptDeathState);
		PlaySound('human/disrupt', CHAN_BODY);
	}
	else if (Health < GibsHealth && GibsDeathState)
	{
		SetState(GibsDeathState);
	}
	else
	{
		SetState(DeathState);
	}
	StateTime -= Random() * 0.1;

	if (StateTime < 0.1)
		StateTime = 0.1;

	SpeechNum = GetSpeech();
	if (SpeechNum)
	{
		//	Drop stuff as determined by conversation.
		if (SpeechNum < 0)
		{
			Speech = &XLevel.GenericSpeeches[-SpeechNum - 1];
		}
		else
		{
			Speech = &XLevel.LevelSpeeches[SpeechNum - 1];
		}
		DropItemType = StrifeLevelInfo(Level).GetClassFromID(Speech->DropItem);
		if (DropItemType)
		{
			A = Spawn(DropItemType, Origin + vector(0.0, 0.0, Height / 2.0));

			if (Pickup(A) && Pickup(A).bDropAutoGive)
			{
				Pickup(A).HandlePickup(source);
				A.Remove();
			}
			else
			{
				A.Velocity.x = (Random() - Random()) * 35.0;
				A.Velocity.y = (Random() - Random()) * 35.0;
				A.Velocity.z = (5.0 + Random() * 4.0) * 35.0;
				A.bDropped = true;	// special versions of items
			}
		}
	}
	//  This class of rebel always drops a clip, unless it already did.
	if (Class == Rebel && !ItemAmmoClipOfBullets(A))
	{
		A = Spawn(ItemAmmoClipOfBullets, Origin + vector(0.0, 0.0, Height / 2.0));
		A.Velocity.x = (Random() - Random()) * 35.0;
		A.Velocity.y = (Random() - Random()) * 35.0;
		A.Velocity.z = (5.0 + Random() * 4.0) * 35.0;
		A.bDropped = true;	// special versions of items
	}
	if (Class == Crusader)
	{
		A = Spawn(ItemAmmoEnergyPod, Origin + vector(0.0, 0.0, Height / 2.0));
		A.Velocity.x = (Random() - Random()) * 35.0;
		A.Velocity.y = (Random() - Random()) * 35.0;
		A.Velocity.z = (5.0 + Random() * 4.0) * 35.0;
		A.bDropped = true;	// special versions of items
	}
	if (Class == Bishop)
	{
		A = Spawn(ItemAmmoCrateOfMissiles, Origin + vector(0.0, 0.0, Height / 2.0));
		A.Velocity.x = (Random() - Random()) * 35.0;
		A.Velocity.y = (Random() - Random()) * 35.0;
		A.Velocity.z = (5.0 + Random() * 4.0) * 35.0;
		A.bDropped = true;	// special versions of items
	}
}

//==========================================================================
//
//  AutoUseHealth
//
//==========================================================================

void AutoUseHealth(int saveHealth)
{
	int i, j;
	int count;

	for (i = 0; i < StrifeDefs::NUMINVITEMS - 1; i++)
	{
		if (Player(Player).Inventory[i] && i == StrifeDefs::ITEM_MedicalKit
			&& Player(Player).Inventory[i] * 25 >= saveHealth)
		{
			// Use medical kits
			Health += 25;
			Player(Player).RemoveInvItem(i, 1);
			Player.MO.PlaySound('misc/invuse', CHAN_BODY);
		}
		else if (Player(Player).Inventory[i] && i == StrifeDefs::ITEM_MedPatch
			&& Player(Player).Inventory[i] * 10 >= saveHealth)
		{
			Health += 10;
			Player(Player).RemoveInvItem(i, 1);
			Player.MO.PlaySound('misc/invuse', CHAN_BODY);
		}
	}
	Player.Health = Health;
}

//==========================================================================
//
//  AutoUseArmor
//
//==========================================================================

void AutoUseArmor()
{
	int i;
	int count;

	for (i = 0; i < StrifeDefs::NUMINVITEMS - 1; i++)
	{
		if (Player(Player).Inventory[i] && i == StrifeDefs::ITEM_MetalArmor)
		{
			// Use metal armor
			Player(Player).GiveArmor(2);
			Player(Player).RemoveInvItem(i, 1);
		}
		else if (Player(Player).Inventory[i] && i == StrifeDefs::ITEM_LeatherArmor)
		{
			// Use leather armor
			Player(Player).GiveArmor(1);
			Player(Player).RemoveInvItem(i, 1);
		}
	}
}

//==========================================================================
//
//  Damage
//
//  Damages both enemies and players.
//  "inflictor" is the thing that caused the damage, creature or missile,
// can be NULL (slime, etc).
//  "source" is the thing to target after taking damage, creature or NULL.
//  Source and inflictor are the same for melee attacks. Source can be NULL
// for slime, barrel explosions and other environmental stuff.
//
//==========================================================================

void Damage(Actor inflictor, Actor source, int damage)
{
	int saved;

	if (!bShootable)
		return;	// shouldn't happen...

	if (Health <= 0)
		return;

	//	Spectral targets only take damage from spectral projectiles.
	if (bSpectral)
	{
		if (!inflictor || !inflictor.bSpectral)
		{
			if (MissileState)
			{
				SetState(MissileState);
			}
			return;
		}
	}

	if (bSkullFly)
	{
		Velocity = vector(0.0, 0.0, 0.0);
	}
	if (bDormant)
	{
		// Invulnerable, and won't wake up
		return;
	}

	if (bIsPlayer && Level.Game.gameskill == sk_baby)
		damage >>= 1;	// take half damage in trainer mode

	if (inflictor)
	{
		damage = inflictor.DoSpecialDamage(self, damage);
		if (damage == -1)
		{
			return;
		}
	}
	damage = TakeSpecialDamage(inflictor, source, damage);
	if (damage == -1)
	{
		return;
	}

	// Some close combat weapons should not
	// inflict thrust and push the victim out of reach,
	// thus kick away unless using the chainsaw.
	if (inflictor && bColideWithThings)
	{
		Velocity += (500.0 * itof(damage > 100 ? 100 : damage) / Mass) *
			Normalise(MobjCenter(self) - MobjCenter(inflictor));
	}

	if (inflictor && inflictor.bPoisonDamage && bNoBlood)
	{
		// Don't damage actors that don't take poison damage
		return;
	}

	if (inflictor && inflictor.Class == InquisitorGrenade && Class == Inquisitor)
	{
		// Inquisitor grenades don't damage inquisitors
		return;
	}

	// player specific
	if (bIsPlayer)
	{
		if (inflictor && inflictor.bFireDamage && Player(Player).Powers[pw_ironfeet])
		{
			// If the player wears an environmental suit it's not
			// damaged by fire damage
			return;
		}

		//	End of game hell hack.
		if ((Sector->special & SECSPEC_BASE_MASK) ==
			SECSPEC_DamageSuperHellslimeExit && damage >= Health)
		{
			damage = Health - 1;
		}

		// Below certain threshold,
		// ignore damage in GOD mode, or with INVUL power.
		if (damage < 1000 && ((Player(Player).Cheats & StrifeDefs::CF_GODMODE) ||
			Player(Player).Powers[pw_invulnerability]))
		{
			return;
		}

		if (Player(Player).ArmorType)
		{
			if (Player(Player).ArmorType == 1)
				saved = damage / 3;
			else
				saved = damage / 2;

			if (Player(Player).ArmorPoints <= saved)
			{
				// armor is used up
				saved = Player(Player).ArmorPoints;
				Player(Player).ArmorType = 0;
				// Try to use some inventory armor
				AutoUseArmor();
			}
			Player(Player).ArmorPoints -= saved;
			damage -= saved;
		}
		if (Player.Health < 50 || damage >= Player.Health)
		{
			// Try to use some inventory health
			AutoUseHealth(damage - Health + 1);
		}
		Player.Health -= damage;	// mirror mobj health here for Dave
		if (Player.Health < 0)
			Player.Health = 0;

		Player(Player).Attacker = source;
		Player(Player).DamageFlash += itof(damage) / 35.0;	// add damage after armor / invuln

		if (Player(Player).DamageFlash > 3.0)
			Player(Player).DamageFlash = 3.0;	// teleport stomp does 10k points...
	}

	// do the damage    
	Health -= damage;
	if (Health <= 0)
	{
		if (inflictor)
		{
			if (inflictor.bPoisonDamage)
			{
				//	Prevent gibing animation.
				Health = -1;
			}
			else if (inflictor.bFireDamage)
			{
				bFireDamage = true;
			}
			else if (inflictor.bDisruptDamage)
			{
				bDisruptDamage = true;
			}
		}
		Died(source);
		return;
	}

	if ((Random() < PainChance) && !bSkullFly)
	{
		bJustHit = true;	// fight back!
		SetState(PainState);
	}

	ReactionCount = 0;	// we're awake now...

	if ((!Threshold) && source && source != self &&
		(Level.Game.deathmatch || source.bFriendly != bFriendly))
	{
		// if not intent on another player,
		// chase after this one
		Enemy = source;
		Threshold = BASETHRESHOLD;
		if (State == IdleState && SeeState)
		{
			SetState(SeeState);
		}
	}
}

//==========================================================================
//
//  DoSpecialDamage
//
//==========================================================================

int DoSpecialDamage(Actor Victim, int damage)
{
	return damage;
}

//==========================================================================
//
//  TakeSpecialDamage
//
//==========================================================================

int TakeSpecialDamage(Actor inflictor, Actor source, int damage)
{
	return damage;
}

//==========================================================================
//
//  NightmareRespawn
//
//==========================================================================

void NightmareRespawn()
{
	float x;
	float y;
	float z;
	Actor A;
	mthing_t *mthing;

	x = SpawnSpot.x;
	y = SpawnSpot.y;

	// somthing is occupying it's position?
	if (!CheckPosition(vector(x, y, ONFLOORZ)))
		return;	// no respwan

	// spawn a teleport fog at old spot
	// because of removal of the body?
	A = Spawn(TeleportFog, vector(Origin.x, Origin.y, ONFLOORZ));

	// initiate teleport sound
	A.PlaySound('misc/teleport', CHAN_BODY);

	// spawn a teleport fog at the new spot
	A = Spawn(TeleportFog, vector(x, y, ONFLOORZ));

	A.PlaySound('misc/teleport', CHAN_BODY);

	// spawn the new monster
	mthing = &SpawnSpot;

	// spawn it
	if (bSpawnCeiling)
		z = ONCEILINGZ;
	else
		z = ONFLOORZ;

	// inherit attributes from deceased one
	A = Spawn(Class, vector(x, y, z));
	Level.CopyMThing(&SpawnSpot, &A.SpawnSpot);
	A.Angles.yaw = itof(45 * (mthing->angle / 45));

	if (mthing->options & StrifeLevelInfo::MTF_AMBUSH)
		A.bStanding = true;

	A.ReactionCount = 18;

	// remove the old monster,
	Remove();
}

//==========================================================================
//
//  Thrust
//
//==========================================================================

void Thrust(float angle, float move)
{
	Velocity.x += move * cos(angle) * 35.0;
	Velocity.y += move * sin(angle) * 35.0;
}

//==========================================================================
//
//  TestLocation
//
//  Returns true if the mobj is not blocked by anything at its current
// location, otherwise returns false.
//
//==========================================================================

bool TestLocation()
{
	if (!bColideWithThings && !bColideWithWorld)
		return true;

	if (CheckPosition(Origin))
	{
		// XY is ok, now check Z
		if ((Origin.z < FloorZ) || (Origin.z + Height > CeilingZ))
		{
			// Bad Z
			return false;
		}
		return true;
	}
	return false;
}

//==========================================================================
//
//	Touch
//
//==========================================================================

bool Touch(Entity InOther)
{
	bool solid;
	int damage;
	Actor Other;

	Other = Actor(InOther);
	if (!Other.bSolid && !Other.bSpecial && !Other.bShootable)
		return true;

	// check for skulls slamming into things
	if (bSkullFly)
	{
		damage = ((P_Random() % 8) + 1) * MissileDamage;
		Other.Damage(self, self, damage);
		bSkullFly = false;
		Velocity = vector(0.0, 0.0, 0.0);
		SetState(IdleState);
		return false;	// stop moving
	}

	// missiles can hit other things
	if (bMissile)
	{
		if (Instigator && (Instigator.Class == Other.Class))
		{
			// Don't hit same species as originator.
			if (Other == Instigator)
				return true;

			if (Other.Class != StrifePlayer)
			{
				// Explode, but do no damage.
				// Let players missile other players.
				return false;
			}
		}

		//	Don't hit spectres with non-sigil weapons.
		if (Other.bSpectral && !bSpectral)
		{
			return true;
		}

		if (!Other.bShootable)
		{
			// didn't do any damage
			return !Other.bSolid;
		}

		// damage / explode
		damage = ((P_Random() % 4) + 1) * MissileDamage;
		Other.Damage(self, Instigator, damage);
		// don't traverse any more
		return false;
	}

	// check for special pickup
	if (Other.bSpecial)
	{
		solid = Other.bSolid;
		Other.TouchSpecial(self);
		return !solid;
	}

	//return !Other.bSolid || Other.bNoClip;
	return !Other.bSolid;
}

//===========================================================================
//
//	CheckForPushSpecial
//
//===========================================================================

void CheckForPushSpecial(line_t * line, int side)
{
	if (line->special)
	{
		if (bActivatePushWall)
		{
			StrifeLevelInfo(Level).ActivateLine(line, self, side, SPAC_PUSH);
		}
		else if (bActivateImpact)
		{
			StrifeLevelInfo(Level).ActivateLine(line,
				bMissile ? Instigator : self, side, SPAC_IMPACT);
		}
	}
}

//==========================================================================
//
//	BlockedByLine
//
//==========================================================================

void BlockedByLine(line_t * ld)
{
	if (bBlasted)
	{
		Damage(none, none, ftoi(Mass) >> 5);
	}
	CheckForPushSpecial(ld, 0);
}

//==========================================================================
//
//  PushLine
//
//==========================================================================

void PushLine()
{
	if (bColideWithWorld)
	{
		int numSpecHitTemp;
		line_t *ld;
		int side;

		if (bBlasted)
		{
			Damage(none, none, ftoi(Mass) >> 5);
		}
		numSpecHitTemp = Level.Game.tmtrace->NumSpecHit;
		while (numSpecHitTemp > 0)
		{
			numSpecHitTemp--;
			// see if the line was crossed
			ld = Level.Game.tmtrace->SpecHit[numSpecHitTemp];
			side = PointOnPlaneSide(Origin, ld);
			CheckForPushSpecial(ld, side);
		}
	}
}

//==========================================================================
//
//	CrossSpecialLine
//
//==========================================================================

void CrossSpecialLine(line_t *ld, int side)
{
	if (bIsPlayer)
	{
		StrifeLevelInfo(Level).ActivateLine(ld, self, side, SPAC_CROSS);
	}
	else if (bActivateMCross)
	{
		StrifeLevelInfo(Level).ActivateLine(ld, self, side, SPAC_MCROSS);
	}
	else if (bActivatePCross)
	{
		StrifeLevelInfo(Level).ActivateLine(ld, self, side, SPAC_PCROSS);
	}
	else if (ld->special == LNSPEC_Teleport)
	{
		//	Teleport hack
		StrifeLevelInfo(Level).ActivateLine(ld, self, side, SPAC_MCROSS);
	}
}

//===========================================================================
//
//  GiveInventory
//
//===========================================================================

void GiveInventory(name ItemName, int Amount)
{
	if (!bIsPlayer)
	{
		return;
	}

	//	Stamina upgrade.
	if (ItemName == 'UpgradeStamina')
	{
		Player(Player).Stamina += 10;
		Player(Player).GiveBody(200);
	}

	//	Accuracy upgrade.
	if (ItemName == 'UpgradeAccuracy')
	{
		Player(Player).Accuracy += 10;
	}

	//	Quest items.
	if (ItemName == 'QuestItem1')
	{
		Player(Player).GiveQuest(QUEST_KilledBeldin);
	}
	if (ItemName == 'QuestItem2')
	{
		Player(Player).GiveQuest(QUEST_StoleChalice);
	}
	if (ItemName == 'QuestItem3')
	{
		Player(Player).GiveQuest(QUEST_Prison);
	}
	if (ItemName == 'QuestItem4')
	{
		Player(Player).GiveQuest(QUEST_GovPowerCoupling);
	}
	if (ItemName == 'QuestItem5')
	{
		Player(Player).GiveQuest(QUEST_GovDerwin);
	}
	if (ItemName == 'QuestItem6')
	{
		Player(Player).GiveQuest(QUEST_BrokePowerCoupling);
	}
	if (ItemName == 'QuestItem7')
	{
		Player(Player).GiveQuest(QUEST_7);
	}
	if (ItemName == 'QuestItem8')
	{
		Player(Player).GiveQuest(QUEST_GotBrokenPowerCoupling);
	}
	if (ItemName == 'QuestItem9')
	{
		Player(Player).GiveQuest(QUEST_GotDerwinsEar);
	}
	if (ItemName == 'QuestItem10')
	{
		Player(Player).GiveQuest(QUEST_GotPrisonPass);
	}
	if (ItemName == 'QuestItem11')
	{
		Player(Player).GiveQuest(QUEST_GotPrisonKey);
	}
	if (ItemName == 'QuestItem12')
	{
		Player(Player).GiveQuest(QUEST_GotSeveredHand);
	}
	if (ItemName == 'QuestItem13')
	{
		Player(Player).GiveQuest(QUEST_FreedPrisoners);
	}
	if (ItemName == 'QuestItem14')
	{
		Player(Player).GiveQuest(QUEST_BlownUpCrystal);
	}
	if (ItemName == 'QuestItem15')
	{
		Player(Player).GiveQuest(QUEST_GotGuardUniform);
	}
	if (ItemName == 'QuestItem16')
	{
		Player(Player).GiveQuest(QUEST_BlownUpGates);
	}
	if (ItemName == 'QuestItem17')
	{
		Player(Player).GiveQuest(QUEST_VisitOracle);
	}
	if (ItemName == 'QuestItem18')
	{
		Player(Player).GiveQuest(QUEST_GotOraclePass);
	}
	if (ItemName == 'QuestItem19')
	{
		Player(Player).GiveQuest(QUEST_DestroyComputer);
	}
	if (ItemName == 'QuestItem20')
	{
		Player(Player).GiveQuest(QUEST_20);
	}
	if (ItemName == 'QuestItem21')
	{
		Player(Player).GiveQuest(QUEST_KilledBishop);
	}
	if (ItemName == 'QuestItem22')
	{
		Player(Player).GiveQuest(QUEST_KillMacil);
	}
	if (ItemName == 'QuestItem23')
	{
		Player(Player).GiveQuest(QUEST_KilledOracle);
	}
	if (ItemName == 'QuestItem24')
	{
		Player(Player).GiveQuest(QUEST_KilledMacil);
	}
	if (ItemName == 'QuestItem25')
	{
		Player(Player).GiveQuest(QUEST_Factory);
	}
	if (ItemName == 'QuestItem26')
	{
		Player(Player).GiveQuest(QUEST_KilledLoremaster);
	}
	if (ItemName == 'QuestItem27')
	{
		Player(Player).GiveQuest(QUEST_BlownUpComputer);
	}
	if (ItemName == 'QuestItem28')
	{
		Player(Player).GiveQuest(QUEST_GotCatacombKey);
	}
	if (ItemName == 'QuestItem29')
	{
		Player(Player).GiveQuest(QUEST_FreedWorkers);
	}
	if (ItemName == 'QuestItem30')
	{
		Player(Player).GiveQuest(QUEST_30);
	}
	if (ItemName == 'QuestItem31')
	{
		Player(Player).GiveQuest(QUEST_31);
	}
}

//===========================================================================
//
//  CheckInventory
//
//===========================================================================

int CheckInventory(name ItemName)
{
	//	Check if it's a player.
	if (!bIsPlayer)
	{
		return 0;
	}

	//	Weapons.
	if (ItemName == 'FlameThrower')
	{
		return Player(Player).WeaponOwned[StrifeDefs::wp_flame];
	}
	if (ItemName == 'Sigil')
	{
		return Player(Player).WeaponOwned[StrifeDefs::wp_sigil];
	}

	//	Inventory items.
	if (ItemName == 'OfferingChalice')
	{
		return Player(Player).Inventory[StrifeDefs::ITEM_OfferingChalice];
	}
	if (ItemName == 'OfficersUniform')
	{
		return Player(Player).Inventory[StrifeDefs::ITEM_OfficersUniform];
	}

	//	Quest items.
	if (ItemName == 'QuestItem1')
	{
		return Player(Player).Quests & (1 << 0) ? 1 : 0;
	}
	if (ItemName == 'QuestItem2')
	{
		return Player(Player).Quests & (1 << 1) ? 1 : 0;
	}
	if (ItemName == 'QuestItem3')
	{
		return Player(Player).Quests & (1 << 2) ? 1 : 0;
	}
	if (ItemName == 'QuestItem4')
	{
		return Player(Player).Quests & (1 << 3) ? 1 : 0;
	}
	if (ItemName == 'QuestItem5')
	{
		return Player(Player).Quests & (1 << 4) ? 1 : 0;
	}
	if (ItemName == 'QuestItem6')
	{
		return Player(Player).Quests & (1 << 5) ? 1 : 0;
	}
	if (ItemName == 'QuestItem7')
	{
		return Player(Player).Quests & (1 << 6) ? 1 : 0;
	}
	if (ItemName == 'QuestItem8')
	{
		return Player(Player).Quests & (1 << 7) ? 1 : 0;
	}
	if (ItemName == 'QuestItem9')
	{
		return Player(Player).Quests & (1 << 8) ? 1 : 0;
	}
	if (ItemName == 'QuestItem10')
	{
		return Player(Player).Quests & (1 << 9) ? 1 : 0;
	}
	if (ItemName == 'QuestItem11')
	{
		return Player(Player).Quests & (1 << 10) ? 1 : 0;
	}
	if (ItemName == 'QuestItem12')
	{
		return Player(Player).Quests & (1 << 11) ? 1 : 0;
	}
	if (ItemName == 'QuestItem13')
	{
		return Player(Player).Quests & (1 << 12) ? 1 : 0;
	}
	if (ItemName == 'QuestItem14')
	{
		return Player(Player).Quests & (1 << 13) ? 1 : 0;
	}
	if (ItemName == 'QuestItem15')
	{
		return Player(Player).Quests & (1 << 14) ? 1 : 0;
	}
	if (ItemName == 'QuestItem16')
	{
		return Player(Player).Quests & (1 << 15) ? 1 : 0;
	}
	if (ItemName == 'QuestItem17')
	{
		return Player(Player).Quests & (1 << 16) ? 1 : 0;
	}
	if (ItemName == 'QuestItem18')
	{
		return Player(Player).Quests & (1 << 17) ? 1 : 0;
	}
	if (ItemName == 'QuestItem19')
	{
		return Player(Player).Quests & (1 << 18) ? 1 : 0;
	}
	if (ItemName == 'QuestItem20')
	{
		return Player(Player).Quests & (1 << 19) ? 1 : 0;
	}
	if (ItemName == 'QuestItem21')
	{
		return Player(Player).Quests & (1 << 20) ? 1 : 0;
	}
	if (ItemName == 'QuestItem22')
	{
		return Player(Player).Quests & (1 << 21) ? 1 : 0;
	}
	if (ItemName == 'QuestItem23')
	{
		return Player(Player).Quests & (1 << 22) ? 1 : 0;
	}
	if (ItemName == 'QuestItem24')
	{
		return Player(Player).Quests & (1 << 23) ? 1 : 0;
	}
	if (ItemName == 'QuestItem25')
	{
		return Player(Player).Quests & (1 << 24) ? 1 : 0;
	}
	if (ItemName == 'QuestItem26')
	{
		return Player(Player).Quests & (1 << 25) ? 1 : 0;
	}
	if (ItemName == 'QuestItem27')
	{
		return Player(Player).Quests & (1 << 26) ? 1 : 0;
	}
	if (ItemName == 'QuestItem28')
	{
		return Player(Player).Quests & (1 << 27) ? 1 : 0;
	}
	if (ItemName == 'QuestItem29')
	{
		return Player(Player).Quests & (1 << 28) ? 1 : 0;
	}
	if (ItemName == 'QuestItem30')
	{
		return Player(Player).Quests & (1 << 29) ? 1 : 0;
	}
	if (ItemName == 'QuestItem31')
	{
		return Player(Player).Quests & (1 << 30) ? 1 : 0;
	}

	//	I don't know what it is.
	return 0;
}

//===========================================================================
//
//  GetSigilPieces
//
//===========================================================================

int GetSigilPieces()
{
	if (bIsPlayer && Player(Player).WeaponOwned[StrifeDefs::wp_sigil])
	{
		return Player(Player).Sigil + 1;
	}
	return 0;
}

//**************************************************************************
//
//  OBJECT MOVEMENT
//
//**************************************************************************

//==========================================================================
//
//  XYMovement
//
//==========================================================================

void XYMovement(float DeltaTime)
{
	float ptryx;
	float ptryy;
	float xmove;
	float ymove;
	int special;

	if (bWindThrust)
	{
		special = Sector->special & SECSPEC_BASE_MASK;
		switch (special)
		{
		case SECSPEC_WindEastSlow:
		case SECSPEC_WindEastMedium:
		case SECSPEC_WindEastFast:
			Thrust(0.0, MainGameInfo(Level.Game).windTab[special - SECSPEC_WindEastSlow]);
			break;
		case SECSPEC_WindNorthSlow:
		case SECSPEC_WindNorthMedium:
		case SECSPEC_WindNorthFast:
			Thrust(90.0, MainGameInfo(Level.Game).windTab[special - SECSPEC_WindNorthSlow]);
			break;
		case SECSPEC_WindSouthSlow:
		case SECSPEC_WindSouthMedium:
		case SECSPEC_WindSouthFast:
			Thrust(270.0, MainGameInfo(Level.Game).windTab[special - SECSPEC_WindSouthSlow]);
			break;
		case SECSPEC_WindWestSlow:
		case SECSPEC_WindWestMedium:
		case SECSPEC_WindWestFast:
			Thrust(180.0, MainGameInfo(Level.Game).windTab[special - SECSPEC_WindWestSlow]);
			break;
		}
	}
	if (Velocity.x > MAXMOVE)
		Velocity.x = MAXMOVE;
	else if (Velocity.x < -MAXMOVE)
		Velocity.x = -MAXMOVE;

	if (Velocity.y > MAXMOVE)
		Velocity.y = MAXMOVE;
	else if (Velocity.y < -MAXMOVE)
		Velocity.y = -MAXMOVE;

	xmove = Velocity.x * DeltaTime;
	ymove = Velocity.y * DeltaTime;

	do
	{
		if (xmove > MAXMOVE / (35.0 * 2.0) || ymove > MAXMOVE / (35.0 * 2.0))
		{
			ptryx = Origin.x + xmove / 2.0;
			ptryy = Origin.y + ymove / 2.0;
			xmove /= 2.0;
			ymove /= 2.0;
		}
		else
		{
			ptryx = Origin.x + xmove;
			ptryy = Origin.y + ymove;
			xmove = 0.0;
			ymove = 0.0;
		}

		if (!TryMove(vector(ptryx, ptryy, Origin.z)))
		{
			// blocked move
			if (bIsPlayer)
			{
				// try to slide along it
				SlideMove();
			}
			else if (bMissile)
			{
				if (bFloorBounce && ReactionCount > 0)
				{
					//  Bounce against walls and ofjects
					if (Level.Game.tmtrace->BlockingMobj)
					{
						if ((!Level.Game.tmtrace->BlockingMobj.bIsPlayer))
						{
							float speed;
							float angle;

							angle = AngleMod360(
								atan2(Origin.y - Level.Game.tmtrace->BlockingMobj.Origin.y,
								Origin.x - Level.Game.tmtrace->BlockingMobj.Origin.x) +
								(Random() * 16.0 - 8.0));
							speed = Length(Velocity);
							speed = speed * 0.50;
							Angles.yaw = angle;
							Velocity.x = speed * cos(angle);
							Velocity.y = speed * sin(angle);
							if (PainSound)
							{
								PlaySound(PainSound, CHAN_VOICE);
							}
							A_DecReactionCount();
							// Hit killable objects, but don't explode
							if (Actor(Level.Game.tmtrace->BlockingMobj).bCountKill)
								Damage(self, self.Instigator, MissileDamage);

						}
					}
					else
					{
						// Struck a wall
						BounceWall(BOUNCE_VAL);
						if (PainSound)
						{
							PlaySound(PainSound, CHAN_VOICE);
						}
						A_DecReactionCount();
					}
					if (IsDestroyed())
					{
						return;	// mobj was removed
					}
					A_DecReactionCount();
					return;
				}

				// explode a missile
				if (Level.Game.tmtrace->CeilingLine && Level.Game.tmtrace->CeilingLine->backsector &&
					Level.Game.tmtrace->CeilingLine->backsector->ceiling.pic == Level.Game.skyflatnum)
				{
					// Hack to prevent missiles exploding
					// against the sky.
					// Does not handle sky floors.
					Remove();
					return;
				}
				ExplodeMissile();
			}
			else
			{
				Velocity.x = 0.0;
				Velocity.y = 0.0;
			}
		}
	}
	while (xmove || ymove);
}

//==========================================================================
//
//	ZMovement
//
//==========================================================================

void ZMovement(float DeltaTime)
{
	float dist;
	float delta;
	float vdot;

	// check for smooth step up
	if (bIsPlayer && Origin.z < FloorZ)
	{
		Player(Player).ViewHeight -= FloorZ - Origin.z;
		Player(Player).DeltaViewHeight = (Player::VIEWHEIGHT - Player(Player).ViewHeight) * 4.0;
	}

	// adjust height
	Origin.z += Velocity.z * DeltaTime;

	if (bFloat && Enemy)
	{
		// float down towards enemy if too close
		if (!bSkullFly && !bInFloat)
		{
			dist = DistTo2(Enemy);

			delta = Enemy.Origin.z + Height / 2.0 - Origin.z;

			if (delta < 0.0 && dist < -(delta * 3.0))
				Origin.z -= FLOATSPEED * DeltaTime;
			else if (delta > 0.0 && dist < (delta * 3.0))
				Origin.z += FLOATSPEED * DeltaTime;
		}
	}

	// clip movement
	if (Origin.z <= FloorZ + 0.1)
	{
		// hit the floor

		vdot = DotProduct(Velocity, Floor->normal);
		// Note (id):
		//  somebody left this after the setting momz to 0,
		//  kinda useless there.
		if (bSkullFly)
		{
			// the skull slammed into something
			Velocity.z = -Velocity.z;
		}

		if (vdot < -0.1)
		{
			if (bIsPlayer && (vdot < -GRAVITY * 0.25))
			{
				// Squat down.
				// Decrease ViewHeight for a moment
				// after hitting the ground (hard),
				// and utter appropriate sound.
				Player(Player).DeltaViewHeight = vdot / 8.0;
				PlaySound('*land', CHAN_VOICE);
			}
		}
		Origin.z = FloorZ;

		if (bMissile)
		{
			if (bColideWithWorld && !bFloorBounce)
			{
				ExplodeMissile();
				return;
			}
			if (bFloorBounce)
			{
				// Bouncing Missiles explode on water surfaces
				if(TerrainType(Floor->pic) == 3)
				{
					ExplodeMissile();
					return;
				}
				Velocity.z = Velocity.z * -0.5;
				Velocity.x = 2.0 * Velocity.x / 3.0;
				Velocity.y = 2.0 * Velocity.y / 3.0;
				if (PainSound && Length(Velocity) > 256.0)
				{
					PlaySound(PainSound, CHAN_VOICE);
				}
				A_DecReactionCount();
			}
		}

		if(TerrainType(Floor->pic) == 3 && Origin.z - Velocity.z * DeltaTime > FloorZ)
			PlaySound('world/watersplash', CHAN_VOICE);
	}

	if (Origin.z + Height > CeilingZ)
	{
		// hit the ceiling
		vdot = DotProduct(Velocity, Ceiling->normal);
		if (vdot < 0.0)
			Velocity -= vdot * Ceiling->normal;

		Origin.z = CeilingZ - Height;

		if (bSkullFly)
		{
			// the skull slammed into something
			Velocity.z = -Velocity.z;
		}

		if (bMissile)
		{
			if (bColideWithWorld && !bFloorBounce)
			{
				ExplodeMissile();
				return;
			}
			if (bFloorBounce)
			{
				// Reverse momentum here for ceiling bounce
				Velocity -= vdot * Ceiling->normal;
				if (PainSound && Length(Velocity) > 256.0)
				{
					PlaySound(PainSound, CHAN_VOICE);
				}
				A_DecReactionCount();
			}
		}
	}
}

//==========================================================================
//
//  ApplyFriction
//
//==========================================================================

void ApplyFriction()
{
	float dot;

	// slow down

	if (bMissile || bSkullFly)
		return;	// no friction for missiles ever

	if (Origin.z > FloorZ && !bOnMobj && WaterLevel < 2)
		return;	// no friction when airborne

	//  Clip velocity
	if (Origin.z <= FloorZ)
	{
		dot = DotProduct(Velocity, Floor->normal);
		if (dot < 0.0)
		{
			if (bFloorBounce)
			{
				dot *= BOUNCE_VAL;
				A_DecReactionCount();
			}
			Velocity -= dot * Floor->normal;
		}
	}

	if (bCorpse)
	{
		// do not stop sliding if halfway off a step with some momentum
		if (Velocity.x > 0.25 * 35.0 || Velocity.x < -0.25 * 35.0 ||
			Velocity.y > 0.25 * 35.0 || Velocity.y < -0.25 * 35.0)
		{
			if (FloorZ != GetPlanePointZ(&Sector->floor, Origin))
				return;
		}
	}

	if (Velocity.x > -STOPSPEED && Velocity.x < STOPSPEED &&
		Velocity.y > -STOPSPEED && Velocity.y < STOPSPEED &&
		Velocity.z > -STOPSPEED && Velocity.z < STOPSPEED &&
		(!bIsPlayer || (!Player.ForwardMove && !Player.SideMove)))
	{
		if (bIsPlayer)
		{
			// if in a walking frame, stop moving
			if (StateIsInRange(State, SeeState, none, 4))
				SetState(IdleState);
		}
		Velocity = vector(0.0, 0.0, 0.0);
	}
	else
	{
		Velocity -= Velocity * (GetFriction() * Level.Game.frametime);
	}
}

//===========================================================================
//
//  GetFriction
//
//===========================================================================

float GetFriction()
{
	if (WaterLevel > 1)
	{
		return FRICTION_WATER;
	}
	if ((Sector->special & SECSPEC_BASE_MASK) == SECSPEC_FrictionLow)
	{
		return FRICTION_LOW;
	}
	if (Sector->special & SECSPEC_FRICTION_MASK)
	{
		return Sector->Friction;
	}
	return FRICTION;
}

//===========================================================================
//
//  PlayerLandedOnThing
//
//===========================================================================

void PlayerLandedOnThing()
{
	Player(Player).DeltaViewHeight = Velocity.z / 8.0;
	if (Velocity.z < -GRAVITY * 0.375)
	{
		PlaySound('*land', CHAN_VOICE);
	}
}

//==========================================================================
//
//	Physics
//
//==========================================================================

bool Physics(float DeltaTime)
{
	Actor			onmo;
	SectorThinker	SecThink;
	float			scrollx;
	float			scrolly;
	float			height;
	float			waterheight;	// killough 4/4/98: add waterheight

	if (Sector->AffectorData && bColideWithWorld)
	{

		// killough 3/7/98: Carry things on floor
		// killough 3/20/98: use new sector list which reflects true members
		// killough 3/27/98: fix carrier bug
		// killough 4/4/98: Underwater, carry things even w/o gravity

		// Move objects only if on floor or underwater,
		// non-floating, and clipped.

		for (SecThink = SectorThinker(Sector->AffectorData); SecThink;
			SecThink = SecThink.NextAffector)
		{
			if (!Scroller(SecThink))
			{
				continue;
			}
			scrollx = Scroller(SecThink).CarryScrollX;
			scrolly = Scroller(SecThink).CarryScrollY;
			if (!scrollx && !scrolly)
			{
				continue;
			}
			if (bNoGravity && (!Sector->heightsec ||
				(Sector->heightsec->bIgnoreHeightSec)))
			{
				continue;
			}
			height = GetPlanePointZ(&Sector->floor, Origin);
			if (Origin.z > height)
			{
				if (!Sector->heightsec || (Sector->heightsec->bIgnoreHeightSec))
				{
					continue;
				}

				waterheight = GetPlanePointZ(&Sector->heightsec->floor, Origin);
				if (waterheight > height && Origin.z >= waterheight)
				{
					continue;
				}
			}

			Velocity.x += scrollx;
			Velocity.y += scrolly;
		}
	}

	CheckWater();
	UpdateVelocity();

	// momentum movement
	Level.Game.tmtrace->BlockingMobj = none;
	if (Velocity.x || Velocity.y)
	{
		XYMovement(DeltaTime);
		if (IsDestroyed())
		{
			// mobj was removed
			return false;
		}
	}
	else if (bSkullFly)
	{
		// the skull slammed into something
		bSkullFly = false;
		Velocity = vector(0.0, 0.0, 0.0);
		if (!SetState(IdleState))
		{
			return false;
		}
	}
	if ((Origin.z != FloorZ) || Velocity.z || Level.Game.tmtrace->BlockingMobj)
	{
		// Handle Z momentum and gravity
		if (!bNoPassMobj && !bMissile)
		{
			onmo = Actor(CheckOnmobj());
			if (!onmo)
			{
				ZMovement(DeltaTime);
				bOnMobj = false;
			}
			else
			{
				if (bIsPlayer)
				{
					if (Velocity.z < -GRAVITY * 0.25 && !bFly)
					{
						PlayerLandedOnThing();
					}
				}
				if (onmo.Origin.z + onmo.Height - Origin.z <= MaxStepHeight)
				{
					if (bIsPlayer)
					{
						Player(Player).ViewHeight -=
							onmo.Origin.z + onmo.Height - Origin.z;
						Player(Player).DeltaViewHeight =
							(Player::VIEWHEIGHT - Player(Player).ViewHeight) * 4.0;
					}
					Origin.z = onmo.Origin.z + onmo.Height;
				}
				bOnMobj = true;
				Velocity.z = 0.0;
			}
		}
		else
		{
			ZMovement(DeltaTime);
		}
		if (IsDestroyed())
		{
			return false;	// entity was removed
		}
	}
	return true;
}

//==========================================================================
//
//	Tick
//
//==========================================================================

void Tick(float deltaTime)
{
	//  In my deathmatch mode remove dropped weapons after 30 seconds
	// because otherwise they are spawned fastar than player(s) can pick 
	// them up and the game is going slower and slower and slower ...
	if (bDropped && (Level.Game.deathmatch == 3))
	{
		MoveCount++;
		if (MoveCount >= 30 * 35)
		{
			Remove();
			return;
		}
	}

	if (!Physics(deltaTime))
	{
		return;
	}

	// cycle through states,
	// calling action functions at transitions
	if (StateTime != -1.0)
	{
		StateTime -= deltaTime;

		// you can cycle through multiple states in a tic
		if (StateTime <= 0.0)
		{
			StateTime = 0.0;
			if (!SetState(NextState))
				return;	// freed itself
		}
	}
	else
	{
		// check for nightmare respawn
		if (!bCountKill)
			return;

		//  In my deathmatch mode monstars respawns very fast
		if (Level.Game.deathmatch == 3)
		{
			if (Level.Game.level->tictime & 31)
				return;

			if (P_Random() > 32)
				return;

			NightmareRespawn();
		}
		else
		{
			if (!MainGameInfo(Level.Game).respawnmonsters)
				return;

			MoveCount++;

			if (MoveCount < 12 * 35)
				return;

			if (Level.Game.level->tictime & 31)
				return;

			if (P_Random() > 4)
				return;

			NightmareRespawn();
		}
	}
}

//==========================================================================
//
//  HeightClip
//
//  Takes a valid thing and adjusts the thing->FloorZ, thing->CeilingZ, and
// possibly thing->z. This is called for all nearby monsters whenever a
// sector changes height. If the thing doesn't fit, the z will be set to the
// lowest value and false will be returned.
//
//==========================================================================

bool HeightClip()
{
	bool onfloor;

	onfloor = (Origin.z == FloorZ);

	CheckRelPosition(Origin);
	// what about stranding a monster partially off an edge?

	Floor = Level.Game.tmtrace->Floor;
	Ceiling = Level.Game.tmtrace->Ceiling;
	FloorZ = Level.Game.tmtrace->FloorZ;
	CeilingZ = Level.Game.tmtrace->CeilingZ;

	if (onfloor)
	{
		// walking monsters rise and fall with the floor
		Origin.z = FloorZ;
	}
	else
	{
		// don't adjust a floating monster unless forced to
		if (Origin.z + Height > CeilingZ)
			Origin.z = CeilingZ - Height;
	}

	if (CeilingZ - FloorZ < Height)
		return false;

	return true;
}

//==========================================================================
//
//	SectorChanged
//
//==========================================================================

bool SectorChanged(int CrushChange)
{
	Actor A;

	if (HeightClip())
	{
		return true;
	}

	//	Crunch bodies to giblets
	if (Health <= 0)
	{
		SetState(S_GIBS);
		bSolid = false;
		Height = 0.0;
		Radius = 0.0;
		return true;
	}

	//	Crunch dropped items
	if (bDropped)
	{
		Remove();
		return true;
	}

	if (!bShootable)
	{
		//	Assume it is bloody gibs or something
		return true;
	}

	if (CrushChange && !(Level.Game.level->tictime & 3))
	{
		Damage(none, none, CrushChange);

		// spray blood in a random direction
		A = Spawn(Blood, Origin + vector(0.0, 0.0, Height / 2.0));
		A.Velocity.x = (Random() - Random()) * 16.0 * 35.0;
		A.Velocity.y = (Random() - Random()) * 16.0 * 35.0;
	}
	return false;	//don't fit
}

//**************************************************************************
//
//  RADIUS ATTACK
//
//**************************************************************************

//==========================================================================
//
//  PIT_RadiusAttack
//
//  "bombsource" is the creature that caused the explosion at "bombspot".
//
//==========================================================================

bool PIT_RadiusAttack(Entity Other)
{
	float dist;

	if (!Actor(Other).bShootable)
		return true;

	dist = Length(MobjCenter(Other) - MobjCenter(self)) - Other.Radius;

	if (dist < 0.0)
		dist = 0.0;

	if (dist >= bombdamage)
		return true;	// out of range

	if (Actor(Other).CanSee(self))
	{
		// must be in direct path
		Actor(Other).Damage(self, Instigator, ftoi(bombdamage - dist));
	}

	return true;
}

//==========================================================================
//
//  RadiusAttack
//
//  Source is the creature that caused the explosion at spot.
//
//==========================================================================

void RadiusAttack(int damage, int distance, bool damageSource)
{
	int x;
	int y;

	int xl;
	int xh;
	int yl;
	int yh;

	float dist;

	dist = itof(damage);
	yh = MapBlock(Origin.y + dist - XLevel.BlockMapOrgY);
	yl = MapBlock(Origin.y - dist - XLevel.BlockMapOrgY);
	xh = MapBlock(Origin.x + dist - XLevel.BlockMapOrgX);
	xl = MapBlock(Origin.x - dist - XLevel.BlockMapOrgX);
	bombdamage = itof(damage);

	for (y = yl; y <= yh; y++)
		for (x = xl; x <= xh; x++)
			P_BlockThingsIterator(x, y, self, 'PIT_RadiusAttack');
}

//==========================================================================
//
//  PIT_StompThing
//
//==========================================================================

bool PIT_StompThing(Entity Other)
{
	float blockdist;

	if (!Actor(Other).bShootable)
		return true;

	blockdist = Other.Radius + Radius;

	if (fabs(Other.Origin.x - teleport_x) >= blockdist ||
		fabs(Other.Origin.y - teleport_y) >= blockdist)
	{
		// didn't hit it
		return true;
	}

	// don't clip against self
	if (Other == self)
		return true;

	if (!bIsPlayer)
	{
		return false;
	}

	Actor(Other).Damage(self, self, 10000);

	return true;
}

//==========================================================================
//
//  TeleportMove
//
//==========================================================================

bool TeleportMove(TVec org)
{
	int xl;
	int xh;
	int yl;
	int yh;
	int bx;
	int by;

	// kill anything occupying the position
	teleport_x = org.x;
	teleport_y = org.y;

	// stomp on any things contacted
	xl = MapBlock(org.x - Radius - XLevel.BlockMapOrgX - MAXRADIUS);
	xh = MapBlock(org.x + Radius - XLevel.BlockMapOrgX + MAXRADIUS);
	yl = MapBlock(org.y - Radius - XLevel.BlockMapOrgY - MAXRADIUS);
	yh = MapBlock(org.y + Radius - XLevel.BlockMapOrgY + MAXRADIUS);

	for (bx = xl; bx <= xh; bx++)
		for (by = yl; by <= yh; by++)
			if (!P_BlockThingsIterator(bx, by, self, 'PIT_StompThing'))
				return false;

	// the move is ok,
	// so link the thing into its new position
	UnlinkFromWorld();
	Origin = org;
	LinkToWorld();
	if (org.z == ONFLOORZ)
	{
		Origin.z = FloorZ;
	}

	return true;
}

//==========================================================================
//
//  Teleport
//
//==========================================================================

int Teleport(TVec Dst, float angle, bool DstFog, bool SrcFog, bool KeepDir)
{
	TVec oldOrg;
	Actor fog;

	oldOrg = Origin;

	if (!TeleportMove(Dst))
		return 0;

	if (bIsPlayer)
		Player.ViewOrg.z = Origin.z + Player(Player).ViewHeight;

	if (SrcFog)
	{
		// spawn teleport fog at source and destination
		fog = Spawn(TeleportFog, oldOrg);
		fog.PlaySound('misc/teleport', CHAN_VOICE);
	}

	if (DstFog)
	{
		fog = Spawn(TeleportFog, Origin +
			vector(20.0 * cos(angle), 20.0 * sin(angle), 0.0));

		// emit sound, where?
		fog.PlaySound('misc/teleport', CHAN_VOICE);
	}

	if (!KeepDir)
	{
		// don't move for a bit
		if (bIsPlayer)
		{
			ReactionTime = 0.5;
			Player.bFixAngle = true;
		}

		Angles.yaw = angle;
		Velocity = vector(0.0, 0.0, 0.0);
	}
	return 1;
}

//==========================================================================
//
//  LookForMonsters
//
//==========================================================================

bool LookForMonsters(bool allaround)
{
	Actor mo;
	float an;
	float dist;

	if (!Level.Game.Players[0].MO.CanSee(self))
	{
		return false;	//  Not seen by player
	}

	FOREACH(Actor, mo)
	{
		if (mo.Health <= 0)
			continue;	// dead

		if (mo == self)
			continue;	// self

		if (!mo.bCountKill)
			continue;	// not a monster

		if (!CanSee(mo))
			continue;	// out of sight

		if (P_Random() > 128)
			continue;	// sometimes skip

		if (!allaround)
		{
			an = AngleMod360(atan2(mo.Origin.y - Origin.y,
				mo.Origin.x - Origin.x) - Angles.yaw);

			if (an > 90.0 && an < 270.0)
			{
				dist = DistTo(mo);
				// if real close, react anyway
				if (dist > MELEERANGE)
					continue;	// behind back
			}
		}

		Enemy = mo;
		return true;
	}
	return false;
}

//==========================================================================
//
//  LookForMonsters2
//
//==========================================================================

bool LookForMonsters2(bool allaround)
{
	Actor mo;
	float an;
	float dist;

	FOREACH(Actor, mo)
	{
		if (mo.Health <= 0)
			continue;	// dead

		if (mo == self)
			continue;	// self

		if (!mo.bCountKill)
			continue;	// not a monster

		if (bFriendly == mo.bFriendly)
			continue;	// fiendly.

		if (!CanSee(mo))
			continue;	// out of sight

		if (P_Random() > 128)
			continue;	// sometimes skip

		if (!allaround)
		{
			an = AngleMod360(atan2(mo.Origin.y - Origin.y,
				mo.Origin.x - Origin.x) - Angles.yaw);

			if (an > 90.0 && an < 270.0)
			{
				dist = DistTo(mo);
				// if real close, react anyway
				if (dist > MELEERANGE)
					continue;	// behind back
			}
		}

		Enemy = mo;
		return true;
	}
	return false;
}

//==========================================================================
//
//  LookForPlayers
//
//  If allaround is false, only look 180 degrees in front.
//  Returns true if a player is targeted.
//
//==========================================================================

bool LookForPlayers(bool allaround)
{
	int c;
	int stop;
	Player player;
	float an;
	float dist;

	if (bFriendly)
	{
		return LookForMonsters2(allaround);
	}
// 
	if (!Level.Game.netgame && Level.Game.Players[0] && Level.Game.Players[0].bSpawned && Level.Game.Players[0].Health <= 0)
	{
		return LookForMonsters(allaround);
	}

	c = 0;
	stop = (LastLook - 1) & (MAXPLAYERS - 1);

	for (;; LastLook = (LastLook + 1) & (MAXPLAYERS - 1))
	{
		if (LastLook == stop)
		{
			// done looking
			return false;
		}

		player = Player(Level.Game.Players[LastLook]);

		if (!player)
			continue;

		if (c++ == 2)
		{
			// done looking
			return false;
		}

		if (!player.bSpawned || !player.MO)
			continue;	//  not spawned yet

		if (player.Health <= 0)
			continue;	// dead

		if (!CanSee(player.MO))
			continue;	//  out of sight

		if (!allaround)
		{
			an = AngleMod360(atan2(player.MO.Origin.y - Origin.y,
				player.MO.Origin.x - Origin.x) - Angles.yaw);

			if (an > 90.0 && an < 270.0)
			{
				dist = DistTo(player.MO);
				// if real close, react anyway
				if (dist > MELEERANGE)
					continue;	// behind back
			}
		}

		Enemy = Actor(player.MO);
		return true;
	}

	return false;
}

//==========================================================================
//
//	SpawnSubMissile
//
//==========================================================================

Actor SpawnSubMissile(classid type, Actor AInstigator)
{
	Actor other;
	TVec dir;

	other = Spawn(type, Origin);
	if (!other)
	{
		return none;
	}

	other.Instigator = AInstigator;
	other.Angles = Angles;

	other.Velocity.x = other.Speed * cos(Angles.yaw);
	other.Velocity.y = other.Speed * sin(Angles.yaw);
	dir = AimLineAttack(Angles, 1024.0);
	other.Velocity.z = other.Speed * dir.z;
	other.CheckMissileSpawn();
	return other;
}

//==========================================================================
//
//  TossUpObject
//
//==========================================================================

Actor TossUpObject(classid type)
{
	Actor		A;
	float		an;
	float		randomspeed;

	randomspeed = Random() * 8.0 - 6.0;

	A = Spawn(type, MobjCenter(self));
	if (A)
	{
		an = AngleMod360(Angles.yaw + Random() * 360.0);
		A.Angles.yaw = an;
		A.Enemy = Enemy;
		A.Instigator = self;
		A.Velocity.x = randomspeed * cos(an) * 35.0;
		A.Velocity.y = randomspeed * sin(an) * 35.0;
		A.Velocity.z = (12.0 + Random() / 8.0) * 35.0;
	}
	return A;
}

//**************************************************************************
//
//  AIMING
//
//**************************************************************************

//==========================================================================
//
//  PTR_AimTraverse
//
//  Sets linetaget and aim_slope when a target is aimed at.
//
//==========================================================================

bool PTR_AimTraverse(intercept_t * in)
{
	line_t *li;
	Actor Th;
	float thingtopslope;
	float thingbottomslope;
	float dist;
	float slope;
	opening_t *open;

	if (in->bIsALine)
	{
		TVec hit_point;

		li = in->line;

		if (!(li->flags & ML_TWOSIDED))
			return false;	// stop

		// Crosses a two sided line.
		// A two sided line will restrict
		// the possible target ranges.
		dist = aim_range * in->frac;
		hit_point = Origin + dist * aim_dir;
		open = LineOpenings(li, hit_point);
		open = FindOpening(open, hit_point.z, hit_point.z);

		if (!open || open->bottom >= open->top)
			return false;	// stop

		dist = aim_range2d * in->frac;
		if (li->frontsector->floorheight != li->backsector->floorheight)
		{
			slope = (open->bottom - aim_z) / dist;
			if (slope > aim_bottomslope)
				aim_bottomslope = slope;
		}

		if (li->frontsector->ceilingheight != li->backsector->ceilingheight)
		{
			slope = (open->top - aim_z) / dist;
			if (slope < aim_topslope)
				aim_topslope = slope;
		}

		if (aim_topslope <= aim_bottomslope)
			return false;	// stop

		return true;	// shot continues
	}

	// shoot a thing
	Th = Actor(in->Thing);
	if (Th == self)
		return true;	// can't shoot self

	if (!Th.bShootable)
		return true;	// corpse or something

#ifdef FIXME
	//  Hexen does this. There's no reason why we can't enable it in Doom.
	if (Th.player && netgame && !deathmatch)
	{
		// don't aim at fellow co-op players
		return true;
	}
#endif

	// check angles to see if the thing can be aimed at
	dist = aim_range2d * in->frac;
	thingtopslope = (Th.Origin.z + Th.Height - aim_z) / dist;

	if (thingtopslope < aim_bottomslope)
		return true;	// shot over the thing

	thingbottomslope = (Th.Origin.z - aim_z) / dist;

	if (thingbottomslope > aim_topslope)
		return true;	// shot under the thing

	// this thing can be hit!
	if (thingtopslope > aim_topslope)
		thingtopslope = aim_topslope;

	if (thingbottomslope < aim_bottomslope)
		thingbottomslope = aim_bottomslope;

	aim_slope = (thingtopslope + thingbottomslope) / 2.0;
	linetarget = Th;

	return false;	// don't go any farther
}

//==========================================================================
//
//  AimLineAttack
//
//==========================================================================

TVec AimLineAttack(TAVec angles, float distance)
{
	float x2;
	float y2;
	float topangle;
	float botangle;
	TVec dir;

	AngleVector(&angles, &aim_dir);
	x2 = Origin.x + distance * aim_dir.x;
	y2 = Origin.y + distance * aim_dir.y;
	aim_z = Origin.z + Height / 2.0 + 8.0 - FloorClip;
	aim_range2d =
		Length(vector(distance * aim_dir.x, distance * aim_dir.y, 0.0));

	// can't shoot outside view angles
	topangle = AngleMod180(-angles.pitch + 30.0);
	botangle = AngleMod180(-angles.pitch - 30.0);
	if (topangle > 89.0)
		topangle = 89.0;
	if (botangle < -89.0)
		botangle = -89.0;
	aim_topslope = tan(topangle);
	aim_bottomslope = tan(botangle);

	aim_range = distance;
	linetarget = none;

	P_PathTraverse(Origin.x, Origin.y, x2, y2,
		PT_ADDLINES | PT_ADDTHINGS, self, 'PTR_AimTraverse');

	if (linetarget)
	{
		angles.pitch = -atan(aim_slope);
	}
	AngleVector(&angles, &dir);
	return dir;
}

//===========================================================================
//
//	Aim
//
//  Sets a slope so a near miss is at aproximately the height of the
// intended target
//
//===========================================================================

TVec Aim(float distance)
{
	TAVec an;
	TVec dir;

	// see which target is to be aimed at
	an = Angles;

	dir = AimLineAttack(an, distance);
	if (!linetarget)
	{
		an.yaw = AngleMod360(an.yaw + 45.0 / 8.0);
		dir = AimLineAttack(an, distance);
		if (!linetarget)
		{
			an.yaw = AngleMod360(an.yaw - 45.0 / 4.0);
			dir = AimLineAttack(an, distance);
			if (!linetarget)
			{
				an.yaw = AngleMod360(an.yaw + 45.0 / 8.0);
				AngleVector(&an, &dir);
			}
		}
	}
	return dir;
}

//===========================================================================
//
//	AimAngle
//
//  Sets a slope so a near miss is at aproximately the height of the
// intended target
//
//===========================================================================

TVec AimAngle(float distance, float angle)
{
	TAVec an;
	TVec dir;

	// see which target is to be aimed at
	an = Angles;
	an.yaw = angle;

	dir = AimLineAttack(an, distance);
	if (!linetarget)
	{
		an.yaw = AngleMod360(an.yaw + 45.0 / 8.0);
		dir = AimLineAttack(an, distance);
		if (!linetarget)
		{
			an.yaw = AngleMod360(an.yaw - 45.0 / 4.0);
			dir = AimLineAttack(an, distance);
			if (!linetarget)
			{
				an.yaw = AngleMod360(an.yaw + 45.0 / 8.0);
				AngleVector(&an, &dir);
			}
		}
	}
	return dir;
}

//**************************************************************************
//
//  SHOOTING
//
//**************************************************************************

//==========================================================================
//
//  ShootHitPlane
//
//==========================================================================

bool ShootHitPlane(sec_plane_t * plane)
{
	float org_dist;
	float hit_dist;

	if (plane->flags & SPF_NOBLOCKSHOOT)
	{
		//  Doesn't block shooting
		return true;
	}
	org_dist = DotProduct(shoot_linestart, plane->normal) - plane->dist;
	if (org_dist < 0.0)
	{
		//  Don't shoot back side
		return true;
	}
	hit_dist = DotProduct(shoot_lineend, plane->normal) - plane->dist;
	if (hit_dist >= 0.0)
	{
		//  Didn't hit plane
		return true;
	}

	//  Hit plane
	if (plane->pic == Level.Game.skyflatnum)
	{
		// don't shoot the sky!
		return false;
	}

	//  If we are shooting floor or ceiling we are adjusting position
	// to spawn puff on floor or ceiling, not on wall
	shoot_lineend -= (shoot_lineend - shoot_linestart) * hit_dist / (hit_dist - org_dist);

	// position a bit closer
	shoot_lineend += 4.0 * plane->normal;

	// Spawn bullet puffs.
	SpawnPuff(shootPuffType, shoot_lineend);

	// don't go any farther
	return false;
}

//==========================================================================
//
//  ShootCheckPlanes
//
//==========================================================================

bool ShootCheckPlanes(sector_t * sec)
{
	sec_region_t *reg;
	sec_region_t *startreg;

	startreg = PointInRegion(sec, shoot_linestart);
	for (reg = startreg; reg; reg = reg->next)
	{
		if (!ShootHitPlane(reg->floor))
		{
			//  Hit floor
			return false;
		}
		if (!ShootHitPlane(reg->ceiling))
		{
			//  Hit ceiling
			return false;
		}
	}
	for (reg = startreg->prev; reg; reg = reg->prev)
	{
		if (!ShootHitPlane(reg->floor))
		{
			//  Hit floor
			return false;
		}
		if (!ShootHitPlane(reg->ceiling))
		{
			//  Hit ceiling
			return false;
		}
	}
	return true;
}

//==========================================================================
//
//  PTR_ShootTraverse
//
//==========================================================================

bool PTR_ShootTraverse(intercept_t * in)
{
	TVec hit_point;
	line_t *li;
	Actor th;

	if (in->bIsALine)
	{
		sector_t *sec;

		li = in->line;
		hit_point = shoot_origin + (shoot_range * in->frac) * shoot_dir;
		if (li->flags & ML_TWOSIDED && PointOnPlaneSide(shoot_origin, li))
		{
			sec = li->backsector;
		}
		else
		{
			sec = li->frontsector;
		}

		shoot_lineend = hit_point;

		//  Check for shooting floor or ceiling
		if (!ShootCheckPlanes(sec))
		{
			return false;
		}

		shoot_linestart = shoot_lineend;

		//  Execute line special after checking for hitting floor or ceiling
		// when we know that it actally hits line
		if (li->special)
		{
			StrifeLevelInfo(Level).ActivateLine(li, self, 0, SPAC_IMPACT);
		}

		if (li->flags & ML_TWOSIDED)
		{
			// crosses a two sided line
			opening_t *open;
			float opentop = 0.0;

			open = LineOpenings(li, hit_point);
			if (open)
			{
				opentop = open->top;
			}
			while (open)
			{
				if (open->bottom <= hit_point.z && open->top >= hit_point.z)
				{
					// shot continues
					return true;
				}
				open = open->next;
			}
			if (li->frontsector->ceiling.pic == Level.Game.skyflatnum &&
				li->backsector->ceiling.pic == Level.Game.skyflatnum &&
				hit_point.z > opentop)
			{
				// it's a sky hack wall
				return false;
			}
		}

		//  Hit line

		// position a bit closer
		hit_point -= 4.0 * shoot_dir;

		// Spawn bullet puffs.
		SpawnPuff(shootPuffType, hit_point);

		// don't go any farther
		return false;
	}

	// shoot a thing
	th = Actor(in->Thing);

	if (th == self)
		return true;	// can't shoot self

	if (!th.bShootable)
		return true;	// corpse or something

	// check angles to see if the thing can be aimed at
	hit_point = shoot_origin + (shoot_range * in->frac) * shoot_dir;

	if (th.Origin.z + th.Height < hit_point.z)
		return true;	// shot over the thing

	if (th.Origin.z > hit_point.z)
		return true;	// shot under the thing

	// hit thing
	// position a bit closer
	hit_point -= 10.0 * shoot_dir;

	// Spawn bullet puffs or blod spots,
	// depending on target type.
	if (th.bNoBlood)
		SpawnPuff(shootPuffType, hit_point);
	else
		SpawnBlood(hit_point.x, hit_point.y, hit_point.z, la_damage);

	if (la_damage)
		th.Damage(self, self, la_damage);

	// don't go any farther
	return false;
}

//==========================================================================
//
//  LineAttack
//
//  If damage == 0, it is just a test trace that will leave linetarget set.
//
//==========================================================================

int LineAttack(TVec dir, float distance, int damage, classid PuffType)
{
	TVec dst;

	la_damage = damage;
	shootPuffType = PuffType;

	shoot_origin = Origin;
	shoot_origin.z += Height * 0.5 + 8.0 - FloorClip;

	shoot_dir = dir;
	shoot_range = distance;

	dst = shoot_origin + shoot_range * shoot_dir;
	shoot_linestart = shoot_origin;
	if (!P_PathTraverse(Origin.x, Origin.y, dst.x, dst.y,
			PT_ADDLINES | PT_ADDTHINGS, self, 'PTR_ShootTraverse'))
	{
		return false;
	}
	shoot_lineend = dst;
	return ShootCheckPlanes(XLevel.PointInSector(dst));
}

//==========================================================================
//
//  SpawnPuff
//
//==========================================================================

void SpawnPuff(classid PuffType, TVec Org)
{
	Actor A;

	Org.z += (Random() - Random()) * 4.0;
	A = Spawn(PuffType, Org);
	A.Velocity.z = 1.0 * 35.0;
	A.StateTime -= Random() * 0.1;
	if (A.StateTime < 0.1)
		A.StateTime = 0.1;
}

//==========================================================================
//
//  SpawnBlood
// 
//==========================================================================

void SpawnBlood(float x, float y, float z, int damage)
{
	Actor A;

	MSG_Select(MSG_SV_DATAGRAM);
	MSG_WriteByte(StrifeDefs::svc_blood);
	MSG_WriteShort(ftoi(x));
	MSG_WriteShort(ftoi(y));
	MSG_WriteShort(ftoi(z));
	MSG_WriteByte(damage > 255 ? 255 : damage);

	z += (Random() - Random()) * 4.0;
	A = Spawn(Blood, vector(x, y, z));
	A.Velocity.z = 2.0 * 35.0;
	A.StateTime -= Random() * 0.1;

	if (A.StateTime < 0.1)
		A.StateTime = 0.1;

	if (damage <= 12 && damage >= 9)
		A.SetState(Blood::S_BLOOD2);
	else if (damage < 9)
		A.SetState(Blood::S_BLOOD3);
}

//==========================================================================
//
//  A_Look
//
//  Stay in state until a player is sighted
//
//==========================================================================

void A_Look()
{
	Actor targ;
	int sound;

	Threshold = 0;	// any shot will wake up
	targ = Actor(Sector->SoundTarget);

	if (targ && targ.bShootable)
	{
		Enemy = targ;
	}
	else
	{
		if (!LookForPlayers(bLookAllAround))
			return;
	}

	// go into chase state
	if (SightSound)
	{
		PlaySound(SightSound, CHAN_VOICE);
	}

	SetState(SeeState);
}

//==========================================================================
//
//	A_ActiveSound
//
//==========================================================================

void A_ActiveSound()
{
	if (ActiveSound && !GetSoundPlayingInfo(self, GetSoundID(ActiveSound)))
	{
		PlaySound(ActiveSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//  A_Pain
//
//==========================================================================

void A_Pain()
{
	if (PainSound)
	{
		PlaySound(PainSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//  A_Explode
//
//  Rocket and barrel explosion.
//
//==========================================================================

void A_Explode()
{
	RadiusAttack(64, 0, 0);
	if (Instigator && Instigator.bIsPlayer)
	{
		StrifeLevelInfo(Level).NoiseAlert(Instigator, self);
	}

	if (ExplodeEffect)
	{
		MSG_Select(MSG_SV_DATAGRAM);
		MSG_WriteByte(StrifeDefs::svc_explosion);
		MSG_WriteByte(ExplodeEffect);
		MSG_WriteShort(ftoi(Origin.x));
		MSG_WriteShort(ftoi(Origin.y));
		MSG_WriteShort(ftoi(Origin.z));
	}
}

//==========================================================================
//
//  A_Explode2
//
//  Rocket and barrel explosion.
//
//==========================================================================

void A_Explode2()
{
	RadiusAttack(128, 0, 0);

	if (ExplodeEffect)
	{
		MSG_Select(MSG_SV_DATAGRAM);
		MSG_WriteByte(StrifeDefs::svc_explosion);
		MSG_WriteByte(ExplodeEffect);
		MSG_WriteShort(ftoi(Origin.x));
		MSG_WriteShort(ftoi(Origin.y));
		MSG_WriteShort(ftoi(Origin.z));
	}
}

//==========================================================================
//
//  A_Scream
//
//  Death sound.
//
//==========================================================================

void A_Scream()
{
	//  Remove muzzle flash & other light effects
	if (Effects & StrifeDefs::EF_DLIGHT_MASK)
	{
		Effects &= ~StrifeDefs::EF_DLIGHT_MASK;
	}

	if (DeathSound)
	{
		PlaySound(DeathSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//  A_Fall
//
//  Unset blocking.
//
//==========================================================================

void A_Fall()
{
	//  Remove muzzle flash
	if ((Effects & StrifeDefs::EF_DLIGHT_MASK) == StrifeDefs::EF_DL_MUZZLEFLASH)
	{
		Effects &= ~StrifeDefs::EF_DLIGHT_MASK;
	}

	// actor is on ground, it can be walked over
	bSolid = false;
}

//==========================================================================
//
//	A_SetShadow
//
//==========================================================================

void A_SetShadow()
{
	bUnknown2 = true;
	Translucency = 66;
}

//==========================================================================
//
//	A_ClearShadow
//
//==========================================================================

void A_ClearShadow()
{
	bUnknown2 = false;
	Translucency = 0;
}

//==========================================================================
//
//	A_BeShadowyFoe
//
//==========================================================================

void A_BeShadowyFoe()
{
	Translucency = 66;
	bFriendly = false;
}

//==========================================================================
//
//	A_Tracer
//
//==========================================================================

const float TRACEANGLE	= (7.0 * 45.0 / 16.0);

void A_Tracer()
{
	Actor dest;
	float exact;
	float dist;
	float slope;

	dest = Enemy;

	if (!dest || dest.Health <= 0)
		return;

	// change angle
	exact = atan2(dest.Origin.y - Origin.y, dest.Origin.x - Origin.x);

	if (exact != Angles.yaw)
	{
		if (AngleMod360(exact - Angles.yaw) > 180.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw - TRACEANGLE);
			if (AngleMod360(exact - Angles.yaw) < 180.0)
				Angles.yaw = exact;
		}
		else
		{
			Angles.yaw = AngleMod360(Angles.yaw + TRACEANGLE);
			if (AngleMod360(exact - Angles.yaw) > 180.0)
				Angles.yaw = exact;
		}
	}

	exact = Angles.yaw;
	Velocity.x = Speed * cos(exact);
	Velocity.y = Speed * sin(exact);

	// change slope
	dist = DistTo2(dest);
	dist /= Speed;

	if (dist < 1.0)
	{
		dist = 1.0;
	}
	slope = (dest.Origin.z + 40.0 - Origin.z) / dist;
	if (slope < Velocity.z)
	{
		Velocity.z -= 1.0 / 8.0 * 35.0;
	}
	else
	{
		Velocity.z += 1.0 / 8.0 * 35.0;
	}
}

//==========================================================================
//
//	A_SpawnPuff
//
//==========================================================================

void A_SpawnPuff()
{
	Actor A;

	if (MiniMissile(self))
	{
		PlaySound('misc/missileinflight', CHAN_VOICE);
		SpawnPuff(Puff, Origin);
		A = Spawn(ReactorPuff, Origin - Velocity / 35.0);
		if (A)
		{
			A.Velocity.z = 1.0 * 35.0;
		}
	}
	else
	{
		A = Spawn(Puff, Origin + vector(
			(Random() - Random()) * 5.0 / 8.0,
			(Random() - Random()) * 5.0 / 8.0, 0.0));
		//FIXME Create a class for this.
		A.SetState(Puff::S_GRENADE_HE_X2);
	}
}

//==========================================================================
//
//	A_ScrollOrDie
//
//==========================================================================

void A_ScrollOrDie()
{
	int anglespeed;
	float speed;
	float finean;

	if (Origin.z == GetPlanePointZ(Floor, Origin))
	{
		if ((Sector->special & SECSPEC_BASE_MASK) == SECSPEC_DamageInstantDeath)
		{
			Damage(none, none, 999);
		}
		else if ((Sector->special & SECSPEC_BASE_MASK) == SECSPEC_ScrollCurrent)
		{
			anglespeed = Sector->tag - 100;
			speed = itof(anglespeed % 10) / 16.0 * 35.0;
			finean = itof(anglespeed / 10) * 45.0;
			Velocity.x += speed * cos(finean);
			Velocity.y += speed * sin(finean);
		}
	}
}

//==========================================================================
//
//	A_XDying
//
//==========================================================================

void A_XDying()
{
	Actor gib;
	float an;
	float speed;

	gib = Spawn(bNoBlood ? TechJunk : MeatChunk, Origin + vector(0.0, 0.0, 24.0));
	if (!gib)
	{
		return;
	}

	an = Random() * 360.0;
	gib.Angles.yaw = an;
	speed = Random() * 16.0 * 35.0;
	gib.Velocity.x = speed * cos(an);
	gib.Velocity.y = speed * sin(an);
	gib.Velocity.z = Random() * 16.0 * 35.0;
}

//==========================================================================
//
//	A_DecReactionCount
//
//==========================================================================

void A_DecReactionCount()
{
	if (--ReactionCount <= 0)
	{
		ExplodeMissile();
		bSkullFly = false;
	}
}

//==========================================================================
//
//	A_AlertMonsters
//
//==========================================================================

void A_AlertMonsters()
{
	if (Instigator && Instigator.bIsPlayer)
	{
		StrifeLevelInfo(Level).NoiseAlert(Instigator, self);
	}
}

//==========================================================================
//
//	A_CheckAlarm
//
//	Stay in state untill alarm is triggered.
//
//==========================================================================

void A_CheckAlarm()
{
	Actor targ;
	int sound;

	Threshold = 0;
	targ = Actor(Sector->SoundTarget);
	if (targ && targ.bShootable)
	{
		Enemy = targ;
		// go into chase state
		if (SightSound)
		{
			PlaySound(SightSound, CHAN_VOICE);
		}
		Threshold = 10;
		SetState(SeeState);
	}
}

//==========================================================================
//
//	A_Explode32
//
//==========================================================================

void A_Explode32()
{
	RadiusAttack(32, 32, false);
	if (DeathSound)
		PlaySound(DeathSound, CHAN_VOICE);

	if (ExplodeEffect)
	{
		MSG_Select(MSG_SV_DATAGRAM);
		MSG_WriteByte(StrifeDefs::svc_explosion);
		MSG_WriteByte(ExplodeEffect);
		MSG_WriteShort(ftoi(Origin.x));
		MSG_WriteShort(ftoi(Origin.y));
		MSG_WriteShort(ftoi(Origin.z));
	}
}

//==========================================================================
//
//	A_Explode192
//
//==========================================================================

void A_Explode192()
{
	RadiusAttack(192, 192, false);
	if (DeathSound)
		PlaySound(DeathSound, CHAN_VOICE);

	if (ExplodeEffect)
	{
		MSG_Select(MSG_SV_DATAGRAM);
		MSG_WriteByte(StrifeDefs::svc_explosion);
		MSG_WriteByte(ExplodeEffect);
		MSG_WriteShort(ftoi(Origin.x));
		MSG_WriteShort(ftoi(Origin.y));
		MSG_WriteShort(ftoi(Origin.z));
	}
}

//==========================================================================
//
//	A_RemoveForceField
//
//==========================================================================

void A_RemoveForceField()
{
	int i;
	line_t* line;

	bSpecial = false;
	for (i = 0; i < Sector->linecount; i++)
	{
		line = Sector->lines[i];
		if (line->backsector && line->special == 33)
		{
			line->flags &= ~(ML_BLOCKING|ML_BLOCKEVERYTHING);
			line->special = 0;
			SetLineTexture(line->sidenum[0], 1, 0);
			SetLineTexture(line->sidenum[1], 1, 0);
		}
	}
}

//==========================================================================
//
//	GetSpeechIndex
//
//==========================================================================

int GetSpeechIndex(RogueConSpeech *List, int Count, int ID, int Num)
{
	int Found;
	int i;

	Found = 0;
	for (i = 0; i < Count; i++)
	{
		if (List[i].SpeakerID == ID)
		{
			Found++;
			if (Found == Num)
			{
				return i + 1;
			}
		}
	}
	return 0;
}

//==========================================================================
//
//	GetSpeech
//
//==========================================================================

int GetSpeech()
{
	int Index;

	if (!CurrentSpeech)
	{
		CurrentSpeech = 1;
	}
	Index = GetSpeechIndex(XLevel.LevelSpeeches, XLevel.NumLevelSpeeches,
		ConversationID, CurrentSpeech);
	if (Index)
	{
		return Index;
	}
	return -GetSpeechIndex(XLevel.GenericSpeeches, XLevel.NumGenericSpeeches,
		ConversationID, CurrentSpeech);
}

__states__
{
	S_ZAP1_1('ZAP1', 1, 3.0 / 35.0, S_ZAP1_2) { A_Explode32(); }
	S_ZAP1_0('ZAP1', 0, 3.0 / 35.0, S_ZAP1_2) { A_AlertMonsters(); }
	S_ZAP1_2('ZAP1', 1, 3.0 / 35.0, S_ZAP1_3) { }
	S_ZAP1_3('ZAP1', 2, 3.0 / 35.0, S_ZAP1_4) { }
	S_ZAP1_4('ZAP1', 3, 3.0 / 35.0, S_ZAP1_5) { }
	S_ZAP1_5('ZAP1', 4, 3.0 / 35.0, S_ZAP1_6) { }
	S_ZAP1_6('ZAP1', 5, 3.0 / 35.0, S_ZAP1_7) { }
	S_ZAP1_7('ZAP1', 4, 3.0 / 35.0, S_ZAP1_8) { }
	S_ZAP1_8('ZAP1', 3, 2.0 / 35.0, S_ZAP1_9) { }
	S_ZAP1_9('ZAP1', 2, 2.0 / 35.0, S_ZAP1_10) { }
	S_ZAP1_10('ZAP1', 1, 2.0 / 35.0, S_ZAP1_11) { }
	S_ZAP1_11('ZAP1', 0, 1.0 / 35.0, none) { }

	S_BLOOD1('BLOD', 2, 8.0 / 35.0, S_BLOOD2) { }
	S_BLOOD2('BLOD', 1, 8.0 / 35.0, S_BLOOD3) { }
	S_BLOOD3('BLOD', 0, 8.0 / 35.0, none) { }

	S_SHARD_1('SHRD', 0, 128.0 / 35.0, none) { }
	S_SHARD_2('SHRD', 1, 128.0 / 35.0, none) { }
	S_SHARD_3('SHRD', 2, 128.0 / 35.0, none) { }
	S_SHARD_4('SHRD', 3, 128.0 / 35.0, none) { }
	S_SHARD_5('SHRD', 4, 128.0 / 35.0, none) { }
	S_SHARD_6('SHRD', 5, 128.0 / 35.0, none) { }

	S_MINI_MISSILE2_1('MICR', 0 | FF_FULLBRIGHT, 2.0 / 35.0, S_MINI_MISSILE2_2) { A_Tracer(); }
	S_MINI_MISSILE2_2('MICR', 0 | FF_FULLBRIGHT, 2.0 / 35.0, S_MINI_MISSILE2_1) { A_Tracer(); }

	S_TOKENS('TOKN', 0, -1.0, none) { }

	S_GIBS('DIE1', 0, -1.0, none) { }

	S_ANKH('ANKH', 0, -1.0, none) { }
}

defaultproperties
{
	Health = 1000;
	Radius = 20.0;
	Height = 16.0;
	Mass = 100.0;
	MaxStepHeight = 16.0;
	MaxDropoffHeight = 32.0;
	ReactionCount = 8;
	LightOffset = vector(0.0, 0.0, 0.0);
	LightColour = 0xffffffff;
	LightRadius = 128.0;
}

//**************************************************************************
//
//  $Log: Actor.vc,v $
//  Revision 1.49  2006/04/14 14:57:30  firebrand_kh
//  Added static light flag and properties
//
//  Revision 1.48  2006/04/11 18:27:40  dj_jl
//  Removed Strife specific mapinfo extensions.
//
//  Revision 1.47  2006/04/10 19:22:18  dj_jl
//  Added floor clipping in liquids.
//
//  Revision 1.46  2006/04/09 15:35:16  dj_jl
//  Added static lights and other lighting effects.
//
//  Revision 1.45  2006/04/09 11:22:00  dj_jl
//  Properly remove current lighting special.
//
//  Revision 1.44  2006/04/06 21:50:23  dj_jl
//  For some builtins changed string arguments to names.
//
//  Revision 1.43  2006/04/06 15:54:01  firebrand_kh
//  Made fire damage don't affect a player with environmental suit activated
//
//  Revision 1.42  2006/04/06 11:47:46  dj_jl
//  Added maximal dropoff parameter.
//
//  Revision 1.41  2006/04/05 17:29:24  dj_jl
//  Fix for missiles imediately exploding and having wrong instigator.
//
//  Revision 1.40  2006/03/29 14:36:30  firebrand_kh
//  Added bouncing flags / Changed Improved A_Tracer method
//
//  Revision 1.39  2006/03/28 15:02:57  firebrand_kh
//  Lots of fixes and improvements
//
//  Revision 1.38  2006/03/24 15:41:09  firebrand_kh
//  Made poison arrows don't damage certain actors
//
//  Revision 1.37  2006/03/21 15:09:34  firebrand_kh
//  Fixes for onmobj checks
//
//  Revision 1.36  2006/03/13 18:52:38  dj_jl
//  Added function to check if a state is in the range.
//
//  Revision 1.35  2006/03/12 20:01:24  dj_jl
//  States as objects, added state variable type.
//
//  Revision 1.34  2006/03/02 18:36:30  dj_jl
//  Don't use game specific classes in common.
//
//  Revision 1.33  2006/02/28 22:47:55  dj_jl
//  Replaced defines with constants.
//
//  Revision 1.32  2006/02/17 19:06:53  dj_jl
//  Moved common defs to classes.
//
//  Revision 1.31  2006/02/15 23:34:27  dj_jl
//  Moved all server progs global variables to classes.
//
//  Revision 1.30  2006/02/13 18:30:17  dj_jl
//  Moved all server progs global functions to classes.
//
//  Revision 1.29  2006/02/05 18:50:55  dj_jl
//  Moved common utils to level info class or built-in.
//
//  Revision 1.28  2006/01/22 17:30:02  dj_jl
//  Continue conversation if failed to give the item.
//
//  Revision 1.27  2006/01/10 19:54:01  dj_jl
//  Many bug fixes.
//
//  Revision 1.26  2005/12/27 22:22:28  dj_jl
//  Created level info class, moved action special handling to it.
//
//  Revision 1.25  2005/12/25 17:13:08  dj_jl
//  Some fixes.
//
//  Revision 1.24  2005/12/22 23:53:01  dj_jl
//  Rebel always drops an ammo clip.
//
//  Revision 1.23  2005/12/14 20:52:32  dj_jl
//  State names belong to a class.
//
//  Revision 1.22  2005/12/12 20:33:49  dj_jl
//  Cleaned up state types.
//
//  Revision 1.21  2005/12/11 21:31:40  dj_jl
//  Made path traversal callbacks class members.
//
//  Revision 1.20  2005/12/07 22:54:19  dj_jl
//  Moved compiler generated data out of globals.
//
//  Revision 1.19  2005/11/19 13:43:50  dj_jl
//  Renamed sounds.
//
//  Revision 1.18  2005/07/09 13:55:47  dj_jl
//  Scrolers carrying objects.
//
//  Revision 1.17  2005/03/28 07:45:29  dj_jl
//  Some Boom line specials, fixed multiple bugs.
//
//  Revision 1.16  2005/03/16 15:04:42  dj_jl
//  More work on line specials.
//
//  Revision 1.15  2004/12/27 12:23:14  dj_jl
//  Multiple small changes for version 1.16
//
//  Revision 1.14  2004/12/22 07:56:47  dj_jl
//  Fully working Strife support.
//
//  Revision 1.13  2004/11/22 07:36:28  dj_jl
//  Implemented all sector specials in all games.
//
//  Revision 1.12  2004/11/01 07:38:23  dj_jl
//  Almost all Hexen line specials are available in all games.
//
//  Revision 1.11  2004/10/14 06:22:38  dj_jl
//  Implemented several objects amd monsters.
//
//  Revision 1.10  2004/10/13 06:37:33  dj_jl
//  Implemented items also giving quests.
//
//  Revision 1.9  2004/08/23 19:24:01  dj_jl
//  Moved weapon utilites to player class.
//
//  Revision 1.8  2004/03/12 07:22:14  dj_jl
//  Monster desth special action
//
//  Revision 1.7  2004/02/04 07:32:58  dj_jl
//  Implemented many action functions
//
//  Revision 1.6  2003/11/12 16:51:33  dj_jl
//  Changed player structure into a class
//
//  Revision 1.5  2003/10/02 17:59:30  dj_jl
//  Dropped items.
//
//  Revision 1.4  2003/09/15 16:43:11  dj_jl
//  Implemented stand action
//
//  Revision 1.3  2003/07/11 16:47:39  dj_jl
//  Made array of players with pointers
//
//  Revision 1.2  2003/03/08 12:41:45  dj_jl
//  Removing class pointers.
//
//  Revision 1.1  2002/11/02 08:20:56  dj_jl
//  New style classes.
//
//**************************************************************************
