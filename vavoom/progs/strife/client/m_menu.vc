//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define MNF_INACTIVE		1
#define MNF_HIDEN			2

//  callback notifications
#define MMSG_ACTIVATE		1
#define MMSG_LOST_FOCUS		2
#define MMSG_RECEIVE_FOCUS	4

#define MAX_MENU_ITEMS		32

#define MAX_MENU_STACK		32

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

struct menucommon_t;
class MenuObject;

typedef void (*menu_item_drawer_t) (menucommon_t *);
typedef boolean(*menu_item_responder_t) (menucommon_t *, int);
typedef void (*itemcallback_t) (menucommon_t *, int);

struct menucommon_t
{
	menu_item_drawer_t drawer;
	menu_item_responder_t responder;
	itemcallback_t callback;
	int flags;
	int id;
	int x;
	int y;
};

struct menu_t;

typedef void (*menu_drawer_t) (menu_t *);
typedef boolean(*menu_responder_t) (menu_t *, int);

struct menu_t
{
	menu_drawer_t drawer;
	menu_responder_t responder;
	int cursor;
	int cursor_prev;
	int numitems;
	MenuObject Items[MAX_MENU_ITEMS];
};

// FUNCTION PROTOTYPES -----------------------------------------------------

void PopMenu(void);
void menu_main(void);

// DATA DECLARATIONS -------------------------------------------------------

menu_t *menu_stack[MAX_MENU_STACK];
int menu_sp;

menu_t *CurrentMenu;

float MenuTime;

// CODE --------------------------------------------------------------------

//**************************************************************************
//**
//**	MenuObject
//**
//**************************************************************************

class MenuObject:Object
{
	int x;
	int y;
	int width;
	int height;
	boolean selected;

	void Init(void)
	{
	}

	void Draw(void)
	{
	}

	boolean Key(int key)
	{
		return false;
	}

	void Callback(int ID)
	{
	}

	boolean IsVisible(void)
	{
		return true;
	}

	boolean IsDisabled(void)
	{
		return false;
	}

	menucommon_t *GetOldItem(void)
	{
		return NULL;
	}

	void Destroyed(void)
	{
	}
}

//**************************************************************************
//**
//**	MenuItemWrapper
//**
//**************************************************************************

class MenuItemWrapper:MenuObject
{
	menucommon_t *item;

	void Draw(void)
	{
		if (item->drawer)
		{
			item->drawer(item);
		}
	}

	boolean Key(int key)
	{
		if (item->responder)
		{
			return item->responder(item, key);
		}
		return false;
	}

	void Callback(int id)
	{
		if (item->callback)
		{
			item->callback(item, id);
		}
	}

	boolean IsVisible(void)
	{
		return !(item->flags & MNF_HIDEN);
	}

	boolean IsDisabled(void)
	{
		return item->flags & MNF_INACTIVE;
	}

	menucommon_t *GetOldItem(void)
	{
		return item;
	}
}

//**************************************************************************
//**
//**
//**
//**************************************************************************

//==========================================================================
//
//	InputLine_Init
//
//  Initializes input line
//
//==========================================================================

void InputLine_Init(TILine * iline)
{
    iline->len = 0;
    strsetchar(ARR2STR(iline->Data), 0, 0);
}

//==========================================================================
//
//	InputLine_Key
//
// 	Wrapper function for handling general keyed input.
//	Returns true if it ate the key
//
//==========================================================================

boolean InputLine_Key(TILine * iline, int ch)
{
    if (ch >= 32 && ch < 128)
	{
  		ch = TranslateKey(ch);
	    if (iline->len < MAX_ILINE_LENGTH)
    	{
			strsetchar(ARR2STR(iline->Data), iline->len++, ch);
			strsetchar(ARR2STR(iline->Data), iline->len, 0);
    	}
	}
    else if (ch == K_BACKSPACE)
	{
	    if (iline->len)
		{
			strsetchar(ARR2STR(iline->Data), --iline->len, 0);
		}
	}
	else if (ch != K_ENTER)
	{
		return false; // did not eat key
	}
    return true; // ate the key
}

//==========================================================================
//
//	InputLine_SetValue
//
//  Sets input line value
//
//==========================================================================

void InputLine_SetValue(TILine * iline, string text)
{
	strcpy(ARR2STR(iline->Data), text);
	iline->len = strlen(text);
}

//==========================================================================
//
//  Menu_CursorMoved
//
//==========================================================================

void Menu_CursorMoved(menu_t * m)
{
	if (m->cursor_prev == m->cursor)
		return;

	if (m->cursor_prev >= 0 && m->cursor_prev < m->numitems)
	{
		m->Items[m->cursor_prev].Callback(MMSG_LOST_FOCUS);
		m->Items[m->cursor_prev].selected = false;
	}

	if (m->cursor >= 0 && m->cursor < m->numitems)
	{
		m->Items[m->cursor].Callback(MMSG_RECEIVE_FOCUS);
		m->Items[m->cursor].selected = true;
	}
}

//==========================================================================
//
//  Menu_SetCursor
//
//==========================================================================

void Menu_SetCursor(menu_t * m, int cursor)
{
	if (m->Items[cursor].IsDisabled())
	{
		// cursor can't go there
		return;
	}

	m->cursor_prev = m->cursor;
	m->cursor = cursor;

	Menu_CursorMoved(m);
}

//==========================================================================
//
//  Menu_Draw
//
//==========================================================================

void Menu_Draw(menu_t * menu)
{
	int i;

	for (i = 0; i < menu->numitems; i++)
	{
		if (menu->Items[i].IsVisible())
		{
			menu->Items[i].Draw();
		}
	}
}

//==========================================================================
//
//  Menu_Use
//
//==========================================================================

boolean Menu_Use(menu_t * menu, int key)
{
	if (menu->Items[menu->cursor].Key(key))
	{
		return true;
	}

	switch (key)
	{
	case K_DOWNARROW:
		menu->cursor_prev = menu->cursor;
		do
		{
			if (menu->cursor == menu->numitems - 1)
				menu->cursor = 0;
			else
				menu->cursor++;
		}
		while (menu->Items[menu->cursor].IsDisabled() &&
			menu->cursor_prev != menu->cursor);
		Menu_CursorMoved(menu);
		LocalSound("MenuMove");
		return true;

	case K_UPARROW:
		menu->cursor_prev = menu->cursor;
		do
		{
			if (!menu->cursor)
				menu->cursor = menu->numitems - 1;
			else
				menu->cursor--;
		}
		while (menu->Items[menu->cursor].IsDisabled() &&
			menu->cursor_prev != menu->cursor);
		Menu_CursorMoved(menu);
		LocalSound("MenuMove");
		return true;

	case K_ESCAPE:
	case K_MOUSE2:
		PopMenu();
		return true;
	}

	return false;
}

//==========================================================================
//
//  InitMenu
//
//==========================================================================

void InitMenu(menu_t * menu)
{
	int i;

	menu->numitems = 0;
	menu->drawer = Menu_Draw;
	menu->responder = Menu_Use;
	for (i = 0; i < MAX_MENU_ITEMS; i++)
	{
		if (menu->Items[i] != none)
		{
			menu->Items[i].Destroyed();
			menu->Items[i].Destroy();
			menu->Items[i] = none;
		}
	}
}

//==========================================================================
//
//  AddMenuItem
//
//==========================================================================

void AddMenuItem(menu_t * menu, menucommon_t * item)
{
	MenuItemWrapper it;

	if (menu->numitems >= MAX_MENU_ITEMS)
	{
		FatalError("Too many menu items");
	}
	it = Spawn(MenuItemWrapper, none);
	it.item = item;
	menu->Items[menu->numitems] = it;
	menu->Items[menu->numitems].Init();
	menu->numitems++;
}

//==========================================================================
//
//  Menu_AddItem
//
//==========================================================================

MenuObject Menu_AddItem(menu_t * menu, classid type)
{
	MenuObject item;

	if (menu->numitems >= MAX_MENU_ITEMS)
	{
		FatalError("Too many menu items");
	}
	item = Spawn(type, none);
	menu->Items[menu->numitems] = item;
	item.Init();
	menu->numitems++;
	return item;
}

//==========================================================================
//
//  ActiveItem
//
//==========================================================================

menucommon_t *ActiveItem(void)
{
	return CurrentMenu->Items[CurrentMenu->cursor].GetOldItem();
}

//**************************************************************************
//**
//**    Menu stack handling
//**
//**************************************************************************

//==========================================================================
//
//  PushMenu
//
//==========================================================================

void PushMenu(menu_t * menu)
{
	int i;
	MenuObject item;

	// avoid stacking menus invoked by hotkeys
	for (i = 0; i < menu_sp; i++)
	{
		if (menu_stack[i] == menu)
		{
			menu_sp = i;
			break;
		}
	}

	if (i == menu_sp)
	{
		if (menu_sp >= MAX_MENU_STACK)
			FatalError("PushMenu: menu stack overflow");

		menu_stack[menu_sp++] = menu;
	}

	if (!CurrentMenu)
	{
		MenuTime = 0.0;
/*		if (cl.paused)
		{
			S_ResumeSound();
		}
		C_ClearNotify();*/
		CmdBuf_AddText("HideConsole\n");
		LocalSound("MenuActivate");
	}

	CurrentMenu = menu;

	// default cursor position
	menu->cursor = 0;
	menu->cursor_prev = 0;

	// force first available item to have focus
	for (i = 0; i < menu->numitems; i++)
	{
		item = menu->Items[i];
		if (!item.IsDisabled())
		{
			menu->cursor_prev = -1;
			menu->cursor = i;
			Menu_CursorMoved(menu);
			break;
		}
	}
}

//==========================================================================
//
//  PopMenu
//
//==========================================================================

void PopMenu(void)
{
	menu_sp--;

	if (menu_sp < 0)
		FatalError("PopMenu: menu stack underflow");

	if (menu_sp)
	{
		CurrentMenu = menu_stack[menu_sp - 1];
		LocalSound("MenuPrevious");
	}
	else
	{
		CurrentMenu = NULL;
		LocalSound("MenuClose");
	}
}

//==========================================================================
//
//  ForceMenuOff
//
//==========================================================================

void ForceMenuOff(void)
{
	menu_sp = 0;
	CurrentMenu = NULL;
}

//**************************************************************************
//**
//**    Base type of all items
//**
//**************************************************************************

//==========================================================================
//
//  MenuCommon_Draw
//
//==========================================================================

void MenuCommon_Draw(menucommon_t * item)
{
}

//==========================================================================
//
//  MenuCommon_Use
//
//==========================================================================

boolean MenuCommon_Use(menucommon_t * item, int key)
{
	return false;
}

//==========================================================================
//
//  MenuCommon_Init
//
//==========================================================================

void MenuCommon_Init(menucommon_t * item, int x, int y, int flags)
{
	item->drawer = MenuCommon_Draw;
	item->responder = MenuCommon_Use;
	item->x = x;
	item->y = y;
	item->flags = flags;
	item->id = 0;
}

//**************************************************************************
//**
//**    Bitmap
//**
//**************************************************************************

struct menubitmap_t:menucommon_t
{
	int handle;
};

//==========================================================================
//
//  MenuBitmap_Draw
//
//==========================================================================

void MenuBitmap_Draw(menucommon_t * aitem)
{
	menubitmap_t *item = (menubitmap_t *) aitem;

	int x = item->x;
	int y = item->y;

	R_DrawPic(x, y, item->handle);
}

//==========================================================================
//
//  MenuBitmap_Init
//
//==========================================================================

void MenuBitmap_Init(menubitmap_t * item, int x, int y, int flags,
	string name, int type)
{
	MenuCommon_Init(item, x, y, flags);
	item->drawer = MenuBitmap_Draw;
	item->handle = R_RegisterPic(name, type);
}

//**************************************************************************
//**
//**    Anims
//**
//**************************************************************************

#define MAX_ANIM_FRAMES		18

struct menuanim_t:menucommon_t
{
	int speed;
	int frames;
	int start;
	boolean backwards;
	int pics[MAX_ANIM_FRAMES];
};

//==========================================================================
//
//  MenuAnim_Draw
//
//==========================================================================

void MenuAnim_Draw(menucommon_t * aitem)
{
	menuanim_t *item = (menuanim_t *) aitem;

	int x = item->x;
	int y = item->y;
	int frame =

		ftoi(MenuTime * itof(item->speed) + itof(item->start)) % item->frames;
	if (item->backwards)
	{
		frame = item->frames - frame - 1;
	}

	R_DrawPic(x, y, item->pics[frame]);
}

//==========================================================================
//
//  MenuAnim_Init
//
//==========================================================================

void MenuAnim_Init(menuanim_t * item, int x, int y, int flags, int speed,
	int frames, int start, boolean backwards)
{
	MenuCommon_Init(item, x, y, flags);
	item->drawer = MenuAnim_Draw;
	item->speed = speed;
	item->frames = frames;
	item->start = start;
	item->backwards = backwards;
}

//**************************************************************************
//**
//**    Sprite animation
//**
//**************************************************************************

struct menuspriteanim_t:menucommon_t
{
	int sprdef;
	int speed;
	int frames;
	int translation;
};

//==========================================================================
//
//  MenuSpriteAnim_Draw
//
//==========================================================================

void MenuSpriteAnim_Draw(menucommon_t * aitem)
{
	menuspriteanim_t *item = (menuspriteanim_t *) aitem;

	int x = item->x;
	int y = item->y;
	int frame = ftoi(MenuTime * itof(item->speed)) % item->frames;

	R_DrawSpritePatch(x, y, item->sprdef, frame, 0, item->translation);
}

//==========================================================================
//
//  MenuSpriteAnim_Init
//
//==========================================================================

void MenuSpriteAnim_Init(menuspriteanim_t * item, int x, int y, int sprdef,
	int speed, int frames)
{
	MenuCommon_Init(item, x, y, MNF_INACTIVE);
	item->drawer = MenuSpriteAnim_Draw;
	item->sprdef = sprdef;
	item->speed = speed;
	item->frames = frames;
	item->translation = 0;
}

//**************************************************************************
//**    
//**    Selector
//**    
//**************************************************************************

int selector_pics[8];

//==========================================================================
//
//  DrawSelector
//
//==========================================================================

void DrawSelector(int x, int y)
{
	R_DrawPic(x - 32, y - 5, selector_pics[ftoi(MenuTime * 4.0) & 7]);
}

//==========================================================================
//
//  InitSelector
//
//==========================================================================

void InitSelector(void)
{
	selector_pics[0] = R_RegisterPic("M_CURS1", PIC_PATCH);
	selector_pics[1] = R_RegisterPic("M_CURS2", PIC_PATCH);
	selector_pics[2] = R_RegisterPic("M_CURS3", PIC_PATCH);
	selector_pics[3] = R_RegisterPic("M_CURS4", PIC_PATCH);
	selector_pics[4] = R_RegisterPic("M_CURS5", PIC_PATCH);
	selector_pics[5] = R_RegisterPic("M_CURS6", PIC_PATCH);
	selector_pics[6] = R_RegisterPic("M_CURS7", PIC_PATCH);
	selector_pics[7] = R_RegisterPic("M_CURS8", PIC_PATCH);
}

//**************************************************************************
//**    
//**    Text
//**    
//**************************************************************************

enum
{
	TEXT_BIG,
	TEXT_BIGC,
	TEXT_SMALLL,
	TEXT_SMALLR
};

typedef void (*menufunc_t) (void);

struct menutext_t:menucommon_t
{
	string text;
	int type;
	menufunc_t func;
	string command;
};

//==========================================================================
//
//  MenuText_Use
//
//==========================================================================

boolean MenuText_Use(menucommon_t * aitem, int key)
{
	menutext_t *item = (menutext_t *) aitem;

	if (key == K_ENTER || key == K_MOUSE1 || key == K_JOY1)
	{
		if (item->callback)
		{
			item->callback(aitem, MMSG_ACTIVATE);
		}
		if (item->func)
		{
			item->func();
		}
		else if (item->command)
		{
			CmdBuf_AddText(item->command);
		}
		else
		{
			return false;
		}
		LocalSound("MenuSelect");
		return true;
	}
	return false;
}

//==========================================================================
//
//  MenuText_Draw
//
//==========================================================================

void MenuText_Draw(menucommon_t * aitem)
{
	menutext_t *item = (menutext_t *) aitem;

	int x = item->x;
	int y = item->y;
	boolean is_active = ActiveItem() == aitem;

	switch (item->type)
	{
	case TEXT_BIG:
		if (is_active)
		{
			DrawSelector(x, y);
		}
		T_SetFont(font_big);
		T_SetAlign(hleft, vtop);
		break;

	case TEXT_BIGC:
		T_SetFont(font_big);
		T_SetAlign(hcenter, vbottom);
		break;

	case TEXT_SMALLL:
		T_SetFont(font_small);
		if (is_active)
		{
			T_SetAlign(hright, vtop);
			T_DrawText(x - 2, y, ">");
		}
		T_SetAlign(hleft, vtop);
		break;

	case TEXT_SMALLR:
		T_SetFont(font_small);
		if (is_active)
		{
			T_SetAlign(hleft, vtop);
			T_DrawText(x + 2, y, ">");
		}
		T_SetAlign(hright, vtop);
		break;
	}
	T_DrawText(x, y, item->text);
}

//==========================================================================
//
//  MenuText_Init
//
//==========================================================================

void MenuText_Init(menutext_t * item, int x, int y, int flags, string text,
	int type)
{
	MenuCommon_Init(item, x, y, flags);
	item->drawer = MenuText_Draw;
	item->responder = MenuText_Use;
	item->text = text;
	item->type = type;
	InitSelector();
}

//==========================================================================
//
//  MenuText_InitFunc
//
//==========================================================================

void MenuText_InitFunc(menutext_t * item, int x, int y, string text, int type,
	menufunc_t func)
{
	MenuText_Init(item, x, y, 0, text, type);
	item->func = func;
}

//==========================================================================
//
//  MenuText_InitCmd
//
//==========================================================================

void MenuText_InitCmd(menutext_t * item, int x, int y, string text, int type,
	string cmd)
{
	MenuText_Init(item, x, y, 0, text, type);
	item->command = cmd;
}

//==========================================================================
//
//  MenuText_InitTitle
//
//==========================================================================

void MenuText_InitTitle(menutext_t * item, int x, int y, string text,
	int type)
{
	MenuText_Init(item, x, y, MNF_INACTIVE, text, type);
}

//**************************************************************************
//**
//**    Switch
//**
//**************************************************************************

struct menuswitch_t:menutext_t
{
	int value;
	int max;
	string *names;
};

//  Widely used on/off
string sw_offon[2] = { "Off", "On" };

//==========================================================================
//
//  MenuSwitch_Draw
//
//==========================================================================

void MenuSwitch_Draw(menucommon_t * aitem)
{
	menuswitch_t *item = (menuswitch_t *) aitem;

	int x = item->x;
	int y = item->y;

	MenuText_Draw(aitem);

	if (item->type == TEXT_SMALLL)
	{
		x += T_TextWidth(item->text) + 8;
	}
	else
	{
		x += 10;
	}
	T_SetAlign(hleft, vtop);
	T_DrawText(x, y, item->names[item->value]);
}

//==========================================================================
//
//  MenuSwitch_Use
//
//==========================================================================

boolean MenuSwitch_Use(menucommon_t * aitem, int key)
{
	menuswitch_t *item = (menuswitch_t *) aitem;

	switch (key)
	{
	case K_LEFTARROW:
		if (item->value > 0)
			item->value--;
		else
			item->value = item->max - 1;
		LocalSound("MenuSwitch");
		if (item->callback)
			item->callback(aitem, MMSG_ACTIVATE);
		return true;
	case K_RIGHTARROW:
	case K_ENTER:
	case K_MOUSE1:
		if (item->value < item->max - 1)
			item->value++;
		else
			item->value = 0;
		LocalSound("MenuSwitch");
		if (item->callback)
			item->callback(aitem, MMSG_ACTIVATE);
		return true;
	}
	return false;
}

//==========================================================================
//
//  MenuSwitch_Init
//
//==========================================================================

void MenuSwitch_Init(menuswitch_t * item, int x, int y, string text, int type,
	int value, int max, string * names)
{
	MenuText_Init(item, x, y, 0, text, type);
	item->drawer = MenuSwitch_Draw;
	item->responder = MenuSwitch_Use;
	item->max = max;
	if (value < 0)
		value = 0;
	if (value >= max)
		value = max - 1;
	item->value = value;
	item->names = names;
}

//**************************************************************************
//**
//**    Slider
//**
//**************************************************************************

struct menuslider_t:menutext_t
{
	int value;
	int max;
};

int pic_M_THERML;
int pic_M_THERMM;
int pic_M_THERMR;
int pic_M_THERMO;

//==========================================================================
//
//  MenuSlider_Draw
//
//==========================================================================

void MenuSlider_Draw(menucommon_t * aitem)
{
	menuslider_t *item = (menuslider_t *) aitem;

	int i;
	int xx;

	int x = item->x;
	int y = item->y;

	MenuText_Draw(aitem);

	xx = x + 8;
	R_DrawPic(xx, y, pic_M_THERML);
	xx += 8;
	for (i = 0; i < 13; i++)
	{
		R_DrawPic(xx, y, pic_M_THERMM);
		xx += 8;
	}
	R_DrawPic(xx, y, pic_M_THERMR);
	xx = x + 8 + 6 + item->value * 100 / (item->max - 1);
	R_DrawPic(xx, y, pic_M_THERMO);
}

//==========================================================================
//
//  MenuSlider_Use
//
//==========================================================================

boolean MenuSlider_Use(menucommon_t * aitem, int key)
{
	menuslider_t *item = (menuslider_t *) aitem;

	switch (key)
	{
	case K_LEFTARROW:
		if (item->value > 0)
		{
			item->value--;
		}
		LocalSound("MenuSwitch");
		if (item->callback)
			item->callback(aitem, MMSG_ACTIVATE);
		return true;

	case K_RIGHTARROW:
		if (item->value < item->max - 1)
		{
			item->value++;
		}
		LocalSound("MenuSwitch");
		if (item->callback)
			item->callback(aitem, MMSG_ACTIVATE);
		return true;
	}
	return false;
}

//==========================================================================
//
//  MenuSlider_Init
//
//==========================================================================

void MenuSlider_Init(menuslider_t * item, int x, int y, string text, int type,
	int value, int max)
{
	MenuText_Init(item, x, y, 0, text, type);
	item->drawer = MenuSlider_Draw;
	item->responder = MenuSlider_Use;
	item->max = max;
	if (value < 0)
		value = 0;
	if (value >= max)
		value = max - 1;
	item->value = value;

	pic_M_THERML = R_RegisterPic("M_THERML", PIC_PATCH);
	pic_M_THERMM = R_RegisterPic("M_THERMM", PIC_PATCH);
	pic_M_THERMR = R_RegisterPic("M_THERMR", PIC_PATCH);
	pic_M_THERMO = R_RegisterPic("M_THERMO", PIC_PATCH);
}

//**************************************************************************
//**
//**    Control key
//**
//**************************************************************************

struct menucontrol_t:menucommon_t
{
	string text;
	string command_on;
	string command_off;
};

menucontrol_t *current_ctl;
int ControlColumn;	// menu column for controls

//==========================================================================
//
//  MenuControl_Draw
//
//==========================================================================

void MenuControl_Draw(menucommon_t * aitem)
{
	menucontrol_t *item = (menucontrol_t *) aitem;

	int key1;
	int key2;
	int name_buf[32 / 4];
	string name = ARR2STR(name_buf);

	int x = item->x;
	int y = item->y;
	boolean is_active = ActiveItem() == aitem;

	T_SetFont(font_small);
	if (is_active)
	{
		T_SetAlign(hleft, vtop);
		T_DrawText(x + 2 + ControlColumn * 90, y, ">");
	}

	T_SetAlign(hright, vtop);
	T_DrawText(x, y, item->text);

	IN_GetBindingKeys(item->command_on, &key1, &key2);

	T_SetAlign(hleft, vtop);
	if (key1 >= 0)
	{
		KeyNameForNum(key1, name);
		T_DrawText(x + 10, y, name);
	}
	else
	{
		T_DrawText(x + 10, y, "---");
	}
	if (key2 >= 0)
	{
		KeyNameForNum(key2, name);
		T_DrawText(x + 100, y, name);
	}
	else
	{
		T_DrawText(x + 100, y, "---");
	}
}

//==========================================================================
//
//  ControlResponse
//
//==========================================================================

void ControlResponse(int key)
{
	string kb_down;
	string kb_up;
	int key1;
	int key2;

	if (key != K_ESCAPE)
	{
		kb_down = current_ctl->command_on;
		kb_up = current_ctl->command_off;
		IN_GetBindingKeys(kb_down, &key1, &key2);
		if (ControlColumn == 0)
		{
			IN_SetBinding(key1, "", "");
			IN_SetBinding(key, kb_down, kb_up);
		}
		if (ControlColumn == 1)
		{
			IN_SetBinding(key2, "", "");
			IN_SetBinding(key, kb_down, kb_up);
		}
	}
}

//==========================================================================
//
//  MenuControl_Use
//
//==========================================================================

boolean MenuControl_Use(menucommon_t * aitem, int key)
{
	menucontrol_t *item = (menucontrol_t *) aitem;

	int key1;
	int key2;

	switch (key)
	{
	case K_LEFTARROW:
		ControlColumn = 0;
		return true;

	case K_RIGHTARROW:
		ControlColumn = 1;
		return true;

	case K_ENTER:
	case K_MOUSE1:
		current_ctl = item;
		MB_StartMessage("Press new key\n\nESC to cancel", ControlResponse,
			false);
		return true;

	case K_BACKSPACE:
		IN_GetBindingKeys(item->command_on, &key1, &key2);
		if (ControlColumn == 0)
			IN_SetBinding(key1, "", "");
		if (ControlColumn == 1)
			IN_SetBinding(key2, "", "");
		return true;
	}
	return false;
}

//==========================================================================
//
//  MenuControl_Init
//
//==========================================================================

void MenuControl_Init(menucontrol_t * item, menu_t * parent, int x, int y,
	string text, string kbdown, string kbup)
{
	MenuCommon_Init(item, x, y, 0);
	item->drawer = MenuControl_Draw;
	item->responder = MenuControl_Use;
	item->text = text;
	item->command_on = kbdown;
	item->command_off = kbup;
	AddMenuItem(parent, item);
}

//**************************************************************************
//**
//**    Slot for saves and input lines
//**
//**************************************************************************

int pic_M_LSLEFT;
int pic_M_LSCNTR;
int pic_M_LSRGHT;

//==========================================================================
//
//  DrawSlot
//
//==========================================================================

int DrawSlot(int x, int y, string text, boolean entering)
{
	int xx;
	int j;

	R_DrawPic(x + 2, y + 12, pic_M_LSLEFT);
	for (j = 0, xx = x + 10; j < 24; j++, xx += 8)
	{
		R_DrawPic(xx, y + 12, pic_M_LSCNTR);
	}
	R_DrawPic(xx, y + 12, pic_M_LSRGHT);

	T_SetFont(font_small);
	T_SetAlign(hleft, vtop);
	T_DrawText(x + 8, y + 5, text);
	if (entering)
	{
		T_DrawCursor();
	}
	return 16;
}

//==========================================================================
//
//  InitSlot
//
//==========================================================================

void InitSlot(void)
{
	pic_M_LSLEFT = R_RegisterPic("M_LSLEFT", PIC_PATCH);
	pic_M_LSCNTR = R_RegisterPic("M_LSCNTR", PIC_PATCH);
	pic_M_LSRGHT = R_RegisterPic("M_LSRGHT", PIC_PATCH);
}

//**************************************************************************
//**
//**    Save slot
//**
//**************************************************************************

#define SLOTTEXTLEN 		24

struct menusaveslot_t:menucommon_t
{
	int status;
	int text[(SLOTTEXTLEN + 4) / 4];
};

boolean enteringText;
TILine slot_enter_text;

//==========================================================================
//
//  MenuSaveSlot_Draw
//
//==========================================================================

void MenuSaveSlot_Draw(menucommon_t * aitem)
{
	menusaveslot_t *item = (menusaveslot_t *) aitem;

	int x = item->x;
	int y = item->y;
	boolean is_active = ActiveItem() == aitem;

	if (enteringText && is_active)
	{
		DrawSlot(x, y, ARR2STR(slot_enter_text.Data), true);
	}
	else
	{
		DrawSlot(x, y, ARR2STR(item->text), false);
	}
	if (is_active)
	{
		DrawSelector(x, y);
	}
}

//==========================================================================
//
//  MenuSaveSlot_Use
//
//==========================================================================

boolean MenuSaveSlot_Use(menucommon_t * aitem, int key)
{
	menusaveslot_t *item = (menusaveslot_t *) aitem;

	if (enteringText)
	{
		// Save Game string input
		switch (key)
		{
		case K_ESCAPE:
		case K_MOUSE2:
			enteringText = false;
			break;

		case K_ENTER:
		case K_MOUSE1:
			enteringText = false;
			if (slot_enter_text.Data[0])
			{
				strcpy(ARR2STR(item->text), ARR2STR(slot_enter_text.Data));
				CmdBuf_AddText("Save %d \"%s\"\n", item->id,
					ARR2STR(item->text));
				ForceMenuOff();
			}
			break;

		default:
			InputLine_Key(&slot_enter_text, key);
			if (slot_enter_text.len >= SLOTTEXTLEN - 1)
			{
				InputLine_Key(&slot_enter_text, K_BACKSPACE);
			}
			break;
		}
		return true;
	}

	if (key == K_ENTER || key == K_MOUSE1 || key == K_JOY1)
	{
		if (item->callback)
			item->callback(aitem, MMSG_ACTIVATE);
		return true;
	}
	return false;
}

//==========================================================================
//
//  MenuSaveSlot_Init
//
//==========================================================================

void MenuSaveSlot_Init(menusaveslot_t * item, int x, int y)
{
	MenuCommon_Init(item, x, y, 0);
	item->drawer = MenuSaveSlot_Draw;
	item->responder = MenuSaveSlot_Use;
	InitSlot();
}

//**************************************************************************
//**
//**    Input line
//**
//**************************************************************************

struct menuinputline_t:menutext_t
{
	int value[32 / 4];
	int ilstyle;
};

//==========================================================================
//
//  MenuInputLine_Draw
//
//==========================================================================

void MenuInputLine_Draw(menucommon_t * aitem)
{
	menuinputline_t *item = (menuinputline_t *) aitem;
	int x = item->x;
	int y = item->y;

	MenuText_Draw(aitem);
	if (item->ilstyle == 1)
	{
		x += T_TextWidth(item->text) + 8;
		y -= 5;
	}
	else
	{
		y += 12;
	}
	if (enteringText)
		DrawSlot(x, y, ARR2STR(slot_enter_text.Data), true);
	else
		DrawSlot(x, y, ARR2STR(item->value), false);
}

//==========================================================================
//
//  MenuInputLine_Use
//
//==========================================================================

boolean MenuInputLine_Use(menucommon_t * aitem, int key)
{
	menuinputline_t *item = (menuinputline_t *) aitem;

	if (enteringText)
	{
		switch (key)
		{
		case K_ESCAPE:
		case K_MOUSE2:
			enteringText = false;
			break;

		case K_ENTER:
		case K_MOUSE1:
			enteringText = false;
			strcpy(ARR2STR(item->value), ARR2STR(slot_enter_text.Data));
			if (item->callback)
				item->callback(aitem, MMSG_ACTIVATE);
			break;

		default:
			InputLine_Key(&slot_enter_text, key);
			if (slot_enter_text.len >= 30)
			{
				InputLine_Key(&slot_enter_text, K_BACKSPACE);
			}
			break;
		}
		return true;
	}

	if (key == K_ENTER || key == K_MOUSE1 || key == K_JOY1)
	{
		// we are going to be intercepting all chars
		enteringText = true;
		InputLine_Init(&slot_enter_text);
		LocalSound("MenuSelect");
		InputLine_SetValue(&slot_enter_text, ARR2STR(item->value));
		return true;
	}
	return false;
}

//==========================================================================
//
//  MenuInputLine_Init
//
//==========================================================================

void MenuInputLine_Init(menuinputline_t * item, int x, int y, string text,
	int type, int ilstyle)
{
	MenuText_Init(item, x, y, 0, text, type);
	item->drawer = MenuInputLine_Draw;
	item->responder = MenuInputLine_Use;
	item->ilstyle = ilstyle;
	InitSlot();
}

//**************************************************************************
//**
//**    Server list
//**
//**************************************************************************

struct menuslist_t:menucommon_t
{
	int cursor;
};

slist_t * slist;

//==========================================================================
//
//  Text box
//
//==========================================================================

void DrawTextBox(string text)
{
	int x;
	int y;
	int w;
	int h;

	// Horiz. & Vertically center string and print it.
	T_SetFont(font_small);
	T_SetAlign(hcenter, vcenter);

	w = (T_TextWidth(text) + 16) & ~15;
	h = (T_TextHeight(text) + 16) & ~15;
	if (w > 304)
		w = 304;
	if (h > 184)
		h = 184;
	x = (320 - w) / 2;
	y = (200 - h) / 2;

	R_FillRectWithFlat(x, y, w, h, "F_PAVE01");
	DrawBorder(x, y, w, h);

	T_DrawText(160, 100, text);
}

//==========================================================================
//
//  MenuSlist_Draw
//
//==========================================================================

void MenuSlist_Draw(menucommon_t * aitem)
{
	int i;
	int x;
	int y;
	menuslist_t *item = (menuslist_t *) aitem;

	slist = GetSlist();

	T_SetFont(font_small);
	T_SetAlign(hleft, vtop);
	for (i = 0; i < slist->count; i++)
	{
		T_DrawText(16, 32 + 10 * i, ARR2STR(slist->cache[i].name));
		T_DrawText(16 + 128, 32 + 10 * i, ARR2STR(slist->cache[i].map));
		if (slist->cache[i].maxusers)
		{
			T_DrawText(16 + 256, 32 + 10 * i, va("%d/%d",
					slist->cache[i].users, slist->cache[i].maxusers));
		}
	}
	T_DrawText(8, 32 + item->cursor * 10, ">");

	if (slist->return_reason[0])
		T_DrawText(16, 116, ARR2STR(slist->return_reason));

	if (slist->count)
	{
		x = 8;
		y = 124;
		for (i = 0; i < 20 && slist->cache[item->cursor].wadfiles[i][0]; i++)
		{
			int w =

				T_TextWidth(ARR2STR(slist->cache[item->cursor].wadfiles[i]));
			if (x + w > 312)
			{
				x = 8;
				y += 9;
				if (y > 190)
					break;
			}
			T_DrawText(x, y, ARR2STR(slist->cache[item->cursor].wadfiles[i]));
			x += w + 8;
		}
	}

	if (slist->inProgress)
	{
		DrawTextBox("Searching...");
	}
	else if (!slist->count)
	{
		DrawTextBox("No servers found");
	}
}

//==========================================================================
//
//  MenuSlist_Use
//
//==========================================================================

boolean MenuSlist_Use(menucommon_t * aitem, int key)
{
	menuslist_t *item = (menuslist_t *) aitem;

	slist = GetSlist();

	if (slist->inProgress)
	{
		return true;
	}

	switch (key)
	{
	case K_DOWNARROW:
		if (slist->count)
		{
			item->cursor++;
			if (item->cursor >= slist->count)
				item->cursor = 0;
			LocalSound("MenuMove");
		}
		return true;

	case K_UPARROW:
		if (slist->count)
		{
			item->cursor--;
			if (item->cursor < 0)
				item->cursor = slist->count - 1;
			LocalSound("MenuMove");
		}
		return true;

	case K_ENTER:
		if (slist->count)
		{
			LocalSound("MenuSelect");
			CmdBuf_AddText("connect \"%s\"\n",
				slist->cache[item->cursor].cname);
		}
		return true;

	case K_SPACE:
		item->cursor = 0;
		StartSearch();
		return true;
	}
	return false;
}

//==========================================================================
//
//  MenuSlist_Init
//
//==========================================================================

void MenuSlist_Init(menuslist_t * item)
{
	MenuCommon_Init(item, 0, 0, 0);
	item->drawer = MenuSlist_Draw;
	item->responder = MenuSlist_Use;
	item->cursor = 0;
}

//**************************************************************************
//**
//**	MenuTextButton
//**
//**************************************************************************

class MenuTextButton:MenuObject
{
	string activateSound;
	string text;
	int textFont;
	int textHAlign;
	int textVAlign;

	defaultproperties
	{
		activateSound = "MenuSelect";
	}

	void ActivateEvent(void)
	{
	}

	boolean Key(int key)
	{
		if (key == K_ENTER || key == K_MOUSE1 || key == K_JOY1)
		{
			ActivateEvent();
			LocalSound(activateSound);
			return true;
		}
		return false;
	}

	void Draw(void)
	{
		T_SetFont(textFont);
		T_SetAlign(textHAlign, textVAlign);
		T_DrawText(x, y, text);
	}
}

//**************************************************************************
//**
//**	MenuBigTextButton
//**
//**************************************************************************

class MenuBigTextButton:MenuTextButton
{
	defaultproperties
	{
		textFont = font_big;
		textHAlign = hleft;
		textVAlign = vtop;
	}

	void Init(void)
	{
		::Init();
		InitSelector();
	}

	void Draw(void)
	{
		if (selected)
		{
			DrawSelector(x, y);
		}
		::Draw();
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.11  2002/01/03 18:32:28  dj_jl
//  Fixed menu
//
//  Revision 1.10  2001/12/12 19:14:11  dj_jl
//  Removed support for ASCII character constants
//
//  Revision 1.9  2001/12/04 18:22:08  dj_jl
//  Reworking menus
//
//  Revision 1.8  2001/12/01 18:04:24  dj_jl
//  Started reworking menus
//
//  Revision 1.7  2001/11/09 14:38:45  dj_jl
//  Moved input line to progs
//
//  Revision 1.6  2001/10/08 17:22:12  dj_jl
//  Changed slist to be returned by engine
//
//  Revision 1.5  2001/09/25 17:11:04  dj_jl
//  Seperated menu API
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/29 17:46:25  dj_jl
//  Moved view border and message box to progs
//  
//  Revision 1.2  2001/07/27 14:27:53  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
