//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define MAXMOVE			1050.0
#define STOPSPEED		2.1875
#define FRICTION		3.28125
#define FRICTION_WATER	3.0

#define BOUNCE_VAL		1.5

#define FLOATSPEED		140.0

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//**************************************************************************
//
//  OBJECT MOVEMENT
//
//**************************************************************************

//==========================================================================
//
//  Actor::XYMovement
//
//==========================================================================

void Actor::XYMovement(void)
{
	float ptryx;
	float ptryy;
	float xmove;
	float ymove;

	if (Velocity.x > MAXMOVE)
		Velocity.x = MAXMOVE;
	else if (Velocity.x < -MAXMOVE)
		Velocity.x = -MAXMOVE;

	if (Velocity.y > MAXMOVE)
		Velocity.y = MAXMOVE;
	else if (Velocity.y < -MAXMOVE)
		Velocity.y = -MAXMOVE;

	xmove = Velocity.x * frametime;
	ymove = Velocity.y * frametime;

	do
	{
		if (xmove > MAXMOVE / (35.0 * 2.0) || ymove > MAXMOVE / (35.0 * 2.0))
		{
			ptryx = Origin.x + xmove / 2.0;
			ptryy = Origin.y + ymove / 2.0;
			xmove /= 2.0;
			ymove /= 2.0;
		}
		else
		{
			ptryx = Origin.x + xmove;
			ptryy = Origin.y + ymove;
			xmove = 0.0;
			ymove = 0.0;
		}

		if (!TryMove(vector(ptryx, ptryy, Origin.z)))
		{
			// blocked move
			if (bIsPlayer)
			{
				// try to slide along it
				SlideMove();
			}
			else if (bMissile)
			{
#if 0
				if (Flags & MF_BOUNCE)
				{
					//  Bounce against walls and non-killable ofjects
					if (BlockingMobj)
					{
						if ((!BlockingMobj->bIsPlayer) &&
							(!(BlockingMobj->Flags & MF_COUNTKILL)))
						{
							float speed;
							float angle;

							angle = AngleMod360(
								atan2(Origin.y - BlockingMobj->Origin.y,
								Origin.x - BlockingMobj->Origin.x) +
								(Random() * 16.0 - 8.0));
							speed = Length(Velocity);
							speed = speed * 0.75;
							Angles.yaw = angle;
							Velocity.x = speed * cos(angle);
							Velocity.y = speed * sin(angle);
							if (PainSound)
							{
								PlaySound(PainSound, CHAN_VOICE);
							}
						}
						else
						{
							// Struck a player/creature
							P_ExplodeMissile(this);
						}
					}
					else
					{
						// Struck a wall
						BounceWall(BOUNCE_VAL);
						if (PainSound)
						{
							PlaySound(PainSound, CHAN_VOICE);
						}
					}
					if (destroyed)
					{
						return false;	// mobj was removed
					}
					return true;
				}
#endif

				// explode a missile
				if (tmtrace->CeilingLine && tmtrace->CeilingLine->backsector &&
					tmtrace->CeilingLine->backsector->ceiling.pic == skyflatnum)
				{
					// Hack to prevent missiles exploding
					// against the sky.
					// Does not handle sky floors.
					Remove();
					return;
				}
				ExplodeMissile();
			}
			else
			{
				Velocity.x = 0.0;
				Velocity.y = 0.0;
			}
		}
	}
	while (xmove || ymove);
}

//==========================================================================
//
//	Actor::ZMovement
//
//==========================================================================

void Actor::ZMovement(void)
{
	float dist;
	float delta;
	float vdot;

	// check for smooth step up
	if (bIsPlayer && Origin.z < FloorZ)
	{
		Player->ViewHeight -= FloorZ - Origin.z;

		Player->DeltaViewHeight
			= (VIEWHEIGHT - Player->ViewHeight) / 8.0;
	}

	// adjust height
	Origin.z += Velocity.z * frametime;

	if (bFloat && Enemy)
	{
		// float down towards enemy if too close
		if (!bSkullFly && !bInFloat)
		{
			dist = MobjDist2(self, Enemy);

			delta = Enemy.Origin.z + Height / 2.0 - Origin.z;

			if (delta < 0.0 && dist < -(delta * 3.0))
				Origin.z -= FLOATSPEED * frametime;
			else if (delta > 0.0 && dist < (delta * 3.0))
				Origin.z += FLOATSPEED * frametime;
		}
	}

	// clip movement
	if (Origin.z <= FloorZ + 0.1)
	{
		// hit the floor

		vdot = DotProduct(Velocity, Floor->normal);
		// Note (id):
		//  somebody left this after the setting momz to 0,
		//  kinda useless there.
		if (bSkullFly)
		{
			// the skull slammed into something
			Velocity.z = -Velocity.z;
		}

		if (vdot < -0.1)
		{
			if (bIsPlayer && (vdot < -GRAVITY * 0.25))
			{
				// Squat down.
				// Decrease ViewHeight for a moment
				// after hitting the ground (hard),
				// and utter appropriate sound.
				Player->DeltaViewHeight = vdot / 8.0 * frametime;
				PlaySound('PlayerLand', CHAN_VOICE);
			}
		}
		Origin.z = FloorZ;

		if (bMissile)
		{
//			if (!(Flags & (MF_NOCLIP | MF_BOUNCE)))
			if (bColideWithWorld)
			{
				ExplodeMissile();
				return;
			}
#if 0
			if (Flags & MF_BOUNCE && PainSound && Length(Velocity) > 256.0)
			{
				PlaySound(PainSound, CHAN_VOICE);
			}
#endif
		}
	}

	if (Origin.z + Height > CeilingZ)
	{
		// hit the ceiling
		vdot = DotProduct(Velocity, Ceiling->normal);
		if (vdot < 0.0)
			Velocity -= vdot * Ceiling->normal;

		Origin.z = CeilingZ - Height;

		if (bSkullFly)
		{
			// the skull slammed into something
			Velocity.z = -Velocity.z;
		}

		if (bMissile)
		{
//			if (!(Flags & (MF_NOCLIP | MF_BOUNCE)))
			if (bColideWithWorld)
			{
				ExplodeMissile();
				return;
			}
#if 0
			if (Flags & MF_BOUNCE && PainSound && Length(Velocity) > 256.0)
			{
				PlaySound(PainSound, CHAN_VOICE);
			}
#endif
		}
	}
}

//==========================================================================
//
//  Actor::ApplyFriction
//
//==========================================================================

void Actor::ApplyFriction(void)
{
	float dot;

	// slow down

	if (bMissile || bSkullFly)
		return;	// no friction for missiles ever

	if (Origin.z > FloorZ && !bOnMobj && WaterLevel < 2)
		return;	// no friction when airborne

	//  Clip velocity
	if (Origin.z <= FloorZ)
	{
		dot = DotProduct(Velocity, Floor->normal);
		if (dot < 0.0)
		{
#if 0
			if (Flags & MF_BOUNCE)
			{
				dot *= BOUNCE_VAL;
			}
#endif
			Velocity -= dot * Floor->normal;
		}
	}

	if (bCorpse)
	{
		// do not stop sliding if halfway off a step with some momentum
		if (Velocity.x > 0.25 * 35.0 || Velocity.x < -0.25 * 35.0 ||
			Velocity.y > 0.25 * 35.0 || Velocity.y < -0.25 * 35.0)
		{
			if (FloorZ != Sector->floorheight)
				return;
		}
	}

	if (Velocity.x > -STOPSPEED && Velocity.x < STOPSPEED &&
		Velocity.y > -STOPSPEED && Velocity.y < STOPSPEED &&
		Velocity.z > -STOPSPEED && Velocity.z < STOPSPEED &&
		(!bIsPlayer || (!Player->ForwardMove && !Player->SideMove)))
	{
		if (bIsPlayer)
		{
			int sn;

			// if in a walking frame, stop moving
			sn = StateNum - SeeState;
			if (sn >= 0 && sn < 4)
				SetState(IdleState);
		}
		Velocity = vector(0.0, 0.0, 0.0);
	}
	else
	{
		if (WaterLevel > 1)
		{
			Velocity -= Velocity * (FRICTION_WATER * frametime);
		}
		else
		{
			Velocity -= Velocity * (FRICTION * frametime);
		}
	}
}

//===========================================================================
//
//  Actor::PlayerLandedOnThing
//
//===========================================================================

void Actor::PlayerLandedOnThing(void)
{
	Player->DeltaViewHeight = Velocity.z * frametime / 8.0;
	if (Velocity.z < -GRAVITY * 0.375)
	{
		PlaySound('PlayerLand', CHAN_VOICE);
	}
}

//==========================================================================
//
//	Actor::Physics
//
//==========================================================================

boolean Actor::Physics(void)
{
	Actor onmo;

	CheckWater();
	UpdateVelocity();

	// momentum movement
	if (Velocity.x || Velocity.y)
	{
		XYMovement();
		if (IsDestroyed())
		{
			return false;	// mobj was removed
		}
	}
	else if (bSkullFly)
	{
		// the skull slammed into something
		bSkullFly = false;
		Velocity = vector(0.0, 0.0, 0.0);
		if (!SetState(IdleState))
		{
			return false;
		}
	}
	if ((Origin.z != FloorZ) || Velocity.z || tmtrace->BlockingMobj)
	{
		// Handle Z momentum and gravity
		onmo = Actor(CheckOnmobj());
		if (!onmo)
		{
			ZMovement();
			if (bIsPlayer && bOnMobj)
			{
				bOnMobj = false;
			}
		}
		else
		{
			if (bIsPlayer)
			{
				if (Velocity.z < -GRAVITY * 0.25)
				{
					PlayerLandedOnThing();
				}
				if (onmo.Origin.z + onmo.Height - Origin.z <= MaxStepHeight)
				{
					Player->ViewHeight -= onmo.Origin.z + onmo.Height
						- Origin.z;
					Player->DeltaViewHeight =
						(VIEWHEIGHT - Player->ViewHeight) / 8.0;
					Origin.z = onmo.Origin.z + onmo.Height;
					bOnMobj = true;
					Velocity.z = 0.0;
				}
				else
				{
					// hit the bottom of the blocking actor
					Velocity.z = 0.0;
				}
			}
		}
		if (IsDestroyed())
		{
			return false;	// entity was removed
		}
	}
	return true;
}

//==========================================================================
//
//	Actor::Tick
//
//==========================================================================

void Actor::Tick(float deltaTime)
{
	//  In my deathmatch mode remove dropped weapons after 30 seconds
	// because otherwise they are spawned fastar than player(s) can pick 
	// them up and the game is going slower and slower and slower ...
	if (bDropped && (deathmatch == 3))
	{
		MoveCount++;
		if (MoveCount >= 30 * 35)
		{
			Remove();
			return;
		}
	}

	if (!Physics())
	{
		return;
	}

	// cycle through states,
	// calling action functions at transitions
	if (StateTime != -1.0)
	{
		StateTime -= deltaTime;

		// you can cycle through multiple states in a tic
		if (StateTime <= 0.0)
		{
			StateTime = 0.0;
			if (!SetState(NextState))
				return;	// freed itself
		}
	}
	else
	{
		// check for nightmare respawn
		if (!bCountKill)
			return;

		//  In my deathmatch mode monstars respawns very fast
		if (deathmatch == 3)
		{
			if (level->tictime & 31)
				return;

			if (P_Random() > 32)
				return;

			NightmareRespawn();
		}
		else
		{
			if (!respawnmonsters)
				return;

			MoveCount++;

			if (MoveCount < 12 * 35)
				return;

			if (level->tictime & 31)
				return;

			if (P_Random() > 4)
				return;

			NightmareRespawn();
		}
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.29  2002/06/22 07:09:58  dj_jl
//  Made sliding and bouncing functions native.
//
//  Revision 1.28  2002/05/18 17:00:04  dj_jl
//  Renamed SpawnState to IdleState, other changes.
//
//  Revision 1.27  2002/04/27 17:04:54  dj_jl
//  Merged all creatures.
//
//  Revision 1.26  2002/04/11 16:50:54  dj_jl
//  Made TryMove native, Tick function.
//
//  Revision 1.25  2002/03/20 19:07:47  dj_jl
//  Got rid of a lots of legacy, beautification.
//
//  Revision 1.24  2002/03/09 17:57:02  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.23  2002/03/04 18:31:36  dj_jl
//  Replaced bNoClip with two seperate flags, beautification.
//
//  Revision 1.22  2002/03/02 17:41:13  dj_jl
//  Renamed Enemy to Target. Beautification.
//
//  Revision 1.21  2002/02/26 17:49:49  dj_jl
//  no message
//
//  Revision 1.20  2002/02/22 18:00:26  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.19  2002/02/16 16:26:56  dj_jl
//  Removed precalculated sound IDs
//
//  Revision 1.18  2002/02/14 19:21:00  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.17  2002/02/07 18:50:09  dj_jl
//  Made CheckPosition shared.
//
//  Revision 1.16  2002/02/06 17:28:53  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.15  2002/02/02 19:17:26  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.14  2002/01/28 18:50:20  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.13  2002/01/24 18:19:27  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.12  2002/01/15 18:27:01  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.11  2002/01/11 18:19:43  dj_jl
//  Started to use names in progs
//
//  Revision 1.10  2002/01/07 12:27:42  dj_jl
//  Changed copyright year
//
//  Revision 1.9  2001/12/27 17:52:24  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.8  2001/12/01 18:08:53  dj_jl
//  Physics functions as methods, started to use class references
//
//  Revision 1.7  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.6  2001/10/02 17:42:38  dj_jl
//  Possibility to declare function's code inside class declaration
//
//  Revision 1.5  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.4  2001/09/20 16:20:00  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.3  2001/08/30 17:33:18  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:53  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
