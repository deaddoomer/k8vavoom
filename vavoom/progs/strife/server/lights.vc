//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**    Light specials
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//**************************************************************************
//
//  FIRELIGHT FLICKER
//
//**************************************************************************

class TFireFlicker:Thinker
{
	sector_t *sector;
	float time;
	int maxlight;
	int minlight;

	void Think(void);
	void Archive(void);
	void Unarchive(void);
};

//==========================================================================
//
//	TFireFlicker::Think
//
//==========================================================================

void TFireFlicker::Think(void)
{
	int amount;

	time -= frametime;
	if (time > 0.0)
	{
		return;
	}

	amount = (P_Random() & 3) * 16;

	if (sector->params.lightlevel - amount < minlight)
		sector->params.lightlevel = minlight;
	else
		sector->params.lightlevel = maxlight - amount;

	time = 4.0 / 35.0;
}

//==========================================================================
//
//	TFireFlicker::Archive
//
//==========================================================================

void TFireFlicker::Archive(void)
{
	sector = SectorToNum(sector);
}

//==========================================================================
//
//	TFireFlicker::Unarchive
//
//==========================================================================

void TFireFlicker::Unarchive(void)
{
	sector = NumToSector(sector);
}

//==========================================================================
//
//  P_SpawnFireFlicker
//
//==========================================================================

void P_SpawnFireFlicker(sector_t * sector)
{
	TFireFlicker *flick;

	// Note that we are resetting sector attributes.
	// Nothing special about it during gameplay.
	sector->special = 0;

	flick = NewSpecialThinker(TFireFlicker);

	flick->sector = sector;
	flick->time = 4.0 / 35.0;
	flick->maxlight = sector->params.lightlevel;
	flick->minlight =
		FindMinSurroundingLight(sector, sector->params.lightlevel) + 16;
}

//**************************************************************************
//
//  GLOWING LIGHT
//
//**************************************************************************

#define GLOWSPEED			256.0

class TGlow:Thinker
{
	sector_t *sector;
	int direction;
	int maxlight;
	int minlight;

	void Think(void);
	void Archive(void);
	void Unarchive(void);
};

//==========================================================================
//
//  T_Glow
//
//==========================================================================

void TGlow::Think(void)
{
	switch (direction)
	{
	case -1:
		// DOWN
		sector->params.lightlevel -= ftoi(GLOWSPEED * frametime);
		if (sector->params.lightlevel <= minlight)
		{
			sector->params.lightlevel += ftoi(GLOWSPEED * frametime);
			direction = 1;
		}
		break;

	case 1:
		// UP
		sector->params.lightlevel += ftoi(GLOWSPEED * frametime);
		if (sector->params.lightlevel >= maxlight)
		{
			sector->params.lightlevel -= ftoi(GLOWSPEED * frametime);
			direction = -1;
		}
		break;
	}
}

//==========================================================================
//
//	TGlow::Archive
//
//==========================================================================

void TGlow::Archive(void)
{
	sector = SectorToNum(sector);
}

//==========================================================================
//
//	TGlow::Unarchive
//
//==========================================================================

void TGlow::Unarchive(void)
{
	sector = NumToSector(sector);
}

//==========================================================================
//
//  P_SpawnGlowingLight
//
//  Spawn glowing light
//
//==========================================================================

void P_SpawnGlowingLight(sector_t * sector)
{
	TGlow *g;

	g = NewSpecialThinker(TGlow);

	g->sector = sector;
	g->minlight = FindMinSurroundingLight(sector, sector->params.lightlevel);
	g->maxlight = sector->params.lightlevel;
	g->direction = -1;

	sector->special = 0;
}

//**************************************************************************
//
//  BROKEN LIGHT FLASHING
//
//**************************************************************************

class TLightFlash:Thinker
{
	sector_t *sector;
	float time;
	int maxlight;
	int minlight;
	int maxtime;
	int mintime;

	void Think(void);
	void Archive(void);
	void Unarchive(void);
};

//==========================================================================
//
//  T_LightFlash
//
//  Do flashing lights.
//
//==========================================================================

void TLightFlash::Think(void)
{
	time -= frametime;
	if (time >= 0.0)
	{
		return;
	}

	if (sector->params.lightlevel == maxlight)
	{
		sector->params.lightlevel = minlight;
		time = itof((P_Random() & mintime) + 1) / 35.0;
	}
	else
	{
		sector->params.lightlevel = maxlight;
		time = itof((P_Random() & maxtime) + 1) / 35.0;
	}

}

//==========================================================================
//
//  TLightFlash::Archive
//
//==========================================================================

void TLightFlash::Archive(void)
{
	sector = SectorToNum(sector);
}

//==========================================================================
//
//	TLightFlash::Unarchive
//
//==========================================================================

void TLightFlash::Unarchive(void)
{
	sector = NumToSector(sector);
}

//==========================================================================
//
//  P_SpawnLightFlash
//
//  After the map has been loaded, scan each sector
// for specials that spawn thinkers
//
//==========================================================================

void P_SpawnLightFlash(sector_t * sector)
{
	TLightFlash *flash;

	// nothing special about it during gameplay
	sector->special = 0;

	flash = NewSpecialThinker(TLightFlash);

	flash->sector = sector;
	flash->maxlight = sector->params.lightlevel;
	flash->minlight =
		FindMinSurroundingLight(sector, sector->params.lightlevel);
	flash->maxtime = 64;
	flash->mintime = 7;
	flash->time = itof((P_Random() & flash->maxtime) + 1) / 35.0;
}

//**************************************************************************
//
//  STROBE LIGHT FLASHING
//
//**************************************************************************

#define STROBEBRIGHT		5
#define FASTDARK			15
#define SLOWDARK			35

class TStrobe:Thinker
{
	sector_t *sector;
	float time;
	int maxlight;
	int minlight;
	float maxtime;
	float mintime;

	void Think(void);
	void Archive(void);
	void Unarchive(void);
};

//==========================================================================
//
//  T_StrobeFlash
//
//==========================================================================

void TStrobe::Think(void)
{
	time -= frametime;
	if (time > 0.0)
	{
		return;
	}

	if (sector->params.lightlevel == minlight)
	{
		sector->params.lightlevel = maxlight;
		time = maxtime;
	}
	else
	{
		sector->params.lightlevel = minlight;
		time = mintime;
	}
}

//==========================================================================
//
//	TStrobe::Archive
//
//==========================================================================

void TStrobe::Archive(void)
{
	sector = SectorToNum(sector);
}

//==========================================================================
//
//	TStrobe::Unarchive
//
//==========================================================================

void TStrobe::Unarchive(void)
{
	sector = NumToSector(sector);
}

//==========================================================================
//
//  P_SpawnStrobeFlash
//
//  After the map has been loaded, scan each sector for specials that spawn
// thinkers
//
//==========================================================================

void P_SpawnStrobeFlash(sector_t * sector, int fastOrSlow, int maxtime,
	int inSync)
{
	TStrobe *flash;

	flash = NewSpecialThinker(TStrobe);

	flash->sector = sector;
	flash->mintime = itof(fastOrSlow) / 35.0;
	flash->maxtime = itof(maxtime) / 35.0;
	flash->maxlight = sector->params.lightlevel;
	flash->minlight =
		FindMinSurroundingLight(sector, sector->params.lightlevel);

	if (flash->minlight == flash->maxlight)
		flash->minlight = 0;

	// nothing special about it during gameplay
	sector->special = 0;

	if (!inSync)
		flash->time = (Random() * 8.0 + 1.0) / 35.0;
	else
		flash->time = 1.0 / 35.0;
}

//==========================================================================
//
//  EV_StartLightStrobing
//
//  Start strobing lights (usually from a trigger)
//
//==========================================================================

int EV_StartLightStrobing(line_t * line, int *args)
{
	int secnum;
	sector_t *sec;

	secnum = -1;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &level->sectors[secnum];
		if (sec->specialdata)
			continue;

		P_SpawnStrobeFlash(sec, args[2], args[1], 0);
	}
	return 1;
}

//**************************************************************************
//
//  TURN LINE'S TAG LIGHTS ON / OFF
//
//**************************************************************************

//==========================================================================
//
//  EV_TagLightTurnOn
//
//==========================================================================

int EV_TagLightTurnOn(line_t * line, int *args)
{
	int i;
	int j;
	sector_t *sector;
	sector_t *temp;
	line_t *templine;
	int max;

	for (i = 0; i < level->numsectors; i++)
	{
		sector = &level->sectors[i];

		if (sector->tag == args[0])
		{
			max = 0;
			for (j = 0; j < sector->linecount; j++)
			{
				templine = sector->lines[j];
				temp = getNextSector(templine, sector);
				if (!temp)
					continue;
				if (temp->params.lightlevel > max)
					max = temp->params.lightlevel;
			}
			sector->params.lightlevel = max;
		}
	}
	return 1;
}

//==========================================================================
//
//  EV_TurnTagLightsOff
//
//==========================================================================

int EV_TurnTagLightsOff(line_t * line, int *args)
{
	int i;
	int j;
	int min;
	sector_t *sector;
	sector_t *tsec;
	line_t *templine;

	for (j = 0; j < level->numsectors; j++)
	{
		sector = &level->sectors[j];

		if (sector->tag == args[0])
		{
			min = sector->params.lightlevel;
			for (i = 0; i < sector->linecount; i++)
			{
				templine = sector->lines[i];
				tsec = getNextSector(templine, sector);
				if (!tsec)
					continue;
				if (tsec->params.lightlevel < min)
					min = tsec->params.lightlevel;
			}
			sector->params.lightlevel = min;
		}
	}
	return 1;
}

//**************************************************************************
//
//	Hexen light specials
//
//**************************************************************************

enum
{
	LITE_RAISEBYVALUE,
	LITE_LOWERBYVALUE,
	LITE_CHANGETOVALUE,
	LITE_FADE,
	LITE_GLOW,
	LITE_FLICKER,
	LITE_STROBE
};

class TLight:Thinker
{
	sector_t *sector;
	int type;
	int value1;
	int value2;
	float time1;
	float time2;
	int direction;
	float time;
	float delta;

	void Think(void);
	void Archive(void);
	void Unarchive(void);
};

//============================================================================
//
//	TLight::Think
//
//============================================================================

void TLight::Think(void)
{
	if (time)
	{
		time -= frametime;
		if (time <= 0.0)
		{
			time = 0.0;
		}
		return;
	}
	switch (type)
	{
	case LITE_FADE:
		sector->params.lightlevel += ftoi(delta * frametime);
		if (direction == 1)
		{
			if (sector->params.lightlevel >= value1)
			{
				sector->params.lightlevel = value1;
				RemoveSpecialThinker(this);
			}
		}
		else if (sector->params.lightlevel <= value1)
		{
			sector->params.lightlevel = value1;
			RemoveSpecialThinker(this);
		}
		break;

	case LITE_GLOW:
		sector->params.lightlevel += ftoi(delta * frametime);
		if (direction == 1)
		{
			if (sector->params.lightlevel >= value1)
			{
				sector->params.lightlevel = value1;
				delta = -delta;
				direction = -1;	// reverse direction
			}
		}
		else if (sector->params.lightlevel <= value2)
		{
			sector->params.lightlevel = value2;
			delta = -delta;
			direction = 1;	// reverse direction
		}
		break;

	case LITE_FLICKER:
		if (sector->params.lightlevel == value1)
		{
			sector->params.lightlevel = value2;
			time = itof((P_Random() & 7) + 1) / 32.0;
		}
		else
		{
			sector->params.lightlevel = value1;
			time = itof((P_Random() & 31) + 1) / 32.0;
		}
		break;

	case LITE_STROBE:
		if (sector->params.lightlevel == value1)
		{
			sector->params.lightlevel = value2;
			time = time2;
		}
		else
		{
			sector->params.lightlevel = value1;
			time = time1;
		}
		break;

	default:
		break;
	}
}

//==========================================================================
//
//  TLight::Archive
//
//==========================================================================

void TLight::Archive(void)
{
	sector = SectorToNum(sector);
}

//==========================================================================
//
//  TLight::Unarchive
//
//==========================================================================

void TLight::Unarchive(void)
{
	//  Restore sector pointer
	sector = NumToSector(sector);
}

//============================================================================
//
//  EV_SpawnLight
//
//============================================================================

boolean EV_SpawnLight(line_t * line, int *arg, int type)
{
	TLight *light;
	sector_t *sec;
	int secNum;
	int arg1, arg2, arg3, arg4;
	boolean think;
	boolean rtn;

	arg1 = arg[1] > 255 ? 255 : arg[1];
	arg1 = arg1 < 0 ? 0 : arg1;
	arg2 = arg[2] > 255 ? 255 : arg[2];
	arg2 = arg2 < 0 ? 0 : arg2;
	arg3 = arg[3] > 255 ? 255 : arg[3];
	arg3 = arg3 < 0 ? 0 : arg3;
	arg4 = arg[4] > 255 ? 255 : arg[4];
	arg4 = arg4 < 0 ? 0 : arg4;

	secNum = -1;
	rtn = false;
	think = false;
	while ((secNum = FindSectorFromTag(arg[0], secNum)) >= 0)
	{
		think = false;
		sec = &level->sectors[secNum];

		light = NewSpecialThinker(TLight);
		light->type = type;
		light->sector = sec;
		light->time = 0.0;
		rtn = true;
		switch (type)
		{
		case LITE_RAISEBYVALUE:
			sec->params.lightlevel += arg1;
			if (sec->params.lightlevel > 255)
			{
				sec->params.lightlevel = 255;
			}
			break;
		case LITE_LOWERBYVALUE:
			sec->params.lightlevel -= arg1;
			if (sec->params.lightlevel < 0)
			{
				sec->params.lightlevel = 0;
			}
			break;
		case LITE_CHANGETOVALUE:
			sec->params.lightlevel = arg1;
			if (sec->params.lightlevel < 0)
			{
				sec->params.lightlevel = 0;
			}
			else if (sec->params.lightlevel > 255)
			{
				sec->params.lightlevel = 255;
			}
			break;
		case LITE_FADE:
			think = true;
			light->value1 = arg1;	// destination lightlevel
			light->delta = itof((arg1 - sec->params.lightlevel) / arg2) * 32.0;	// delta lightlevel
			if (sec->params.lightlevel <= arg1)
			{
				light->direction = 1;	// get brighter
			}
			else
			{
				light->direction = -1;
			}
			break;
		case LITE_GLOW:
			think = true;
			light->value1 = arg1;	// upper lightlevel
			light->value2 = arg2;	// lower lightlevel
			light->delta = itof((arg1 - sec->params.lightlevel) / arg3) * 32.0;	// lightlevel delta
			if (sec->params.lightlevel <= arg1)
			{
				light->direction = 1;	// get brighter
			}
			else
			{
				light->direction = -1;
			}
			break;
		case LITE_FLICKER:
			think = true;
			light->value1 = arg1;	// upper lightlevel
			light->value2 = arg2;	// lower lightlevel
			sec->params.lightlevel = light->value1;
			light->time = itof((P_Random() & 64) + 1) / 32.0;
			break;
		case LITE_STROBE:
			think = true;
			light->value1 = arg1;	// upper lightlevel
			light->value2 = arg2;	// lower lightlevel
			light->time1 = itof(arg3) / 35.0;	// upper tics
			light->time2 = itof(arg4) / 35.0;	// lower tics
			light->time = itof(arg3) / 35.0;
			sec->params.lightlevel = light->value1;
			break;
		default:
			rtn = false;
			break;
		}
		if (!think)
		{
			RemoveSpecialThinker(light);
		}
	}
	return rtn;
}

#if 0
//**************************************************************************
//
//
//
//**************************************************************************

#define LIGHT_SEQUENCE_START    2
#define LIGHT_SEQUENCE          3
#define LIGHT_SEQUENCE_ALT      4

class TPhase:Thinker
{
	sector_t *sector;
	float index;
	int base;

	void Think(void);
	void Archive(void);
	void Unarchive(void);
};

int PhaseTable[64] = {
	128, 112, 96, 80, 64, 48, 32, 32,
	16, 16, 16, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 16, 16, 16,
	32, 32, 48, 64, 80, 96, 112, 128
};

//============================================================================
//
//	TPhase::Think
//
//============================================================================

void TPhase::Think(void)
{
	index += frametime;
	sector->params.lightlevel = base + PhaseTable[ftoi(index * 32.0) & 63];
}

//==========================================================================
//
//  TPhase::Archive
//
//==========================================================================

void TPhase::Archive(void)
{
	sector = SectorToNum(sector);
}

//==========================================================================
//
//  TPhase::Unarchive
//
//==========================================================================

void TPhase::Unarchive(void)
{
	//  Restore sector pointer
	sector = NumToSector(sector);
}

//==========================================================================
//
// P_SpawnPhasedLight
//
//==========================================================================

void P_SpawnPhasedLight(sector_t * sector, int base, int index)
{
	TPhase *phase;

	phase = NewSpecialThinker(TPhase);
	phase->sector = sector;
	if (index == -1)
	{
		// sector->lightlevel as the index
		phase->index = itof(sector->params.lightlevel) / 32.0;
	}
	else
	{
		phase->index = itof(index) / 32.0;
	}
	phase->base = base & 255;
	sector->params.lightlevel = phase->base + PhaseTable[ftoi(phase->index * 32.0) & 63];

	sector->special = 0;
}

//==========================================================================
//
// P_SpawnLightSequence
//
//==========================================================================

void P_SpawnLightSequence(sector_t * sector, float indexStep)
{
	sector_t *sec;
	sector_t *nextSec;
	sector_t *tempSec;
	int seqSpecial;
	int i;
	float count;
	float index;
	float indexDelta;
	int base;

	seqSpecial = LIGHT_SEQUENCE;	// look for Light_Sequence, first
	sec = sector;
	count = 1.0;
	do
	{
		nextSec = NULL;
		sec->special = LIGHT_SEQUENCE_START;	// make sure that the search doesn't back up.
		for (i = 0; i < sec->linecount; i++)
		{
			tempSec = getNextSector(sec->lines[i], sec);
			if (!tempSec)
			{
				continue;
			}
			if (tempSec->special == seqSpecial)
			{
				if (seqSpecial == LIGHT_SEQUENCE)
				{
					seqSpecial = LIGHT_SEQUENCE_ALT;
				}
				else
				{
					seqSpecial = LIGHT_SEQUENCE;
				}
				nextSec = tempSec;
				count += 1.0;
			}
		}
		sec = nextSec;
	}
	while (sec);

	sec = sector;
	count *= indexStep;
	index = 0.0;
	indexDelta = 64.0 / count;
	base = sector->params.lightlevel;
	do
	{
		nextSec = NULL;
		if (sec->params.lightlevel)
		{
			base = sec->params.lightlevel;
		}
		P_SpawnPhasedLight(sec, base, ftoi(index));
		index += indexDelta;
		for (i = 0; i < sec->linecount; i++)
		{
			tempSec = getNextSector(sec->lines[i], sec);
			if (!tempSec)
			{
				continue;
			}
			if (tempSec->special == LIGHT_SEQUENCE_START)
			{
				nextSec = tempSec;
			}
		}
		sec = nextSec;
	}
	while (sec);
}
#endif

//**************************************************************************
//
//	Static light sources
//
//**************************************************************************

//==========================================================================
//
//  misc_static_light
//
//==========================================================================

class misc_static_light:Entity
{
	void OnMapSpawn(mthing_t * mthing)
	{
		float l;

		RemoveMobjThinker(this);
		if (!mthing->arg1)
			l = 200.0;
		else
			l = itof(mthing->arg1) * 8.0;
		AddStaticLight(vector(mthing->x, mthing->y, mthing->height), l);
	}
};

//==========================================================================
//
//  misc_static_rgb_light
//
//==========================================================================

class misc_static_rgb_light:Entity
{
	void OnMapSpawn(mthing_t * mthing)
	{
		float l;

		RemoveMobjThinker(this);
		if (!mthing->arg1)
			l = 200.0;
		else
			l = itof(mthing->arg1) * 8.0;
		AddStaticLightRGB(vector(mthing->x, mthing->y, mthing->height), l,
			RGB(mthing->arg2, mthing->arg3, mthing->arg4));
	}
};

__mobjinfo__
{
	{ 1502, misc_static_light }
	{ 1503, misc_static_rgb_light }
}

//**************************************************************************
//
//  $Log$
//  Revision 1.9  2002/01/07 12:27:42  dj_jl
//  Changed copyright year
//
//  Revision 1.8  2001/12/18 18:29:22  dj_jl
//  Added Hexen action specials
//
//  Revision 1.6  2001/10/22 17:23:11  dj_jl
//  Floatification of angles
//
//  Revision 1.5  2001/10/09 17:33:29  dj_jl
//  Moved static light sources into games
//
//  Revision 1.4  2001/09/24 17:13:25  dj_jl
//  Created thinker classes
//
//  Revision 1.3  2001/09/20 16:19:59  dj_jl
//  Start using object-oriented stuff, beautification
//
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
