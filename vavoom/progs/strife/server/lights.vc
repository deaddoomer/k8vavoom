//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**    Light specials
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

int PhaseTable[64] = {
	128, 112, 96, 80, 64, 48, 32, 32,
	16, 16, 16, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 16, 16, 16,
	32, 32, 48, 64, 80, 96, 112, 128
};

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  P_SpawnFireFlicker
//
//==========================================================================

void P_SpawnFireFlicker(sector_t * sector)
{
	FireFlicker Flick;

	Flick = NewSpecialThinker(FireFlicker);

	Flick.sector = sector;
	Flick.time = 4.0 / 35.0;
	Flick.maxlight = sector->params.lightlevel;
	Flick.minlight = FindMinSurroundingLight(sector,
		sector->params.lightlevel) + 16;
}

//==========================================================================
//
//  P_SpawnGlowingLight
//
//  Spawn glowing light
//
//==========================================================================

void P_SpawnGlowingLight(sector_t * sector)
{
	GlowingLight G;

	G = NewSpecialThinker(GlowingLight);

	G.sector = sector;
	G.minlight = FindMinSurroundingLight(sector, sector->params.lightlevel);
	G.maxlight = sector->params.lightlevel;
	G.direction = -1;
}

//==========================================================================
//
//  P_SpawnLightFlash
//
//  After the map has been loaded, scan each sector
// for specials that spawn thinkers
//
//==========================================================================

void P_SpawnLightFlash(sector_t * sector)
{
	LightFlash Flash;

	Flash = NewSpecialThinker(LightFlash);

	Flash.sector = sector;
	Flash.maxlight = sector->params.lightlevel;
	Flash.minlight = FindMinSurroundingLight(sector,
		sector->params.lightlevel);
	Flash.maxtime = 64;
	Flash.mintime = 7;
	Flash.time = itof((P_Random() & Flash.maxtime) + 1) / 35.0;
}

#define STROBEBRIGHT		5
#define FASTDARK			15
#define SLOWDARK			35

//==========================================================================
//
//  P_SpawnStrobeFlash
//
//  After the map has been loaded, scan each sector for specials that spawn
// thinkers
//
//==========================================================================

void P_SpawnStrobeFlash(sector_t * sector, int fastOrSlow, int maxtime,
	int inSync)
{
	Strobe Flash;

	Flash = NewSpecialThinker(Strobe);

	Flash.sector = sector;
	Flash.mintime = itof(fastOrSlow) / 35.0;
	Flash.maxtime = itof(maxtime) / 35.0;
	Flash.maxlight = sector->params.lightlevel;
	Flash.minlight = FindMinSurroundingLight(sector,
		sector->params.lightlevel);

	if (Flash.minlight == Flash.maxlight)
		Flash.minlight = 0;

	if (!inSync)
		Flash.time = (Random() * 8.0 + 1.0) / 35.0;
	else
		Flash.time = 1.0 / 35.0;
}

//==========================================================================
//
//  EV_StartLightStrobing
//
//  Start strobing lights (usually from a trigger)
//
//==========================================================================

int EV_StartLightStrobing(line_t * line, int *args)
{
	int secnum;
	sector_t *sec;

	secnum = -1;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &GLevel.Sectors[secnum];
		if (sec->SpecialData)
			continue;

		P_SpawnStrobeFlash(sec, args[2], args[1], 0);
	}
	return 1;
}

//**************************************************************************
//
//  TURN LINE'S TAG LIGHTS ON / OFF
//
//**************************************************************************

//==========================================================================
//
//  EV_TagLightTurnOn
//
//==========================================================================

int EV_TagLightTurnOn(line_t * line, int *args)
{
	int i;
	int j;
	sector_t *sector;
	sector_t *temp;
	line_t *templine;
	int max;

	for (i = 0; i < GLevel.NumSectors; i++)
	{
		sector = &GLevel.Sectors[i];

		if (sector->tag == args[0])
		{
			max = 0;
			for (j = 0; j < sector->linecount; j++)
			{
				templine = sector->lines[j];
				temp = getNextSector(templine, sector);
				if (!temp)
					continue;
				if (temp->params.lightlevel > max)
					max = temp->params.lightlevel;
			}
			sector->params.lightlevel = max;
		}
	}
	return 1;
}

//==========================================================================
//
//  EV_TurnTagLightsOff
//
//==========================================================================

int EV_TurnTagLightsOff(line_t * line, int *args)
{
	int i;
	int j;
	int min;
	sector_t *sector;
	sector_t *tsec;
	line_t *templine;

	for (j = 0; j < GLevel.NumSectors; j++)
	{
		sector = &GLevel.Sectors[j];

		if (sector->tag == args[0])
		{
			min = sector->params.lightlevel;
			for (i = 0; i < sector->linecount; i++)
			{
				templine = sector->lines[i];
				tsec = getNextSector(templine, sector);
				if (!tsec)
					continue;
				if (tsec->params.lightlevel < min)
					min = tsec->params.lightlevel;
			}
			sector->params.lightlevel = min;
		}
	}
	return 1;
}

//**************************************************************************
//
//	Hexen light specials
//
//**************************************************************************

enum
{
	LITE_RAISEBYVALUE,
	LITE_LOWERBYVALUE,
	LITE_CHANGETOVALUE,
	LITE_FADE,
	LITE_GLOW,
	LITE_FLICKER,
	LITE_STROBE
};

//============================================================================
//
//  EV_SpawnLight
//
//============================================================================

bool EV_SpawnLight(line_t * line, int *arg, int type)
{
	LightEffect Light;
	sector_t *sec;
	int secNum;
	int arg1, arg2, arg3, arg4;
	bool think;
	bool rtn;

	arg1 = arg[1] > 255 ? 255 : arg[1];
	arg1 = arg1 < 0 ? 0 : arg1;
	arg2 = arg[2] > 255 ? 255 : arg[2];
	arg2 = arg2 < 0 ? 0 : arg2;
	arg3 = arg[3] > 255 ? 255 : arg[3];
	arg3 = arg3 < 0 ? 0 : arg3;
	arg4 = arg[4] > 255 ? 255 : arg[4];
	arg4 = arg4 < 0 ? 0 : arg4;

	secNum = -1;
	rtn = false;
	think = false;
	while ((secNum = FindSectorFromTag(arg[0], secNum)) >= 0)
	{
		think = false;
		sec = &GLevel.Sectors[secNum];

		Light = NewSpecialThinker(LightEffect);
		Light.type = type;
		Light.sector = sec;
		Light.time = 0.0;
		rtn = true;
		switch (type)
		{
		case LITE_RAISEBYVALUE:
			sec->params.lightlevel += arg1;
			if (sec->params.lightlevel > 255)
			{
				sec->params.lightlevel = 255;
			}
			break;
		case LITE_LOWERBYVALUE:
			sec->params.lightlevel -= arg1;
			if (sec->params.lightlevel < 0)
			{
				sec->params.lightlevel = 0;
			}
			break;
		case LITE_CHANGETOVALUE:
			sec->params.lightlevel = arg1;
			if (sec->params.lightlevel < 0)
			{
				sec->params.lightlevel = 0;
			}
			else if (sec->params.lightlevel > 255)
			{
				sec->params.lightlevel = 255;
			}
			break;
		case LITE_FADE:
			think = true;
			Light.value1 = arg1;	// destination lightlevel
			Light.delta = itof((arg1 - sec->params.lightlevel) / arg2) * 32.0;	// delta lightlevel
			if (sec->params.lightlevel <= arg1)
			{
				Light.direction = 1;	// get brighter
			}
			else
			{
				Light.direction = -1;
			}
			break;
		case LITE_GLOW:
			think = true;
			Light.value1 = arg1;	// upper lightlevel
			Light.value2 = arg2;	// lower lightlevel
			Light.delta = itof((arg1 - sec->params.lightlevel) / arg3) * 32.0;	// lightlevel delta
			if (sec->params.lightlevel <= arg1)
			{
				Light.direction = 1;	// get brighter
			}
			else
			{
				Light.direction = -1;
			}
			break;
		case LITE_FLICKER:
			think = true;
			Light.value1 = arg1;	// upper lightlevel
			Light.value2 = arg2;	// lower lightlevel
			sec->params.lightlevel = Light.value1;
			Light.time = itof((P_Random() & 64) + 1) / 32.0;
			break;
		case LITE_STROBE:
			think = true;
			Light.value1 = arg1;	// upper lightlevel
			Light.value2 = arg2;	// lower lightlevel
			Light.time1 = itof(arg3) / 35.0;	// upper tics
			Light.time2 = itof(arg4) / 35.0;	// lower tics
			Light.time = itof(arg3) / 35.0;
			sec->params.lightlevel = Light.value1;
			break;
		default:
			rtn = false;
			break;
		}
		if (!think)
		{
			RemoveSpecialThinker(Light);
		}
	}
	return rtn;
}

//==========================================================================
//
// P_SpawnPhasedLight
//
//==========================================================================

void P_SpawnPhasedLight(sector_t * sector, int base, int index)
{
	PhasedLight Phase;

	Phase = NewSpecialThinker(PhasedLight);
	Phase.sector = sector;
	if (index == -1)
	{
		// sector->lightlevel as the index
		Phase.index = itof(sector->params.lightlevel) / 32.0;
	}
	else
	{
		Phase.index = itof(index) / 32.0;
	}
	Phase.base = base & 255;
	sector->params.lightlevel = Phase.base +
		PhaseTable[ftoi(Phase.index * 32.0) & 63];
}

//==========================================================================
//
// P_SpawnLightSequence
//
//==========================================================================

void P_SpawnLightSequence(sector_t * sector, float indexStep)
{
	sector_t *sec;
	sector_t *nextSec;
	sector_t *tempSec;
	int seqSpecial;
	int i;
	float count;
	float index;
	float indexDelta;
	int base;

	seqSpecial = SECSPEC_LightSequence;	// look for Light_Sequence, first
	sec = sector;
	count = 1.0;
	do
	{
		nextSec = NULL;
		//	Make sure that the search doesn't back up.
		sec->special = (sec->special & ~SECSPEC_BASE_MASK) |
			SECSPEC_LightSequenceStart;
		for (i = 0; i < sec->linecount; i++)
		{
			tempSec = getNextSector(sec->lines[i], sec);
			if (!tempSec)
			{
				continue;
			}
			if ((tempSec->special & SECSPEC_BASE_MASK) == seqSpecial)
			{
				if (seqSpecial == SECSPEC_LightSequence)
				{
					seqSpecial = SECSPEC_LightSequenceAlt;
				}
				else
				{
					seqSpecial = SECSPEC_LightSequence;
				}
				nextSec = tempSec;
				count += 1.0;
			}
		}
		sec = nextSec;
	}
	while (sec);

	sec = sector;
	count *= indexStep;
	index = 0.0;
	indexDelta = 64.0 / count;
	base = sector->params.lightlevel;
	do
	{
		nextSec = NULL;
		if (sec->params.lightlevel)
		{
			base = sec->params.lightlevel;
		}
		P_SpawnPhasedLight(sec, base, ftoi(index));
		index += indexDelta;
		for (i = 0; i < sec->linecount; i++)
		{
			tempSec = getNextSector(sec->lines[i], sec);
			if (!tempSec)
			{
				continue;
			}
			if ((tempSec->special & SECSPEC_BASE_MASK) ==
				SECSPEC_LightSequenceStart)
			{
				nextSec = tempSec;
			}
		}
		sec = nextSec;
	}
	while (sec);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.18  2004/11/22 07:36:29  dj_jl
//  Implemented all sector specials in all games.
//
//  Revision 1.17  2002/11/02 08:22:38  dj_jl
//  New style classes.
//
//  Revision 1.16  2002/09/07 16:28:26  dj_jl
//  Added Level class.
//
//  Revision 1.15  2002/08/28 16:36:39  dj_jl
//  Merged MapObject with Entity, some natives, beautification.
//
//  Revision 1.14  2002/06/29 15:55:42  dj_jl
//  Fixed static lights, beautification.
//
//  Revision 1.13  2002/04/11 16:48:10  dj_jl
//  New base classes for sector thinkers, Tick function.
//
//  Revision 1.12  2002/01/28 18:50:20  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.11  2002/01/17 18:15:55  dj_jl
//  Renamed all map object classes
//
//  Revision 1.10  2002/01/15 08:12:26  dj_jl
//  Replaced some pointers with references
//
//  Revision 1.9  2002/01/07 12:27:42  dj_jl
//  Changed copyright year
//
//  Revision 1.8  2001/12/18 18:29:22  dj_jl
//  Added Hexen action specials
//
//  Revision 1.6  2001/10/22 17:23:11  dj_jl
//  Floatification of angles
//
//  Revision 1.5  2001/10/09 17:33:29  dj_jl
//  Moved static light sources into games
//
//  Revision 1.4  2001/09/24 17:13:25  dj_jl
//  Created thinker classes
//
//  Revision 1.3  2001/09/20 16:19:59  dj_jl
//  Start using object-oriented stuff, beautification
//
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
