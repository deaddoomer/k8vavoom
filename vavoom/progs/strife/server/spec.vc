//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define MAX_TAGGED_LINES	64

#define MAXLINEANIMS            64

// TYPES -------------------------------------------------------------------

struct tagged_line_t
{
	line_t *line;
	int lineTag;
};

// FUNCTION PROTOTYPES -----------------------------------------------------

int CanActivateCross(mobj_t * thing);
void P_RespawnSpecials(void);

int EV_Teleport(int tag, mobj_t * thing, boolean usefog);
boolean EV_SilentLineTeleport(line_t *line, int side, Actor *thing, int id,
							boolean reverse);

void P_ThrustMobj(mobj_t *mo, float an, float force);

// DATA DECLARATIONS -------------------------------------------------------

//
//      Animating line specials
//
int numlinespecials;
line_t *linespeciallist[MAXLINEANIMS];

tagged_line_t TaggedLines[MAX_TAGGED_LINES];
int TaggedLineCount;

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  CheckLock
//
//==========================================================================

boolean CheckLock(mobj_t * user, int lock)
{
	player_t *player;

	player = user->Player;

	if (!player)
	{
		return false;
	}
	if (!lock)
	{
		return true;
	}

	switch (lock)
	{
	case 2:	// Blue Lock
		if (!(player->keys & (1 << it_bluecard)))
		{
			centerprint(player, "You need a blue keycard");
			StartSoundName(*player->mo, 'PlayerLand', CHAN_VOICE);
			return false;
		}
		break;

	case 1:	// Red Lock
		if (!(player->keys & (1 << it_redcard)))
		{
			centerprint(player, "You need a red keycard");
			StartSoundName(*player->mo, 'PlayerLand', CHAN_VOICE);
			return false;
		}
		break;

	case 3:	// Yellow Lock
		if (!(player->keys & (1 << it_yellowcard)))
		{
			centerprint(player, "You need a yellow keycard");
			StartSoundName(*player->mo, 'PlayerLand', CHAN_VOICE);
			return false;
		}
		break;

	case 5:	// Blue Lock
		if (!(player->keys & (1 << it_blueskull)))
		{
			centerprint(player, "You need a blue skullkey");
			StartSoundName(*player->mo, 'PlayerLand', CHAN_VOICE);
			return false;
		}
		break;

	case 4:	// Red Lock
		if (!(player->keys & (1 << it_redskull)))
		{
			centerprint(player, "You need a red skullkey");
			StartSoundName(*player->mo, 'PlayerLand', CHAN_VOICE);
			return false;
		}
		break;

	case 6:	// Yellow Lock
		if (!(player->keys & (1 << it_yellowskull)))
		{
			centerprint(player, "You need a yellow skullkey");
			StartSoundName(*player->mo, 'PlayerLand', CHAN_VOICE);
			return false;
		}
		break;

	case 100:	// Any key
	case 128 + 100:	// Any key
		if (!player->keys)
		{
			centerprint(player, "You need any key");
			StartSoundName(*player->mo, 'PlayerLand', CHAN_VOICE);
			return false;
		}
		break;

	case 110:	// All keys
		if (player->keys != 0x3f)
		{
			centerprint(player, "You need all keycards and skullkeys");
			StartSoundName(*player->mo, 'PlayerLand', CHAN_VOICE);
			return false;
		}
		break;

	case 128 + 2:	// Blue Lock
		if (!(player->keys & ((1 << it_bluecard) | (1 << it_blueskull))))
		{
			centerprint(player, "You need a blue key");
			StartSoundName(*player->mo, 'PlayerLand', CHAN_VOICE);
			return false;
		}
		break;

	case 128 + 1:	// Red Lock
		if (!(player->keys & ((1 << it_redcard) | (1 << it_redskull))))
		{
			centerprint(player, "You need a red key");
			StartSoundName(*player->mo, 'PlayerLand', CHAN_VOICE);
			return false;
		}
		break;

	case 128 + 3:	// Yellow Lock
		if (!(player->keys & ((1 << it_yellowcard) | (1 << it_yellowskull))))
		{
			centerprint(player, "You need a yellow key");
			StartSoundName(*player->mo, 'PlayerLand', CHAN_VOICE);
			return false;
		}
		break;

	case 128 + 101:	// All keys
		if (!(player->keys & ((1 << it_bluecard) | (1 << it_blueskull))) ||
			!(player->keys & ((1 << it_redcard) | (1 << it_redskull))) ||
			!(player->keys & ((1 << it_yellowcard) | (1 << it_yellowskull))))
		{
			centerprint(player, "You need all keys");
			StartSoundName(*player->mo, 'PlayerLand', CHAN_VOICE);
			return false;
		}
		break;
	}

	return true;
}

//==========================================================================
//
//  StartLockedACS
//
//==========================================================================

boolean StartLockedACS(line_t * line, int *args, mobj_t * mo, int side)
{
	int i;
	int newArgs[5];

	if (!CheckLock(mo, args[4]))
	{
		return false;
	}
	for (i = 0; i < 4; i++)
	{
		newArgs[i] = args[i];
	}
	newArgs[4] = 0;
	return StartACS(newArgs[0], newArgs[1], &newArgs[2], *mo, line, side);
}

//==========================================================================
//
//  ExecuteLineSpecial
//
//==========================================================================

boolean ExecuteLineSpecial(int special, int *args, line_t * line, int side,
	mobj_t * mo)
{
	boolean buttonSuccess;

	buttonSuccess = false;
	switch (special)
	{
	case 1: // Poly Start Line
		break;
	case 2: // Poly Rotate Left
		buttonSuccess = EV_RotatePoly(line, args, 1, false);
		break;
	case 3: // Poly Rotate Right
		buttonSuccess = EV_RotatePoly(line, args, -1, false);
		break;
	case 4: // Poly Move
		buttonSuccess = EV_MovePoly(line, args, false, false);
		break;
	case 5: // Poly Explicit Line:  Only used in initialization
		break;
	case 6: // Poly Move Times 8
		buttonSuccess = EV_MovePoly(line, args, true, false);
		break;
	case 7: // Poly Door Swing
		buttonSuccess = EV_OpenPolyDoor(line, args, PODOOR_SWING);
		break;
	case 8: // Poly Door Slide
		buttonSuccess = EV_OpenPolyDoor(line, args, PODOOR_SLIDE);
		break;
	case 10:	// Door Close
		buttonSuccess = EV_DoDoor(line, args, doorClose);
		break;
	case 11:	// Door Open
		if (!args[0])
		{
			buttonSuccess = EV_VerticalDoor(line, mo);
		}
		else
		{
			buttonSuccess = EV_DoDoor(line, args, doorOpen);
		}
		break;
	case 12:	// Door Raise
		if (!args[0])
		{
			buttonSuccess = EV_VerticalDoor(line, mo);
		}
		else
		{
			buttonSuccess = EV_DoDoor(line, args, doorRaise);
		}
		break;
	case 13:	// Door Locked_Raise
		if (CheckLock(mo, args[3]))
		{
			if (!args[0])
			{
				buttonSuccess = EV_VerticalDoor(line, mo);
			}
			else
			{
				buttonSuccess = EV_DoDoor(line, args, doorRaise);
			}
		}
		break;
	case 20: // Floor Lower by Value
		buttonSuccess = EV_DoFloor(line, args, FLEV_LOWERFLOORBYVALUE);
		break;
	case 21:	// Floor Lower to Lowest
		buttonSuccess = EV_DoFloor(line, args, FLEV_LOWERFLOORTOLOWEST);
		break;
	case 22:	// Floor Lower to Nearest
		buttonSuccess = EV_DoFloor(line, args, FLEV_LOWERFLOOR);
		break;
	case 23:	// Floor Raise by Value
		buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEFLOORBYVALUE);
		break;
	case 24: // Floor Raise to Highest
		//WARNING this conflicts with actual Hexen behavior
		buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEFLOORTOHIGHEST);
		break;
	case 25:	// Floor Raise to Nearest
		buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEFLOORTONEAREST);
		break;
	case 26: // Stairs Build Down Normal
		buttonSuccess = EV_BuildStairs(line, args, -1, STAIRS_NORMAL);
		break;
	case 27: // Build Stairs Up Normal
		buttonSuccess = EV_BuildStairs(line, args, 1, STAIRS_NORMAL);
		break;
	case 28:	// Floor Raise and Crush
		buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEFLOORCRUSH);
		break;
	case 29: // Build Pillar (no crushing)
		buttonSuccess = EV_BuildPillar(line, args, false);
		break;
	case 30: // Open Pillar
		buttonSuccess = EV_OpenPillar(line, args);
		break;
	case 31: // Stairs Build Down Sync
		buttonSuccess = EV_BuildStairs(line, args, -1, STAIRS_SYNC);
		break;
	case 32: // Build Stairs Up Sync
		buttonSuccess = EV_BuildStairs(line, args, 1, STAIRS_SYNC);
		break;
	case 35:	// Raise Floor by Value Times 8
		buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEBYVALUETIMES8);
		break;
	case 36: // Lower Floor by Value Times 8
		buttonSuccess = EV_DoFloor(line, args, FLEV_LOWERBYVALUETIMES8);
		break;
	case 40: // Ceiling Lower by Value
		buttonSuccess = EV_DoCeiling(line, args, CLEV_LOWERBYVALUE);
		break;
	case 41: // Ceiling Raise by Value
		buttonSuccess = EV_DoCeiling(line, args, CLEV_RAISEBYVALUE);
		break;
	case 42: // Ceiling Crush and Raise
		buttonSuccess = EV_DoCeiling(line, args, CLEV_CRUSHANDRAISE);
		break;
	case 43:	// Ceiling Lower and Crush
		buttonSuccess = EV_DoCeiling(line, args, CLEV_LOWERANDCRUSH);
		break;
	case 44:	// Ceiling Crush Stop
		buttonSuccess = EV_CeilingCrushStop(line, args);
		break;
	case 45: // Ceiling Crush Raise and Stay
		buttonSuccess = EV_DoCeiling(line, args, CLEV_CRUSHRAISEANDSTAY);
		break;
	case 46: // Floor Crush Stop
		buttonSuccess = EV_FloorCrushStop(line, args);
		break;
	case 60: // Plat Perpetual Raise
		buttonSuccess = EV_DoPlat(line, args, PLAT_PERPETUALRAISE);
		break;
	case 61:	// Plat Stop
		EV_StopPlat(line, args);
		break;
	case 62: // Plat Down-Wait-Up-Stay
		buttonSuccess = EV_DoPlat(line, args, PLAT_DOWNWAITUPSTAY);
		break;
	case 63: // Plat Down-by-Value*8-Wait-Up-Stay
		buttonSuccess = EV_DoPlat(line, args, PLAT_DOWNBYVALUEWAITUPSTAY);
		break;
	case 64: // Plat Up-Wait-Down-Stay
		buttonSuccess = EV_DoPlat(line, args, PLAT_UPWAITDOWNSTAY);
		break;
	case 65: // Plat Up-by-Value*8-Wait-Down-Stay
		buttonSuccess = EV_DoPlat(line, args, PLAT_UPBYVALUEWAITDOWNSTAY);
		break;
	case 66: // Floor Lower Instant * 8
		buttonSuccess = EV_DoFloor(line, args, FLEV_LOWERTIMES8INSTANT);
		break;
	case 67: // Floor Raise Instant * 8
		buttonSuccess = EV_DoFloor(line, args, FLEV_RAISETIMES8INSTANT);
		break;
	case 68: // Floor Move to Value * 8
		buttonSuccess = EV_DoFloor(line, args, FLEV_MOVETOVALUETIMES8);
		break;
	case 69: // Ceiling Move to Value * 8
		buttonSuccess = EV_DoCeiling(line, args, CLEV_MOVETOVALUETIMES8);
		break;
	case 70:	// Teleport
		if (side == 0)
		{
			// Only teleport when crossing the front side of a line
			buttonSuccess = EV_Teleport(args[0], mo, true);
		}
		break;
/*		case 71: // Teleport, no fog
			if(side == 0)
			{ // Only teleport when crossing the front side of a line
				buttonSuccess = EV_Teleport(args[0], mo, false);
			}
			break;*/
	case 72: // Thrust Mobj
		if (!side) // Only thrust on side 0
		{
			P_ThrustMobj(mo, itof(args[0]) * (90.0 / 64.0), itof(args[1]));
			buttonSuccess = 1;
		}
		break;
	case 73: // Damage Mobj
		if (args[0])
		{
			mo->Damage(none, none, args[0]);
		}
		else
		{
			// If arg1 is zero, then guarantee a kill
			mo->Damage(none, none, 10000);
		}
		buttonSuccess = 1;
		break;
	case 74:	// Teleport_NewMap
		if (side == 0)
		{	// Only teleport when crossing the front side of a line
			if (!(mo && mo->bIsPlayer && mo->Player->playerstate == PST_DEAD))	// Players must be alive to teleport
			{
				G_Completed(args[0], args[1]);
				buttonSuccess = true;
			}
		}
		break;
	case 75:	// Teleport_EndGame
		if (side == 0)
		{	// Only teleport when crossing the front side of a line
			if (!(mo && mo->bIsPlayer && mo->Player->playerstate == PST_DEAD))	// Players must be alive to teleport
			{
				buttonSuccess = true;
				if (deathmatch)
				{	// Winning in deathmatch just goes back to map 1
					G_Completed(1, 0);
				}
				else
				{	// Passing -1, -1 to G_Completed() starts the Finale
					G_Completed(-1, -1);
				}
			}
		}
		break;
	case 80:	// ACS_Execute
		buttonSuccess = StartACS(args[0], args[1], &args[2], *mo, line, side);
		break;
	case 81:	// ACS_Suspend
		buttonSuccess = SuspendACS(args[0], args[1]);
		break;
	case 82:	// ACS_Terminate
		buttonSuccess = TerminateACS(args[0], args[1]);
		break;
	case 83:	// ACS_LockedExecute
		buttonSuccess = StartLockedACS(line, args, mo, side);
		break;
	case 90: // Poly Rotate Left Override
		buttonSuccess = EV_RotatePoly(line, args, 1, true);
		break;
	case 91: // Poly Rotate Right Override
		buttonSuccess = EV_RotatePoly(line, args, -1, true);
		break;
	case 92: // Poly Move Override
		buttonSuccess = EV_MovePoly(line, args, false, true);
		break;
	case 93: // Poly Move Times 8 Override
		buttonSuccess = EV_MovePoly(line, args, true, true);
		break;
	case 94: // Build Pillar Crush
		buttonSuccess = EV_BuildPillar(line, args, true);
		break;
	case 95: // Lower Floor and Ceiling
		buttonSuccess = EV_DoFloorAndCeiling(line, args, false);
		break;
	case 96: // Raise Floor and Ceiling
		buttonSuccess = EV_DoFloorAndCeiling(line, args, true);
		break;
	case 109: // Force Lightning
		buttonSuccess = true;
		P_ForceLightning();
		break;
	case 110: // Light Raise by Value
		buttonSuccess = EV_SpawnLight(line, args, LITE_RAISEBYVALUE);
		break;
	case 111: // Light Lower by Value
		buttonSuccess = EV_SpawnLight(line, args, LITE_LOWERBYVALUE);
		break;
	case 112:	// Light Change to Value
		buttonSuccess = EV_SpawnLight(line, args, LITE_CHANGETOVALUE);
		break;
	case 113: // Light Fade
		buttonSuccess = EV_SpawnLight(line, args, LITE_FADE);
		break;
	case 114: // Light Glow
		buttonSuccess = EV_SpawnLight(line, args, LITE_GLOW);
		break;
	case 115: // Light Flicker
		buttonSuccess = EV_SpawnLight(line, args, LITE_FLICKER);
		break;
	case 116: // Light Strobe
		buttonSuccess = EV_SpawnLight(line, args, LITE_STROBE);
		break;
/*		case 120: // Quake Tremor
			buttonSuccess = A_LocalQuake(args, mo);
			break;
		case 129: // UsePuzzleItem
			buttonSuccess = EV_LineSearchForPuzzleItem(line, args, mo);
			break;
		case 130: // Thing_Activate
			buttonSuccess = EV_ThingActivate(args[0]);
			break;
		case 131: // Thing_Deactivate
			buttonSuccess = EV_ThingDeactivate(args[0]);
			break;
		case 132: // Thing_Remove
			buttonSuccess = EV_ThingRemove(args[0]);
			break;
		case 133: // Thing_Destroy
			buttonSuccess = EV_ThingDestroy(args[0]);
			break;
		case 134: // Thing_Projectile
			buttonSuccess = EV_ThingProjectile(args, 0);
			break;
		case 135: // Thing_Spawn
			buttonSuccess = EV_ThingSpawn(args, 1);
			break;
		case 136: // Thing_ProjectileGravity
			buttonSuccess = EV_ThingProjectile(args, 1);
			break;
		case 137: // Thing_SpawnNoFog
			buttonSuccess = EV_ThingSpawn(args, 0);
			break;*/
	case 138: // Floor_Waggle
		buttonSuccess = EV_StartFloorWaggle(args[0], args[1],
			args[2], args[3], args[4]);
		break;
/*		case 140: // Sector_SoundChange
			buttonSuccess = EV_SectorSoundChange(args);
			break;

		// Line specials only processed during level initialization
		// 100: Scroll_Texture_Left
		// 101: Scroll_Texture_Right
		// 102: Scroll_Texture_Up
		// 103: Scroll_Texture_Down
		// 121: Line_SetIdentification
*/

	case 196:	// Ceiling Crush and RaiseA
		buttonSuccess = EV_DoCeiling(line, args, CLEV_CRUSHANDRAISEA);
		break;
	case 197:	// Ceiling_CrushAndRaiseSilentA
		buttonSuccess = EV_DoCeiling(line, args, CLEV_CRUSHRAISEANDSTAYSILA);
		break;
	case 206:	// Plat_DownWaitUpStayLip
		buttonSuccess = EV_DoPlat(line, args, PLAT_DOWNWAITUPSTAYLIP);
		break;
	case 207:	// Plat_PerpetualRaiseLip
		buttonSuccess = EV_DoPlat(line, args, PLAT_PERPETUALRAISELIP);
		break;
	case 215:	// Teleport_Line
		buttonSuccess = EV_SilentLineTeleport(line, side, mo, args[1], args[2]);
		break;
	case 217:	// Stairs_BuildUpDoom
		buttonSuccess = EV_BuildStairsOld(line, args);
		break;
	case 226:	// ACS_ExecuteAlways
		buttonSuccess = StartACS(args[0], args[1], &args[2], *mo, line, side);
		break;
	case 228:	// Plat_RaiseAndStayTx0
		buttonSuccess =
			EV_DoFloor(line, args, FLEV_RAISEFLOORTONEARESTCHANGE);
		break;
	case 230:	// Plat_UpByValueStayTx
		buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEFLOORBYVALUECHANGE2);
		break;
	case 232:	// Light_StrobeDoom
		buttonSuccess = EV_StartLightStrobing(line, args);
		break;
	case 233:	// Light_MinNeighbor
		buttonSuccess = EV_TurnTagLightsOff(line, args);
		break;
	case 234:	// Light_MaxNeighbor
		buttonSuccess = EV_TagLightTurnOn(line, args);
		break;
	case 238:	// Floor Raise to Lowest
		buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEFLOOR);
		break;
	case 239:	// Floor_RaiseByValueTxTy
		buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEFLOORBYVALUECHANGE);
		break;
	case 240:	// Floor_RaiseByTexture
		buttonSuccess = EV_DoFloor(line, args, FLEV_RAISETOTEXTURE);
		break;
	case 241:	// Floor_LowerToLowestTxTy
		buttonSuccess = EV_DoFloor(line, args, FLEV_LOWERTOLOWESTCHANGE);
		break;
	case 242:	// Floor_LowerToHighest
		buttonSuccess = EV_DoFloor(line, args, FLEV_LOWERTOHIGHEST);
		break;
	case 243:	// Exit_Normal
		buttonSuccess = 1;
		G_ExitLevel();
		break;
	case 244:	// Exit_Secret
		buttonSuccess = 1;
		G_SecretExitLevel();
		break;
	case 249:	// Door_CloseWaitOpen
		buttonSuccess = EV_DoDoor(line, args, DREV_CLOSEWAITOPEN);
		break;
	case 250:	// Floor_Donut
		buttonSuccess = EV_DoDonut(line, args);
		break;
	case 251:	// FloorAndCeiling_LowerRaise
	case 201:	//FIXME
		buttonSuccess = EV_DoCeiling(line, args, CLEV_RAISETOHIGHEST);
		buttonSuccess |= EV_DoFloor(line, args, FLEV_LOWERFLOORTOLOWEST);
		break;
	case 254:	// Ceiling_LowerToFloor
		buttonSuccess = EV_DoCeiling(line, args, CLEV_LOWERTOFLOOR);
		break;

		// Inert Line specials
	default:
		break;
	}
	return buttonSuccess;
}

//==========================================================================
//
//  P_SpawnSpecials
//
//==========================================================================

void P_SpawnSpecials(boolean spawn_thinkers)
{
	sector_t *sector;
	int i;

	//  Init special SECTORs.
	if (spawn_thinkers)
	{
		for (i = 0; i < level->numsectors; i++)
		{
			sector = &level->sectors[i];

			if (!sector->special)
				continue;

			if (sector->special & SECRET_MASK)
			{
				// SECRET SECTOR
				level->totalsecret++;
			}
			switch (sector->special)
			{
			case 64 + 1:
				// FLICKERING LIGHTS
				P_SpawnLightFlash(sector);
				break;

			case 64 + 2:
				// STROBE FAST
				P_SpawnStrobeFlash(sector, FASTDARK, STROBEBRIGHT, 0);
				break;

			case 64 + 3:
				// STROBE SLOW
				P_SpawnStrobeFlash(sector, SLOWDARK, STROBEBRIGHT, 0);
				break;

			case 64 + 4:
				// STROBE FAST/DEATH SLIME
				P_SpawnStrobeFlash(sector, FASTDARK, STROBEBRIGHT, 0);
				sector->special = 4;
				break;

			case 64 + 8:
				// GLOWING LIGHT
				P_SpawnGlowingLight(sector);
				break;

			case 64 + 10:
				// DOOR CLOSE IN 30 SECONDS
				P_SpawnDoorCloseIn30(sector);
				break;

			case 64 + 12:
				// SYNC STROBE SLOW
				P_SpawnStrobeFlash(sector, SLOWDARK, STROBEBRIGHT, 1);
				break;

			case 64 + 13:
				// SYNC STROBE FAST
				P_SpawnStrobeFlash(sector, FASTDARK, STROBEBRIGHT, 1);
				break;

			case 64 + 14:
				// DOOR RAISE IN 5 MINUTES
				P_SpawnDoorRaiseIn5Mins(sector);
				break;

			case 64 + 17:
				P_SpawnFireFlicker(sector);
				break;
			}
		}
	}

	//  Init line EFFECTs
	numlinespecials = 0;
	for (i = 0; i < level->numlines; i++)
	{
		switch (level->lines[i].special)
		{
		case 100:
			// EFFECT FIRSTCOL SCROLL+
			linespeciallist[numlinespecials] = &level->lines[i];
			numlinespecials++;
			break;
		}
	}

	TaggedLineCount = 0;
	for (i = 0; i < level->numlines; i++)
	{
		switch (level->lines[i].special)
		{
		case 121:	// Line_SetIdentification
		case 208:	// TranslucentLine
		case 215:	// Teleport_Line
			if (level->lines[i].arg1)
			{
				if (TaggedLineCount == MAX_TAGGED_LINES)
				{
					Error("P_SpawnSpecials: MAX_TAGGED_LINES exceeded.");
				}
				TaggedLines[TaggedLineCount].line = &level->lines[i];
				TaggedLines[TaggedLineCount++].lineTag = level->lines[i].arg1;
			}
			if (level->lines[i].special == 121)
			{
				level->lines[i].special = 0;
			}
			break;
		}
	}
}

//==========================================================================
//
//  P_UpdateSpecials
//
//==========================================================================

void P_UpdateSpecials(void)
{
	int i;
	line_t *line;

	//  ANIMATE LINE SPECIALS
	for (i = 0; i < numlinespecials; i++)
	{
		line = linespeciallist[i];
		switch (line->special)
		{
		case 100:
			// EFFECT FIRSTCOL SCROLL +
			level->sides[line->sidenum[0]].textureoffset +=
				itof(line->arg1) / 64.0;
			break;
		}
	}

	P_RespawnSpecials();
}

//==========================================================================
//
//  CheckActivation
//
//==========================================================================

boolean CheckActivation(int activationType, line_t * line, mobj_t * mo)
{
	int lineActivation;
	boolean noway = true;

	lineActivation = GET_SPAC(line->flags);
	if (lineActivation != activationType &&
		!(activationType == SPAC_MCROSS && lineActivation == SPAC_CROSS))
	{
		return false;
	}
	if (!mo->bIsPlayer && !mo->bMissile)
	{
		if ((activationType == SPAC_USE || activationType == SPAC_PUSH)
			&& (line->flags & ML_SECRET))
			return false;	// never open secret doors

		switch (lineActivation)
		{
		case SPAC_IMPACT:
		case SPAC_PCROSS:
			// shouldn't really be here if not a missile
		case SPAC_MCROSS:
			noway = false;
			break;

		case SPAC_CROSS:
			switch (line->special)
			{
			case 12:
			case 70:
/*			 case Teleport_NoFog:
			 case Teleport_Line:
			 case Plat_DownWaitUpStayLip:*/
			case 62:
				noway = false;
			}
			break;

		case SPAC_USE:
		case SPAC_PUSH:
			switch (line->special)
			{
			case 12:
				if (line->arg1 == 0)
					noway = false;
				break;
/*			 case Teleport:
			 case Teleport_NoFog:
				noway = false;*/
			}
			break;
		}
		if (noway)
			return false;
	}
	return true;
}

//============================================================================
//
//  P_ActivateLine
//
//============================================================================

boolean P_ActivateLine(line_t * line, mobj_t * mo, int side,
	int activationType)
{
	int lineActivation;
	boolean repeat;
	boolean buttonSuccess;

	if (!CheckActivation(activationType, line, mo))
	{
		return false;
	}

	lineActivation = GET_SPAC(line->flags);
	repeat = line->flags & ML_REPEAT_SPECIAL;
	buttonSuccess = ExecuteLineSpecial(line->special, &line->arg1, line,
		side, mo);
	if (!repeat && buttonSuccess)
	{
		// clear the special on non-retriggerable lines
		line->special = 0;
	}
	if ((lineActivation == SPAC_USE || lineActivation == SPAC_IMPACT)
		&& buttonSuccess)
	{
		P_ChangeSwitchTexture(line, repeat);
	}
	return true;
}

//==========================================================================
//
//  P_FindLine
//
//==========================================================================

line_t *P_FindLine(int lineTag, int *searchPosition)
{
	int i;

	for (i = *searchPosition + 1; i < TaggedLineCount; i++)
	{
		if (TaggedLines[i].lineTag == lineTag)
		{
			*searchPosition = i;
			return TaggedLines[i].line;
		}
	}
	*searchPosition = -1;
	return NULL;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.15  2002/02/16 16:23:46  dj_jl
//  Added line teleporters and translucent lines
//
//  Revision 1.14  2002/02/14 19:21:00  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.13  2002/02/06 17:28:53  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.12  2002/01/29 18:15:06  dj_jl
//  Added some thing specials
//
//  Revision 1.11  2002/01/28 18:50:20  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.10  2002/01/15 18:27:01  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.9  2002/01/11 18:19:43  dj_jl
//  Started to use names in progs
//
//  Revision 1.8  2002/01/07 12:27:42  dj_jl
//  Changed copyright year
//
//  Revision 1.7  2001/12/18 18:29:22  dj_jl
//  Added Hexen action specials
//
//  Revision 1.4  2001/09/24 17:14:11  dj_jl
//  Created thinker classes
//
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
