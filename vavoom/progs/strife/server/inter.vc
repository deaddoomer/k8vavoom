//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**    GET STUFF
//**
//**************************************************************************

#define BONUSADD	6

int maxammo[] = { 250, 25, 50, 30, 16, 100, 400 };
int clipammo[] = { 10, 10, 10, 10, 10, 10, 10 };

Actor Spawn(classid type, TVec AOrigin);

//**************************************************************************
//**************************************************************************
//
//	Pickup
//
//**************************************************************************
//**************************************************************************

//==========================================================================
//
//	Pickup::ValidTouch
//
//==========================================================================

boolean Pickup::ValidTouch(Actor Toucher)
{
	if (!Toucher.bIsPlayer)
	{
		// can't remove thing
		return false;
	}
	// Dead thing touching.
	// Can happen with a sliding player corpse.
	if (Toucher.Health <= 0)
	{
		return false;
	}

	return true;
}

//==========================================================================
//
//	Pickup::HandlePickup
//
//==========================================================================

boolean Pickup::HandlePickup(Actor Toucher)
{
	cprint(Toucher.Player, "Unimplemented pickup %n", ClassName);
	return true;
}

__states__(Pickup)
{
	S_DORMANT_PICKUP1('', 0, 30.0, S_DORMANT_PICKUP2)
	{
		bHidden = true;
		bSpecial = false;
	}
	S_DORMANT_PICKUP2('', 0, -1.0, S_NULL)
	{
		Actor A;

		bHidden = false;
		bSpecial = true;
		SetState(IdleState);

		// spawn a teleport fog at the new spot
		A = Spawn(ItemRespawnFog, Origin);
		A.PlaySound('ItemRespawn', CHAN_ITEM);
	}
}

//==========================================================================
//
//	Pickup::HideSpecial
//
//==========================================================================

void Pickup::HideSpecial(void)
{
	// only respawn items in deathmatch
	if (deathmatch && !bDropped)
	{
		SetState(S_DORMANT_PICKUP1);
	}
	else
	{
		Remove();
	}
}

//==========================================================================
//
//	Pickup::TouchSpecial
//
//==========================================================================

void Pickup::TouchSpecial(Actor Toucher)
{
	if (!ValidTouch(Toucher))
	{
		// can't remove thing
		return;
	}

	if (!HandlePickup(Toucher))
	{
		return;
	}

	cprint(Toucher.Player, "You picked up the %s.", PickupString);
	HideSpecial();
	Toucher.Player->BonusCount += BONUSADD;
	Toucher.PlaySound(PickupSound, CHAN_ITEM);
}

//**************************************************************************
//**************************************************************************

//==========================================================================
//
//  PlayerPawn::GiveAmmo
//
//  Num is the number of clip loads, not the individual count (0= 1/2 clip).
// Returns false if the ammo can't be picked up at all
//
//==========================================================================

boolean PlayerPawn::GiveAmmo(int ammo, int num)
{
	int oldammo;
	int max;

	if (ammo == am_noammo)
		return false;

	if (ammo < 0 || ammo > NUMAMMO)
//      I_Error ("P_GiveAmmo: bad type %i", ammo);
		Error("P_GiveAmmo: bad type");

	max = Player->Backpack ? maxammo[ammo] * 2 : maxammo[ammo];
	if (Player->Ammo[ammo] == max)
		return false;

	if (num)
		num *= clipammo[ammo];
	else
		num = clipammo[ammo] / 2;

	if (gameskill == sk_baby || gameskill == sk_nightmare)
	{
		// give double ammo in trainer mode,
		// you'll need in nightmare
		num <<= 1;
	}

	oldammo = Player->Ammo[ammo];
	Player->Ammo[ammo] += num;

	if (Player->Ammo[ammo] > max)
		Player->Ammo[ammo] = max;

	// If non zero ammo, 
	// don't change up weapons,
	// player was lower on purpose.
	if (oldammo)
		return true;

	// We were down to zero,
	// so select a new weapon.
	// Preferences are not user selectable.
	switch (ammo)
	{
	case am_clip:
		if (Player->ReadyWeapon == wp_fist)
		{
			if (Player->WeaponOwned[wp_riffle])
				Player->PendingWeapon = wp_riffle;
		}
		break;

	case am_electric_arrow:
		if (Player->ReadyWeapon == wp_fist)
		{
			if (Player->WeaponOwned[wp_crossbow])
				Player->PendingWeapon = wp_crossbow;
		}
		break;

	case am_cell:
		if (Player->ReadyWeapon == wp_fist)
		{
			if (Player->WeaponOwned[wp_flame])
				Player->PendingWeapon = wp_flame;
		}
		break;

	case am_misl:
		if (Player->ReadyWeapon == wp_fist)
		{
			if (Player->WeaponOwned[wp_missile])
				Player->PendingWeapon = wp_missile;
		}
	default:
		break;
	}

	return true;
}

//==========================================================================
//
//  PlayerPawn::GiveWeapon
//
//  The weapon name may have a MF_DROPPED flag ored in.
//
//==========================================================================

boolean PlayerPawn::GiveWeapon(int weapon, boolean dropped)
{
	boolean gaveammo;
	boolean gaveweapon;

	if (netgame && (deathmatch < 2) && !dropped)
	{
		// leave placed weapons forever on net games
		if (Player->WeaponOwned[weapon])
			return false;

		Player->BonusCount += BONUSADD;
		Player->WeaponOwned[weapon] = true;

		if (deathmatch)
			GiveAmmo(weapon_ammo_type[weapon], 5);
		else
			GiveAmmo(weapon_ammo_type[weapon], 2);
		Player->PendingWeapon = weapon;

		PlaySound('PickupWeapon', CHAN_ITEM);
		return false;
	}

	if (weapon_ammo_type[weapon] != am_noammo)
	{
		// give one clip with a dropped weapon,
		// two clips with a found weapon
		if (dropped)
			gaveammo = GiveAmmo(weapon_ammo_type[weapon], 1);
		else
			gaveammo = GiveAmmo(weapon_ammo_type[weapon], 2);
	}
	else
		gaveammo = false;

	if (Player->WeaponOwned[weapon])
		gaveweapon = false;
	else
	{
		gaveweapon = true;
		Player->WeaponOwned[weapon] = true;
		Player->PendingWeapon = weapon;
	}

	return (gaveweapon || gaveammo);
}

//==========================================================================
//
//	PlayerPawn::GiveBody
//
//	Returns false if the body isn't needed at all
//
//==========================================================================

boolean PlayerPawn::GiveBody(int num)
{
	if (Health >= MAXHEALTH)
		return false;

	Health += num;
	if (Health > MAXHEALTH)
		Health = MAXHEALTH;
	Player->Health = Health;

	return true;
}

//==========================================================================
//
//	PlayerPawn::GiveArmor
//
//	Returns false if the armor is worse than the current armor.
//
//==========================================================================

boolean PlayerPawn::GiveArmor(int armortype)
{
	int hits;

	hits = armortype * 100;
	if (Player->ArmorPoints >= hits)
		return false;	// don't pick up

	Player->ArmorType = armortype;
	Player->ArmorPoints = hits;

	return true;
}

//==========================================================================
//
//	PlayerPawn::GiveKey
//
//==========================================================================

boolean PlayerPawn::GiveKey(int key)
{
	if (Player->Keys & (1 << key))
		return false;

	Player->BonusCount = BONUSADD;
	Player->Keys |= 1 << key;
	return true;
}

//==========================================================================
//
//  PlayerPawn::GiveItem
//
//==========================================================================

boolean PlayerPawn::GiveItem(int item)
{
	if (Player->Items & item)
	{
		return false;	// already got it
	}

	Player->Items |= item;
	return true;
}

//==========================================================================
//
//	PlayerPawn::GivePower
//
//==========================================================================

boolean PlayerPawn::GivePower(int power)
{
	if (power == pw_invulnerability)
	{
		Player->Powers[power] = ftoi(INVULNTIME * 35.0);
		return true;
	}

	if (power == pw_invisibility)
	{
		Player->Powers[power] = ftoi(INVISTIME * 35.0);
		Translucency = 90;
		return true;
	}

	if (power == pw_infrared)
	{
		Player->Powers[power] = ftoi(INFRATIME * 35.0);
		return true;
	}

	if (power == pw_ironfeet)
	{
		Player->Powers[power] = ftoi(IRONTIME * 35.0);
		return true;
	}

	if (power == pw_strength)
	{
		GiveBody(100);
		Player->Powers[power] = 1;
		return true;
	}

	if (Player->Powers[power])
		return false;	// already got it

	Player->Powers[power] = 1;
	return true;
}

//==========================================================================
//
//	Actor::HideSpecial
//
//==========================================================================

__states__(Actor)
{
	S_HIDDEN_SPECIAL1('', 0, 30.0, S_HIDDEN_SPECIAL2)
	{
		bHidden = true;
		bSpecial = false;
	}
	S_HIDDEN_SPECIAL2('', 0, -1.0, S_NULL)
	{
		Actor A;

		bHidden = false;
		bSpecial = true;

		// spawn a teleport fog at the new spot
		A = Spawn(ItemRespawnFog, Origin);
		A.PlaySound('ItemRespawn', CHAN_VOICE);
	}
}

void Actor::HideSpecial(void)
{
	// only respawn items in deathmatch
	if ((deathmatch == 2 || deathmatch == 3) &&
		!bDropped)
	{
		SetState(S_HIDDEN_SPECIAL1);
	}
	else
	{
		Remove();
	}
}

//==========================================================================
//
//	Actor::TouchSpecial
//
//==========================================================================

void Actor::TouchSpecial(Actor Toucher)
{
}

	// Identify by sprite.
/*    switch (_self->sprite)
    {
		// armor
      case SPR_ARM1:
		if (!P_GiveArmor(Toucher.player, 1))
		    return;
		P_SetMessage(Toucher.player, GOTARMOR, false);
		break;
		
      case SPR_ARM2:
		if (!P_GiveArmor(Toucher.player, 2))
		    return;
		P_SetMessage(Toucher.player, GOTMEGA, false);
		break;
	
		// bonus items
      case SPR_BON1:
		Toucher.player->health++;		// can go over 100%
		if (Toucher.player->health > 200)
	    	Toucher.player->health = 200;
		Toucher.player->mo->health = Toucher.player->health;
		P_SetMessage(Toucher.player, GOTHTHBONUS, false);
		break;
	
      case SPR_BON2:
		Toucher.player->ArmorPoints++;		// can go over 100%
		if (Toucher.player->ArmorPoints > 200)
		    Toucher.player->ArmorPoints = 200;
		if (!Toucher.player->ArmorType)
		    Toucher.player->ArmorType = 1;
		P_SetMessage(Toucher.player, GOTARMBONUS, false);
		break;
	
      case SPR_SOUL:
		Toucher.player->health += SOULSPHERE_HEALTH;
		if (Toucher.player->health > SOULSPHERE_MAX)
		    Toucher.player->health = SOULSPHERE_MAX;
		Toucher.player->mo->health = Toucher.player->health;
		P_SetMessage(Toucher.player, GOTSUPER, false);
		sound = 'PickupPower';
		break;

		// cards
		// leave cards for everyone
      case SPR_BKEY:
		if (P_GiveCard(Toucher.player, it_bluecard))
		    P_SetMessage(Toucher.player, GOTBLUECARD, false);
		if (!netgame)
		    break;
		return;
	
      case SPR_YKEY:
		if (P_GiveCard(Toucher.player, it_yellowcard))
		    P_SetMessage(Toucher.player, GOTYELWCARD, false);
		if (!netgame)
		    break;
		return;
	
      case SPR_RKEY:
		if (P_GiveCard(Toucher.player, it_redcard))
		    P_SetMessage(Toucher.player, GOTREDCARD, false);
		if (!netgame)
		    break;
		return;
	
      case SPR_BSKU:
		if (P_GiveCard(Toucher.player, it_blueskull))
		    P_SetMessage(Toucher.player, GOTBLUESKUL, false);
		if (!netgame)
		    break;
		return;
	
      case SPR_YSKU:
		if (P_GiveCard(Toucher.player, it_yellowskull))
		    P_SetMessage(Toucher.player, GOTYELWSKUL, false);
		if (!netgame)
	    	break;
		return;
	
      case SPR_RSKU:
		if (P_GiveCard(Toucher.player, it_redskull))
		    P_SetMessage(Toucher.player, GOTREDSKULL, false);
		if (!netgame)
	    	break;
		return;
	
		// medikits, heals
      case SPR_STIM:
		if (!P_GiveBody (Toucher.player, 10))
		    return;
		P_SetMessage(Toucher.player, GOTSTIM, false);
		break;
	
      case SPR_MEDI:
		if (!P_GiveBody (Toucher.player, 25))
		    return;

		if (Toucher.player->health < 25)
		    P_SetMessage(Toucher.player, GOTMEDINEED, false);
		else
		    P_SetMessage(Toucher.player, GOTMEDIKIT, false);
		break;

	
		// power ups
      case SPR_PINV:
		if (!P_GivePower (Toucher.player, pw_invulnerability))
		    return;
		P_SetMessage(Toucher.player, GOTINVUL, false);
		sound = 'PickupPower';
		break;
	
      case SPR_PSTR:
		if (!P_GivePower (Toucher.player, pw_strength))
		    return;
		P_SetMessage(Toucher.player, GOTBERSERK, false);
		if (Toucher.player->ReadyWeapon != wp_fist)
		    Toucher.player->PendingWeapon = wp_fist;
		sound = 'PickupPower';
		break;
	
      case SPR_PINS:
		if (!P_GivePower (Toucher.player, pw_invisibility))
		    return;
		P_SetMessage(Toucher.player, GOTINVIS, false);
		sound = 'PickupPower';
		break;
	
      case SPR_SUIT:
		if (!P_GivePower (Toucher.player, pw_ironfeet))
		    return;
		P_SetMessage(Toucher.player, GOTSUIT, false);
		sound = 'PickupPower';
		break;
	
      case SPR_PVIS:
		if (!P_GivePower (Toucher.player, pw_infrared))
		    return;
		P_SetMessage(Toucher.player, GOTVISOR, false);
		sound = 'PickupPower';
		break;

	    //	Items
      case SPR_PMAP:
		if (!P_GiveItem(Toucher.player, IT_ALL_MAP))
		    return;
		P_SetMessage(Toucher.player, GOTMAP, false);
		sound = 'PickupPower';
		break;
	
		// ammo
      case SPR_CLIP:
		if (_self->Flags & MF_DROPPED)
		{
		    if (!P_GiveAmmo (Toucher.player,am_clip,0))
				return;
		}
		else
		{
		    if (!P_GiveAmmo (Toucher.player,am_clip,1))
				return;
		}
		P_SetMessage(Toucher.player, GOTCLIP, false);
		break;
	
      case SPR_AMMO:
		if (!P_GiveAmmo (Toucher.player, am_clip,5))
		    return;
		P_SetMessage(Toucher.player, GOTCLIPBOX, false);
		break;
	
      case SPR_ROCK:
		if (!P_GiveAmmo (Toucher.player, am_misl,1))
		    return;
		P_SetMessage(Toucher.player, GOTROCKET, false);
		break;

      case SPR_BROK:
		if (!P_GiveAmmo (Toucher.player, am_misl,5))
		    return;
		P_SetMessage(Toucher.player, GOTROCKBOX, false);
		break;
	
      case SPR_CELL:
		if (!P_GiveAmmo (Toucher.player, am_cell,1))
		    return;
		P_SetMessage(Toucher.player, GOTCELL, false);
		break;
	
      case SPR_CELP:
		if (!P_GiveAmmo (Toucher.player, am_cell,5))
		    return;
		P_SetMessage(Toucher.player, GOTCELLBOX, false);
		break;
	
      case SPR_SHEL:
		if (!P_GiveAmmo (Toucher.player, am_shell,1))
		    return;
		P_SetMessage(Toucher.player, GOTSHELLS, false);
		break;
	
      case SPR_SBOX:
		if (!P_GiveAmmo (Toucher.player, am_shell,5))
		    return;
		P_SetMessage(Toucher.player, GOTSHELLBOX, false);
		break;
	
      case SPR_BPAK:
	    Toucher.player->Backpack = true;
		for (i=0 ; i<NUMAMMO; i++)
        {
		    P_GiveAmmo (Toucher.player, i, 1);
		}
		P_SetMessage(Toucher.player, GOTBACKPACK, false);
		break;
	
		// weapons
      case SPR_BFUG:
		if (!P_GiveWeapon (Toucher.player, wp_bfg, false))
		    return;
		P_SetMessage(Toucher.player, GOTBFG9000, false);
		sound = 'PickupWeapon';
		break;
	
      case SPR_MGUN:
		if (!P_GiveWeapon (Toucher.player, wp_chaingun, _self->Flags&MF_DROPPED) )
		    return;
		P_SetMessage(Toucher.player, GOTCHAINGUN, false);
		sound = 'PickupWeapon';
		break;
	
      case SPR_CSAW:
		if (!P_GiveWeapon (Toucher.player, wp_chainsaw, false) )
		    return;
		P_SetMessage(Toucher.player, GOTCHAINSAW, false);
		sound = 'PickupWeapon';
		break;
	
      case SPR_LAUN:
		if (!P_GiveWeapon (Toucher.player, wp_missile, false) )
		    return;
		P_SetMessage(Toucher.player, GOTLAUNCHER, false);
		sound = 'PickupWeapon';
		break;
	
      case SPR_PLAS:
		if (!P_GiveWeapon (Toucher.player, wp_plasma, false) )
		    return;
		P_SetMessage(Toucher.player, GOTPLASMA, false);
		sound = 'PickupWeapon';
		break;
	
      case SPR_SHOT:
		if (!P_GiveWeapon (Toucher.player, wp_shotgun, _self->Flags&MF_DROPPED ) )
		    return;
		P_SetMessage(Toucher.player, GOTSHOTGUN, false);
		sound = 'PickupWeapon';
		break;

#ifdef GRENADE_LAUNCHER
      case SPR_GLAU:
		if (!P_GiveWeapon(Toucher.player, wp_grenade, false))
		    return;
		P_SetMessage(Toucher.player, "Piched up a grenade launcher", false);
		sound = 'PickupWeapon';
		break;
#endif
	
      default:
		Error("P_SpecialThing: Unknown gettable thing");
    }*/

//**************************************************************************
//
//  $Log$
//  Revision 1.18  2002/06/29 15:59:26  dj_jl
//  Split out items, projectiles and decorations.
//
//  Revision 1.17  2002/05/18 17:00:01  dj_jl
//  Renamed SpawnState to IdleState, other changes.
//
//  Revision 1.16  2002/05/03 17:17:31  dj_jl
//  Started work on weapons and items.
//
//  Revision 1.15  2002/03/28 18:11:24  dj_jl
//  Changed hiding of specials like in Raven games.
//
//  Revision 1.14  2002/03/20 19:07:47  dj_jl
//  Got rid of a lots of legacy, beautification.
//
//  Revision 1.13  2002/02/22 18:00:25  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.12  2002/02/14 19:20:59  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.11  2002/02/06 17:28:53  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.10  2002/01/28 18:50:20  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.9  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.8  2002/01/17 18:15:55  dj_jl
//  Renamed all map object classes
//
//  Revision 1.7  2002/01/15 18:27:01  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.6  2002/01/11 18:19:42  dj_jl
//  Started to use names in progs
//
//  Revision 1.5  2002/01/07 12:27:42  dj_jl
//  Changed copyright year
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/30 17:33:18  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:53  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
