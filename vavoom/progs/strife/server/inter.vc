//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**    GET STUFF
//**
//**************************************************************************

int maxammo[] = { 200, 50, 300, 50 };
int clipammo[] = { 10, 4, 20, 1 };

#define BONUSADD	6

void P_RemoveMobj(mobj_t * mobj);

//==========================================================================
//
//  P_GiveAmmo
//
//  Num is the number of clip loads, not the individual count (0= 1/2 clip).
// Returns false if the ammo can't be picked up at all
//
//==========================================================================

boolean P_GiveAmmo(player_t * player, int ammo, int num)
{
	int oldammo;
	int max;

	if (ammo == am_noammo)
		return false;

	if (ammo < 0 || ammo > NUMAMMO)
//      I_Error ("P_GiveAmmo: bad type %i", ammo);
		Error("P_GiveAmmo: bad type");

	max = player->Backpack ? maxammo[ammo] * 2 : maxammo[ammo];
	if (player->Ammo[ammo] == max)
		return false;

	if (num)
		num *= clipammo[ammo];
	else
		num = clipammo[ammo] / 2;

	if (gameskill == sk_baby || gameskill == sk_nightmare)
	{
		// give double ammo in trainer mode,
		// you'll need in nightmare
		num <<= 1;
	}

	oldammo = player->Ammo[ammo];
	player->Ammo[ammo] += num;

	if (player->Ammo[ammo] > max)
		player->Ammo[ammo] = max;

	// If non zero ammo, 
	// don't change up weapons,
	// player was lower on purpose.
	if (oldammo)
		return true;

	// We were down to zero,
	// so select a new weapon.
	// Preferences are not user selectable.
	switch (ammo)
	{
	case am_clip:
		if (player->ReadyWeapon == wp_fist)
		{
			if (player->WeaponOwned[wp_riffle])
				player->PendingWeapon = wp_riffle;
		}
		break;

	case am_electric_arrow:
		if (player->ReadyWeapon == wp_fist)
		{
			if (player->WeaponOwned[wp_crossbow])
				player->PendingWeapon = wp_crossbow;
		}
		break;

	case am_cell:
		if (player->ReadyWeapon == wp_fist)
		{
			if (player->WeaponOwned[wp_flame])
				player->PendingWeapon = wp_flame;
		}
		break;

	case am_misl:
		if (player->ReadyWeapon == wp_fist)
		{
			if (player->WeaponOwned[wp_missile])
				player->PendingWeapon = wp_missile;
		}
	default:
		break;
	}

	return true;
}

//==========================================================================
//
//  P_GiveWeapon
//
//  The weapon name may have a MF_DROPPED flag ored in.
//
//==========================================================================

boolean P_GiveWeapon(player_t * player, int weapon, boolean dropped)
{
	boolean gaveammo;
	boolean gaveweapon;

	if (netgame && (deathmatch < 2) && !dropped)
	{
		// leave placed weapons forever on net games
		if (player->WeaponOwned[weapon])
			return false;

		player->BonusCount += BONUSADD;
		player->WeaponOwned[weapon] = true;

		if (deathmatch)
			P_GiveAmmo(player, weapon_ammo_type[weapon], 5);
		else
			P_GiveAmmo(player, weapon_ammo_type[weapon], 2);
		player->PendingWeapon = weapon;

		player->mo->PlaySound('PickupWeapon', CHAN_ITEM);
		return false;
	}

	if (weapon_ammo_type[weapon] != am_noammo)
	{
		// give one clip with a dropped weapon,
		// two clips with a found weapon
		if (dropped)
			gaveammo = P_GiveAmmo(player, weapon_ammo_type[weapon], 1);
		else
			gaveammo = P_GiveAmmo(player, weapon_ammo_type[weapon], 2);
	}
	else
		gaveammo = false;

	if (player->WeaponOwned[weapon])
		gaveweapon = false;
	else
	{
		gaveweapon = true;
		player->WeaponOwned[weapon] = true;
		player->PendingWeapon = weapon;
	}

	return (gaveweapon || gaveammo);
}

//==========================================================================
//
// P_GiveBody
// Returns false if the body isn't needed at all
//
//==========================================================================

boolean P_GiveBody(player_t * player, int num)
{
	if (player->Health >= MAXHEALTH)
		return false;

	player->Health += num;
	if (player->Health > MAXHEALTH)
		player->Health = MAXHEALTH;
	player->mo->Health = player->Health;

	return true;
}

//==========================================================================
//
// P_GiveArmor
// Returns false if the armor is worse
// than the current armor.
//
//==========================================================================

boolean P_GiveArmor(player_t * player, int armortype)
{
	int hits;

	hits = armortype * 100;
	if (player->ArmorPoints >= hits)
		return false;	// don't pick up

	player->ArmorType = armortype;
	player->ArmorPoints = hits;

	return true;
}

//==========================================================================
//
// P_GiveCard
//
//==========================================================================

boolean P_GiveCard(player_t * player, int card)
{
	if (player->Keys & (1 << card))
		return false;

	player->BonusCount = BONUSADD;
	player->Keys |= 1 << card;
	return true;
}

//==========================================================================
//
//  P_GiveItem
//
//==========================================================================

boolean P_GiveItem(player_t * player, int item)
{
	if (player->Items & item)
	{
		return false;	// already got it
	}

	player->Items |= item;
	return true;
}

//==========================================================================
//
// P_GivePower
//
//==========================================================================

boolean P_GivePower(player_t * player, int power)
{
	if (power == pw_invulnerability)
	{
		player->Powers[power] = ftoi(INVULNTIME * 35.0);
		return true;
	}

	if (power == pw_invisibility)
	{
		player->Powers[power] = ftoi(INVISTIME * 35.0);
		player->mo->Translucency = 90;
		return true;
	}

	if (power == pw_infrared)
	{
		player->Powers[power] = ftoi(INFRATIME * 35.0);
		return true;
	}

	if (power == pw_ironfeet)
	{
		player->Powers[power] = ftoi(IRONTIME * 35.0);
		return true;
	}

	if (power == pw_strength)
	{
		P_GiveBody(player, 100);
		player->Powers[power] = 1;
		return true;
	}

	if (player->Powers[power])
		return false;	// already got it

	player->Powers[power] = 1;
	return true;
}

//==========================================================================
//
//	Actor::TouchSpecial
//
//==========================================================================

void Actor::TouchSpecial(Actor Toucher)
{
	int i;
	name sound;

	if (!Toucher.bIsPlayer)
	{
		// can't remove thing
		return;
	}
	// Dead thing touching.
	// Can happen with a sliding player corpse.
	if (Toucher.Health <= 0)
		return;

	sound = 'PickupItem';

	// Identify by sprite.
/*    switch (_self->sprite)
    {
		// armor
      case SPR_ARM1:
		if (!P_GiveArmor(Toucher.player, 1))
		    return;
		P_SetMessage(Toucher.player, GOTARMOR, false);
		break;
		
      case SPR_ARM2:
		if (!P_GiveArmor(Toucher.player, 2))
		    return;
		P_SetMessage(Toucher.player, GOTMEGA, false);
		break;
	
		// bonus items
      case SPR_BON1:
		Toucher.player->health++;		// can go over 100%
		if (Toucher.player->health > 200)
	    	Toucher.player->health = 200;
		Toucher.player->mo->health = Toucher.player->health;
		P_SetMessage(Toucher.player, GOTHTHBONUS, false);
		break;
	
      case SPR_BON2:
		Toucher.player->ArmorPoints++;		// can go over 100%
		if (Toucher.player->ArmorPoints > 200)
		    Toucher.player->ArmorPoints = 200;
		if (!Toucher.player->ArmorType)
		    Toucher.player->ArmorType = 1;
		P_SetMessage(Toucher.player, GOTARMBONUS, false);
		break;
	
      case SPR_SOUL:
		Toucher.player->health += SOULSPHERE_HEALTH;
		if (Toucher.player->health > SOULSPHERE_MAX)
		    Toucher.player->health = SOULSPHERE_MAX;
		Toucher.player->mo->health = Toucher.player->health;
		P_SetMessage(Toucher.player, GOTSUPER, false);
		sound = 'PickupPower';
		break;

		// cards
		// leave cards for everyone
      case SPR_BKEY:
		if (P_GiveCard(Toucher.player, it_bluecard))
		    P_SetMessage(Toucher.player, GOTBLUECARD, false);
		if (!netgame)
		    break;
		return;
	
      case SPR_YKEY:
		if (P_GiveCard(Toucher.player, it_yellowcard))
		    P_SetMessage(Toucher.player, GOTYELWCARD, false);
		if (!netgame)
		    break;
		return;
	
      case SPR_RKEY:
		if (P_GiveCard(Toucher.player, it_redcard))
		    P_SetMessage(Toucher.player, GOTREDCARD, false);
		if (!netgame)
		    break;
		return;
	
      case SPR_BSKU:
		if (P_GiveCard(Toucher.player, it_blueskull))
		    P_SetMessage(Toucher.player, GOTBLUESKUL, false);
		if (!netgame)
		    break;
		return;
	
      case SPR_YSKU:
		if (P_GiveCard(Toucher.player, it_yellowskull))
		    P_SetMessage(Toucher.player, GOTYELWSKUL, false);
		if (!netgame)
	    	break;
		return;
	
      case SPR_RSKU:
		if (P_GiveCard(Toucher.player, it_redskull))
		    P_SetMessage(Toucher.player, GOTREDSKULL, false);
		if (!netgame)
	    	break;
		return;
	
		// medikits, heals
      case SPR_STIM:
		if (!P_GiveBody (Toucher.player, 10))
		    return;
		P_SetMessage(Toucher.player, GOTSTIM, false);
		break;
	
      case SPR_MEDI:
		if (!P_GiveBody (Toucher.player, 25))
		    return;

		if (Toucher.player->health < 25)
		    P_SetMessage(Toucher.player, GOTMEDINEED, false);
		else
		    P_SetMessage(Toucher.player, GOTMEDIKIT, false);
		break;

	
		// power ups
      case SPR_PINV:
		if (!P_GivePower (Toucher.player, pw_invulnerability))
		    return;
		P_SetMessage(Toucher.player, GOTINVUL, false);
		sound = 'PickupPower';
		break;
	
      case SPR_PSTR:
		if (!P_GivePower (Toucher.player, pw_strength))
		    return;
		P_SetMessage(Toucher.player, GOTBERSERK, false);
		if (Toucher.player->ReadyWeapon != wp_fist)
		    Toucher.player->PendingWeapon = wp_fist;
		sound = 'PickupPower';
		break;
	
      case SPR_PINS:
		if (!P_GivePower (Toucher.player, pw_invisibility))
		    return;
		P_SetMessage(Toucher.player, GOTINVIS, false);
		sound = 'PickupPower';
		break;
	
      case SPR_SUIT:
		if (!P_GivePower (Toucher.player, pw_ironfeet))
		    return;
		P_SetMessage(Toucher.player, GOTSUIT, false);
		sound = 'PickupPower';
		break;
	
      case SPR_PVIS:
		if (!P_GivePower (Toucher.player, pw_infrared))
		    return;
		P_SetMessage(Toucher.player, GOTVISOR, false);
		sound = 'PickupPower';
		break;

	    //	Items
      case SPR_PMAP:
		if (!P_GiveItem(Toucher.player, IT_ALL_MAP))
		    return;
		P_SetMessage(Toucher.player, GOTMAP, false);
		sound = 'PickupPower';
		break;
	
		// ammo
      case SPR_CLIP:
		if (_self->Flags & MF_DROPPED)
		{
		    if (!P_GiveAmmo (Toucher.player,am_clip,0))
				return;
		}
		else
		{
		    if (!P_GiveAmmo (Toucher.player,am_clip,1))
				return;
		}
		P_SetMessage(Toucher.player, GOTCLIP, false);
		break;
	
      case SPR_AMMO:
		if (!P_GiveAmmo (Toucher.player, am_clip,5))
		    return;
		P_SetMessage(Toucher.player, GOTCLIPBOX, false);
		break;
	
      case SPR_ROCK:
		if (!P_GiveAmmo (Toucher.player, am_misl,1))
		    return;
		P_SetMessage(Toucher.player, GOTROCKET, false);
		break;

      case SPR_BROK:
		if (!P_GiveAmmo (Toucher.player, am_misl,5))
		    return;
		P_SetMessage(Toucher.player, GOTROCKBOX, false);
		break;
	
      case SPR_CELL:
		if (!P_GiveAmmo (Toucher.player, am_cell,1))
		    return;
		P_SetMessage(Toucher.player, GOTCELL, false);
		break;
	
      case SPR_CELP:
		if (!P_GiveAmmo (Toucher.player, am_cell,5))
		    return;
		P_SetMessage(Toucher.player, GOTCELLBOX, false);
		break;
	
      case SPR_SHEL:
		if (!P_GiveAmmo (Toucher.player, am_shell,1))
		    return;
		P_SetMessage(Toucher.player, GOTSHELLS, false);
		break;
	
      case SPR_SBOX:
		if (!P_GiveAmmo (Toucher.player, am_shell,5))
		    return;
		P_SetMessage(Toucher.player, GOTSHELLBOX, false);
		break;
	
      case SPR_BPAK:
	    Toucher.player->Backpack = true;
		for (i=0 ; i<NUMAMMO; i++)
        {
		    P_GiveAmmo (Toucher.player, i, 1);
		}
		P_SetMessage(Toucher.player, GOTBACKPACK, false);
		break;
	
		// weapons
      case SPR_BFUG:
		if (!P_GiveWeapon (Toucher.player, wp_bfg, false))
		    return;
		P_SetMessage(Toucher.player, GOTBFG9000, false);
		sound = 'PickupWeapon';
		break;
	
      case SPR_MGUN:
		if (!P_GiveWeapon (Toucher.player, wp_chaingun, _self->Flags&MF_DROPPED) )
		    return;
		P_SetMessage(Toucher.player, GOTCHAINGUN, false);
		sound = 'PickupWeapon';
		break;
	
      case SPR_CSAW:
		if (!P_GiveWeapon (Toucher.player, wp_chainsaw, false) )
		    return;
		P_SetMessage(Toucher.player, GOTCHAINSAW, false);
		sound = 'PickupWeapon';
		break;
	
      case SPR_LAUN:
		if (!P_GiveWeapon (Toucher.player, wp_missile, false) )
		    return;
		P_SetMessage(Toucher.player, GOTLAUNCHER, false);
		sound = 'PickupWeapon';
		break;
	
      case SPR_PLAS:
		if (!P_GiveWeapon (Toucher.player, wp_plasma, false) )
		    return;
		P_SetMessage(Toucher.player, GOTPLASMA, false);
		sound = 'PickupWeapon';
		break;
	
      case SPR_SHOT:
		if (!P_GiveWeapon (Toucher.player, wp_shotgun, _self->Flags&MF_DROPPED ) )
		    return;
		P_SetMessage(Toucher.player, GOTSHOTGUN, false);
		sound = 'PickupWeapon';
		break;

#ifdef GRENADE_LAUNCHER
      case SPR_GLAU:
		if (!P_GiveWeapon(Toucher.player, wp_grenade, false))
		    return;
		P_SetMessage(Toucher.player, "Piched up a grenade launcher", false);
		sound = 'PickupWeapon';
		break;
#endif
	
      default:
		Error("P_SpecialThing: Unknown gettable thing");
    }*/

	if (bCountItem)
		Toucher.Player->ItemCount++;
	P_RemoveMobj(this);
	Toucher.Player->BonusCount += BONUSADD;
	Toucher.PlaySound(sound, CHAN_ITEM);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.13  2002/02/22 18:00:25  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.12  2002/02/14 19:20:59  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.11  2002/02/06 17:28:53  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.10  2002/01/28 18:50:20  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.9  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.8  2002/01/17 18:15:55  dj_jl
//  Renamed all map object classes
//
//  Revision 1.7  2002/01/15 18:27:01  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.6  2002/01/11 18:19:42  dj_jl
//  Started to use names in progs
//
//  Revision 1.5  2002/01/07 12:27:42  dj_jl
//  Changed copyright year
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/30 17:33:18  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:53  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
