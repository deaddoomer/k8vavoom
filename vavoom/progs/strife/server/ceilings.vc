//**************************************************************************
//**
//**	##   ##    ##    ##   ##   ####     ####   ###     ###
//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**	   #    ##    ##    #      ####     ####   ##       ##
//**
//**	$Id$
//**
//**	Copyright (C) 1999-2001 JÆnis Legzdi·ı
//**
//**	This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**	This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**	$Log$
//**	Revision 1.2  2001/07/27 14:27:53  dj_jl
//**	Update with Id-s and Log-s, some fixes
//**
//**************************************************************************
//**
//**	CEILINGS
//**
//**	Ceiling aninmation (lowering, crushing, raising)
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define CEILSPEED		1.0
#define CEILWAIT		150

// TYPES -------------------------------------------------------------------

enum
{
    lowerToFloor,
    raiseToHighest,
    lowerAndCrush,
    crushAndRaise,
    fastCrushAndRaise,
    silentCrushAndRaise
};

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

special_t		activeceilings;

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  P_ClearActiveCeilings
//
//==========================================================================

void P_ClearActiveCeilings(void)
{
 	activeceilings.prev = activeceilings.next = &activeceilings;
}

//==========================================================================
//
//  P_AddActiveCeiling
//
// 	Add an active ceiling
//
//==========================================================================

void P_AddActiveCeiling(special_t* ceiling)
{
	//  Add to active ceilings
	ceiling->prev = activeceilings.prev;
    ceiling->next = &activeceilings;
    ceiling->prev->next = ceiling;
    activeceilings.prev = ceiling;
}

//==========================================================================
//
//  P_RemoveActiveCeiling
//
//	Remove a ceiling's thinker
//
//==========================================================================

void P_RemoveActiveCeiling(special_t* ceiling)
{
	ceiling->next->prev = ceiling->prev;
    ceiling->prev->next = ceiling->next;
    ceiling->sector->specialdata = NULL;
    RemoveSpecialThinker(ceiling);
}

//==========================================================================
//
//	T_MoveCeiling
//
//==========================================================================

void T_MoveCeiling(special_t* ceiling)
{
    int		res;
	
    switch (ceiling->direction)
    {
      case 0:
		// IN STASIS
		break;
      case 1:
		// UP
		res = T_MovePlane(ceiling->sector,
				  ceiling->tic_speed,
				  ceiling->topheight,
				  false, 1, ceiling->direction);
	
		if (!(level->tictime & 7))
		{
		    switch (ceiling->type)
		    {
		      case silentCrushAndRaise:
				break;
		      default:
				StartSoundName(&ceiling->sector->soundorg, "StoneMoving");
				break;
		    }
		}
	
		if (res == RES_PASTDEST)
		{
		    switch (ceiling->type)
		    {
		      case raiseToHighest:
				P_RemoveActiveCeiling(ceiling);
				break;
		
		      case silentCrushAndRaise:
				StartSoundName(&ceiling->sector->soundorg, "PlatformStop");
		      case fastCrushAndRaise:
		      case crushAndRaise:
				ceiling->direction = -1;
				break;

		      default:
				break;
		    }
	    
		}
		break;
	
      case -1:
		// DOWN
		res = T_MovePlane(ceiling->sector,
				  ceiling->tic_speed,
				  ceiling->bottomheight,
				  ceiling->crush, 1, ceiling->direction);
	
		if (!(level->tictime & 7))
		{
		    switch (ceiling->type)
		    {
		      case silentCrushAndRaise:
                   break;
		      default:
                   StartSoundName(&ceiling->sector->soundorg, "StoneMoving");
		    }
		}
	
		if (res == RES_PASTDEST)
		{
		    switch (ceiling->type)
		    {
		      case silentCrushAndRaise:
					StartSoundName(&ceiling->sector->soundorg, "PlatformStop");
		      case crushAndRaise:
					ceiling->tic_speed = CEILSPEED;
		      case fastCrushAndRaise:
					ceiling->direction = 1;
					break;

		      case lowerAndCrush:
		      case lowerToFloor:
					P_RemoveActiveCeiling(ceiling);
					break;

		      default:
					break;
		    }
		}
		else // ( res != pastdest )
		{
		    if (res == RES_CRUSHED)
		    {
				switch (ceiling->type)
				{
				  case silentCrushAndRaise:
				  case crushAndRaise:
				  case lowerAndCrush:
				    ceiling->tic_speed = CEILSPEED / 8.0;
				    break;

				  default:
				    break;
				}
		    }
		}
		break;
    }
}

//==========================================================================
//
//  P_ActivateInStasisCeiling
//
// 	Restart a ceiling that's in-stasis
//
//==========================================================================

int P_ActivateInStasisCeiling(line_t* line)
{
    special_t*		ceiling;
	
    for (ceiling = activeceilings.next;
         ceiling != &activeceilings;
         ceiling = ceiling->next)
    {
		if ((ceiling->tag == line->arg1) && (ceiling->direction == 0))
		{
		    ceiling->direction = ceiling->olddirection;
		}
    }
	return 1;
}

//==========================================================================
//
//	EV_DoCeiling
//
//	Move a ceiling up/down and all around!
//
//==========================================================================

int EV_DoCeiling(line_t* line, int type)
{
    int			secnum;
    int			rtn;
    sector_t*	sec;
    special_t*	ceiling;
	
    secnum = -1;
    rtn = 0;
    
    //	Reactivate in-stasis ceilings...for certain types.
    switch (type)
    {
      case fastCrushAndRaise:
      case silentCrushAndRaise:
      case crushAndRaise:
		P_ActivateInStasisCeiling(line);
      default:
		break;
    }
	
    while ((secnum = FindSectorFromTag(line->arg1,secnum)) >= 0)
    {
		sec = &level->sectors[secnum];
		if (sec->specialdata)
	    	continue;
	
		// new door thinker
		rtn = 1;
		ceiling = NewSpecialThinker(T_MoveCeiling);
		sec->specialdata = ceiling;
		ceiling->sector = sec;
		ceiling->crush = false;
	
		switch(type)
		{
		  case fastCrushAndRaise:
			    ceiling->crush = true;
			    ceiling->topheight = sec->ceilingheight;
			    ceiling->bottomheight = sec->floorheight + 8.0;
			    ceiling->direction = -1;
			    ceiling->tic_speed = CEILSPEED * 2.0;
			    break;

		  case silentCrushAndRaise:
		  case crushAndRaise:
			    ceiling->crush = true;
			    ceiling->topheight = sec->ceilingheight;
		  case lowerAndCrush:
		  case lowerToFloor:
			    ceiling->bottomheight = sec->floorheight;
			    if (type != lowerToFloor)
					ceiling->bottomheight += 8.0;
			    ceiling->direction = -1;
			    ceiling->tic_speed = CEILSPEED;
			    break;

		  case raiseToHighest:
			    ceiling->topheight = FindHighestCeilingSurrounding(sec);
			    ceiling->direction = 1;
			    ceiling->tic_speed = CEILSPEED;
			    break;
		  default:
               break;
		}
		
		ceiling->tag = sec->tag;
		ceiling->type = type;
		P_AddActiveCeiling(ceiling);
    }
    return rtn;
}

//==========================================================================
//
//	EV_CeilingCrushStop
//
//	Stop a ceiling from crushing!
//
//==========================================================================

int	EV_CeilingCrushStop(line_t* line)
{
    int				rtn;
    special_t*		ceiling;
	
	rtn = 0;
    for (ceiling = activeceilings.next;
         ceiling != &activeceilings;
         ceiling = ceiling->next)
		if ((ceiling->tag == line->arg1) && (ceiling->direction != 0))
		{
		    ceiling->olddirection = ceiling->direction;
		    ceiling->direction = 0;		// in-stasis
		    rtn = 1;
		}

    return rtn;
}
