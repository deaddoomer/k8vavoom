//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

enum
{
	// lower floor to highest surrounding floor
	FLEV_LOWERFLOOR,

	// lower floor to lowest surrounding floor
	FLEV_LOWERFLOORTOLOWEST,

	// lower floor to highest surrounding floor VERY FAST
	FLEV_LOWERTOHIGHEST,

	// raise floor to lowest surrounding CEILING
	FLEV_RAISEFLOOR,

	// raise floor to next highest surrounding floor
	FLEV_RAISEFLOORTONEAREST,

	// raise floor to shortest height texture around it
	FLEV_RAISETOTEXTURE,

	// lower floor to lowest surrounding floor
	//  and change floorpic
	FLEV_LOWERTOLOWESTCHANGE,

	FLEV_RAISEFLOORBYVALUE,
	FLEV_RAISEFLOORBYVALUECHANGE,
	FLEV_RAISEFLOORCRUSH,

	FLEV_DONUT,
	FLEV_RAISEBYVALUETIMES8,

	FLEV_RAISEFLOORBYVALUECHANGE2,
	FLEV_RAISEFLOORTONEARESTCHANGE
};

// TYPES -------------------------------------------------------------------

class TFloor:Thinker
{
	sector_t *sector;
	int type;
	float speed;
	boolean crush;
	int direction;	// 1 = up, 0 = waiting, -1 = down
	int newspecial;
	int texture;
	float floordestheight;

	void Think(void);
	void Archive(void);
	void Unarchive(void);
};

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//	TFloor::Think
//
//  MOVE A FLOOR TO IT'S DESTINATION (UP OR DOWN)
//
//==========================================================================

void TFloor::Think(void)
{
	int res;

	res = T_MovePlane(sector, speed * frametime,
		floordestheight, crush, 0, direction);

	if (!(level->tictime & 7))
		SectorStartSoundName(sector, "StoneMoving", CHAN_VOICE);

	if (res == RES_PASTDEST)
	{
		sector->specialdata = NULL;

		if (direction == 1)
		{
			switch (type)
			{
			case FLEV_DONUT:
				sector->special = newspecial;
				SetFloorPic(sector, texture);
				break;

			default:
				break;
			}
		}
		else if (direction == -1)
		{
			switch (type)
			{
			case FLEV_LOWERTOLOWESTCHANGE:
				sector->special = newspecial;
				SetFloorPic(sector, texture);
				break;

			default:
				break;
			}
		}
		RemoveSpecialThinker(this);
		SectorStartSoundName(sector, "PlatformStop", CHAN_VOICE);
	}
}

//==========================================================================
//
//	TFloor::Archive
//
//==========================================================================

void TFloor::Archive(void)
{
	sector = SectorToNum(sector);
}

//==========================================================================
//
//	TFloor::Unarchive
//
//==========================================================================

void TFloor::Unarchive(void)
{
	sector = NumToSector(sector);

	//  Set sector's specialdata
	sector->specialdata = this;
}

//==========================================================================
//
//  EV_DoFloor
//
//  HANDLE FLOOR TYPES
//
//==========================================================================

int EV_DoFloor(line_t * line, int *args, int floortype)
{
	int secnum;
	int rtn;
	int i;
	sector_t *sec;
	TFloor *floor;
	float minsize = 99999.0;
	line_t *secline;
	side_t *side;

	secnum = -1;
	rtn = 0;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &level->sectors[secnum];

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (sec->specialdata)
			continue;

		// new floor thinker
		rtn = 1;
		floor = NewSpecialThinker(TFloor);
		sec->specialdata = floor;
		floor->sector = sec;
		floor->type = floortype;
		floor->crush = false;
		floor->speed = itof(args[1]) * 4.0;

		switch (floortype)
		{
		case FLEV_LOWERFLOOR:
			floor->direction = -1;
			floor->floordestheight = FindHighestFloorSurrounding(sec);
			break;

		case FLEV_LOWERFLOORTOLOWEST:
			floor->direction = -1;
			floor->floordestheight = FindLowestFloorSurrounding(sec);
			break;

		case FLEV_LOWERTOHIGHEST:
			floor->direction = -1;
			floor->floordestheight = FindHighestFloorSurrounding(sec);
			if (floor->floordestheight != sec->floorheight)
				floor->floordestheight += itof(args[2]) - 128.0;
			break;

		case FLEV_RAISEFLOOR:
			floor->direction = 1;
			floor->floordestheight = FindLowestCeilingSurrounding(sec);
			if (floor->floordestheight > sec->ceilingheight)
				floor->floordestheight = sec->ceilingheight;
			break;

		case FLEV_RAISEFLOORCRUSH:
			floor->crush = args[2];
			floor->direction = 1;
			floor->floordestheight = FindLowestCeilingSurrounding(sec);
			if (floor->floordestheight > sec->ceilingheight)
				floor->floordestheight = sec->ceilingheight;
			floor->floordestheight -= 8.0;
			break;

		case FLEV_RAISEFLOORTONEAREST:
			floor->direction = 1;
			floor->floordestheight =
				FindNextHighestFloor(sec, sec->floorheight);
			break;

		case FLEV_RAISEFLOORBYVALUE:
			floor->direction = 1;
			floor->floordestheight = floor->sector->floorheight +
				itof(args[2]);
			break;

		case FLEV_RAISEBYVALUETIMES8:
			floor->direction = 1;
			floor->floordestheight = floor->sector->floorheight +
				itof(args[2]) * 8.0;
			break;

		case FLEV_RAISEFLOORBYVALUECHANGE:
			floor->direction = 1;
			floor->floordestheight = floor->sector->floorheight +
				itof(args[2]);
			SetFloorPic(sec, line->frontsector->floor.pic);
			sec->special = line->frontsector->special;
			break;

		case FLEV_RAISEFLOORBYVALUECHANGE2:
			floor->direction = 1;
			floor->floordestheight = sec->floorheight + itof(args[2]) * 8.0;
			SetFloorPic(sec, line->frontsector->floor.pic);
			SectorStartSoundName(sec, "StoneMoving", CHAN_VOICE);
			break;

		case FLEV_RAISETOTEXTURE:
			floor->direction = 1;
			for (i = 0; i < sec->linecount; i++)
			{
				secline = sec->lines[i];
				if (!(secline->flags & ML_TWOSIDED))
					continue;

				side = &level->sides[secline->sidenum[0]];
				if (side->bottomtexture >= 0)
					if (TextureHeight(side->bottomtexture) < minsize)
						minsize = TextureHeight(side->bottomtexture);

				side = &level->sides[secline->sidenum[1]];
				if (side->bottomtexture >= 0)
					if (TextureHeight(side->bottomtexture) < minsize)
						minsize = TextureHeight(side->bottomtexture);
			}
			floor->floordestheight = floor->sector->floorheight + minsize;
			break;

		case FLEV_LOWERTOLOWESTCHANGE:
			floor->direction = -1;
			floor->floordestheight = FindLowestFloorSurrounding(sec);
			floor->texture = sec->floor.pic;
			for (i = 0; i < sec->linecount; i++)
			{
				secline = sec->lines[i];
				if (secline->flags & ML_TWOSIDED)
				{
					if (level->sides[secline->sidenum[0]].sector == sec)
					{
						sec = level->sides[secline->sidenum[1]].sector;

						if (sec->floorheight == floor->floordestheight)
						{
							floor->texture = sec->floor.pic;
							floor->newspecial = sec->special;
							break;
						}
					}
					else
					{
						sec = level->sides[secline->sidenum[0]].sector;

						if (sec->floorheight == floor->floordestheight)
						{
							floor->texture = sec->floor.pic;
							floor->newspecial = sec->special;
							break;
						}
					}
				}
			}
			break;

		case FLEV_RAISEFLOORTONEARESTCHANGE:
			floor->direction = 1;
			floor->floordestheight =
				FindNextHighestFloor(sec, sec->floorheight);
			SetFloorPic(sec, line->frontsector->floor.pic);
			// NO MORE DAMAGE, IF APPLICABLE
			sec->special = 0;
			SectorStartSoundName(sec, "StoneMoving", CHAN_VOICE);
			break;

		default:
			break;
		}
	}
	return rtn;
}

//==========================================================================
//
//  EV_BuildStairs
//
//  BUILD A STAIRCASE!
//
//==========================================================================

int EV_BuildStairs(line_t * line, int *args)
{
	int secnum;
	float height;
	int i;
	int texture;
	int ok;
	int rtn;
	int j;

	sector_t *sec;
	sector_t *tsec;

	TFloor *floor;

	float stairsize;
	float speed;

	speed = itof(args[1]) * 4.0;
	stairsize = itof(args[2]);

	secnum = -1;
	rtn = 0;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &level->sectors[secnum];

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (sec->specialdata)
			continue;

		// new floor thinker
		rtn = 1;
		floor = NewSpecialThinker(TFloor);
		sec->specialdata = floor;
		floor->direction = 1;
		floor->sector = sec;
		floor->speed = speed;
		height = sec->floorheight + stairsize;
		floor->floordestheight = height;

		texture = sec->floor.pic;

		// Find next sector to raise
		// 1.   Find 2-sided line with same sector side[0]
		// 2.   Other side is the next sector to raise
		//   3. Unless already moving, or different texture, then stop building
		do
		{
			ok = 0;
			for (i = 0; i < sec->linecount; i++)
			{
				if (!(sec->lines[i]->flags & ML_TWOSIDED))
					continue;

				tsec = sec->lines[i]->frontsector;

				if (&level->sectors[secnum] != tsec)
					continue;

				tsec = sec->lines[i]->backsector;

				if (tsec->floor.pic != texture)
					continue;

				height += stairsize;

				if (tsec->specialdata)
					continue;

				sec = tsec;
//              secnum = tsec - level->sectors;
				for (j = 0; j < level->numsectors; j++)
					if (tsec == &level->sectors[j])
					{
						secnum = j;
						break;
					}

				floor = NewSpecialThinker(TFloor);

				sec->specialdata = floor;
				floor->direction = 1;
				floor->sector = sec;
				floor->speed = speed;
				floor->floordestheight = height;
				ok = 1;
				break;
			}
		}
		while (ok);
	}
	return rtn;
}

//==========================================================================
//
//  EV_DoDonut()
//
//  Handle donut function: lower pillar, raise surrounding pool, both to
// height, texture and type of the sector surrounding the pool.
//  Passed the linedef that triggered the donut
//  Returns whether a thinker was created
//
//==========================================================================

int EV_DoDonut(line_t * line, int *args)
{
	sector_t *s1;
	sector_t *s2;
	sector_t *s3;
	int secnum;
	int rtn;
	int i;
	TFloor *floor;

	secnum = -1;
	rtn = 0;
	// do function on all sectors with same tag as linedef
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		s1 = &level->sectors[secnum];	// s1 is pillar's sector

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (s1->specialdata)
			continue;

		s2 = getNextSector(s1->lines[0], s1);	// s2 is pool's sector
		rtn = 1;

		// find a two sided line around the pool whose other side isn't the pillar
		for (i = 0; i < s2->linecount; i++)
		{
			if ((!s2->lines[i]->flags & ML_TWOSIDED) ||
				(s2->lines[i]->backsector == s1))
				continue;
			s3 = s2->lines[i]->backsector;

			//  Spawn rising slime
			floor = NewSpecialThinker(TFloor);
			s2->specialdata = floor;
			floor->type = FLEV_DONUT;
			floor->crush = false;
			floor->direction = 1;
			floor->sector = s2;
			floor->speed = itof(args[1]) * 4.0;
			floor->texture = s3->floor.pic;
			floor->newspecial = 0;
			floor->floordestheight = s3->floorheight;

			//  Spawn lowering donut-hole
			floor = NewSpecialThinker(TFloor);
			s1->specialdata = floor;
			floor->type = FLEV_LOWERFLOOR;
			floor->crush = false;
			floor->direction = -1;
			floor->sector = s1;
			floor->speed = itof(args[2]) * 4.0;
			floor->floordestheight = s3->floorheight;
			break;
		}
	}
	return rtn;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.6  2001/09/25 17:12:09  dj_jl
//  Switched to Hexen map format, special thinker classes
//
//  Revision 1.5  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.4  2001/09/20 16:20:00  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.3  2001/08/30 17:33:18  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:53  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
