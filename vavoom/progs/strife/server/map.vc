//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

classid InvItemCID[NUMINVITEMS] =
{
	MedPatch,
	MedicalKit,
	SurgeryKit,
	DegninOre,
	MetalArmor,
	LeatherArmor,
	Shadow_armor,
	Environmental_Suit,
	Guard_Uniform,
	Officers_Uniform,
	Map,
	Scanner,
	Teleporter_Beacon,
	Targeter,
	Coin,
	Ring,
	Offering_Chalice,
	Ear,
	Flame_thrower_Parts,
	BrokenPowerCoupling,
	Prison_pass,
	Report,
	Toughness,
	Accuracy,
	Oracle_Pass,
};

classid KeyCID[NUMKEYS] =
{
	ItemBaseKey,
	ItemGovsKey,
	ItemPasscard,
	ItemIDBadge,
	ItemPrisonKey,
	ItemSeveredHand,
	ItemPower1Key,
	ItemPower2Key,
	ItemGoldKey,
	ItemPower3Key,
	ItemIDCard,
	ItemSilverKey,
	ItemOracleKey,
	ItemMilitaryID,
	ItemOrderKey,
	ItemWarehouseKey,
	ItemBrassKey,
	ItemRedCrystalKey,
	ItemBlueCrystalKey,
	ItemChapelKey,
	ItemCatacombKey,
	ItemSecurityKey,
	ItemCoreKey,
	ItemMaulerKey,
	ItemFactoryKey,
	ItemMineKey,
	ItemNewKey5,
};

// CODE --------------------------------------------------------------------

//**************************************************************************
//
//	CONVERSATION STUFF
//
//**************************************************************************

Actor CurrentSpeaker;
Actor CurrentSpeakingTo;
float OldSpeakerAngle;
int CurrentSpeechIndex;

//==========================================================================
//
//	GetSpeechIndex
//
//==========================================================================

int GetSpeechIndex(RogueConSpeech *List, int Count, int ID, int Num)
{
	int Found;
	int i;

	Found = 0;
	for (i = 0; i < Count; i++)
	{
		if (List[i].SpeakerID == ID)
		{
			Found++;
			if (Found == Num)
			{
				return i + 1;
			}
		}
	}
	return 0;
}

//==========================================================================
//
//	GetSpeech
//
//==========================================================================

int GetSpeech(Actor A)
{
	int Index;

	if (!A.CurrentSpeech)
	{
		A.CurrentSpeech = 1;
	}
	Index = GetSpeechIndex(GLevel.LevelSpeeches, GLevel.NumLevelSpeeches,
		A.ConversationID, A.CurrentSpeech);
	if (Index)
	{
		return Index;
	}
	return -GetSpeechIndex(GLevel.GenericSpeeches, GLevel.NumGenericSpeeches,
		A.ConversationID, A.CurrentSpeech);
}

//==========================================================================
//
//	StartConversation
//
//==========================================================================

bool StartConversation(Actor User, Actor UseOn)
{
	int SpeechNum;

	if (netgame)
	{
		return false;
	}
	if (!User || !User.bIsPlayer || User.Health <= 0)
	{
		return false;
	}
	if (!UseOn || UseOn.Health <= 0)
	{
		return false;
	}
	if (!UseOn.ConversationID)
	{
		return false;
	}
	SpeechNum = GetSpeech(UseOn);
	if (SpeechNum)
	{
		CurrentSpeaker = UseOn;
		CurrentSpeakingTo = User;
		OldSpeakerAngle = UseOn.Angles.yaw;
		UseOn.Angles.yaw = atan2(User.Origin.y - UseOn.Origin.y,
			User.Origin.x - UseOn.Origin.x);
		StartSpeech(SpeechNum);
	}
	return true;
}

//==========================================================================
//
//	StartSpeech
//
//==========================================================================

void StartSpeech(int SpeechNum)
{
	RogueConSpeech *Speech;
	bool conJumped;

	do
	{
		conJumped = false;
		if (!SpeechNum)
		{
			StopSpeech();
			return;
		}
		if (SpeechNum < 0)
		{
			Speech = &GLevel.GenericSpeeches[-SpeechNum - 1];
		}
		else
		{
			Speech = &GLevel.LevelSpeeches[SpeechNum - 1];
		}
		if (Speech->JumpToConv &&
			CheckForNeededItem(CurrentSpeakingTo, Speech->CheckItem1, 1) != -2 &&
			CheckForNeededItem(CurrentSpeakingTo, Speech->CheckItem2, 1) != -2 &&
			CheckForNeededItem(CurrentSpeakingTo, Speech->CheckItem3, 1) != -2)
		{
			CurrentSpeaker.CurrentSpeech = Speech->JumpToConv;
			SpeechNum = GetSpeech(CurrentSpeaker);
			conJumped = true;
		}
	}
	while (conJumped);
	CurrentSpeechIndex = SpeechNum;

	MSG_Select(MSG_SV_RELIABLE);
	MSG_WriteByte(svc_speech);
	MSG_WriteShort(SpeechNum);
}

//==========================================================================
//
//	CheckChoice
//
//==========================================================================

bool CheckChoice(RogueConChoice *Choice)
{
	int Item1;
	int Item2;
	int Item3;
	classid ItemType;
	Pickup Item;

	Item1 = CheckForNeededItem(CurrentSpeakingTo, Choice->NeedItem1, Choice->NeedAmount1);
	Item2 = CheckForNeededItem(CurrentSpeakingTo, Choice->NeedItem2, Choice->NeedAmount2);
	Item3 = CheckForNeededItem(CurrentSpeakingTo, Choice->NeedItem3, Choice->NeedAmount3);
	if (Item1 == -2 || Item2 == -2 || Item3 == -2)
	{
		return false;
	}
	if (Item1 != -1)
		CurrentSpeakingTo.Player.RemoveInvItem(Item1, Choice->NeedAmount1);
	if (Item2 != -1)
		CurrentSpeakingTo.Player.RemoveInvItem(Item2, Choice->NeedAmount2);
	if (Item3 != -1)
		CurrentSpeakingTo.Player.RemoveInvItem(Item3, Choice->NeedAmount3);
	if (Choice->GiveItem > 0)
	{
		ItemType = GetClassFromID(Choice->GiveItem);
		if (ItemType != classidNone)
		{
			Item = Pickup(Spawn(ItemType, vector(0.0, 0.0, 0.0)));
			Item.GiveItemTo(CurrentSpeakingTo);
			Item.Remove();
		}
		//	Several items actually give more items
		ItemType = GetExtraClassFromID(Choice->GiveItem);
		if (ItemType != classidNone)
		{
			Item = Pickup(Spawn(ItemType, vector(0.0, 0.0, 0.0)));
			Item.GiveItemTo(CurrentSpeakingTo);
			Item.Remove();
		}
	}
	if (Choice->Objectives)
	{
		CurrentSpeakingTo.Player.Objectives = Choice->Objectives;
	}
	return true;
}

//==========================================================================
//
//	GetClassFromID
//
//==========================================================================

classid GetClassFromID(int ID)
{
	switch (ID)
	{
	case 125:	return MedPatch;
	case 126:	return MedicalKit;
	case 127:	return SurgeryKit;
	case 128:	return DegninOre;
	case 129:	return MetalArmor;
	case 130:	return LeatherArmor;
	case 133:	return ItemBaseKey;
	case 134:	return ItemGovsKey;
	case 135:	return ItemPasscard;
	case 136:	return ItemIDBadge;
	case 137:	return ItemPrisonKey;
	case 138:	return ItemSeveredHand;
	case 139:	return ItemPower1Key;
	case 140:	return ItemPower2Key;
	case 141:	return ItemPower3Key;
	case 142:	return ItemGoldKey;
	case 143:	return ItemIDCard;
	case 144:	return ItemSilverKey;
	case 145:	return ItemOracleKey;
	case 146:	return ItemMilitaryID;
	case 147:	return ItemOrderKey;
	case 148:	return ItemWarehouseKey;
	case 149:	return ItemBrassKey;
	case 150:	return ItemRedCrystalKey;
	case 151:	return ItemBlueCrystalKey;
	case 152:	return ItemChapelKey;
	case 153:	return ItemCatacombKey;
	case 154:	return ItemSecurityKey;
	case 155:	return ItemCoreKey;
	case 156:	return ItemMaulerKey;
	case 157:	return ItemFactoryKey;
	case 158:	return ItemMineKey;
	case 159:	return ItemNewKey5;
	case 160:	return Shadow_armor;
	case 161:	return Environmental_Suit;
	case 162:	return Guard_Uniform;
	case 163:	return Officers_Uniform;
	case 164:	return Map;
	case 165:	return Scanner;
	case 166:	return Teleporter_Beacon;
	case 167:	return Targeter;
	case 168:	return Coin;
	case 169:	return Gold10;
	case 170:	return Gold25;
	case 171:	return Gold50;
	case 172:	return Gold300;
	case 173:	return Ring;
	case 174:	return Offering_Chalice;
	case 175:	return Ear;
	case 176:	return Communicator;
	case 177:	return ItemAmmoHEGrenadeRounds;
	case 178:	return ItemAmmoPhosphorusGrenadeRounds;
	case 179:	return ItemAmmoClipOfBullets;
	case 180:	return ItemAmmoBoxOfBullets;
	case 181:	return ItemAmmoMiniMissiles;
	case 182:	return ItemAmmoCrateOfMissiles;
	case 183:	return ItemAmmoEnergyPod;
	case 184:	return ItemAmmoEnergyPack;
	case 185:	return ItemAmmoPoisonBolts;
	case 186:	return ItemAmmoElectricBolts;
	case 187:	return Ammo_satchel;
	case 188:	return ItemWeaponAssaultGun;
	case 189:	return ItemWeaponAssaultGun2;
	case 190:	return ItemWeaponFlameThrower;
	case 191:	return Flame_thrower_Parts;
	case 192:	return ItemWeaponMiniMissileLauncher;
	case 193:	return ItemWeaponMauler;
	case 194:	return ItemWeaponCrossbow;
	case 195:	return ItemWeaponGrenadeLauncher;
	case 196:	return ItemWeaponSigil1;
	case 197:	return ItemWeaponSigil2;
	case 198:	return ItemWeaponSigil3;
	case 199:	return ItemWeaponSigil4;
	case 200:	return ItemWeaponSigil5;
	case 289:	return BrokenPowerCoupling;
	case 298:	return Ammo2;
	case 299:	return Health1;
	case 300:	return Info1;
	case 301:	return Alarm1;
	case 302:	return ConversationItem302;
	case 303:	return ConversationItem303;
	case 304:	return Prison_pass;
	case 305:	return ConversationItem305;
	case 306:	return ConversationItem306;
	case 307:	return ConversationItem307;
	case 308:	return Report;
	case 309:	return Toughness;
	case 310:	return Accuracy;
	case 311:	return Oracle_Pass;
	case 312:	return Quest1;
	case 313:	return Quest2;
	case 314:	return Quest3;
	case 315:	return Quest4;
	case 316:	return Quest5;
	case 317:	return Quest6;
	case 318:	return Quest7;
	case 319:	return Quest8;
	case 320:	return Quest9;
	case 321:	return Quest10;
	case 322:	return Quest11;
	case 323:	return Quest12;
	case 324:	return Quest13;
	case 325:	return Quest14;
	case 326:	return Quest15;
	case 327:	return Quest16;
	case 328:	return Quest17;
	case 329:	return Quest18;
	case 330:	return Quest19;
	case 331:	return Quest20;
	case 332:	return Quest21;
	case 333:	return Quest22;
	case 334:	return Quest23;
	case 335:	return Quest24;
	case 336:	return Quest25;
	case 337:	return Quest26;
	case 338:	return Quest27;
	case 339:	return Quest28;
	case 340:	return Quest29;
	case 341:	return Quest30;
	case 342:	return Quest31;
	case 343:	return ConversationItem343;
	}
	if (ID)
	{
		print("Unknown item %d", ID);
	}
	return classidNone;
}

//==========================================================================
//
//	GetExtraClassFromID
//
//==========================================================================

classid GetExtraClassFromID(int ID)
{
	switch (ID)
	{
	case 309:	return Accuracy;	//	Toughness;
	}
	return classidNone;
}

//==========================================================================
//
//	CheckForNeededItem
//
//==========================================================================

int CheckForNeededItem(Actor A, int ID, int Amount)
{
	classid CID;
	int i;

	//	Get class ID.
	CID = GetClassFromID(ID);
	//	Check inventory items.
	for (i = 0; i < NUMINVITEMS; i++)
	{
		if (InvItemCID[i] == CID)
		{
			return A.Player.Inventory[i] < Amount ? -2 : i;
		}
	}
	//	Check keys.
	for (i = 0; i < NUMKEYS; i++)
	{
		if (KeyCID[i] == CID)
		{
			return A.Player.Keys & (1 << i) ? -1 : -2;
		}
	}
	//	Check quests.
	if (ID >= 312 && ID <= 342)
	{
		return A.Player.Quests & (1 << (ID - 312)) ? -1 : -2;
	}
	//	Check Communicator.
	if (CID == Communicator)
	{
		return A.Player.Communicator ? -1 : -2;
	}
	return -1;
}

//==========================================================================
//
//	StopSpeech
//
//==========================================================================

void StopSpeech(void)
{
	CurrentSpeaker.Angles.yaw = OldSpeakerAngle;
	CurrentSpeaker = none;
	CurrentSpeakingTo = none;
	CurrentSpeechIndex = 0;
}

//==========================================================================
//
//	ConChoiceImpulse
//
//==========================================================================

void ConChoiceImpulse(int ChoiceNum)
{
	RogueConSpeech *Speech;
	RogueConChoice *Choice;
	int SpeechNum;

	if (!CurrentSpeaker || !CurrentSpeechIndex)
	{
		return;
	}
	if (!ChoiceNum)
	{
		StopSpeech();
		return;
	}
	if (CurrentSpeechIndex < 0)
	{
		Speech = &GLevel.GenericSpeeches[-CurrentSpeechIndex - 1];
	}
	else
	{
		Speech = &GLevel.LevelSpeeches[CurrentSpeechIndex - 1];
	}
	Choice = &Speech->Choices[ChoiceNum - 1];
	if (!CheckChoice(Choice))
	{
		cprint(CurrentSpeakingTo.Player, ARR2STR(Choice->TextNo));
		StopSpeech();
		return;
	}
	if (strcmp(ARR2STR(Choice->TextOK), "") &&
		strcmp(ARR2STR(Choice->TextOK), "_"))
	{
		cprint(CurrentSpeakingTo.Player, ARR2STR(Choice->TextOK));
	}
	if (Choice->Next < 0)
	{
		CurrentSpeaker.CurrentSpeech = -Choice->Next;
		StartSpeech(GetSpeech(CurrentSpeaker));
	}
	else
	{
		if (Choice->Next)
		{
			CurrentSpeaker.CurrentSpeech = Choice->Next;
		}
		StopSpeech();
	}
}

//**************************************************************************
//
//  USE LINES
//
//**************************************************************************

#define USERANGE		64.0
#define USETHINGRANGE	96.0

Actor usething;
TVec useDir;

//==========================================================================
//
//  PTR_UseThingTraverse
//
//==========================================================================

bool PTR_UseThingTraverse(intercept_t * in)
{
	TVec hit_point;
	opening_t *open;

	if (!in->bIsALine)
	{
		//	Check height.
		if (usething.Origin.z >= in->Thing.Origin.z + in->Thing.Height ||
			usething.Origin.z + usething.Height <= in->Thing.Origin.z)
		{
			return true;
		}
		if (StartConversation(usething, Actor(in->Thing)))
		{
			return false;
		}
		return true;
	}

	if (!(in->line->flags & ML_TWOSIDED))
		return false;	// stop

	hit_point = usething.Origin + (USETHINGRANGE * in->frac) * useDir;
	open = LineOpenings(in->line, hit_point);
	open = FindOpening(open, hit_point.z, hit_point.z + usething.Height);
	if (!open)
	{
		// can't use through a wall
		return false;
	}
	return true;
}

//==========================================================================
//
//  PTR_UseTraverse
//
//==========================================================================

bool PTR_UseTraverse(intercept_t * in)
{
	if (!in->line->special)
	{
		TVec hit_point;
		opening_t *open;

		hit_point = usething.Origin + (USERANGE * in->frac) * useDir;
		open = LineOpenings(in->line, hit_point);
		open = FindOpening(open, hit_point.z, hit_point.z + usething.Height);
		if (!open)
		{
			usething.PlaySound('Blocked', CHAN_VOICE);

			// can't use through a wall
			return false;
		}
		// not a special line, but keep checking
		return true;
	}

	if (PointOnPlaneSide(usething.Origin, in->line) == 1)
		return false;	// don't use back side

	P_ActivateLine(in->line, usething, 0, SPAC_USE);

	// can't use for than one special line in a row
	return false;
}

//==========================================================================
//
//  P_UseLines
//
//  Looks for special lines in front of the player to activate.
//
//==========================================================================

void P_UseLines(Player player)
{
	float x1;
	float y1;
	float x2;
	float y2;

	usething = player.MO;

	AngleVector(&player.MO.Angles, &useDir);
	x1 = player.MO.Origin.x;
	y1 = player.MO.Origin.y;

	x2 = x1 + USETHINGRANGE * useDir.x;
	y2 = y1 + USETHINGRANGE * useDir.y;
	P_PathTraverse(x1, y1, x2, y2, PT_ADDLINES | PT_ADDTHINGS,
		'PTR_UseThingTraverse');

	x2 = x1 + USERANGE * useDir.x;
	y2 = y1 + USERANGE * useDir.y;
	P_PathTraverse(x1, y1, x2, y2, PT_ADDLINES, 'PTR_UseTraverse');
}

//**************************************************************************
//
//  AIMING
//
//**************************************************************************

Actor aim_thing;

// Height if not aiming up or down
// ???: use slope for monsters?
float aim_z;
float aim_range;
float aim_slope;
TVec aim_dir;
float aim_topslope;
float aim_bottomslope;	// slopes to top and bottom of target
Actor linetarget;	// who got hit (or NULL)
float aim_range2d;

//==========================================================================
//
//  PTR_AimTraverse
//
//  Sets linetaget and aim_slope when a target is aimed at.
//
//==========================================================================

bool PTR_AimTraverse(intercept_t * in)
{
	line_t *li;
	Actor Th;
	float thingtopslope;
	float thingbottomslope;
	float dist;
	float slope;
	opening_t *open;

	if (in->bIsALine)
	{
		TVec hit_point;

		li = in->line;

		if (!(li->flags & ML_TWOSIDED))
			return false;	// stop

		// Crosses a two sided line.
		// A two sided line will restrict
		// the possible target ranges.
		dist = aim_range * in->frac;
		hit_point = aim_thing.Origin + dist * aim_dir;
		open = LineOpenings(li, hit_point);
		open = FindOpening(open, hit_point.z, hit_point.z);

		if (!open || open->bottom >= open->top)
			return false;	// stop

		dist = aim_range2d * in->frac;
		if (li->frontsector->floorheight != li->backsector->floorheight)
		{
			slope = (open->bottom - aim_z) / dist;
			if (slope > aim_bottomslope)
				aim_bottomslope = slope;
		}

		if (li->frontsector->ceilingheight != li->backsector->ceilingheight)
		{
			slope = (open->top - aim_z) / dist;
			if (slope < aim_topslope)
				aim_topslope = slope;
		}

		if (aim_topslope <= aim_bottomslope)
			return false;	// stop

		return true;	// shot continues
	}

	// shoot a thing
	Th = Actor(in->Thing);
	if (Th == aim_thing)
		return true;	// can't shoot self

	if (!Th.bShootable)
		return true;	// corpse or something

#ifdef FIXME
	//  Hexen does this. There's no reason why we can't enable it in Doom.
	if (Th.player && netgame && !deathmatch)
	{
		// don't aim at fellow co-op players
		return true;
	}
#endif

	// check angles to see if the thing can be aimed at
	dist = aim_range2d * in->frac;
	thingtopslope = (Th.Origin.z + Th.Height - aim_z) / dist;

	if (thingtopslope < aim_bottomslope)
		return true;	// shot over the thing

	thingbottomslope = (Th.Origin.z - aim_z) / dist;

	if (thingbottomslope > aim_topslope)
		return true;	// shot under the thing

	// this thing can be hit!
	if (thingtopslope > aim_topslope)
		thingtopslope = aim_topslope;

	if (thingbottomslope < aim_bottomslope)
		thingbottomslope = aim_bottomslope;

	aim_slope = (thingtopslope + thingbottomslope) / 2.0;
	linetarget = Th;

	return false;	// don't go any farther
}

//==========================================================================
//
//  AimLineAttack
//
//==========================================================================

TVec AimLineAttack(Actor t1, TAVec angles, float distance)
{
	float x2;
	float y2;
	float topangle;
	float botangle;
	TVec dir;

	aim_thing = t1;

	AngleVector(&angles, &aim_dir);
	x2 = t1.Origin.x + distance * aim_dir.x;
	y2 = t1.Origin.y + distance * aim_dir.y;
	aim_z = t1.Origin.z + t1.Height / 2.0 + 8.0 - t1.FloorClip;
	aim_range2d =
		Length(vector(distance * aim_dir.x, distance * aim_dir.y, 0.0));

	// can't shoot outside view angles
	topangle = AngleMod180(-angles.pitch + 30.0);
	botangle = AngleMod180(-angles.pitch - 30.0);
	if (topangle > 89.0)
		topangle = 89.0;
	if (botangle < -89.0)
		botangle = -89.0;
	aim_topslope = tan(topangle);
	aim_bottomslope = tan(botangle);

	aim_range = distance;
	linetarget = none;

	P_PathTraverse(t1.Origin.x, t1.Origin.y, x2, y2,
		PT_ADDLINES | PT_ADDTHINGS, 'PTR_AimTraverse');

	if (linetarget)
	{
		angles.pitch = -atan(aim_slope);
	}
	AngleVector(&angles, &dir);
	return dir;
}

//===========================================================================
//
//	Aim
//
//  Sets a slope so a near miss is at aproximately the height of the
// intended target
//
//===========================================================================

TVec Aim(Actor A, float distance)
{
	TAVec an;
	TVec dir;

	// see which target is to be aimed at
	an = A.Angles;

	dir = AimLineAttack(A, an, distance);
	if (!linetarget)
	{
		an.yaw = AngleMod360(an.yaw + 45.0 / 8.0);
		dir = AimLineAttack(A, an, distance);
		if (!linetarget)
		{
			an.yaw = AngleMod360(an.yaw - 45.0 / 4.0);
			dir = AimLineAttack(A, an, distance);
			if (!linetarget)
			{
				an.yaw = AngleMod360(an.yaw + 45.0 / 8.0);
				AngleVector(&an, &dir);
			}
		}
	}
	return dir;
}

//===========================================================================
//
//	AimAngle
//
//  Sets a slope so a near miss is at aproximately the height of the
// intended target
//
//===========================================================================

TVec AimAngle(Actor A, float distance, float angle)
{
	TAVec an;
	TVec dir;

	// see which target is to be aimed at
	an = A.Angles;
	an.yaw = angle;

	dir = AimLineAttack(A, an, distance);
	if (!linetarget)
	{
		an.yaw = AngleMod360(an.yaw + 45.0 / 8.0);
		dir = AimLineAttack(A, an, distance);
		if (!linetarget)
		{
			an.yaw = AngleMod360(an.yaw - 45.0 / 4.0);
			dir = AimLineAttack(A, an, distance);
			if (!linetarget)
			{
				an.yaw = AngleMod360(an.yaw + 45.0 / 8.0);
				AngleVector(&an, &dir);
			}
		}
	}
	return dir;
}

//**************************************************************************
//
//  SHOOTING
//
//**************************************************************************

Actor shoot_thing;
float shoot_range;
TVec shoot_origin;
TVec shoot_dir;
int la_damage;

//==========================================================================
//
//  ShootHitPlane
//
//==========================================================================

bool ShootHitPlane(sec_plane_t * plane)
{
	float org_dist;
	float hit_dist;

	if (plane->flags & SPF_NOBLOCKSHOOT)
	{
		//  Doesn't block shooting
		return true;
	}
	org_dist = DotProduct(linestart, plane->normal) - plane->dist;
	if (org_dist < 0.0)
	{
		//  Don't shoot back side
		return true;
	}
	hit_dist = DotProduct(lineend, plane->normal) - plane->dist;
	if (hit_dist >= 0.0)
	{
		//  Didn't hit plane
		return true;
	}

	//  Hit plane
	if (plane->pic == skyflatnum)
	{
		// don't shoot the sky!
		return false;
	}

	//  If we are shooting floor or ceiling we are adjusting position
	// to spawn puff on floor or ceiling, not on wall
	lineend -= (lineend - linestart) * hit_dist / (hit_dist - org_dist);

	// position a bit closer
	lineend += 4.0 * plane->normal;

	// Spawn bullet puffs.
	SpawnPuff(lineend.x, lineend.y, lineend.z);

	// don't go any farther
	return false;
}

//==========================================================================
//
//  ShootCheckPlanes
//
//==========================================================================

bool ShootCheckPlanes(sector_t * sec)
{
	sec_region_t *reg;
	sec_region_t *startreg;

	startreg = PointInRegion(sec, linestart);
	for (reg = startreg; reg; reg = reg->next)
	{
		if (!ShootHitPlane(reg->floor))
		{
			//  Hit floor
			return false;
		}
		if (!ShootHitPlane(reg->ceiling))
		{
			//  Hit ceiling
			return false;
		}
	}
	for (reg = startreg->prev; reg; reg = reg->prev)
	{
		if (!ShootHitPlane(reg->floor))
		{
			//  Hit floor
			return false;
		}
		if (!ShootHitPlane(reg->ceiling))
		{
			//  Hit ceiling
			return false;
		}
	}
	return true;
}

//==========================================================================
//
//  PTR_ShootTraverse
//
//==========================================================================

bool PTR_ShootTraverse(intercept_t * in)
{
	TVec hit_point;
	line_t *li;
	Actor th;

	if (in->bIsALine)
	{
		sector_t *sec;

		li = in->line;
		hit_point = shoot_origin + (shoot_range * in->frac) * shoot_dir;
		if (li->flags & ML_TWOSIDED && PointOnPlaneSide(shoot_origin, li))
		{
			sec = li->backsector;
		}
		else
		{
			sec = li->frontsector;
		}

		lineend = hit_point;

		//  Check for shooting floor or ceiling
		if (!ShootCheckPlanes(sec))
		{
			return false;
		}

		linestart = lineend;

		//  Execute line special after checking for hitting floor or ceiling
		// when we know that it actally hits line
		if (li->special)
		{
			P_ActivateLine(li, shoot_thing, 0, SPAC_IMPACT);
		}

		if (li->flags & ML_TWOSIDED)
		{
			// crosses a two sided line
			opening_t *open;
			float opentop = 0.0;

			open = LineOpenings(li, hit_point);
			if (open)
			{
				opentop = open->top;
			}
			while (open)
			{
				if (open->bottom <= hit_point.z && open->top >= hit_point.z)
				{
					// shot continues
					return true;
				}
				open = open->next;
			}
			if (li->frontsector->ceiling.pic == skyflatnum &&
				li->backsector->ceiling.pic == skyflatnum &&
				hit_point.z > opentop)
			{
				// it's a sky hack wall
				return false;
			}
		}

		//  Hit line

		// position a bit closer
		hit_point -= 4.0 * shoot_dir;

		// Spawn bullet puffs.
		SpawnPuff(hit_point.x, hit_point.y, hit_point.z);

		// don't go any farther
		return false;
	}

	// shoot a thing
	th = Actor(in->Thing);

	if (th == shoot_thing)
		return true;	// can't shoot self

	if (!th.bShootable)
		return true;	// corpse or something

	// check angles to see if the thing can be aimed at
	hit_point = shoot_origin + (shoot_range * in->frac) * shoot_dir;

	if (th.Origin.z + th.Height < hit_point.z)
		return true;	// shot over the thing

	if (th.Origin.z > hit_point.z)
		return true;	// shot under the thing

	// hit thing
	// position a bit closer
	hit_point -= 10.0 * shoot_dir;

	// Spawn bullet puffs or blod spots,
	// depending on target type.
	if (th.bNoBlood)
		SpawnPuff(hit_point.x, hit_point.y, hit_point.z);
	else
		P_SpawnBlood(hit_point.x, hit_point.y, hit_point.z, la_damage);

	if (la_damage)
		th.Damage(shoot_thing, shoot_thing, la_damage);

	// don't go any farther
	return false;
}

//==========================================================================
//
//  LineAttack
//
//  If damage == 0, it is just a test trace that will leave linetarget set.
//
//==========================================================================

int LineAttack(Actor t1, TVec dir, float distance, int damage)
{
	TVec dst;

	shoot_thing = t1;
	la_damage = damage;

	shoot_origin = t1.Origin;
	shoot_origin.z += t1.Height * 0.5 + 8.0 - t1.FloorClip;

	shoot_dir = dir;
	shoot_range = distance;

	dst = shoot_origin + shoot_range * shoot_dir;
	linestart = shoot_origin;
	if (!P_PathTraverse(t1.Origin.x, t1.Origin.y, dst.x, dst.y,
			PT_ADDLINES | PT_ADDTHINGS, 'PTR_ShootTraverse'))
	{
		return false;
	}
	lineend = dst;
	return ShootCheckPlanes(GLevel.PointInSector(dst));
}

//**************************************************************************
//
//  RADIUS ATTACK
//
//**************************************************************************

Actor bombsource;
Actor bombspot;
float bombdamage;

//==========================================================================
//
//  PIT_RadiusAttack
//
//  "bombsource" is the creature that caused the explosion at "bombspot".
//
//==========================================================================

bool PIT_RadiusAttack(Entity Other)
{
	float dist;

	if (!Actor(Other).bShootable)
		return true;

	// Boss spider and cyborg
	// take no damage from concussion.
//	if (Other.Class == Cyberdemon || Other.Class == SpiderMastermind)
//		return true;

	dist = Length(MobjCenter(Other) - MobjCenter(bombspot)) - Other.Radius;

	if (dist < 0.0)
		dist = 0.0;

	if (dist >= bombdamage)
		return true;	// out of range

	if (Actor(Other).CanSee(bombspot))
	{
		// must be in direct path
		Actor(Other).Damage(bombspot, bombsource, ftoi(bombdamage - dist));
	}

	return true;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.36  2004/10/18 06:35:36  dj_jl
//  Implemented many monsters, sigil and some more.
//
//  Revision 1.35  2004/10/13 06:36:38  dj_jl
//  Implemented items also giving quests.
//
//  Revision 1.34  2004/10/12 06:39:08  dj_jl
//  Various improvements.
//
//  Revision 1.33  2004/08/22 19:23:27  dj_jl
//  Moved many functions to player class.
//
//  Revision 1.32  2004/02/16 07:13:26  dj_jl
//  Height check on using a thing
//
//  Revision 1.31  2003/11/12 16:51:33  dj_jl
//  Changed player structure into a class
//
//  Revision 1.30  2003/10/02 18:03:20  dj_jl
//  Fully working conversations.
//
//  Revision 1.29  2002/11/02 08:22:38  dj_jl
//  New style classes.
//
//  Revision 1.28  2002/09/07 16:28:26  dj_jl
//  Added Level class.
//
//  Revision 1.27  2002/08/28 16:36:39  dj_jl
//  Merged MapObject with Entity, some natives, beautification.
//
//  Revision 1.26  2002/07/27 18:08:12  dj_jl
//  Implementing Strife conversations.
//
//  Revision 1.25  2002/07/13 07:56:42  dj_jl
//  Huge work on Strife: splitting, merging, implementing stuff, etc.
//
//  Revision 1.24  2002/03/28 18:15:35  dj_jl
//  Renamed mo in player_t to MO.
//
//  Revision 1.23  2002/03/20 19:07:47  dj_jl
//  Got rid of a lots of legacy, beautification.
//
//  Revision 1.22  2002/03/09 17:57:02  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.21  2002/03/02 17:41:13  dj_jl
//  Renamed Enemy to Target. Beautification.
//
//  Revision 1.20  2002/02/22 18:00:25  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.19  2002/02/14 19:20:59  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.18  2002/02/06 17:28:53  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.17  2002/02/02 19:17:26  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.16  2002/01/28 18:50:20  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.15  2002/01/24 18:19:27  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.14  2002/01/17 18:15:55  dj_jl
//  Renamed all map object classes
//
//  Revision 1.13  2002/01/15 18:27:01  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.12  2002/01/15 08:10:57  dj_jl
//  Added P_CheckRelPosition
//
//  Revision 1.11  2002/01/11 18:19:42  dj_jl
//  Started to use names in progs
//
//  Revision 1.10  2002/01/07 12:27:42  dj_jl
//  Changed copyright year
//
//  Revision 1.9  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.8  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.7  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.6  2001/09/25 17:12:09  dj_jl
//  Switched to Hexen map format, special thinker classes
//
//  Revision 1.5  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.4  2001/08/31 17:17:23  dj_jl
//  Removed vector macros
//  
//  Revision 1.3  2001/08/30 17:33:18  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:53  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
