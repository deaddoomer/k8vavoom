//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

#define USE_GWND_AMMO_1	1
#define USE_GWND_AMMO_2 1
#define USE_CBOW_AMMO_1 1
#define USE_CBOW_AMMO_2 1
#define USE_BLSR_AMMO_1 1
#define USE_BLSR_AMMO_2 5
#define USE_SKRD_AMMO_1 1
#define USE_SKRD_AMMO_2 5
#define USE_PHRD_AMMO_1 1
#define USE_PHRD_AMMO_2 1
#define USE_MACE_AMMO_1 1
#define USE_MACE_AMMO_2 5

#define MAX_MACE_SPOTS	8

int WeaponAmmoUsePL1[NUMWEAPONS] = {
	0,	// staff
	USE_GWND_AMMO_1,	// gold wand
	USE_CBOW_AMMO_1,	// crossbow
	USE_BLSR_AMMO_1,	// blaster
	USE_SKRD_AMMO_1,	// skull rod
	USE_PHRD_AMMO_1,	// phoenix rod
	USE_MACE_AMMO_1,	// mace
	0,	// gauntlets
	0	// beak
};

int WeaponAmmoUsePL2[NUMWEAPONS] = {
	0,	// staff
	USE_GWND_AMMO_2,	// gold wand
	USE_CBOW_AMMO_2,	// crossbow
	USE_BLSR_AMMO_2,	// blaster
	USE_SKRD_AMMO_2,	// skull rod
	USE_PHRD_AMMO_2,	// phoenix rod
	USE_MACE_AMMO_2,	// mace
	0,	// gauntlets
	0	// beak
};

int MaceSpotCount;
float MaceSpot_x[MAX_MACE_SPOTS];
float MaceSpot_y[MAX_MACE_SPOTS];

//****************************************************************************
//
//  WEAPON UTILITES
//
//****************************************************************************

//==========================================================================
//
//	SetWeapon
//
//==========================================================================

void SetWeapon(player_t *player, int NewWeapon)
{
	player->ReadyWeapon = NewWeapon;
	player->PendingWeapon = wp_nochange;
	weaponinfo[NewWeapon] (player);
	player->PSpriteSY = PSpriteSY[NewWeapon];
}

//===========================================================================
//
//  OpenWeapons
//
//  Called at level load before things are loaded.
//
//===========================================================================

void OpenWeapons(void)
{
	MaceSpotCount = 0;
}

//===========================================================================
//
//  AddMaceSpot
//
//===========================================================================

void AddMaceSpot(float x, float y)
{
	if (MaceSpotCount == MAX_MACE_SPOTS)
	{
		Error("Too many mace spots.");
	}
	MaceSpot_x[MaceSpotCount] = x;
	MaceSpot_y[MaceSpotCount] = y;
	MaceSpotCount++;
}

//===========================================================================
//
//  RepositionMace
//
//  Chooses the next spot to place the mace.
//
//===========================================================================

void RepositionMace(mobj_t * mo)
{
	int spot;

	spot = P_Random() % MaceSpotCount;
	P_UnsetThingPosition(*mo);
	mo->Origin.x = MaceSpot_x[spot];
	mo->Origin.y = MaceSpot_y[spot];
	P_SetThingPosition(*mo);
	mo->Origin.z = mo->FloorZ;
}

//===========================================================================
//
//  CloseWeapons
//
//  Called at level load after things are loaded.
//
//===========================================================================

void CloseWeapons(void)
{
	int spot;

	if (!MaceSpotCount)
	{
		// No maces placed
		return;
	}
	if (!deathmatch && P_Random() < 64)
	{
		// Sometimes doesn't show up if not in deathmatch
		return;
	}
	spot = P_Random() % MaceSpotCount;
	P_SpawnMobj(MaceSpot_x[spot], MaceSpot_y[spot], ONFLOORZ, ItemWeaponMace);
}

//===========================================================================
//
//  SetPsprite
//
//===========================================================================

void SetPsprite(player_t * player, int position, int stnum)
{
	player->ViewEnts[position].SetState(stnum);
}

//===========================================================================
//
//  BringUpWeapon
//
//  Starts bringing the pending weapon up from the bottom of the screen.
//
//===========================================================================

void BringUpWeapon(player_t * player)
{
	SetWeapon(player, player->ReadyWeapon);
	if (player->ReadyWeapon == wp_gauntlets)
	{
		player->mo->PlaySound('GauntletActive', CHAN_WEAPON);
	}
	player->ViewEnts[ps_weapon].SY = WEAPONBOTTOM;
	if (player->Powers[pw_weaponlevel2])
	{
		SetPsprite(player, ps_weapon, player->w2_UpState);
	}
	else
	{
		SetPsprite(player, ps_weapon, player->w_UpState);
	}
}

//===========================================================================
//
//  DropWeapon
//
//  The player died, so put the weapon away.
//
//===========================================================================

void DropWeapon(player_t * player)
{
	if (player->Powers[pw_weaponlevel2])
	{
		SetPsprite(player, ps_weapon, player->w2_DownState);
	}
	else
	{
		SetPsprite(player, ps_weapon, player->w_DownState);
	}
}

//===========================================================================
//
//  SetupPsprites
//
//  Called at start of level for each player
//
//===========================================================================

void SetupPsprites(player_t * player)
{
	int i;

	// Remove all  ViewEnts
	for (i = 0; i < NUMPSPRITES; i++)
	{
		player->ViewEnts[i].StateNum = 0;
	}
	// Spawn the ready weapon
	BringUpWeapon(player);
}

//===========================================================================
//
//  MovePsprites
//
//  Called every tic by player thinking routine
//
//===========================================================================

void MovePsprites(player_t * player)
{
	int i;
	ViewEntity e;

	for (i = 0; i < NUMPSPRITES; i++)
	{
		e = player->ViewEnts[i];
		if (e.StateNum)	// a null state means not active
		{
			// drop tic count and possibly change state
			if (e.StateTime != -1.0)	// a -1 tic count never changes
			{
				e.StateTime -= frametime;
				if (e.StateTime <= 0.0)
				{
					e.StateTime = 0.0;
					SetPsprite(player, i, e.NextState);
				}
			}
		}
	}
	player->ViewEnts[ps_flash].SX = player->ViewEnts[ps_weapon].SX;
	player->ViewEnts[ps_flash].SY = player->ViewEnts[ps_weapon].SY;
}

//===========================================================================
//
//  CheckAmmo
//
//  Returns true if there is enough ammo to shoot.  If not, selects the
// next weapon to use.
//
//===========================================================================

boolean CheckAmmo(player_t * player)
{
	int ammo;
	int *ammoUse;
	int count;

	ammo = player->w_Ammo;
	if (player->Powers[pw_weaponlevel2] && !deathmatch)
	{
		ammoUse = &WeaponAmmoUsePL2[0];
	}
	else
	{
		ammoUse = &WeaponAmmoUsePL1[0];
	}
	count = ammoUse[player->ReadyWeapon];
	if (ammo == am_noammo || player->Ammo[ammo] >= count)
	{
		return true;
	}
	// out of ammo, pick a weapon to change to
	do
	{
		if (player->WeaponOwned[wp_skullrod]
			&& player->Ammo[am_skullrod] > ammoUse[wp_skullrod])
		{
			player->PendingWeapon = wp_skullrod;
		}
		else if (player->WeaponOwned[wp_blaster]
			&& player->Ammo[am_blaster] > ammoUse[wp_blaster])
		{
			player->PendingWeapon = wp_blaster;
		}
		else if (player->WeaponOwned[wp_crossbow]
			&& player->Ammo[am_crossbow] > ammoUse[wp_crossbow])
		{
			player->PendingWeapon = wp_crossbow;
		}
		else if (player->WeaponOwned[wp_mace]
			&& player->Ammo[am_mace] > ammoUse[wp_mace])
		{
			player->PendingWeapon = wp_mace;
		}
		else if (player->Ammo[am_goldwand] > ammoUse[wp_goldwand])
		{
			player->PendingWeapon = wp_goldwand;
		}
		else if (player->WeaponOwned[wp_gauntlets])
		{
			player->PendingWeapon = wp_gauntlets;
		}
		else if (player->WeaponOwned[wp_phoenixrod]
			&& player->Ammo[am_phoenixrod] > ammoUse[wp_phoenixrod])
		{
			player->PendingWeapon = wp_phoenixrod;
		}
		else
		{
			player->PendingWeapon = wp_staff;
		}
	}
	while (player->PendingWeapon == wp_nochange);
	if (player->Powers[pw_weaponlevel2])
	{
		SetPsprite(player, ps_weapon, player->w2_DownState);
	}
	else
	{
		SetPsprite(player, ps_weapon, player->w_DownState);
	}
	return false;
}

//===========================================================================
//
//  BulletSlope
//
//  Sets a slope so a near miss is at aproximately the height of the
// intended target
//
//===========================================================================

void BulletSlope(mobj_t * mo, TAVec * angles)
{
	//
	// see which target is to be aimed at
	//
	angles->pitch = mo->Angles.pitch;
	angles->yaw = mo->Angles.yaw;
	angles->roll = mo->Angles.roll;

	AimLineAttack(mo, angles, 16.0 * 64.0);
	if (!linetarget)
	{
		angles->yaw = AngleMod360(angles->yaw + 45.0 / 8.0);
		AimLineAttack(mo, angles, 16.0 * 64.0);
		if (!linetarget)
		{
			angles->yaw = AngleMod360(angles->yaw - 45.0 / 4.0);
			AimLineAttack(mo, angles, 16.0 * 64.0);
			if (!linetarget)
			{
				angles->yaw = AngleMod360(angles->yaw + 45.0 / 8.0);
			}
		}
	}
}

//===========================================================================
//
//  FireWeapon
//
//===========================================================================

void FireWeapon(player_t * player)
{
	int attackState;

	if (!CheckAmmo(player))
	{
		return;
	}
	player->mo->SetState(S_PLAY_ATK2);
	if (player->Powers[pw_weaponlevel2])
	{
		attackState = player->Refire ? player->w2_HoldAttackState
			: player->w2_AttackState;
	}
	else
	{
		attackState = player->Refire ? player->w_HoldAttackState
			: player->w_AttackState;
	}
	SetPsprite(player, ps_weapon, attackState);
	P_NoiseAlert(player->mo, player->mo);
	if (player->ReadyWeapon == wp_gauntlets && !player->Refire)
	{
		// Play the sound for the initial gauntlet attack
		player->mo->PlaySound('GauntletUse', CHAN_WEAPON);
	}
}

//===========================================================================
//
//  ActivateBeak
//
//===========================================================================

void ActivateBeak(player_t * player)
{
	SetWeapon(player, wp_beak);
	player->ViewEnts[ps_weapon].SY = WEAPONTOP;
	SetPsprite(player, ps_weapon, S_BEAKREADY);
}

//===========================================================================
//
//  PostChickenWeapon
//
//===========================================================================

void PostChickenWeapon(player_t * player, int weapon)
{
	if (weapon == wp_beak)
	{	// Should never happen
		weapon = wp_staff;
	}
	SetWeapon(player, weapon);
	player->ViewEnts[ps_weapon].SY = WEAPONBOTTOM;
	SetPsprite(player, ps_weapon, player->w_UpState);
}

//===========================================================================
//
//  UpdateBeak
//
//===========================================================================

void UpdateBeak(player_t * player, ViewEntity e)
{
	e.SY = WEAPONTOP + itof(player->ChickenPeck) / 2.0;
}

//===========================================================================
//
//  WeaponLevel2Fade
//
//===========================================================================

void WeaponLevel2Fade(player_t * player)
{
	if ((player->ReadyWeapon == wp_phoenixrod) &&
		(player->ViewEnts[ps_weapon].StateNum != S_PHOENIXREADY) &&
		(player->ViewEnts[ps_weapon].StateNum != S_PHOENIXUP))
	{
		SetPsprite(player, ps_weapon, S_PHOENIXREADY);
		player->Ammo[am_phoenixrod] -= USE_PHRD_AMMO_2;
		player->Refire = 0;
	}
	else if ((player->ReadyWeapon == wp_gauntlets)
		|| (player->ReadyWeapon == wp_staff))
	{
		player->PendingWeapon = player->ReadyWeapon;
	}
}

//****************************************************************************
//
//  WEAPON ACTIONS
//
//****************************************************************************

//===========================================================================
//
//  Weapon::A_WeaponReady
//
//  The player can fire the weapon or change to another weapon at this time.
//
//===========================================================================

void Weapon::A_WeaponReady(void)
{
	float angle;

	if (Player->ChickenTics)
	{
		// Change to the chicken beak
		ActivateBeak(Player);
		return;
	}
	// Change player from attack state
	if (Player->mo->StateNum == S_PLAY_ATK1 ||
		Player->mo->StateNum == S_PLAY_ATK2)
	{
		Player->mo->SetState(S_PLAY);
	}
	// Check for staff PL2 active sound
	if ((Player->ReadyWeapon == wp_staff) &&
		(StateNum == S_STAFFREADY2_1) && P_Random() < 128)
	{
		Player->mo->PlaySound('StaffActive', CHAN_WEAPON);
	}
	// Put the weapon away if the player has a pending weapon or has
	// died.
	if (Player->PendingWeapon != wp_nochange || !Player->Health)
	{
		if (Player->Powers[pw_weaponlevel2])
		{
			SetPsprite(Player, ps_weapon, Player->w2_DownState);
		}
		else
		{
			SetPsprite(Player, ps_weapon, Player->w_DownState);
		}
		return;
	}

	// Check for fire.  The phoenix rod does not auto fire.
	if (Player->Buttons & BT_ATTACK)
	{
		if (!Player->bAttackDown || (Player->ReadyWeapon != wp_phoenixrod))
		{
			Player->bAttackDown = true;
			FireWeapon(Player);
			return;
		}
	}
	else
	{
		Player->bAttackDown = false;
	}

	// Bob the weapon based on movement speed.
	angle = AngleMod360(180.0 * level->time);
	SX = 1.0 + Player->Bob * cos(angle);
	if (angle >= 180.0)
	{
		angle -= 180.0;
	}
	SY = WEAPONTOP + Player->Bob * sin(angle);
}

//===========================================================================
//
//  Weapon::A_BeakReady
//
//===========================================================================

void Weapon::A_BeakReady(void)
{
	if (Player->Buttons & BT_ATTACK)
	{
		// Chicken beak attack
		Player->bAttackDown = true;
		Player->mo->SetState(S_CHICPLAY_ATK1);
		if (Player->Powers[pw_weaponlevel2])
		{
			SetPsprite(Player, ps_weapon, S_BEAKATK2_1);
		}
		else
		{
			SetPsprite(Player, ps_weapon, S_BEAKATK1_1);
		}
		P_NoiseAlert(Player->mo, Player->mo);
	}
	else
	{
		if (Player->mo->StateNum == S_CHICPLAY_ATK1)
		{	// Take out of attack state
			Player->mo->SetState(S_CHICPLAY);
		}
		Player->bAttackDown = false;
	}
}

//===========================================================================
//
//  Weapon::A_Lower
//
//===========================================================================

void Weapon::A_Lower(void)
{
	if (Player->ChickenTics)
	{
		SY = WEAPONBOTTOM;
	}
	else
	{
		SY += LOWERSPEED;
	}
	if (SY < WEAPONBOTTOM)
	{
		// Not lowered all the way yet
		return;
	}
	if (Player->PlayerState == PST_DEAD)
	{
		// Player is dead, so don't bring up a pending weapon
		SY = WEAPONBOTTOM;
		return;
	}
	if (!Player->Health)
	{
		// Player is dead, so keep the weapon off screen
		SetPsprite(Player, ps_weapon, S_NULL);
		return;
	}
	Player->ReadyWeapon = Player->PendingWeapon;
	BringUpWeapon(Player);
}

//===========================================================================
//
//  Weapon::A_Raise
//
//===========================================================================

void Weapon::A_Raise(void)
{
	SY -= RAISESPEED;
	if (SY > WEAPONTOP)
	{
		// Not raised all the way yet
		return;
	}
	SY = WEAPONTOP;
	if (Player->Powers[pw_weaponlevel2])
	{
		SetPsprite(Player, ps_weapon, Player->w2_ReadyState);
	}
	else
	{
		SetPsprite(Player, ps_weapon, Player->w_ReadyState);
	}
}

//===========================================================================
//
//  Weapon::A_BeakRaise
//
//===========================================================================

void Weapon::A_BeakRaise(void)
{
	SY = WEAPONTOP;
	SetPsprite(Player, ps_weapon, Player->w_ReadyState);
}

//===========================================================================
//
//  Weapon::A_ReFire
//
//  The player can re fire the weapon without lowering it entirely.
//
//===========================================================================

void Weapon::A_ReFire(void)
{
	if ((Player->Buttons & BT_ATTACK)
		&& Player->PendingWeapon == wp_nochange && Player->Health)
	{
		Player->Refire++;
		FireWeapon(Player);
	}
	else
	{
		Player->Refire = 0;
		CheckAmmo(Player);
	}
}

//===========================================================================
//
//  Weapon::A_Light0
//
//===========================================================================

void Weapon::A_Light0(void)
{
	Player->ExtraLight = 0;
}

//****************************************************************************
//
//  WEAPON ATTACKS
//
//****************************************************************************

//===========================================================================
//
//  Weapon::A_StaffAttackPL1
//
//===========================================================================

void Weapon::A_StaffAttackPL1(void)
{
	TAVec angles;
	int damage;
	TVec vforward;

	damage = 5 + (P_Random() & 15);
	avcpy(Player->mo->Angles, angles);
	angles.yaw = AngleMod360(angles.yaw +
		(Random() - Random()) * 45.0 / 8.0);
	AimLineAttack(Player->mo, &angles, MELEERANGE);
	AngleVector(&angles, &vforward);
	PuffType = StaffPuff;
	LineAttack(Player->mo, &vforward, MELEERANGE, damage);
	if (linetarget)
	{
		// turn to face target
		Player->mo->Angles.yaw =
			atan2(linetarget->Origin.y - Player->mo->Origin.y,
			linetarget->Origin.x - Player->mo->Origin.x);
	}
}

//===========================================================================
//
//  Weapon::A_StaffAttackPL2
//
//===========================================================================

void Weapon::A_StaffAttackPL2(void)
{
	TAVec angles;
	int damage;
	TVec vforward;

	// P_inter.c:DamageMobj() handles target momentums
	damage = 18 + (P_Random() & 63);

	avcpy(Player->mo->Angles, angles);
	angles.yaw = AngleMod360(angles.yaw +
		(Random() - Random()) * 45.0 / 8.0);
	AimLineAttack(Player->mo, &angles, MELEERANGE);
	AngleVector(&angles, &vforward);
	PuffType = StaffPuff2;
	LineAttack(Player->mo, &vforward, MELEERANGE, damage);
	if (linetarget)
	{
		// turn to face target
		Player->mo->Angles.yaw =
			atan2(linetarget->Origin.y - Player->mo->Origin.y,
			linetarget->Origin.x - Player->mo->Origin.x);
		Player->bFixAngle = true;
	}
}

//===========================================================================
//
//  Weapon::A_GauntletAttack
//
//===========================================================================

void Weapon::A_GauntletAttack(void)
{
	float angle;
	int damage;
	float slope;
	int randVal;
	float dist;
	TAVec angles;
	TVec vforward;

	SX = Random() * 4.0 - 2.0;
	SY = WEAPONTOP + Random() * 4.0;
	angles = Player->mo->Angles;
	if (Player->Powers[pw_weaponlevel2])
	{
		damage = HITDICE(2);
		dist = 4.0 * MELEERANGE;
		angles.yaw = AngleMod360(angles.yaw +
			(Random() - Random()) * 45.0 / 16.0);
		PuffType = GauntletPuff2;
	}
	else
	{
		damage = HITDICE(2);
		dist = MELEERANGE + 0.00001;
		angles.yaw = AngleMod360(angles.yaw +
			(Random() - Random()) * 45.0 / 8.0);
		PuffType = GauntletPuff1;
	}
	AimLineAttack(Player->mo, &angles, dist);
	AngleVector(&angles, &vforward);
	LineAttack(Player->mo, &vforward, dist, damage);
	if (!linetarget)
	{
		if (P_Random() > 64)
		{
			Player->ExtraLight = !Player->ExtraLight;
		}
		Player->mo->PlaySound('GauntletFull', CHAN_WEAPON);
		return;
	}
	randVal = P_Random();
	if (randVal < 64)
	{
		Player->ExtraLight = 0;
	}
	else if (randVal < 160)
	{
		Player->ExtraLight = 1;
	}
	else
	{
		Player->ExtraLight = 2;
	}
	if (Player->Powers[pw_weaponlevel2])
	{
		Player->mo->GiveBody(damage >> 1);
		Player->mo->PlaySound('GauntletHit2', CHAN_WEAPON);
	}
	else
	{
		Player->mo->PlaySound('GauntletHit', CHAN_WEAPON);
	}
	// turn to face target
	angle = atan2(linetarget->Origin.y - Player->mo->Origin.y,
		linetarget->Origin.x - Player->mo->Origin.x);
	if (AngleMod360(angle - Player->mo->Angles.yaw) > 180.0)
	{
		if (AngleMod360(angle - Player->mo->Angles.yaw) < 360.0 - 90.0 / 20.0)
			Player->mo->Angles.yaw = AngleMod360(angle + 90.0 / 21.0);
		else
			Player->mo->Angles.yaw = AngleMod360(Player->mo->Angles.yaw - 90.0 / 20.0);
	}
	else
	{
		if (AngleMod360(angle - Player->mo->Angles.yaw) > 90.0 / 20.0)
			Player->mo->Angles.yaw = AngleMod360(angle - 90.0 / 21.0);
		else
			Player->mo->Angles.yaw = AngleMod360(Player->mo->Angles.yaw + 90.0 / 20.0);
	}
	Player->mo->bJustAttacked = true;
}

//===========================================================================
//
//  Weapon::A_FireGoldWandPL1
//
//===========================================================================

void Weapon::A_FireGoldWandPL1(void)
{
	mobj_t *mo;
	int damage;
	TAVec angles;
	TVec vforward;

	mo = Player->mo;
	Player->Ammo[am_goldwand] -= USE_GWND_AMMO_1;
	damage = 7 + (P_Random() & 7);
	BulletSlope(mo, &angles);
	if (Player->Refire)
	{
		angles.yaw = AngleMod360(angles.yaw +
			(Random() - Random()) * 45.0 / 8.0);
	}
	AngleVector(&angles, &vforward);
	PuffType = GoldWandPuff1;
	LineAttack(mo, &vforward, MISSILERANGE, damage);
	Player->mo->PlaySound('GoldWandFire', CHAN_WEAPON);
}

//===========================================================================
//
//  Weapon::A_FireGoldWandPL2
//
//===========================================================================

void Weapon::A_FireGoldWandPL2(void)
{
	int i;
	mobj_t *mo;
	int damage;
	float momz;
	TAVec angles;
	TVec vforward;

	mo = Player->mo;
	Player->Ammo[am_goldwand] -=
		deathmatch ? USE_GWND_AMMO_1 : USE_GWND_AMMO_2;
	PuffType = GoldWandPuff2;
	BulletSlope(mo, &angles);
	SpawnMissileAngles(mo, GoldWandMissile2,
		AngleMod360(angles.yaw - (45.0 / 8.0)), angles.pitch);
	SpawnMissileAngles(mo, GoldWandMissile2,
		AngleMod360(angles.yaw + (45.0 / 8.0)), angles.pitch);
	angles.yaw = AngleMod360(angles.yaw - (45.0 / 8.0));
	for (i = 0; i < 5; i++)
	{
		damage = 1 + (P_Random() & 7);
		AngleVector(&angles, &vforward);
		LineAttack(mo, &vforward, MISSILERANGE, damage);
		angles.yaw = AngleMod360(angles.yaw + (((45.0 / 8.0) * 2.0) / 4.0));
	}
	Player->mo->PlaySound('GoldWandFire', CHAN_WEAPON);
}

//===========================================================================
//
//  Weapon::A_FireCrossbowPL1
//
//===========================================================================

void Weapon::A_FireCrossbowPL1(void)
{
	mobj_t *pmo;

	pmo = Player->mo;
	Player->Ammo[am_crossbow] -= USE_CBOW_AMMO_1;
	SpawnPlayerMissile(pmo, CrossbowFX1);
	SpawnPlayerMissileAngle(pmo, CrossbowFX3,
		AngleMod360(pmo->Angles.yaw - (45.0 / 10.0)));
	SpawnPlayerMissileAngle(pmo, CrossbowFX3,
		AngleMod360(pmo->Angles.yaw + (45.0 / 10.0)));
}

//===========================================================================
//
//  Weapon::A_FireCrossbowPL2
//
//===========================================================================

void Weapon::A_FireCrossbowPL2(void)
{
	mobj_t *pmo;

	pmo = Player->mo;
	Player->Ammo[am_crossbow] -=
		deathmatch ? USE_CBOW_AMMO_1 : USE_CBOW_AMMO_2;
	SpawnPlayerMissile(pmo, CrossbowFX2);
	SpawnPlayerMissileAngle(pmo, CrossbowFX2,
		AngleMod360(pmo->Angles.yaw - (45.0 / 10.0)));
	SpawnPlayerMissileAngle(pmo, CrossbowFX2,
		AngleMod360(pmo->Angles.yaw + (45.0 / 10.0)));
	SpawnPlayerMissileAngle(pmo, CrossbowFX3,
		AngleMod360(pmo->Angles.yaw - (45.0 / 5.0)));
	SpawnPlayerMissileAngle(pmo, CrossbowFX3,
		AngleMod360(pmo->Angles.yaw + (45.0 / 5.0)));
}

//===========================================================================
//
//  Weapon::A_FireBlasterPL1
//
//===========================================================================

void Weapon::A_FireBlasterPL1(void)
{
	mobj_t *mo;
	int damage;
	float bulletslope;
	TAVec angles;
	TVec vforward;

	mo = Player->mo;
	mo->PlaySound('GoldWandFire', CHAN_WEAPON);
	Player->Ammo[am_blaster] -= USE_BLSR_AMMO_1;
	BulletSlope(mo, &angles);
	damage = HITDICE(4);
	if (Player->Refire)
	{
		angles.yaw = AngleMod360(angles.yaw +
			(Random() - Random()) * 45.0 / 8.0);
	}
	PuffType = BlasterPuff1;
	AngleVector(&angles, &vforward);
	LineAttack(mo, &vforward, MISSILERANGE, damage);
	Player->mo->PlaySound('BlasterFire', CHAN_WEAPON);
}

//===========================================================================
//
//  Weapon::A_FireBlasterPL2
//
//===========================================================================

void Weapon::A_FireBlasterPL2(void)
{
	mobj_t *mo;

	Player->Ammo[am_blaster] -=
		deathmatch ? USE_BLSR_AMMO_1 : USE_BLSR_AMMO_2;
	mo = SpawnPlayerMissile(Player->mo, BlasterFX1);
	if (mo)
	{
		mo->bBlaster = true;
	}
	Player->mo->PlaySound('BlasterFire', CHAN_WEAPON);
}

//===========================================================================
//
//  Weapon::A_FireSkullRodPL1
//
//===========================================================================

void Weapon::A_FireSkullRodPL1(void)
{
	mobj_t *mo;

	if (Player->Ammo[am_skullrod] < USE_SKRD_AMMO_1)
	{
		return;
	}
	Player->Ammo[am_skullrod] -= USE_SKRD_AMMO_1;
	mo = SpawnPlayerMissile(Player->mo, HornRodMissile1);
	// Randomize the first frame
	if (mo && P_Random() > 128)
	{
		mo->SetState(S_HRODFX1_2);
	}
}

//===========================================================================
//
//  Weapon::A_FireSkullRodPL2
//
//  The special2 field holds the player number that shot the rain missile.
// The specialmobj1 field is used for the seeking routines, special1 as a
// counter for the sound looping.
//
//===========================================================================

void Weapon::A_FireSkullRodPL2(void)
{
	Player->Ammo[am_skullrod] -=
		deathmatch ? USE_SKRD_AMMO_1 : USE_SKRD_AMMO_2;
	SpawnPlayerMissile(Player->mo, HornRodMissile2);
	// Use MissileMobj instead of the return value from
	// SpawnPlayerMissile because we need to give info to the mobj
	// even if it exploded immediately.
	if (netgame)
	{
		// Multi-player game
		MissileMobj->Special2 = P_GetPlayerNum(Player);
	}
	else
	{
		// Always use red missiles in single player games
		MissileMobj->Special2 = 2;
	}
	if (linetarget)
	{
		MissileMobj->SpecialMobj1 = linetarget;
	}
	MissileMobj->PlaySound('SkullRodFire2', CHAN_WEAPON);
}

//===========================================================================
//
//  Weapon::A_FirePhoenixPL1
//
//===========================================================================

void Weapon::A_FirePhoenixPL1(void)
{
	TVec vforward;

	Player->Ammo[am_phoenixrod] -= USE_PHRD_AMMO_1;
	SpawnPlayerMissile(Player->mo, PhoenixFX1);
	AngleVector(&Player->mo->Angles, &vforward);
	Player->mo->Velocity -= vforward * 140.0;
}

//===========================================================================
//
//  Weapon::A_InitPhoenixPL2
//
//===========================================================================

void Weapon::A_InitPhoenixPL2(void)
{
	Player->FlameCount = ftoi(FLAME_THROWER_TIME * 35.0);
}

//===========================================================================
//
//  Weapon::A_FirePhoenixPL2
//
//  Flame thrower effect.
//
//===========================================================================

void Weapon::A_FirePhoenixPL2(void)
{
	mobj_t *mo;
	mobj_t *pmo;
	TVec dir;
	float x, y, z;

	if (--Player->FlameCount == 0)
	{
		// Out of flame
		SetPsprite(Player, ps_weapon, S_PHOENIXATK2_4);
		Player->Refire = 0;
		return;
	}
	pmo = Player->mo;
	x = pmo->Origin.x + (Random() - Random()) * 2.0;
	y = pmo->Origin.y + (Random() - Random()) * 2.0;
	z = pmo->Origin.z + 26.0 - sin(Player->mo->Angles.pitch);
	z -= pmo->FloorClip;
	mo = P_SpawnMobj(x, y, z, PhoenixFX2);
	mo->Owner = *pmo;
	mo->Angles.yaw = pmo->Angles.yaw;
	mo->Angles.pitch = pmo->Angles.pitch;
	AngleVector(&mo->Angles, &dir);
	mo->Velocity = pmo->Velocity + mo->Speed * dir;
	if (!Player->Refire || !(level->tictime % 38))
	{
		Player->mo->PlaySound('PhoenixHit2', CHAN_WEAPON);
	}
	CheckMissileSpawn(mo);
}

//===========================================================================
//
//  Weapon::A_ShutdownPhoenixPL2
//
//===========================================================================

void Weapon::A_ShutdownPhoenixPL2(void)
{
	Player->Ammo[am_phoenixrod] -= USE_PHRD_AMMO_2;
}

//===========================================================================
//
// PROC A_FireMacePL1B
//
//===========================================================================

void A_FireMacePL1B(mobj_t * actor)
{
	player_t *player = actor->Player;
	mobj_t *pmo;
	mobj_t *ball;
	float angle;

	if (player->Ammo[am_mace] < USE_MACE_AMMO_1)
	{
		return;
	}
	player->Ammo[am_mace] -= USE_MACE_AMMO_1;
	pmo = player->mo;
	ball = P_SpawnMobj(pmo->Origin.x, pmo->Origin.y, pmo->Origin.z + 28.0
		- pmo->FloorClip, MaceFX2);
	ball->Velocity.z =
		(2.0 + 173.0 * -tan(player->mo->Angles.pitch) / 32.0) * 35.0;
	angle = pmo->Angles.yaw;
	ball->Owner = *pmo;
	ball->Angles.yaw = angle;
	ball->Origin.z += 173.0 * -tan(player->mo->Angles.pitch) / 16.0;
	ball->Velocity.x = pmo->Velocity.x / 2.0 + ball->Speed * cos(angle);
	ball->Velocity.y = pmo->Velocity.y / 2.0 + ball->Speed * sin(angle);
	ball->PlaySound('MaceFire', CHAN_WEAPON);
	CheckMissileSpawn(ball);
}

//===========================================================================
//
//  Weapon::A_FireMacePL1
//
//===========================================================================

void Weapon::A_FireMacePL1(void)
{
	mobj_t *ball;

	if (P_Random() < 28)
	{
		A_FireMacePL1B(Player->mo);
		return;
	}
	if (Player->Ammo[am_mace] < USE_MACE_AMMO_1)
	{
		return;
	}
	Player->Ammo[am_mace] -= USE_MACE_AMMO_1;
	SX = Random() * 4.0 - 2.0;
	SY = WEAPONTOP + Random() * 4.0;
	ball = SpawnPlayerMissileAngle(Player->mo, MaceFX1,
		AngleMod360(Player->mo->Angles.yaw + (Random() - 0.5) * 45.0 / 4.0));
	if (ball)
	{
		ball->Special1 = 16;	// tics till dropoff
	}
}

//===========================================================================
//
//  Weapon::A_FireMacePL2
//
//===========================================================================

void Weapon::A_FireMacePL2(void)
{
	mobj_t *mo;

	Player->Ammo[am_mace] -= deathmatch ? USE_MACE_AMMO_1 : USE_MACE_AMMO_2;
	mo = SpawnPlayerMissile(Player->mo, MaceFX4);
	if (mo)
	{
		mo->Velocity.x += Player->mo->Velocity.x;
		mo->Velocity.y += Player->mo->Velocity.y;
		mo->Velocity.z =
			(2.0 + 173.0 * -tan(Player->mo->Angles.pitch) / 32.0) * 35.0;
		if (linetarget)
		{
			mo->SpecialMobj1 = linetarget;
		}
	}
	Player->mo->PlaySound('MaceFire', CHAN_WEAPON);
}

//===========================================================================
//
//  Weapon::A_BeakAttackPL1
//
//===========================================================================

void Weapon::A_BeakAttackPL1(void)
{
	int damage;
	TAVec angles;
	TVec vforward;
	name SoundName;

	damage = 1 + (P_Random() & 3);
	avcpy(Player->mo->Angles, angles);
	AimLineAttack(Player->mo, &angles, MELEERANGE);
	PuffType = BeakPuff;
	AngleVector(&angles, &vforward);
	LineAttack(Player->mo, &vforward, MELEERANGE, damage);
	if (linetarget)
	{
		Player->mo->Angles.yaw =
			atan2(linetarget->Origin.y - Player->mo->Origin.y,
			linetarget->Origin.x - Player->mo->Origin.x);
		Player->bFixAngle = true;
	}
	switch (P_Random() % 3)
	{
	case 0:
		SoundName = 'ChickenPeak1';
		break;
	case 1:
		SoundName = 'ChickenPeak2';
		break;
	case 2:
		SoundName = 'ChickenPeak3';
		break;
	}
	Player->mo->PlaySound(SoundName, CHAN_VOICE);
	Player->ChickenPeck = 12;
	StateTime -= Random() * 0.25;
}

//===========================================================================
//
//  Weapon::A_BeakAttackPL2
//
//===========================================================================

void Weapon::A_BeakAttackPL2(void)
{
	int damage;
	TAVec angles;
	TVec vforward;
	name SoundName;

	damage = HITDICE(4);
	avcpy(Player->mo->Angles, angles);
	AimLineAttack(Player->mo, &angles, MELEERANGE);
	PuffType = BeakPuff;
	AngleVector(&angles, &vforward);
	LineAttack(Player->mo, &vforward, MELEERANGE, damage);
	if (linetarget)
	{
		Player->mo->Angles.yaw =
			atan2(linetarget->Origin.y - Player->mo->Origin.y,
			linetarget->Origin.x - Player->mo->Origin.x);
		Player->bFixAngle = true;
	}
	switch (P_Random() % 3)
	{
	case 0:
		SoundName = 'ChickenPeak1';
		break;
	case 1:
		SoundName = 'ChickenPeak2';
		break;
	case 2:
		SoundName = 'ChickenPeak3';
		break;
	}
	Player->mo->PlaySound(SoundName, CHAN_VOICE);
	Player->ChickenPeck = 12;
	StateTime -= Random() * 0.125;
}

//****************************************************************************
//
//  WEAPON PROJECTILE ACTIONS
//
//****************************************************************************

//===========================================================================
//
//  Actor::A_BoltSpark
//
//===========================================================================

void Actor::A_BoltSpark(void)
{
	mobj_t *spark;

	if (P_Random() > 50)
	{
		spark = P_SpawnMobj(Origin.x, Origin.y, Origin.z, CrossbowFX4);
		spark->Origin.x += (Random() - Random()) * 4.0;
		spark->Origin.y += (Random() - Random()) * 4.0;
	}
}

//===========================================================================
//
//  Actor::A_SpawnRippers
//
//===========================================================================

void Actor::A_SpawnRippers(void)
{
	int i;
	float angle;
	mobj_t *ripper;

	for (i = 0; i < 8; i++)
	{
		ripper = P_SpawnMobj(Origin.x, Origin.y, Origin.z, Ripper);
		angle = itof(i) * 45.0;
		ripper->Owner = Owner;
		ripper->Angles.yaw = angle;
		ripper->Velocity.x = ripper->Speed * cos(angle);
		ripper->Velocity.y = ripper->Speed * sin(angle);
		CheckMissileSpawn(ripper);
	}
}

//===========================================================================
//
//  Actor::A_SkullRodPL2Seek
//
//===========================================================================

void Actor::A_SkullRodPL2Seek(void)
{
	P_SeekerMissile(this, 10.0, 30.0);
}

//===========================================================================
//
//  Actor::A_AddPlayerRain
//
//===========================================================================

void Actor::A_AddPlayerRain(void)
{
	int playerNum;
	player_t *player;

	playerNum = netgame ? Special2 : 0;
	player = &players[playerNum];
	if (!player->bActive)
	{
		// Player left the game
		return;
	}
	if (player->Health <= 0)
	{
		// Player is dead
		return;
	}
	if (player->Rain1 && player->Rain2)
	{
		// Terminate an active rain
		if (player->Rain1->Health < player->Rain2->Health)
		{
			if (player->Rain1->Health > 16)
			{
				player->Rain1->Health = 16;
			}
			player->Rain1 = NULL;
		}
		else
		{
			if (player->Rain2->Health > 16)
			{
				player->Rain2->Health = 16;
			}
			player->Rain2 = NULL;
		}
	}
	// Add rain mobj to list
	if (player->Rain1)
	{
		player->Rain2 = this;
	}
	else
	{
		player->Rain1 = this;
	}
}

//===========================================================================
//
//  Actor::A_SkullRodStorm
//
//===========================================================================

void Actor::A_SkullRodStorm(void)
{
	float x;
	float y;
	mobj_t *mo;
	int playerNum;
	player_t *player;
	classid rain_type;

	if (Health-- == 0)
	{
		SetState(S_NULL);
		playerNum = netgame ? Special2 : 0;
		player = &players[playerNum];
		if (!player->bActive)
		{
			// Player left the game
			return;
		}
		if (player->Health <= 0)
		{
			// Player is dead
			return;
		}
		if (player->Rain1 == this)
		{
			player->Rain1 = NULL;
		}
		else if (player->Rain2 == this)
		{
			player->Rain2 = NULL;
		}
		return;
	}
	if (P_Random() < 25)
	{
		// Fudge rain frequency
		return;
	}
	x = Origin.x + Random() * 128.0 - 64.0;
	y = Origin.y + Random() * 128.0 - 64.0;
	switch (Special2)
	{
	case 0: rain_type = RainPlayer1; break;
	case 1: rain_type = RainPlayer2; break;
	case 2: rain_type = RainPlayer3; break;
	case 3: rain_type = RainPlayer4; break;
	}
	mo = P_SpawnMobj(x, y, ONCEILINGZ, rain_type);
	mo->Owner = Owner;
	mo->Velocity.x = 0.00001;	// Force collision detection
	mo->Velocity.z = -mo->Speed;
	mo->Special2 = Special2;	// Transfer player number
	CheckMissileSpawn(mo);
	if (!(Special1 & 31))
	{
		PlaySound('SkullRodRain', CHAN_VOICE);
	}
	Special1++;
}

//===========================================================================
//
//  Actor::A_RainImpact
//
//===========================================================================

void Actor::A_RainImpact(void)
{
	if (Origin.z > FloorZ)
	{
		SetState(S_RAINAIRXPLR1_1 + Special2);
	}
	else if (P_Random() < 40)
	{
		HitFloorEffect();
	}
}

//===========================================================================
//
//  Actor::A_HideInCeiling
//
//===========================================================================

void Actor::A_HideInCeiling(void)
{
	Origin.z = CeilingZ + 4.0;
}

//===========================================================================
//
//  Actor::A_PhoenixPuff
//
//===========================================================================

void Actor::A_PhoenixPuff(void)
{
	mobj_t *puff;
	float angle;

	P_SeekerMissile(this, 5.0, 10.0);
	puff = P_SpawnMobj(Origin.x, Origin.y, Origin.z, PhoenixPuff);
	angle = AngleMod360(Angles.yaw + 90.0);
	puff->Velocity.x = 1.3 * cos(angle) * 35.0;
	puff->Velocity.y = 1.3 * sin(angle) * 35.0;
	puff->Velocity.z = 0.0;
	puff = P_SpawnMobj(Origin.x, Origin.y, Origin.z, PhoenixPuff);
	angle = AngleMod360(Angles.yaw - 90.0);
	puff->Velocity.x = 1.3 * cos(angle) * 35.0;
	puff->Velocity.y = 1.3 * sin(angle) * 35.0;
	puff->Velocity.z = 0.0;
}

//===========================================================================
//
//  Actor::A_FlameEnd
//
//===========================================================================

void Actor::A_FlameEnd(void)
{
	Velocity.z += 1.5 * 35.0;
}

//===========================================================================
//
//  Actor::A_FloatPuff
//
//===========================================================================

void Actor::A_FloatPuff(void)
{
	Velocity.z += 1.8 * 35.0;
}

//===========================================================================
//
//  Actor::A_MacePL1Check
//
//===========================================================================

void Actor::A_MacePL1Check(void)
{
	float angle;

	if (Special1 == 0)
	{
		return;
	}
	Special1 -= 4;
	if (Special1 > 0)
	{
		return;
	}
	Special1 = 0;
	bLowGravity = true;
	angle = Angles.yaw;
	Velocity.x = 7.0 * cos(angle) * 35.0;
	Velocity.y = 7.0 * sin(angle) * 35.0;
	Velocity.z -= Velocity.z / 2.0;
}

//===========================================================================
//
//  Actor::A_MaceBallImpact
//
//===========================================================================

void Actor::A_MaceBallImpact(void)
{
	if ((Origin.z <= FloorZ) && (HitFloorEffect() != FLOOR_SOLID))
	{
		// Landed in some sort of liquid
		P_RemoveMobj(this);
		return;
	}
	if ((Health != MAGIC_JUNK) && (Origin.z <= FloorZ) && Velocity.z)
	{
		// Bounce
		Health = MAGIC_JUNK;
		Velocity.z = Velocity.z * 192.0 / 256.0;
		bFloorBounce = false;
		SetState(SpawnState);
		PlaySound('Bounce', CHAN_VOICE);
	}
	else
	{
		// Explode
		bNoGravity = true;
		bLowGravity = false;
		PlaySound('MaceHit', CHAN_VOICE);
	}
}

//===========================================================================
//
//  Actor::A_MaceBallImpact2
//
//===========================================================================

void Actor::A_MaceBallImpact2(void)
{
	mobj_t *tiny;
	float angle;

	if ((Origin.z <= FloorZ) && (HitFloorEffect() != FLOOR_SOLID))
	{
		// Landed in some sort of liquid
		P_RemoveMobj(this);
		return;
	}
	if ((Origin.z != FloorZ) || (Velocity.z < 2.0 * 35.0))
	{
		// Explode
		Velocity = vector(0.0, 0.0, 0.0);
		bNoGravity = true;
		bLowGravity = false;
		bFloorBounce = false;
	}
	else
	{
		// Bounce
		Velocity.z = Velocity.z * 192.0 / 256.0;
		SetState(SpawnState);

		tiny = P_SpawnMobj(Origin.x, Origin.y, Origin.z, MaceFX3);
		angle = AngleMod360(Angles.yaw + 90.0);
		tiny->Owner = Owner;
		tiny->Angles.yaw = angle;
		tiny->Velocity.x =
			Velocity.x / 2.0 + (Velocity.z - 35.0) * cos(angle);
		tiny->Velocity.y =
			Velocity.y / 2.0 + (Velocity.z - 35.0) * sin(angle);
		tiny->Velocity.z = Velocity.z;
		CheckMissileSpawn(tiny);

		tiny = P_SpawnMobj(Origin.x, Origin.y, Origin.z, MaceFX3);
		angle = AngleMod360(Angles.yaw - 90.0);
		tiny->Owner = Owner;
		tiny->Angles.yaw = angle;
		tiny->Velocity.x =
			Velocity.x / 2.0 + (Velocity.z - 35.0) * cos(angle);
		tiny->Velocity.y =
			Velocity.y / 2.0 + (Velocity.z - 35.0) * sin(angle);
		tiny->Velocity.z = Velocity.z;
		CheckMissileSpawn(tiny);
	}
}

//===========================================================================
//
//  Actor::A_DeathBallImpact
//
//===========================================================================

void Actor::A_DeathBallImpact(void)
{
	int i;
	mobj_t *targ;
	float angle;
	int newAngle;
	TAVec angles;

	if ((Origin.z <= FloorZ) && (HitFloorEffect() != FLOOR_SOLID))
	{
		// Landed in some sort of liquid
		P_RemoveMobj(this);
		return;
	}
	if ((Origin.z <= FloorZ) && Velocity.z)
	{
		// Bounce
		newAngle = false;
		targ = SpecialMobj1;
		if (targ)
		{
			if (!targ->bShootable)
			{
				// Target died
				SpecialMobj1 = NULL;
			}
			else
			{
				// Seek
				angle = atan2(targ->Origin.y - Origin.y,
					targ->Origin.x - Origin.x);
				newAngle = true;
			}
		}
		else
		{
			// Find new target
			angles.pitch = 0.0;
			angles.yaw = 0.0;
			angles.roll = 0.0;
			for (i = 0; i < 16; i++)
			{
				AimLineAttack(this, &angles, 10.0 * 64.0);
				if (linetarget && Owner != *linetarget)
				{
					SpecialMobj1 = linetarget;
					angle = atan2(linetarget->Origin.y - Origin.y,
						linetarget->Origin.x - Origin.x);
					newAngle = true;
					break;
				}
				angles.yaw = AngleMod360(angles.yaw + 45.0 / 2.0);
			}
		}
		if (newAngle)
		{
			Angles.yaw = angle;
			Velocity.x = Speed * cos(angle);
			Velocity.y = Speed * sin(angle);
		}
		SetState(SpawnState);
		PlaySound('PlatformStop', CHAN_VOICE);
	}
	else
	{	// Explode
		bNoGravity = true;
		bLowGravity = false;
		PlaySound('PhoenixHit', CHAN_VOICE);
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.20  2002/02/26 17:49:48  dj_jl
//  no message
//
//  Revision 1.19  2002/02/22 18:00:19  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.18  2002/02/14 19:20:58  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.17  2002/02/06 17:28:52  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.16  2002/01/28 18:50:18  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.15  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.14  2002/01/24 18:19:26  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.13  2002/01/17 18:15:53  dj_jl
//  Renamed all map object classes
//
//  Revision 1.12  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.11  2002/01/11 18:19:41  dj_jl
//  Started to use names in progs
//
//  Revision 1.10  2002/01/07 12:23:18  dj_jl
//  Changed copyright year
//
//  Revision 1.9  2001/12/12 18:57:42  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.8  2001/10/22 17:23:12  dj_jl
//  Floatification of angles
//
//  Revision 1.7  2001/10/18 17:39:33  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.6  2001/10/02 17:42:38  dj_jl
//  Possibility to declare function's code inside class declaration
//
//  Revision 1.5  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.4  2001/08/31 17:17:23  dj_jl
//  Removed vector macros
//  
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
