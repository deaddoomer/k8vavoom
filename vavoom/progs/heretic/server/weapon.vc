//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

#define USE_GWND_AMMO_1	1
#define USE_GWND_AMMO_2 1
#define USE_CBOW_AMMO_1 1
#define USE_CBOW_AMMO_2 1
#define USE_BLSR_AMMO_1 1
#define USE_BLSR_AMMO_2 5
#define USE_SKRD_AMMO_1 1
#define USE_SKRD_AMMO_2 5
#define USE_PHRD_AMMO_1 1
#define USE_PHRD_AMMO_2 1
#define USE_MACE_AMMO_1 1
#define USE_MACE_AMMO_2 5

#define MAX_MACE_SPOTS	8

int WeaponAmmoUsePL1[NUMWEAPONS] = {
	0,	// staff
	USE_GWND_AMMO_1,	// gold wand
	USE_CBOW_AMMO_1,	// crossbow
	USE_BLSR_AMMO_1,	// blaster
	USE_SKRD_AMMO_1,	// skull rod
	USE_PHRD_AMMO_1,	// phoenix rod
	USE_MACE_AMMO_1,	// mace
	0,	// gauntlets
	0	// beak
};

int WeaponAmmoUsePL2[NUMWEAPONS] = {
	0,	// staff
	USE_GWND_AMMO_2,	// gold wand
	USE_CBOW_AMMO_2,	// crossbow
	USE_BLSR_AMMO_2,	// blaster
	USE_SKRD_AMMO_2,	// skull rod
	USE_PHRD_AMMO_2,	// phoenix rod
	USE_MACE_AMMO_2,	// mace
	0,	// gauntlets
	0	// beak
};

int MaceSpotCount;
float MaceSpot_x[MAX_MACE_SPOTS];
float MaceSpot_y[MAX_MACE_SPOTS];

//****************************************************************************
//
//  WEAPON UTILITES
//
//****************************************************************************

//===========================================================================
//
//  OpenWeapons
//
//  Called at level load before things are loaded.
//
//===========================================================================

void OpenWeapons(void)
{
	MaceSpotCount = 0;
}

//===========================================================================
//
//  AddMaceSpot
//
//===========================================================================

void AddMaceSpot(float x, float y)
{
	if (MaceSpotCount == MAX_MACE_SPOTS)
	{
		Error("Too many mace spots.");
	}
	MaceSpot_x[MaceSpotCount] = x;
	MaceSpot_y[MaceSpotCount] = y;
	MaceSpotCount++;
}

//===========================================================================
//
//  RepositionMace
//
//  Chooses the next spot to place the mace.
//
//===========================================================================

void RepositionMace(mobj_t * mo)
{
	int spot;

	spot = P_Random() % MaceSpotCount;
	P_UnsetThingPosition(*mo);
	mo->origin.x = MaceSpot_x[spot];
	mo->origin.y = MaceSpot_y[spot];
	P_SetThingPosition(*mo);
	mo->origin.z = mo->floorz;
}

//===========================================================================
//
//  CloseWeapons
//
//  Called at level load after things are loaded.
//
//===========================================================================

void CloseWeapons(void)
{
	int spot;

	if (!MaceSpotCount)
	{
		// No maces placed
		return;
	}
	if (!deathmatch && P_Random() < 64)
	{
		// Sometimes doesn't show up if not in deathmatch
		return;
	}
	spot = P_Random() % MaceSpotCount;
	P_SpawnMobj(MaceSpot_x[spot], MaceSpot_y[spot], ONFLOORZ, ItemWeaponMace);
}

//===========================================================================
//
//  SetPsprite
//
//===========================================================================

void SetPsprite(player_t * player, int position, int stnum)
{
	ViewEntity e;
	state_t *state;

	e = player->ViewEnts[position];
	do
	{
		if (!stnum)
		{
			// Object removed itself.
			e.statenum = 0;
			break;
		}
		state = &states[stnum];
		e.time = state->time;	// could be 0
		e.sprite = state->sprite;
		e.frame = state->frame;
		e.model_index = state->model_index;
		e.alias_frame = state->model_frame;
		e.statenum = state->statenum;
		e.nextstate = state->nextstate;
		if (state->misc1)
		{
			// Set coordinates.
			e.sx = state->misc1;
			e.sy = state->misc2;
		}
		if (state->function)
		{
			// Call action routine.
			state->function(e);
			if (!e.statenum)
			{
				break;
			}
		}
		stnum = e.nextstate;
	}
	while (!e.time);	// An initial state of 0 could cycle through.
}

//===========================================================================
//
//  BringUpWeapon
//
//  Starts bringing the pending weapon up from the bottom of the screen.
//
//===========================================================================

void BringUpWeapon(player_t * player)
{
	player->pspriteSY = PSpriteSY[player->readyweapon];
	weaponinfo[player->readyweapon] (player);
	if (player->readyweapon == wp_gauntlets)
	{
		StartSoundName(*player->mo, 'GauntletActive', CHAN_WEAPON);
	}
	player->pendingweapon = wp_nochange;
	player->ViewEnts[ps_weapon].sy = WEAPONBOTTOM;
	if (player->powers[pw_weaponlevel2])
	{
		SetPsprite(player, ps_weapon, player->w2_upstate);
	}
	else
	{
		SetPsprite(player, ps_weapon, player->w_upstate);
	}
}

//===========================================================================
//
//  DropWeapon
//
//  The player died, so put the weapon away.
//
//===========================================================================

void DropWeapon(player_t * player)
{
	if (player->powers[pw_weaponlevel2])
	{
		SetPsprite(player, ps_weapon, player->w2_downstate);
	}
	else
	{
		SetPsprite(player, ps_weapon, player->w_downstate);
	}
}

//===========================================================================
//
//  SetupPsprites
//
//  Called at start of level for each player
//
//===========================================================================

void SetupPsprites(player_t * player)
{
	int i;

	// Remove all  ViewEnts
	for (i = 0; i < NUMPSPRITES; i++)
	{
		player->ViewEnts[i].statenum = 0;
	}
	// Spawn the ready weapon
	BringUpWeapon(player);
}

//===========================================================================
//
//  MovePsprites
//
//  Called every tic by player thinking routine
//
//===========================================================================

void MovePsprites(player_t * player)
{
	int i;
	ViewEntity e;

	for (i = 0; i < NUMPSPRITES; i++)
	{
		e = player->ViewEnts[i];
		if (e.statenum)	// a null state means not active
		{
			// drop tic count and possibly change state
			if (e.time != -1.0)	// a -1 tic count never changes
			{
				e.time -= frametime;
				if (e.time <= 0.0)
				{
					e.time = 0.0;
					SetPsprite(player, i, e.nextstate);
				}
			}
		}
	}
	player->ViewEnts[ps_flash].sx = player->ViewEnts[ps_weapon].sx;
	player->ViewEnts[ps_flash].sy = player->ViewEnts[ps_weapon].sy;
}

//===========================================================================
//
//  CheckAmmo
//
//  Returns true if there is enough ammo to shoot.  If not, selects the
// next weapon to use.
//
//===========================================================================

boolean CheckAmmo(player_t * player)
{
	int ammo;
	int *ammoUse;
	int count;

	ammo = player->w_ammo;
	if (player->powers[pw_weaponlevel2] && !deathmatch)
	{
		ammoUse = &WeaponAmmoUsePL2[0];
	}
	else
	{
		ammoUse = &WeaponAmmoUsePL1[0];
	}
	count = ammoUse[player->readyweapon];
	if (ammo == am_noammo || player->ammo[ammo] >= count)
	{
		return true;
	}
	// out of ammo, pick a weapon to change to
	do
	{
		if (player->weaponowned[wp_skullrod]
			&& player->ammo[am_skullrod] > ammoUse[wp_skullrod])
		{
			player->pendingweapon = wp_skullrod;
		}
		else if (player->weaponowned[wp_blaster]
			&& player->ammo[am_blaster] > ammoUse[wp_blaster])
		{
			player->pendingweapon = wp_blaster;
		}
		else if (player->weaponowned[wp_crossbow]
			&& player->ammo[am_crossbow] > ammoUse[wp_crossbow])
		{
			player->pendingweapon = wp_crossbow;
		}
		else if (player->weaponowned[wp_mace]
			&& player->ammo[am_mace] > ammoUse[wp_mace])
		{
			player->pendingweapon = wp_mace;
		}
		else if (player->ammo[am_goldwand] > ammoUse[wp_goldwand])
		{
			player->pendingweapon = wp_goldwand;
		}
		else if (player->weaponowned[wp_gauntlets])
		{
			player->pendingweapon = wp_gauntlets;
		}
		else if (player->weaponowned[wp_phoenixrod]
			&& player->ammo[am_phoenixrod] > ammoUse[wp_phoenixrod])
		{
			player->pendingweapon = wp_phoenixrod;
		}
		else
		{
			player->pendingweapon = wp_staff;
		}
	}
	while (player->pendingweapon == wp_nochange);
	if (player->powers[pw_weaponlevel2])
	{
		SetPsprite(player, ps_weapon, player->w2_downstate);
	}
	else
	{
		SetPsprite(player, ps_weapon, player->w_downstate);
	}
	return false;
}

//===========================================================================
//
//  BulletSlope
//
//  Sets a slope so a near miss is at aproximately the height of the
// intended target
//
//===========================================================================

void BulletSlope(mobj_t * mo, TAVec * angles)
{
	//
	// see which target is to be aimed at
	//
	angles->pitch = mo->angles.pitch;
	angles->yaw = mo->angles.yaw;
	angles->roll = mo->angles.roll;

	AimLineAttack(mo, angles, 16.0 * 64.0);
	if (!linetarget)
	{
		angles->yaw = AngleMod360(angles->yaw + 45.0 / 8.0);
		AimLineAttack(mo, angles, 16.0 * 64.0);
		if (!linetarget)
		{
			angles->yaw = AngleMod360(angles->yaw - 45.0 / 4.0);
			AimLineAttack(mo, angles, 16.0 * 64.0);
			if (!linetarget)
			{
				angles->yaw = AngleMod360(angles->yaw + 45.0 / 8.0);
			}
		}
	}
}

//===========================================================================
//
//  FireWeapon
//
//===========================================================================

void FireWeapon(player_t * player)
{
	int attackState;

	if (!CheckAmmo(player))
	{
		return;
	}
	player->mo->SetState(S_PLAY_ATK2);
	if (player->powers[pw_weaponlevel2])
	{
		attackState = player->refire ? player->w2_holdatkstate
			: player->w2_atkstate;
	}
	else
	{
		attackState = player->refire ? player->w_holdatkstate
			: player->w_atkstate;
	}
	SetPsprite(player, ps_weapon, attackState);
	P_NoiseAlert(player->mo, player->mo);
	if (player->readyweapon == wp_gauntlets && !player->refire)
	{
		// Play the sound for the initial gauntlet attack
		StartSoundName(*player->mo, 'GauntletUse', CHAN_WEAPON);
	}
}

//===========================================================================
//
//  ActivateBeak
//
//===========================================================================

void ActivateBeak(player_t * player)
{
	player->pendingweapon = wp_nochange;
	player->readyweapon = wp_beak;
	weaponinfo[wp_beak] (player);
	player->pspriteSY = PSpriteSY[player->readyweapon];
	player->ViewEnts[ps_weapon].sy = WEAPONTOP;
	SetPsprite(player, ps_weapon, S_BEAKREADY);
}

//===========================================================================
//
//  PostChickenWeapon
//
//===========================================================================

void PostChickenWeapon(player_t * player, int weapon)
{
	if (weapon == wp_beak)
	{	// Should never happen
		weapon = wp_staff;
	}
	player->pendingweapon = wp_nochange;
	player->readyweapon = weapon;
	weaponinfo[weapon] (player);
	player->pspriteSY = PSpriteSY[player->readyweapon];
	player->ViewEnts[ps_weapon].sy = WEAPONBOTTOM;
	SetPsprite(player, ps_weapon, player->w_upstate);
}

//===========================================================================
//
//  UpdateBeak
//
//===========================================================================

void UpdateBeak(player_t * player, ViewEntity e)
{
	e.sy = WEAPONTOP + itof(player->chickenPeck) / 2.0;
}

//===========================================================================
//
//  WeaponLevel2Fade
//
//===========================================================================

void WeaponLevel2Fade(player_t * player)
{
	if ((player->readyweapon == wp_phoenixrod) &&
		(player->ViewEnts[ps_weapon].statenum != S_PHOENIXREADY) &&
		(player->ViewEnts[ps_weapon].statenum != S_PHOENIXUP))
	{
		SetPsprite(player, ps_weapon, S_PHOENIXREADY);
		player->ammo[am_phoenixrod] -= USE_PHRD_AMMO_2;
		player->refire = 0;
	}
	else if ((player->readyweapon == wp_gauntlets)
		|| (player->readyweapon == wp_staff))
	{
		player->pendingweapon = player->readyweapon;
	}
}

//****************************************************************************
//
//  WEAPON ACTIONS
//
//****************************************************************************

//===========================================================================
//
//  Weapon::A_WeaponReady
//
//  The player can fire the weapon or change to another weapon at this time.
//
//===========================================================================

void Weapon::A_WeaponReady(void)
{
	float angle;

	if (player->chickenTics)
	{
		// Change to the chicken beak
		ActivateBeak(player);
		return;
	}
	// Change player from attack state
	if (player->mo->statenum == S_PLAY_ATK1 ||
		player->mo->statenum == S_PLAY_ATK2)
	{
		player->mo->SetState(S_PLAY);
	}
	// Check for staff PL2 active sound
	if ((player->readyweapon == wp_staff) &&
		(statenum == S_STAFFREADY2_1) && P_Random() < 128)
	{
		StartSoundName(*player->mo, 'StaffActive', CHAN_WEAPON);
	}
	// Put the weapon away if the player has a pending weapon or has
	// died.
	if (player->pendingweapon != wp_nochange || !player->health)
	{
		if (player->powers[pw_weaponlevel2])
		{
			SetPsprite(player, ps_weapon, player->w2_downstate);
		}
		else
		{
			SetPsprite(player, ps_weapon, player->w_downstate);
		}
		return;
	}

	// Check for fire.  The phoenix rod does not auto fire.
	if (player->buttons & BT_ATTACK)
	{
		if (!player->attackdown || (player->readyweapon != wp_phoenixrod))
		{
			player->attackdown = true;
			FireWeapon(player);
			return;
		}
	}
	else
	{
		player->attackdown = false;
	}

	// Bob the weapon based on movement speed.
	angle = AngleMod360(180.0 * level->time);
	sx = 1.0 + player->bob * cos(angle);
	if (angle >= 180.0)
	{
		angle -= 180.0;
	}
	sy = WEAPONTOP + player->bob * sin(angle);
}

//===========================================================================
//
//  Weapon::A_BeakReady
//
//===========================================================================

void Weapon::A_BeakReady(void)
{
	if (player->buttons & BT_ATTACK)
	{
		// Chicken beak attack
		player->attackdown = true;
		player->mo->SetState(S_CHICPLAY_ATK1);
		if (player->powers[pw_weaponlevel2])
		{
			SetPsprite(player, ps_weapon, S_BEAKATK2_1);
		}
		else
		{
			SetPsprite(player, ps_weapon, S_BEAKATK1_1);
		}
		P_NoiseAlert(player->mo, player->mo);
	}
	else
	{
		if (player->mo->statenum == S_CHICPLAY_ATK1)
		{	// Take out of attack state
			player->mo->SetState(S_CHICPLAY);
		}
		player->attackdown = false;
	}
}

//===========================================================================
//
//  Weapon::A_Lower
//
//===========================================================================

void Weapon::A_Lower(void)
{
	if (player->chickenTics)
	{
		sy = WEAPONBOTTOM;
	}
	else
	{
		sy += LOWERSPEED;
	}
	if (sy < WEAPONBOTTOM)
	{
		// Not lowered all the way yet
		return;
	}
	if (player->playerstate == PST_DEAD)
	{
		// Player is dead, so don't bring up a pending weapon
		sy = WEAPONBOTTOM;
		return;
	}
	if (!player->health)
	{
		// Player is dead, so keep the weapon off screen
		SetPsprite(player, ps_weapon, S_NULL);
		return;
	}
	player->readyweapon = player->pendingweapon;
	BringUpWeapon(player);
}

//===========================================================================
//
//  Weapon::A_Raise
//
//===========================================================================

void Weapon::A_Raise(void)
{
	sy -= RAISESPEED;
	if (sy > WEAPONTOP)
	{
		// Not raised all the way yet
		return;
	}
	sy = WEAPONTOP;
	if (player->powers[pw_weaponlevel2])
	{
		SetPsprite(player, ps_weapon, player->w2_readystate);
	}
	else
	{
		SetPsprite(player, ps_weapon, player->w_readystate);
	}
}

//===========================================================================
//
//  Weapon::A_BeakRaise
//
//===========================================================================

void Weapon::A_BeakRaise(void)
{
	sy = WEAPONTOP;
	SetPsprite(player, ps_weapon, player->w_readystate);
}

//===========================================================================
//
//  Weapon::A_ReFire
//
//  The player can re fire the weapon without lowering it entirely.
//
//===========================================================================

void Weapon::A_ReFire(void)
{
	if ((player->buttons & BT_ATTACK)
		&& player->pendingweapon == wp_nochange && player->health)
	{
		player->refire++;
		FireWeapon(player);
	}
	else
	{
		player->refire = 0;
		CheckAmmo(player);
	}
}

//===========================================================================
//
//  Weapon::A_Light0
//
//===========================================================================

void Weapon::A_Light0(void)
{
	player->extralight = 0;
}

//****************************************************************************
//
//  WEAPON ATTACKS
//
//****************************************************************************

//===========================================================================
//
//  Weapon::A_StaffAttackPL1
//
//===========================================================================

void Weapon::A_StaffAttackPL1(void)
{
	TAVec angles;
	int damage;
	TVec vforward;

	damage = 5 + (P_Random() & 15);
	avcpy(player->mo->angles, angles);
	angles.yaw = AngleMod360(angles.yaw +
		(Random() - Random()) * 45.0 / 8.0);
	AimLineAttack(player->mo, &angles, MELEERANGE);
	AngleVector(&angles, &vforward);
	PuffType = StaffPuff;
	LineAttack(player->mo, &vforward, MELEERANGE, damage);
	if (linetarget)
	{
		//StartSoundName(player->mo, sfx_stfhit);
		// turn to face target
		player->mo->angles.yaw =
			atan2(linetarget->origin.y - player->mo->origin.y,
			linetarget->origin.x - player->mo->origin.x);
	}
}

//===========================================================================
//
//  Weapon::A_StaffAttackPL2
//
//===========================================================================

void Weapon::A_StaffAttackPL2(void)
{
	TAVec angles;
	int damage;
	TVec vforward;

	// P_inter.c:DamageMobj() handles target momentums
	damage = 18 + (P_Random() & 63);

	avcpy(player->mo->angles, angles);
	angles.yaw = AngleMod360(angles.yaw +
		(Random() - Random()) * 45.0 / 8.0);
	AimLineAttack(player->mo, &angles, MELEERANGE);
	AngleVector(&angles, &vforward);
	PuffType = StaffPuff2;
	LineAttack(player->mo, &vforward, MELEERANGE, damage);
	if (linetarget)
	{
		//StartSoundName(player->mo, sfx_stfpow);
		// turn to face target
		player->mo->angles.yaw =
			atan2(linetarget->origin.y - player->mo->origin.y,
			linetarget->origin.x - player->mo->origin.x);
		player->fixangle = 1;
	}
}

//===========================================================================
//
//  Weapon::A_GauntletAttack
//
//===========================================================================

void Weapon::A_GauntletAttack(void)
{
	float angle;
	int damage;
	float slope;
	int randVal;
	float dist;
	TAVec angles;
	TVec vforward;

	sx = Random() * 4.0 - 2.0;
	sy = WEAPONTOP + Random() * 4.0;
	angles = player->mo->angles;
	if (player->powers[pw_weaponlevel2])
	{
		damage = HITDICE(2);
		dist = 4.0 * MELEERANGE;
		angles.yaw = AngleMod360(angles.yaw +
			(Random() - Random()) * 45.0 / 16.0);
		PuffType = GauntletPuff2;
	}
	else
	{
		damage = HITDICE(2);
		dist = MELEERANGE + 0.00001;
		angles.yaw = AngleMod360(angles.yaw +
			(Random() - Random()) * 45.0 / 8.0);
		PuffType = GauntletPuff1;
	}
	AimLineAttack(player->mo, &angles, dist);
	AngleVector(&angles, &vforward);
	LineAttack(player->mo, &vforward, dist, damage);
	if (!linetarget)
	{
		if (P_Random() > 64)
		{
			player->extralight = !player->extralight;
		}
		StartSoundName(*player->mo, 'GauntletFull', CHAN_WEAPON);
		return;
	}
	randVal = P_Random();
	if (randVal < 64)
	{
		player->extralight = 0;
	}
	else if (randVal < 160)
	{
		player->extralight = 1;
	}
	else
	{
		player->extralight = 2;
	}
	if (player->powers[pw_weaponlevel2])
	{
		player->mo->GiveBody(damage >> 1);
		StartSoundName(*player->mo, 'GauntletHit2', CHAN_WEAPON);
	}
	else
	{
		StartSoundName(*player->mo, 'GauntletHit', CHAN_WEAPON);
	}
	// turn to face target
	angle = atan2(linetarget->origin.y - player->mo->origin.y,
		linetarget->origin.x - player->mo->origin.x);
	if (AngleMod360(angle - player->mo->angles.yaw) > 180.0)
	{
		if (AngleMod360(angle - player->mo->angles.yaw) < 360.0 - 90.0 / 20.0)
			player->mo->angles.yaw = AngleMod360(angle + 90.0 / 21.0);
		else
			player->mo->angles.yaw = AngleMod360(player->mo->angles.yaw - 90.0 / 20.0);
	}
	else
	{
		if (AngleMod360(angle - player->mo->angles.yaw) > 90.0 / 20.0)
			player->mo->angles.yaw = AngleMod360(angle - 90.0 / 21.0);
		else
			player->mo->angles.yaw = AngleMod360(player->mo->angles.yaw + 90.0 / 20.0);
	}
	player->mo->bJustAttacked = true;
}

//===========================================================================
//
//  Weapon::A_FireGoldWandPL1
//
//===========================================================================

void Weapon::A_FireGoldWandPL1(void)
{
	mobj_t *mo;
	int damage;
	TAVec angles;
	TVec vforward;

	mo = player->mo;
	player->ammo[am_goldwand] -= USE_GWND_AMMO_1;
	damage = 7 + (P_Random() & 7);
	BulletSlope(mo, &angles);
	if (player->refire)
	{
		angles.yaw = AngleMod360(angles.yaw +
			(Random() - Random()) * 45.0 / 8.0);
	}
	AngleVector(&angles, &vforward);
	PuffType = GoldWandPuff1;
	LineAttack(mo, &vforward, MISSILERANGE, damage);
	StartSoundName(*player->mo, 'GoldWandFire', CHAN_WEAPON);
}

//===========================================================================
//
//  Weapon::A_FireGoldWandPL2
//
//===========================================================================

void Weapon::A_FireGoldWandPL2(void)
{
	int i;
	mobj_t *mo;
	int damage;
	float momz;
	TAVec angles;
	TVec vforward;

	mo = player->mo;
	player->ammo[am_goldwand] -=
		deathmatch ? USE_GWND_AMMO_1 : USE_GWND_AMMO_2;
	PuffType = GoldWandPuff2;
	BulletSlope(mo, &angles);
	SpawnMissileAngles(mo, GoldWandMissile2,
		AngleMod360(angles.yaw - (45.0 / 8.0)), angles.pitch);
	SpawnMissileAngles(mo, GoldWandMissile2,
		AngleMod360(angles.yaw + (45.0 / 8.0)), angles.pitch);
	angles.yaw = AngleMod360(angles.yaw - (45.0 / 8.0));
	for (i = 0; i < 5; i++)
	{
		damage = 1 + (P_Random() & 7);
		AngleVector(&angles, &vforward);
		LineAttack(mo, &vforward, MISSILERANGE, damage);
		angles.yaw = AngleMod360(angles.yaw + (((45.0 / 8.0) * 2.0) / 4.0));
	}
	StartSoundName(*player->mo, 'GoldWandFire', CHAN_WEAPON);
}

//===========================================================================
//
//  Weapon::A_FireCrossbowPL1
//
//===========================================================================

void Weapon::A_FireCrossbowPL1(void)
{
	mobj_t *pmo;

	pmo = player->mo;
	player->ammo[am_crossbow] -= USE_CBOW_AMMO_1;
	SpawnPlayerMissile(pmo, CrossbowFX1);
	SpawnPlayerMissileAngle(pmo, CrossbowFX3,
		AngleMod360(pmo->angles.yaw - (45.0 / 10.0)));
	SpawnPlayerMissileAngle(pmo, CrossbowFX3,
		AngleMod360(pmo->angles.yaw + (45.0 / 10.0)));
}

//===========================================================================
//
//  Weapon::A_FireCrossbowPL2
//
//===========================================================================

void Weapon::A_FireCrossbowPL2(void)
{
	mobj_t *pmo;

	pmo = player->mo;
	player->ammo[am_crossbow] -=
		deathmatch ? USE_CBOW_AMMO_1 : USE_CBOW_AMMO_2;
	SpawnPlayerMissile(pmo, CrossbowFX2);
	SpawnPlayerMissileAngle(pmo, CrossbowFX2,
		AngleMod360(pmo->angles.yaw - (45.0 / 10.0)));
	SpawnPlayerMissileAngle(pmo, CrossbowFX2,
		AngleMod360(pmo->angles.yaw + (45.0 / 10.0)));
	SpawnPlayerMissileAngle(pmo, CrossbowFX3,
		AngleMod360(pmo->angles.yaw - (45.0 / 5.0)));
	SpawnPlayerMissileAngle(pmo, CrossbowFX3,
		AngleMod360(pmo->angles.yaw + (45.0 / 5.0)));
}

//===========================================================================
//
//  Weapon::A_FireBlasterPL1
//
//===========================================================================

void Weapon::A_FireBlasterPL1(void)
{
	mobj_t *mo;
	int damage;
	float bulletslope;
	TAVec angles;
	TVec vforward;

	mo = player->mo;
	StartSoundName(*mo, 'GoldWandFire', CHAN_WEAPON);
	player->ammo[am_blaster] -= USE_BLSR_AMMO_1;
	BulletSlope(mo, &angles);
	damage = HITDICE(4);
	if (player->refire)
	{
		angles.yaw = AngleMod360(angles.yaw +
			(Random() - Random()) * 45.0 / 8.0);
	}
	PuffType = BlasterPuff1;
	AngleVector(&angles, &vforward);
	LineAttack(mo, &vforward, MISSILERANGE, damage);
	StartSoundName(*player->mo, 'BlasterFire', CHAN_WEAPON);
}

//===========================================================================
//
//  Weapon::A_FireBlasterPL2
//
//===========================================================================

void Weapon::A_FireBlasterPL2(void)
{
	mobj_t *mo;

	player->ammo[am_blaster] -=
		deathmatch ? USE_BLSR_AMMO_1 : USE_BLSR_AMMO_2;
	mo = SpawnPlayerMissile(player->mo, BlasterFX1);
	if (mo)
	{
		mo->blaster = true;
	}
	StartSoundName(*player->mo, 'BlasterFire', CHAN_WEAPON);
}

//===========================================================================
//
//  Weapon::A_FireSkullRodPL1
//
//===========================================================================

void Weapon::A_FireSkullRodPL1(void)
{
	mobj_t *mo;

	if (player->ammo[am_skullrod] < USE_SKRD_AMMO_1)
	{
		return;
	}
	player->ammo[am_skullrod] -= USE_SKRD_AMMO_1;
	mo = SpawnPlayerMissile(player->mo, HornRodMissile1);
	// Randomize the first frame
	if (mo && P_Random() > 128)
	{
		mo->SetState(S_HRODFX1_2);
	}
}

//===========================================================================
//
//  Weapon::A_FireSkullRodPL2
//
//  The special2 field holds the player number that shot the rain missile.
// The specialmobj1 field is used for the seeking routines, special1 as a
// counter for the sound looping.
//
//===========================================================================

void Weapon::A_FireSkullRodPL2(void)
{
	player->ammo[am_skullrod] -=
		deathmatch ? USE_SKRD_AMMO_1 : USE_SKRD_AMMO_2;
	SpawnPlayerMissile(player->mo, HornRodMissile2);
	// Use MissileMobj instead of the return value from
	// SpawnPlayerMissile because we need to give info to the mobj
	// even if it exploded immediately.
	if (netgame)
	{
		// Multi-player game
		MissileMobj->special2 = P_GetPlayerNum(player);
	}
	else
	{
		// Always use red missiles in single player games
		MissileMobj->special2 = 2;
	}
	if (linetarget)
	{
		MissileMobj->specialmobj1 = linetarget;
	}
	StartSoundName(*MissileMobj, 'SkullRodFire2', CHAN_WEAPON);
}

//===========================================================================
//
//  Weapon::A_FirePhoenixPL1
//
//===========================================================================

void Weapon::A_FirePhoenixPL1(void)
{
	TVec vforward;

	player->ammo[am_phoenixrod] -= USE_PHRD_AMMO_1;
	SpawnPlayerMissile(player->mo, PhoenixFX1);
	AngleVector(&player->mo->angles, &vforward);
	player->mo->velocity -= vforward * 140.0;
}

//===========================================================================
//
//  Weapon::A_InitPhoenixPL2
//
//===========================================================================

void Weapon::A_InitPhoenixPL2(void)
{
	player->flamecount = ftoi(FLAME_THROWER_TIME * 35.0);
}

//===========================================================================
//
//  Weapon::A_FirePhoenixPL2
//
//  Flame thrower effect.
//
//===========================================================================

void Weapon::A_FirePhoenixPL2(void)
{
	mobj_t *mo;
	mobj_t *pmo;
	TVec dir;
	float x, y, z;

	if (--player->flamecount == 0)
	{
		// Out of flame
		SetPsprite(player, ps_weapon, S_PHOENIXATK2_4);
		player->refire = 0;
		return;
	}
	pmo = player->mo;
	x = pmo->origin.x + (Random() - Random()) * 2.0;
	y = pmo->origin.y + (Random() - Random()) * 2.0;
	z = pmo->origin.z + 26.0 - sin(player->mo->angles.pitch);
	z -= pmo->floorclip;
	mo = P_SpawnMobj(x, y, z, PhoenixFX2);
	mo->target = pmo;
	mo->angles.yaw = pmo->angles.yaw;
	mo->angles.pitch = pmo->angles.pitch;
	AngleVector(&mo->angles, &dir);
	mo->velocity = pmo->velocity + mo->Speed * dir;
	if (!player->refire || !(level->tictime % 38))
	{
		StartSoundName(*player->mo, 'PhoenixHit2', CHAN_WEAPON);
	}
	CheckMissileSpawn(mo);
}

//===========================================================================
//
//  Weapon::A_ShutdownPhoenixPL2
//
//===========================================================================

void Weapon::A_ShutdownPhoenixPL2(void)
{
	player->ammo[am_phoenixrod] -= USE_PHRD_AMMO_2;
}

//===========================================================================
//
// PROC A_FireMacePL1B
//
//===========================================================================

void A_FireMacePL1B(mobj_t * actor)
{
	player_t *player = actor->player;
	mobj_t *pmo;
	mobj_t *ball;
	float angle;

	if (player->ammo[am_mace] < USE_MACE_AMMO_1)
	{
		return;
	}
	player->ammo[am_mace] -= USE_MACE_AMMO_1;
	pmo = player->mo;
	ball = P_SpawnMobj(pmo->origin.x, pmo->origin.y, pmo->origin.z + 28.0
		- pmo->floorclip, MaceFX2);
	ball->velocity.z =
		(2.0 + 173.0 * -tan(player->mo->angles.pitch) / 32.0) * 35.0;
	angle = pmo->angles.yaw;
	ball->target = pmo;
	ball->angles.yaw = angle;
	ball->origin.z += 173.0 * -tan(player->mo->angles.pitch) / 16.0;
	ball->velocity.x = pmo->velocity.x / 2.0 + ball->Speed * cos(angle);
	ball->velocity.y = pmo->velocity.y / 2.0 + ball->Speed * sin(angle);
	StartSoundName(*ball, 'MaceFire', CHAN_WEAPON);
	CheckMissileSpawn(ball);
}

//===========================================================================
//
//  Weapon::A_FireMacePL1
//
//===========================================================================

void Weapon::A_FireMacePL1(void)
{
	mobj_t *ball;

	if (P_Random() < 28)
	{
		A_FireMacePL1B(player->mo);
		return;
	}
	if (player->ammo[am_mace] < USE_MACE_AMMO_1)
	{
		return;
	}
	player->ammo[am_mace] -= USE_MACE_AMMO_1;
	sx = Random() * 4.0 - 2.0;
	sy = WEAPONTOP + Random() * 4.0;
	ball = SpawnPlayerMissileAngle(player->mo, MaceFX1,
		AngleMod360(player->mo->angles.yaw + (Random() - 0.5) * 45.0 / 4.0));
	if (ball)
	{
		ball->special1 = 16;	// tics till dropoff
	}
}

//===========================================================================
//
//  Weapon::A_FireMacePL2
//
//===========================================================================

void Weapon::A_FireMacePL2(void)
{
	mobj_t *mo;

	player->ammo[am_mace] -= deathmatch ? USE_MACE_AMMO_1 : USE_MACE_AMMO_2;
	mo = SpawnPlayerMissile(player->mo, MaceFX4);
	if (mo)
	{
		mo->velocity.x += player->mo->velocity.x;
		mo->velocity.y += player->mo->velocity.y;
		mo->velocity.z =
			(2.0 + 173.0 * -tan(player->mo->angles.pitch) / 32.0) * 35.0;
		if (linetarget)
		{
			mo->specialmobj1 = linetarget;
		}
	}
	StartSoundName(*player->mo, 'MaceFire', CHAN_WEAPON);
}

//===========================================================================
//
//  Weapon::A_BeakAttackPL1
//
//===========================================================================

void Weapon::A_BeakAttackPL1(void)
{
	int damage;
	TAVec angles;
	TVec vforward;

	damage = 1 + (P_Random() & 3);
	avcpy(player->mo->angles, angles);
	AimLineAttack(player->mo, &angles, MELEERANGE);
	PuffType = BeakPuff;
	AngleVector(&angles, &vforward);
	LineAttack(player->mo, &vforward, MELEERANGE, damage);
	if (linetarget)
	{
		player->mo->angles.yaw =
			atan2(linetarget->origin.y - player->mo->origin.y,
			linetarget->origin.x - player->mo->origin.x);
		player->fixangle = 1;
	}
	StartSound(*player->mo, GetSoundID('ChickenPeak1') + (P_Random() % 3),
		CHAN_VOICE);
	player->chickenPeck = 12;
	time -= Random() * 0.25;
}

//===========================================================================
//
//  Weapon::A_BeakAttackPL2
//
//===========================================================================

void Weapon::A_BeakAttackPL2(void)
{
	int damage;
	TAVec angles;
	TVec vforward;

	damage = HITDICE(4);
	avcpy(player->mo->angles, angles);
	AimLineAttack(player->mo, &angles, MELEERANGE);
	PuffType = BeakPuff;
	AngleVector(&angles, &vforward);
	LineAttack(player->mo, &vforward, MELEERANGE, damage);
	if (linetarget)
	{
		player->mo->angles.yaw =
			atan2(linetarget->origin.y - player->mo->origin.y,
			linetarget->origin.x - player->mo->origin.x);
		player->fixangle = 1;
	}
	StartSound(*player->mo, GetSoundID('ChickenPeak1') + (P_Random() % 3),
		CHAN_VOICE);
	player->chickenPeck = 12;
	time -= Random() * 0.125;
}

//****************************************************************************
//
//  WEAPON PROJECTILE ACTIONS
//
//****************************************************************************

//===========================================================================
//
//  Actor::A_BoltSpark
//
//===========================================================================

void Actor::A_BoltSpark(void)
{
	mobj_t *spark;

	if (P_Random() > 50)
	{
		spark = P_SpawnMobj(origin.x, origin.y, origin.z, CrossbowFX4);
		spark->origin.x += (Random() - Random()) * 4.0;
		spark->origin.y += (Random() - Random()) * 4.0;
	}
}

//===========================================================================
//
//  Actor::A_SpawnRippers
//
//===========================================================================

void Actor::A_SpawnRippers(void)
{
	int i;
	float angle;
	mobj_t *ripper;

	for (i = 0; i < 8; i++)
	{
		ripper = P_SpawnMobj(origin.x, origin.y, origin.z, Ripper);
		angle = itof(i) * 45.0;
		ripper->target = target;
		ripper->angles.yaw = angle;
		ripper->velocity.x = ripper->Speed * cos(angle);
		ripper->velocity.y = ripper->Speed * sin(angle);
		CheckMissileSpawn(ripper);
	}
}

//===========================================================================
//
//  Actor::A_SkullRodPL2Seek
//
//===========================================================================

void Actor::A_SkullRodPL2Seek(void)
{
	P_SeekerMissile(this, 10.0, 30.0);
}

//===========================================================================
//
//  Actor::A_AddPlayerRain
//
//===========================================================================

void Actor::A_AddPlayerRain(void)
{
	int playerNum;
	player_t *player;

	playerNum = netgame ? special2 : 0;
	player = &players[playerNum];
	if (!player->active)
	{
		// Player left the game
		return;
	}
	if (player->health <= 0)
	{
		// Player is dead
		return;
	}
	if (player->rain1 && player->rain2)
	{
		// Terminate an active rain
		if (player->rain1->Health < player->rain2->Health)
		{
			if (player->rain1->Health > 16)
			{
				player->rain1->Health = 16;
			}
			player->rain1 = NULL;
		}
		else
		{
			if (player->rain2->Health > 16)
			{
				player->rain2->Health = 16;
			}
			player->rain2 = NULL;
		}
	}
	// Add rain mobj to list
	if (player->rain1)
	{
		player->rain2 = this;
	}
	else
	{
		player->rain1 = this;
	}
}

//===========================================================================
//
//  Actor::A_SkullRodStorm
//
//===========================================================================

void Actor::A_SkullRodStorm(void)
{
	float x;
	float y;
	mobj_t *mo;
	int playerNum;
	player_t *player;
	classid rain_type;

	if (Health-- == 0)
	{
		SetState(S_NULL);
		playerNum = netgame ? special2 : 0;
		player = &players[playerNum];
		if (!player->active)
		{
			// Player left the game
			return;
		}
		if (player->health <= 0)
		{
			// Player is dead
			return;
		}
		if (player->rain1 == this)
		{
			player->rain1 = NULL;
		}
		else if (player->rain2 == this)
		{
			player->rain2 = NULL;
		}
		return;
	}
	if (P_Random() < 25)
	{
		// Fudge rain frequency
		return;
	}
	x = origin.x + Random() * 128.0 - 64.0;
	y = origin.y + Random() * 128.0 - 64.0;
	switch (special2)
	{
	case 0: rain_type = RainPlayer1; break;
	case 1: rain_type = RainPlayer2; break;
	case 2: rain_type = RainPlayer3; break;
	case 3: rain_type = RainPlayer4; break;
	}
	mo = P_SpawnMobj(x, y, ONCEILINGZ, rain_type);
	mo->target = target;
	mo->velocity.x = 0.00001;	// Force collision detection
	mo->velocity.z = -mo->Speed;
	mo->special2 = special2;	// Transfer player number
	CheckMissileSpawn(mo);
	if (!(special1 & 31))
	{
		StartSoundName(self, 'SkullRodRain', CHAN_VOICE);
	}
	special1++;
}

//===========================================================================
//
//  Actor::A_RainImpact
//
//===========================================================================

void Actor::A_RainImpact(void)
{
	if (origin.z > floorz)
	{
		SetState(S_RAINAIRXPLR1_1 + special2);
	}
	else if (P_Random() < 40)
	{
		P_HitFloor(this);
	}
}

//===========================================================================
//
//  Actor::A_HideInCeiling
//
//===========================================================================

void Actor::A_HideInCeiling(void)
{
	origin.z = ceilingz + 4.0;
}

//===========================================================================
//
//  Actor::A_PhoenixPuff
//
//===========================================================================

void Actor::A_PhoenixPuff(void)
{
	mobj_t *puff;
	float angle;

	P_SeekerMissile(this, 5.0, 10.0);
	puff = P_SpawnMobj(origin.x, origin.y, origin.z, PhoenixPuff);
	angle = AngleMod360(angles.yaw + 90.0);
	puff->velocity.x = 1.3 * cos(angle) * 35.0;
	puff->velocity.y = 1.3 * sin(angle) * 35.0;
	puff->velocity.z = 0.0;
	puff = P_SpawnMobj(origin.x, origin.y, origin.z, PhoenixPuff);
	angle = AngleMod360(angles.yaw - 90.0);
	puff->velocity.x = 1.3 * cos(angle) * 35.0;
	puff->velocity.y = 1.3 * sin(angle) * 35.0;
	puff->velocity.z = 0.0;
}

//===========================================================================
//
//  Actor::A_FlameEnd
//
//===========================================================================

void Actor::A_FlameEnd(void)
{
	velocity.z += 1.5 * 35.0;
}

//===========================================================================
//
//  Actor::A_FloatPuff
//
//===========================================================================

void Actor::A_FloatPuff(void)
{
	velocity.z += 1.8 * 35.0;
}

//===========================================================================
//
//  Actor::A_MacePL1Check
//
//===========================================================================

void Actor::A_MacePL1Check(void)
{
	float angle;

	if (special1 == 0)
	{
		return;
	}
	special1 -= 4;
	if (special1 > 0)
	{
		return;
	}
	special1 = 0;
	bLowGravity = true;
	angle = angles.yaw;
	velocity.x = 7.0 * cos(angle) * 35.0;
	velocity.y = 7.0 * sin(angle) * 35.0;
	velocity.z -= velocity.z / 2.0;
}

//===========================================================================
//
//  Actor::A_MaceBallImpact
//
//===========================================================================

void Actor::A_MaceBallImpact(void)
{
	if ((origin.z <= floorz) && (P_HitFloor(this) != FLOOR_SOLID))
	{
		// Landed in some sort of liquid
		P_RemoveMobj(this);
		return;
	}
	if ((Health != MAGIC_JUNK) && (origin.z <= floorz) && velocity.z)
	{
		// Bounce
		Health = MAGIC_JUNK;
		velocity.z = velocity.z * 192.0 / 256.0;
		bFloorBounce = false;
		SetState(SpawnState);
		StartSoundName(self, 'Bounce', CHAN_VOICE);
	}
	else
	{
		// Explode
		bNoGravity = true;
		bLowGravity = false;
		StartSoundName(self, 'MaceHit', CHAN_VOICE);
	}
}

//===========================================================================
//
//  Actor::A_MaceBallImpact2
//
//===========================================================================

void Actor::A_MaceBallImpact2(void)
{
	mobj_t *tiny;
	float angle;

	if ((origin.z <= floorz) && (P_HitFloor(this) != FLOOR_SOLID))
	{
		// Landed in some sort of liquid
		P_RemoveMobj(this);
		return;
	}
	if ((origin.z != floorz) || (velocity.z < 2.0 * 35.0))
	{
		// Explode
		velocity = vector(0.0, 0.0, 0.0);
		bNoGravity = true;
		bLowGravity = false;
		bFloorBounce = false;
	}
	else
	{
		// Bounce
		velocity.z = velocity.z * 192.0 / 256.0;
		SetState(SpawnState);

		tiny = P_SpawnMobj(origin.x, origin.y, origin.z, MaceFX3);
		angle = AngleMod360(angles.yaw + 90.0);
		tiny->target = target;
		tiny->angles.yaw = angle;
		tiny->velocity.x =
			velocity.x / 2.0 + (velocity.z - 35.0) * cos(angle);
		tiny->velocity.y =
			velocity.y / 2.0 + (velocity.z - 35.0) * sin(angle);
		tiny->velocity.z = velocity.z;
		CheckMissileSpawn(tiny);

		tiny = P_SpawnMobj(origin.x, origin.y, origin.z, MaceFX3);
		angle = AngleMod360(angles.yaw - 90.0);
		tiny->target = target;
		tiny->angles.yaw = angle;
		tiny->velocity.x =
			velocity.x / 2.0 + (velocity.z - 35.0) * cos(angle);
		tiny->velocity.y =
			velocity.y / 2.0 + (velocity.z - 35.0) * sin(angle);
		tiny->velocity.z = velocity.z;
		CheckMissileSpawn(tiny);
	}
}

//===========================================================================
//
//  Actor::A_DeathBallImpact
//
//===========================================================================

void Actor::A_DeathBallImpact(void)
{
	int i;
	mobj_t *targ;
	float angle;
	int newAngle;
	TAVec angles;

	if ((origin.z <= floorz) && (P_HitFloor(this) != FLOOR_SOLID))
	{
		// Landed in some sort of liquid
		P_RemoveMobj(this);
		return;
	}
	if ((origin.z <= floorz) && velocity.z)
	{
		// Bounce
		newAngle = false;
		targ = specialmobj1;
		if (targ)
		{
			if (!targ->bShootable)
			{
				// Target died
				specialmobj1 = NULL;
			}
			else
			{
				// Seek
				angle = atan2(targ->origin.y - origin.y,
					targ->origin.x - origin.x);
				newAngle = true;
			}
		}
		else
		{
			// Find new target
			angles.pitch = 0.0;
			angles.yaw = 0.0;
			angles.roll = 0.0;
			for (i = 0; i < 16; i++)
			{
				AimLineAttack(this, &angles, 10.0 * 64.0);
				if (linetarget && target != linetarget)
				{
					specialmobj1 = linetarget;
					angle = atan2(linetarget->origin.y - origin.y,
						linetarget->origin.x - origin.x);
					newAngle = true;
					break;
				}
				angles.yaw = AngleMod360(angles.yaw + 45.0 / 2.0);
			}
		}
		if (newAngle)
		{
			angles.yaw = angle;
			velocity.x = Speed * cos(angle);
			velocity.y = Speed * sin(angle);
		}
		SetState(SpawnState);
		StartSoundName(self, 'PlatformStop', CHAN_VOICE);
	}
	else
	{	// Explode
		bNoGravity = true;
		bLowGravity = false;
		StartSoundName(self, 'PhoenixHit', CHAN_VOICE);
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.17  2002/02/06 17:28:52  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.16  2002/01/28 18:50:18  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.15  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.14  2002/01/24 18:19:26  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.13  2002/01/17 18:15:53  dj_jl
//  Renamed all map object classes
//
//  Revision 1.12  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.11  2002/01/11 18:19:41  dj_jl
//  Started to use names in progs
//
//  Revision 1.10  2002/01/07 12:23:18  dj_jl
//  Changed copyright year
//
//  Revision 1.9  2001/12/12 18:57:42  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.8  2001/10/22 17:23:12  dj_jl
//  Floatification of angles
//
//  Revision 1.7  2001/10/18 17:39:33  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.6  2001/10/02 17:42:38  dj_jl
//  Possibility to declare function's code inside class declaration
//
//  Revision 1.5  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.4  2001/08/31 17:17:23  dj_jl
//  Removed vector macros
//  
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
