//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

#define USE_GWND_AMMO_1	1
#define USE_GWND_AMMO_2 1
#define USE_CBOW_AMMO_1 1
#define USE_CBOW_AMMO_2 1
#define USE_BLSR_AMMO_1 1
#define USE_BLSR_AMMO_2 5
#define USE_SKRD_AMMO_1 1
#define USE_SKRD_AMMO_2 5
#define USE_PHRD_AMMO_1 1
#define USE_PHRD_AMMO_2 1
#define USE_MACE_AMMO_1 1
#define USE_MACE_AMMO_2 5

#define MAX_MACE_SPOTS	8

int WeaponAmmoUsePL1[NUMWEAPONS] = {
	0,	// staff
	USE_GWND_AMMO_1,	// gold wand
	USE_CBOW_AMMO_1,	// crossbow
	USE_BLSR_AMMO_1,	// blaster
	USE_SKRD_AMMO_1,	// skull rod
	USE_PHRD_AMMO_1,	// phoenix rod
	USE_MACE_AMMO_1,	// mace
	0,	// gauntlets
	0	// beak
};

int WeaponAmmoUsePL2[NUMWEAPONS] = {
	0,	// staff
	USE_GWND_AMMO_2,	// gold wand
	USE_CBOW_AMMO_2,	// crossbow
	USE_BLSR_AMMO_2,	// blaster
	USE_SKRD_AMMO_2,	// skull rod
	USE_PHRD_AMMO_2,	// phoenix rod
	USE_MACE_AMMO_2,	// mace
	0,	// gauntlets
	0	// beak
};

int MaceSpotCount;
float MaceSpot_x[MAX_MACE_SPOTS];
float MaceSpot_y[MAX_MACE_SPOTS];

//****************************************************************************
//
//  WEAPON UTILITES
//
//****************************************************************************

//==========================================================================
//
//	SetWeapon
//
//==========================================================================

void SetWeapon(player_t *player, int NewWeapon)
{
	player->ReadyWeapon = NewWeapon;
	player->PendingWeapon = wp_nochange;

	if (player->ViewEnts[ps_weapon])
	{
		player->ViewEnts[ps_weapon].Destroy();
	}
	player->ViewEnts[ps_weapon] = SpawnObject(WeaponClasses[NewWeapon], none);
	player->ViewEnts[ps_weapon].Player = player;
	player->PSpriteSY = Weapon(player->ViewEnts[ps_weapon]).PSpriteSY;
}

//===========================================================================
//
//  OpenWeapons
//
//  Called at level load before things are loaded.
//
//===========================================================================

void OpenWeapons(void)
{
	MaceSpotCount = 0;
}

//===========================================================================
//
//  AddMaceSpot
//
//===========================================================================

void AddMaceSpot(float x, float y)
{
	if (MaceSpotCount == MAX_MACE_SPOTS)
	{
		Error("Too many mace spots.");
	}
	MaceSpot_x[MaceSpotCount] = x;
	MaceSpot_y[MaceSpotCount] = y;
	MaceSpotCount++;
}

//==========================================================================
//
//  ItemWeaponMace::A_RestoreSpecialThing1
//
//  Chooses the next spot to place the mace.
//
//==========================================================================

void ItemWeaponMace::A_RestoreSpecialThing1(void)
{
	int spot;

	// Do random mace placement
	spot = P_Random() % MaceSpotCount;
	P_UnsetThingPosition(self);
	Origin.x = MaceSpot_x[spot];
	Origin.y = MaceSpot_y[spot];
	P_SetThingPosition(self);
	Origin.z = FloorZ;

	::A_RestoreSpecialThing1();
}

//===========================================================================
//
//  CloseWeapons
//
//  Called at level load after things are loaded.
//
//===========================================================================

void CloseWeapons(void)
{
	int spot;

	if (!MaceSpotCount)
	{
		// No maces placed
		return;
	}
	if (!deathmatch && P_Random() < 64)
	{
		// Sometimes doesn't show up if not in deathmatch
		return;
	}
	spot = P_Random() % MaceSpotCount;
	Spawn(ItemWeaponMace, vector(MaceSpot_x[spot], MaceSpot_y[spot],
		ONFLOORZ));
}

//===========================================================================
//
//  SetPsprite
//
//===========================================================================

void SetPsprite(player_t * player, int position, int stnum)
{
	player->ViewEnts[position].SetState(stnum);
}

//===========================================================================
//
//  BringUpWeapon
//
//  Starts bringing the pending weapon up from the bottom of the screen.
//
//===========================================================================

void BringUpWeapon(player_t * player)
{
	SetWeapon(player, player->ReadyWeapon);
	if (player->ReadyWeapon == wp_gauntlets)
	{
		player->MO.PlaySound('GauntletActive', CHAN_WEAPON);
	}
	player->ViewEnts[ps_weapon].SY = WEAPONBOTTOM;
	if (player->Powers[pw_weaponlevel2])
	{
		SetPsprite(player, ps_weapon, Weapon(player->ViewEnts[ps_weapon]).UpState2);
	}
	else
	{
		SetPsprite(player, ps_weapon, Weapon(player->ViewEnts[ps_weapon]).UpState);
	}
}

//===========================================================================
//
//  DropWeapon
//
//  The player died, so put the weapon away.
//
//===========================================================================

void DropWeapon(player_t * player)
{
	if (player->Powers[pw_weaponlevel2])
	{
		SetPsprite(player, ps_weapon, Weapon(player->ViewEnts[ps_weapon]).DownState2);
	}
	else
	{
		SetPsprite(player, ps_weapon, Weapon(player->ViewEnts[ps_weapon]).DownState);
	}
}

//===========================================================================
//
//  SetupPsprites
//
//  Called at start of level for each player
//
//===========================================================================

void SetupPsprites(player_t * player)
{
	int i;

	// Remove all  ViewEnts
	for (i = 0; i < NUMPSPRITES; i++)
	{
		player->ViewEnts[i].StateNum = 0;
	}
	// Spawn the ready weapon
	BringUpWeapon(player);
}

//===========================================================================
//
//  MovePsprites
//
//  Called every tic by player thinking routine
//
//===========================================================================

void MovePsprites(player_t * player)
{
	int i;
	ViewEntity e;

	for (i = 0; i < NUMPSPRITES; i++)
	{
		e = player->ViewEnts[i];
		if (e.StateNum)	// a null state means not active
		{
			// drop tic count and possibly change state
			if (e.StateTime != -1.0)	// a -1 tic count never changes
			{
				e.StateTime -= frametime;
				if (e.StateTime <= 0.0)
				{
					e.StateTime = 0.0;
					SetPsprite(player, i, e.NextState);
				}
			}
		}
	}
	player->ViewEnts[ps_flash].SX = player->ViewEnts[ps_weapon].SX;
	player->ViewEnts[ps_flash].SY = player->ViewEnts[ps_weapon].SY;
}

//===========================================================================
//
//  CheckAmmo
//
//  Returns true if there is enough ammo to shoot.  If not, selects the
// next weapon to use.
//
//===========================================================================

boolean CheckAmmo(player_t * player)
{
	int ammo;
	int *ammoUse;
	int count;

	ammo = Weapon(player->ViewEnts[ps_weapon]).Ammo;
	if (player->Powers[pw_weaponlevel2] && !deathmatch)
	{
		ammoUse = &WeaponAmmoUsePL2[0];
	}
	else
	{
		ammoUse = &WeaponAmmoUsePL1[0];
	}
	count = ammoUse[player->ReadyWeapon];
	if (ammo == am_noammo || player->Ammo[ammo] >= count)
	{
		return true;
	}
	// out of ammo, pick a weapon to change to
	do
	{
		if (player->WeaponOwned[wp_skullrod]
			&& player->Ammo[am_skullrod] > ammoUse[wp_skullrod])
		{
			player->PendingWeapon = wp_skullrod;
		}
		else if (player->WeaponOwned[wp_blaster]
			&& player->Ammo[am_blaster] > ammoUse[wp_blaster])
		{
			player->PendingWeapon = wp_blaster;
		}
		else if (player->WeaponOwned[wp_crossbow]
			&& player->Ammo[am_crossbow] > ammoUse[wp_crossbow])
		{
			player->PendingWeapon = wp_crossbow;
		}
		else if (player->WeaponOwned[wp_mace]
			&& player->Ammo[am_mace] > ammoUse[wp_mace])
		{
			player->PendingWeapon = wp_mace;
		}
		else if (player->Ammo[am_goldwand] > ammoUse[wp_goldwand])
		{
			player->PendingWeapon = wp_goldwand;
		}
		else if (player->WeaponOwned[wp_gauntlets])
		{
			player->PendingWeapon = wp_gauntlets;
		}
		else if (player->WeaponOwned[wp_phoenixrod]
			&& player->Ammo[am_phoenixrod] > ammoUse[wp_phoenixrod])
		{
			player->PendingWeapon = wp_phoenixrod;
		}
		else
		{
			player->PendingWeapon = wp_staff;
		}
	}
	while (player->PendingWeapon == wp_nochange);
	if (player->Powers[pw_weaponlevel2])
	{
		SetPsprite(player, ps_weapon, Weapon(player->ViewEnts[ps_weapon]).DownState2);
	}
	else
	{
		SetPsprite(player, ps_weapon, Weapon(player->ViewEnts[ps_weapon]).DownState);
	}
	return false;
}

//===========================================================================
//
//  FireWeapon
//
//===========================================================================

void FireWeapon(player_t * player)
{
	int attackState;

	if (!CheckAmmo(player))
	{
		return;
	}
	player->MO.SetState(PlayerPawn(player->MO).Attack2State);
	if (player->Powers[pw_weaponlevel2])
	{
		attackState = player->Refire ?
			Weapon(player->ViewEnts[ps_weapon]).HoldAttackState2 :
			Weapon(player->ViewEnts[ps_weapon]).AttackState2;
	}
	else
	{
		attackState = player->Refire ?
			Weapon(player->ViewEnts[ps_weapon]).HoldAttackState :
			Weapon(player->ViewEnts[ps_weapon]).AttackState;
	}
	SetPsprite(player, ps_weapon, attackState);
	P_NoiseAlert(player->MO, player->MO);
	if (player->ReadyWeapon == wp_gauntlets && !player->Refire)
	{
		// Play the sound for the initial gauntlet attack
		player->MO.PlaySound('GauntletUse', CHAN_WEAPON);
	}
}

//===========================================================================
//
//  ActivateBeak
//
//===========================================================================

void ActivateBeak(player_t * player)
{
	SetWeapon(player, wp_beak);
	player->ViewEnts[ps_weapon].SY = WEAPONTOP;
	SetPsprite(player, ps_weapon,
		Weapon(player->ViewEnts[ps_weapon]).ReadyState);
}

//===========================================================================
//
//  PostChickenWeapon
//
//===========================================================================

void PostChickenWeapon(player_t * player, int weapon)
{
	if (weapon == wp_beak)
	{
		// Should never happen
		weapon = wp_staff;
	}
	SetWeapon(player, weapon);
	player->ViewEnts[ps_weapon].SY = WEAPONBOTTOM;
	SetPsprite(player, ps_weapon, Weapon(player->ViewEnts[ps_weapon]).UpState);
}

//===========================================================================
//
//  UpdateBeak
//
//===========================================================================

void UpdateBeak(player_t * player, ViewEntity e)
{
	e.SY = WEAPONTOP + itof(player->ChickenPeck) / 2.0;
}

//===========================================================================
//
//  WeaponLevel2Fade
//
//===========================================================================

void WeaponLevel2Fade(player_t * player)
{
	Weapon(player->ViewEnts[ps_weapon]).WeaponLevel2Fade();
}

//****************************************************************************
//
//  WEAPON ACTIONS
//
//****************************************************************************

//===========================================================================
//
//  Weapon::A_WeaponReady
//
//  The player can fire the weapon or change to another weapon at this time.
//
//===========================================================================

void Weapon::A_WeaponReady(void)
{
	float angle;

	if (Player->ChickenTics)
	{
		// Change to the chicken beak
		ActivateBeak(Player);
		return;
	}
	// Change player from attack state
	if (Player->MO.StateNum == Player->MO.MissileState ||
		Player->MO.StateNum == PlayerPawn(Player->MO).Attack2State)
	{
		Player->MO.SetState(Player->MO.IdleState);
	}
	// Put the weapon away if the player has a pending weapon or has
	// died.
	if (Player->PendingWeapon != wp_nochange || !Player->Health)
	{
		if (Player->Powers[pw_weaponlevel2])
		{
			SetPsprite(Player, ps_weapon, DownState2);
		}
		else
		{
			SetPsprite(Player, ps_weapon, DownState);
		}
		return;
	}

	// Check for fire.  The phoenix rod does not auto fire.
	if (Player->Buttons & BT_ATTACK)
	{
		if (!Player->bAttackDown || (Player->ReadyWeapon != wp_phoenixrod))
		{
			Player->bAttackDown = true;
			FireWeapon(Player);
			return;
		}
	}
	else
	{
		Player->bAttackDown = false;
	}

	// Bob the weapon based on movement speed.
	angle = AngleMod360(180.0 * level->time);
	SX = 1.0 + Player->Bob * cos(angle);
	if (angle >= 180.0)
	{
		angle -= 180.0;
	}
	SY = WEAPONTOP + Player->Bob * sin(angle);
}

//===========================================================================
//
//  Weapon::A_Lower
//
//===========================================================================

void Weapon::A_Lower(void)
{
	if (Player->ChickenTics)
	{
		SY = WEAPONBOTTOM;
	}
	else
	{
		SY += LOWERSPEED;
	}
	if (SY < WEAPONBOTTOM)
	{
		// Not lowered all the way yet
		return;
	}
	if (Player->PlayerState == PST_DEAD)
	{
		// Player is dead, so don't bring up a pending weapon
		SY = WEAPONBOTTOM;
		return;
	}
	if (!Player->Health)
	{
		// Player is dead, so keep the weapon off screen
		SetPsprite(Player, ps_weapon, S_NULL);
		return;
	}
	Player->ReadyWeapon = Player->PendingWeapon;
	BringUpWeapon(Player);
}

//===========================================================================
//
//  Weapon::A_Raise
//
//===========================================================================

void Weapon::A_Raise(void)
{
	SY -= RAISESPEED;
	if (SY > WEAPONTOP)
	{
		// Not raised all the way yet
		return;
	}
	SY = WEAPONTOP;
	if (Player->Powers[pw_weaponlevel2])
	{
		SetPsprite(Player, ps_weapon, ReadyState2);
	}
	else
	{
		SetPsprite(Player, ps_weapon, ReadyState);
	}
}

//===========================================================================
//
//  Weapon::A_ReFire
//
//  The player can re fire the weapon without lowering it entirely.
//
//===========================================================================

void Weapon::A_ReFire(void)
{
	if ((Player->Buttons & BT_ATTACK)
		&& Player->PendingWeapon == wp_nochange && Player->Health)
	{
		Player->Refire++;
		FireWeapon(Player);
	}
	else
	{
		Player->Refire = 0;
		CheckAmmo(Player);
	}
}

//===========================================================================
//
//  Weapon::A_Light0
//
//===========================================================================

void Weapon::A_Light0(void)
{
	Player->ExtraLight = 0;
}

//****************************************************************************
//
//  WEAPON PROJECTILE ACTIONS
//
//****************************************************************************

//===========================================================================
//
//  Actor::A_BoltSpark
//
//===========================================================================

void Actor::A_BoltSpark(void)
{
	Actor spark;

	if (P_Random() > 50)
	{
		spark = Spawn(CrossbowFX4, Origin);
		spark.Origin.x += (Random() - Random()) * 4.0;
		spark.Origin.y += (Random() - Random()) * 4.0;
	}
}

//===========================================================================
//
//  Actor::A_SpawnRippers
//
//===========================================================================

void Actor::A_SpawnRippers(void)
{
	int i;
	float angle;
	Actor ripper;

	for (i = 0; i < 8; i++)
	{
		ripper = Spawn(Ripper, Origin);
		angle = itof(i) * 45.0;
		ripper.Instigator = Instigator;
		ripper.Angles.yaw = angle;
		ripper.Velocity.x = ripper.Speed * cos(angle);
		ripper.Velocity.y = ripper.Speed * sin(angle);
		ripper.CheckMissileSpawn();
	}
}

//===========================================================================
//
//  Actor::A_SkullRodPL2Seek
//
//===========================================================================

void Actor::A_SkullRodPL2Seek(void)
{
	SeekerMissile(10.0, 30.0);
}

//===========================================================================
//
//  Actor::A_AddPlayerRain
//
//===========================================================================

void Actor::A_AddPlayerRain(void)
{
	int playerNum;
	player_t *player;

	playerNum = netgame ? Special2 : 0;
	player = &players[playerNum];
	if (!player->bActive)
	{
		// Player left the game
		return;
	}
	if (player->Health <= 0)
	{
		// Player is dead
		return;
	}
	if (player->Rain1 && player->Rain2)
	{
		// Terminate an active rain
		if (player->Rain1->Health < player->Rain2->Health)
		{
			if (player->Rain1->Health > 16)
			{
				player->Rain1->Health = 16;
			}
			player->Rain1 = NULL;
		}
		else
		{
			if (player->Rain2->Health > 16)
			{
				player->Rain2->Health = 16;
			}
			player->Rain2 = NULL;
		}
	}
	// Add rain mobj to list
	if (player->Rain1)
	{
		player->Rain2 = this;
	}
	else
	{
		player->Rain1 = this;
	}
}

//===========================================================================
//
//  Actor::A_SkullRodStorm
//
//===========================================================================

void Actor::A_SkullRodStorm(void)
{
	float x;
	float y;
	Actor A;
	int playerNum;
	player_t *player;
	classid rain_type;

	if (Health-- == 0)
	{
		SetState(S_NULL);
		playerNum = netgame ? Special2 : 0;
		player = &players[playerNum];
		if (!player->bActive)
		{
			// Player left the game
			return;
		}
		if (player->Health <= 0)
		{
			// Player is dead
			return;
		}
		if (player->Rain1 == this)
		{
			player->Rain1 = NULL;
		}
		else if (player->Rain2 == this)
		{
			player->Rain2 = NULL;
		}
		return;
	}
	if (P_Random() < 25)
	{
		// Fudge rain frequency
		return;
	}
	x = Origin.x + Random() * 128.0 - 64.0;
	y = Origin.y + Random() * 128.0 - 64.0;
	switch (Special2)
	{
	case 0: rain_type = RainPlayer1; break;
	case 1: rain_type = RainPlayer2; break;
	case 2: rain_type = RainPlayer3; break;
	case 3: rain_type = RainPlayer4; break;
	}
	A = Spawn(rain_type, vector(x, y, ONCEILINGZ));
	A.Instigator = Instigator;
	A.Velocity.x = 0.00001;	// Force collision detection
	A.Velocity.z = -A.Speed;
	A.Special2 = Special2;	// Transfer player number
	A.CheckMissileSpawn();
	if (!(Special1 & 31))
	{
		PlaySound('SkullRodRain', CHAN_VOICE);
	}
	Special1++;
}

//===========================================================================
//
//  Actor::A_RainImpact
//
//===========================================================================

void Actor::A_RainImpact(void)
{
	if (Origin.z > FloorZ)
	{
		SetState(S_RAINAIRXPLR1_1 + Special2);
	}
	else if (P_Random() < 40)
	{
		HitFloorEffect();
	}
}

//===========================================================================
//
//  Actor::A_HideInCeiling
//
//===========================================================================

void Actor::A_HideInCeiling(void)
{
	Origin.z = CeilingZ + 4.0;
}

//===========================================================================
//
//  Actor::A_PhoenixPuff
//
//===========================================================================

void Actor::A_PhoenixPuff(void)
{
	Actor puff;
	float angle;

	SeekerMissile(5.0, 10.0);
	puff = Spawn(PhoenixPuff, Origin);
	angle = AngleMod360(Angles.yaw + 90.0);
	puff.Velocity.x = 1.3 * cos(angle) * 35.0;
	puff.Velocity.y = 1.3 * sin(angle) * 35.0;
	puff.Velocity.z = 0.0;
	puff = Spawn(PhoenixPuff, Origin);
	angle = AngleMod360(Angles.yaw - 90.0);
	puff.Velocity.x = 1.3 * cos(angle) * 35.0;
	puff.Velocity.y = 1.3 * sin(angle) * 35.0;
	puff.Velocity.z = 0.0;
}

//===========================================================================
//
//  Actor::A_FlameEnd
//
//===========================================================================

void Actor::A_FlameEnd(void)
{
	Velocity.z += 1.5 * 35.0;
}

//===========================================================================
//
//  Actor::A_FloatPuff
//
//===========================================================================

void Actor::A_FloatPuff(void)
{
	Velocity.z += 1.8 * 35.0;
}

//===========================================================================
//
//  Actor::A_MacePL1Check
//
//===========================================================================

void Actor::A_MacePL1Check(void)
{
	float angle;

	if (Special1 == 0)
	{
		return;
	}
	Special1 -= 4;
	if (Special1 > 0)
	{
		return;
	}
	Special1 = 0;
	bNoGravity = false;
	angle = Angles.yaw;
	Velocity.x = 7.0 * cos(angle) * 35.0;
	Velocity.y = 7.0 * sin(angle) * 35.0;
	Velocity.z -= Velocity.z / 2.0;
}

//===========================================================================
//
//  Actor::A_MaceBallImpact
//
//===========================================================================

void Actor::A_MaceBallImpact(void)
{
	if ((Origin.z <= FloorZ) && (HitFloorEffect() != FLOOR_SOLID))
	{
		// Landed in some sort of liquid
		Remove();
		return;
	}
	if ((Health != MAGIC_JUNK) && (Origin.z <= FloorZ) && Velocity.z)
	{
		// Bounce
		Health = MAGIC_JUNK;
		Velocity.z = Velocity.z * 192.0 / 256.0;
		bFloorBounce = false;
		SetState(IdleState);
		PlaySound('Bounce', CHAN_VOICE);
	}
	else
	{
		// Explode
		bNoGravity = true;
		PlaySound('MaceHit', CHAN_VOICE);
	}
}

//===========================================================================
//
//  Actor::A_MaceBallImpact2
//
//===========================================================================

void Actor::A_MaceBallImpact2(void)
{
	Actor tiny;
	float angle;

	if ((Origin.z <= FloorZ) && (HitFloorEffect() != FLOOR_SOLID))
	{
		// Landed in some sort of liquid
		Remove();
		return;
	}
	if ((Origin.z != FloorZ) || (Velocity.z < 2.0 * 35.0))
	{
		// Explode
		Velocity = vector(0.0, 0.0, 0.0);
		bNoGravity = true;
		bFloorBounce = false;
	}
	else
	{
		// Bounce
		Velocity.z = Velocity.z * 192.0 / 256.0;
		SetState(IdleState);

		tiny = Spawn(MaceFX3, Origin);
		angle = AngleMod360(Angles.yaw + 90.0);
		tiny.Instigator = Instigator;
		tiny.Angles.yaw = angle;
		tiny.Velocity.x =
			Velocity.x / 2.0 + (Velocity.z - 35.0) * cos(angle);
		tiny.Velocity.y =
			Velocity.y / 2.0 + (Velocity.z - 35.0) * sin(angle);
		tiny.Velocity.z = Velocity.z;
		tiny.CheckMissileSpawn();

		tiny = Spawn(MaceFX3, Origin);
		angle = AngleMod360(Angles.yaw - 90.0);
		tiny.Instigator = Instigator;
		tiny.Angles.yaw = angle;
		tiny.Velocity.x =
			Velocity.x / 2.0 + (Velocity.z - 35.0) * cos(angle);
		tiny.Velocity.y =
			Velocity.y / 2.0 + (Velocity.z - 35.0) * sin(angle);
		tiny.Velocity.z = Velocity.z;
		tiny.CheckMissileSpawn();
	}
}

//===========================================================================
//
//  Actor::A_DeathBallImpact
//
//===========================================================================

void Actor::A_DeathBallImpact(void)
{
	int i;
	float angle;
	int newAngle;
	TAVec angles;

	if ((Origin.z <= FloorZ) && (HitFloorEffect() != FLOOR_SOLID))
	{
		// Landed in some sort of liquid
		Remove();
		return;
	}
	if ((Origin.z <= FloorZ) && Velocity.z)
	{
		// Bounce
		newAngle = false;
		if (Enemy)
		{
			if (!Enemy.bShootable)
			{
				// Target died
				Enemy = none;
			}
			else
			{
				// Seek
				angle = atan2(Enemy.Origin.y - Origin.y,
					Enemy.Origin.x - Origin.x);
				newAngle = true;
			}
		}
		else
		{
			// Find new target
			angles.pitch = 0.0;
			angles.yaw = 0.0;
			angles.roll = 0.0;
			for (i = 0; i < 16; i++)
			{
				AimLineAttack(self, angles, 10.0 * 64.0);
				if (linetarget && Instigator != linetarget)
				{
					Enemy = linetarget;
					angle = atan2(linetarget.Origin.y - Origin.y,
						linetarget.Origin.x - Origin.x);
					newAngle = true;
					break;
				}
				angles.yaw = AngleMod360(angles.yaw + 45.0 / 2.0);
			}
		}
		if (newAngle)
		{
			Angles.yaw = angle;
			Velocity.x = Speed * cos(angle);
			Velocity.y = Speed * sin(angle);
		}
		SetState(IdleState);
		PlaySound('PlatformStop', CHAN_VOICE);
	}
	else
	{
		// Explode
		bNoGravity = true;
		PlaySound('PhoenixHit', CHAN_VOICE);
	}
}

//**************************************************************************
//**************************************************************************
//
//	WeaponStaff
//
//**************************************************************************
//**************************************************************************

class WeaponStaff:Weapon
{

//==========================================================================
//
//	WeaponLevel2Init
//
//==========================================================================

void WeaponLevel2Init(void)
{
	SetState(ReadyState2);
}

//==========================================================================
//
//	WeaponLevel2Fade
//
//==========================================================================

void WeaponLevel2Fade(void)
{
	Player->PendingWeapon = Player->ReadyWeapon;
}

//===========================================================================
//
//  A_StaffAttackPL1
//
//===========================================================================

void A_StaffAttackPL1(void)
{
	TAVec angles;
	int damage;
	TVec dir;

	damage = 5 + (P_Random() & 15);
	angles = Player->MO.Angles;
	angles.yaw = AngleMod360(angles.yaw +
		(Random() - Random()) * 45.0 / 8.0);
	dir = AimLineAttack(Player->MO, angles, MELEERANGE);
	PuffType = StaffPuff;
	LineAttack(Player->MO, dir, MELEERANGE, damage);
	if (linetarget)
	{
		// turn to face target
		Player->MO.Angles.yaw =
			atan2(linetarget.Origin.y - Player->MO.Origin.y,
			linetarget.Origin.x - Player->MO.Origin.x);
		Player->bFixAngle = true;
	}
}

//===========================================================================
//
//  A_StaffAttackPL2
//
//===========================================================================

void A_StaffAttackPL2(void)
{
	TAVec angles;
	int damage;
	TVec dir;

	// P_inter.c:DamageMobj() handles target momentums
	damage = 18 + (P_Random() & 63);

	angles = Player->MO.Angles;
	angles.yaw = AngleMod360(angles.yaw +
		(Random() - Random()) * 45.0 / 8.0);
	dir = AimLineAttack(Player->MO, angles, MELEERANGE);
	PuffType = StaffPuff2;
	LineAttack(Player->MO, dir, MELEERANGE, damage);
	if (linetarget)
	{
		// turn to face target
		Player->MO.Angles.yaw =
			atan2(linetarget.Origin.y - Player->MO.Origin.y,
			linetarget.Origin.x - Player->MO.Origin.x);
		Player->bFixAngle = true;
	}
}

__states__
{
	S_STAFFREADY('STFF', 0, 1.0 / 35.0, S_STAFFREADY) { A_WeaponReady(); }
	S_STAFFDOWN('STFF', 0, 1.0 / 35.0, S_STAFFDOWN) { A_Lower(); }
	S_STAFFUP('STFF', 0, 1.0 / 35.0, S_STAFFUP) { A_Raise(); }
	S_STAFFREADY2_1('STFF', 3, 4.0 / 35.0, S_STAFFREADY2_2)
	{
		// Check for staff PL2 active sound
		if (Random() < 0.5)
		{
			Player->MO.PlaySound('StaffActive', CHAN_WEAPON);
		}
		A_WeaponReady();
	}
	S_STAFFREADY2_2('STFF', 4, 4.0 / 35.0, S_STAFFREADY2_3) { A_WeaponReady(); }
	S_STAFFREADY2_3('STFF', 5, 4.0 / 35.0, S_STAFFREADY2_1) { A_WeaponReady(); }
	S_STAFFDOWN2('STFF', 3, 1.0 / 35.0, S_STAFFDOWN2) { A_Lower(); }
	S_STAFFUP2('STFF', 3, 1.0 / 35.0, S_STAFFUP2) { A_Raise(); }
	S_STAFFATK1_1('STFF', 1, 6.0 / 35.0, S_STAFFATK1_2) { }
	S_STAFFATK1_2('STFF', 2, 8.0 / 35.0, S_STAFFATK1_3) { A_StaffAttackPL1(); }
	S_STAFFATK1_3('STFF', 1, 8.0 / 35.0, S_STAFFREADY) { A_ReFire(); }
	S_STAFFATK2_1('STFF', 6, 6.0 / 35.0, S_STAFFATK2_2) { }
	S_STAFFATK2_2('STFF', 7, 8.0 / 35.0, S_STAFFATK2_3) { A_StaffAttackPL2(); }
	S_STAFFATK2_3('STFF', 6, 8.0 / 35.0, S_STAFFREADY2_1) { A_ReFire(); }
}

defaultproperties
{
	Ammo = am_noammo;
	UpState = S_STAFFUP;
	DownState = S_STAFFDOWN;
	ReadyState = S_STAFFREADY;
	AttackState = S_STAFFATK1_1;
	HoldAttackState = S_STAFFATK1_1;
	UpState2 = S_STAFFUP2;
	DownState2 = S_STAFFDOWN2;
	ReadyState2 = S_STAFFREADY2_1;
	AttackState2 = S_STAFFATK2_1;
	HoldAttackState2 = S_STAFFATK2_1;
	PSpriteSY = 0.0;
}

}

//**************************************************************************
//**************************************************************************
//
//	WeaponGauntlets
//
//**************************************************************************
//**************************************************************************

class WeaponGauntlets:Weapon
{

//==========================================================================
//
//	WeaponLevel2Init
//
//==========================================================================

void WeaponLevel2Init(void)
{
	SetState(ReadyState2);
}

//==========================================================================
//
//	WeaponLevel2Fade
//
//==========================================================================

void WeaponLevel2Fade(void)
{
	Player->PendingWeapon = Player->ReadyWeapon;
}

//===========================================================================
//
//  A_GauntletAttack
//
//===========================================================================

void A_GauntletAttack(void)
{
	float angle;
	int damage;
	float slope;
	int randVal;
	float dist;
	TAVec angles;
	TVec dir;

	SX = Random() * 4.0 - 2.0;
	SY = WEAPONTOP + Random() * 4.0;
	angles = Player->MO.Angles;
	if (Player->Powers[pw_weaponlevel2])
	{
		damage = HITDICE(2);
		dist = 4.0 * MELEERANGE;
		angles.yaw = AngleMod360(angles.yaw +
			(Random() - Random()) * 45.0 / 16.0);
		PuffType = GauntletPuff2;
	}
	else
	{
		damage = HITDICE(2);
		dist = MELEERANGE + 0.00001;
		angles.yaw = AngleMod360(angles.yaw +
			(Random() - Random()) * 45.0 / 8.0);
		PuffType = GauntletPuff1;
	}
	dir = AimLineAttack(Player->MO, angles, dist);
	LineAttack(Player->MO, dir, dist, damage);
	if (!linetarget)
	{
		if (P_Random() > 64)
		{
			Player->ExtraLight = !Player->ExtraLight;
		}
		Player->MO.PlaySound('GauntletFull', CHAN_WEAPON);
		return;
	}
	randVal = P_Random();
	if (randVal < 64)
	{
		Player->ExtraLight = 0;
	}
	else if (randVal < 160)
	{
		Player->ExtraLight = 1;
	}
	else
	{
		Player->ExtraLight = 2;
	}
	if (Player->Powers[pw_weaponlevel2])
	{
		PlayerPawn(Player->MO).GiveBody(damage >> 1);
		Player->MO.PlaySound('GauntletHit2', CHAN_WEAPON);
	}
	else
	{
		Player->MO.PlaySound('GauntletHit', CHAN_WEAPON);
	}
	// turn to face target
	angle = atan2(linetarget.Origin.y - Player->MO.Origin.y,
		linetarget.Origin.x - Player->MO.Origin.x);
	if (AngleMod360(angle - Player->MO.Angles.yaw) > 180.0)
	{
		if (AngleMod360(angle - Player->MO.Angles.yaw) < 360.0 - 90.0 / 20.0)
			Player->MO.Angles.yaw = AngleMod360(angle + 90.0 / 21.0);
		else
			Player->MO.Angles.yaw = AngleMod360(Player->MO.Angles.yaw - 90.0 / 20.0);
	}
	else
	{
		if (AngleMod360(angle - Player->MO.Angles.yaw) > 90.0 / 20.0)
			Player->MO.Angles.yaw = AngleMod360(angle - 90.0 / 21.0);
		else
			Player->MO.Angles.yaw = AngleMod360(Player->MO.Angles.yaw + 90.0 / 20.0);
	}
	Player->MO.bJustAttacked = true;
}

__states__
{
	S_GAUNTLETREADY('GAUN', 0, 1.0 / 35.0, S_GAUNTLETREADY) { A_WeaponReady(); }
	S_GAUNTLETDOWN('GAUN', 0, 1.0 / 35.0, S_GAUNTLETDOWN) { A_Lower(); }
	S_GAUNTLETUP('GAUN', 0, 1.0 / 35.0, S_GAUNTLETUP) { A_Raise(); }
	S_GAUNTLETREADY2_1('GAUN', 6, 4.0 / 35.0, S_GAUNTLETREADY2_2) { A_WeaponReady(); }
	S_GAUNTLETREADY2_2('GAUN', 7, 4.0 / 35.0, S_GAUNTLETREADY2_3) { A_WeaponReady(); }
	S_GAUNTLETREADY2_3('GAUN', 8, 4.0 / 35.0, S_GAUNTLETREADY2_1) { A_WeaponReady(); }
	S_GAUNTLETDOWN2('GAUN', 6, 1.0 / 35.0, S_GAUNTLETDOWN2) { A_Lower(); }
	S_GAUNTLETUP2('GAUN', 6, 1.0 / 35.0, S_GAUNTLETUP2) { A_Raise(); }
	S_GAUNTLETATK1_1('GAUN', 1, 4.0 / 35.0, S_GAUNTLETATK1_2) { }
	S_GAUNTLETATK1_2('GAUN', 2, 4.0 / 35.0, S_GAUNTLETATK1_3) { }
	S_GAUNTLETATK1_3('GAUN', 3 | FF_FULLBRIGHT, 4.0 / 35.0, S_GAUNTLETATK1_4) { A_GauntletAttack(); }
	S_GAUNTLETATK1_4('GAUN', 4 | FF_FULLBRIGHT, 4.0 / 35.0, S_GAUNTLETATK1_5) { A_GauntletAttack(); }
	S_GAUNTLETATK1_5('GAUN', 5 | FF_FULLBRIGHT, 4.0 / 35.0, S_GAUNTLETATK1_6) { A_GauntletAttack(); }
	S_GAUNTLETATK1_6('GAUN', 2, 4.0 / 35.0, S_GAUNTLETATK1_7) { A_ReFire(); }
	S_GAUNTLETATK1_7('GAUN', 1, 4.0 / 35.0, S_GAUNTLETREADY) { A_Light0(); }
	S_GAUNTLETATK2_1('GAUN', 9, 4.0 / 35.0, S_GAUNTLETATK2_2) { }
	S_GAUNTLETATK2_2('GAUN', 10, 4.0 / 35.0, S_GAUNTLETATK2_3) { }
	S_GAUNTLETATK2_3('GAUN', 11 | FF_FULLBRIGHT, 4.0 / 35.0, S_GAUNTLETATK2_4) { A_GauntletAttack(); }
	S_GAUNTLETATK2_4('GAUN', 12 | FF_FULLBRIGHT, 4.0 / 35.0, S_GAUNTLETATK2_5) { A_GauntletAttack(); }
	S_GAUNTLETATK2_5('GAUN', 13 | FF_FULLBRIGHT, 4.0 / 35.0, S_GAUNTLETATK2_6) { A_GauntletAttack(); }
	S_GAUNTLETATK2_6('GAUN', 10, 4.0 / 35.0, S_GAUNTLETATK2_7) { A_ReFire(); }
	S_GAUNTLETATK2_7('GAUN', 9, 4.0 / 35.0, S_GAUNTLETREADY2_1) { A_Light0(); }
}

defaultproperties
{
	Ammo = am_noammo;
	UpState = S_GAUNTLETUP;
	DownState = S_GAUNTLETDOWN;
	ReadyState = S_GAUNTLETREADY;
	AttackState = S_GAUNTLETATK1_1;
	HoldAttackState = S_GAUNTLETATK1_3;
	UpState2 = S_GAUNTLETUP2;
	DownState2 = S_GAUNTLETDOWN2;
	ReadyState2 = S_GAUNTLETREADY2_1;
	AttackState2 = S_GAUNTLETATK2_1;
	HoldAttackState2 = S_GAUNTLETATK2_3;
	PSpriteSY = 15.0;
}

}

//**************************************************************************
//**************************************************************************
//
//	WeaponGoldWand
//
//**************************************************************************
//**************************************************************************

class WeaponGoldWand:Weapon
{

//===========================================================================
//
//  A_FireGoldWandPL1
//
//===========================================================================

void A_FireGoldWandPL1(void)
{
	int damage;
	TVec dir;

	Player->Ammo[am_goldwand] -= USE_GWND_AMMO_1;
	damage = 7 + (P_Random() & 7);
	dir = Aim(Player->MO, Player->MO.Angles.yaw, 16.0 * 64.0);
	if (Player->Refire)
	{
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 8.0);
	}
	PuffType = GoldWandPuff1;
	LineAttack(Player->MO, dir, MISSILERANGE, damage);
	Player->MO.PlaySound('GoldWandFire', CHAN_WEAPON);
}

//===========================================================================
//
//  A_FireGoldWandPL2
//
//===========================================================================

void A_FireGoldWandPL2(void)
{
	int i;
	int damage;
	float momz;
	TAVec angles;
	TVec dir;

	Player->Ammo[am_goldwand] -=
		deathmatch ? USE_GWND_AMMO_1 : USE_GWND_AMMO_2;
	PuffType = GoldWandPuff2;
	dir = Aim(Player->MO, Player->MO.Angles.yaw, 16.0 * 64.0);
	VectorAngles(&dir, &angles);
	Player->MO.SpawnMissileAngles(GoldWandMissile2,
		AngleMod360(angles.yaw - (45.0 / 8.0)), angles.pitch);
	Player->MO.SpawnMissileAngles(GoldWandMissile2,
		AngleMod360(angles.yaw + (45.0 / 8.0)), angles.pitch);
	VectorRotateAroundZ(&dir, -45.0 / 8.0);
	for (i = 0; i < 5; i++)
	{
		damage = 1 + (P_Random() & 7);
		LineAttack(Player->MO, dir, MISSILERANGE, damage);
		VectorRotateAroundZ(&dir, (45.0 / 8.0) / 2.0);
	}
	Player->MO.PlaySound('GoldWandFire', CHAN_WEAPON);
}

__states__
{
	S_GOLDWANDREADY('GWND', 0, 1.0 / 35.0, S_GOLDWANDREADY) { A_WeaponReady(); }
	S_GOLDWANDDOWN('GWND', 0, 1.0 / 35.0, S_GOLDWANDDOWN) { A_Lower(); }
	S_GOLDWANDUP('GWND', 0, 1.0 / 35.0, S_GOLDWANDUP) { A_Raise(); }
	S_GOLDWANDATK1_1('GWND', 1, 3.0 / 35.0, S_GOLDWANDATK1_2) { }
	S_GOLDWANDATK1_2('GWND', 2, 5.0 / 35.0, S_GOLDWANDATK1_3) { A_FireGoldWandPL1(); }
	S_GOLDWANDATK1_3('GWND', 3, 3.0 / 35.0, S_GOLDWANDATK1_4) { }
	S_GOLDWANDATK1_4('GWND', 3, 0.0 / 35.0, S_GOLDWANDREADY) { A_ReFire(); }
	S_GOLDWANDATK2_1('GWND', 1, 3.0 / 35.0, S_GOLDWANDATK2_2) { }
	S_GOLDWANDATK2_2('GWND', 2, 4.0 / 35.0, S_GOLDWANDATK2_3) { A_FireGoldWandPL2(); }
	S_GOLDWANDATK2_3('GWND', 3, 3.0 / 35.0, S_GOLDWANDATK2_4) { }
	S_GOLDWANDATK2_4('GWND', 3, 0.0 / 35.0, S_GOLDWANDREADY) { A_ReFire(); }
}

defaultproperties
{
	Ammo = am_goldwand;
	UpState = S_GOLDWANDUP;
	DownState = S_GOLDWANDDOWN;
	ReadyState = S_GOLDWANDREADY;
	AttackState = S_GOLDWANDATK1_1;
	HoldAttackState = S_GOLDWANDATK1_1;
	UpState2 = S_GOLDWANDUP;
	DownState2 = S_GOLDWANDDOWN;
	ReadyState2 = S_GOLDWANDREADY;
	AttackState2 = S_GOLDWANDATK2_1;
	HoldAttackState2 = S_GOLDWANDATK2_1;
	PSpriteSY = 5.0;
}

}

//**************************************************************************
//**************************************************************************
//
//	WeaponCrossbow
//
//**************************************************************************
//**************************************************************************

class WeaponCrossbow:Weapon
{

//===========================================================================
//
//  A_FireCrossbowPL1
//
//===========================================================================

void A_FireCrossbowPL1(void)
{
	Player->Ammo[am_crossbow] -= USE_CBOW_AMMO_1;
	Player->MO.SpawnPlayerMissile(CrossbowFX1);
	Player->MO.SpawnPlayerMissileAngle(CrossbowFX3,
		AngleMod360(Player->MO.Angles.yaw - (45.0 / 10.0)));
	Player->MO.SpawnPlayerMissileAngle(CrossbowFX3,
		AngleMod360(Player->MO.Angles.yaw + (45.0 / 10.0)));
}

//===========================================================================
//
//  A_FireCrossbowPL2
//
//===========================================================================

void A_FireCrossbowPL2(void)
{
	Player->Ammo[am_crossbow] -=
		deathmatch ? USE_CBOW_AMMO_1 : USE_CBOW_AMMO_2;
	Player->MO.SpawnPlayerMissile(CrossbowFX2);
	Player->MO.SpawnPlayerMissileAngle(CrossbowFX2,
		AngleMod360(Player->MO.Angles.yaw - (45.0 / 10.0)));
	Player->MO.SpawnPlayerMissileAngle(CrossbowFX2,
		AngleMod360(Player->MO.Angles.yaw + (45.0 / 10.0)));
	Player->MO.SpawnPlayerMissileAngle(CrossbowFX3,
		AngleMod360(Player->MO.Angles.yaw - (45.0 / 5.0)));
	Player->MO.SpawnPlayerMissileAngle(CrossbowFX3,
		AngleMod360(Player->MO.Angles.yaw + (45.0 / 5.0)));
}

__states__
{
	S_CRBOW1('CRBW', 0, 1.0 / 35.0, S_CRBOW2) { A_WeaponReady(); }
	S_CRBOW2('CRBW', 0, 1.0 / 35.0, S_CRBOW3) { A_WeaponReady(); }
	S_CRBOW3('CRBW', 0, 1.0 / 35.0, S_CRBOW4) { A_WeaponReady(); }
	S_CRBOW4('CRBW', 0, 1.0 / 35.0, S_CRBOW5) { A_WeaponReady(); }
	S_CRBOW5('CRBW', 0, 1.0 / 35.0, S_CRBOW6) { A_WeaponReady(); }
	S_CRBOW6('CRBW', 0, 1.0 / 35.0, S_CRBOW7) { A_WeaponReady(); }
	S_CRBOW7('CRBW', 1, 1.0 / 35.0, S_CRBOW8) { A_WeaponReady(); }
	S_CRBOW8('CRBW', 1, 1.0 / 35.0, S_CRBOW9) { A_WeaponReady(); }
	S_CRBOW9('CRBW', 1, 1.0 / 35.0, S_CRBOW10) { A_WeaponReady(); }
	S_CRBOW10('CRBW', 1, 1.0 / 35.0, S_CRBOW11) { A_WeaponReady(); }
	S_CRBOW11('CRBW', 1, 1.0 / 35.0, S_CRBOW12) { A_WeaponReady(); }
	S_CRBOW12('CRBW', 1, 1.0 / 35.0, S_CRBOW13) { A_WeaponReady(); }
	S_CRBOW13('CRBW', 2, 1.0 / 35.0, S_CRBOW14) { A_WeaponReady(); }
	S_CRBOW14('CRBW', 2, 1.0 / 35.0, S_CRBOW15) { A_WeaponReady(); }
	S_CRBOW15('CRBW', 2, 1.0 / 35.0, S_CRBOW16) { A_WeaponReady(); }
	S_CRBOW16('CRBW', 2, 1.0 / 35.0, S_CRBOW17) { A_WeaponReady(); }
	S_CRBOW17('CRBW', 2, 1.0 / 35.0, S_CRBOW18) { A_WeaponReady(); }
	S_CRBOW18('CRBW', 2, 1.0 / 35.0, S_CRBOW1) { A_WeaponReady(); }
	S_CRBOWDOWN('CRBW', 0, 1.0 / 35.0, S_CRBOWDOWN) { A_Lower(); }
	S_CRBOWUP('CRBW', 0, 1.0 / 35.0, S_CRBOWUP) { A_Raise(); }
	S_CRBOWATK1_1('CRBW', 3, 6.0 / 35.0, S_CRBOWATK1_2) { A_FireCrossbowPL1(); }
	S_CRBOWATK1_2('CRBW', 4, 3.0 / 35.0, S_CRBOWATK1_3) { }
	S_CRBOWATK1_3('CRBW', 5, 3.0 / 35.0, S_CRBOWATK1_4) { }
	S_CRBOWATK1_4('CRBW', 6, 3.0 / 35.0, S_CRBOWATK1_5) { }
	S_CRBOWATK1_5('CRBW', 7, 3.0 / 35.0, S_CRBOWATK1_6) { }
	S_CRBOWATK1_6('CRBW', 0, 4.0 / 35.0, S_CRBOWATK1_7) { }
	S_CRBOWATK1_7('CRBW', 1, 4.0 / 35.0, S_CRBOWATK1_8) { }
	S_CRBOWATK1_8('CRBW', 2, 5.0 / 35.0, S_CRBOW1) { A_ReFire(); }
	S_CRBOWATK2_1('CRBW', 3, 5.0 / 35.0, S_CRBOWATK2_2) { A_FireCrossbowPL2(); }
	S_CRBOWATK2_2('CRBW', 4, 3.0 / 35.0, S_CRBOWATK2_3) { }
	S_CRBOWATK2_3('CRBW', 5, 2.0 / 35.0, S_CRBOWATK2_4) { }
	S_CRBOWATK2_4('CRBW', 6, 3.0 / 35.0, S_CRBOWATK2_5) { }
	S_CRBOWATK2_5('CRBW', 7, 2.0 / 35.0, S_CRBOWATK2_6) { }
	S_CRBOWATK2_6('CRBW', 0, 3.0 / 35.0, S_CRBOWATK2_7) { }
	S_CRBOWATK2_7('CRBW', 1, 3.0 / 35.0, S_CRBOWATK2_8) { }
	S_CRBOWATK2_8('CRBW', 2, 4.0 / 35.0, S_CRBOW1) { A_ReFire(); }
}

defaultproperties
{
	Ammo = am_crossbow;
	UpState = S_CRBOWUP;
	DownState = S_CRBOWDOWN;
	ReadyState = S_CRBOW1;
	AttackState = S_CRBOWATK1_1;
	HoldAttackState = S_CRBOWATK1_1;
	UpState2 = S_CRBOWUP;
	DownState2 = S_CRBOWDOWN;
	ReadyState2 = S_CRBOW1;
	AttackState2 = S_CRBOWATK2_1;
	HoldAttackState2 = S_CRBOWATK2_1;
	PSpriteSY = 15.0;
}

}

//**************************************************************************
//**************************************************************************
//
//	WeaponBlaster
//
//**************************************************************************
//**************************************************************************

class WeaponBlaster:Weapon
{

//===========================================================================
//
//  A_FireBlasterPL1
//
//===========================================================================

void A_FireBlasterPL1(void)
{
	int damage;
	float bulletslope;
	TVec dir;

	Player->MO.PlaySound('GoldWandFire', CHAN_WEAPON);
	Player->Ammo[am_blaster] -= USE_BLSR_AMMO_1;
	dir = Aim(Player->MO, Player->MO.Angles.yaw, 16.0 * 64.0);
	damage = HITDICE(4);
	if (Player->Refire)
	{
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 8.0);
	}
	PuffType = BlasterPuff1;
	LineAttack(Player->MO, dir, MISSILERANGE, damage);
	Player->MO.PlaySound('BlasterFire', CHAN_WEAPON);
}

//===========================================================================
//
//  A_FireBlasterPL2
//
//===========================================================================

void A_FireBlasterPL2(void)
{
	Actor A;

	Player->Ammo[am_blaster] -=
		deathmatch ? USE_BLSR_AMMO_1 : USE_BLSR_AMMO_2;
	A = Player->MO.SpawnPlayerMissile(BlasterFX1);
	if (A)
	{
		A.bBlaster = true;
	}
	Player->MO.PlaySound('BlasterFire', CHAN_WEAPON);
}

__states__
{
	S_BLASTERREADY('BLSR', 0, 1.0 / 35.0, S_BLASTERREADY) { A_WeaponReady(); }
	S_BLASTERDOWN('BLSR', 0, 1.0 / 35.0, S_BLASTERDOWN) { A_Lower(); }
	S_BLASTERUP('BLSR', 0, 1.0 / 35.0, S_BLASTERUP) { A_Raise(); }
	S_BLASTERATK1_1('BLSR', 1, 3.0 / 35.0, S_BLASTERATK1_2) { }
	S_BLASTERATK1_2('BLSR', 2, 3.0 / 35.0, S_BLASTERATK1_3) { }
	S_BLASTERATK1_3('BLSR', 3, 2.0 / 35.0, S_BLASTERATK1_4) { A_FireBlasterPL1(); }
	S_BLASTERATK1_4('BLSR', 2, 2.0 / 35.0, S_BLASTERATK1_5) { }
	S_BLASTERATK1_5('BLSR', 1, 2.0 / 35.0, S_BLASTERATK1_6) { }
	S_BLASTERATK1_6('BLSR', 0, 0.0 / 35.0, S_BLASTERREADY) { A_ReFire(); }
	S_BLASTERATK2_1('BLSR', 1, 0.0 / 35.0, S_BLASTERATK2_2) { }
	S_BLASTERATK2_2('BLSR', 2, 0.0 / 35.0, S_BLASTERATK2_3) { }
	S_BLASTERATK2_3('BLSR', 3, 3.0 / 35.0, S_BLASTERATK2_4) { A_FireBlasterPL2(); }
	S_BLASTERATK2_4('BLSR', 2, 4.0 / 35.0, S_BLASTERATK2_5) { }
	S_BLASTERATK2_5('BLSR', 1, 4.0 / 35.0, S_BLASTERATK2_6) { }
	S_BLASTERATK2_6('BLSR', 0, 0.0 / 35.0, S_BLASTERREADY) { A_ReFire(); }
}

defaultproperties
{
	Ammo = am_blaster;
	UpState = S_BLASTERUP;
	DownState = S_BLASTERDOWN;
	ReadyState = S_BLASTERREADY;
	AttackState = S_BLASTERATK1_1;
	HoldAttackState = S_BLASTERATK1_3;
	UpState2 = S_BLASTERUP;
	DownState2 = S_BLASTERDOWN;
	ReadyState2 = S_BLASTERREADY;
	AttackState2 = S_BLASTERATK2_1;
	HoldAttackState2 = S_BLASTERATK2_3;
	PSpriteSY = 15.0;
}

}

//**************************************************************************
//**************************************************************************
//
//	WeaponSkullRod
//
//**************************************************************************
//**************************************************************************

class WeaponSkullRod:Weapon
{

//===========================================================================
//
//  A_FireSkullRodPL1
//
//===========================================================================

void A_FireSkullRodPL1(void)
{
	Actor A;

	if (Player->Ammo[am_skullrod] < USE_SKRD_AMMO_1)
	{
		return;
	}
	Player->Ammo[am_skullrod] -= USE_SKRD_AMMO_1;
	A = Player->MO.SpawnPlayerMissile(HornRodMissile1);
	// Randomize the first frame
	if (A && P_Random() > 128)
	{
		A.SetState(S_HRODFX1_2);
	}
}

//===========================================================================
//
//  A_FireSkullRodPL2
//
//  The special2 field holds the player number that shot the rain missile.
// The specialmobj1 field is used for the seeking routines, special1 as a
// counter for the sound looping.
//
//===========================================================================

void A_FireSkullRodPL2(void)
{
	Player->Ammo[am_skullrod] -=
		deathmatch ? USE_SKRD_AMMO_1 : USE_SKRD_AMMO_2;
	Player->MO.SpawnPlayerMissile(HornRodMissile2);
	// Use MissileMobj instead of the return value from
	// SpawnPlayerMissile because we need to give info to the mobj
	// even if it exploded immediately.
	if (netgame)
	{
		// Multi-player game
		MissileMobj.Special2 = P_GetPlayerNum(Player);
	}
	else
	{
		// Always use red missiles in single player games
		MissileMobj.Special2 = 2;
	}
	if (linetarget)
	{
		MissileMobj.Enemy = linetarget;
	}
	MissileMobj.PlaySound('SkullRodFire2', CHAN_WEAPON);
}

__states__
{
	S_HORNRODREADY('HROD', 0, 1.0 / 35.0, S_HORNRODREADY) { A_WeaponReady(); }
	S_HORNRODDOWN('HROD', 0, 1.0 / 35.0, S_HORNRODDOWN) { A_Lower(); }
	S_HORNRODUP('HROD', 0, 1.0 / 35.0, S_HORNRODUP) { A_Raise(); }
	S_HORNRODATK1_1('HROD', 0, 4.0 / 35.0, S_HORNRODATK1_2) { A_FireSkullRodPL1(); }
	S_HORNRODATK1_2('HROD', 1, 4.0 / 35.0, S_HORNRODATK1_3) { A_FireSkullRodPL1(); }
	S_HORNRODATK1_3('HROD', 1, 0.0 / 35.0, S_HORNRODREADY) { A_ReFire(); }
	S_HORNRODATK2_1('HROD', 2, 2.0 / 35.0, S_HORNRODATK2_2) { }
	S_HORNRODATK2_2('HROD', 3, 3.0 / 35.0, S_HORNRODATK2_3) { }
	S_HORNRODATK2_3('HROD', 4, 2.0 / 35.0, S_HORNRODATK2_4) { }
	S_HORNRODATK2_4('HROD', 5, 3.0 / 35.0, S_HORNRODATK2_5) { }
	S_HORNRODATK2_5('HROD', 6, 4.0 / 35.0, S_HORNRODATK2_6) { A_FireSkullRodPL2(); }
	S_HORNRODATK2_6('HROD', 5, 2.0 / 35.0, S_HORNRODATK2_7) { }
	S_HORNRODATK2_7('HROD', 4, 3.0 / 35.0, S_HORNRODATK2_8) { }
	S_HORNRODATK2_8('HROD', 3, 2.0 / 35.0, S_HORNRODATK2_9) { }
	S_HORNRODATK2_9('HROD', 2, 2.0 / 35.0, S_HORNRODREADY) { A_ReFire(); }
}

defaultproperties
{
	Ammo = am_skullrod;
	UpState = S_HORNRODUP;
	DownState = S_HORNRODDOWN;
	ReadyState = S_HORNRODREADY;
	AttackState = S_HORNRODATK1_1;
	HoldAttackState = S_HORNRODATK1_1;
	UpState2 = S_HORNRODUP;
	DownState2 = S_HORNRODDOWN;
	ReadyState2 = S_HORNRODREADY;
	AttackState2 = S_HORNRODATK2_1;
	HoldAttackState2 = S_HORNRODATK2_1;
	PSpriteSY = 15.0;
}

}

//**************************************************************************
//**************************************************************************
//
//	WeaponPhoenixRod
//
//**************************************************************************
//**************************************************************************

class WeaponPhoenixRod:Weapon
{

int Attack2ShutdownState;

//==========================================================================
//
//	WeaponLevel2Fade
//
//==========================================================================

void WeaponLevel2Fade(void)
{
	if (StateNum != ReadyState2 && StateNum != UpState2)
	{
		SetState(ReadyState);
		Player->Ammo[am_phoenixrod] -= USE_PHRD_AMMO_2;
		Player->Refire = 0;
	}
}

//===========================================================================
//
//  A_FirePhoenixPL1
//
//===========================================================================

void A_FirePhoenixPL1(void)
{
	TVec vforward;

	Player->Ammo[am_phoenixrod] -= USE_PHRD_AMMO_1;
	Player->MO.SpawnPlayerMissile(PhoenixFX1);
	AngleVector(&Player->MO.Angles, &vforward);
	Player->MO.Velocity -= vforward * 140.0;
}

//===========================================================================
//
//  A_InitPhoenixPL2
//
//===========================================================================

void A_InitPhoenixPL2(void)
{
	Player->FlameCount = ftoi(FLAME_THROWER_TIME * 35.0);
}

//===========================================================================
//
//  A_FirePhoenixPL2
//
//  Flame thrower effect.
//
//===========================================================================

void A_FirePhoenixPL2(void)
{
	Actor A;
	TVec dir;
	TVec org;

	if (--Player->FlameCount == 0)
	{
		// Out of flame
		SetState(Attack2ShutdownState);
		Player->Refire = 0;
		return;
	}
	org.x = Player->MO.Origin.x + (Random() - Random()) * 2.0;
	org.y = Player->MO.Origin.y + (Random() - Random()) * 2.0;
	org.z = Player->MO.Origin.z + 26.0 - sin(Player->MO.Angles.pitch);
	org.z -= Player->MO.FloorClip;
	A = Spawn(PhoenixFX2, org);
	A.Instigator = Player->MO;
	A.Angles.yaw = Player->MO.Angles.yaw;
	A.Angles.pitch = Player->MO.Angles.pitch;
	AngleVector(&A.Angles, &dir);
	A.Velocity = Player->MO.Velocity + A.Speed * dir;
	if (!Player->Refire || !(level->tictime % 38))
	{
		Player->MO.PlaySound('PhoenixHit2', CHAN_WEAPON);
	}
	A.CheckMissileSpawn();
}

//===========================================================================
//
//  A_ShutdownPhoenixPL2
//
//===========================================================================

void A_ShutdownPhoenixPL2(void)
{
	Player->Ammo[am_phoenixrod] -= USE_PHRD_AMMO_2;
}

__states__
{
	S_PHOENIXREADY('PHNX', 0, 1.0 / 35.0, S_PHOENIXREADY) { A_WeaponReady(); }
	S_PHOENIXDOWN('PHNX', 0, 1.0 / 35.0, S_PHOENIXDOWN) { A_Lower(); }
	S_PHOENIXUP('PHNX', 0, 1.0 / 35.0, S_PHOENIXUP) { A_Raise(); }
	S_PHOENIXATK1_1('PHNX', 1, 5.0 / 35.0, S_PHOENIXATK1_2) { }
	S_PHOENIXATK1_2('PHNX', 2, 7.0 / 35.0, S_PHOENIXATK1_3) { A_FirePhoenixPL1(); }
	S_PHOENIXATK1_3('PHNX', 3, 4.0 / 35.0, S_PHOENIXATK1_4) { }
	S_PHOENIXATK1_4('PHNX', 1, 4.0 / 35.0, S_PHOENIXATK1_5) { }
	S_PHOENIXATK1_5('PHNX', 1, 0.0 / 35.0, S_PHOENIXREADY) { A_ReFire(); }
	S_PHOENIXATK2_1('PHNX', 1, 3.0 / 35.0, S_PHOENIXATK2_2) { A_InitPhoenixPL2(); }
	S_PHOENIXATK2_2('PHNX', 2 | FF_FULLBRIGHT, 1.0 / 35.0, S_PHOENIXATK2_3) { A_FirePhoenixPL2(); }
	S_PHOENIXATK2_3('PHNX', 1, 4.0 / 35.0, S_PHOENIXATK2_4) { A_ReFire(); }
	S_PHOENIXATK2_4('PHNX', 1, 4.0 / 35.0, S_PHOENIXREADY) { A_ShutdownPhoenixPL2(); }
}

defaultproperties
{
	Ammo = am_phoenixrod;
	UpState = S_PHOENIXUP;
	DownState = S_PHOENIXDOWN;
	ReadyState = S_PHOENIXREADY;
	AttackState = S_PHOENIXATK1_1;
	HoldAttackState = S_PHOENIXATK1_1;
	UpState2 = S_PHOENIXUP;
	DownState2 = S_PHOENIXDOWN;
	ReadyState2 = S_PHOENIXREADY;
	AttackState2 = S_PHOENIXATK2_1;
	HoldAttackState2 = S_PHOENIXATK2_2;
	Attack2ShutdownState = S_PHOENIXATK2_4;
	PSpriteSY = 15.0;
}

}

//**************************************************************************
//**************************************************************************
//
//	WeaponMace
//
//**************************************************************************
//**************************************************************************

class WeaponMace:Weapon
{

//===========================================================================
//
//	A_FireMacePL1B
//
//===========================================================================

void A_FireMacePL1B(void)
{
	Actor ball;
	float angle;

	if (Player->Ammo[am_mace] < USE_MACE_AMMO_1)
	{
		return;
	}
	Player->Ammo[am_mace] -= USE_MACE_AMMO_1;
	ball = Spawn(MaceFX2, Player->MO.Origin +
		vector(0.0, 0.0, 28.0 - Player->MO.FloorClip));
	ball.Velocity.z =
		(2.0 + 173.0 * -tan(Player->MO.Angles.pitch) / 32.0) * 35.0;
	angle = Player->MO.Angles.yaw;
	ball.Instigator = Player->MO;
	ball.Angles.yaw = angle;
	ball.Origin.z += 173.0 * -tan(Player->MO.Angles.pitch) / 16.0;
	ball.Velocity.x = Player->MO.Velocity.x / 2.0 + ball.Speed * cos(angle);
	ball.Velocity.y = Player->MO.Velocity.y / 2.0 + ball.Speed * sin(angle);
	ball.PlaySound('MaceFire', CHAN_WEAPON);
	ball.CheckMissileSpawn();
}

//===========================================================================
//
//  A_FireMacePL1
//
//===========================================================================

void A_FireMacePL1(void)
{
	Actor ball;

	if (P_Random() < 28)
	{
		A_FireMacePL1B();
		return;
	}
	if (Player->Ammo[am_mace] < USE_MACE_AMMO_1)
	{
		return;
	}
	Player->Ammo[am_mace] -= USE_MACE_AMMO_1;
	SX = Random() * 4.0 - 2.0;
	SY = WEAPONTOP + Random() * 4.0;
	ball = Player->MO.SpawnPlayerMissileAngle(MaceFX1,
		AngleMod360(Player->MO.Angles.yaw + (Random() - 0.5) * 45.0 / 4.0));
	if (ball)
	{
		ball.Special1 = 16;	// tics till dropoff
	}
}

//===========================================================================
//
//  A_FireMacePL2
//
//===========================================================================

void A_FireMacePL2(void)
{
	Actor A;

	Player->Ammo[am_mace] -= deathmatch ? USE_MACE_AMMO_1 : USE_MACE_AMMO_2;
	A = Player->MO.SpawnPlayerMissile(MaceFX4);
	if (A)
	{
		A.Velocity.x += Player->MO.Velocity.x;
		A.Velocity.y += Player->MO.Velocity.y;
		A.Velocity.z =
			(2.0 + 173.0 * -tan(Player->MO.Angles.pitch) / 32.0) * 35.0;
		if (linetarget)
		{
			A.Enemy = linetarget;
		}
	}
	Player->MO.PlaySound('MaceFire', CHAN_WEAPON);
}

__states__
{
	S_MACEREADY('MACE', 0, 1.0 / 35.0, S_MACEREADY) { A_WeaponReady(); }
	S_MACEDOWN('MACE', 0, 1.0 / 35.0, S_MACEDOWN) { A_Lower(); }
	S_MACEUP('MACE', 0, 1.0 / 35.0, S_MACEUP) { A_Raise(); }
	S_MACEATK1_1('MACE', 1, 4.0 / 35.0, S_MACEATK1_2) { }
	S_MACEATK1_2('MACE', 2, 3.0 / 35.0, S_MACEATK1_3) { A_FireMacePL1(); }
	S_MACEATK1_3('MACE', 3, 3.0 / 35.0, S_MACEATK1_4) { A_FireMacePL1(); }
	S_MACEATK1_4('MACE', 4, 3.0 / 35.0, S_MACEATK1_5) { A_FireMacePL1(); }
	S_MACEATK1_5('MACE', 5, 3.0 / 35.0, S_MACEATK1_6) { A_FireMacePL1(); }
	S_MACEATK1_6('MACE', 2, 4.0 / 35.0, S_MACEATK1_7) { A_ReFire(); }
	S_MACEATK1_7('MACE', 3, 4.0 / 35.0, S_MACEATK1_8) { }
	S_MACEATK1_8('MACE', 4, 4.0 / 35.0, S_MACEATK1_9) { }
	S_MACEATK1_9('MACE', 5, 4.0 / 35.0, S_MACEATK1_10) { }
	S_MACEATK1_10('MACE', 1, 4.0 / 35.0, S_MACEREADY) { }
	S_MACEATK2_1('MACE', 1, 4.0 / 35.0, S_MACEATK2_2) { }
	S_MACEATK2_2('MACE', 3, 4.0 / 35.0, S_MACEATK2_3) { A_FireMacePL2(); }
	S_MACEATK2_3('MACE', 1, 4.0 / 35.0, S_MACEATK2_4) { }
	S_MACEATK2_4('MACE', 0, 8.0 / 35.0, S_MACEREADY) { A_ReFire(); }
}

defaultproperties
{
	Ammo = am_mace;
	UpState = S_MACEUP;
	DownState = S_MACEDOWN;
	ReadyState = S_MACEREADY;
	AttackState = S_MACEATK1_1;
	HoldAttackState = S_MACEATK1_2;
	UpState2 = S_MACEUP;
	DownState2 = S_MACEDOWN;
	ReadyState2 = S_MACEREADY;
	AttackState2 = S_MACEATK2_1;
	HoldAttackState2 = S_MACEATK2_1;
	PSpriteSY = 15.0;
}

}

//**************************************************************************
//**************************************************************************
//
//	WeaponBeak
//
//**************************************************************************
//**************************************************************************

class WeaponBeak:Weapon
{

//===========================================================================
//
//  A_BeakRaise
//
//===========================================================================

void A_BeakRaise(void)
{
	SY = WEAPONTOP;
	SetState(ReadyState);
}

//===========================================================================
//
//  A_BeakReady
//
//===========================================================================

void A_BeakReady(void)
{
	if (Player->Buttons & BT_ATTACK)
	{
		// Chicken beak attack
		Player->bAttackDown = true;
		Player->MO.SetState(Player->MO.MissileState);
		if (Player->Powers[pw_weaponlevel2])
		{
			SetState(AttackState2);
		}
		else
		{
			SetState(AttackState);
		}
		P_NoiseAlert(Player->MO, Player->MO);
	}
	else
	{
		if (Player->MO.StateNum == Player->MO.MissileState)
		{
			// Take out of attack state
			Player->MO.SetState(Player->MO.IdleState);
		}
		Player->bAttackDown = false;
	}
}

//===========================================================================
//
//  A_BeakAttackPL1
//
//===========================================================================

void A_BeakAttackPL1(void)
{
	int damage;
	TAVec angles;
	TVec dir;
	name SoundName;

	damage = 1 + (P_Random() & 3);
	avcpy(Player->MO.Angles, angles);
	dir = AimLineAttack(Player->MO, angles, MELEERANGE);
	PuffType = BeakPuff;
	LineAttack(Player->MO, dir, MELEERANGE, damage);
	if (linetarget)
	{
		Player->MO.Angles.yaw =
			atan2(linetarget.Origin.y - Player->MO.Origin.y,
			linetarget.Origin.x - Player->MO.Origin.x);
		Player->bFixAngle = true;
	}
	switch (P_Random() % 3)
	{
	case 0:
		SoundName = 'ChickenPeak1';
		break;
	case 1:
		SoundName = 'ChickenPeak2';
		break;
	case 2:
		SoundName = 'ChickenPeak3';
		break;
	}
	Player->MO.PlaySound(SoundName, CHAN_VOICE);
	Player->ChickenPeck = 12;
	StateTime -= Random() * 0.25;
}

//===========================================================================
//
//  A_BeakAttackPL2
//
//===========================================================================

void A_BeakAttackPL2(void)
{
	int damage;
	TAVec angles;
	TVec dir;
	name SoundName;

	damage = HITDICE(4);
	avcpy(Player->MO.Angles, angles);
	dir = AimLineAttack(Player->MO, angles, MELEERANGE);
	PuffType = BeakPuff;
	LineAttack(Player->MO, dir, MELEERANGE, damage);
	if (linetarget)
	{
		Player->MO.Angles.yaw =
			atan2(linetarget.Origin.y - Player->MO.Origin.y,
			linetarget.Origin.x - Player->MO.Origin.x);
		Player->bFixAngle = true;
	}
	switch (P_Random() % 3)
	{
	case 0:
		SoundName = 'ChickenPeak1';
		break;
	case 1:
		SoundName = 'ChickenPeak2';
		break;
	case 2:
		SoundName = 'ChickenPeak3';
		break;
	}
	Player->MO.PlaySound(SoundName, CHAN_VOICE);
	Player->ChickenPeck = 12;
	StateTime -= Random() * 0.125;
}

__states__
{
	S_BEAKREADY('BEAK', 0, 1.0 / 35.0, S_BEAKREADY) { A_BeakReady(); }
	S_BEAKDOWN('BEAK', 0, 1.0 / 35.0, S_BEAKDOWN) { A_Lower(); }
	S_BEAKUP('BEAK', 0, 1.0 / 35.0, S_BEAKUP) { A_BeakRaise(); }
	S_BEAKATK1_1('BEAK', 0, 18.0 / 35.0, S_BEAKREADY) { A_BeakAttackPL1(); }
	S_BEAKATK2_1('BEAK', 0, 12.0 / 35.0, S_BEAKREADY) { A_BeakAttackPL2(); }
}

defaultproperties
{
	Ammo = am_noammo;
	UpState = S_BEAKUP;
	DownState = S_BEAKDOWN;
	ReadyState = S_BEAKREADY;
	AttackState = S_BEAKATK1_1;
	HoldAttackState = S_BEAKATK1_1;
	UpState2 = S_BEAKUP;
	DownState2 = S_BEAKDOWN;
	ReadyState2 = S_BEAKREADY;
	AttackState2 = S_BEAKATK2_1;
	HoldAttackState2 = S_BEAKATK2_1;
	PSpriteSY = 15.0;
}

}

//**************************************************************************
//
//  $Log$
//  Revision 1.26  2002/05/18 17:00:00  dj_jl
//  Renamed SpawnState to IdleState, other changes.
//
//  Revision 1.25  2002/03/28 18:15:34  dj_jl
//  Renamed mo in player_t to MO.
//
//  Revision 1.24  2002/03/20 19:07:47  dj_jl
//  Got rid of a lots of legacy, beautification.
//
//  Revision 1.23  2002/03/16 17:45:13  dj_jl
//  Added Pawn and PlayerPawn classes, beautification.
//
//  Revision 1.22  2002/03/09 17:57:02  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.21  2002/03/02 17:35:55  dj_jl
//  Weapon classes
//
//  Revision 1.20  2002/02/26 17:49:48  dj_jl
//  no message
//
//  Revision 1.19  2002/02/22 18:00:19  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.18  2002/02/14 19:20:58  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.17  2002/02/06 17:28:52  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.16  2002/01/28 18:50:18  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.15  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.14  2002/01/24 18:19:26  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.13  2002/01/17 18:15:53  dj_jl
//  Renamed all map object classes
//
//  Revision 1.12  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.11  2002/01/11 18:19:41  dj_jl
//  Started to use names in progs
//
//  Revision 1.10  2002/01/07 12:23:18  dj_jl
//  Changed copyright year
//
//  Revision 1.9  2001/12/12 18:57:42  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.8  2001/10/22 17:23:12  dj_jl
//  Floatification of angles
//
//  Revision 1.7  2001/10/18 17:39:33  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.6  2001/10/02 17:42:38  dj_jl
//  Possibility to declare function's code inside class declaration
//
//  Revision 1.5  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.4  2001/08/31 17:17:23  dj_jl
//  Removed vector macros
//  
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
