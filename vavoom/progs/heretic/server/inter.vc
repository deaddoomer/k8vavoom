//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

//**************************************************************************
//
//	Pickup
//
//**************************************************************************

class Pickup:Actor
	abstract
{

void TouchSpecial(Actor Toucher);

//==========================================================================
//
//  A_RestoreSpecialThing1
//
//  Make a special thing visible again.
//
//==========================================================================

void A_RestoreSpecialThing1(void)
{
	bHidden = false;
	PlaySound('Respawn', CHAN_VOICE);
}

//==========================================================================
//
//  A_RestoreSpecialThing2
//
//==========================================================================

void A_RestoreSpecialThing2(void)
{
	bSpecial = true;
	SetState(IdleState);
}

__states__
{
	S_HIDESPECIAL1('ACLO', 4, 1400.0 / 35.0, S_HIDESPECIAL2) { }
	S_HIDESPECIAL2('ACLO', 0, 4.0 / 35.0, S_HIDESPECIAL3) { A_RestoreSpecialThing1(); }
	S_HIDESPECIAL3('ACLO', 1, 4.0 / 35.0, S_HIDESPECIAL4) { }
	S_HIDESPECIAL4('ACLO', 0, 4.0 / 35.0, S_HIDESPECIAL5) { }
	S_HIDESPECIAL5('ACLO', 1, 4.0 / 35.0, S_HIDESPECIAL6) { }
	S_HIDESPECIAL6('ACLO', 2, 4.0 / 35.0, S_HIDESPECIAL7) { }
	S_HIDESPECIAL7('ACLO', 1, 4.0 / 35.0, S_HIDESPECIAL8) { }
	S_HIDESPECIAL8('ACLO', 2, 4.0 / 35.0, S_HIDESPECIAL9) { }
	S_HIDESPECIAL9('ACLO', 3, 4.0 / 35.0, S_HIDESPECIAL10) { }
	S_HIDESPECIAL10('ACLO', 2, 4.0 / 35.0, S_HIDESPECIAL11) { }
	S_HIDESPECIAL11('ACLO', 3, 4.0 / 35.0, S_NULL) { A_RestoreSpecialThing2(); }
}

//==========================================================================
//
//  HideSpecialThing
//
//==========================================================================

void HideSpecialThing(void)
{
	bSpecial = false;
	bHidden = true;
	SetState(S_HIDESPECIAL1);
}

defaultproperties
{
	Health = 1000;
	Radius = 20.0;
	Height = 32.0;
	Mass = 100.0;
	bSpecial = true;
	bNoPassMobj = true;
}

}

//**************************************************************************
//**************************************************************************
//
//	Artifact
//
//**************************************************************************
//**************************************************************************

class Artifact:Pickup
	abstract
{

int ArtifactType;
bool bCanRespawn;

void TouchSpecial(Actor Toucher);

//==========================================================================
//
//  A_HideThing
//
//==========================================================================

void A_HideThing(void)
{
	bHidden = true;
}

//==========================================================================
//
//  A_UnHideThing
//
//==========================================================================

void A_UnHideThing(void)
{
	bHidden = false;
}

//==========================================================================
//
//  A_RestoreArtifact
//
//==========================================================================

void A_RestoreArtifact(void)
{
	bSpecial = true;
	SetState(IdleState);
	PlaySound('Respawn', CHAN_VOICE);
}

__states__
{
	S_DORMANTARTI1('ACLO', 3, 3.0 / 35.0, S_DORMANTARTI2) { }
	S_DORMANTARTI2('ACLO', 2, 3.0 / 35.0, S_DORMANTARTI3) { }
	S_DORMANTARTI3('ACLO', 3, 3.0 / 35.0, S_DORMANTARTI4) { }
	S_DORMANTARTI4('ACLO', 2, 3.0 / 35.0, S_DORMANTARTI5) { }
	S_DORMANTARTI5('ACLO', 1, 3.0 / 35.0, S_DORMANTARTI6) { }
	S_DORMANTARTI6('ACLO', 2, 3.0 / 35.0, S_DORMANTARTI7) { }
	S_DORMANTARTI7('ACLO', 1, 3.0 / 35.0, S_DORMANTARTI8) { }
	S_DORMANTARTI8('ACLO', 0, 3.0 / 35.0, S_DORMANTARTI9) { }
	S_DORMANTARTI9('ACLO', 1, 3.0 / 35.0, S_DORMANTARTI10) { }
	S_DORMANTARTI10('ACLO', 0, 3.0 / 35.0, S_DORMANTARTI11) { }
	S_DORMANTARTI11('ACLO', 0, 1400.0 / 35.0, S_DORMANTARTI12) { A_HideThing(); }
	S_DORMANTARTI12('ACLO', 0, 3.0 / 35.0, S_DORMANTARTI13) { A_UnHideThing(); }
	S_DORMANTARTI13('ACLO', 1, 3.0 / 35.0, S_DORMANTARTI14) { }
	S_DORMANTARTI14('ACLO', 0, 3.0 / 35.0, S_DORMANTARTI15) { }
	S_DORMANTARTI15('ACLO', 1, 3.0 / 35.0, S_DORMANTARTI16) { }
	S_DORMANTARTI16('ACLO', 2, 3.0 / 35.0, S_DORMANTARTI17) { }
	S_DORMANTARTI17('ACLO', 1, 3.0 / 35.0, S_DORMANTARTI18) { }
	S_DORMANTARTI18('ACLO', 2, 3.0 / 35.0, S_DORMANTARTI19) { }
	S_DORMANTARTI19('ACLO', 3, 3.0 / 35.0, S_DORMANTARTI20) { }
	S_DORMANTARTI20('ACLO', 2, 3.0 / 35.0, S_DORMANTARTI21) { }
	S_DORMANTARTI21('ACLO', 3, 3.0 / 35.0, S_NULL) { A_RestoreArtifact(); }

	S_DEADARTI1('ACLO', 3, 3.0 / 35.0, S_DEADARTI2) { }
	S_DEADARTI2('ACLO', 2, 3.0 / 35.0, S_DEADARTI3) { }
	S_DEADARTI3('ACLO', 3, 3.0 / 35.0, S_DEADARTI4) { }
	S_DEADARTI4('ACLO', 2, 3.0 / 35.0, S_DEADARTI5) { }
	S_DEADARTI5('ACLO', 1, 3.0 / 35.0, S_DEADARTI6) { }
	S_DEADARTI6('ACLO', 2, 3.0 / 35.0, S_DEADARTI7) { }
	S_DEADARTI7('ACLO', 1, 3.0 / 35.0, S_DEADARTI8) { }
	S_DEADARTI8('ACLO', 0, 3.0 / 35.0, S_DEADARTI9) { }
	S_DEADARTI9('ACLO', 1, 3.0 / 35.0, S_DEADARTI10) { }
	S_DEADARTI10('ACLO', 0, 3.0 / 35.0, S_NULL) { }
}

//==========================================================================
//
//  SetDormantArtifact
//
//  Removes the bSpecial flag, and initiates the artifact pickup animation.
//
//==========================================================================

void SetDormantArtifact(void)
{
	bSpecial = false;
	if (deathmatch && bCanRespawn)
	{
		SetState(S_DORMANTARTI1);
	}
	else
	{
		// Don't respawn
		SetState(S_DEADARTI1);
	}
	PlaySound('PickupArtifact', CHAN_ITEM);
}

defaultproperties
{
	bCountItem = true;
	bFloatBob = true;
	bCanRespawn = true;
}

}

//**************************************************************************
//**************************************************************************
//
//	WeaponPickup
//
//**************************************************************************
//**************************************************************************

class WeaponPickup:Pickup
	abstract
{

int WeaponType;

void TouchSpecial(Actor Toucher);

defaultproperties
{
}

}

//**************************************************************************
//**************************************************************************
//
//	Key
//
//**************************************************************************
//**************************************************************************

class Key:Pickup
	abstract
{

int KeyType;

void TouchSpecial(Actor Toucher);

void OnMapSpawn(mthing_t *mthing)
{
	if (deathmatch)
	{
		Remove();
		return;
	}
	::OnMapSpawn(mthing);
}

defaultproperties
{
}

}

//**************************************************************************
//**************************************************************************
//
//	Ammo
//
//**************************************************************************
//**************************************************************************

class Ammo:Pickup
	abstract
{

int AmmoType;
int AmmoCount;
int StringIndex;	// FIXME

void TouchSpecial(Actor Toucher);

defaultproperties
{
}

}

//**************************************************************************
//**************************************************************************

#define BONUSADD				0.2

// Keys

#define TXT_GOTBLUEKEY			"BLUE KEY"
#define TXT_GOTYELLOWKEY		"YELLOW KEY"
#define TXT_GOTGREENKEY			"GREEN KEY"

// Artifacts

#define TXT_ARTIHEALTH			"QUARTZ FLASK"
#define TXT_ARTIFLY				"WINGS OF WRATH"
#define TXT_ARTIINVULNERABILITY	"RING OF INVINCIBILITY"
#define TXT_ARTITOMEOFPOWER		"TOME OF POWER"
#define TXT_ARTIINVISIBILITY	"SHADOWSPHERE"
#define TXT_ARTIEGG				"MORPH OVUM"
#define TXT_ARTISUPERHEALTH		"MYSTIC URN"
#define TXT_ARTITORCH			"TORCH"
#define TXT_ARTIFIREBOMB		"TIME BOMB OF THE ANCIENTS"
#define TXT_ARTITELEPORT		"CHAOS DEVICE"

// Items

#define TXT_ITEMHEALTH			"CRYSTAL VIAL"
#define TXT_ITEMBAGOFHOLDING	"BAG OF HOLDING"
#define TXT_ITEMSHIELD1			"SILVER SHIELD"
#define TXT_ITEMSHIELD2			"ENCHANTED SHIELD"
#define TXT_ITEMSUPERMAP		"MAP SCROLL"

// Ammo

#define TXT_AMMOGOLDWAND1		"WAND CRYSTAL"
#define TXT_AMMOGOLDWAND2		"CRYSTAL GEODE"
#define TXT_AMMOMACE1			"MACE SPHERES"
#define TXT_AMMOMACE2			"PILE OF MACE SPHERES"
#define TXT_AMMOCROSSBOW1		"ETHEREAL ARROWS"
#define TXT_AMMOCROSSBOW2		"QUIVER OF ETHEREAL ARROWS"
#define TXT_AMMOBLASTER1		"CLAW ORB"
#define TXT_AMMOBLASTER2		"ENERGY ORB"
#define TXT_AMMOSKULLROD1		"LESSER RUNES"
#define TXT_AMMOSKULLROD2		"GREATER RUNES"
#define TXT_AMMOPHOENIXROD1		"FLAME ORB"
#define TXT_AMMOPHOENIXROD2		"INFERNO ORB"

// Weapons

#define TXT_WPNMACE				"FIREMACE"
#define TXT_WPNCROSSBOW			"ETHEREAL CROSSBOW"
#define TXT_WPNBLASTER			"DRAGON CLAW"
#define TXT_WPNSKULLROD			"HELLSTAFF"
#define TXT_WPNPHOENIXROD		"PHOENIX ROD"
#define TXT_WPNGAUNTLETS		"GAUNTLETS OF THE NECROMANCER"

#define AMMO_GWND_WIMPY 		10
#define AMMO_GWND_HEFTY 		50
#define AMMO_CBOW_WIMPY 		5
#define AMMO_CBOW_HEFTY 		20
#define AMMO_BLSR_WIMPY 		10
#define AMMO_BLSR_HEFTY 		25
#define AMMO_SKRD_WIMPY 		20
#define AMMO_SKRD_HEFTY 		100
#define AMMO_PHRD_WIMPY 		1
#define AMMO_PHRD_HEFTY 		10
#define AMMO_MACE_WIMPY 		20
#define AMMO_MACE_HEFTY 		100

int GetAmmoChange[] = {
	wp_goldwand,
	wp_crossbow,
	wp_blaster,
	wp_skullrod,
	wp_phoenixrod,
	wp_mace
};

int GetWeaponAmmo[NUMWEAPONS] = {
	0,	// staff
	25,	// gold wand
	10,	// crossbow
	30,	// blaster
	50,	// skull rod
	2,	// phoenix rod
	50,	// mace
	0,	// gauntlets
	0	// beak
};

int WeaponValue[] = {
	1,	// staff
	3,	// goldwand
	4,	// crossbow
	5,	// blaster
	6,	// skullrod
	7,	// phoenixrod
	8,	// mace
	2,	// gauntlets
	0	// beak
};
int maxammo[NUMAMMO] = {
	100,	// gold wand
	50,	// crossbow
	200,	// blaster
	200,	// skull rod
	20,	// phoenix rod
	150	// mace
};

string ArtifactText[NUMARTIFACTS] =
{
	"",
	TXT_ARTIINVULNERABILITY,
	TXT_ARTIINVISIBILITY,
	TXT_ARTIHEALTH,
	TXT_ARTISUPERHEALTH,
	TXT_ARTITOMEOFPOWER,
	TXT_ARTITORCH,
	TXT_ARTIFIREBOMB,
	TXT_ARTIEGG,
	TXT_ARTIFLY,
	TXT_ARTITELEPORT,
};
string WeaponText[] = {
	"",
	"",
	TXT_WPNCROSSBOW,
	TXT_WPNBLASTER,
	TXT_WPNSKULLROD,
	TXT_WPNPHOENIXROD,
	TXT_WPNMACE,
	TXT_WPNGAUNTLETS,
};
string KeyText[] = {
	TXT_GOTYELLOWKEY,
	TXT_GOTGREENKEY,
	TXT_GOTBLUEKEY,
};
string AmmoText[] = {
	TXT_AMMOGOLDWAND1,
	TXT_AMMOGOLDWAND2,
	TXT_AMMOMACE1,
	TXT_AMMOMACE2,
	TXT_AMMOCROSSBOW1,
	TXT_AMMOCROSSBOW2,
	TXT_AMMOBLASTER1,
	TXT_AMMOBLASTER2,
	TXT_AMMOSKULLROD1,
	TXT_AMMOSKULLROD2,
	TXT_AMMOPHOENIXROD1,
	TXT_AMMOPHOENIXROD2,
};

//==========================================================================
//
//  PlayerPawn::GiveAmmo
//
//  Returns true if the player accepted the ammo, false if it was
// refused (player has maxammo[ammo]).
//
//==========================================================================

boolean PlayerPawn::GiveAmmo(int ammo, int count)
{
	int prevAmmo;
	int max;

	if (ammo == am_noammo)
	{
		return false;
	}
	if (ammo < 0 || ammo > NUMAMMO)
	{
		Error("GiveAmmo: bad type %i", ammo);
	}
	max = Player->Backpack ? maxammo[ammo] * 2 : maxammo[ammo];
	if (Player->Ammo[ammo] == max)
	{
		return false;
	}
	if (gameskill == sk_baby || gameskill == sk_nightmare)
	{
		// extra ammo in baby mode and nightmare mode
		count += count >> 1;
	}
	prevAmmo = Player->Ammo[ammo];

	Player->Ammo[ammo] += count;
	if (Player->Ammo[ammo] > max)
	{
		Player->Ammo[ammo] = max;
	}
	if (prevAmmo)
	{
		// Don't attempt to change weapons if the player already had
		// ammo of the type just given
		return true;
	}
	if (Player->ReadyWeapon == wp_staff ||
		Player->ReadyWeapon == wp_gauntlets)
	{
		if (Player->WeaponOwned[GetAmmoChange[ammo]])
		{
			Player->PendingWeapon = GetAmmoChange[ammo];
		}
	}
	return true;
}

//==========================================================================
//
//  PlayerPawn::GiveWeapon
//
//  Returns true if the weapon or its ammo was accepted.
//
//==========================================================================

boolean PlayerPawn::GiveWeapon(int weapon)
{
	boolean gaveAmmo;
	boolean gaveWeapon;

	if (netgame && !deathmatch)
	{
		// Cooperative net-game
		if (Player->WeaponOwned[weapon])
		{
			return false;
		}
		Player->BonusFlash += BONUSADD;
		Player->WeaponOwned[weapon] = true;
		GiveAmmo(weapon_ammo_type[weapon], GetWeaponAmmo[weapon]);
		Player->PendingWeapon = weapon;
		PlaySound('PickupWeapon', CHAN_ITEM);
		return false;
	}
	gaveAmmo = GiveAmmo(weapon_ammo_type[weapon], GetWeaponAmmo[weapon]);
	if (Player->WeaponOwned[weapon])
	{
		gaveWeapon = false;
	}
	else
	{
		gaveWeapon = true;
		Player->WeaponOwned[weapon] = true;
		if (WeaponValue[weapon] > WeaponValue[Player->ReadyWeapon])
		{
			// Only switch to more powerful weapons
			Player->PendingWeapon = weapon;
		}
	}
	return (gaveWeapon || gaveAmmo);
}

//==========================================================================
//
//  PlayerPawn::GiveBody
//
//  Returns false if the body isn't needed at all.
//
//==========================================================================

boolean PlayerPawn::GiveBody(int num)
{
	int max;

	max = MAXHEALTH;
	if (Player->ChickenTime)
	{
		max = MAXCHICKENHEALTH;
	}
	if (Player->Health >= max)
	{
		return false;
	}
	Player->Health += num;
	if (Player->Health > max)
	{
		Player->Health = max;
	}
	Health = Player->Health;
	return true;
}

//==========================================================================
//
//  PlayerPawn::GiveArmor
//
//  Returns false if the armor is worse than the current armor.
//
//==========================================================================

boolean PlayerPawn::GiveArmor(int armortype)
{
	int hits;

	hits = armortype * 100;
	if (Player->ArmorPoints >= hits)
	{
		return false;
	}
	Player->ArmorType = armortype;
	Player->ArmorPoints = hits;
	return true;
}

//==========================================================================
//
//  PlayerPawn::GiveKey
//
//==========================================================================

boolean PlayerPawn::GiveKey(int key)
{
	if ((Player->Keys & (1 << key)))
	{
		return false;
	}
	Player->BonusFlash = BONUSADD;
	Player->Keys |= 1 << key;
	return true;
}

//==========================================================================
//
//  PlayerPawn::GivePower
//
//  Returns true if power accepted.
//
//==========================================================================

boolean PlayerPawn::GivePower(int power)
{
	if (power == pw_invulnerability)
	{
		if (Player->Powers[power] > BLINKTHRESHOLD)
		{
			// Already have it
			return false;
		}
		Player->Powers[power] = INVULNTIME;
		return true;
	}
	if (power == pw_weaponlevel2)
	{
		if (Player->Powers[power] > BLINKTHRESHOLD)
		{
			// Already have it
			return false;
		}
		Player->Powers[power] = WPNLEV2TIME;
		return true;
	}
	if (power == pw_invisibility)
	{
		if (Player->Powers[power] > BLINKTHRESHOLD)
		{
			// Already have it
			return false;
		}
		Player->Powers[power] = INVISTIME;
		Translucency = 33;
		return true;
	}
	if (power == pw_flight)
	{
		if (Player->Powers[power] > BLINKTHRESHOLD)
		{
			// Already have it
			return false;
		}
		Player->Powers[power] = FLIGHTTIME;
		bFly = true;
		bNoGravity = true;
		if (Origin.z <= FloorZ)
		{
			Player->FlyHeight = 10.0;	// thrust the player in the air a bit
		}
		return true;
	}
	if (power == pw_infrared)
	{
		if (Player->Powers[power] > BLINKTHRESHOLD)
		{
			// Already have it
			return false;
		}
		Player->Powers[power] = INFRATIME;
		return true;
	}
	if (Player->Powers[power])
	{
		return false;	// already got it
	}
	Player->Powers[power] = 1.0;
	return true;
}

//==========================================================================
//
//  PlayerPawn::GiveItem
//
//==========================================================================

boolean PlayerPawn::GiveItem(int item)
{
	if (Player->Items & item)
	{
		return false;	// already got it
	}
	Player->Items |= item;
	return true;
}

//==========================================================================
//
//  PlayerPawn::GiveArtifact
//
//  Returns true if artifact accepted.
//
//==========================================================================

boolean PlayerPawn::GiveArtifact(int arti)
{
	int i;

	i = 0;
	while (Player->Inventory[i].type != arti && i < Player->InventorySlotNum)
	{
		i++;
	}
	if (i == Player->InventorySlotNum)
	{
		Player->Inventory[i].count = 1;
		Player->Inventory[i].type = arti;
		Player->InventorySlotNum++;
	}
	else
	{
		if (Player->Inventory[i].count >= 16)
		{
			// Player already has 16 of this item
			return false;
		}
		Player->Inventory[i].count++;
	}
	if (Player->ArtifactCount == 0)
	{
		Player->ReadyArtifact = arti;
	}
	Player->ArtifactCount++;
	return true;
}

//==========================================================================
//
//  Pickup::TouchSpecial
//
//==========================================================================

void Pickup::TouchSpecial(Actor Toucher)
{
	int i;
	name sound;
	PlayerPawn P;

	if (!Toucher.bPickUp)
	{
		// can't remove thing
		return;
	}
	if (Toucher.Health <= 0)
	{
		// Toucher is dead
		return;
	}
	P = PlayerPawn(Toucher);
	sound = 'PickupItem';
	switch (Class)
	{
		// Items
	case ItemHealthPotion:
		if (!P.GiveBody(10))
		{
			return;
		}
		cprint(P.Player, TXT_ITEMHEALTH);
		break;
	case ItemShield1:
		if (!P.GiveArmor(1))
		{
			return;
		}
		cprint(P.Player, TXT_ITEMSHIELD1);
		break;
	case ItemShield2:
		if (!P.GiveArmor(2))
		{
			return;
		}
		cprint(P.Player, TXT_ITEMSHIELD2);
		break;
	case ItemBagOfHolding:
		P.Player->Backpack = true;
		P.GiveAmmo(am_goldwand, AMMO_GWND_WIMPY);
		P.GiveAmmo(am_blaster, AMMO_BLSR_WIMPY);
		P.GiveAmmo(am_crossbow, AMMO_CBOW_WIMPY);
		P.GiveAmmo(am_skullrod, AMMO_SKRD_WIMPY);
		P.GiveAmmo(am_phoenixrod, AMMO_PHRD_WIMPY);
		cprint(P.Player, TXT_ITEMBAGOFHOLDING);
		break;
	case ItemMap:
		if (!P.GiveItem(IT_ALL_MAP))
		{
			return;
		}
		cprint(P.Player, TXT_ITEMSUPERMAP);
		break;
	}
	if (bCountItem)
	{
		P.Player->ItemCount++;
	}
	if (deathmatch && !bDropped)
	{
		HideSpecialThing();
	}
	else
	{
		Remove();
	}
	P.Player->BonusFlash += BONUSADD;
	P.PlaySound(sound, CHAN_ITEM);
}

//==========================================================================
//
//  Artifact::TouchSpecial
//
//==========================================================================

void Artifact::TouchSpecial(Actor Toucher)
{
	PlayerPawn P;

	if (!Toucher.bPickUp)
	{
		// can't remove thing
		return;
	}
	if (Toucher.Health <= 0)
	{
		// Toucher is dead
		return;
	}
	P = PlayerPawn(Toucher);
	if (P.GiveArtifact(ArtifactType))
	{
		cprint(P.Player, ArtifactText[ArtifactType]);
		if (bCountItem)
		{
			P.Player->ItemCount++;
		}
		SetDormantArtifact();
	}
}

//==========================================================================
//
//  WeaponPickup::TouchSpecial
//
//==========================================================================

void WeaponPickup::TouchSpecial(Actor Toucher)
{
	PlayerPawn P;

	if (!Toucher.bPickUp)
	{
		// can't remove thing
		return;
	}
	if (Toucher.Health <= 0)
	{
		// Toucher is dead
		return;
	}
	P = PlayerPawn(Toucher);
	if (!P.GiveWeapon(WeaponType))
	{
		return;
	}
	cprint(P.Player, WeaponText[WeaponType]);
	if (bCountItem)
	{
		P.Player->ItemCount++;
	}
	if (deathmatch && !bDropped)
	{
		HideSpecialThing();
	}
	else
	{
		Remove();
	}
	P.Player->BonusFlash += BONUSADD;
	P.PlaySound('PickupWeapon', CHAN_ITEM);
}

//==========================================================================
//
//  Key::TouchSpecial
//
//==========================================================================

void Key::TouchSpecial(Actor Toucher)
{
	PlayerPawn P;

	if (!Toucher.bPickUp)
	{
		// can't remove thing
		return;
	}
	if (Toucher.Health <= 0)
	{
		// Toucher is dead
		return;
	}
	P = PlayerPawn(Toucher);
	if (P.GiveKey(KeyType))
	{
		cprint(P.Player, KeyText[KeyType]);
	}
	if (netgame)
	{
		return;
	}
	if (bCountItem)
	{
		P.Player->ItemCount++;
	}
	Remove();
	P.Player->BonusFlash += BONUSADD;
	P.PlaySound('PickupKey', CHAN_ITEM);
}

//==========================================================================
//
//  Ammo::TouchSpecial
//
//==========================================================================

void Ammo::TouchSpecial(Actor Toucher)
{
	int i;
	PlayerPawn P;

	if (!Toucher.bPickUp)
	{
		// can't remove thing
		return;
	}
	if (Toucher.Health <= 0)
	{
		// Toucher is dead
		return;
	}
	P = PlayerPawn(Toucher);
	if (!P.GiveAmmo(AmmoType, AmmoCount))
	{
		return;
	}
	cprint(P.Player, AmmoText[StringIndex]);
	if (bCountItem)
	{
		P.Player->ItemCount++;
	}
	if (deathmatch && !bDropped)
	{
		HideSpecialThing();
	}
	else
	{
		Remove();
	}
	P.Player->BonusFlash += BONUSADD;
	P.PlaySound('PickupItem', CHAN_ITEM);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.21  2002/08/28 16:36:39  dj_jl
//  Merged MapObject with Entity, some natives, beautification.
//
//  Revision 1.20  2002/07/23 13:07:30  dj_jl
//  Final touches for switching to floating-point time, beautification.
//
//  Revision 1.19  2002/06/22 07:16:00  dj_jl
//  Added base classes for objects, split them into corresponding files.
//
//  Revision 1.18  2002/05/18 16:59:59  dj_jl
//  Renamed SpawnState to IdleState, other changes.
//
//  Revision 1.17  2002/03/20 19:07:46  dj_jl
//  Got rid of a lots of legacy, beautification.
//
//  Revision 1.16  2002/03/16 17:45:13  dj_jl
//  Added Pawn and PlayerPawn classes, beautification.
//
//  Revision 1.15  2002/03/12 19:21:24  dj_jl
//  No need for linefeed in client-printing
//
//  Revision 1.14  2002/02/22 18:00:16  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.13  2002/02/14 19:20:58  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.12  2002/02/09 18:12:25  dj_jl
//  Replaced identifying sprite name indexes with sprite names
//
//  Revision 1.11  2002/02/06 17:28:52  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.10  2002/01/28 18:50:18  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.9  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.8  2002/01/17 18:15:53  dj_jl
//  Renamed all map object classes
//
//  Revision 1.7  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.6  2002/01/11 18:19:41  dj_jl
//  Started to use names in progs
//
//  Revision 1.5  2002/01/07 12:23:17  dj_jl
//  Changed copyright year
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
