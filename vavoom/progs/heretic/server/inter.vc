//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

#define BONUSADD				6

// Keys

#define TXT_GOTBLUEKEY			"BLUE KEY"
#define TXT_GOTYELLOWKEY		"YELLOW KEY"
#define TXT_GOTGREENKEY			"GREEN KEY"

// Artifacts

#define TXT_ARTIHEALTH			"QUARTZ FLASK"
#define TXT_ARTIFLY				"WINGS OF WRATH"
#define TXT_ARTIINVULNERABILITY	"RING OF INVINCIBILITY"
#define TXT_ARTITOMEOFPOWER		"TOME OF POWER"
#define TXT_ARTIINVISIBILITY	"SHADOWSPHERE"
#define TXT_ARTIEGG				"MORPH OVUM"
#define TXT_ARTISUPERHEALTH		"MYSTIC URN"
#define TXT_ARTITORCH			"TORCH"
#define TXT_ARTIFIREBOMB		"TIME BOMB OF THE ANCIENTS"
#define TXT_ARTITELEPORT		"CHAOS DEVICE"

// Items

#define TXT_ITEMHEALTH			"CRYSTAL VIAL"
#define TXT_ITEMBAGOFHOLDING	"BAG OF HOLDING"
#define TXT_ITEMSHIELD1			"SILVER SHIELD"
#define TXT_ITEMSHIELD2			"ENCHANTED SHIELD"
#define TXT_ITEMSUPERMAP		"MAP SCROLL"

// Ammo

#define TXT_AMMOGOLDWAND1		"WAND CRYSTAL"
#define TXT_AMMOGOLDWAND2		"CRYSTAL GEODE"
#define TXT_AMMOMACE1			"MACE SPHERES"
#define TXT_AMMOMACE2			"PILE OF MACE SPHERES"
#define TXT_AMMOCROSSBOW1		"ETHEREAL ARROWS"
#define TXT_AMMOCROSSBOW2		"QUIVER OF ETHEREAL ARROWS"
#define TXT_AMMOBLASTER1		"CLAW ORB"
#define TXT_AMMOBLASTER2		"ENERGY ORB"
#define TXT_AMMOSKULLROD1		"LESSER RUNES"
#define TXT_AMMOSKULLROD2		"GREATER RUNES"
#define TXT_AMMOPHOENIXROD1		"FLAME ORB"
#define TXT_AMMOPHOENIXROD2		"INFERNO ORB"

// Weapons

#define TXT_WPNMACE				"FIREMACE"
#define TXT_WPNCROSSBOW			"ETHEREAL CROSSBOW"
#define TXT_WPNBLASTER			"DRAGON CLAW"
#define TXT_WPNSKULLROD			"HELLSTAFF"
#define TXT_WPNPHOENIXROD		"PHOENIX ROD"
#define TXT_WPNGAUNTLETS		"GAUNTLETS OF THE NECROMANCER"

#define AMMO_GWND_WIMPY 		10
#define AMMO_GWND_HEFTY 		50
#define AMMO_CBOW_WIMPY 		5
#define AMMO_CBOW_HEFTY 		20
#define AMMO_BLSR_WIMPY 		10
#define AMMO_BLSR_HEFTY 		25
#define AMMO_SKRD_WIMPY 		20
#define AMMO_SKRD_HEFTY 		100
#define AMMO_PHRD_WIMPY 		1
#define AMMO_PHRD_HEFTY 		10
#define AMMO_MACE_WIMPY 		20
#define AMMO_MACE_HEFTY 		100

int GetAmmoChange[] = {
	wp_goldwand,
	wp_crossbow,
	wp_blaster,
	wp_skullrod,
	wp_phoenixrod,
	wp_mace
};

int GetWeaponAmmo[NUMWEAPONS] = {
	0,	// staff
	25,	// gold wand
	10,	// crossbow
	30,	// blaster
	50,	// skull rod
	2,	// phoenix rod
	50,	// mace
	0,	// gauntlets
	0	// beak
};

int WeaponValue[] = {
	1,	// staff
	3,	// goldwand
	4,	// crossbow
	5,	// blaster
	6,	// skullrod
	7,	// phoenixrod
	8,	// mace
	2,	// gauntlets
	0	// beak
};
int maxammo[NUMAMMO] = {
	100,	// gold wand
	50,	// crossbow
	200,	// blaster
	200,	// skull rod
	20,	// phoenix rod
	150	// mace
};

//==========================================================================
//
//  Actor::GiveAmmo
//
//  Returns true if the player accepted the ammo, false if it was
// refused (player has maxammo[ammo]).
//
//==========================================================================

boolean Actor::GiveAmmo(int ammo, int count)
{
	int prevAmmo;
	int max;

	if (ammo == am_noammo)
	{
		return false;
	}
	if (ammo < 0 || ammo > NUMAMMO)
	{
		Error("GiveAmmo: bad type %i", ammo);
	}
	max = Player->Backpack ? maxammo[ammo] * 2 : maxammo[ammo];
	if (Player->Ammo[ammo] == max)
	{
		return false;
	}
	if (gameskill == sk_baby || gameskill == sk_nightmare)
	{
		// extra ammo in baby mode and nightmare mode
		count += count >> 1;
	}
	prevAmmo = Player->Ammo[ammo];

	Player->Ammo[ammo] += count;
	if (Player->Ammo[ammo] > max)
	{
		Player->Ammo[ammo] = max;
	}
	if (prevAmmo)
	{
		// Don't attempt to change weapons if the player already had
		// ammo of the type just given
		return true;
	}
	if (Player->ReadyWeapon == wp_staff ||
		Player->ReadyWeapon == wp_gauntlets)
	{
		if (Player->WeaponOwned[GetAmmoChange[ammo]])
		{
			Player->PendingWeapon = GetAmmoChange[ammo];
		}
	}
	return true;
}

//==========================================================================
//
//  Actor::GiveWeapon
//
//  Returns true if the weapon or its ammo was accepted.
//
//==========================================================================

boolean Actor::GiveWeapon(int weapon)
{
	boolean gaveAmmo;
	boolean gaveWeapon;

	if (netgame && !deathmatch)
	{
		// Cooperative net-game
		if (Player->WeaponOwned[weapon])
		{
			return false;
		}
		Player->BonusCount += BONUSADD;
		Player->WeaponOwned[weapon] = true;
		GiveAmmo(weapon_ammo_type[weapon], GetWeaponAmmo[weapon]);
		Player->PendingWeapon = weapon;
		PlaySound('PickupWeapon', CHAN_ITEM);
		return false;
	}
	gaveAmmo = GiveAmmo(weapon_ammo_type[weapon], GetWeaponAmmo[weapon]);
	if (Player->WeaponOwned[weapon])
	{
		gaveWeapon = false;
	}
	else
	{
		gaveWeapon = true;
		Player->WeaponOwned[weapon] = true;
		if (WeaponValue[weapon] > WeaponValue[Player->ReadyWeapon])
		{
			// Only switch to more powerful weapons
			Player->PendingWeapon = weapon;
		}
	}
	return (gaveWeapon || gaveAmmo);
}

//==========================================================================
//
//  Actor::GiveBody
//
//  Returns false if the body isn't needed at all.
//
//==========================================================================

boolean Actor::GiveBody(int num)
{
	int max;

	max = MAXHEALTH;
	if (Player->ChickenTics)
	{
		max = MAXCHICKENHEALTH;
	}
	if (Player->Health >= max)
	{
		return false;
	}
	Player->Health += num;
	if (Player->Health > max)
	{
		Player->Health = max;
	}
	Health = Player->Health;
	return true;
}

//==========================================================================
//
//  Actor::GiveArmor
//
//  Returns false if the armor is worse than the current armor.
//
//==========================================================================

boolean Actor::GiveArmor(int armortype)
{
	int hits;

	hits = armortype * 100;
	if (Player->ArmorPoints >= hits)
	{
		return false;
	}
	Player->ArmorType = armortype;
	Player->ArmorPoints = hits;
	return true;
}

//==========================================================================
//
//  Actor::GiveKey
//
//==========================================================================

boolean Actor::GiveKey(int key)
{
	if ((Player->Keys & (1 << key)))
	{
		return false;
	}
	Player->BonusCount = BONUSADD;
	Player->Keys |= 1 << key;
	return true;
}

//==========================================================================
//
//  Actor::GivePower
//
//  Returns true if power accepted.
//
//==========================================================================

boolean Actor::GivePower(int power)
{
	if (power == pw_invulnerability)
	{
		if (Player->Powers[power] > ftoi(BLINKTHRESHOLD * 35.0))
		{
			// Already have it
			return false;
		}
		Player->Powers[power] = ftoi(INVULNTIME * 35.0);
		return true;
	}
	if (power == pw_weaponlevel2)
	{
		if (Player->Powers[power] > ftoi(BLINKTHRESHOLD * 35.0))
		{
			// Already have it
			return false;
		}
		Player->Powers[power] = ftoi(WPNLEV2TIME * 35.0);
		return true;
	}
	if (power == pw_invisibility)
	{
		if (Player->Powers[power] > ftoi(BLINKTHRESHOLD * 35.0))
		{
			// Already have it
			return false;
		}
		Player->Powers[power] = ftoi(INVISTIME * 35.0);
		Translucency = 33;
		return true;
	}
	if (power == pw_flight)
	{
		if (Player->Powers[power] > ftoi(BLINKTHRESHOLD * 35.0))
		{
			// Already have it
			return false;
		}
		Player->Powers[power] = ftoi(FLIGHTTIME * 35.0);
		bFly = true;
		bNoGravity = true;
		if (Origin.z <= FloorZ)
		{
			Player->FlyHeight = 10.0;	// thrust the player in the air a bit
		}
		return true;
	}
	if (power == pw_infrared)
	{
		if (Player->Powers[power] > ftoi(BLINKTHRESHOLD * 35.0))
		{
			// Already have it
			return false;
		}
		Player->Powers[power] = ftoi(INFRATIME * 35.0);
		return true;
	}
	if (Player->Powers[power])
	{
		return false;	// already got it
	}
	Player->Powers[power] = 1;
	return true;
}

//==========================================================================
//
//  Actor::GiveItem
//
//==========================================================================

boolean Actor::GiveItem(int item)
{
	if (Player->Items & item)
	{
		return false;	// already got it
	}
	Player->Items |= item;
	return true;
}

//==========================================================================
//
//  Actor::GiveArtifact
//
//  Returns true if artifact accepted.
//
//==========================================================================

boolean Actor::GiveArtifact(int arti, Actor mo)
{
	int i;

	i = 0;
	while (Player->Inventory[i].type != arti && i < Player->InventorySlotNum)
	{
		i++;
	}
	if (i == Player->InventorySlotNum)
	{
		Player->Inventory[i].count = 1;
		Player->Inventory[i].type = arti;
		Player->InventorySlotNum++;
	}
	else
	{
		if (Player->Inventory[i].count >= 16)
		{
			// Player already has 16 of this item
			return false;
		}
		Player->Inventory[i].count++;
	}
	if (Player->ArtifactCount == 0)
	{
		Player->ReadyArtifact = arti;
	}
	Player->ArtifactCount++;
	if (mo && mo.bCountItem)
	{
		Player->ItemCount++;
	}
	return true;
}

//==========================================================================
//
//  Actor::TouchSpecial
//
//==========================================================================

void Actor::TouchSpecial(Actor Toucher)
{
	int i;
	name sound;
	boolean respawn;

	if (!Toucher.bPickUp)
	{
		// can't remove thing
		return;
	}
	if (Toucher.Health <= 0)
	{
		// Toucher is dead
		return;
	}
	sound = 'PickupItem';
	respawn = true;
	switch (SpriteName)
	{
		// Items
	case 'PTN1':	// Item_HealingPotion
		if (!Toucher.GiveBody(10))
		{
			return;
		}
		cprint(Toucher.Player, TXT_ITEMHEALTH);
		break;
	case 'SHLD':	// Item_Shield1
		if (!Toucher.GiveArmor(1))
		{
			return;
		}
		cprint(Toucher.Player, TXT_ITEMSHIELD1);
		break;
	case 'SHD2':	// Item_Shield2
		if (!Toucher.GiveArmor(2))
		{
			return;
		}
		cprint(Toucher.Player, TXT_ITEMSHIELD2);
		break;
	case 'BAGH':	// Item_BagOfHolding
		Toucher.Player->Backpack = true;
		Toucher.GiveAmmo(am_goldwand, AMMO_GWND_WIMPY);
		Toucher.GiveAmmo(am_blaster, AMMO_BLSR_WIMPY);
		Toucher.GiveAmmo(am_crossbow, AMMO_CBOW_WIMPY);
		Toucher.GiveAmmo(am_skullrod, AMMO_SKRD_WIMPY);
		Toucher.GiveAmmo(am_phoenixrod, AMMO_PHRD_WIMPY);
		cprint(Toucher.Player, TXT_ITEMBAGOFHOLDING);
		break;
	case 'SPMP':	// Item_SuperMap
		if (!Toucher.GiveItem(IT_ALL_MAP))
		{
			return;
		}
		cprint(Toucher.Player, TXT_ITEMSUPERMAP);
		break;

		// Keys
	case 'BKYY':	// Key_Blue
		if (Toucher.GiveKey(key_blue))
		{
			cprint(Toucher.Player, TXT_GOTBLUEKEY);
		}
		sound = 'PickupKey';
		if (!netgame)
		{
			break;
		}
		return;
	case 'CKYY':	// Key_Yellow
		if (Toucher.GiveKey(key_yellow))
		{
			cprint(Toucher.Player, TXT_GOTYELLOWKEY);
		}
		sound = 'PickupKey';
		if (!netgame)
		{
			break;
		}
		return;
	case 'AKYY':	// Key_Green
		if (Toucher.GiveKey(key_green))
		{
			cprint(Toucher.Player, TXT_GOTGREENKEY);
		}
		sound = 'PickupKey';
		if (!netgame)
		{
			break;
		}
		return;

		// Artifacts
	case 'PTN2':	// Arti_HealingPotion
		if (Toucher.GiveArtifact(arti_health, self))
		{
			cprint(Toucher.Player, TXT_ARTIHEALTH);
			SetDormantArtifact();
		}
		return;
	case 'SOAR':	// Arti_Fly
		if (Toucher.GiveArtifact(arti_fly, self))
		{
			cprint(Toucher.Player, TXT_ARTIFLY);
			SetDormantArtifact();
		}
		return;
	case 'INVU':	// Arti_Invulnerability
		if (Toucher.GiveArtifact(arti_invulnerability, self))
		{
			cprint(Toucher.Player, TXT_ARTIINVULNERABILITY);
			SetDormantArtifact();
		}
		return;
	case 'PWBK':	// Arti_TomeOfPower
		if (Toucher.GiveArtifact(arti_tomeofpower, self))
		{
			cprint(Toucher.Player, TXT_ARTITOMEOFPOWER);
			SetDormantArtifact();
		}
		return;
	case 'INVS':	// Arti_Invisibility
		if (Toucher.GiveArtifact(arti_invisibility, self))
		{
			cprint(Toucher.Player, TXT_ARTIINVISIBILITY);
			SetDormantArtifact();
		}
		return;
	case 'EGGC':	// Arti_Egg
		if (Toucher.GiveArtifact(arti_egg, self))
		{
			cprint(Toucher.Player, TXT_ARTIEGG);
			SetDormantArtifact();
		}
		return;
	case 'SPHL':	// Arti_SuperHealth
		if (Toucher.GiveArtifact(arti_superhealth, self))
		{
			cprint(Toucher.Player, TXT_ARTISUPERHEALTH);
			SetDormantArtifact();
		}
		return;
	case 'TRCH':	// Arti_Torch
		if (Toucher.GiveArtifact(arti_torch, self))
		{
			cprint(Toucher.Player, TXT_ARTITORCH);
			SetDormantArtifact();
		}
		return;
	case 'FBMB':	// Arti_FireBomb
		if (Toucher.GiveArtifact(arti_firebomb, self))
		{
			cprint(Toucher.Player, TXT_ARTIFIREBOMB);
			SetDormantArtifact();
		}
		return;
	case 'ATLP':	// Arti_Teleport
		if (Toucher.GiveArtifact(arti_teleport, self))
		{
			cprint(Toucher.Player, TXT_ARTITELEPORT);
			SetDormantArtifact();
		}
		return;

		// Ammo
	case 'AMG1':	// Ammo_GoldWandWimpy
		if (!Toucher.GiveAmmo(am_goldwand, Health))
		{
			return;
		}
		cprint(Toucher.Player, TXT_AMMOGOLDWAND1);
		break;
	case 'AMG2':	// Ammo_GoldWandHefty
		if (!Toucher.GiveAmmo(am_goldwand, Health))
		{
			return;
		}
		cprint(Toucher.Player, TXT_AMMOGOLDWAND2);
		break;
	case 'AMM1':	// Ammo_MaceWimpy
		if (!Toucher.GiveAmmo(am_mace, Health))
		{
			return;
		}
		cprint(Toucher.Player, TXT_AMMOMACE1);
		break;
	case 'AMM2':	// Ammo_MaceHefty
		if (!Toucher.GiveAmmo(am_mace, Health))
		{
			return;
		}
		cprint(Toucher.Player, TXT_AMMOMACE2);
		break;
	case 'AMC1':	// Ammo_CrossbowWimpy
		if (!Toucher.GiveAmmo(am_crossbow, Health))
		{
			return;
		}
		cprint(Toucher.Player, TXT_AMMOCROSSBOW1);
		break;
	case 'AMC2':	// Ammo_CrossbowHefty
		if (!Toucher.GiveAmmo(am_crossbow, Health))
		{
			return;
		}
		cprint(Toucher.Player, TXT_AMMOCROSSBOW2);
		break;
	case 'AMB1':	// Ammo_BlasterWimpy
		if (!Toucher.GiveAmmo(am_blaster, Health))
		{
			return;
		}
		cprint(Toucher.Player, TXT_AMMOBLASTER1);
		break;
	case 'AMB2':	// Ammo_BlasterHefty
		if (!Toucher.GiveAmmo(am_blaster, Health))
		{
			return;
		}
		cprint(Toucher.Player, TXT_AMMOBLASTER2);
		break;
	case 'AMS1':	// Ammo_SkullRodWimpy
		if (!Toucher.GiveAmmo(am_skullrod, Health))
		{
			return;
		}
		cprint(Toucher.Player, TXT_AMMOSKULLROD1);
		break;
	case 'AMS2':	// Ammo_SkullRodHefty
		if (!Toucher.GiveAmmo(am_skullrod, Health))
		{
			return;
		}
		cprint(Toucher.Player, TXT_AMMOSKULLROD2);
		break;
	case 'AMP1':	// Ammo_PhoenixRodWimpy
		if (!Toucher.GiveAmmo(am_phoenixrod, Health))
		{
			return;
		}
		cprint(Toucher.Player, TXT_AMMOPHOENIXROD1);
		break;
	case 'AMP2':	// Ammo_PhoenixRodHefty
		if (!Toucher.GiveAmmo(am_phoenixrod, Health))
		{
			return;
		}
		cprint(Toucher.Player, TXT_AMMOPHOENIXROD2);
		break;

		// Weapons
	case 'WMCE':	// Weapon_Mace
		if (!Toucher.GiveWeapon(wp_mace))
		{
			return;
		}
		cprint(Toucher.Player, TXT_WPNMACE);
		sound = 'PickupWeapon';
		break;
	case 'WBOW':	// Weapon_Crossbow
		if (!Toucher.GiveWeapon(wp_crossbow))
		{
			return;
		}
		cprint(Toucher.Player, TXT_WPNCROSSBOW);
		sound = 'PickupWeapon';
		break;
	case 'WBLS':	// Weapon_Blaster
		if (!Toucher.GiveWeapon(wp_blaster))
		{
			return;
		}
		cprint(Toucher.Player, TXT_WPNBLASTER);
		sound = 'PickupWeapon';
		break;
	case 'WSKL':	// Weapon_SkullRod
		if (!Toucher.GiveWeapon(wp_skullrod))
		{
			return;
		}
		cprint(Toucher.Player, TXT_WPNSKULLROD);
		sound = 'PickupWeapon';
		break;
	case 'WPHX':	// Weapon_PhoenixRod
		if (!Toucher.GiveWeapon(wp_phoenixrod))
		{
			return;
		}
		cprint(Toucher.Player, TXT_WPNPHOENIXROD);
		sound = 'PickupWeapon';
		break;
	case 'WGNT':	// Weapon_Gauntlets
		if (!Toucher.GiveWeapon(wp_gauntlets))
		{
			return;
		}
		cprint(Toucher.Player, TXT_WPNGAUNTLETS);
		sound = 'PickupWeapon';
		break;

	default:
		Error("Unknown gettable thing %n", SpriteName);
	}
	if (bCountItem)
	{
		Toucher.Player->ItemCount++;
	}
	if (deathmatch && respawn && !bDropped)
	{
		HideSpecialThing();
	}
	else
	{
		Remove();
	}
	Toucher.Player->BonusCount += BONUSADD;
	Toucher.PlaySound(sound, CHAN_ITEM);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.16  2002/03/16 17:45:13  dj_jl
//  Added Pawn and PlayerPawn classes, beautification.
//
//  Revision 1.15  2002/03/12 19:21:24  dj_jl
//  No need for linefeed in client-printing
//
//  Revision 1.14  2002/02/22 18:00:16  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.13  2002/02/14 19:20:58  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.12  2002/02/09 18:12:25  dj_jl
//  Replaced identifying sprite name indexes with sprite names
//
//  Revision 1.11  2002/02/06 17:28:52  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.10  2002/01/28 18:50:18  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.9  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.8  2002/01/17 18:15:53  dj_jl
//  Renamed all map object classes
//
//  Revision 1.7  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.6  2002/01/11 18:19:41  dj_jl
//  Started to use names in progs
//
//  Revision 1.5  2002/01/07 12:23:17  dj_jl
//  Changed copyright year
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
