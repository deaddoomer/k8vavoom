//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

void DropWeapon(player_t * player);
void ActivateBeak(player_t * player);
void SetupPsprites(player_t * player);
void AddBossSpot(float x, float y, float angle);
void AddMaceSpot(float x, float y);

// DATA DECLARATIONS -------------------------------------------------------

mobj_t *MissileMobj;
classid PuffType;

// CODE --------------------------------------------------------------------

//===========================================================================
//
//  P_GetThingFloorType
//
//===========================================================================

int P_GetThingFloorType(mobj_t * thing)
{
	return TerrainType(thing->Floor->pic);
}

//==========================================================================
//
//  SetOrigin
//
//==========================================================================

void SetOrigin(mobj_t * mobj, TVec origin)
{
	float space;

	mobj->Origin = origin;
	// Set subsector and/or block links.
	P_SetThingPosition(*mobj);
	if (origin.z == ONFLOORZ)
	{
		mobj->Origin.z = mobj->FloorZ;
	}
	else if (origin.z == ONCEILINGZ)
	{
		mobj->Origin.z = mobj->CeilingZ - mobj->Height;
	}
	else if (origin.z == FLOATRANDZ)
	{
		space = mobj->CeilingZ - mobj->Height - mobj->FloorZ;
		if (space > 48.0)
		{
			space -= 40.0;
			mobj->Origin.z = space * Random() + mobj->FloorZ + 40.0;
		}
		else
		{
			mobj->Origin.z = mobj->FloorZ;
		}
	}
	if (mobj->bFootClip && P_GetThingFloorType(mobj) != FLOOR_SOLID &&
		mobj->FloorZ == mobj->Sector->floorheight)
	{
		mobj->FloorClip = FOOTCLIPSIZE;
	}
	else
	{
		mobj->FloorClip = 0.0;
	}
}

//==========================================================================
//
//  CopyMThing
//
//==========================================================================

void CopyMThing(mthing_t * from, mthing_t * to)
{
	to->tid = from->tid;
	to->x = from->x;
	to->y = from->y;
	to->height = from->height;
	to->angle = from->angle;
	to->type = from->type;
	to->options = from->options;
	to->special = from->special;
	to->arg1 = from->arg1;
	to->arg2 = from->arg2;
	to->arg3 = from->arg3;
	to->arg4 = from->arg4;
	to->arg5 = from->arg5;
}

//==========================================================================
//
//	Actor::OnMapSpawn
//
//==========================================================================

void Actor::OnMapSpawn(mthing_t * mthing)
{
	state_t *st;

	spawnhealth = Health;
	sound_sight = GetSoundID(SightSound);
	sound_active = GetSoundID(ActiveSound);
	sound_attack = GetSoundID(AttackSound);
	sound_pain = GetSoundID(PainSound);
	sound_death = GetSoundID(DeathSound);

	bCheckLineBlocking = false;
	bCheckLineBlockMonsters = false;
	if (!bMissile)
	{
		bCheckLineBlocking = true;
		if (Class != PlayerEntity && Class != Pod)
		{
			bCheckLineBlockMonsters = true;
		}
	}

	if (gameskill == sk_nightmare)
	{
		ReactionCount = 0;
	}

	lastlook = P_Random() % MAXPLAYERS;

	// Set the state, but do not use P_SetMobjState, because action
	// routines can't be called yet.  If the spawnstate has an action
	// routine, it will not be called.
	st = &states[SpawnState];
	StateTime = st->time;
	SpriteIndex = st->sprite;
	SpriteName = sprite_names[st->sprite];
	SpriteFrame = st->frame;
	ModelIndex = st->model_index;
	ModelFrame = st->model_frame;
	StateNum = st->statenum;
	NextState = st->nextstate;

	if (mthing)
	{
		float x, y, z;

		x = mthing->x;
		y = mthing->y;
		if (bSpawnCeiling)
		{
			z = ONCEILINGZ;
		}
		else if (bSpawnFloat)
		{
			z = FLOATRANDZ;
		}
		else
		{
			z = ONFLOORZ;
		}
		SetOrigin(this, vector(x, y, z));
		if (bFloatBob)
		{
			// Seed random starting index for bobbing motion
			Health = P_Random();
		}
		if (z == ONFLOORZ)
		{
			Origin.z += mthing->height;
		}
		else if (z == ONCEILINGZ)
		{
			Origin.z -= mthing->height;
		}
		P_SetThingPosition(self);
		TID = mthing->tid;
		Special = mthing->special;
		Args[0] = mthing->arg1;
		Args[1] = mthing->arg2;
		Args[2] = mthing->arg3;
		Args[3] = mthing->arg4;
		Args[4] = mthing->arg5;
		if (StateTime > 0.0)
		{
			StateTime = 0.1 + Random() * StateTime;
		}
		if (bCountKill)
		{
			level->totalkills++;
			CopyMThing(mthing, &spawnpoint);
		}
		if (bCountItem)
		{
			level->totalitems++;
		}
		Angles.yaw = itof(45 * (mthing->angle / 45));
		if (mthing->options & MTF_AMBUSH)
		{
			bAmbush = true;
		}
		if (mthing->options & MTF_DORMANT)
		{
			bDormant = true;
			StateTime = -1.0;
		}
	}
	else
	{
		SetOrigin(this, Origin);
	}
}

//===========================================================================
//
//  P_SpawnMobj
//
//===========================================================================

mobj_t *P_SpawnMobj(float x, float y, float z, classid type)
{
	mobj_t *mobj;

	mobj = &Actor(NewMobjThinker(type));

	mobj->Origin = vector(x, y, z);
	mobj->OnMapSpawn(NULL);
	return mobj;
}

//===========================================================================
//
//  P_RemoveMobj
//
//===========================================================================

void P_RemoveMobj(mobj_t * mobj)
{
	// free block
	RemoveMobjThinker(*mobj);
}

//===========================================================================
//
//  P_FaceMobj
//
//  Returns 1 if 'source' needs to turn clockwise, or 0 if 'source' needs
// to turn counter clockwise.  'delta' is set to the amount 'source'
// needs to turn.
//
//===========================================================================

int P_FaceMobj(mobj_t * source, mobj_t * target, float * delta)
{
	float diff;
	float angle1;
	float angle2;

	angle1 = source->Angles.yaw;
	angle2 = atan2(target->Origin.y - source->Origin.y,
		target->Origin.x - source->Origin.x);
	if (angle2 > angle1)
	{
		diff = AngleMod360(angle2 - angle1);
		if (diff > 180.0)
		{
			*delta = 360.0 - diff;
			return 0;
		}
		else
		{
			*delta = diff;
			return 1;
		}
	}
	else
	{
		diff = AngleMod360(angle1 - angle2);
		if (diff > 180.0)
		{
			*delta = 360.0 - diff;
			return 1;
		}
		else
		{
			*delta = diff;
			return 0;
		}
	}
}

//===========================================================================
//
//  P_ExplodeMissile
//
//===========================================================================

void P_ExplodeMissile(mobj_t * mo)
{
	if (mo->Class == WhirlWind)
	{
		if (++mo->special2 < 60)
		{
			return;
		}
	}
	mo->Velocity = vector(0.0, 0.0, 0.0);
	mo->SetState(mo->DeathState);
	//mo->tics -= P_Random()&3;
	mo->bMissile = false;
	if (mo->sound_death)
	{
		StartSound(*mo, mo->sound_death, CHAN_VOICE);
	}
	if (mo->Effects & EF_DLIGHT_MASK)
	{
		MSG_Select(MSG_SV_DATAGRAM);
		MSG_WriteByte(svc_explosion);
		MSG_WriteByte(mo->Effects & EF_DLIGHT_MASK);
		MSG_WriteShort(ftoi(mo->Origin.x));
		MSG_WriteShort(ftoi(mo->Origin.y));
		MSG_WriteShort(ftoi(mo->Origin.z));
		mo->Effects &= ~EF_DLIGHT_MASK;
	}
}

//==========================================================================
//
//  P_KillMobj
//
//==========================================================================

void P_KillMobj(mobj_t * source, mobj_t * target)
{
	target->bShootable = false;
	target->bNoGravity = false;
	target->bFloat = false;
	target->bSkullFly = false;
	target->bDropOff = true;
	target->bCorpse = true;
	target->bNoPassMobj = true;
	target->Height /= 4.0;
	if (source && source->bIsPlayer)
	{
		if (target->bCountKill)
		{
			// Count for intermission
			source->Player->killcount++;
		}
		if (target->bIsPlayer)
		{
			if (source->Player->is_bot)
			{
				source->Player->Bot.Killed(*target);
			}

			if (target->Player->is_bot)
			{
				target->Player->Bot.Died(*source);
			}

			// Frag stuff
			if (target == source)
			{
				// Self-frag
				target->Player->frags[P_GetPlayerNum(target->Player)]--;
			}
			else
			{
				source->Player->frags[P_GetPlayerNum(target->Player)]++;
				StartSoundName(*source->Player->mo, 'Frag', CHAN_ITEM);
				if (source->Player->chickenTics)
				{
					// Make a super chicken
					source->GivePower(pw_weaponlevel2);
				}
			}
		}
	}
	else if (!netgame && target->bCountKill)
	{
		// Count all monster deaths
		players[0].killcount++;
	}
	if (target->bIsPlayer)
	{
		if (!source)
		{
			// Self-frag
			target->Player->frags[P_GetPlayerNum(target->Player)]--;
		}
		target->bSolid = false;
		target->bFly = false;
		target->Player->powers[pw_flight] = 0;
		target->Player->powers[pw_weaponlevel2] = 0;
		target->Player->playerstate = PST_DEAD;
		DropWeapon(target->Player);
		if (target->bFireDamage)
		{
			// Player flame death
			target->SetState(S_PLAY_FDTH1);
			//StartSoundName(target, sfx2_hedat1); // Burn sound
			return;
		}
	}
	if (target->Health < target->GibsHealth && target->GibsDeathState)
	{
		// Extreme death
		target->SetState(target->GibsDeathState);
	}
	else
	{
		// Normal death
		target->SetState(target->DeathState);
	}
	target->StateTime -= Random() * 0.1;
}

//==========================================================================
//
//  P_MinotaurSlam
//
//==========================================================================

void P_MinotaurSlam(mobj_t * source, mobj_t * target)
{
	float angle;
	float thrust;

	angle = atan2(target->Origin.y - source->Origin.y,
		target->Origin.x - source->Origin.x);
	thrust = 16.0 + Random() * 4.0;
	target->Velocity.x += thrust * cos(angle) * 35.0;
	target->Velocity.y += thrust * sin(angle) * 35.0;
	target->Damage(none, none, HITDICE(6));
	if (target->Player)
	{
		target->ReactionTime = 0.4 + Random() * 0.2;
	}
}

//==========================================================================
//
//  P_TouchWhirlwind
//
//==========================================================================

void P_TouchWhirlwind(mobj_t * target)
{
	float randVal;

	target->Angles.yaw = AngleMod360(target->Angles.yaw +
		(Random() - Random()) * 45.0 / 2.0);
	target->Velocity.x += (Random() - Random()) * 4.0 * 35.0;
	target->Velocity.y += (Random() - Random()) * 4.0 * 35.0;
	if (level->tictime & 16 && !target->bBoss)
	{
		randVal = Random() * 4.0;
		if (randVal > 2.5)
		{
			randVal = 2.5;
		}
		target->Velocity.z += randVal * 35.0;
		if (target->Velocity.z > 12.0 * 35.0)
		{
			target->Velocity.z = 12.0 * 35.0;
		}
	}
	if (!(level->tictime & 7))
	{
		target->Damage(none, none, 3);
	}
}

//==========================================================================
//
//  ChickenMorphPlayer
//
//  Returns true if the player gets turned into a chicken.
//
//==========================================================================

boolean ChickenMorphPlayer(player_t * player)
{
	mobj_t *pmo;
	mobj_t *fog;
	mobj_t *chicken;
	float x;
	float y;
	float z;
	float angle;
	boolean OldbFly;

	if (player->chickenTics)
	{
		if ((player->chickenTics < ftoi(CHICKENTIME * 35.0) - TICRATE)
			&& !player->powers[pw_weaponlevel2])
		{
			// Make a super chicken
			player->mo->GivePower(pw_weaponlevel2);
		}
		return false;
	}
	if (player->powers[pw_invulnerability])
	{
		// Immune when invulnerable
		return false;
	}
	pmo = player->mo;
	x = pmo->Origin.x;
	y = pmo->Origin.y;
	z = pmo->Origin.z;
	angle = pmo->Angles.yaw;
	OldbFly = pmo->bFly;
	pmo->SetState(S_FREETARGMOBJ);
	fog = P_SpawnMobj(x, y, z + TELEFOGHEIGHT, TeleportFog);
	StartSoundName(*fog, 'Teleport', CHAN_VOICE);
	chicken = P_SpawnMobj(x, y, z, ChickenPlayer);
	chicken->special1 = player->readyweapon;
	chicken->Angles.yaw = angle;
	chicken->Player = player;
	chicken->bIsPlayer = true;
	player->health = chicken->Health = MAXCHICKENHEALTH;
	player->mo = chicken;
	player->armorpoints = player->armortype = 0;
	player->powers[pw_invisibility] = 0;
	player->powers[pw_weaponlevel2] = 0;
	chicken->bFly = OldbFly;
	player->chickenTics = ftoi(CHICKENTIME * 35.0);
	ActivateBeak(player);
	return true;
}

//==========================================================================
//
//  P_ChickenMorph
//
//==========================================================================

boolean P_ChickenMorph(mobj_t * actor)
{
	mobj_t *fog;
	mobj_t *chicken;
	mobj_t *target;
	classid moType;
	float x;
	float y;
	float z;
	float angle;
	int ghost;

	if (actor->bIsPlayer)
	{
		return false;
	}
	moType = actor->Class;
	switch (moType)
	{
	case Pod:
	case Chicken:
	case Head:
	case Minotaur:
	case Sorcerer1:
	case Sorcerer2:
		return false;
	default:
		break;
	}
	x = actor->Origin.x;
	y = actor->Origin.y;
	z = actor->Origin.z;
	angle = actor->Angles.yaw;
	ghost = actor->Translucency;
	target = actor->target;
	actor->SetState(S_FREETARGMOBJ);
	fog = P_SpawnMobj(x, y, z + TELEFOGHEIGHT, TeleportFog);
	StartSoundName(*fog, 'Teleport', CHAN_VOICE);
	chicken = P_SpawnMobj(x, y, z, Chicken);
	chicken->specialcid = moType;
	chicken->special1 = ftoi(CHICKENTIME * 35.0) + P_Random();
	chicken->Translucency = ghost;
	chicken->target = target;
	chicken->Angles.yaw = angle;
	return true;
}

//==========================================================================
//
//  P_AutoUseChaosDevice
//
//==========================================================================

boolean P_AutoUseChaosDevice(player_t * player)
{
	int i;

	for (i = 0; i < player->inventorySlotNum; i++)
	{
		if (player->inventory[i].type == arti_teleport)
		{
			PlayerUseArtifact(player, arti_teleport);
			player->health = player->mo->Health = (player->health + 1) / 2;
			return true;
		}
	}
	return false;
}

//==========================================================================
//
//  P_AutoUseHealth
//
//==========================================================================

void P_AutoUseHealth(player_t * player, int saveHealth)
{
	int i;
	int count;
	int normalCount;
	int normalSlot;
	int superCount;
	int superSlot;

	normalCount = superCount = 0;
	for (i = 0; i < player->inventorySlotNum; i++)
	{
		if (player->inventory[i].type == arti_health)
		{
			normalSlot = i;
			normalCount = player->inventory[i].count;
		}
		else if (player->inventory[i].type == arti_superhealth)
		{
			superSlot = i;
			superCount = player->inventory[i].count;
		}
	}
	if ((gameskill == sk_baby) && (normalCount * 25 >= saveHealth))
	{
		// Use quartz flasks
		count = (saveHealth + 24) / 25;
		for (i = 0; i < count; i++)
		{
			player->health += 25;
			PlayerRemoveArtifact(player, normalSlot);
		}
	}
	else if (superCount * 100 >= saveHealth)
	{
		// Use mystic urns
		count = (saveHealth + 99) / 100;
		for (i = 0; i < count; i++)
		{
			player->health += 100;
			PlayerRemoveArtifact(player, superSlot);
		}
	}
	else if ((gameskill == sk_baby)
		&& (superCount * 100 + normalCount * 25 >= saveHealth))
	{
		// Use mystic urns and quartz flasks
		count = (saveHealth + 24) / 25;
		saveHealth -= count * 25;
		for (i = 0; i < count; i++)
		{
			player->health += 25;
			PlayerRemoveArtifact(player, normalSlot);
		}
		count = (saveHealth + 99) / 100;
		for (i = 0; i < count; i++)
		{
			player->health += 100;
			//  I found a bug. There must be used superSlot, not normalSlot.
			//  Also if player used all quartz flasks, superSlot may be
			// invalid, so it must be found again.
			PlayerRemoveArtifact(player, superSlot);
		}
	}
	player->mo->Health = player->health;
}

//==========================================================================
//
//  Actor::Damage
//
//  Damages both enemies and players.
//  inflictor is the thing that caused the damage creature or missile, can
// be NULL (slime, etc)
//  source is the thing to target after taking damage creature or NULL
//  Source and inflictor are the same for melee attacks
//  source can be null for barrel explosions and other environmental stuff
//
//==========================================================================

void Actor::Damage(Actor inflictor, Actor source, int damage)
{
	int saved;

	if (!bShootable)
	{
		// Shouldn't happen
		return;
	}
	if (Health <= 0)
	{
		return;
	}
	if (bSkullFly)
	{
		if (Class == Minotaur)
		{
			// Minotaur is invulnerable during charge attack
			return;
		}
		Velocity = vector(0.0, 0.0, 0.0);
	}
	if (bDormant)
	{
		// Invulnerable, and won't wake up
		return;
	}
	if (bIsPlayer && gameskill == sk_baby)
	{
		// Take half damage in trainer mode
		damage >>= 1;
	}
	// Special damage types
	if (inflictor)
	{
		switch (inflictor.Class)
		{
		case EggMissile:
			if (bIsPlayer)
			{
				ChickenMorphPlayer(Player);
			}
			else
			{
				P_ChickenMorph(this);
			}
			return;	// Always return
		case WhirlWind:
			P_TouchWhirlwind(this);
			return;
		case Minotaur:
			if (inflictor.bSkullFly)
			{
				// Slam only when in charge mode
				P_MinotaurSlam(&inflictor, this);
				return;
			}
			break;
		case MaceFX4:	// Death ball
			if (bBoss || Class == Head)
			{
				// Don't allow cheap boss kills
				break;
			}
			else if (bIsPlayer)
			{
				// Player specific checks
				if (Player->powers[pw_invulnerability])
				{
					// Can't hurt invulnerable players
					break;
				}
				if (P_AutoUseChaosDevice(Player))
				{
					// Player was saved using chaos device
					return;
				}
			}
			damage = 10000;	// Something's gonna die
			break;
		case PhoenixFX2:	// Flame thrower
			if (Player && P_Random() < 128)
			{
				// Freeze player for a bit
				ReactionTime += 0.125;
			}
			break;
		case RainPlayer1:	// Rain missiles
		case RainPlayer2:
		case RainPlayer3:
		case RainPlayer4:
			if (bBoss)
			{
				// Decrease damage for bosses
				damage = (P_Random() & 7) + 1;
			}
			break;
		case HornRodMissile2:
		case PhoenixFX1:
			if (Class == Sorcerer2 && P_Random() < 96)
			{
				// D'Sparil teleports away
				DSparilTeleport();
				return;
			}
			break;
		case BlasterFX1:
		case Ripper:
			if (Class == Head)
			{
				// Less damage to Ironlich bosses
				damage = P_Random() & 1;
				if (!damage)
				{
					return;
				}
			}
			break;
		default:
			break;
		}
	}
	// Push the target unless source is using the gauntlets
	if (inflictor && (!source || !source.bIsPlayer ||
			source.Player->readyweapon != wp_gauntlets) &&
			!inflictor.bNoDamageThrust)
	{
		TVec dir;
		float thrust;

		if (source && source.bIsPlayer && (source == inflictor)
			&& source.Player->powers[pw_weaponlevel2]
			&& source.Player->readyweapon == wp_staff)
		{
			// Staff power level 2
			thrust = 350.0;
		}
		else
		{
			thrust = itof(damage) / Mass * 656.25;
		}

		dir = MobjCenter(self) - MobjCenter(inflictor);
		if (bNoGravity)
		{
			dir.z = 0.0;
		}
		Velocity += Normalize(dir) * thrust;
	}

	//
	// player specific
	//
	if (bIsPlayer)
	{
		if (damage < 1000 && ((Player->cheats & CF_GODMODE)
				|| Player->powers[pw_invulnerability]))
		{
			return;
		}
		if (Player->armortype)
		{
			if (Player->armortype == 1)
			{
				saved = damage >> 1;
			}
			else
			{
				saved = (damage >> 1) + (damage >> 2);
			}
			if (Player->armorpoints <= saved)
			{
				// armor is used up
				saved = Player->armorpoints;
				Player->armortype = 0;
			}
			Player->armorpoints -= saved;
			damage -= saved;
		}
		if (damage >= Player->health
			&& ((gameskill == sk_baby) || deathmatch) && !Player->chickenTics)
		{
			// Try to use some inventory health
			P_AutoUseHealth(Player, damage - Health + 1);
		}
		Player->health -= damage;	// mirror mobj health here for Dave
		if (Player->health < 0)
		{
			Player->health = 0;
		}
		Player->attacker = &source;
		Player->damagecount += damage;	// add damage after armor / invuln
		if (Player->damagecount > 100)
		{
			Player->damagecount = 100;	// teleport stomp does 10k points...
		}
	}

	//
	// do the damage
	//
	Health -= damage;
	if (Health <= 0)
	{
		// Death
		special1 = damage;
		if (Class == Pod && source && source.Class != Pod)
		{
			// Make sure players get frags for chain-reaction kills
			target = &source;
		}
		if (bIsPlayer && inflictor && !Player->chickenTics)
		{
			// Check for flame death
			if (inflictor.bFireDamage
				|| ((inflictor.Class == PhoenixFX1)
					&& (Health > -50) && (damage > 25)))
			{
				bFireDamage = true;
			}
		}
		P_KillMobj(&source, this);
		return;
	}
	if ((P_Random() < PainChance) && !bSkullFly)
	{
		bJustHit = true;	// fight back!
		SetState(PainState);
	}
	ReactionCount = 0;	// we're awake now...
	if (!threshold && source && !source.bBoss &&
		!(Class == Sorcerer2 && source.Class == Wizard))
	{
		// Target actor is not intent on another actor,
		// so make him chase after source
		target = &source;
		threshold = BASETHRESHOLD;
		if (StateNum == SpawnState && SeeState != S_NULL)
		{
			SetState(SeeState);
		}
	}
}

//==========================================================================
//
//  SpawnPuff
//
//==========================================================================

void SpawnPuff(float x, float y, float z)
{
	mobj_t *puff;

	z += (Random() - Random()) * 4.0;
	puff = P_SpawnMobj(x, y, z, PuffType);
	if (puff->sound_attack)
	{
		StartSound(*puff, puff->sound_attack, CHAN_VOICE);
	}
	switch (PuffType)
	{
	case BeakPuff:
	case StaffPuff:
		puff->Velocity.z = 1.0 * 35.0;
		break;
	case GauntletPuff1:
	case GauntletPuff2:
		puff->Velocity.z = 0.8 * 35.0;
	default:
		break;
	}
	if (PuffType == GoldWandPuff1)
	{
		MSG_Select(MSG_SV_DATAGRAM);
		MSG_WriteByte(svc_explosion);
		MSG_WriteByte(EF_DL_WHITE);
		MSG_WriteShort(ftoi(x));
		MSG_WriteShort(ftoi(y));
		MSG_WriteShort(ftoi(z));
	}
	if (PuffType == BlasterFX1)
	{
		MSG_Select(MSG_SV_DATAGRAM);
		MSG_WriteByte(svc_explosion);
		MSG_WriteByte(EF_DL_BLUE);
		MSG_WriteShort(ftoi(x));
		MSG_WriteShort(ftoi(y));
		MSG_WriteShort(ftoi(z));
	}
}

//==========================================================================
//
//  P_BloodSplatter
//
//==========================================================================

void P_BloodSplatter(float x, float y, float z, mobj_t * originator)
{
	mobj_t *mo;

	mo = P_SpawnMobj(x, y, z, BloodSplatter);
	mo->target = originator;
	mo->Velocity.x = (Random() - Random()) * 2.0 * 35.0;
	mo->Velocity.y = (Random() - Random()) * 2.0 * 35.0;
	mo->Velocity.z = 2.0 * 35.0;
}

//==========================================================================
//
//  P_RipperBlood
//
//==========================================================================

void P_RipperBlood(mobj_t * mo)
{
	mobj_t *th;
	float x, y, z;

	x = mo->Origin.x + (Random() - Random()) * 16.0;
	y = mo->Origin.y + (Random() - Random()) * 16.0;
	z = mo->Origin.z + (Random() - Random()) * 16.0;
	th = P_SpawnMobj(x, y, z, Blood);
	th->bNoGravity = true;
	th->Velocity.x = mo->Velocity.x / 2.0;
	th->Velocity.y = mo->Velocity.y / 2.0;
	th->StateTime += Random() * 0.1;
}

//==========================================================================
//
//  P_SpawnPlayer
//
//  Called when a player is spawned on the level
//  Most of the player structure stays unchanged between levels
//
//==========================================================================

void P_SpawnPlayer(mthing_t * mthing)
{
	player_t *p;
	float x, y, z;
	mobj_t *mobj;

	p = &players[mthing->type - 1];

	if (!p->active)
		return;	// not playing

	if (p->playerstate == PST_REBORN)
	{
		G_PlayerReborn(mthing->type - 1);
	}
	x = mthing->x;
	y = mthing->y;

	z = ONFLOORZ;
	mobj = P_SpawnMobj(x, y, z, PlayerEntity);
	// set color translations for player sprites
	mobj->Translation = p->color;

	mobj->Angles.yaw = itof(45 * (mthing->angle / 45));
	mobj->Player = p;
	mobj->bIsPlayer = true;
	mobj->Health = p->health;
	p->mo = mobj;
	p->playerstate = PST_LIVE;
	p->refire = 0;
	p->damagecount = 0;
	p->bonuscount = 0;
	p->chickenTics = 0;
	p->rain1 = NULL;
	p->rain2 = NULL;
	p->extralight = 0;
	p->fixedcolormap = 0;
	p->viewheight = VIEWHEIGHT;
	p->viewangles = mobj->Angles;
	p->fixangle = true;
	SetupPsprites(p);	// setup gun psprite
	if (deathmatch)
	{
		// Give all keys in death match mode
		p->keys = 7;
	}
	if (p->is_bot)
	{
		p->Bot.OnSpawn();
	}
}

//==========================================================================
//
//  P_SpawnMapThing
//
//==========================================================================

void P_SpawnMapThing(mthing_t * mthing, boolean spawn_thinkers)
{
	int i;
	int bit;
	mobj_t *mobj;
	int spawnMask;

	if (mthing->type <= 0)
	{
		return;
	}

	// count deathmatch start positions
	if (mthing->type == 11)
	{
		if (level->numdeathmatchstarts < MAXDEATHMATCHSTARTS)
		{
			CopyMThing(mthing,
				&level->deathmatchstarts[level->numdeathmatchstarts]);
			level->numdeathmatchstarts++;
		}
		return;
	}

	// check for players specially
	if (mthing->type <= 4)
	{
		// save spots for respawning in network games
		CopyMThing(mthing,
			&level->playerstarts[mthing->arg1 * MAXPLAYERS + mthing->type -
				1]);
		return;
	}

	// Ambient sound sequences
	if (mthing->type >= 1200 && mthing->type < 1300)
	{
		P_AddAmbientSfx(mthing->type - 1200);
		return;
	}

	// Check for boss spots
	if (mthing->type == 56)	// Monster_BossSpot
	{
		AddBossSpot(mthing->x, mthing->y, itof(45 * (mthing->angle / 45)));
		return;
	}

	if (mthing->type == PO_SPAWN_TYPE || mthing->type == PO_SPAWNCRUSH_TYPE)
	{
		// Polyobj StartSpot Pt.
		SpawnPolyobj(mthing->x, mthing->y, mthing->angle,
			(mthing->type == PO_SPAWNCRUSH_TYPE));
		return;
	}
	if (mthing->type == PO_ANCHOR_TYPE)
	{
		// Polyobj Anchor Pt.
		AddAnchorPoint(mthing->x, mthing->y, mthing->angle);
		return;
	}

	// Check current game type with spawn flags
	if (netgame == false)
	{
		spawnMask = MTF_GSINGLE;
	}
	else if (deathmatch)
	{
		spawnMask = MTF_GDEATHMATCH;
	}
	else
	{
		spawnMask = MTF_GCOOP;
	}
	if (!(mthing->options & spawnMask))
	{
		return;
	}

	// check for apropriate skill level
	if (gameskill == sk_baby)
		bit = 1;
	else if (gameskill == sk_nightmare)
		bit = 4;
	else
		bit = 1 << (gameskill - 1);
	if (!(mthing->options & bit))
		return;

	// find which type to spawn
	for (i = 0; i < num_mobj_types; i++)
		if (mthing->type == mobjinfo[i].doomednum)
			break;

	if (i == num_mobj_types)
	{
		dprint("P_SpawnMapThing: Unknown type %i at (%f, %f)\n",
			mthing->type, mthing->x, mthing->y);
		return;
	}

	// spawn it
	switch (mobjinfo[i].class_id)
	{
		// Special stuff
	case ItemWeaponSkullRod:
	case ItemWeaponPhoenixRod:
	case ItemAmmoSkullRodWimpy:
	case ItemAmmoSkullRodHefty:
	case ItemAmmoPhoenixWimpy:
	case ItemAmmoPhoenixHefty:
	case ItemAmmoMaceWimpy:
	case ItemAmmoMaceHefty:
	case ArtifactSuperHeal:
	case ArtifactTeleport:
	case ItemShield2:
		if (shareware)
		{
			// Don't place on map in shareware version
			return;
		}
		break;
	case ItemWeaponMace:
		if (!shareware)
		{
			// Put in the mace spot list
			AddMaceSpot(mthing->x, mthing->y);
			return;
		}
		return;
	default:
		break;
	}
	if (!spawn_thinkers)
	{
		return;
	}

	mobj = &Actor(NewMobjThinker(mobjinfo[i].class_id));
	mobj->OnMapSpawn(mthing);
}

//==========================================================================
//
//  P_HitFloor
//
//==========================================================================

int P_HitFloor(mobj_t * thing)
{
	mobj_t *mo;

	if (thing->FloorZ != thing->Sector->floorheight)
	{
		// don't splash if landing on the edge above water/lava/etc....
		return FLOOR_SOLID;
	}
	switch (P_GetThingFloorType(thing))
	{
	case FLOOR_WATER:
		P_SpawnMobj(thing->Origin.x, thing->Origin.y, ONFLOORZ, SplashBase);
		mo = P_SpawnMobj(thing->Origin.x, thing->Origin.y, ONFLOORZ, Splash);
		mo->target = thing;
		mo->Velocity.x = (Random() - Random()) * 35.0;
		mo->Velocity.y = (Random() - Random()) * 35.0;
		mo->Velocity.z = (2.0 + Random()) * 35.0;
		StartSoundName(*mo, 'WaterSplash', CHAN_VOICE);
		return FLOOR_WATER;
	case FLOOR_LAVA:
		P_SpawnMobj(thing->Origin.x, thing->Origin.y, ONFLOORZ, LavaSplash);
		mo = P_SpawnMobj(thing->Origin.x, thing->Origin.y, ONFLOORZ,
			LavaSmoke);
		mo->Velocity.z = (1.0 + Random() / 2.0) * 35.0;
		StartSoundName(*mo, 'Burn', CHAN_VOICE);
		return FLOOR_LAVA;
	case FLOOR_SLUDGE:
		P_SpawnMobj(thing->Origin.x, thing->Origin.y, ONFLOORZ,
			SludgeSplash);
		mo = P_SpawnMobj(thing->Origin.x, thing->Origin.y, ONFLOORZ,
			SludgeChunk);
		mo->target = thing;
		mo->Velocity.x = (Random() - Random()) * 35.0;
		mo->Velocity.y = (Random() - Random()) * 35.0;
		mo->Velocity.z = (1.0 + Random()) * 35.0;
		return FLOOR_SLUDGE;
	}
	return FLOOR_SOLID;
}

//===========================================================================
//
//  P_FloorBounceMissile
//
//===========================================================================

void P_FloorBounceMissile(mobj_t * mo)
{
	mo->Velocity.z = -mo->Velocity.z;
	mo->SetState(mo->DeathState);
}

//===========================================================================
//
//  P_ThrustMobj
//
//===========================================================================

void P_ThrustMobj(mobj_t * mo, float angle, float move)
{
	mo->Velocity.x += move * cos(angle) * 35.0;
	mo->Velocity.y += move * sin(angle) * 35.0;
}

//**************************************************************************
//
//      NOISE ALERT
//
//**************************************************************************

mobj_t *soundtarget;

//==========================================================================
//
//  P_RecursiveSound
//
//  Called by P_NoiseAlert. Recursively traverse adjacent sectors, sound
// blocking lines cut off traversal.
//
//==========================================================================

void P_RecursiveSound(sector_t * sec, int soundblocks)
{
	int i;
	line_t *check;
	sector_t *other;

	// wake up all monsters in this sector
	if (sec->validcount == *validcount &&
		sec->soundtraversed <= soundblocks + 1)
	{
		return;	// already flooded
	}

	sec->validcount = *validcount;
	sec->soundtraversed = soundblocks + 1;
	sec->SoundTarget = *soundtarget;

	for (i = 0; i < sec->linecount; i++)
	{
		check = sec->lines[i];
		if (!(check->flags & ML_TWOSIDED))
			continue;

		if (!LineOpenings(check, *check->v1))
		{
			if (!LineOpenings(check, *check->v2))
				continue;	// closed door
		}

		if (level->sides[check->sidenum[0]].sector == sec)
			other = level->sides[check->sidenum[1]].sector;
		else
			other = level->sides[check->sidenum[0]].sector;

		if (check->flags & ML_SOUNDBLOCK)
		{
			if (!soundblocks)
				P_RecursiveSound(other, 1);
		}
		else
			P_RecursiveSound(other, soundblocks);
	}
}

//==========================================================================
//
//  P_NoiseAlert
//
//  If a monster yells at a player, it will alert other monsters to the
// player.
//
//==========================================================================

void P_NoiseAlert(mobj_t * target, mobj_t * emmiter)
{
	soundtarget = target;
	(*validcount)++;
	P_RecursiveSound(emmiter->Sector, 0);
}

//===========================================================================
//
//  P_NightmareRespawn
//
//===========================================================================

void P_NightmareRespawn(mobj_t * mobj)
{
	float x, y, z;
	mobj_t *mo;
	mthing_t *mthing;

	x = mobj->spawnpoint.x;
	y = mobj->spawnpoint.y;

	if (!CheckPosition(*mobj, vector(x, y, ONFLOORZ)))
		return;	// somthing is occupying it's position

	// spawn a teleport fog at old spot
	mo = P_SpawnMobj(mobj->Origin.x, mobj->Origin.y, ONFLOORZ, TeleportFog);
	mo->Origin.z += TELEFOGHEIGHT;
	StartSoundName(*mo, 'Teleport', CHAN_VOICE);

	// spawn a teleport fog at the new spot
	mo = P_SpawnMobj(x, y, ONFLOORZ, TeleportFog);
	mo->Origin.z += TELEFOGHEIGHT;
	StartSoundName(*mo, 'Teleport', CHAN_VOICE);

	// spawn the new monster
	mthing = &mobj->spawnpoint;

	// spawn it
	if (mobj->bSpawnCeiling)
		z = ONCEILINGZ;
	else
		z = ONFLOORZ;
	mo = P_SpawnMobj(x, y, z, mobj->Class);
	CopyMThing(&mobj->spawnpoint, &mo->spawnpoint);
	mo->Angles.yaw = itof(45 * (mthing->angle / 45));
	if (mthing->options & MTF_AMBUSH)
		mo->bAmbush = true;

	mo->ReactionCount = 18;

	// remove the old monster
	P_RemoveMobj(mobj);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.32  2002/02/14 19:20:58  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.31  2002/02/09 18:13:46  dj_jl
//  Added flags that determines what line blocking flags to check
//
//  Revision 1.30  2002/02/07 18:50:08  dj_jl
//  Made CheckPosition shared.
//
//  Revision 1.29  2002/02/06 17:28:52  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.28  2002/02/02 19:17:25  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.27  2002/01/29 18:11:23  dj_jl
//  Added dormant things
//
//  Revision 1.26  2002/01/28 18:50:18  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.25  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.24  2002/01/24 18:19:26  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.23  2002/01/17 18:15:53  dj_jl
//  Renamed all map object classes
//
//  Revision 1.22  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.21  2002/01/15 08:10:57  dj_jl
//  Added P_CheckRelPosition
//
//  Revision 1.20  2002/01/12 18:00:47  dj_jl
//  Sound names initialized as names
//
//  Revision 1.19  2002/01/11 18:19:41  dj_jl
//  Started to use names in progs
//
//  Revision 1.18  2002/01/07 12:23:17  dj_jl
//  Changed copyright year
//
//  Revision 1.17  2001/12/27 17:52:23  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.16  2001/12/18 18:35:26  dj_jl
//  Added polyobjs
//
//  Revision 1.15  2001/12/12 18:57:41  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.14  2001/12/04 18:36:42  dj_jl
//  Bots, directly from SkullTag!
//
//  Revision 1.13  2001/12/01 18:14:09  dj_jl
//  Changed MSG_Select, beautification
//
//  Revision 1.12  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.11  2001/10/22 17:23:12  dj_jl
//  Floatification of angles
//
//  Revision 1.10  2001/10/18 17:39:33  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.9  2001/10/09 17:41:17  dj_jl
//  Beautification
//
//  Revision 1.8  2001/10/02 17:42:38  dj_jl
//  Possibility to declare function's code inside class declaration
//
//  Revision 1.7  2001/09/27 17:08:19  dj_jl
//  Removed spawn functions, added mobj classes
//
//  Revision 1.6  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.5  2001/08/31 17:17:23  dj_jl
//  Removed vector macros
//  
//  Revision 1.4  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.3  2001/07/31 16:59:30  dj_jl
//  Set model when spawning object
//
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
