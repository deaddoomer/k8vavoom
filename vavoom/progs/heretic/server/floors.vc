//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

enum
{
	FLEV_LOWERFLOOR,	// lower floor to highest surrounding floor
	FLEV_LOWERFLOORTOLOWEST,	// lower floor to lowest surrounding floor
	FLEV_LOWERTOHIGHEST,	// lower floor to highest surrounding floor VERY FAST
	FLEV_RAISEFLOOR,	// raise floor to lowest surrounding CEILING
	FLEV_RAISEFLOORTONEAREST,	// raise floor to next highest surrounding floor
	FLEV_RAISETOTEXTURE,	// raise floor to shortest height texture around it
	FLEV_LOWERTOLOWESTCHANGE,	// lower floor to lowest surrounding floor and change
	// floorpic
	FLEV_RAISEFLOORBYVALUE,
	FLEV_RAISEFLOORBYVALUECHANGE,
	FLEV_RAISEFLOORCRUSH,
	FLEV_DONUT,
	raiseBuildStep,	// One step of a staircase

	FLEV_RAISEFLOORBYVALUECHANGE2,
	FLEV_RAISEFLOORTONEARESTCHANGE
};

// TYPES -------------------------------------------------------------------

class TFloor:Thinker
{
	sector_t *sector;
	int type;
	float speed;
	boolean crush;
	int direction;	// 1 = up, 0 = waiting, -1 = down
	int newspecial;
	int texture;
	float floordestheight;

	void Think(void);
	void Archive(void);
	void Unarchive(void);
};

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//	TFloor::Think
//
//  MOVE A FLOOR TO IT'S DESTINATION (UP OR DOWN)
//
//==========================================================================

void TFloor::Think(void)
{
	int res;

	res = T_MovePlane(sector, speed * frametime,
		floordestheight, crush, 0, direction);
	if (!(level->tictime & 7))
	{
		if (type == FLEV_RAISEFLOORBYVALUECHANGE2 ||
			type == FLEV_RAISEFLOORTONEARESTCHANGE)
			SectorStartSoundName(sector, "PlatformMove", CHAN_VOICE);
		else
			SectorStartSoundName(sector, "DoorMove", CHAN_VOICE);
	}

	if (res == RES_PASTDEST)
	{
		sector->specialdata = NULL;
		if (type == raiseBuildStep ||
			type == FLEV_RAISEFLOORBYVALUECHANGE2 ||
			type == FLEV_RAISEFLOORTONEARESTCHANGE)
		{
			SectorStartSoundName(sector, "PlatformStop", CHAN_VOICE);
		}
		if (direction == 1)
			switch (type)
			{
			case FLEV_DONUT:
				sector->special = newspecial;
				SetFloorPic(sector, texture);
			default:
				break;
			}
		else if (direction == -1)
			switch (type)
			{
			case FLEV_LOWERTOLOWESTCHANGE:
				sector->special = newspecial;
				SetFloorPic(sector, texture);
			default:
				break;
			}
		RemoveSpecialThinker(this);
	}
}

//==========================================================================
//
//  TFloor::Archive
//
//==========================================================================

void TFloor::Archive(void)
{
	sector = SectorToNum(sector);
}

//==========================================================================
//
//  TFloor::Unarchive
//
//==========================================================================

void TFloor::Unarchive(void)
{
	sector = NumToSector(sector);
	sector->specialdata = this;
}

//==========================================================================
//
//  EV_DoFloor
//
//  HANDLE FLOOR TYPES
//
//==========================================================================

int EV_DoFloor(line_t * line, int *args, int floortype)
{
	int secnum;
	int rtn;
	int i;
	sector_t *sec;
	TFloor *floor;
	float minsize = 99999.0;
	side_t *side;
	line_t *secline;

	secnum = -1;
	rtn = 0;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &level->sectors[secnum];

		//  ALREADY MOVING?  IF SO, KEEP GOING...
		if (sec->specialdata)
			continue;

		//
		//  new floor thinker
		//
		rtn = 1;
		floor = NewSpecialThinker(TFloor);
		sec->specialdata = floor;
		floor->sector = sec;
		floor->type = floortype;
		floor->crush = false;
		floor->speed = itof(args[1]) * 4.0;
		switch (floortype)
		{
		case FLEV_LOWERFLOOR:
			floor->direction = -1;
			floor->floordestheight = FindHighestFloorSurrounding(sec);
			break;

		case FLEV_LOWERFLOORTOLOWEST:
			floor->direction = -1;
			floor->floordestheight = FindLowestFloorSurrounding(sec);
			break;

		case FLEV_LOWERTOHIGHEST:
			floor->direction = -1;
			floor->floordestheight =
				FindHighestFloorSurrounding(sec) + itof(args[2]) - 128.0;
			break;

		case FLEV_RAISEFLOOR:
			floor->direction = 1;
			floor->floordestheight = FindLowestCeilingSurrounding(sec);
			if (floor->floordestheight > sec->ceilingheight)
				floor->floordestheight = sec->ceilingheight;
			break;

		case FLEV_RAISEFLOORCRUSH:
			floor->crush = args[2];
			floor->direction = 1;
			floor->floordestheight = FindLowestCeilingSurrounding(sec);
			if (floor->floordestheight > sec->ceilingheight)
				floor->floordestheight = sec->ceilingheight;
			floor->floordestheight -= 8.0;
			break;

		case FLEV_RAISEFLOORTONEAREST:
			floor->direction = 1;
			floor->floordestheight =
				FindNextHighestFloor(sec, sec->floorheight);
			break;

		case FLEV_RAISEFLOORBYVALUE:
			floor->direction = 1;
			floor->floordestheight = floor->sector->floorheight +
				itof(args[2]);
			break;

		case FLEV_RAISEFLOORBYVALUECHANGE:
			floor->direction = 1;
			floor->floordestheight = floor->sector->floorheight +
				itof(args[2]);
			SetFloorPic(sec, line->frontsector->floor.pic);
			sec->special = line->frontsector->special;
			break;

		case FLEV_RAISETOTEXTURE:
			floor->direction = 1;
			for (i = 0; i < sec->linecount; i++)
			{
				secline = sec->lines[i];
				if (!(secline->flags & ML_TWOSIDED))
					continue;

				side = &level->sides[secline->sidenum[0]];
				if (side->bottomtexture >= 0 &&
					TextureHeight(side->bottomtexture) < minsize)
					minsize = TextureHeight(side->bottomtexture);

				side = &level->sides[secline->sidenum[1]];
				if (side->bottomtexture >= 0 &&
					TextureHeight(side->bottomtexture) < minsize)
					minsize = TextureHeight(side->bottomtexture);
			}
			floor->floordestheight = floor->sector->floorheight + minsize;
			break;

		case FLEV_LOWERTOLOWESTCHANGE:
			floor->direction = -1;
			floor->floordestheight = FindLowestFloorSurrounding(sec);
			floor->texture = sec->floor.pic;
			for (i = 0; i < sec->linecount; i++)
			{
				secline = sec->lines[i];
				if (!(secline->flags & ML_TWOSIDED))
					continue;

				if (level->sides[secline->sidenum[0]].sector == sec)
				{
					sec = level->sides[secline->sidenum[1]].sector;
				}
				else
				{
					sec = level->sides[secline->sidenum[0]].sector;
				}
				floor->texture = sec->floor.pic;
				floor->newspecial = sec->special;
				break;
			}
			break;

		case FLEV_RAISEFLOORTONEARESTCHANGE:
			floor->direction = 1;
			floor->floordestheight =
				FindNextHighestFloor(sec, sec->floorheight);
			SetFloorPic(sec,
				level->sides[line->sidenum[0]].sector->floor.pic);
			sec->special = 0;	// NO MORE DAMAGE, IF APPLICABLE
			SectorStartSoundName(sec, "PlatformMove", CHAN_VOICE);
			break;

		case FLEV_RAISEFLOORBYVALUECHANGE2:
			floor->direction = 1;
			floor->floordestheight = sec->floorheight + itof(args[2]) * 8.0;
			SetFloorPic(sec,
				level->sides[line->sidenum[0]].sector->floor.pic);
			SectorStartSoundName(sec, "PlatformMove", CHAN_VOICE);
			break;

		default:
			break;
		}
	}
	return rtn;
}

//==========================================================================
//
//  EV_BuildStairs
//
//  BUILD A STAIRCASE!
//
//==========================================================================

int EV_BuildStairs(line_t * line, int *args)
{
	int secnum;
	float height;
	int i;
	int texture;
	int ok;
	int rtn;
	sector_t *sec, *tsec;
	TFloor *floor;
	line_t *secline;
	int j;
	float stepDelta;

	stepDelta = itof(args[2]);
	secnum = -1;
	rtn = 0;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &level->sectors[secnum];

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (sec->specialdata)
			continue;

		//
		// new floor thinker
		//
		rtn = 1;
		height = sec->floorheight + stepDelta;
		floor = NewSpecialThinker(TFloor);
		sec->specialdata = floor;
		floor->type = raiseBuildStep;
		floor->direction = 1;
		floor->sector = sec;
		floor->speed = itof(args[1]) * 4.0;
		floor->floordestheight = height;

		texture = sec->floor.pic;

		//
		// Find next sector to raise
		// 1.   Find 2-sided line with same sector side[0]
		// 2.   Other side is the next sector to raise
		//
		do
		{
			ok = 0;
			for (i = 0; i < sec->linecount; i++)
			{
				secline = sec->lines[i];

				if (!(secline->flags & ML_TWOSIDED))
					continue;

				tsec = secline->frontsector;
				if (sec != tsec)
					continue;
				tsec = secline->backsector;
				if (tsec->floor.pic != texture)
					continue;

				height += stepDelta;
				if (tsec->specialdata)
					continue;

				sec = tsec;
//              secnum = tsec - level->sectors;
				for (j = 0; j < level->numsectors; j++)
					if (tsec == &level->sectors[j])
					{
						secnum = j;
						break;
					}
				floor = NewSpecialThinker(TFloor);
				sec->specialdata = floor;
				floor->type = raiseBuildStep;
				floor->direction = 1;
				floor->sector = sec;
				floor->speed = 35.0;
				floor->floordestheight = height;
				ok = 1;
				break;
			}
		}
		while (ok);
	}
	return (rtn);
}

//==========================================================================
//
//  EV_DoDonut
//
//  Special Stuff that can't be categorized
//
//==========================================================================

int EV_DoDonut(line_t * line, int *args)
{
	sector_t *s1;
	sector_t *s2;
	sector_t *s3;
	int secnum;
	int rtn;
	int i;
	TFloor *floor;
	line_t *secline;

	secnum = -1;
	rtn = 0;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		s1 = &level->sectors[secnum];

		//  ALREADY MOVING?  IF SO, KEEP GOING...
		if (s1->specialdata)
			continue;

		rtn = 1;
		s2 = getNextSector(s1->lines[0], s1);
		for (i = 0; i < s2->linecount; i++)
		{
			secline = s2->lines[i];
			if ((!secline->flags & ML_TWOSIDED) ||
				(secline->backsector == s1))
				continue;
			s3 = secline->backsector;

			//
			//  Spawn rising slime
			//
			floor = NewSpecialThinker(TFloor);
			s2->specialdata = floor;
			floor->type = FLEV_DONUT;
			floor->crush = false;
			floor->direction = 1;
			floor->sector = s2;
			floor->speed = itof(args[1]) * 4.0;
			floor->texture = s3->floor.pic;
			floor->newspecial = 0;
			floor->floordestheight = s3->floorheight;

			//
			//  Spawn lowering donut-hole
			//
			floor = NewSpecialThinker(TFloor);
			s1->specialdata = floor;
			floor->type = FLEV_LOWERFLOOR;
			floor->crush = false;
			floor->direction = -1;
			floor->sector = s1;
			floor->speed = itof(args[2]) * 4.0;
			floor->floordestheight = s3->floorheight;
			break;
		}
	}
	return rtn;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.5  2001/09/24 17:15:39  dj_jl
//  Created thinker classes
//
//  Revision 1.4  2001/09/20 16:19:59  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
