//**************************************************************************
//**
//**	##   ##    ##    ##   ##   ####     ####   ###     ###
//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**	   #    ##    ##    #      ####     ####   ##       ##
//**
//**	$Id$
//**
//**	Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**	This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**	This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// TYPES -------------------------------------------------------------------

enum
{
	FLEV_LOWERFLOOR,			// lower floor to highest surrounding floor
	FLEV_LOWERFLOORTOLOWEST,	// lower floor to lowest surrounding floor
	FLEV_LOWERTOHIGHEST,			// lower floor to highest surrounding floor VERY FAST
	FLEV_RAISEFLOOR,			// raise floor to lowest surrounding CEILING
	FLEV_RAISEFLOORTONEAREST,	// raise floor to next highest surrounding floor
	FLEV_RAISETOTEXTURE,		// raise floor to shortest height texture around it
	FLEV_LOWERTOLOWESTCHANGE,		// lower floor to lowest surrounding floor and change
						// floorpic
	FLEV_RAISEFLOORBYVALUE,
	FLEV_RAISEFLOORBYVALUECHANGE,
	FLEV_RAISEFLOORCRUSH,
	FLEV_DONUT,
	raiseBuildStep,		// One step of a staircase

	FLEV_RAISEFLOORBYVALUECHANGE2,
	FLEV_RAISEFLOORTONEARESTCHANGE
};

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//
//	Will return a side_t* given the number of the current sector,
//		the line number, and the side (0/1) that you want.
//
side_t *getSide(int currentSector, int line, int side)
{
	return &level->sides[level->sectors[currentSector].lines[line]->sidenum[side]];
}

//
//	Will return a sector_t* given the number of the current sector,
//		the line number and the side (0/1) that you want.
//
sector_t *getSector(int currentSector,int line,int side)
{
	return level->sides[level->sectors[currentSector].lines[line]->sidenum[side]].sector;
}

//
//	Given the sector number and the line number, will tell you whether
//		the line is two-sided or not.
//
int	twoSided(int sector, int line)
{
	return level->sectors[sector].lines[line]->flags & ML_TWOSIDED;
}

//==========================================================================
//
//  T_MoveFloor
//
//	MOVE A FLOOR TO IT'S DESTINATION (UP OR DOWN)
//
//==========================================================================

void T_MoveFloor(special_t *floor)
{
	int		res;

	res = T_MovePlane(floor->sector, floor->speed,
			floor->floordestheight, floor->crush, 0, floor->direction);
	if (!(level->tictime&7))
	{
		if (floor->type == FLEV_RAISEFLOORBYVALUECHANGE2 ||
			floor->type == FLEV_RAISEFLOORTONEARESTCHANGE)
			StartSoundName(&floor->sector->soundorg, "PlatformMove", CHAN_VOICE);
		else
			StartSoundName(&floor->sector->soundorg, "DoorMove", CHAN_VOICE);
	}

	if (res == RES_PASTDEST)
	{
		floor->sector->specialdata = NULL;
		if (floor->type == raiseBuildStep ||
			floor->type == FLEV_RAISEFLOORBYVALUECHANGE2 ||
			floor->type == FLEV_RAISEFLOORTONEARESTCHANGE)
		{
			StartSoundName(&floor->sector->soundorg, "PlatformStop", CHAN_VOICE);
		}
		if (floor->direction == 1)
			switch(floor->type)
			{
				case FLEV_DONUT:
					floor->sector->special = floor->newspecial;
					SetFloorPic(floor->sector, floor->texture);
				default:
					break;
			}
		else if (floor->direction == -1)
			switch(floor->type)
			{
				case FLEV_LOWERTOLOWESTCHANGE:
					floor->sector->special = floor->newspecial;
					SetFloorPic(floor->sector, floor->texture);
				default:
					break;
			}
		RemoveSpecialThinker(floor);
	}

}

//==========================================================================
//
//  EV_DoFloor
//
//	HANDLE FLOOR TYPES
//
//==========================================================================

int EV_DoFloor(line_t *line, int *args, int floortype)
{
	int			secnum;
	int			rtn;
	int			i;
	sector_t	*sec;
	special_t	*floor;
	float		minsize = 99999.0;
	side_t		*side;

	secnum = -1;
	rtn = 0;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &level->sectors[secnum];
		
		//	ALREADY MOVING?  IF SO, KEEP GOING...
		if (sec->specialdata)
			continue;
			
		//
		//	new floor thinker
		//
		rtn = 1;
		floor = NewSpecialThinker(T_MoveFloor);
		sec->specialdata = floor;
		floor->sector = sec;
		floor->type = floortype;
		floor->crush = false;
		floor->speed = itof(args[1]) / 8.0;
/*		if (floortype == FLEV_LOWERTIMES8INSTANT ||
			floortype == FLEV_RAISETIMES8INSTANT)
		{
			floor->speed = 2000.0;
		}*/
		switch(floortype)
		{
			case FLEV_LOWERFLOOR:
				floor->direction = -1;
				floor->floordestheight = FindHighestFloorSurrounding(sec);
				break;

			case FLEV_LOWERFLOORTOLOWEST:
				floor->direction = -1;
				floor->floordestheight = FindLowestFloorSurrounding(sec);
				break;

			case FLEV_LOWERTOHIGHEST:
				floor->direction = -1;
				floor->floordestheight = FindHighestFloorSurrounding(sec) + itof(args[2]) - 128.0;
				break;

			case FLEV_RAISEFLOOR:
				floor->direction = 1;
				floor->floordestheight = FindLowestCeilingSurrounding(sec);
				if (floor->floordestheight > sec->ceilingheight)
					floor->floordestheight = sec->ceilingheight;
				break;

			case FLEV_RAISEFLOORCRUSH:
				floor->crush = args[2];
				floor->direction = 1;
				floor->floordestheight = FindLowestCeilingSurrounding(sec);
				if (floor->floordestheight > sec->ceilingheight)
					floor->floordestheight = sec->ceilingheight;
				floor->floordestheight -= 8.0;
				break;

			case FLEV_RAISEFLOORTONEAREST:
				floor->direction = 1;
				floor->floordestheight = FindNextHighestFloor(sec, sec->floorheight);
				break;

			case FLEV_RAISEFLOORBYVALUE:
				floor->direction = 1;
				floor->floordestheight = floor->sector->floorheight +
					itof(args[2]);
				break;

			case FLEV_RAISEFLOORBYVALUECHANGE:
				floor->direction = 1;
				floor->floordestheight = floor->sector->floorheight +
					itof(args[2]);
				SetFloorPic(sec, line->frontsector->floor.pic);
				sec->special = line->frontsector->special;
				break;

			case FLEV_RAISETOTEXTURE:
				floor->direction = 1;
				for (i = 0; i < sec->linecount; i++)
				{
					if (!twoSided(secnum, i))
						continue;

					side = getSide(secnum, i, 0);
					if (side->bottomtexture >= 0 &&
						TextureHeight(side->bottomtexture) < minsize)
						minsize = TextureHeight(side->bottomtexture);

					side = getSide(secnum, i, 1);
					if (side->bottomtexture >= 0 &&
						TextureHeight(side->bottomtexture) < minsize)
						minsize = TextureHeight(side->bottomtexture);
				}
				floor->floordestheight = floor->sector->floorheight + minsize;
				break;

			case FLEV_LOWERTOLOWESTCHANGE:
				floor->direction = -1;
				floor->floordestheight = FindLowestFloorSurrounding(sec);
				floor->texture = sec->floor.pic;
				for (i = 0; i < sec->linecount; i++)
				{
					if (!twoSided(secnum, i))
						continue;

					if (getSide(secnum, i, 0)->sector == &level->sectors[secnum])
					{
						sec = getSector(secnum, i, 1);
					}
					else
					{
						sec = getSector(secnum, i, 0);
					}
					floor->texture = sec->floor.pic;
					floor->newspecial = sec->special;
					break;
				}
				break;

			case FLEV_RAISEFLOORTONEARESTCHANGE:
				floor->direction = 1;
				floor->floordestheight = FindNextHighestFloor(sec, sec->floorheight);
				SetFloorPic(sec, level->sides[line->sidenum[0]].sector->floor.pic);
				sec->special = 0;		// NO MORE DAMAGE, IF APPLICABLE
				StartSoundName(&sec->soundorg, "PlatformMove", CHAN_VOICE);
				break;

			case FLEV_RAISEFLOORBYVALUECHANGE2:
				floor->direction = 1;
				floor->floordestheight = sec->floorheight + itof(args[2]) * 8.0;
				SetFloorPic(sec, level->sides[line->sidenum[0]].sector->floor.pic);
				StartSoundName(&sec->soundorg, "PlatformMove", CHAN_VOICE);
				break;

/*
			case FLEV_LOWERFLOORBYVALUE:
				floor->direction = -1;
				floor->floordestheight = floor->sector->floorheight -
					itof(args[2]);
				break;
			case FLEV_LOWERTIMES8INSTANT:
			case FLEV_LOWERBYVALUETIMES8:
				floor->direction = -1;
				floor->floordestheight = floor->sector->floorheight -
					itof(args[2]) * 8.0;
				break;
			case FLEV_RAISETIMES8INSTANT:
			case FLEV_RAISEBYVALUETIMES8:
				floor->direction = 1;
				floor->floordestheight = floor->sector->floorheight +
					itof(args[2]) * 8.0;
				break;
			case FLEV_MOVETOVALUETIMES8:
				floor->floordestheight = itof(args[2]) * 8.0;
				if (args[3])
				{
					floor->floordestheight = -floor->floordestheight;
				}
				if (floor->floordestheight > floor->sector->floorheight)
				{
					floor->direction = 1;
				}
				else if (floor->floordestheight < floor->sector->floorheight)
				{
					floor->direction = -1;
				}
				else
				{ // already at lowest position
					rtn = 0;
				}
				break;
*/
			default:
				break;
		}
	}
	return rtn;
}

//==========================================================================
//
//  EV_BuildStairs
//
//	BUILD A STAIRCASE!
//
//==========================================================================

int EV_BuildStairs(line_t *line, int *args)
{
	int		secnum;
	float	height;
	int		i;
	int		texture;
	int		ok;
	int		rtn;
	sector_t	*sec, *tsec;
	special_t	*floor;
	line_t	*secline;
	int		j;
	float	stepDelta;

	stepDelta = itof(args[2]);
	secnum = -1;
	rtn = 0;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &level->sectors[secnum];
		
		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (sec->specialdata)
			continue;

		//
		// new floor thinker
		//
		rtn = 1;
		height = sec->floorheight + stepDelta;
		floor = NewSpecialThinker(T_MoveFloor);
		sec->specialdata = floor;
		floor->type = raiseBuildStep;
		floor->direction = 1;
		floor->sector = sec;
		floor->speed = itof(args[1]) / 8.0;
		floor->floordestheight = height;
		
		texture = sec->floor.pic;

		//
		// Find next sector to raise
		// 1.	Find 2-sided line with same sector side[0]
		// 2.	Other side is the next sector to raise
		//
		do
		{
			ok = 0;
			for (i = 0;i < sec->linecount;i++)
			{
            	secline = sec->lines[i];

				if (!(secline->flags & ML_TWOSIDED))
					continue;
					
				tsec = secline->frontsector;
				if (sec != tsec)
					continue;
				tsec = secline->backsector;
				if (tsec->floor.pic != texture)
					continue;

				height += stepDelta;
				if (tsec->specialdata)
					continue;

				sec = tsec;
//				secnum = tsec - level->sectors;
				for (j=0; j<level->numsectors; j++)
					if (tsec == &level->sectors[j])
                    {
                    	secnum = j;
                        break;
                    }
				floor = NewSpecialThinker(T_MoveFloor);
				sec->specialdata = floor;
				floor->type = raiseBuildStep;
				floor->direction = 1;
				floor->sector = sec;
				floor->speed = 1.0;
				floor->floordestheight = height;
				ok = 1;
				break;
			}
		} while(ok);
	}
	return(rtn);
}

//============================================================
//
//	EV_DoDonut
//
//	Special Stuff that can't be categorized
//
//============================================================

int EV_DoDonut(line_t *line, int *args)
{
	sector_t	*s1;
	sector_t	*s2;
	sector_t	*s3;
	int			secnum;
	int			rtn;
	int			i;
	special_t	*floor;
    line_t		*secline;
	
	secnum = -1;
	rtn = 0;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		s1 = &level->sectors[secnum];
		
		//	ALREADY MOVING?  IF SO, KEEP GOING...
		if (s1->specialdata)
			continue;
			
		rtn = 1;
		s2 = getNextSector(s1->lines[0], s1);
		for (i = 0;i < s2->linecount;i++)
		{
        	secline = s2->lines[i];
			if ((!secline->flags & ML_TWOSIDED) ||
				(secline->backsector == s1))
				continue;
			s3 = secline->backsector;

			//
			//	Spawn rising slime
			//
			floor = NewSpecialThinker(T_MoveFloor);
			s2->specialdata = floor;
			floor->type = FLEV_DONUT;
			floor->crush = false;
			floor->direction = 1;
			floor->sector = s2;
			floor->speed = itof(args[1]) / 8.0;
			floor->texture = s3->floor.pic;
			floor->newspecial = 0;
			floor->floordestheight = s3->floorheight;
			
			//
			//	Spawn lowering donut-hole
			//
			floor = NewSpecialThinker(T_MoveFloor);
			s1->specialdata = floor;
			floor->type = FLEV_LOWERFLOOR;
			floor->crush = false;
			floor->direction = -1;
			floor->sector = s1;
			floor->speed = itof(args[2]) / 8.0;
			floor->floordestheight = s3->floorheight;
			break;
		}
	}
	return rtn;
}

//**************************************************************************
//
//	$Log$
//	Revision 1.3  2001/08/29 17:42:13  dj_jl
//	Added sound channel
//
//	Revision 1.2  2001/07/27 14:27:52  dj_jl
//	Update with Id-s and Log-s, some fixes
//
//**************************************************************************
