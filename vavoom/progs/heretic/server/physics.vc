//**************************************************************************
//**
//**	##   ##    ##    ##   ##   ####     ####   ###     ###
//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**	   #    ##    ##    #      ####     ####   ##       ##
//**
//**	Copyright (C) 1999-2000 JÆnis Legzdi·ý
//**
//**	This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**	This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**	
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define	GRAVITY			1225.0
#define	MAXMOVE			1050.0
#define STOPSPEED		2.1875

#define FRICTION_NORMAL	3.28125
#define FRICTION_LOW	0.95703125
#define FRICTION_FLY	2.87109375
#define FRICTION_WATER	3.0

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

float windTab[3] = {5.0 / 32.0, 10.0 / 32.0, 25.0 / 32.0};

// CODE --------------------------------------------------------------------

//==========================================================================
//
//	ClipVelocity
//
//	Slide off of the impacting object
//
//==========================================================================

TVec ClipVelocity(TVec in, TVec normal, float overbounce)
{
	return in - normal * (DotProduct(in, normal) * overbounce);
}

//**************************************************************************
//
//	SLIDE MOVE
//
//	Allows the player to slide along any angled walls.
//
//**************************************************************************

float			bestslidefrac;
float			secondslidefrac;

line_t*			bestslideline;
line_t*			secondslideline;

mobj_t*			slidemo;
TVec			slideorg;
TVec			slidedir;

//==========================================================================
//
//	PTR_SlideTraverse
//
//==========================================================================

boolean PTR_SlideTraverse(intercept_t* in)
{
	line_t*		li;
	TVec		hit_point;
	opening_t	*open;

    if (!in->isaline)
		Error("PTR_SlideTraverse: not a line?");
		
    li = in->line;

    if (li->flags & ML_TWOSIDED)
    {
	    // set openrange, opentop, openbottom
		hit_point = slideorg + in->frac * slidedir;
    	open = LineOpenings(li, hit_point);
		open = FindOpening(open, slidemo->origin.z,	slidemo->origin.z + slidemo->height);
    
	    if (open &&
	    	(open->range >= slidemo->height) &&	//	fits
    		(open->top - slidemo->origin.z >= slidemo->height) && // mobj is not too high
	    	(open->bottom - slidemo->origin.z <= 24.0)) // not too big a step up
		{
    		// this line doesn't block movement
    		return true;
		}
	}
	else
    {
		if (PointOnPlaneSide(slidemo->origin, li))
		{
	    	// don't hit the back side
	    	return true;
		}
    }

    // the line does block movement,
    // see if it is closer than best so far
    if (in->frac < bestslidefrac)
    {
		secondslidefrac = bestslidefrac;
		secondslideline = bestslideline;
		bestslidefrac = in->frac;
		bestslideline = li;
    }
	
    return false;	// stop
}

//==========================================================================
//
//	SlidePathTraverse
//
//==========================================================================

void SlidePathTraverse(float x, float y)
{
	slideorg = vector(x, y, slidemo->origin.z);
	slidedir = slidemo->velocity * frametime;
	P_PathTraverse(x, y, x + slidedir.x, y + slidedir.y,
		PT_ADDLINES, PTR_SlideTraverse);
}

//==========================================================================
//
//	P_SlideMove
//
//	The momx / momy move is bad, so try to slide along a wall.
//	Find the first line hit, move flush to it, and slide along it.
//	This is a kludgy mess.
//
//==========================================================================

void P_SlideMove(mobj_t* mo)
{
	float		leadx;
	float		leady;
	float		trailx;
	float		traily;
	float		newx;
	float		newy;
    int			hitcount;
		
    slidemo = mo;
    hitcount = 0;

	do
    {
	    if (++hitcount == 3)
		{
			// don't loop forever
			if (!P_TryMove(mo, mo->origin.x, mo->origin.y + mo->velocity.y * frametime))
			    P_TryMove(mo, mo->origin.x + mo->velocity.x * frametime, mo->origin.y);
			return;
		}

	    // trace along the three leading corners
	    if (mo->velocity.x > 0.0)
    	{
			leadx = mo->origin.x + mo->radius;
			trailx = mo->origin.x - mo->radius;
    	}
	    else
    	{
			leadx = mo->origin.x - mo->radius;
			trailx = mo->origin.x + mo->radius;
	    }

	    if (mo->velocity.y > 0.0)
	    {
			leady = mo->origin.y + mo->radius;
			traily = mo->origin.y - mo->radius;
	    }
    	else
	    {
			leady = mo->origin.y - mo->radius;
			traily = mo->origin.y + mo->radius;
	    }
		
	    bestslidefrac = 1.00001;

	    SlidePathTraverse(leadx, leady);
	    SlidePathTraverse(trailx, leady);
	    SlidePathTraverse(leadx, traily);
    
	    // move up to the wall
    	if (bestslidefrac == 1.00001)
	    {
			// the move most have hit the middle, so stairstep
			if (!P_TryMove(mo, mo->origin.x, mo->origin.y + mo->velocity.y * frametime))
			    P_TryMove(mo, mo->origin.x + mo->velocity.x * frametime, mo->origin.y);
			return;
    	}

	    // fudge a bit to make sure it doesn't hit
    	bestslidefrac -= 0.03125;
	    if (bestslidefrac > 0.0)
    	{
			newx = mo->velocity.x * frametime * bestslidefrac;
			newy = mo->velocity.y * frametime * bestslidefrac;
	
			if (!P_TryMove(mo, mo->origin.x + newx, mo->origin.y + newy))
            {
				if (!P_TryMove(mo, mo->origin.x, mo->origin.y + mo->velocity.y * frametime))
				    P_TryMove(mo, mo->origin.x + mo->velocity.x * frametime, mo->origin.y);
				return;
			}
	    }
    
	    // Now continue along the wall.
    	// First calculate remainder.
	    bestslidefrac = 1.0 - (bestslidefrac + 0.03125);
    
	    if (bestslidefrac > 1.0)
			bestslidefrac = 1.0;
    
	    if (bestslidefrac <= 0.0)
			return;
    
	    // clip the moves
		mo->velocity = ClipVelocity(mo->velocity * bestslidefrac, bestslideline->normal, 1.0);

    } while (!P_TryMove(mo, mo->origin.x + mo->velocity.x * frametime,
    	mo->origin.y + mo->velocity.y * frametime));
}

//**************************************************************************
//
//	BOUNCING
//
//	Bounce missile against walls
//
//**************************************************************************

//============================================================================
//
//	PTR_BounceTraverse
//
//============================================================================

boolean PTR_BounceTraverse(intercept_t *in)
{
	line_t  	*li;
	TVec		hit_point;
	opening_t	*open;

	if (!in->isaline)
		Error("PTR_BounceTraverse: not a line?");

	li = in->line;
	if (li->flags & ML_TWOSIDED)
    {
		hit_point = slideorg + in->frac * slidedir;
		open = LineOpenings(li, hit_point);	// set openrange, opentop, openbottom
		open = FindOpening(open, slidemo->origin.z,	slidemo->origin.z + slidemo->height);
		if (open &&
			open->range >= slidemo->height &&			// fits
			open->top - slidemo->origin.z >= slidemo->height)// mobj is not too high
		{
			return true;            // this line doesn't block movement
		}
	}
	else
	{
		if (PointOnPlaneSide(slidemo->origin, li))
        {
			return true;            // don't hit the back side
		}
	}

	// the line does block movement, see if it is closer than best so far
	if (in->frac < bestslidefrac)
	{
		secondslidefrac = bestslidefrac;
		secondslideline = bestslideline;
		bestslidefrac = in->frac;
		bestslideline = li;
	}
	return false;   // stop
}

//============================================================================
//
//	P_BounceWall
//
//============================================================================

void P_BounceWall(mobj_t *mo)
{
	float		leadx, leady;

	slidemo = mo;

	//
	// trace along the three leading corners
	//
	if (mo->velocity.x > 0.0)
	{
		leadx = mo->origin.x + mo->radius;
	}
	else
	{
		leadx = mo->origin.x - mo->radius;
	}
	if (mo->velocity.y > 0.0)
	{
		leady = mo->origin.y + mo->radius;
	}
	else
	{
		leady = mo->origin.y - mo->radius;
	}
	bestslidefrac = 1.00001;
	slideorg = vector(leadx, leady, slidemo->origin.z);
	slidedir = mo->velocity * frametime;
	P_PathTraverse(leadx, leady, leadx + slidedir.x, leady + slidedir.y,
		PT_ADDLINES, PTR_BounceTraverse);
	mo->velocity = ClipVelocity(mo->velocity * 0.75, bestslideline->normal, 2.0);
}

//**************************************************************************
//
//	OBJECT MOVEMENT
//
//**************************************************************************

//==========================================================================
//
//	CheckWater
//
//==========================================================================

boolean CheckWater(mobj_t *mobj)
{
	TVec	point;
	int		cont;

	point = mobj->origin;
	point.z += 1.0;
	
	mobj->waterlevel = 0;
	mobj->watertype = CONTENTS_EMPTY;
	cont = PointContents(mobj->subsector->sector, point);
	if (cont >= CONTENTS_WATER)
	{
		mobj->watertype = cont;
		mobj->waterlevel = 1;
		point.z = mobj->origin.z + mobj->height * 0.5;
		cont = PointContents(mobj->subsector->sector, point);
		if (cont >= CONTENTS_WATER)
		{
			mobj->waterlevel = 2;
			if (mobj->player)
			{
				point = mobj->player->vieworg;
				cont = PointContents(mobj->subsector->sector, point);
				if (cont >= CONTENTS_WATER)
					mobj->waterlevel = 3;
			}
		}
	}
	return mobj->waterlevel > 1;
}

//==========================================================================
//
//	UpdateVelocity
//
//==========================================================================

void UpdateVelocity(mobj_t *mo)
{
	player_t	*player;

	if (mo->waterlevel < 2)
	{
		if (mo->flags2 & MF2_LOGRAV)
		{
			mo->velocity.z -= GRAVITY / 8.0 * frametime;
		}
		else if (!(mo->flags & MF_NOGRAVITY))
		{
			mo->velocity.z -= GRAVITY * frametime;
		}
	}
	else if (!mo->player)
	{
		if (mo->flags2 & MF2_LOGRAV)
		{
			mo->velocity.z = -10.0;
		}
		else if (!(mo->flags & MF_NOGRAVITY))
		{
			mo->velocity.z = -60.0;
		}
	}

	// Friction

	if (mo->flags & (MF_MISSILE | MF_SKULLFLY))
	{
		// No friction for missiles
		return;
	}

	if (mo->origin.z > mo->floorz && mo->waterlevel < 2 &&
		!(mo->flags2&MF2_FLY) && !(mo->flags2&MF2_ONMOBJ))
	{
		// No friction when falling
		return;
	}

	if (mo->origin.z <= mo->floorz)
	{
		//	Clip velocity
		float dot = DotProduct(mo->velocity, mo->floor->normal);
		if (dot < 0.0)
		{
			mo->velocity -= dot * mo->floor->normal;
		}
	}

	if (mo->flags & MF_CORPSE)
	{
		// Don't stop sliding if halfway off a step with some momentum
		if (mo->velocity.x > 0.25 * 35.0 || mo->velocity.x < -0.25 * 35.0 ||
			mo->velocity.y > 0.25 * 35.0 || mo->velocity.y < -0.25 * 35.0)
		{
			if (mo->floorz != mo->subsector->sector->floorheight)
			{
				return;
			}
		}
	}

	player = mo->player;
	if (mo->velocity.x > -STOPSPEED && mo->velocity.x < STOPSPEED &&
		mo->velocity.y > -STOPSPEED && mo->velocity.y < STOPSPEED &&
		mo->velocity.z > -STOPSPEED && mo->velocity.z < STOPSPEED &&
		(!player || (!player->forwardmove && !player->sidemove)))
	{
		// If in a walking frame, stop moving
		if (player)
		{
			if (player->chickenTics)
			{
            	int		sn;

                sn = player->mo->statenum;
				if (sn >= S_CHICPLAY_RUN1 && sn <= S_CHICPLAY_RUN4)
				{
					SetMobjState(player->mo, S_CHICPLAY);
				}
			}
			else
			{
            	int		sn;

                sn = player->mo->statenum;
				if (sn >= S_PLAY_RUN1 && sn <= S_PLAY_RUN4)
				{
					SetMobjState(player->mo, S_PLAY);
				}
			}
		}
		mo->velocity = vector(0.0, 0.0,	0.0);
	}
	else
	{
		if (mo->waterlevel > 1)
		{
			mo->velocity -= mo->velocity * FRICTION_WATER * frametime;
		}
		else if ((mo->flags2 & MF2_FLY) && !(mo->origin.z <= mo->floorz)
			&& !(mo->flags2 & MF2_ONMOBJ))
		{
			mo->velocity -= mo->velocity * FRICTION_FLY * frametime;
		}
		else if (mo->subsector->sector->special == 15) // Friction_Low
		{
			mo->velocity -= mo->velocity * FRICTION_LOW * frametime;
		}
		else
		{
			mo->velocity -= mo->velocity * FRICTION_NORMAL * frametime;
		}
	}
}

//===========================================================================
//
//	P_XYMovement
//
//===========================================================================

void P_XYMovement(mobj_t *mo)
{
	float		ptryx, ptryy;
	float		xmove, ymove;
	int			special;

	if (!mo->velocity.x && !mo->velocity.y)
	{
		if (mo->flags & MF_SKULLFLY)
		{
			// A flying mobj slammed into something
			mo->flags &= ~MF_SKULLFLY;
			mo->velocity.x = mo->velocity.y = mo->velocity.z = 0.0;
			SetMobjState(mo, mo->seestate);
		}
		return;
	}
	special = mo->subsector->sector->special;
	if (mo->flags2 & MF2_WINDTHRUST)
	{
		switch (special)
		{
			case 40: case 41: case 42: // Wind_East
				P_ThrustMobj(mo, 0, windTab[special-40]);
				break;
			case 43: case 44: case 45: // Wind_North
				P_ThrustMobj(mo, ANG90, windTab[special-43]);
				break;
			case 46: case 47: case 48: // Wind_South
				P_ThrustMobj(mo, ANG270, windTab[special-46]);
				break;
			case 49: case 50: case 51: // Wind_West
				P_ThrustMobj(mo, ANG180, windTab[special-49]);
				break;
		}
	}
	if (mo->velocity.x > MAXMOVE)
	{
		mo->velocity.x = MAXMOVE;
	}
	else if (mo->velocity.x < -MAXMOVE)
	{
		mo->velocity.x = -MAXMOVE;
	}
	if (mo->velocity.y > MAXMOVE)
	{
		mo->velocity.y = MAXMOVE;
	}
	else if (mo->velocity.y < -MAXMOVE)
	{
		mo->velocity.y = -MAXMOVE;
	}
	xmove = mo->velocity.x * frametime;
	ymove = mo->velocity.y * frametime;
	do
	{
		if (xmove > MAXMOVE / (35.0 * 2.0) || ymove > MAXMOVE / (35.0 * 2.0))
		{
			ptryx = mo->origin.x + xmove / 2.0;
			ptryy = mo->origin.y + ymove / 2.0;
			xmove /= 2.0;
			ymove /= 2.0;
		}
		else
		{
			ptryx = mo->origin.x + xmove;
			ptryy = mo->origin.y + ymove;
			xmove = ymove = 0.0;
		}
		if (!P_TryMove(mo, ptryx, ptryy))
		{
			// Blocked move
			if (mo->flags2 & MF2_SLIDE)
			{
				// Try to slide along it
				P_SlideMove(mo);
			}
			else if (mo->flags & MF_MISSILE)
			{
				// Explode a missile
				if (ceilingline && ceilingline->backsector &&
					ceilingline->backsector->ceiling.pic == skyflatnum)
				{
					// Hack to prevent missiles exploding against the sky
					if (mo->type == MT_BLOODYSKULL)
					{
						mo->velocity.x = mo->velocity.y = 0.0;
						mo->velocity.z = -1.0 * 35.0;
					}
					else
					{
						P_RemoveMobj(mo);
					}
					return;
				}
				P_ExplodeMissile(mo);
			}
			//else if(mo->info->crashstate)
			//{
			//      mo->velocity.x = mo->velocity.y = 0;
			//      P_SetMobjState(mo, mo->info->crashstate);
			//      return;
			//}
			else
			{
				mo->velocity.x = mo->velocity.y = 0.0;
			}
		}
	} while (xmove || ymove);
}

//**************************************************************************
//
//	TEST ON MOBJ
//
//**************************************************************************

mobj_t*		tzmthing;
float		tzmx;
float		tzmy;
float		tzmz;

mobj_t 		*onmobj; //generic global onmobj...used for landing on pods/players

//==========================================================================
//
//	PIT_CheckOnmobjZ
//
//==========================================================================

boolean PIT_CheckOnmobjZ(mobj_t *thing)
{
	float	blockdist;

	if (!(thing->flags & (MF_SOLID | MF_SPECIAL | MF_SHOOTABLE)))
	{
		// Can't hit thing
		return true;
	}
	blockdist = thing->radius + tzmthing->radius;
	if (fabs(thing->origin.x - tzmx) >= blockdist || fabs(thing->origin.y - tzmy) >= blockdist)
	{
		// Didn't hit thing
		return true;
	}
	if (thing == tzmthing)
	{
		// Don't clip against self
		return true;
	}
	if (tzmz > thing->origin.z + thing->height)
	{	
		return true;
	}
	else if (tzmz + tzmthing->height < thing->origin.z)
	{
		// under thing
		return true;
	}
	if (thing->flags & MF_SOLID)
	{
		onmobj = thing;
	}
	return (!(thing->flags & MF_SOLID));
}

//=============================================================================
//
//	P_FakeZMovement
//
//	Fake the zmovement so that we can check if a move is legal
//
//=============================================================================

void P_FakeZMovement(mobj_t *mo)
{
	float		dist;
	float		delta;

	//
	//	adjust height
	//
	tzmz += mo->velocity.z * frametime;
	if (mo->flags & MF_FLOAT && mo->target)
	{
		// float down towards target if too close
		if (!(mo->flags & MF_SKULLFLY) && !(mo->flags & MF_INFLOAT))
		{
			dist = MobjDist2(mo, mo->target);
			delta = mo->target->origin.z + mo->height / 2.0 - tzmz;
			if (delta < 0.0 && dist < -(delta * 3.0))
				tzmz -= FLOATSPEED * frametime;
			else if (delta > 0.0 && dist < (delta * 3.0))
				tzmz += FLOATSPEED * frametime;
		}
	}
	if (mo->player && mo->flags2 & MF2_FLY && !(tzmz <= mo->floorz)
		&& level->tictime & 2)
	{
		tzmz += sin(ANG90 / 20 * level->tictime);
	}

	//
	//	clip movement
	//
	if (tzmz <= mo->floorz)
	{
		// Hit the floor
		tzmz = mo->floorz;
		if (mo->crashstate && (mo->flags & MF_CORPSE))
		{
			return;
		}
	}
	
	if (tzmz + mo->height > mo->ceilingz)
	{
		// hit the ceiling
		tzmz = mo->ceilingz - mo->height;
	}
}

//=============================================================================
//
//	P_CheckOnmobj
//
//	Checks if the new Z position is legal
//
//=============================================================================

mobj_t *P_CheckOnmobj(mobj_t *thing)
{
	int			xl,xh,yl,yh,bx,by;
	
	tzmthing = thing;
	tzmx = thing->origin.x;
	tzmy = thing->origin.y;
	tzmz = thing->origin.z;
	P_FakeZMovement(tzmthing);
		
	if (thing->flags & MF_NOCLIP)
		return NULL;

	//
	// check things first, possibly picking things up
	// the bounding box is extended by MAXRADIUS because mobj_ts are grouped
	// into mapblocks based on their origin point, and can overlap into adjacent
	// blocks by up to MAXRADIUS units
	//
	xl = MapBlock(thing->origin.x - thing->radius - level->bmaporgx - MAXRADIUS);
	xh = MapBlock(thing->origin.x + thing->radius - level->bmaporgx + MAXRADIUS);
	yl = MapBlock(thing->origin.y - thing->radius - level->bmaporgy - MAXRADIUS);
	yh = MapBlock(thing->origin.y + thing->radius - level->bmaporgy + MAXRADIUS);

	for (bx=xl ; bx<=xh ; bx++)
		for (by=yl ; by<=yh ; by++)
			if (!P_BlockThingsIterator(bx,by,PIT_CheckOnmobjZ))
			{
				return onmobj;
			}
	return NULL;
}

//===========================================================================
//
//	P_ZMovement
//
//===========================================================================

void P_ZMovement(mobj_t *mo)
{
	float	dist;
	float	delta;

	//
	// check for smooth step up
	//
	if (mo->player && mo->origin.z < mo->floorz)
	{
		mo->player->viewheight -= mo->floorz - mo->origin.z;
		mo->player->deltaviewheight = (VIEWHEIGHT - mo->player->viewheight) / 8.0;
	}

	//
	// adjust height
	//
	mo->origin.z += mo->velocity.z * frametime;
	if (mo->flags&MF_FLOAT && mo->target)
	{       // float down towards target if too close
		if (!(mo->flags&MF_SKULLFLY) && !(mo->flags&MF_INFLOAT))
		{
			dist = MobjDist(mo, mo->target);
			delta = mo->target->origin.z + mo->height / 2.0 - mo->origin.z;
			if (delta < 0.0 && dist < -(delta * 3.0))
				mo->origin.z -= FLOATSPEED * frametime;
			else if (delta > 0.0 && dist < (delta * 3.0))
				mo->origin.z += FLOATSPEED * frametime;
		}
	}
	if (mo->player && mo->flags2 & MF2_FLY && !(mo->origin.z <= mo->floorz)
		&& level->tictime & 2)
	{
		mo->origin.z += sin(ANG90 / 20 * level->tictime);
	}

	//
	// clip movement
	//
	if (mo->origin.z <= mo->floorz)
	{
		// Hit the floor
		if (mo->flags&MF_MISSILE)
		{
			mo->origin.z = mo->floorz;
			if (mo->flags2&MF2_FLOORBOUNCE)
			{
				P_FloorBounceMissile(mo);
				return;
			}
			else if (mo->type == MT_MNTRFX2)
			{
				// Minotaur floor fire can go up steps
				return;
			}
			else
			{
				P_ExplodeMissile(mo);
				return;
			}
		}
		if (mo->origin.z - mo->velocity.z * frametime > mo->floorz)
		{
			// Spawn splashes, etc.
			P_HitFloor(mo);
		}
		mo->origin.z = mo->floorz;
		if (mo->velocity.z < 0.0)
		{
			if (mo->player && mo->velocity.z < -GRAVITY * 0.25 && !(mo->flags2&MF2_FLY))       // squat down
			{
				mo->player->deltaviewheight = mo->velocity.z * frametime / 8.0;
				StartSoundName(mo, "PlayerLand");
//FIXME				mo->player->centering = true;
			}
			mo->velocity.z = 0.0;
		}
		if (mo->flags & MF_SKULLFLY)
		{	// The skull slammed into something
			mo->velocity.z = -mo->velocity.z;
		}
		if (mo->crashstate && (mo->flags & MF_CORPSE))
		{
			SetMobjState(mo, mo->crashstate);
			return;
		}
	}

	if (mo->origin.z + mo->height > mo->ceilingz)
	{       // hit the ceiling
		if (mo->velocity.z > 0.0)
			mo->velocity.z = 0.0;
		mo->origin.z = mo->ceilingz - mo->height;
		if (mo->flags & MF_SKULLFLY)
		{       // the skull slammed into something
			mo->velocity.z = -mo->velocity.z;
		}
		if (mo->flags & MF_MISSILE)
		{
			if (mo->subsector->sector->ceiling.pic == skyflatnum)
			{
				if (mo->type == MT_BLOODYSKULL)
				{
					mo->velocity.x = mo->velocity.y = 0.0;
					mo->velocity.z = -1.0 * 35.0;
				}
				else
				{
					P_RemoveMobj(mo);
				}
				return;
			}
			P_ExplodeMissile(mo);
			return;
		}
	}
}

//===========================================================================
//
//	P_NightmareRespawn
//
//===========================================================================

void P_NightmareRespawn(mobj_t *mobj)
{
	float		x,y,z;
	mobj_t		*mo;
	mthing_t	*mthing;
		
	x = mobj->spawnpoint.x;
	y = mobj->spawnpoint.y;
	
	if (!P_CheckPosition(mobj, x, y))
		return; // somthing is occupying it's position


	// spawn a teleport fog at old spot
	mo = P_SpawnMobj(mobj->origin.x, mobj->origin.y, ONFLOORZ, MT_TFOG);
	mo->origin.z += TELEFOGHEIGHT;
	StartSoundName(mo, "Teleport");

	// spawn a teleport fog at the new spot
	mo = P_SpawnMobj(x, y, ONFLOORZ, MT_TFOG);
	mo->origin.z += TELEFOGHEIGHT;
	StartSoundName(mo, "Teleport");

	// spawn the new monster
	mthing = &mobj->spawnpoint;
	
	// spawn it
	if (mobj->flags & MF_SPAWNCEILING)
		z = ONCEILINGZ;
	else
		z = ONFLOORZ;
	mo = P_SpawnMobj(x, y, z, mobj->type);
	CopyMThing(&mobj->spawnpoint, &mo->spawnpoint);
	mo->angles.yaw = ANG45 * (mthing->angle/45);
	if (mthing->options & MTF_AMBUSH)
		mo->flags |= MF_AMBUSH;

	mo->reactiontime = 18;
	
	// remove the old monster
	P_RemoveMobj(mobj);
}

//===========================================================================
//
//	BlasterMobjThinker
//
//	Thinker for the ultra-fast blaster PL2 ripper-spawning missile.
//
//===========================================================================

void BlasterMobjThinker(mobj_t *mobj)
{
	int 	i;
	float	xfrac;
	float	yfrac;
	float	zfrac;
	float	z;
	boolean changexy;

	// Handle movement
	if (mobj->velocity.x || mobj->velocity.y ||
		(mobj->origin.z != mobj->floorz) || mobj->velocity.z)
	{
		xfrac = mobj->velocity.x * frametime / 8.0;
		yfrac = mobj->velocity.y * frametime / 8.0;
		zfrac = mobj->velocity.z * frametime / 8.0;
		changexy = xfrac || yfrac;
		for (i = 0; i < 8; i++)
		{
			if (changexy)
			{
				if (!P_TryMove(mobj, mobj->origin.x + xfrac, mobj->origin.y + yfrac))
				{
					// Blocked move
					P_ExplodeMissile(mobj);
					return;
				}
			}
			mobj->origin.z += zfrac;
			if (mobj->origin.z <= mobj->floorz)
			{
				// Hit the floor
				mobj->origin.z = mobj->floorz;
				P_HitFloor(mobj);
				P_ExplodeMissile(mobj);
				return;
			}
			if (mobj->origin.z + mobj->height > mobj->ceilingz)
			{
				// Hit the ceiling
				mobj->origin.z = mobj->ceilingz - mobj->height;
				P_ExplodeMissile(mobj);
				return;
			}
			if (changexy && (P_Random() < 64))
			{
				z = mobj->origin.z - 8.0;
				if (z < mobj->floorz)
				{
					z = mobj->floorz;
				}
				P_SpawnMobj(mobj->origin.x, mobj->origin.y, z, MT_BLASTERSMOKE);
			}
		}
	}
	// Advance the state
	if (mobj->time != -1.0)
	{
		mobj->time -= frametime;
		if (mobj->time <= 0.0)
		{
			mobj->time = 0.0;
			if (!SetMobjState(mobj, mobj->nextstate))
			{
				// mobj was removed
				return;
			}
		}
	}
}

//===========================================================================
//
//	P_MobjThinker
//
//===========================================================================

void P_MobjThinker(mobj_t *mobj)
{
	mobj_t *onmo;

	if (mobj->blaster)
    {
    	BlasterMobjThinker(mobj);
        return;
    }

	CheckWater(mobj);
	if (!(mobj->flags2 & MF2_FLOATBOB))
	{
		UpdateVelocity(mobj);
	}

	// Handle X and Y momentums
	if (mobj->velocity.x || mobj->velocity.y || (mobj->flags & MF_SKULLFLY))
	{
		P_XYMovement(mobj);
		if (!mobj->real_function)
		{
			// mobj was removed
			return;
		}
	}
	if (mobj->flags2 & MF2_FLOATBOB)
	{
		// Floating item bobbing motion
		mobj->origin.z = mobj->floorz + FloatBobOffsets[(mobj->health++) & 63];
	}
	else if ((mobj->origin.z != mobj->floorz) || mobj->velocity.z)
	{
		// Handle Z momentum and gravity
		if (mobj->flags2 & MF2_PASSMOBJ)
		{
			if (!(onmo = P_CheckOnmobj(mobj)))
			{
				P_ZMovement(mobj);
			}
			else
			{
				if (mobj->player && mobj->velocity.z < 0.0)
				{
					mobj->flags2 |= MF2_ONMOBJ;
					mobj->velocity.z = 0.0;
				}
				if (mobj->player && (onmo->player || onmo->type == MT_POD))
				{
					mobj->velocity.x = onmo->velocity.x;
					mobj->velocity.y = onmo->velocity.y;
					if (onmo->origin.z < onmo->floorz)
					{
						mobj->origin.z += onmo->floorz - onmo->origin.z;
						if (onmo->player)
						{
							onmo->player->viewheight -= onmo->floorz - onmo->origin.z;
							onmo->player->deltaviewheight = (VIEWHEIGHT -
								onmo->player->viewheight) / 8.0;
						}
						onmo->origin.z = onmo->floorz;
					}
				}
			}
		}
		else
		{
			P_ZMovement(mobj);
		}
		if (!mobj->real_function)
		{
			// mobj was removed
			return;
		}
	}

	//
	// cycle through states, calling action functions at transitions
	//
	if (mobj->time != -1.0)
	{
		mobj->time -= frametime;
		// you can cycle through multiple states in a tic
		if (mobj->time <= 0.0)
		{
			mobj->time = 0.0;
			if (!SetMobjState(mobj, mobj->nextstate))
			{
				// mobj was removed
				return;
			}
		}
	}
	else
	{
		// Check for monster respawn
		if (!(mobj->flags&MF_COUNTKILL))
		{
			return;
		}
		if (!respawnmonsters)
		{
			return;
		}
		mobj->movecount++;
		if (mobj->movecount < 12 * 35)
		{
			return;
		}
		if (level->tictime & 31)
		{
			return;
		}
		if (P_Random() > 4)
		{
			return;
		}
		P_NightmareRespawn(mobj);
	}
}

