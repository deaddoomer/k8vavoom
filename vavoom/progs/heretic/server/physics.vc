//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define	GRAVITY			1225.0
#define	MAXMOVE			1050.0
#define STOPSPEED		2.1875

#define FRICTION_NORMAL	3.28125
#define FRICTION_LOW	0.95703125
#define FRICTION_FLY	2.87109375
#define FRICTION_WATER	3.0

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

float windTab[3] = { 5.0 / 32.0, 10.0 / 32.0, 25.0 / 32.0 };

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  ClipVelocity
//
//  Slide off of the impacting object
//
//==========================================================================

TVec ClipVelocity(TVec in, TVec normal, float overbounce)
{
	return in - normal * (DotProduct(in, normal) * overbounce);
}

//**************************************************************************
//
//  SLIDE MOVE
//
//  Allows the player to slide along any angled walls.
//
//**************************************************************************

float bestslidefrac;
float secondslidefrac;

line_t *bestslideline;
line_t *secondslideline;

Actor slidemo;
TVec slideorg;
TVec slidedir;

//==========================================================================
//
//  PTR_SlideTraverse
//
//==========================================================================

boolean PTR_SlideTraverse(intercept_t * in)
{
	line_t *li;
	TVec hit_point;
	opening_t *open;

	if (!in->isaline)
		Error("PTR_SlideTraverse: not a line?");

	li = in->line;

	if (li->flags & ML_TWOSIDED)
	{
		// set openrange, opentop, openbottom
		hit_point = slideorg + in->frac * slidedir;
		open = LineOpenings(li, hit_point);
		open =
			FindOpening(open, slidemo.origin.z,
			slidemo.origin.z + slidemo.Height);

		if (open && (open->range >= slidemo.Height) &&	//  fits
			(open->top - slidemo.origin.z >= slidemo.Height) &&	// mobj is not too high
			(open->bottom - slidemo.origin.z <= 24.0))	// not too big a step up
		{
			// this line doesn't block movement
			return true;
		}
	}
	else
	{
		if (PointOnPlaneSide(slidemo.origin, li))
		{
			// don't hit the back side
			return true;
		}
	}

	// the line does block movement,
	// see if it is closer than best so far
	if (in->frac < bestslidefrac)
	{
		secondslidefrac = bestslidefrac;
		secondslideline = bestslideline;
		bestslidefrac = in->frac;
		bestslideline = li;
	}

	return false;	// stop
}

//==========================================================================
//
//  SlidePathTraverse
//
//==========================================================================

void SlidePathTraverse(float x, float y)
{
	slideorg = vector(x, y, slidemo.origin.z);
	slidedir = slidemo.velocity * frametime;
	P_PathTraverse(x, y, x + slidedir.x, y + slidedir.y,
		PT_ADDLINES, PTR_SlideTraverse);
}

//==========================================================================
//
//  Actor::SlideMove
//
//  The momx / momy move is bad, so try to slide along a wall.
//  Find the first line hit, move flush to it, and slide along it.
//  This is a kludgy mess.
//
//==========================================================================

void Actor::SlideMove(void)
{
	float leadx;
	float leady;
	float trailx;
	float traily;
	float newx;
	float newy;
	int hitcount;

	slidemo = self;
	hitcount = 0;

	do
	{
		if (++hitcount == 3)
		{
			// don't loop forever
			if (!P_TryMove(this, origin.x, origin.y + velocity.y * frametime))
				P_TryMove(this, origin.x + velocity.x * frametime, origin.y);
			return;
		}

		// trace along the three leading corners
		if (velocity.x > 0.0)
		{
			leadx = origin.x + Radius;
			trailx = origin.x - Radius;
		}
		else
		{
			leadx = origin.x - Radius;
			trailx = origin.x + Radius;
		}

		if (velocity.y > 0.0)
		{
			leady = origin.y + Radius;
			traily = origin.y - Radius;
		}
		else
		{
			leady = origin.y - Radius;
			traily = origin.y + Radius;
		}

		bestslidefrac = 1.00001;

		SlidePathTraverse(leadx, leady);
		SlidePathTraverse(trailx, leady);
		SlidePathTraverse(leadx, traily);

		// move up to the wall
		if (bestslidefrac == 1.00001)
		{
			// the move most have hit the middle, so stairstep
			if (!P_TryMove(this, origin.x, origin.y + velocity.y * frametime))
				P_TryMove(this, origin.x + velocity.x * frametime, origin.y);
			return;
		}

		// fudge a bit to make sure it doesn't hit
		bestslidefrac -= 0.03125;
		if (bestslidefrac > 0.0)
		{
			newx = velocity.x * frametime * bestslidefrac;
			newy = velocity.y * frametime * bestslidefrac;

			if (!P_TryMove(this, origin.x + newx, origin.y + newy))
			{
				if (!P_TryMove(this, origin.x,
						origin.y + velocity.y * frametime))
					P_TryMove(this, origin.x + velocity.x * frametime,
						origin.y);
				return;
			}
		}

		// Now continue along the wall.
		// First calculate remainder.
		bestslidefrac = 1.0 - (bestslidefrac + 0.03125);

		if (bestslidefrac > 1.0)
			bestslidefrac = 1.0;

		if (bestslidefrac <= 0.0)
			return;

		// clip the moves
		velocity = ClipVelocity(velocity * bestslidefrac,
			bestslideline->normal, 1.0);

	}
	while (!P_TryMove(this, origin.x + velocity.x * frametime,
			origin.y + velocity.y * frametime));
}

//**************************************************************************
//
//  BOUNCING
//
//  Bounce missile against walls
//
//**************************************************************************

#if 0

//============================================================================
//
//  PTR_BounceTraverse
//
//============================================================================

boolean PTR_BounceTraverse(intercept_t * in)
{
	line_t *li;
	TVec hit_point;
	opening_t *open;

	if (!in->isaline)
		Error("PTR_BounceTraverse: not a line?");

	li = in->line;
	if (li->flags & ML_TWOSIDED)
	{
		hit_point = slideorg + in->frac * slidedir;
		open = LineOpenings(li, hit_point);	// set openrange, opentop, openbottom
		open =
			FindOpening(open, slidemo.origin.z,
			slidemo.origin.z + slidemo.Height);
		if (open && open->range >= slidemo.Height &&	// fits
			open->top - slidemo.origin.z >= slidemo.Height)	// mobj is not too high
		{
			return true;	// this line doesn't block movement
		}
	}
	else
	{
		if (PointOnPlaneSide(slidemo.origin, li))
		{
			return true;	// don't hit the back side
		}
	}

	// the line does block movement, see if it is closer than best so far
	if (in->frac < bestslidefrac)
	{
		secondslidefrac = bestslidefrac;
		secondslideline = bestslideline;
		bestslidefrac = in->frac;
		bestslideline = li;
	}
	return false;	// stop
}

//============================================================================
//
//  Actor::BounceWall
//
//============================================================================

void Actor::BounceWall(void)
{
	float leadx, leady;

	slidemo = self;

	//
	// trace along the three leading corners
	//
	if (velocity.x > 0.0)
	{
		leadx = origin.x + Radius;
	}
	else
	{
		leadx = origin.x - Radius;
	}
	if (velocity.y > 0.0)
	{
		leady = origin.y + Radius;
	}
	else
	{
		leady = origin.y - Radius;
	}
	bestslidefrac = 1.00001;
	slideorg = vector(leadx, leady, slidemo.origin.z);
	slidedir = velocity * frametime;
	P_PathTraverse(leadx, leady, leadx + slidedir.x, leady + slidedir.y,
		PT_ADDLINES, PTR_BounceTraverse);
	velocity = ClipVelocity(velocity * 0.75, bestslideline->normal, 2.0);
}

#endif

//**************************************************************************
//
//  OBJECT MOVEMENT
//
//**************************************************************************

//==========================================================================
//
//  Actor::CheckWater
//
//==========================================================================

boolean Actor::CheckWater(void)
{
	TVec point;
	int cont;

	point = origin;
	point.z += 1.0;

	waterlevel = 0;
	watertype = CONTENTS_EMPTY;
	cont = PointContents(subsector->sector, point);
	if (cont >= CONTENTS_WATER)
	{
		watertype = cont;
		waterlevel = 1;
		point.z = origin.z + Height * 0.5;
		cont = PointContents(subsector->sector, point);
		if (cont >= CONTENTS_WATER)
		{
			waterlevel = 2;
			if (player)
			{
				point = player->vieworg;
				cont = PointContents(subsector->sector, point);
				if (cont >= CONTENTS_WATER)
					waterlevel = 3;
			}
		}
	}
	return waterlevel > 1;
}

//==========================================================================
//
//  Actor::UpdateVelocity
//
//==========================================================================

void Actor::UpdateVelocity(void)
{
	if (origin.z <= floorz && !velocity.x && !velocity.y &&
		!velocity.z && !(Flags & MF_COUNTKILL) && !player)
	{
		//  No gravity for non-moving things on ground to prevent
		// static objects from sliding on slopes
		return;
	}

	if (origin.z > floorz || floor->normal.z < 0.7)
	{
		if (waterlevel < 2)
		{
			if (Flags2 & MF2_LOGRAV)
			{
				velocity.z -= GRAVITY / 8.0 * frametime;
			}
			else if (!(Flags & MF_NOGRAVITY))
			{
				velocity.z -= GRAVITY * frametime;
			}
		}
		else if (!player)
		{
			if (Flags2 & MF2_LOGRAV)
			{
				velocity.z = -10.0;
			}
			else if (!(Flags & MF_NOGRAVITY))
			{
				velocity.z = -60.0;
			}
		}
	}

	// Friction

	if (Flags & (MF_MISSILE | MF_SKULLFLY))
	{
		// No friction for missiles
		return;
	}

	if (origin.z > floorz && waterlevel < 2 &&
		!(Flags2 & MF2_FLY) && !(Flags2 & MF2_ONMOBJ))
	{
		// No friction when falling
		return;
	}

	if (origin.z <= floorz)
	{
		//  Clip velocity
		float dot = DotProduct(velocity, floor->normal);

		if (dot < 0.0)
		{
			velocity -= dot * floor->normal;
		}
	}

	if (Flags & MF_CORPSE)
	{
		// Don't stop sliding if halfway off a step with some momentum
		if (velocity.x > 0.25 * 35.0 || velocity.x < -0.25 * 35.0 ||
			velocity.y > 0.25 * 35.0 || velocity.y < -0.25 * 35.0)
		{
			if (floorz != subsector->sector->floorheight)
			{
				return;
			}
		}
	}

	if (velocity.x > -STOPSPEED && velocity.x < STOPSPEED &&
		velocity.y > -STOPSPEED && velocity.y < STOPSPEED &&
		velocity.z > -STOPSPEED && velocity.z < STOPSPEED &&
		(!player || (!player->forwardmove && !player->sidemove)))
	{
		// If in a walking frame, stop moving
		if (player)
		{
			if (player->chickenTics)
			{
				int sn;

				sn = statenum;
				if (sn >= S_CHICPLAY_RUN1 && sn <= S_CHICPLAY_RUN4)
				{
					SetState(S_CHICPLAY);
				}
			}
			else
			{
				int sn;

				sn = statenum;
				if (sn >= S_PLAY_RUN1 && sn <= S_PLAY_RUN4)
				{
					SetState(S_PLAY);
				}
			}
		}
		velocity = vector(0.0, 0.0, 0.0);
	}
	else
	{
		if (waterlevel > 1)
		{
			velocity -= velocity * FRICTION_WATER * frametime;
		}
		else if ((Flags2 & MF2_FLY) && !(origin.z <= floorz)
			&& !(Flags2 & MF2_ONMOBJ))
		{
			velocity -= velocity * FRICTION_FLY * frametime;
		}
		else if (subsector->sector->special == 15)	// Friction_Low
		{
			velocity -= velocity * FRICTION_LOW * frametime;
		}
		else
		{
			velocity -= velocity * FRICTION_NORMAL * frametime;
		}
	}
}

//===========================================================================
//
//  Actor::XYMovement
//
//===========================================================================

void Actor::XYMovement(void)
{
	float ptryx, ptryy;
	float xmove, ymove;
	int special;

	if (!velocity.x && !velocity.y)
	{
		if (Flags & MF_SKULLFLY)
		{
			// A flying mobj slammed into something
			Flags &= ~MF_SKULLFLY;
			velocity = vector(0.0, 0.0, 0.0);
			SetState(SeeState);
		}
		return;
	}
	special = subsector->sector->special;
	if (Flags2 & MF2_WINDTHRUST)
	{
		switch (special)
		{
		case 40:
		case 41:
		case 42:	// Wind_East
			P_ThrustMobj(this, 0.0, windTab[special - 40]);
			break;
		case 43:
		case 44:
		case 45:	// Wind_North
			P_ThrustMobj(this, 90.0, windTab[special - 43]);
			break;
		case 46:
		case 47:
		case 48:	// Wind_South
			P_ThrustMobj(this, 270.0, windTab[special - 46]);
			break;
		case 49:
		case 50:
		case 51:	// Wind_West
			P_ThrustMobj(this, 180.0, windTab[special - 49]);
			break;
		}
	}
	if (velocity.x > MAXMOVE)
	{
		velocity.x = MAXMOVE;
	}
	else if (velocity.x < -MAXMOVE)
	{
		velocity.x = -MAXMOVE;
	}
	if (velocity.y > MAXMOVE)
	{
		velocity.y = MAXMOVE;
	}
	else if (velocity.y < -MAXMOVE)
	{
		velocity.y = -MAXMOVE;
	}
	xmove = velocity.x * frametime;
	ymove = velocity.y * frametime;
	do
	{
		if (xmove > MAXMOVE / (35.0 * 2.0) || ymove > MAXMOVE / (35.0 * 2.0))
		{
			ptryx = origin.x + xmove / 2.0;
			ptryy = origin.y + ymove / 2.0;
			xmove /= 2.0;
			ymove /= 2.0;
		}
		else
		{
			ptryx = origin.x + xmove;
			ptryy = origin.y + ymove;
			xmove = ymove = 0.0;
		}
		if (!P_TryMove(this, ptryx, ptryy))
		{
			// Blocked move
			if (Flags2 & MF2_SLIDE)
			{
				// Try to slide along it
				SlideMove();
			}
			else if (Flags & MF_MISSILE)
			{
				// Explode a missile
				if (ceilingline && ceilingline->backsector &&
					ceilingline->backsector->ceiling.pic == skyflatnum)
				{
					// Hack to prevent missiles exploding against the sky
					if (Class == BloodySkull)
					{
						velocity.x = velocity.y = 0.0;
						velocity.z = -1.0 * 35.0;
					}
					else
					{
						P_RemoveMobj(this);
					}
					return;
				}
				P_ExplodeMissile(this);
			}
			//else if (crashstate)
			//{
			//      velocity.x = velocity.y = 0.0;
			//      P_SetMobjState(this, crashstate);
			//      return;
			//}
			else
			{
				velocity.x = velocity.y = 0.0;
			}
		}
	}
	while (xmove || ymove);
}

//**************************************************************************
//
//  TEST ON MOBJ
//
//**************************************************************************

Actor tzmthing;
TVec tzorg;
Actor onmobj;	//generic global onmobj...used for landing on pods/players

//==========================================================================
//
//  Actor::Iter_CheckOnmobjZ
//
//==========================================================================

boolean Actor::Iter_CheckOnmobjZ(Actor thing)
{
	float blockdist;

	if (!(thing.Flags & (MF_SOLID | MF_SPECIAL | MF_SHOOTABLE)))
	{
		// Can't hit thing
		return true;
	}
	blockdist = thing.Radius + Radius;
	if (fabs(thing.origin.x - tzorg.x) >= blockdist
		|| fabs(thing.origin.y - tzorg.y) >= blockdist)
	{
		// Didn't hit thing
		return true;
	}
	if (thing == self)
	{
		// Don't clip against self
		return true;
	}
	if (tzorg.z > thing.origin.z + thing.Height)
	{
		return true;
	}
	else if (tzorg.z + Height < thing.origin.z)
	{
		// under thing
		return true;
	}
	if (thing.Flags & MF_SOLID)
	{
		onmobj = thing;
	}
	return (!(thing.Flags & MF_SOLID));
}

//==========================================================================
//
//  PIT_CheckOnmobjZ
//
//==========================================================================

boolean PIT_CheckOnmobjZ(mobj_t * thing)
{
	return tzmthing.Iter_CheckOnmobjZ(*thing);
}

//=============================================================================
//
//  Actor::FakeZMovement
//
//  Fake the zmovement so that we can check if a move is legal
//
//=============================================================================

void Actor::FakeZMovement(void)
{
	float dist;
	float delta;

	//
	//  adjust height
	//
	tzorg.z += velocity.z * frametime;
	if (Flags & MF_FLOAT && target)
	{
		// float down towards target if too close
		if (!(Flags & MF_SKULLFLY) && !(Flags & MF_INFLOAT))
		{
			dist = MobjDist2(this, target);
			delta = target->origin.z + Height / 2.0 - tzorg.z;
			if (delta < 0.0 && dist < -(delta * 3.0))
				tzorg.z -= FLOATSPEED * frametime;
			else if (delta > 0.0 && dist < (delta * 3.0))
				tzorg.z += FLOATSPEED * frametime;
		}
	}
	if (player && Flags2 & MF2_FLY && !(tzorg.z <= floorz)
		&& level->tictime & 2)
	{
		tzorg.z += sin(90.0 * 35.0 / 20.0 * level->time);
	}

	//
	//  clip movement
	//
	if (tzorg.z <= floorz)
	{
		// Hit the floor
		tzorg.z = floorz;
		if (CrashState && (Flags & MF_CORPSE))
		{
			return;
		}
	}

	if (tzorg.z + Height > ceilingz)
	{
		// hit the ceiling
		tzorg.z = ceilingz - Height;
	}
}

//=============================================================================
//
//  Actor::CheckOnmobj
//
//  Checks if the new Z position is legal
//
//=============================================================================

Actor Actor::CheckOnmobj(void)
{
	int xl, xh, yl, yh, bx, by;

	if (Flags & MF_NOCLIP)
		return none;

	tzmthing = self;
	tzorg = origin;
	FakeZMovement();

	//
	// check things first, possibly picking things up
	// the bounding box is extended by MAXRADIUS because mobj_ts are grouped
	// into mapblocks based on their origin point, and can overlap into adjacent
	// blocks by up to MAXRADIUS units
	//
	xl = MapBlock(origin.x - Radius - level->bmaporgx - MAXRADIUS);
	xh = MapBlock(origin.x + Radius - level->bmaporgx + MAXRADIUS);
	yl = MapBlock(origin.y - Radius - level->bmaporgy - MAXRADIUS);
	yh = MapBlock(origin.y + Radius - level->bmaporgy + MAXRADIUS);

	for (bx = xl; bx <= xh; bx++)
	{
		for (by = yl; by <= yh; by++)
		{
			if (!P_BlockThingsIterator(bx, by, PIT_CheckOnmobjZ))
			{
				return onmobj;
			}
		}
	}
	return none;
}

//===========================================================================
//
//  Actor::ZMovement
//
//===========================================================================

void Actor::ZMovement(void)
{
	float dist;
	float delta;
	float vdot;

	//
	// check for smooth step up
	//
	if (player && origin.z < floorz)
	{
		player->viewheight -= floorz - origin.z;
		player->deltaviewheight =
			(VIEWHEIGHT - player->viewheight) / 8.0;
	}

	//
	// adjust height
	//
	origin.z += velocity.z * frametime;
	if (Flags & MF_FLOAT && target)
	{
		// float down towards target if too close
		if (!(Flags & MF_SKULLFLY) && !(Flags & MF_INFLOAT))
		{
			dist = MobjDist(this, target);
			delta = target->origin.z + Height / 2.0 - origin.z;
			if (delta < 0.0 && dist < -(delta * 3.0))
				origin.z -= FLOATSPEED * frametime;
			else if (delta > 0.0 && dist < (delta * 3.0))
				origin.z += FLOATSPEED * frametime;
		}
	}
	if (player && Flags2 & MF2_FLY && !(origin.z <= floorz)
		&& level->tictime & 2)
	{
		origin.z += sin(90.0 * 35.0 / 20.0 * level->time);
	}

	//
	// clip movement
	//
	if (origin.z <= floorz + 0.1)
	{
		// Hit the floor
		vdot = DotProduct(velocity, floor->normal);
		if (Flags & MF_MISSILE)
		{
			origin.z = floorz;
			if (Flags2 & MF2_FLOORBOUNCE)
			{
				P_FloorBounceMissile(this);
				return;
			}
			else if (Class == MinotaurFloorFire)
			{
				// Minotaur floor fire can go up steps
				return;
			}
			else
			{
				P_ExplodeMissile(this);
				return;
			}
		}
		if (origin.z - velocity.z * frametime > floorz)
		{
			// Spawn splashes, etc.
			P_HitFloor(this);
		}
		origin.z = floorz;
		if (vdot < -0.1)
		{
			if (player && vdot < -GRAVITY * 0.25
				&& !(Flags2 & MF2_FLY))	// squat down
			{
				player->deltaviewheight = vdot * frametime / 8.0;
				StartSoundName(this, 'PlayerLand', CHAN_BODY);
//FIXME             player->centering = true;
			}
			velocity -= vdot * floor->normal;
		}
		if (Flags & MF_SKULLFLY)
		{
			// The skull slammed into something
			velocity -= vdot * floor->normal * 2.0;
		}
		if (CrashState && (Flags & MF_CORPSE))
		{
			SetState(CrashState);
			return;
		}
	}

	if (origin.z + Height > ceilingz)
	{
		// hit the ceiling
		vdot = DotProduct(velocity, ceiling->normal);
		if (vdot < 0.0)
			velocity -= vdot * ceiling->normal;
		origin.z = ceilingz - Height;
		if (Flags & MF_SKULLFLY)
		{	// the skull slammed into something
			velocity.z = -velocity.z;
		}
		if (Flags & MF_MISSILE)
		{
			if (subsector->sector->ceiling.pic == skyflatnum)
			{
				if (Class == BloodySkull)
				{
					velocity.x = velocity.y = 0.0;
					velocity.z = -1.0 * 35.0;
				}
				else
				{
					P_RemoveMobj(this);
				}
				return;
			}
			P_ExplodeMissile(this);
			return;
		}
	}
}

//===========================================================================
//
//  Actor::BlasterPhysics
//
//  Thinker for the ultra-fast blaster PL2 ripper-spawning missile.
//
//===========================================================================

boolean Actor::BlasterPhysics(void)
{
	int i;
	float xfrac;
	float yfrac;
	float zfrac;
	float z;
	boolean changexy;

	// Handle movement
	if (velocity.x || velocity.y ||
		(origin.z != floorz) || velocity.z)
	{
		xfrac = velocity.x * frametime / 8.0;
		yfrac = velocity.y * frametime / 8.0;
		zfrac = velocity.z * frametime / 8.0;
		changexy = xfrac || yfrac;
		for (i = 0; i < 8; i++)
		{
			if (changexy)
			{
				if (!P_TryMove(this, origin.x + xfrac, origin.y + yfrac))
				{
					// Blocked move
					P_ExplodeMissile(this);
					return !IsDestroyed();
				}
			}
			origin.z += zfrac;
			if (origin.z <= floorz)
			{
				// Hit the floor
				origin.z = floorz;
				P_HitFloor(this);
				P_ExplodeMissile(this);
				return !IsDestroyed();
			}
			if (origin.z + Height > ceilingz)
			{
				// Hit the ceiling
				origin.z = ceilingz - Height;
				P_ExplodeMissile(this);
				return !IsDestroyed();
			}
			if (changexy && (P_Random() < 64))
			{
				z = origin.z - 8.0;
				if (z < floorz)
				{
					z = floorz;
				}
				P_SpawnMobj(origin.x, origin.y, z, BlasterSmoke);
			}
		}
	}
	return true;
}

//===========================================================================
//
//	Actor::Physics
//
//===========================================================================

boolean Actor::Physics(void)
{
	Actor onmo;

	if (blaster)
	{
		return BlasterPhysics();
	}

	CheckWater();
	if (!(Flags2 & MF2_FLOATBOB))
	{
		UpdateVelocity();
	}

	// Handle X and Y momentums
	if (velocity.x || velocity.y || (Flags & MF_SKULLFLY))
	{
		XYMovement();
		if (IsDestroyed())
		{
			// mobj was removed
			return false;
		}
	}
	if (Flags2 & MF2_FLOATBOB)
	{
		// Floating item bobbing motion
		origin.z = floorz + FloatBobOffsets[(Health++) & 63];
	}
	else if ((origin.z != floorz) || velocity.z)
	{
		// Handle Z momentum and gravity
		if (!(Flags2 & MF2_NOPASSMOBJ))
		{
			if (!(onmo = CheckOnmobj()))
			{
				ZMovement();
			}
			else
			{
				if (player && velocity.z < 0.0)
				{
					Flags2 |= MF2_ONMOBJ;
					velocity.z = 0.0;
				}
				if (player && (onmo.player || onmo.Class == Pod))
				{
					velocity.x = onmo.velocity.x;
					velocity.y = onmo.velocity.y;
					if (onmo.origin.z < onmo.floorz)
					{
						origin.z += onmo.floorz - onmo.origin.z;
						if (onmo.player)
						{
							onmo.player->viewheight -=
								onmo.floorz - onmo.origin.z;
							onmo.player->deltaviewheight =
								(VIEWHEIGHT - onmo.player->viewheight) / 8.0;
						}
						onmo.origin.z = onmo.floorz;
					}
				}
			}
		}
		else
		{
			ZMovement();
		}
		if (IsDestroyed())
		{
			// mobj was removed
			return false;
		}
	}
	return true;
}

//==========================================================================
//
//	Actor::Think
//
//==========================================================================

void Actor::Think(void)
{
	if (!Physics())
	{
		return;
	}

	//
	// cycle through states, calling action functions at transitions
	//
	if (time != -1.0)
	{
		time -= frametime;
		if (time <= 0.0)
		{
			// you can cycle through multiple states in a tic
			do
			{
				if (!SetState(nextstate))
				{
					// mobj was removed
					return;
				}
			}
			while (!time);
		}
	}
	else
	{
		// Check for monster respawn
		if (!(Flags & MF_COUNTKILL))
		{
			return;
		}
		if (!respawnmonsters)
		{
			return;
		}
		movecount++;
		if (movecount < 12 * 35)
		{
			return;
		}
		if (level->tictime & 31)
		{
			return;
		}
		if (P_Random() > 4)
		{
			return;
		}
		P_NightmareRespawn(this);
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.16  2002/01/24 18:19:26  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.15  2002/01/17 18:15:53  dj_jl
//  Renamed all map object classes
//
//  Revision 1.14  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.13  2002/01/11 18:19:41  dj_jl
//  Started to use names in progs
//
//  Revision 1.12  2002/01/07 12:23:17  dj_jl
//  Changed copyright year
//
//  Revision 1.11  2001/12/27 17:52:23  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.10  2001/12/01 18:08:53  dj_jl
//  Physics functions as methods, started to use class references
//
//  Revision 1.9  2001/10/22 17:23:12  dj_jl
//  Floatification of angles
//
//  Revision 1.8  2001/10/18 17:39:33  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.7  2001/10/04 17:27:52  dj_jl
//  Beautification
//
//  Revision 1.6  2001/10/02 17:42:38  dj_jl
//  Possibility to declare function's code inside class declaration
//
//  Revision 1.5  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.4  2001/09/20 16:19:59  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
