//**************************************************************************
//**
//**	##   ##    ##    ##   ##   ####     ####   ###     ###
//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**	   #    ##    ##    #      ####     ####   ##       ##
//**
//**	Copyright (C) 1999-2000 JÆnis Legzdi·ý
//**
//**	This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**	This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**	
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define	MAXLINEANIMS		64

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

//
//	TELEPORTATION
//
boolean EV_Teleport(int tag, mobj_t *thing, boolean usefog);

void CloseWeapons(void);

// DATA DECLARATIONS -------------------------------------------------------

//
//	Animating line specials
//
int		numlinespecials;
line_t	*linespeciallist[MAXLINEANIMS];

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  StartLockedACS
//
//==========================================================================

boolean StartLockedACS(line_t *line, int *args, mobj_t *mo, int side)
{
	int i;
	int newArgs[5];

	if (!CheckLockedDoor(mo, args[4]))
	{
		return false;
	}
	for (i = 0; i < 4; i++)
	{
		newArgs[i] = args[i];
	}
	newArgs[4] = 0;
	return StartACS(newArgs[0], newArgs[1], &newArgs[2], mo, line, side);
}

//==========================================================================
//
//  ExecuteLineSpecial
//
//==========================================================================

boolean ExecuteLineSpecial(int special, int *args, line_t *line, int side,
	mobj_t *mo)
{
	boolean buttonSuccess;

	buttonSuccess = false;
	switch (special)
	{
/*
		case 1: // Poly Start Line
			break;
		case 2: // Poly Rotate Left
			buttonSuccess = EV_RotatePoly(line, args, 1, false);
			break;
		case 3: // Poly Rotate Right
			buttonSuccess = EV_RotatePoly(line, args, -1, false);
			break;
		case 4: // Poly Move
			buttonSuccess = EV_MovePoly(line, args, false, false);
			break;
		case 5: // Poly Explicit Line:  Only used in initialization
			break;
		case 6: // Poly Move Times 8
			buttonSuccess = EV_MovePoly(line, args, true, false);
			break;
		case 7: // Poly Door Swing
			buttonSuccess = EV_OpenPolyDoor(line, args, PODOOR_SWING);
			break;
		case 8: // Poly Door Slide
			buttonSuccess = EV_OpenPolyDoor(line, args, PODOOR_SLIDE);
			break;*/
		case 10: // Door Close
			buttonSuccess = EV_DoDoor(line, args, vd_close);
			break;
		case 11: // Door Open
			if (!args[0])
			{
				buttonSuccess = EV_VerticalDoor(line, mo);
			}
			else
			{
				buttonSuccess = EV_DoDoor(line, args, vd_open);
			}
			break;
		case 12: // Door Raise
			if (!args[0])
			{
				buttonSuccess = EV_VerticalDoor(line, mo);
			}
			else
			{
				buttonSuccess = EV_DoDoor(line, args, vd_normal);
			}
			break;
		case 13: // Door Locked_Raise
			if (CheckLockedDoor(mo, args[3]))
			{
				if (!args[0])
				{
					buttonSuccess = EV_VerticalDoor(line, mo);
				}
				else
				{
					buttonSuccess = EV_DoDoor(line, args, vd_normal);
				}
			}
			break;
/*		case 20: // Floor Lower by Value
			buttonSuccess = EV_DoFloor(line, args, FLEV_LOWERFLOORBYVALUE);
			break;*/
		case 21: // Floor Lower to Lowest
			buttonSuccess = EV_DoFloor(line, args, FLEV_LOWERFLOORTOLOWEST);
			break;
		case 22: // Floor Lower to Nearest
			buttonSuccess = EV_DoFloor(line, args, FLEV_LOWERFLOOR);
			break;
		case 23: // Floor Raise by Value
			buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEFLOORBYVALUE);
			break;
/*		case 24: // Floor Raise to Highest
			buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEFLOOR);
			break;*/
		case 25: // Floor Raise to Nearest
			buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEFLOORTONEAREST);
			break;
/*		case 26: // Stairs Build Down Normal
			buttonSuccess = EV_BuildStairs(line, args, -1, STAIRS_NORMAL);
			break;
		case 27: // Build Stairs Up Normal
			buttonSuccess = EV_BuildStairs(line, args, 1, STAIRS_NORMAL);
			break;*/
		case 28: // Floor Raise and Crush
			buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEFLOORCRUSH);
			break;
/*		case 29: // Build Pillar (no crushing)
			buttonSuccess = EV_BuildPillar(line, args, false);
			break;
		case 30: // Open Pillar
			buttonSuccess = EV_OpenPillar(line, args);
			break;
		case 31: // Stairs Build Down Sync
			buttonSuccess = EV_BuildStairs(line, args, -1, STAIRS_SYNC);
			break;
		case 32: // Build Stairs Up Sync
			buttonSuccess = EV_BuildStairs(line, args, 1, STAIRS_SYNC);
			break;
		case 35: // Raise Floor by Value Times 8
			buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEBYVALUETIMES8);
			break;
		case 36: // Lower Floor by Value Times 8
			buttonSuccess = EV_DoFloor(line, args, FLEV_LOWERBYVALUETIMES8);
			break;
		case 40: // Ceiling Lower by Value
			buttonSuccess = EV_DoCeiling(line, args, CLEV_LOWERBYVALUE);
			break;
		case 41: // Ceiling Raise by Value
			buttonSuccess = EV_DoCeiling(line, args, CLEV_RAISEBYVALUE);
			break;
		case 42: // Ceiling Crush and Raise
			buttonSuccess = EV_DoCeiling(line, args, CLEV_CRUSHANDRAISE);
			break;*/
		case 43: // Ceiling Lower and Crush
			buttonSuccess = EV_DoCeiling(line, args, CLEV_LOWERANDCRUSH);
			break;
		case 44: // Ceiling Crush Stop
			buttonSuccess = EV_CeilingCrushStop(line, args);
			break;
/*		case 45: // Ceiling Crush Raise and Stay
			buttonSuccess = EV_DoCeiling(line, args, CLEV_CRUSHRAISEANDSTAY);
			break;
		case 46: // Floor Crush Stop
			buttonSuccess = EV_FloorCrushStop(line, args);
			break;
		case 60: // Plat Perpetual Raise
			buttonSuccess = EV_DoPlat(line, args, PLAT_PERPETUALRAISE);
			break;*/
		case 61: // Plat Stop
			EV_StopPlat(line, args);
			break;
/*		case 62: // Plat Down-Wait-Up-Stay
			buttonSuccess = EV_DoPlat(line, args, PLAT_DOWNWAITUPSTAY);
			break;
		case 63: // Plat Down-by-Value*8-Wait-Up-Stay
			buttonSuccess = EV_DoPlat(line, args, PLAT_DOWNBYVALUEWAITUPSTAY);
			break;
		case 64: // Plat Up-Wait-Down-Stay
			buttonSuccess = EV_DoPlat(line, args, PLAT_UPWAITDOWNSTAY);
			break;
		case 65: // Plat Up-by-Value*8-Wait-Down-Stay
			buttonSuccess = EV_DoPlat(line, args, PLAT_UPBYVALUEWAITDOWNSTAY);
			break;
		case 66: // Floor Lower Instant * 8
			buttonSuccess = EV_DoFloor(line, args, FLEV_LOWERTIMES8INSTANT);
			break;
		case 67: // Floor Raise Instant * 8
			buttonSuccess = EV_DoFloor(line, args, FLEV_RAISETIMES8INSTANT);
			break;
		case 68: // Floor Move to Value * 8
			buttonSuccess = EV_DoFloor(line, args, FLEV_MOVETOVALUETIMES8);
			break;
		case 69: // Ceiling Move to Value * 8
			buttonSuccess = EV_DoCeiling(line, args, CLEV_MOVETOVALUETIMES8);
			break;*/
		case 70: // Teleport
			if (side == 0)
			{ // Only teleport when crossing the front side of a line
				buttonSuccess = EV_Teleport(args[0], mo, true);
			}
			break;
/*		case 71: // Teleport, no fog
			if(side == 0)
			{ // Only teleport when crossing the front side of a line
				buttonSuccess = EV_Teleport(args[0], mo, false);
			}
			break;
		case 72: // Thrust Mobj
			if (!side) // Only thrust on side 0
			{
				P_ThrustMobj(mo, args[0] * (ANG90 / 64), itof(args[1]));
				buttonSuccess = 1;
			}
			break;
		case 73: // Damage Mobj
			if(args[0])
			{
				DamageMobj(mo, NULL, NULL, args[0]);
			}
			else
			{ // If arg1 is zero, then guarantee a kill
				DamageMobj(mo, NULL, NULL, 10000);
			}
			buttonSuccess = 1;
			break;*/
		case 74: // Teleport_NewMap
			if(side == 0)
			{ // Only teleport when crossing the front side of a line
				if(!(mo && mo->player && mo->player->playerstate
					== PST_DEAD)) // Players must be alive to teleport
				{
					G_Completed(args[0], args[1]);
					buttonSuccess = true;
				}
			}
			break;
		case 75: // Teleport_EndGame
			if(side == 0)
			{ // Only teleport when crossing the front side of a line
				if(!(mo && mo->player && mo->player->playerstate
					== PST_DEAD)) // Players must be alive to teleport
				{
					buttonSuccess = true;
					if(deathmatch)
					{ // Winning in deathmatch just goes back to map 1
						G_Completed(1, 0);
					}
					else
					{ // Passing -1, -1 to G_Completed() starts the Finale
						G_Completed(-1, -1);
					}
				}
			}
			break;
		case 80: // ACS_Execute
			buttonSuccess =
				StartACS(args[0], args[1], &args[2], mo, line, side);
			break;
		case 81: // ACS_Suspend
			buttonSuccess = SuspendACS(args[0], args[1]);
			break;
		case 82: // ACS_Terminate
			buttonSuccess = TerminateACS(args[0], args[1]);
			break;
		case 83: // ACS_LockedExecute
			buttonSuccess = StartLockedACS(line, args, mo, side);
			break;
/*		case 90: // Poly Rotate Left Override
			buttonSuccess = EV_RotatePoly(line, args, 1, true);
			break;
		case 91: // Poly Rotate Right Override
			buttonSuccess = EV_RotatePoly(line, args, -1, true);
			break;
		case 92: // Poly Move Override
			buttonSuccess = EV_MovePoly(line, args, false, true);
			break;
		case 93: // Poly Move Times 8 Override
			buttonSuccess = EV_MovePoly(line, args, true, true);
			break;
		case 94: // Build Pillar Crush 
			buttonSuccess = EV_BuildPillar(line, args, true);
			break;
		case 95: // Lower Floor and Ceiling
			buttonSuccess = EV_DoFloorAndCeiling(line, args, false);
			break;
		case 96: // Raise Floor and Ceiling
			buttonSuccess = EV_DoFloorAndCeiling(line, args, true);
			break;
		case 109: // Force Lightning
			buttonSuccess = true;
			P_ForceLightning();
			break;
		case 110: // Light Raise by Value
			buttonSuccess = EV_SpawnLight(line, args, LITE_RAISEBYVALUE);
			break; 
		case 111: // Light Lower by Value
			buttonSuccess = EV_SpawnLight(line, args, LITE_LOWERBYVALUE);
			break; */
		case 112: // Light Change to Value
//			buttonSuccess = EV_SpawnLight(line, args, LITE_CHANGETOVALUE);
			buttonSuccess = EV_LightTurnOn(line, args);
			break;
/*		case 113: // Light Fade
			buttonSuccess = EV_SpawnLight(line, args, LITE_FADE);
			break; 
		case 114: // Light Glow
			buttonSuccess = EV_SpawnLight(line, args, LITE_GLOW);
			break; 
		case 115: // Light Flicker
			buttonSuccess = EV_SpawnLight(line, args, LITE_FLICKER);
			break; 
		case 116: // Light Strobe
			buttonSuccess = EV_SpawnLight(line, args, LITE_STROBE);
			break; 
		case 120: // Quake Tremor
			buttonSuccess = A_LocalQuake(args, mo);
			break;
		case 129: // UsePuzzleItem
			buttonSuccess = EV_LineSearchForPuzzleItem(line, args, mo);
			break;
		case 130: // Thing_Activate
			buttonSuccess = EV_ThingActivate(args[0]);
			break;
		case 131: // Thing_Deactivate
			buttonSuccess = EV_ThingDeactivate(args[0]);
			break;
		case 132: // Thing_Remove
			buttonSuccess = EV_ThingRemove(args[0]);
			break;
		case 133: // Thing_Destroy
			buttonSuccess = EV_ThingDestroy(args[0]);
			break;
		case 134: // Thing_Projectile
			buttonSuccess = EV_ThingProjectile(args, 0);
			break;
		case 135: // Thing_Spawn
			buttonSuccess = EV_ThingSpawn(args, 1);
			break;
		case 136: // Thing_ProjectileGravity
			buttonSuccess = EV_ThingProjectile(args, 1);
			break;
		case 137: // Thing_SpawnNoFog
			buttonSuccess = EV_ThingSpawn(args, 0);
			break;
		case 138: // Floor_Waggle
			buttonSuccess = EV_StartFloorWaggle(args[0], args[1],
				args[2], args[3], args[4]);
			break;
		case 140: // Sector_SoundChange
			buttonSuccess = EV_SectorSoundChange(args);
			break;

		// Line specials only processed during level initialization
		// 100: Scroll_Texture_Left
		// 101: Scroll_Texture_Right
		// 102: Scroll_Texture_Up
		// 103: Scroll_Texture_Down
		// 121: Line_SetIdentification
*/

		case 196: // Ceiling Crush and Raise
			buttonSuccess = EV_DoCeiling(line, args, CLEV_CRUSHANDRAISE);
			break;
		case 206: // Plat_DownWaitUpStayLip
			buttonSuccess = EV_DoPlat(line, args, PLAT_DOWNWAITUPSTAY);
			break;
		case 207: // Plat_PerpetualRaiseLip
			buttonSuccess = EV_DoPlat(line, args, PLAT_PERPETUALRAISE);
			break;
		case 217: // Stairs_BuildUpOld
			buttonSuccess = EV_BuildStairs(line, args);
			break;
		case 228: // Plat_RaiseAndStayTx0
			buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEFLOORTONEARESTCHANGE);
			break;
		case 230: // Plat_UpByValueStayTx
			buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEFLOORBYVALUECHANGE2);
			break;
		case 232: // Light_StrobeDoom
			buttonSuccess = EV_StartLightStrobing(line, args);
			break;
		case 233: // Light_MinNeighbor
			buttonSuccess = EV_TurnTagLightsOff(line, args);
			break; 
		case 234: // Light_MaxNeighbor
			buttonSuccess = EV_TagLightTurnOn(line, args);
			break; 
		case 238: // Floor Raise to Highest
			buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEFLOOR);
			break;
		case 239: // Floor_RaiseByValueTxTy
			buttonSuccess = EV_DoFloor(line, args, FLEV_RAISEFLOORBYVALUECHANGE);
			break;
		case 240: // Floor_RaiseByTexture
			buttonSuccess = EV_DoFloor(line, args, FLEV_RAISETOTEXTURE);
			break;
		case 241: // Floor_LowerToLowestTxTy
			buttonSuccess = EV_DoFloor(line, args, FLEV_LOWERTOLOWESTCHANGE);
			break;
		case 242: // Floor_LowerToHighest
			buttonSuccess = EV_DoFloor(line, args, FLEV_LOWERTOHIGHEST);
			break;
		case 243: // Exit_Normal
			G_ExitLevel();
			break;
		case 244: // Exit_Secret
			G_SecretExitLevel();
			break;
		case 249: // Door_CloseWaitOpen
			buttonSuccess = EV_DoDoor(line, args, DREV_CLOSEWAITOPEN);
			break;
		case 250: // Floor_Donut
			buttonSuccess = EV_DoDonut(line, args);
			break;
		case 251: // FloorAndCeiling_LowerRaise
			EV_DoCeiling(line, args, CLEV_RAISETOHIGHEST);
			EV_DoFloor(line, args, FLEV_LOWERFLOORTOLOWEST);
			break;
		case 254: // Ceiling_LowerToFloor
			buttonSuccess = EV_DoCeiling(line, args, CLEV_LOWERTOFLOOR);
			break;

		// Inert Line specials
		default:
			break;
	}
	return buttonSuccess;
}

//==========================================================================
//
//  P_SpawnSpecials
//
//==========================================================================

void P_SpawnSpecials(boolean spawn_thinkers)
{
	sector_t*	sector;
	int			i;

	if (spawn_thinkers)
    {
		CloseWeapons();

		//
		//	Init special SECTORs
		//
		for (i=0 ; i<level->numsectors ; i++)
		{
			sector = &level->sectors[i];
			if (!sector->special)
				continue;
			switch (sector->special)
			{
			 case 1:		// FLICKERING LIGHTS
				P_SpawnLightFlash(sector);
				break;
			 case 2:		// STROBE FAST
				P_SpawnStrobeFlash(sector, FASTDARK, STROBEBRIGHT, 0);
				break;
			 case 3:		// STROBE SLOW
				P_SpawnStrobeFlash(sector, SLOWDARK, STROBEBRIGHT, 0);
				break;
			 case 4:		// STROBE FAST/DEATH SLIME
				P_SpawnStrobeFlash(sector, FASTDARK, STROBEBRIGHT, 0);
				sector->special = 4;
				break;
			 case 8:		// GLOWING LIGHT
				P_SpawnGlowingLight(sector);
				break;
			 case 10:	// DOOR CLOSE IN 30 SECONDS
				P_SpawnDoorCloseIn30(sector);
				break;
			 case 12:	// SYNC STROBE SLOW
				P_SpawnStrobeFlash(sector, SLOWDARK, STROBEBRIGHT, 1);
				break;
			 case 13:	// SYNC STROBE FAST
				P_SpawnStrobeFlash(sector, FASTDARK, STROBEBRIGHT, 1);
				break;
			 case 14:	// DOOR RAISE IN 5 MINUTES
				P_SpawnDoorRaiseIn5Mins(sector, i);
				break;
	        }
		}
	}

	for (i=0 ; i<level->numsectors ; i++)
	{
		if (level->sectors[i].special == 9)
		{
		 	// SECRET SECTOR
			level->totalsecret++;
        }
	}

	//
	//	Init line EFFECTs
	//
	numlinespecials = 0;
	for (i = 0; i < level->numlines; i++)
	{
		switch (level->lines[i].special)
		{
			case 100: // Effect_Scroll_Left
			case 101: // Effect_Scroll_Right
				linespeciallist[numlinespecials] = &level->lines[i];
				numlinespecials++;
				break;
		}
	}
		
	P_ClearActiveCeilings();
	P_ClearActivePlats();
}

//==========================================================================
//==========================================================================
//
//								EVENTS
//
//	Events are operations triggered by using, crossing, or shooting special
// lines, or by timed thinkers
//
//==========================================================================
//==========================================================================

//==========================================================================
//
//  P_UpdateSpecials
//
//==========================================================================

void P_UpdateSpecials(void)
{
	int 		i;
	line_t 		*line;
    int         scrollOffset;
    sector_t	*sec;
	int			xoffs;
    int			yoffs;

	P_AmbientSound();

	// Update scrolling texture offsets
	for(i = 0; i < numlinespecials; i++)
	{
		line = linespeciallist[i];
		switch (line->special)
		{
			case 100: // Effect_Scroll_Left
				level->sides[line->sidenum[0]].textureoffset += itof(line->arg1) / 64.0;
				break;
			case 101: // Effect_Scroll_Right
				level->sides[line->sidenum[0]].textureoffset -= itof(line->arg1) / 64.0;
				break;
		}
	}

	//	Handle scrolling flats
	scrollOffset = (level->tictime >> 1) & 63;
	for (i=0; i<level->numsectors; i++)
    {
    	sec = &level->sectors[i];
		switch (sec->special)
		{
			case 20: case 21: case 22: case 23: case 24: // Scroll_East
            	xoffs = (63 - scrollOffset) << (sec->special - 20) & 63;
                yoffs = 0;
				break;
			case 4: // Scroll_EastLavaDamage
            	xoffs = ((63 - scrollOffset) << 3) & 63;
                yoffs = 0;
				break;
			default:
            	xoffs = 0;
                yoffs = 0;
		}
		sec->floor.xoffs = itof(xoffs);
        sec->floor.yoffs = itof(yoffs);
	}
}

//==========================================================================
//
//	CheckActivation
//
//==========================================================================

boolean CheckActivation(int activationType, line_t *line, mobj_t *mo)
{
	int			lineActivation;
	boolean		noway = true;

	lineActivation = GET_SPAC(line->flags);
	if (lineActivation != activationType &&
		!(activationType == SPAC_MCROSS && lineActivation == SPAC_CROSS))
	{
		return false;
	}
	if (!mo->player && !(mo->flags & MF_MISSILE))
	{
		if ((activationType == SPAC_USE || activationType == SPAC_PUSH)
			&& (line->flags & ML_SECRET))
			return false;		// never open secret doors

		switch (lineActivation)
		{
		 case SPAC_IMPACT:
		 case SPAC_PCROSS:
			// shouldn't really be here if not a missile
		 case SPAC_MCROSS:
			noway = false;
			break;

		 case SPAC_CROSS:
			switch (line->special)
			{
			 case 12:
			 case 70:
/*			 case Teleport_NoFog:
			 case Teleport_Line:
			 case Plat_DownWaitUpStayLip:
			 case Plat_DownWaitUpStay:*/
				noway = false;
			}
			break;

		 case SPAC_USE:
		 case SPAC_PUSH:
			switch (line->special)
			{
			 case 12:
				if (line->arg1 == 0)
					noway = false;
				break;
/*			 case Teleport:
			 case Teleport_NoFog:
				noway = false;*/
			}
			break;
		}
		if (noway)
			return false;
	}
	return true;
}

//============================================================================
//
//	P_ActivateLine
//
//============================================================================

boolean P_ActivateLine(line_t *line, mobj_t *mo, int side, int activationType)
{
	int			lineActivation;
	boolean 	repeat;
	boolean 	buttonSuccess;

	if (!CheckActivation(activationType, line, mo))
	{
		return false;
	}

	lineActivation = GET_SPAC(line->flags);
	repeat = line->flags & ML_REPEAT_SPECIAL;
	buttonSuccess = ExecuteLineSpecial(line->special, &line->arg1, line,
		side, mo);

	if (!repeat && buttonSuccess)
	{
		// clear the special on non-retriggerable lines
		line->special = 0;
	}
	if ((lineActivation == SPAC_USE || lineActivation == SPAC_IMPACT)
		&& buttonSuccess)
	{
		P_ChangeSwitchTexture(line, repeat);
	}
	return true;
}

