//**************************************************************************
//**
//**	##   ##    ##    ##   ##   ####     ####   ###     ###
//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**	   #    ##    ##    #      ####     ####   ##       ##
//**
//**	$Id$
//**
//**	Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**	This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**	This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**	$Log$
//**	Revision 1.2  2001/07/27 14:27:52  dj_jl
//**	Update with Id-s and Log-s, some fixes
//**
//**************************************************************************

#define	MAXPLATS	30

enum
{
	PLAT_UP,
	PLAT_DOWN,
	PLAT_WAITING,
	PLAT_IN_STASIS
};

enum
{
	PLAT_PERPETUALRAISE,
	PLAT_DOWNWAITUPSTAY
};

special_t	activeplats;

//==========================================================================
//
//  P_ClearActivePlats
//
//==========================================================================

void P_ClearActivePlats()
{
	activeplats.next = activeplats.prev = &activeplats;
}

//==========================================================================
//
//  P_AddActivePlat
//
//==========================================================================

void P_AddActivePlat(special_t *plat)
{
	//  Add to active plats
	plat->prev = activeplats.prev;
    plat->next = &activeplats;
    plat->prev->next = plat;
    activeplats.prev = plat;
}

//==========================================================================
//
//  P_RemoveActivePlat
//
//==========================================================================

void P_RemoveActivePlat(special_t *plat)
{
	plat->prev->next = plat->next;
    plat->next->prev = plat->prev;
    plat->sector->specialdata = NULL;
    RemoveSpecialThinker(plat);
}

//==================================================================
//
//  T_PlatRaise
//
//	Move a plat up and down
//
//==================================================================

void T_PlatRaise(special_t *plat)
{
	int		res;

	switch(plat->status)
	{
		case PLAT_UP:
			res = T_MovePlane(plat->sector, plat->speed,
					plat->high, plat->crush, 0, 1);
			if(!(level->tictime&31))
			{
				StartSoundName(&plat->sector->soundorg, "PlatformMove");
			}
			if (res == RES_CRUSHED && (!plat->crush))
			{
				plat->count = plat->wait;
				plat->status = PLAT_DOWN;
				StartSoundName(&plat->sector->soundorg, "PlatformStart");
			}
			else
			if (res == RES_PASTDEST)
			{
				plat->count = plat->wait;
				plat->status = PLAT_WAITING;
				StartSoundName(&plat->sector->soundorg, "PlatformStop");
				switch(plat->type)
				{
					case PLAT_DOWNWAITUPSTAY:
						P_RemoveActivePlat(plat);
						break;
					default:
						break;
				}
			}
			break;
		case PLAT_DOWN:
			res = T_MovePlane(plat->sector, plat->speed, plat->low, false, 0, -1);
			if (res == RES_PASTDEST)
			{
				plat->count = plat->wait;
				plat->status = PLAT_WAITING;
				StartSoundName(&plat->sector->soundorg, "PlatformStop");
			}
			else
			{
				if(!(level->tictime&31))
				{
					StartSoundName(&plat->sector->soundorg, "PlatformMove");
				}
			}
			break;
		case PLAT_WAITING:
			if (!--plat->count)
			{
				if (plat->sector->floorheight == plat->low)
					plat->status = PLAT_UP;
				else
					plat->status = PLAT_DOWN;
				StartSoundName(&plat->sector->soundorg, "PlatformStart");
			}
		case PLAT_IN_STASIS:
			break;
	}
}

//==========================================================================
//
//  P_ActivateInStasis
//
//==========================================================================

void P_ActivateInStasis(int tag)
{
    special_t	*plat;
	
    for (plat = activeplats.next; plat != &activeplats; plat = plat->next)
	{
		if ((plat->tag == tag) && (plat->status == PLAT_IN_STASIS))
		{
	    	plat->status = plat->oldstatus;
		}
	}
}

//==================================================================
//
//	Do Platforms
//	"amount" is only used for SOME platforms.
//
//==================================================================

int	EV_DoPlat(line_t *line, int *args,int type)
{
	special_t	*plat;
	int			secnum;
	int			rtn;
	sector_t	*sec;

	secnum = -1;
	rtn = 0;
	
	//
	//	Activate all <type> plats that are   PLAT_IN_STASIS
	//
	if (type == PLAT_PERPETUALRAISE)
	{
		P_ActivateInStasis(args[0]);
	}
	
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &level->sectors[secnum];
		if (sec->specialdata)
			continue;
	
		//
		// Find lowest & highest floors around sector
		//
		rtn = 1;
		plat = NewSpecialThinker(T_PlatRaise);
		
		plat->type = type;
		plat->sector = sec;
		plat->sector->specialdata = plat;
		plat->crush = false;
		plat->tag = args[0];
		plat->speed = itof(args[1]) / 8.0;
		switch(type)
		{
			case PLAT_DOWNWAITUPSTAY:
				plat->low = FindLowestFloorSurrounding(sec);
				if (plat->low > sec->floorheight)
					plat->low = sec->floorheight;
				plat->high = sec->floorheight;
				plat->wait = args[2];
				plat->status = PLAT_DOWN;
				StartSoundName(&sec->soundorg, "PlatformStart");
				break;
			case PLAT_PERPETUALRAISE:
				plat->low = FindLowestFloorSurrounding(sec);
				if (plat->low > sec->floorheight)
					plat->low = sec->floorheight;
				plat->high = FindHighestFloorSurrounding(sec);
				if (plat->high < sec->floorheight)
					plat->high = sec->floorheight;
				plat->wait = args[2];
				plat->status = P_Random()&1;
				StartSoundName(&sec->soundorg, "PlatformStart");
				break;
/*
			case PLAT_DOWNBYVALUEWAITUPSTAY:
				plat->low = sec->floorheight - itof(args[3]) * 8.0;
				if (plat->low > sec->floorheight)
					plat->low = sec->floorheight;
				plat->high = sec->floorheight;
				plat->wait = args[2];
				plat->status = PLAT_DOWN;
				break;
			case PLAT_UPWAITDOWNSTAY:
				plat->high = FindHighestFloorSurrounding(sec);
				if (plat->high < sec->floorheight)
					plat->high = sec->floorheight;
				plat->low = sec->floorheight;
				plat->wait = args[2];
				plat->status = PLAT_UP;
				break;
			case PLAT_UPBYVALUEWAITDOWNSTAY:
				plat->high = sec->floorheight + itof(args[3]) * 8.0;
				if (plat->high < sec->floorheight)
					plat->high = sec->floorheight;
				plat->low = sec->floorheight;
				plat->wait = args[2];
				plat->status = PLAT_UP;
				break;
*/
		}
		P_AddActivePlat(plat);
	}
	return rtn;
}

//==========================================================================
//
//  EV_StopPlat
//
//==========================================================================

int EV_StopPlat(line_t* line, int *args)
{
    special_t	*plat;

    for (plat = activeplats.next; plat != &activeplats; plat = plat->next)
    {
		if ((plat->status != PLAT_IN_STASIS) && (plat->tag == args[0]))
		{
		    plat->oldstatus = plat->status;
		    plat->status = PLAT_IN_STASIS;
		}
	}
	return 1;
}

