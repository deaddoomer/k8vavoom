//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

int WeaponAmmoUsePL1[NUMWEAPONS] = {
	0,	// staff
	USE_GWND_AMMO_1,	// gold wand
	USE_CBOW_AMMO_1,	// crossbow
	USE_BLSR_AMMO_1,	// blaster
	USE_SKRD_AMMO_1,	// skull rod
	USE_PHRD_AMMO_1,	// phoenix rod
	USE_MACE_AMMO_1,	// mace
	0,	// gauntlets
	0	// beak
};

int WeaponAmmoUsePL2[NUMWEAPONS] = {
	0,	// staff
	USE_GWND_AMMO_2,	// gold wand
	USE_CBOW_AMMO_2,	// crossbow
	USE_BLSR_AMMO_2,	// blaster
	USE_SKRD_AMMO_2,	// skull rod
	USE_PHRD_AMMO_2,	// phoenix rod
	USE_MACE_AMMO_2,	// mace
	0,	// gauntlets
	0	// beak
};

int MaceSpotCount;
float MaceSpot_x[MAX_MACE_SPOTS];
float MaceSpot_y[MAX_MACE_SPOTS];

//****************************************************************************
//
//  WEAPON UTILITES
//
//****************************************************************************

//==========================================================================
//
//	SetWeapon
//
//==========================================================================

void SetWeapon(Player player, int NewWeapon)
{
	player.ReadyWeapon = NewWeapon;
	player.PendingWeapon = wp_nochange;

	if (player.ViewEnts[ps_weapon])
	{
		player.ViewEnts[ps_weapon].Destroy();
	}
	player.ViewEnts[ps_weapon] = SpawnObject(WeaponClasses[NewWeapon], none);
	player.ViewEnts[ps_weapon].Player = player;
	player.PSpriteSY = Weapon(player.ViewEnts[ps_weapon]).PSpriteSY;
}

//===========================================================================
//
//  OpenWeapons
//
//  Called at level load before things are loaded.
//
//===========================================================================

void OpenWeapons(void)
{
	MaceSpotCount = 0;
}

//===========================================================================
//
//  AddMaceSpot
//
//===========================================================================

void AddMaceSpot(float x, float y)
{
	if (MaceSpotCount == MAX_MACE_SPOTS)
	{
		Error("Too many mace spots.");
	}
	MaceSpot_x[MaceSpotCount] = x;
	MaceSpot_y[MaceSpotCount] = y;
	MaceSpotCount++;
}

//===========================================================================
//
//  CloseWeapons
//
//  Called at level load after things are loaded.
//
//===========================================================================

void CloseWeapons(void)
{
	int spot;

	if (!MaceSpotCount)
	{
		// No maces placed
		return;
	}
	if (!deathmatch && P_Random() < 64)
	{
		// Sometimes doesn't show up if not in deathmatch
		return;
	}
	spot = P_Random() % MaceSpotCount;
	Spawn(ItemWeaponMace, vector(MaceSpot_x[spot], MaceSpot_y[spot],
		ONFLOORZ));
}

//===========================================================================
//
//  SetPsprite
//
//===========================================================================

void SetPsprite(Player player, int position, int stnum)
{
	player.ViewEnts[position].SetState(stnum);
}

//===========================================================================
//
//  BringUpWeapon
//
//  Starts bringing the pending weapon up from the bottom of the screen.
//
//===========================================================================

void BringUpWeapon(Player player)
{
	SetWeapon(player, player.ReadyWeapon);
	if (player.ReadyWeapon == wp_gauntlets)
	{
		player.MO.PlaySound('GauntletActive', CHAN_WEAPON);
	}
	player.ViewEnts[ps_weapon].SY = WEAPONBOTTOM;
	if (player.Powers[pw_weaponlevel2])
	{
		SetPsprite(player, ps_weapon, Weapon(player.ViewEnts[ps_weapon]).UpState2);
	}
	else
	{
		SetPsprite(player, ps_weapon, Weapon(player.ViewEnts[ps_weapon]).UpState);
	}
}

//===========================================================================
//
//  DropWeapon
//
//  The player died, so put the weapon away.
//
//===========================================================================

void DropWeapon(Player player)
{
	if (player.Powers[pw_weaponlevel2])
	{
		SetPsprite(player, ps_weapon, Weapon(player.ViewEnts[ps_weapon]).DownState2);
	}
	else
	{
		SetPsprite(player, ps_weapon, Weapon(player.ViewEnts[ps_weapon]).DownState);
	}
}

//===========================================================================
//
//  SetupPsprites
//
//  Called at start of level for each player
//
//===========================================================================

void SetupPsprites(Player player)
{
	int i;

	// Remove all  ViewEnts
	for (i = 0; i < NUMPSPRITES; i++)
	{
		player.ViewEnts[i].StateNum = 0;
	}
	// Spawn the ready weapon
	BringUpWeapon(player);
}

//===========================================================================
//
//  MovePsprites
//
//  Called every tic by player thinking routine
//
//===========================================================================

void MovePsprites(Player player)
{
	int i;
	ViewEntity e;

	for (i = 0; i < NUMPSPRITES; i++)
	{
		e = player.ViewEnts[i];
		if (e.StateNum)	// a null state means not active
		{
			// drop tic count and possibly change state
			if (e.StateTime != -1.0)	// a -1 tic count never changes
			{
				e.StateTime -= frametime;
				if (e.StateTime <= 0.0)
				{
					e.StateTime = 0.0;
					SetPsprite(player, i, e.NextState);
				}
			}
		}
	}
	player.ViewEnts[ps_flash].SX = player.ViewEnts[ps_weapon].SX;
	player.ViewEnts[ps_flash].SY = player.ViewEnts[ps_weapon].SY;
}

//===========================================================================
//
//  CheckAmmo
//
//  Returns true if there is enough ammo to shoot.  If not, selects the
// next weapon to use.
//
//===========================================================================

bool CheckAmmo(Player player)
{
	int ammo;
	int *ammoUse;
	int count;

	ammo = Weapon(player.ViewEnts[ps_weapon]).Ammo;
	if (player.Powers[pw_weaponlevel2] && !deathmatch)
	{
		ammoUse = &WeaponAmmoUsePL2[0];
	}
	else
	{
		ammoUse = &WeaponAmmoUsePL1[0];
	}
	count = ammoUse[player.ReadyWeapon];
	if (ammo == am_noammo || player.Ammo[ammo] >= count)
	{
		return true;
	}
	// out of ammo, pick a weapon to change to
	do
	{
		if (player.WeaponOwned[wp_skullrod]
			&& player.Ammo[am_skullrod] > ammoUse[wp_skullrod])
		{
			player.PendingWeapon = wp_skullrod;
		}
		else if (player.WeaponOwned[wp_blaster]
			&& player.Ammo[am_blaster] > ammoUse[wp_blaster])
		{
			player.PendingWeapon = wp_blaster;
		}
		else if (player.WeaponOwned[wp_crossbow]
			&& player.Ammo[am_crossbow] > ammoUse[wp_crossbow])
		{
			player.PendingWeapon = wp_crossbow;
		}
		else if (player.WeaponOwned[wp_mace]
			&& player.Ammo[am_mace] > ammoUse[wp_mace])
		{
			player.PendingWeapon = wp_mace;
		}
		else if (player.Ammo[am_goldwand] > ammoUse[wp_goldwand])
		{
			player.PendingWeapon = wp_goldwand;
		}
		else if (player.WeaponOwned[wp_gauntlets])
		{
			player.PendingWeapon = wp_gauntlets;
		}
		else if (player.WeaponOwned[wp_phoenixrod]
			&& player.Ammo[am_phoenixrod] > ammoUse[wp_phoenixrod])
		{
			player.PendingWeapon = wp_phoenixrod;
		}
		else
		{
			player.PendingWeapon = wp_staff;
		}
	}
	while (player.PendingWeapon == wp_nochange);
	if (player.Powers[pw_weaponlevel2])
	{
		SetPsprite(player, ps_weapon, Weapon(player.ViewEnts[ps_weapon]).DownState2);
	}
	else
	{
		SetPsprite(player, ps_weapon, Weapon(player.ViewEnts[ps_weapon]).DownState);
	}
	return false;
}

//===========================================================================
//
//  FireWeapon
//
//===========================================================================

void FireWeapon(Player player)
{
	int attackState;

	if (!CheckAmmo(player))
	{
		return;
	}
	player.MO.SetState(PlayerPawn(player.MO).Attack2State);
	if (player.Powers[pw_weaponlevel2])
	{
		attackState = player.Refire ?
			Weapon(player.ViewEnts[ps_weapon]).HoldAttackState2 :
			Weapon(player.ViewEnts[ps_weapon]).AttackState2;
	}
	else
	{
		attackState = player.Refire ?
			Weapon(player.ViewEnts[ps_weapon]).HoldAttackState :
			Weapon(player.ViewEnts[ps_weapon]).AttackState;
	}
	SetPsprite(player, ps_weapon, attackState);
	P_NoiseAlert(player.MO, player.MO);
	if (player.ReadyWeapon == wp_gauntlets && !player.Refire)
	{
		// Play the sound for the initial gauntlet attack
		player.MO.PlaySound('GauntletUse', CHAN_WEAPON);
	}
}

//===========================================================================
//
//  ActivateBeak
//
//===========================================================================

void ActivateBeak(Player player)
{
	SetWeapon(player, wp_beak);
	player.ViewEnts[ps_weapon].SY = WEAPONTOP;
	SetPsprite(player, ps_weapon,
		Weapon(player.ViewEnts[ps_weapon]).ReadyState);
}

//===========================================================================
//
//  PostChickenWeapon
//
//===========================================================================

void PostChickenWeapon(Player player, int weapon)
{
	if (weapon == wp_beak)
	{
		// Should never happen
		weapon = wp_staff;
	}
	SetWeapon(player, weapon);
	player.ViewEnts[ps_weapon].SY = WEAPONBOTTOM;
	SetPsprite(player, ps_weapon, Weapon(player.ViewEnts[ps_weapon]).UpState);
}

//===========================================================================
//
//  UpdateBeak
//
//===========================================================================

void UpdateBeak(Player player, ViewEntity e)
{
	e.SY = WEAPONTOP + itof(player.ChickenPeck) / 2.0;
}

//===========================================================================
//
//  WeaponLevel2Fade
//
//===========================================================================

void WeaponLevel2Fade(Player player)
{
	Weapon(player.ViewEnts[ps_weapon]).WeaponLevel2Fade();
}

//**************************************************************************
//
//  $Log$
//  Revision 1.5  2003/11/12 16:49:44  dj_jl
//  Changed player structure into a class
//
//  Revision 1.4  2002/10/26 16:32:24  dj_jl
//  New style of defining classes.
//
//  Revision 1.3  2002/09/07 16:28:25  dj_jl
//  Added Level class.
//
//  Revision 1.2  2002/07/23 13:07:30  dj_jl
//  Final touches for switching to floating-point time, beautification.
//
//  Revision 1.1  2002/06/22 07:16:01  dj_jl
//  Added base classes for objects, split them into corresponding files.
//
//**************************************************************************
