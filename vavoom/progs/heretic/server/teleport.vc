//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

float teleport_bbox[4];
Actor teleport_thing;
float teleport_x;
float teleport_y;

//==========================================================================
//
//  PIT_StompThing
//
//==========================================================================

boolean PIT_StompThing(Entity Other)
{
	float blockdist;

	if (!Actor(Other).bShootable)
	{
		return true;
	}

	blockdist = Other.Radius + teleport_thing.Radius;

	if (fabs(Other.Origin.x - teleport_x) >= blockdist ||
		fabs(Other.Origin.y - teleport_y) >= blockdist)
	{
		// didn't hit it
		return true;
	}

	// don't clip against self
	if (Other == teleport_thing)
	{
		return true;
	}

	//  Check if allowed to stomp things
	if (!teleport_thing.bTelestomp)
	{
		return false;
	}

	Actor(Other).Damage(teleport_thing, teleport_thing, 10000);

	return true;
}

//==========================================================================
//
//  Actor::TeleportMove
//
//==========================================================================

boolean Actor::TeleportMove(TVec newOrg)
{
	int xl;
	int xh;
	int yl;
	int yh;
	int bx;
	int by;

	// kill anything occupying the position
	teleport_thing = self;

	teleport_x = newOrg.x;
	teleport_y = newOrg.y;

	// stomp on any things contacted
	xl = MapBlock(newOrg.x - Radius - level->bmaporgx - MAXRADIUS);
	xh = MapBlock(newOrg.x + Radius - level->bmaporgx + MAXRADIUS);
	yl = MapBlock(newOrg.y - Radius - level->bmaporgy - MAXRADIUS);
	yh = MapBlock(newOrg.y + Radius - level->bmaporgy + MAXRADIUS);

	for (bx = xl; bx <= xh; bx++)
		for (by = yl; by <= yh; by++)
			if (!P_BlockThingsIterator(bx, by, 'PIT_StompThing'))
				return false;

	// the move is ok,
	// so link the thing into its new position
	UnlinkFromWorld();

	Origin = newOrg;

	LinkToWorld();

	return true;
}

//==========================================================================
//
//  Actor::Teleport
//
//==========================================================================

boolean Actor::Teleport(float x, float y, float angle)
{
	TVec oldOrg;
	float aboveFloor;
	float fogDelta;
	Actor fog;

	oldOrg = Origin;
	aboveFloor = Origin.z - FloorZ;
	if (!TeleportMove(vector(x, y, Origin.z)))
	{
		return false;
	}
	if (bIsPlayer)
	{
		if (Player->Powers[pw_flight] && aboveFloor)
		{
			Origin.z = FloorZ + aboveFloor;
			if (Origin.z + Height > CeilingZ)
			{
				Origin.z = CeilingZ - Height;
			}
			Player->ViewOrg.z = Origin.z + Player->ViewHeight;
		}
		else
		{
			Origin.z = FloorZ;
			Player->ViewOrg.z = Origin.z + Player->ViewHeight;
			Angles.pitch = 0.0;
		}
		Player->bFixAngle = true;
	}
	else if (bMissile)
	{
		Origin.z = FloorZ + aboveFloor;
		if (Origin.z + Height > CeilingZ)
		{
			Origin.z = CeilingZ - Height;
		}
	}
	else
	{
		Origin.z = FloorZ;
	}
	// Spawn teleport fog at source and destination
	fogDelta = bMissile ? 0.0 : TELEFOGHEIGHT;
	fog = Spawn(TeleportFog, oldOrg + vector(0.0, 0.0, fogDelta));
	fog.PlaySound('Teleport', CHAN_VOICE);
	fog = Spawn(TeleportFog, vector(x + 20.0 * cos(angle),
		y + 20.0 * sin(angle), Origin.z + fogDelta));
	fog.PlaySound('Teleport', CHAN_VOICE);
	if (bIsPlayer && !Player->Powers[pw_weaponlevel2])
	{
		// Freeze player for about .5 sec
		ReactionTime = 0.5;
	}
	Angles.yaw = angle;
	if (bFloorClip && GetFloorType() != FLOOR_SOLID)
	{
		FloorClip = FOOTCLIPSIZE;
	}
	else
	{
		FloorClip = 0.0;
	}
	if (bMissile)
	{
		Velocity.x = Speed * cos(angle);
		Velocity.y = Speed * sin(angle);
	}
	else
	{
		Velocity = vector(0.0, 0.0, 0.0);
	}
	return true;
}

//==========================================================================
//
//  EV_Teleport
//
//==========================================================================

boolean EV_Teleport(int tag, Actor thing, boolean usefog)
{
	int i;
	Actor m;

	if (thing.bNoTeleport)
	{
		return false;
	}
	FOREACH(Actor, m)
	{
		if (m.Class != TeleportSpot)
		{
			// Not a teleportman
			continue;
		}
		if (m.TID != tag)
		{
			// Wrong sector
			continue;
		}
		return thing.Teleport(m.Origin.x, m.Origin.y, m.Angles.yaw);
	}
	return false;
}

//==========================================================================
//
//	EV_SilentLineTeleport
//
// Silent linedef-based TELEPORTATION, by Lee Killough
// Primarily for rooms-over-rooms etc.
// This is the complete player-preserving kind of teleporter.
// It has advantages over the teleporter with thing exits.
//
// [RH] Modified to support different source and destination ids.
//
//==========================================================================

boolean EV_SilentLineTeleport(line_t *line, int side, Actor thing, int id,
							boolean reverse)
{
	int searcher;
	line_t *l;

	if (side || thing.bNoTeleport || !line)
	{
		return false;
	}

	searcher = -1;
	for (l = P_FindLine(id, &searcher); l; l = P_FindLine(id, &searcher))
	{
		TVec SrcXAxis;
		TVec SrcYAxis;
		TVec DstXAxis;
		TVec DstYAxis;
		TVec newPos;
		TVec TempV;
		TAVec TempA;
		float pos;
		float TempX;
		float TempY;
		float oldZ;

		if (l == line || !l->backsector)
		{
			continue;
		}

		// Get the thing's position along the source linedef
		SrcXAxis = Normalize(*line->v2 - *line->v1);
		SrcYAxis = -line->normal;
		pos = DotProduct(SrcXAxis, thing.Origin - *line->v1);
		oldZ = thing.Origin.z;

		// Interpolate position across the exit linedef
		if (reverse)
		{
			DstXAxis = Normalize(*l->v2 - *l->v1);
			DstYAxis = -l->normal;
			newPos = *l->v1 + pos * DstXAxis;
			newPos.z = thing.Origin.z - GetPlanePointZ(
				line->frontsector->botregion->floor, thing.Origin) +
				GetPlanePointZ(l->frontsector->botregion->floor, newPos);
		}
		else
		{
			DstXAxis = Normalize(*l->v1 - *l->v2);
			DstYAxis = l->normal;
			newPos = *l->v2 + pos * DstXAxis;
			newPos.z = thing.Origin.z - GetPlanePointZ(
				line->frontsector->botregion->floor, thing.Origin) +
				GetPlanePointZ(l->backsector->botregion->floor, newPos);
		}

		// Attempt to teleport, aborting if blocked
		if (!thing.TeleportMove(newPos))
		{
			return false;
		}

		// Rotate thing's orientation according to difference in linedef angles
		TempV.x = DotProduct(DstXAxis, SrcXAxis);
		TempV.y = DotProduct(DstYAxis, SrcXAxis);
		TempV.z = 0.0;
		VectorAngles(&TempV, &TempA);
		thing.Angles.yaw = AngleMod360(thing.Angles.yaw - TempA.yaw);

		// Rotate thing's momentum to come out of exit just like it entered
		TempX = DotProduct(thing.Velocity, SrcXAxis);
		TempY = DotProduct(thing.Velocity, SrcYAxis);
		thing.Velocity.x = TempX * DstXAxis.x + TempY * DstYAxis.x;
		thing.Velocity.y = TempX * DstXAxis.y + TempY * DstYAxis.y;

		// Adjust a player's view, in case there has been a height change
		if (thing.bIsPlayer)
		{
			thing.Player->ViewOrg.z += thing.Origin.z - oldZ;

			thing.Player->bFixAngle = true;
		}
		return true;
	}
	return false;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.26  2002/08/28 16:36:39  dj_jl
//  Merged MapObject with Entity, some natives, beautification.
//
//  Revision 1.25  2002/07/13 08:01:49  dj_jl
//  Moved some functions to the Entity class.
//
//  Revision 1.24  2002/04/11 16:52:15  dj_jl
//  Made TryMove native.
//
//  Revision 1.23  2002/03/20 19:07:47  dj_jl
//  Got rid of a lots of legacy, beautification.
//
//  Revision 1.22  2002/03/16 17:45:13  dj_jl
//  Added Pawn and PlayerPawn classes, beautification.
//
//  Revision 1.21  2002/03/09 17:57:02  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.20  2002/02/26 17:49:48  dj_jl
//  no message
//
//  Revision 1.19  2002/02/22 18:00:19  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.18  2002/02/16 16:21:48  dj_jl
//  Added line teleporters
//
//  Revision 1.17  2002/02/14 19:20:58  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.16  2002/02/09 18:15:42  dj_jl
//  Beautification
//
//  Revision 1.15  2002/02/06 17:28:52  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.14  2002/02/02 19:17:25  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.13  2002/01/28 18:50:18  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.12  2002/01/24 18:19:26  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.11  2002/01/17 18:15:53  dj_jl
//  Renamed all map object classes
//
//  Revision 1.10  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.9  2002/01/11 18:19:41  dj_jl
//  Started to use names in progs
//
//  Revision 1.8  2002/01/07 12:23:18  dj_jl
//  Changed copyright year
//
//  Revision 1.7  2001/12/27 17:52:23  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.6  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.5  2001/10/22 17:23:12  dj_jl
//  Floatification of angles
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
