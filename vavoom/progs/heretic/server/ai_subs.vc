//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

#define MAX_BOSS_SPOTS 8

int BossSpotCount;
TVec BossSpot[MAX_BOSS_SPOTS];
float BossSpot_angle[MAX_BOSS_SPOTS];

int opposite[] = {
	DI_WEST, DI_SOUTHWEST, DI_SOUTH, DI_SOUTHEAST, DI_EAST, DI_NORTHEAST,
	DI_NORTH, DI_NORTHWEST, DI_NODIR
};

int diags[] = { DI_NORTHWEST, DI_NORTHEAST, DI_SOUTHWEST, DI_SOUTHEAST };

//==========================================================================
//
//  InitMonsters
//
//  Called at level load.
//
//==========================================================================

void InitMonsters(void)
{
	BossSpotCount = 0;
}

//==========================================================================
//
//  P_AddBossSpot
//
//==========================================================================

void AddBossSpot(float x, float y, float angle)
{
	if (BossSpotCount == MAX_BOSS_SPOTS)
	{
		Error("Too many boss spots.");
	}
	BossSpot[BossSpotCount].x = x;
	BossSpot[BossSpotCount].y = y;
	BossSpot[BossSpotCount].z = 0.0;	//FIXME
	BossSpot_angle[BossSpotCount] = angle;
	BossSpotCount++;
}

//==========================================================================
//
//  DSparilTeleport
//
//==========================================================================

void DSparilTeleport(mobj_t * actor)
{
	int i;
	float x;
	float y;
	float prevX;
	float prevY;
	float prevZ;
	TVec dir;
	mobj_t *mo;

	if (!BossSpotCount)
	{	// No spots
		return;
	}
	i = P_Random();
	do
	{
		i++;
		x = BossSpot[i % BossSpotCount].x;
		y = BossSpot[i % BossSpotCount].y;
		dir = BossSpot[i % BossSpotCount] - actor->origin;
	}
	while (Length(dir) < 128.0);
	prevX = actor->origin.x;
	prevY = actor->origin.y;
	prevZ = actor->origin.z;
	if (P_TeleportMove(actor, x, y))
	{
		mo = P_SpawnMobj(prevX, prevY, prevZ, Sorcerer2TeleFade);
		StartSoundName(mo, 'Teleport', CHAN_VOICE);
		SetMobjState(actor, S_SOR2_TELE1);
		StartSoundName(actor, 'Teleport', CHAN_VOICE);
		actor->origin.z = actor->floorz;
		actor->angles.yaw = BossSpot_angle[i % BossSpotCount];
		actor->velocity.x = actor->velocity.y = actor->velocity.z = 0.0;
	}
}

//==========================================================================
//
//  P_CheckMeleeRange
//
//==========================================================================

int P_CheckMeleeRange(mobj_t * actor)
{
	mobj_t *mo;
	float dist;

	if (!actor->target)
	{
		return false;
	}
	mo = actor->target;
	dist = MobjDist(mo, actor);
	if (dist >= MELEERANGE)
	{
		return false;
	}
	if (!P_CheckSight(actor, mo))
	{
		return false;
	}
	return true;
}

//==========================================================================
//
//  P_CheckMissileRange
//
//==========================================================================

int P_CheckMissileRange(mobj_t * actor)
{
	float dist;

	if (!P_CheckSight(actor, actor->target))
	{
		return false;
	}
	if (actor->Flags & MF_JUSTHIT)
	{
		// The target just hit the enemy, so fight back!
		actor->Flags &= ~MF_JUSTHIT;
		return true;
	}
	if (actor->ReactionCount)
	{
		// Don't attack yet
		return false;
	}
	dist = MobjDist(actor, actor->target) - 64.0;
	if (!actor->MeleeState)
	{
		// No melee attack, so fire more frequently
		dist -= 128.0;
	}
	if (actor->Class == Imp)
	{
		// Imp's fly attack from far away
		dist /= 2.0;
	}
	if (dist > 200.0)
	{
		dist = 200.0;
	}
	if (Random() * 256.0 < dist)
	{
		return false;
	}
	return true;
}

//==========================================================================
//
//  UpdateChicken
//
//  Returns true if the chicken morphs.
//
//==========================================================================

int UpdateChicken(mobj_t * actor, int tics)
{
	mobj_t *fog;
	float x;
	float y;
	float z;
	classid moType;
	float angle;
	int flags;
	int health;
	mobj_t *target;
	mobj_t *mo;

	actor->special1 -= tics;
	if (actor->special1 > 0)
	{
		return false;
	}
	moType = actor->specialcid;
	x = actor->origin.x;
	y = actor->origin.y;
	z = actor->origin.z;
	angle = actor->angles.yaw;
	flags = actor->Flags;
	health = actor->Health;
	target = actor->target;
	SetMobjState(actor, S_FREETARGMOBJ);
	mo = P_SpawnMobj(x, y, z, moType);
	if (P_TestMobjLocation(mo) == false)
	{
		// Didn't fit
		P_RemoveMobj(mo);
		mo = P_SpawnMobj(x, y, z, Chicken);
		mo->angles.yaw = angle;
		mo->Flags = flags;
		mo->Health = health;
		mo->target = target;
		mo->special1 = 5 * 35;	// Next try in 5 seconds
		mo->specialcid = moType;
		return false;
	}
	mo->angles.yaw = angle;
	mo->target = target;
	fog = P_SpawnMobj(x, y, z + TELEFOGHEIGHT, TeleportFog);
	StartSoundName(fog, 'Teleport', CHAN_VOICE);
	return true;
}

//==========================================================================
//
//  P_Massacre
//
//  Kills all monsters.
//
//==========================================================================

void P_Massacre(void)
{
	mobj_t *mo;

	for (mo = NextMobj(NULL); mo; mo = NextMobj(mo))
	{
		if ((mo->Flags & MF_COUNTKILL) && (mo->Health > 0))
		{
			mo->Damage(NULL, NULL, 10000);
		}
	}
}

//==========================================================================
//
//  P_LookForMonsters
//
//==========================================================================

#define MONS_LOOK_RANGE (20.0 * 64.0)
#define MONS_LOOK_LIMIT 64

boolean P_LookForMonsters(mobj_t * actor)
{
	int count;
	mobj_t *mo;

	if (!P_CheckSight(players[0].mo, actor))
	{	// Player can't see monster
		return false;
	}
	count = 0;
	for (mo = NextMobj(NULL); mo; mo = NextMobj(mo))
	{
		if (!(mo->Flags & MF_COUNTKILL) || (mo == actor) || (mo->Health <= 0))
		{	// Not a valid monster
			continue;
		}
		if (MobjDist(actor, mo) > MONS_LOOK_RANGE)
		{	// Out of range
			continue;
		}
		if (P_Random() < 16)
		{	// Skip
			continue;
		}
		if (count++ > MONS_LOOK_LIMIT)
		{	// Stop searching
			return (false);
		}
		if (!P_CheckSight(actor, mo))
		{	// Out of sight
			continue;
		}
		// Found a target monster
		actor->target = mo;
		return true;
	}
	return false;
}

//==========================================================================
//
//  P_LookForPlayers
//
//  If allaround is false, only look 180 degrees in front
//  returns true if a player is targeted
//
//==========================================================================

boolean P_LookForPlayers(mobj_t * actor, boolean allaround)
{
	int c;
	int stop;
	player_t *player;
	sector_t *sector;
	float an;
	float dist;

	if (!netgame && players[0].spawned && players[0].health <= 0)
	{	// Single player game and player is dead, look for monsters
		return P_LookForMonsters(actor);
	}
	sector = actor->subsector->sector;
	c = 0;
	stop = (actor->lastlook - 1) & 3;
	for (;; actor->lastlook = (actor->lastlook + 1) & (MAXPLAYERS - 1))
	{
		if (actor->lastlook == stop)
			return false;	// done looking

		if (!players[actor->lastlook].active)
			continue;

		if (c++ == 2)
			return false;	// done looking

		player = &players[actor->lastlook];
		if (!player->spawned || !player->mo)
			continue;	// not spawned yet
		if (player->health <= 0)
			continue;	// dead
		if (!P_CheckSight(actor, player->mo))
			continue;	// out of sight

		if (!allaround)
		{
			an = AngleMod360(atan2(player->mo->origin.y - actor->origin.y,
				player->mo->origin.x - actor->origin.x) - actor->angles.yaw);
			if (an > 90.0 && an < 270.0)
			{
				dist = MobjDist(player->mo, actor);
				// if real close, react anyway
				if (dist > MELEERANGE)
					continue;	// behind back
			}
		}
		if (player->mo->Translucency)
		{
			// Player is invisible
			if ((MobjDist(player->mo, actor) > 2.0 * MELEERANGE) &&
				Length(player->mo->velocity) < 5.0 * 35.0)
			{
				// Player is sneaking - can't detect
				return (false);
			}
			if (P_Random() < 225)
			{
				// Player isn't sneaking, but still didn't detect
				return (false);
			}
		}
		actor->target = player->mo;
		return true;
	}
	return false;
}

//==========================================================================
//
//  P_TryWalk
//
//  Attempts to move actor in its current (ob->moveangle) direction.
//  If blocked by either a wall or an actor returns FALSE.
//  If move is either clear of block only by a door, returns TRUE and sets.
//  If a door is in the way, an OpenDoor call is made to start it opening.
//
//==========================================================================

boolean P_TryWalk(mobj_t * actor)
{
	if (!P_Move(actor))
	{
		return false;
	}
	actor->movecount = P_Random() & 15;
	return true;
}

//==========================================================================
//
//  P_NewChaseDir
//
//==========================================================================

void P_NewChaseDir(mobj_t * actor)
{
	float deltax, deltay;
	int d[3];
	int tdir, olddir, turnaround;

	if (!actor->target)
		Error("P_NewChaseDir: called with no target");

	olddir = actor->movedir;
	turnaround = opposite[olddir];

	deltax = actor->target->origin.x - actor->origin.x;
	deltay = actor->target->origin.y - actor->origin.y;
	if (deltax > 10.0)
		d[1] = DI_EAST;
	else if (deltax < -10.0)
		d[1] = DI_WEST;
	else
		d[1] = DI_NODIR;
	if (deltay < -10.0)
		d[2] = DI_SOUTH;
	else if (deltay > 10.0)
		d[2] = DI_NORTH;
	else
		d[2] = DI_NODIR;

	// try direct route
	if (d[1] != DI_NODIR && d[2] != DI_NODIR)
	{
		actor->movedir = diags[((deltay < 0.0) << 1) + (deltax > 0.0)];
		if (actor->movedir != turnaround && P_TryWalk(actor))
			return;
	}

	// try other directions
	if (P_Random() > 200 || fabs(deltay) > fabs(deltax))
	{
		tdir = d[1];
		d[1] = d[2];
		d[2] = tdir;
	}

	if (d[1] == turnaround)
		d[1] = DI_NODIR;
	if (d[2] == turnaround)
		d[2] = DI_NODIR;

	if (d[1] != DI_NODIR)
	{
		actor->movedir = d[1];
		if (P_TryWalk(actor))
			return;	/*either moved forward or attacked */
	}

	if (d[2] != DI_NODIR)
	{
		actor->movedir = d[2];
		if (P_TryWalk(actor))
			return;
	}

	/* there is no direct path to the player, so pick another direction */

	if (olddir != DI_NODIR)
	{
		actor->movedir = olddir;
		if (P_TryWalk(actor))
			return;
	}

	if (P_Random() & 1)	/*randomly determine direction of search */
	{
		for (tdir = DI_EAST; tdir <= DI_SOUTHEAST; tdir++)
		{
			if (tdir != turnaround)
			{
				actor->movedir = tdir;
				if (P_TryWalk(actor))
					return;
			}
		}
	}
	else
	{
		for (tdir = DI_SOUTHEAST; tdir >= DI_EAST; tdir--)
		{
			if (tdir != turnaround)
			{
				actor->movedir = tdir;
				if (P_TryWalk(actor))
					return;
			}
		}
	}

	if (turnaround != DI_NODIR)
	{
		actor->movedir = turnaround;
		if (P_TryWalk(actor))
			return;
	}

	actor->movedir = DI_NODIR;	// can't move
}

//**************************************************************************
//
//  $Log$
//  Revision 1.12  2002/01/17 18:15:53  dj_jl
//  Renamed all map object classes
//
//  Revision 1.11  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.10  2002/01/11 18:19:41  dj_jl
//  Started to use names in progs
//
//  Revision 1.9  2002/01/07 12:23:17  dj_jl
//  Changed copyright year
//
//  Revision 1.8  2001/12/27 17:52:22  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.7  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.6  2001/10/22 17:23:12  dj_jl
//  Floatification of angles
//
//  Revision 1.5  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.4  2001/08/31 17:17:23  dj_jl
//  Removed vector macros
//  
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
