//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ı
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class Actor : Entity
	abstract;

const float FOOTCLIPSIZE	= 10.0;
const float TELEFOGHEIGHT 	= 32.0;

const int BASETHRESHOLD		= 100;	// follow a player exlusively for 3 seconds

const float ONFLOORZ		= -99999.0;
const float ONCEILINGZ		= 99999.0;
const float FLOATRANDZ		= 99998.0;

const float MELEERANGE		= 64.0;
const float MISSILERANGE	= (32.0 * 64.0);

const float FLOATSPEED		= 140.0;

const float MAXMOVE			= 1050.0;
const float STOPSPEED		= 2.1875;

const float FRICTION_NORMAL	= 3.28125;
const float FRICTION_LOW	= 0.95703125;
const float FRICTION_FLY	= 2.87109375;
const float FRICTION_WATER	= 3.0;

const float BONUSADD		= 0.2;

const float MONS_LOOK_RANGE	= (20.0 * 64.0);
const int MONS_LOOK_LIMIT	= 64;

//  States
state IdleState;
state SeeState;
state PainState;
state MeleeState;
state MissileState;
state CrashState;
state DeathState;
state GibsDeathState;

//  Sounds
name SightSound;
name ActiveSound;
name AttackSound;
name PainSound;
name DeathSound;

//	FLAGS
bool bSpecial;		// call P_SpecialThing when touched
bool bShootable;	// Can be hit.
bool bAmbush;		// Ambush
bool bJustHit;		// try to attack right back
bool bJustAttacked;	// take at least one step before attacking
bool bSpawnCeiling;	// hang from ceiling instead of floor
//	MOVEMENT FLAGS
bool bPickUp;		// for players to pick up items
bool bMissile;		// don't hit same species, explode on block
bool bDropped;		// dropped by a demon, not level spawned
bool bNoBlood;		// don't bleed when shot (use puff)
bool bCorpse;		// don't stop moving halfway off a step
bool bInFloat;		// floating to a height for a move, don't
			// auto float to target's height
bool bSkullFly;		// skull in flight
bool bCountKill;	// count towards intermission kill total
bool bCountItem;	// count towards intermission item total
bool bWindThrust;	// gets pushed around by the wind specials
bool bFloorBounce;	// bounces off the floor
bool bThruGhost;	// missile will pass through ghosts
bool bSpawnFloat;	// spawn random float z
bool bNoTeleport;	// does not teleport
bool bRip;		// missile rips through solid targets
bool bPushable;		// can be pushed by other moving mobjs
bool bSlide;		// slides against walls
bool bCannotPush;	// cannot push other pushable mobjs
bool bBoss;		// mobj is a major boss
bool bFireDamage;	// does fire damage
bool bNoDamageThrust;	// does not thrust target when damaging
bool bTelestomp;	// mobj can stomp another
bool bFloatBob;		// use float bobbing z movement
bool bActivateImpact;	// an MF_MISSILE mobj can activate
			// SPAC_IMPACT
bool bActivatePushWall;	// mobj can push walls
bool bActivateMCross;	// can activate monster cross lines
bool bActivatePCross;	// can activate projectile cross lines
bool bDormant;		// thing is dormant
bool bWaterJump;
bool bBlaster;
bool bNoMorph;		// Don't morph into chicken.
bool bStaticLight;	// Static light source.

//  Params
float Speed;
float StepSpeed;
float PainChance;
int SpawnHealth;
int GibsHealth;

// Thing being chased/attacked (or NULL).
Actor Enemy;
// The originator for missiles.
Actor Instigator;

int Special1;	// Special info
float Special1f;
classid SpecialCID;

int MissileDamage;	// For missiles

// Player number last looked for.
int LastLook;

// For nightmare respawn.
mthing_t SpawnSpot;

// Reaction time: if non 0, don't attack yet.
int ReactionCount;
// Used by player to freeze a bit after teleporting.
float ReactionTime;

// If >0, the target will be chased
// no matter what (even if shot)
int Threshold;

// Movement direction, movement generation (zig-zagging).
int MoveDir;	// 0-7
int MoveCount;	// when 0, select a new dir

float bombdamage;

float teleport_x;
float teleport_y;

// Height if not aiming up or down
// ???: use slope for monsters?
float aim_z;
float aim_range;
float aim_slope;
TVec aim_dir;
float aim_topslope;
float aim_bottomslope;	// slopes to top and bottom of target
Actor linetarget;	// who got hit (or NULL)
float aim_range2d;

float shoot_range;
TVec shoot_origin;
TVec shoot_dir;
int la_damage;
TVec shoot_linestart;
TVec shoot_lineend;
classid shootPuffType;

// Static light parameters.
TVec LightOffset;
int LightColour;
float LightRadius;
int ExplodeEffect;

//===========================================================================
//
//  Spawn
//
//===========================================================================

Actor Spawn(classid type, TVec AOrigin)
{
	Actor A;

	A = Actor(NewMobjThinker(type));

	A.Origin = AOrigin;
	A.OnMapSpawn(NULL);
	return A;
}

//==========================================================================
//
//  HITDICE
//
//  Most damage in HERETIC and HEXEN defined using HITDICE
//
//==========================================================================

int HITDICE(int a)
{
	return (1 + (P_Random() & 7)) * a;
}

//===========================================================================
//
//  GetFloorType
//
//===========================================================================

int GetFloorType()
{
	return TerrainType(Floor->pic);
}

//==========================================================================
//
//  SetOrigin2
//
//==========================================================================

void SetOrigin2(TVec origin)
{
	float space;

	Origin = origin;
	// Set subsector and/or block links.
	LinkToWorld();
	if (origin.z == ONFLOORZ)
	{
		Origin.z = FloorZ;
	}
	else if (origin.z == ONCEILINGZ)
	{
		Origin.z = CeilingZ - Height;
	}
	else if (origin.z == FLOATRANDZ)
	{
		space = CeilingZ - Height - FloorZ;
		if (space > 48.0)
		{
			space -= 40.0;
			Origin.z = space * Random() + FloorZ + 40.0;
		}
		else
		{
			Origin.z = FloorZ;
		}
	}
	else if (bFloatBob)
	{
		origin.z = FloorZ + origin.z;	// artifact z passed in as height
	}
	if (bFloorClip && GetFloorType() != FLOOR_SOLID &&
		FloorZ == Sector->floorheight)
	{
		FloorClip = FOOTCLIPSIZE;
	}
	else
	{
		FloorClip = 0.0;
	}
}

//==========================================================================
//
//	OnMapSpawn
//
//==========================================================================

void OnMapSpawn(mthing_t * mthing)
{
	SpawnHealth = Health;
	if (Level.Game.gameskill == sk_nightmare)
	{
		ReactionCount = 0;
	}

	LastLook = P_Random() % MAXPLAYERS;

	// Set the state, but do not use P_SetMobjState, because action
	// routines can't be called yet.  If the spawnstate has an action
	// routine, it will not be called.
	SetInitialState(IdleState);

	if (mthing)
	{
		float x, y, z;

		x = mthing->x;
		y = mthing->y;
		if (bSpawnCeiling)
		{
			z = ONCEILINGZ;
		}
		else if (bSpawnFloat)
		{
			z = FLOATRANDZ;
		}
		else if (bFloatBob)
		{
			z = mthing->height;
		}
		else
		{
			z = ONFLOORZ;
		}
		SetOrigin2(vector(x, y, z));
		if (bFloatBob)
		{
			// Seed random starting index for bobbing motion
			Health = P_Random();
			Special1f = mthing->height;
		}
		if (z == ONFLOORZ)
		{
			Origin.z += mthing->height;
		}
		else if (z == ONCEILINGZ)
		{
			Origin.z -= mthing->height;
		}
		LinkToWorld();
		TID = mthing->tid;
		Special = mthing->special;
		Args[0] = mthing->arg1;
		Args[1] = mthing->arg2;
		Args[2] = mthing->arg3;
		Args[3] = mthing->arg4;
		Args[4] = mthing->arg5;
		if (StateTime > 0.0)
		{
			StateTime = 0.1 + Random() * StateTime;
		}
		if (bCountKill)
		{
			Level.Game.level->totalkills++;
			Level.CopyMThing(mthing, &SpawnSpot);
		}
		if (bCountItem)
		{
			Level.Game.level->totalitems++;
		}
		Angles.yaw = itof(45 * (mthing->angle / 45));
		if (mthing->options & HereticLevelInfo::MTF_AMBUSH)
		{
			bAmbush = true;
		}
		if (mthing->options & HereticLevelInfo::MTF_DORMANT)
		{
			bDormant = true;
			StateTime = -1.0;
		}
	}
	else
	{
		SetOrigin2(Origin);
	}

	if (bStaticLight && mthing && !TID)
	{
		if (LightColour == 0xffffffff)
		{
			Level.AddStaticLight(Origin + LightOffset, mthing->arg1 ?
				itof(mthing->arg1) * 8.0 : LightRadius);
		}
		else
		{
			Level.AddStaticLightRGB(Origin + LightOffset, mthing->arg1 ?
				itof(mthing->arg1) * 8.0 : LightRadius, LightColour);
		}
	}
}

//===========================================================================
//
//  FaceActor
//
//  Returns 1 if 'source' needs to turn clockwise, or 0 if 'source' needs
// to turn counter clockwise.  'delta' is set to the amount 'source'
// needs to turn.
//
//===========================================================================

int FaceActor(Actor Other, float * delta)
{
	float diff;
	float angle1;
	float angle2;

	angle1 = Angles.yaw;
	angle2 = atan2(Other.Origin.y - Origin.y, Other.Origin.x - Origin.x);
	if (angle2 > angle1)
	{
		diff = AngleMod360(angle2 - angle1);
		if (diff > 180.0)
		{
			*delta = 360.0 - diff;
			return 0;
		}
		else
		{
			*delta = diff;
			return 1;
		}
	}
	else
	{
		diff = AngleMod360(angle1 - angle2);
		if (diff > 180.0)
		{
			*delta = 360.0 - diff;
			return 1;
		}
		else
		{
			*delta = diff;
			return 0;
		}
	}
}

//===========================================================================
//
//  ExplodeMissile
//
//===========================================================================

void ExplodeMissile()
{
	Velocity = vector(0.0, 0.0, 0.0);
	SetState(DeathState);
	//tics -= P_Random()&3;
	bMissile = false;
	if (DeathSound)
	{
		PlaySound(DeathSound, CHAN_VOICE);
	}
	if (Effects & HereticDefs::EF_DLIGHT_MASK)
	{
		MSG_Select(MSG_SV_DATAGRAM);
		if (MSG_CheckSpace(8))
		{
			MSG_WriteByte(HereticDefs::svc_explosion);
			MSG_WriteByte(Effects & HereticDefs::EF_DLIGHT_MASK);
			MSG_WriteShort(ftoi(Origin.x));
			MSG_WriteShort(ftoi(Origin.y));
			MSG_WriteShort(ftoi(Origin.z));
		}
		Effects &= ~HereticDefs::EF_DLIGHT_MASK;
	}
}

//==========================================================================
//
//  Kill
//
//==========================================================================

void Kill(Actor source)
{
	bShootable = false;
	bNoGravity = false;
	bFloat = false;
	bSkullFly = false;
	bDropOff = true;
	bCorpse = true;
	bNoPassMobj = true;
	Height /= 4.0;
	if (bCountKill && Special)
	{
		// Initiate monster death actions
		Level.ExecuteActionSpecial(Special, Args[0], Args[1], Args[2],
			Args[3], Args[4], NULL, 0, self);
	}
	if (source && source.bIsPlayer)
	{
		if (bCountKill)
		{
			// Count for intermission
			source.Player.KillCount++;
		}
		if (bIsPlayer)
		{
			if (source.Player.bIsBot)
			{
				Player(source.Player).Bot.Killed(self);
			}

			if (Player.bIsBot)
			{
				Player(Player).Bot.Died(source);
			}

			// Frag stuff
			if (self == source)
			{
				// Self-frag
				Player.FragsStats[P_GetPlayerNum(Player)]--;
				Player.Frags--;
			}
			else
			{
				source.Player.FragsStats[P_GetPlayerNum(Player)]++;
				source.Player.Frags++;
				source.PlaySound('misc/frag', CHAN_ITEM);
				if (Player(source.Player).ChickenTime)
				{
					// Make a super chicken
					Player(source.Player).GivePower(pw_weaponlevel2);
				}
			}
		}
	}
	else if (!Level.Game.netgame && bCountKill)
	{
		// Count all monster deaths
		Level.Game.Players[0].KillCount++;
	}
	if (bCountKill)
		Level.Game.level->currentkills++;
	if (bIsPlayer)
	{
		if (!source)
		{
			// Self-frag
			Player.FragsStats[P_GetPlayerNum(Player)]--;
			Player.Frags--;
		}
		bSolid = false;
		bFly = false;
		Player(Player).Powers[pw_flight] = 0.0;
		Player(Player).Powers[pw_weaponlevel2] = 0.0;
		Player.PlayerState = PST_DEAD;
		Player(Player).DropWeapon();
		if (bFireDamage)
		{
			// Player flame death
			SetState(PlayerPawn(self).FireDeathState);
			return;
		}
	}
	if (Health < GibsHealth && GibsDeathState)
	{
		// Extreme death
		SetState(GibsDeathState);
	}
	else
	{
		// Normal death
		SetState(DeathState);
	}
	StateTime -= Random() * 0.1;
}

//==========================================================================
//
//  MinotaurSlam
//
//==========================================================================

void MinotaurSlam(Actor Other)
{
	float angle;
	float thrust;

	angle = atan2(Other.Origin.y - Origin.y, Other.Origin.x - Origin.x);
	thrust = 16.0 + Random() * 4.0;
	Other.Velocity.x += thrust * cos(angle) * 35.0;
	Other.Velocity.y += thrust * sin(angle) * 35.0;
	Other.Damage(none, none, HITDICE(6));
	if (Other.Player)
	{
		Other.ReactionTime = 0.4 + Random() * 0.2;
	}
}

//==========================================================================
//
//  TouchWhirlwind
//
//==========================================================================

void TouchWhirlwind(Actor Other)
{
	float randVal;

	Other.Angles.yaw = AngleMod360(Other.Angles.yaw +
		(Random() - Random()) * 45.0 / 2.0);
	Other.Velocity.x += (Random() - Random()) * 4.0 * 35.0;
	Other.Velocity.y += (Random() - Random()) * 4.0 * 35.0;
	if (Level.Game.level->tictime & 16 && !Other.bBoss)
	{
		randVal = Random() * 4.0;
		if (randVal > 2.5)
		{
			randVal = 2.5;
		}
		Other.Velocity.z += randVal * 35.0;
		if (Other.Velocity.z > 12.0 * 35.0)
		{
			Other.Velocity.z = 12.0 * 35.0;
		}
	}
	if (!(Level.Game.level->tictime & 7))
	{
		Other.Damage(none, none, 3);
	}
}

//==========================================================================
//
//  ChickenMorphPlayer
//
//  Returns true if the player gets turned into a chicken.
//
//==========================================================================

bool ChickenMorphPlayer()
{
	Actor fog;
	Actor chicken;

	if (Player(Player).ChickenTime)
	{
		if ((Player(Player).ChickenTime < Player::CHICKENTIME - 1.0) &&
			!Player(Player).Powers[pw_weaponlevel2])
		{
			// Make a super chicken
			Player(Player).GivePower(pw_weaponlevel2);
		}
		return false;
	}
	if (Player(Player).Powers[pw_invulnerability])
	{
		// Immune when invulnerable
		return false;
	}

	fog = Spawn(TeleportFog, Origin + vector(0.0, 0.0, TELEFOGHEIGHT));
	fog.PlaySound('misc/teleport', CHAN_VOICE);

	chicken = Spawn(ChickenPlayer, Origin);
	chicken.Special1 = Player(Player).ReadyWeapon;
	chicken.Angles.yaw = Angles.yaw;
	chicken.Player = Player;
	chicken.bIsPlayer = true;
	chicken.Health = Player::MAXCHICKENHEALTH;
	Player.Health = chicken.Health;
	Player.MO = chicken;
	Player(Player).ArmorPoints = 0;
	Player(Player).ArmorType = 0;
	Player(Player).Powers[pw_invisibility] = 0.0;
	Player(Player).Powers[pw_weaponlevel2] = 0.0;
	chicken.bFly = bFly;
	Player(Player).ChickenTime = Player::CHICKENTIME;
	Player(Player).ActivateBeak();

	SetState(S_FREETARGMOBJ);

	return true;
}

//==========================================================================
//
//  ChickenMorph
//
//==========================================================================

bool ChickenMorph()
{
	Actor fog;
	Actor chicken;
	int i;

	if (bIsPlayer)
	{
		return false;
	}
	if (bNoMorph)
	{
		return false;
	}

	fog = Spawn(TeleportFog, Origin + vector(0.0, 0.0, TELEFOGHEIGHT));
	fog.PlaySound('misc/teleport', CHAN_VOICE);

	chicken = Spawn(Chicken, Origin);
	chicken.SpecialCID = Class;
	chicken.Special1 = ftoi(Player::CHICKENTIME * 35.0) + P_Random();
	chicken.Translucency = Translucency;
	chicken.Enemy = Enemy;
	chicken.Angles.yaw = Angles.yaw;
	chicken.TID = TID;
	chicken.Special = Special;
	chicken.InsertIntoTIDList(TID);
	for (i = 0; i < 5; i++)
	{
		chicken.Args[i] = Args[i];
	}

	RemoveFromTIDList();

	SetState(S_FREETARGMOBJ);

	return true;
}

//==========================================================================
//
//  AutoUseChaosDevice
//
//==========================================================================

bool AutoUseChaosDevice()
{
	int i;

	for (i = 0; i < Player(Player).InventorySlotNum; i++)
	{
		if (Player(Player).Inventory[i].type == HereticDefs::arti_teleport)
		{
			Player(Player).PlayerUseArtifact(HereticDefs::arti_teleport);
			Health = (Health + 1) / 2;
			Player.Health = Health;
			return true;
		}
	}
	return false;
}

//==========================================================================
//
//  AutoUseHealth
//
//==========================================================================

void AutoUseHealth(int saveHealth)
{
	int i;
	int count;
	int normalCount;
	int normalSlot;
	int superCount;
	int superSlot;

	normalCount = 0;
	superCount = 0;
	for (i = 0; i < Player(Player).InventorySlotNum; i++)
	{
		if (Player(Player).Inventory[i].type == HereticDefs::arti_health)
		{
			normalSlot = i;
			normalCount = Player(Player).Inventory[i].count;
		}
		else if (Player(Player).Inventory[i].type == HereticDefs::arti_superhealth)
		{
			superSlot = i;
			superCount = Player(Player).Inventory[i].count;
		}
	}
	if ((Level.Game.gameskill == sk_baby) && (normalCount * 25 >= saveHealth))
	{
		// Use quartz flasks
		count = (saveHealth + 24) / 25;
		for (i = 0; i < count; i++)
		{
			Health += 25;
			Player(Player).PlayerRemoveArtifact(normalSlot);
		}
	}
	else if (superCount * 100 >= saveHealth)
	{
		// Use mystic urns
		count = (saveHealth + 99) / 100;
		for (i = 0; i < count; i++)
		{
			Health += 100;
			Player(Player).PlayerRemoveArtifact(superSlot);
		}
	}
	else if ((Level.Game.gameskill == sk_baby)
		&& (superCount * 100 + normalCount * 25 >= saveHealth))
	{
		// Use mystic urns and quartz flasks
		count = (saveHealth + 24) / 25;
		saveHealth -= count * 25;
		for (i = 0; i < count; i++)
		{
			Health += 25;
			Player(Player).PlayerRemoveArtifact(normalSlot);
		}
		count = (saveHealth + 99) / 100;
		for (i = 0; i < count; i++)
		{
			Health += 100;
			//  I found a bug. There must be used superSlot, not normalSlot.
			//  Also if player used all quartz flasks, superSlot may be
			// invalid, so it must be found again.
			Player(Player).PlayerRemoveArtifact(superSlot);
		}
	}
	Player.Health = Health;
}

//==========================================================================
//
//  Damage
//
//  Damages both enemies and players.
//  inflictor is the thing that caused the damage creature or missile, can
// be NULL (slime, etc)
//  source is the thing to target after taking damage creature or NULL
//  Source and inflictor are the same for melee attacks
//  source can be null for barrel explosions and other environmental stuff
//
//==========================================================================

void Damage(Actor inflictor, Actor source, int damage)
{
	int saved;

	if (!bShootable)
	{
		// Shouldn't happen
		return;
	}
	if (Health <= 0)
	{
		return;
	}
	if (bSkullFly)
	{
		if (Class == Minotaur)
		{
			// Minotaur is invulnerable during charge attack
			return;
		}
		Velocity = vector(0.0, 0.0, 0.0);
	}
	if (bDormant)
	{
		// Invulnerable, and won't wake up
		return;
	}
	if (bIsPlayer && Level.Game.gameskill == sk_baby)
	{
		// Take half damage in trainer mode
		damage >>= 1;
	}
	// Special damage types
	if (inflictor)
	{
		if (inflictor.Class == EggMissile)
		{
			if (bIsPlayer)
			{
				ChickenMorphPlayer();
			}
			else
			{
				ChickenMorph();
			}
			return;	// Always return
		}
		else if (inflictor.Class == WhirlWind)
		{
			inflictor.TouchWhirlwind(self);
			return;
		}
		else if (inflictor.Class == Minotaur)
		{
			if (inflictor.bSkullFly)
			{
				// Slam only when in charge mode
				inflictor.MinotaurSlam(self);
				return;
			}
		}
		else if (inflictor.Class == MaceFX4)	// Death ball
		{
			if (bBoss || Class == Head)
			{
				// Don't allow cheap boss kills
			}
			else if (bIsPlayer)
			{
				// Player specific checks
				if (Player(Player).Powers[pw_invulnerability])
				{
					// Can't hurt invulnerable players
				}
				else if (AutoUseChaosDevice())
				{
					// Player was saved using chaos device
					return;
				}
				else
					damage = 10000;	// Something's gonna die
			}
			else
				damage = 10000;	// Something's gonna die
		}
		else if (inflictor.Class == PhoenixFX2)
		{
			// Flame thrower
			if (Player && P_Random() < 128)
			{
				// Freeze player for a bit
				ReactionTime += 0.125;
			}
		}
		else if (inflictor.Class == RainPlayer1 ||	// Rain missiles
			inflictor.Class == RainPlayer2 ||
			inflictor.Class == RainPlayer3 ||
			inflictor.Class == RainPlayer4)
		{
			if (bBoss)
			{
				// Decrease damage for bosses
				damage = (P_Random() & 7) + 1;
			}
		}
		else if (inflictor.Class == HornRodMissile2 ||
			inflictor.Class == PhoenixFX1)
		{
			if (Class == Sorcerer2 && P_Random() < 96)
			{
				// D'Sparil teleports away
				Sorcerer2(self).DSparilTeleport();
				return;
			}
		}
		else if (inflictor.Class == BlasterFX1 ||
			inflictor.Class == Ripper)
		{
			if (Class == Head)
			{
				// Less damage to Ironlich bosses
				damage = P_Random() & 1;
				if (!damage)
				{
					return;
				}
			}
		}
	}
	// Push the target unless source is using the gauntlets
	if (inflictor && (!source || !source.bIsPlayer ||
			Player(source.Player).ReadyWeapon != wp_gauntlets) &&
			!inflictor.bNoDamageThrust)
	{
		TVec dir;
		float thrust;

		if (source && source.bIsPlayer && (source == inflictor)
			&& Player(source.Player).Powers[pw_weaponlevel2]
			&& Player(source.Player).ReadyWeapon == wp_staff)
		{
			// Staff power level 2
			thrust = 350.0;
		}
		else
		{
			thrust = itof(damage) / Mass * 656.25;
		}

		dir = MobjCenter(self) - MobjCenter(inflictor);
		if (bNoGravity)
		{
			dir.z = 0.0;
		}
		Velocity += Normalise(dir) * thrust;
	}

	//
	// player specific
	//
	if (bIsPlayer)
	{
		//	End of game hell hack.
		if ((Sector->special & SECSPEC_BASE_MASK) ==
			SECSPEC_DamageSuperHellslimeExit && damage >= Health)
		{
			damage = Health - 1;
		}

		if (damage < 1000 && ((Player(Player).Cheats & Player::CF_GODMODE) ||
			Player(Player).Powers[pw_invulnerability]))
		{
			return;
		}
		if (Player(Player).ArmorType)
		{
			if (Player(Player).ArmorType == 1)
			{
				saved = damage >> 1;
			}
			else
			{
				saved = (damage >> 1) + (damage >> 2);
			}
			if (Player(Player).ArmorPoints <= saved)
			{
				// armor is used up
				saved = Player(Player).ArmorPoints;
				Player(Player).ArmorType = 0;
			}
			Player(Player).ArmorPoints -= saved;
			damage -= saved;
		}
		if (damage >= Player.Health && ((Level.Game.gameskill == sk_baby) ||
			Level.Game.deathmatch) && !Player(Player).ChickenTime)
		{
			// Try to use some inventory health
			AutoUseHealth(damage - Health + 1);
		}
		Player.Health -= damage;	// mirror mobj health here for Dave
		if (Player.Health < 0)
		{
			Player.Health = 0;
		}
		Player(Player).Attacker = source;
		Player(Player).DamageFlash += itof(damage) / 35.0;	// add damage after armor / invuln
		if (Player(Player).DamageFlash > 3.0)
		{
			Player(Player).DamageFlash = 3.0;	// teleport stomp does 10k points...
		}
	}

	//
	// do the damage
	//
	Health -= damage;
	if (Health <= 0)
	{
		// Death
		Special1 = damage;
		if (Class == Pod && source && source.Class != Pod)
		{
			// Make sure players get frags for chain-reaction kills
			Instigator = source;
		}
		if (bIsPlayer && inflictor && !Player(Player).ChickenTime)
		{
			// Check for flame death
			if (inflictor.bFireDamage
				|| ((inflictor.Class == PhoenixFX1)
					&& (Health > -50) && (damage > 25)))
			{
				bFireDamage = true;
			}
		}
		Kill(source);
		return;
	}
	if ((Random() < PainChance) && !bSkullFly)
	{
		bJustHit = true;	// fight back!
		SetState(PainState);
	}
	ReactionCount = 0;	// we're awake now...
	if (!Threshold && source && !source.bBoss &&
		!(Class == Sorcerer2 && source.Class == Wizard))
	{
		// Target actor is not intent on another actor,
		// so make him chase after source
		Enemy = source;
		Threshold = BASETHRESHOLD;
		if (State == IdleState && SeeState)
		{
			SetState(SeeState);
		}
	}
}

//==========================================================================
//
//  SpawnBloodSplatter
//
//==========================================================================

void SpawnBloodSplatter(TVec org)
{
	Actor mo;

	mo = Spawn(BloodSplatter, org);
	mo.Instigator = self;
	mo.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
	mo.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
	mo.Velocity.z = 2.0 * 35.0;
}

//==========================================================================
//
//  SpawnRipperBlood
//
//==========================================================================

void SpawnRipperBlood()
{
	Actor th;
	TVec org;

	org.x = Origin.x + (Random() - Random()) * 16.0;
	org.y = Origin.y + (Random() - Random()) * 16.0;
	org.z = Origin.z + (Random() - Random()) * 16.0;
	th = Spawn(Blood, org);
	th.bNoGravity = true;
	th.Velocity.x = Velocity.x / 2.0;
	th.Velocity.y = Velocity.y / 2.0;
	th.StateTime += Random() * 0.1;
}

//==========================================================================
//
//  HitFloorEffect
//
//==========================================================================

int HitFloorEffect()
{
	Actor A;

	if (FloorZ != Sector->floorheight)
	{
		// don't splash if landing on the edge above water/lava/etc....
		return FLOOR_SOLID;
	}
	switch (GetFloorType())
	{
	case FLOOR_WATER:
		Spawn(SplashBase, vector(Origin.x, Origin.y, ONFLOORZ));
		A = Spawn(Splash, vector(Origin.x, Origin.y, ONFLOORZ));
		A.Instigator = self;
		A.Velocity.x = (Random() - Random()) * 35.0;
		A.Velocity.y = (Random() - Random()) * 35.0;
		A.Velocity.z = (2.0 + Random()) * 35.0;
		A.PlaySound('world/watersplash', CHAN_VOICE);
		return FLOOR_WATER;
	case FLOOR_LAVA:
		Spawn(LavaSplash, vector(Origin.x, Origin.y, ONFLOORZ));
		A = Spawn(LavaSmoke, vector(Origin.x, Origin.y, ONFLOORZ));
		A.Velocity.z = (1.0 + Random() / 2.0) * 35.0;
		A.PlaySound('world/lavasizzle', CHAN_VOICE);
		return FLOOR_LAVA;
	case FLOOR_SLUDGE:
		Spawn(SludgeSplash, vector(Origin.x, Origin.y, ONFLOORZ));
		A = Spawn(SludgeChunk, vector(Origin.x, Origin.y, ONFLOORZ));
		A.Instigator = self;
		A.Velocity.x = (Random() - Random()) * 35.0;
		A.Velocity.y = (Random() - Random()) * 35.0;
		A.Velocity.z = (1.0 + Random()) * 35.0;
		return FLOOR_SLUDGE;
	}
	return FLOOR_SOLID;
}

//===========================================================================
//
//  FloorBounceMissile
//
//===========================================================================

void FloorBounceMissile()
{
	Velocity.z = -Velocity.z;
	SetState(DeathState);
}

//===========================================================================
//
//  Thrust
//
//===========================================================================

void Thrust(float angle, float move)
{
	Velocity.x += move * cos(angle) * 35.0;
	Velocity.y += move * sin(angle) * 35.0;
}

//===========================================================================
//
//  NightmareRespawn
//
//===========================================================================

void NightmareRespawn()
{
	float x, y, z;
	Actor A;

	x = SpawnSpot.x;
	y = SpawnSpot.y;

	if (!CheckPosition(vector(x, y, ONFLOORZ)))
		return;	// somthing is occupying it's position

	// spawn a teleport fog at old spot
	A = Spawn(TeleportFog, vector(Origin.x, Origin.y, ONFLOORZ));
	A.Origin.z += TELEFOGHEIGHT;
	A.PlaySound('misc/teleport', CHAN_VOICE);

	// spawn a teleport fog at the new spot
	A = Spawn(TeleportFog, vector(x, y, ONFLOORZ));
	A.Origin.z += TELEFOGHEIGHT;
	A.PlaySound('misc/teleport', CHAN_VOICE);

	// spawn the new monster

	// spawn it
	if (bSpawnCeiling)
		z = ONCEILINGZ;
	else
		z = ONFLOORZ;
	A = Spawn(Class, vector(x, y, z));
	Level.CopyMThing(&SpawnSpot, &A.SpawnSpot);
	A.Angles.yaw = itof(45 * (SpawnSpot.angle / 45));
	if (SpawnSpot.options & HereticLevelInfo::MTF_AMBUSH)
		A.bAmbush = true;

	A.ReactionCount = 18;

	// remove the old monster
	Remove();
}

//===========================================================================
//
//  TestLocation
//
//  Returns true if the actor is not blocked by anything at its current
// location, otherwise returns false.
//
//===========================================================================

bool TestLocation()
{
	if (!bColideWithThings && !bColideWithWorld)
		return true;

	if (CheckPosition(Origin))
	{
		// XY is ok, now check Z
		if ((Origin.z < FloorZ) || (Origin.z + Height > CeilingZ))
		{
			// Bad Z
			return false;
		}
		return true;
	}
	return false;
}

//==========================================================================
//
//	Touch
//
//==========================================================================

bool Touch(Entity InOther)
{
	bool solid;
	int damage;
	Actor Other;

	Other = Actor(InOther);
	if (!Other.bSolid && !Other.bSpecial && !Other.bShootable)
		return true;

	// check for skulls slamming into things
	if (bSkullFly)
	{
		damage = ((P_Random() % 8) + 1) * MissileDamage;
		Other.Damage(self, self, damage);
		bSkullFly = false;
		Velocity = vector(0.0, 0.0, 0.0);
		SetState(SeeState);
		return false;
	}

	// missiles can hit other things
	if (bMissile)
	{
		// Check for passing through a ghost
		if (Other.Translucency && bThruGhost)
		{
			return true;
		}

		if (Instigator && Instigator.Class == Other.Class)
		{
			// Don't hit same species as originator
			if (Other == Instigator)
			{
				// Don't missile self
				return true;
			}
			if (Other.Class != HereticPlayer)
			{
				// Hit same species as originator, explode, no damage
				return false;
			}
		}

		if (!Other.bShootable)
		{
			// didn't do any damage
			return !Other.bSolid;
		}

		if (bRip)
		{
			if (!Other.bNoBlood)
			{
				// Ok to spawn some blood
				SpawnRipperBlood();
			}
			PlaySound('misc/ripslop', CHAN_VOICE);
			damage = ((P_Random() & 3) + 2) * MissileDamage;
			Other.Damage(self, Instigator, damage);
			if (Other.bPushable && !bCannotPush)
			{
				// Push	thing
				Other.Velocity.x += Velocity.x / 4.0;
				Other.Velocity.y += Velocity.y / 4.0;
			}
//WTAT A FUCK IS THIS???????			numspechit = 0;
			return true;
		}
		// Do damage
		damage = ((P_Random() % 8) + 1) * MissileDamage;
		if (damage)
		{
			if (!Other.bNoBlood && P_Random() < 192)
			{
				Other.SpawnBloodSplatter(Origin);
			}
			Other.Damage(self, Instigator, damage);
		}
		// don't traverse any more
		return false;
	}

	if (Other.bPushable && !bCannotPush)
	{
		// Push thing
		Other.Velocity.x += Velocity.x / 4.0;
		Other.Velocity.y += Velocity.y / 4.0;
	}

	// check for special pickup
	if (Other.bSpecial)
	{
		solid = Other.bSolid;
		Pickup(Other).TouchSpecial(self);
		return !solid;
	}

	return !Other.bSolid;
}

//===========================================================================
//
//	CheckForPushSpecial
//
//===========================================================================

void CheckForPushSpecial(line_t * line, int side)
{
	if (line->special)
	{
		if (bActivatePushWall)
		{
			HereticLevelInfo(Level).ActivateLine(line, self, side, SPAC_PUSH);
		}
		else if (bActivateImpact)
		{
			HereticLevelInfo(Level).ActivateLine(line,
				bMissile ? Instigator : self, side, SPAC_IMPACT);
		}
	}
}

//==========================================================================
//
//	BlockedByLine
//
//==========================================================================

void BlockedByLine(line_t * ld)
{
	if (bBlasted)
	{
		Damage(none, none, ftoi(Mass) >> 5);
	}
	CheckForPushSpecial(ld, 0);
}

//==========================================================================
//
//  PushLine
//
//==========================================================================

void PushLine()
{
	if (bColideWithWorld)
	{
		int numSpecHitTemp;
		line_t *ld;
		int side;

		if (bBlasted)
		{
			Damage(none, none, ftoi(Mass) >> 5);
		}
		numSpecHitTemp = Level.Game.tmtrace->NumSpecHit;
		while (numSpecHitTemp > 0)
		{
			numSpecHitTemp--;
			// see if the line was crossed
			ld = Level.Game.tmtrace->SpecHit[numSpecHitTemp];
			side = PointOnPlaneSide(Origin, ld);
			CheckForPushSpecial(ld, side);
		}
	}
}

//==========================================================================
//
//	CrossSpecialLine
//
//==========================================================================

void CrossSpecialLine(line_t *ld, int side)
{
	if (bIsPlayer)
	{
		HereticLevelInfo(Level).ActivateLine(ld, self, side, SPAC_CROSS);
	}
	else if (bActivateMCross)
	{
		HereticLevelInfo(Level).ActivateLine(ld, self, side, SPAC_MCROSS);
	}
	else if (bActivatePCross)
	{
		HereticLevelInfo(Level).ActivateLine(ld, self, side, SPAC_PCROSS);
	}
	else if (ld->special == LNSPEC_Teleport)
	{
		//	Teleport hack
		HereticLevelInfo(Level).ActivateLine(ld, self, side, SPAC_MCROSS);
	}
}

//==========================================================================
//
//	HandleFloorclip
//
//==========================================================================

void HandleFloorclip()
{
	if (bFloorClip && GetFloorType() != FLOOR_SOLID)
	{
		FloorClip = FOOTCLIPSIZE;
	}
	else
	{
		FloorClip = 0.0;
	}
}

//**************************************************************************
//
//  OBJECT MOVEMENT
//
//**************************************************************************

//==========================================================================
//
//  ApplyFriction
//
//==========================================================================

void ApplyFriction()
{
	// Friction

	if (bMissile || bSkullFly)
	{
		// No friction for missiles
		return;
	}

	if (Origin.z > FloorZ && WaterLevel < 2 && !bFly && !bOnMobj)
	{
		// No friction when falling
		return;
	}

	if (Origin.z <= FloorZ)
	{
		//  Clip velocity
		float dot = DotProduct(Velocity, Floor->normal);

		if (dot < 0.0)
		{
			Velocity -= dot * Floor->normal;
		}
	}

	if (bCorpse)
	{
		// Don't stop sliding if halfway off a step with some momentum
		if (Velocity.x > 0.25 * 35.0 || Velocity.x < -0.25 * 35.0 ||
			Velocity.y > 0.25 * 35.0 || Velocity.y < -0.25 * 35.0)
		{
			if (FloorZ != GetPlanePointZ(&Sector->floor, Origin))
			{
				return;
			}
		}
	}

	if (Velocity.x > -STOPSPEED && Velocity.x < STOPSPEED &&
		Velocity.y > -STOPSPEED && Velocity.y < STOPSPEED &&
		Velocity.z > -STOPSPEED && Velocity.z < STOPSPEED &&
		(!bIsPlayer || (!Player.ForwardMove && !Player.SideMove)))
	{
		// If in a walking frame, stop moving
		if (bIsPlayer)
		{
			if (StateIsInRange(State, SeeState, none, 4))
			{
				SetState(IdleState);
			}
		}
		Velocity = vector(0.0, 0.0, 0.0);
	}
	else
	{
		Velocity -= Velocity * (GetFriction() * Level.Game.frametime);
	}
}

//===========================================================================
//
//  GetFriction
//
//===========================================================================

float GetFriction()
{
	if (WaterLevel > 1)
	{
		return FRICTION_WATER;
	}
	if (bFly && !(Origin.z <= FloorZ) && !bOnMobj)
	{
		return FRICTION_FLY;
	}
	if ((Sector->special & SECSPEC_BASE_MASK) == SECSPEC_FrictionLow)
	{
		return FRICTION_LOW;
	}
	if (Sector->special & SECSPEC_FRICTION_MASK)
	{
		return Sector->Friction;
	}
	return FRICTION_NORMAL;
}

//===========================================================================
//
//  XYMovement
//
//===========================================================================

void XYMovement(float DeltaTime)
{
	float ptryx, ptryy;
	float xmove, ymove;
	int special;

	if (bWindThrust)
	{
		special = Sector->special & SECSPEC_BASE_MASK;
		switch (special)
		{
		case SECSPEC_WindEastSlow:
		case SECSPEC_WindEastMedium:
		case SECSPEC_WindEastFast:
			Thrust(0.0, MainGameInfo(Level.Game).windTab[special - SECSPEC_WindEastSlow]);
			break;
		case SECSPEC_WindNorthSlow:
		case SECSPEC_WindNorthMedium:
		case SECSPEC_WindNorthFast:
			Thrust(90.0, MainGameInfo(Level.Game).windTab[special - SECSPEC_WindNorthSlow]);
			break;
		case SECSPEC_WindSouthSlow:
		case SECSPEC_WindSouthMedium:
		case SECSPEC_WindSouthFast:
			Thrust(270.0, MainGameInfo(Level.Game).windTab[special - SECSPEC_WindSouthSlow]);
			break;
		case SECSPEC_WindWestSlow:
		case SECSPEC_WindWestMedium:
		case SECSPEC_WindWestFast:
			Thrust(180.0, MainGameInfo(Level.Game).windTab[special - SECSPEC_WindWestSlow]);
			break;
		}
	}
	if (Velocity.x > MAXMOVE)
	{
		Velocity.x = MAXMOVE;
	}
	else if (Velocity.x < -MAXMOVE)
	{
		Velocity.x = -MAXMOVE;
	}
	if (Velocity.y > MAXMOVE)
	{
		Velocity.y = MAXMOVE;
	}
	else if (Velocity.y < -MAXMOVE)
	{
		Velocity.y = -MAXMOVE;
	}
	xmove = Velocity.x * DeltaTime;
	ymove = Velocity.y * DeltaTime;
	do
	{
		if (xmove > MAXMOVE / (35.0 * 2.0) || ymove > MAXMOVE / (35.0 * 2.0))
		{
			ptryx = Origin.x + xmove / 2.0;
			ptryy = Origin.y + ymove / 2.0;
			xmove /= 2.0;
			ymove /= 2.0;
		}
		else
		{
			ptryx = Origin.x + xmove;
			ptryy = Origin.y + ymove;
			xmove = 0.0;
			ymove = 0.0;
		}
		if (!TryMove(vector(ptryx, ptryy, Origin.z)))
		{
			// Blocked move
			if (bSlide)
			{
				// Try to slide along it
				SlideMove();
			}
			else if (bMissile)
			{
				// Explode a missile
				if (Level.Game.tmtrace->CeilingLine && Level.Game.tmtrace->CeilingLine->backsector &&
					Level.Game.tmtrace->CeilingLine->backsector->ceiling.pic == Level.Game.skyflatnum)
				{
					// Hack to prevent missiles exploding against the sky
					if (Class == BloodySkull)
					{
						Velocity = vector(0.0, 0.0, -1.0 * 35.0);
					}
					else
					{
						Remove();
					}
					return;
				}
				ExplodeMissile();
			}
			//else if (crashstate)
			//{
			//      Velocity.x = Velocity.y = 0.0;
			//      P_SetMobjState(this, crashstate);
			//      return;
			//}
			else
			{
				Velocity.x = 0.0;
				Velocity.y = 0.0;
			}
		}
	}
	while (xmove || ymove);
}

//===========================================================================
//
//  ZMovement
//
//===========================================================================

void ZMovement(float DeltaTime)
{
	float dist;
	float delta;
	float vdot;

	//
	// check for smooth step up
	//
	if (bIsPlayer && Origin.z < FloorZ)
	{
		Player(Player).ViewHeight -= FloorZ - Origin.z;
		Player(Player).DeltaViewHeight = (Player::VIEWHEIGHT - Player(Player).ViewHeight) * 4.0;
	}

	//
	// adjust height
	//
	Origin.z += Velocity.z * DeltaTime;
	if (bFloat && Enemy)
	{
		// float down towards enemy if too close
		if (!bSkullFly && !bInFloat)
		{
			dist = DistTo(Enemy);
			delta = Enemy.Origin.z + Height / 2.0 - Origin.z;
			if (delta < 0.0 && dist < -(delta * 3.0))
				Origin.z -= FLOATSPEED * DeltaTime;
			else if (delta > 0.0 && dist < (delta * 3.0))
				Origin.z += FLOATSPEED * DeltaTime;
		}
	}
	if (bIsPlayer && bFly && !(Origin.z <= FloorZ) && Level.Game.level->tictime & 2)
	{
		Origin.z += sin(90.0 * 35.0 / 20.0 * Level.Game.level->time);
	}

	//
	// clip movement
	//
	if (Origin.z <= FloorZ + 0.1)
	{
		// Hit the floor
		vdot = DotProduct(Velocity, Floor->normal);
		if (bMissile)
		{
			Origin.z = FloorZ;
			if (bFloorBounce)
			{
				FloorBounceMissile();
				return;
			}
			else if (Class == MinotaurFloorFire)
			{
				// Minotaur floor fire can go up steps
				return;
			}
			else
			{
				ExplodeMissile();
				return;
			}
		}
		if (Origin.z - Velocity.z * DeltaTime > FloorZ)
		{
			// Spawn splashes, etc.
			HitFloorEffect();
		}
		Origin.z = FloorZ;
		if (vdot < -0.1)
		{
			if (bIsPlayer && vdot < -GRAVITY * 0.25 && !bFly)	// squat down
			{
				Player(Player).DeltaViewHeight = vdot / 8.0;
				PlaySound('*land', CHAN_BODY);
//FIXME				Player.centering = true;
			}
			Velocity -= vdot * Floor->normal;
		}
		if (bSkullFly)
		{
			// The skull slammed into something
			Velocity -= vdot * Floor->normal / 2.0;
		}
		if (CrashState && bCorpse)
		{
			SetState(CrashState);
			return;
		}
	}

	if (Origin.z + Height > CeilingZ)
	{
		// hit the ceiling
		vdot = DotProduct(Velocity, Ceiling->normal);
		if (vdot < 0.0)
			Velocity -= vdot * Ceiling->normal;
		Origin.z = CeilingZ - Height;
		if (bSkullFly)
		{	// the skull slammed into something
			Velocity.z = -Velocity.z;
		}
		if (bMissile)
		{
			if (Sector->ceiling.pic == Level.Game.skyflatnum)
			{
				if (Class == BloodySkull)
				{
					Velocity = vector(0.0, 0.0, -1.0 * 35.0);
				}
				else
				{
					Remove();
				}
				return;
			}
			ExplodeMissile();
			return;
		}
	}
}

//===========================================================================
//
//  BlasterPhysics
//
//  Thinker for the ultra-fast blaster PL2 ripper-spawning missile.
//
//===========================================================================

bool BlasterPhysics(float DeltaTime)
{
	int i;
	float xfrac;
	float yfrac;
	float zfrac;
	TVec org;
	bool changexy;

	// Handle movement
	if (Velocity.x || Velocity.y ||
		(Origin.z != FloorZ) || Velocity.z)
	{
		xfrac = Velocity.x * DeltaTime / 8.0;
		yfrac = Velocity.y * DeltaTime / 8.0;
		zfrac = Velocity.z * DeltaTime / 8.0;
		changexy = xfrac || yfrac;
		for (i = 0; i < 8; i++)
		{
			if (changexy)
			{
				if (!TryMove(vector(Origin.x + xfrac, Origin.y + yfrac, Origin.z)))
				{
					// Blocked move
					ExplodeMissile();
					return !IsDestroyed();
				}
			}
			Origin.z += zfrac;
			if (Origin.z <= FloorZ)
			{
				// Hit the floor
				Origin.z = FloorZ;
				HitFloorEffect();
				ExplodeMissile();
				return !IsDestroyed();
			}
			if (Origin.z + Height > CeilingZ)
			{
				// Hit the ceiling
				Origin.z = CeilingZ - Height;
				ExplodeMissile();
				return !IsDestroyed();
			}
			if (changexy && (P_Random() < 64))
			{
				org = Origin;
				org.z = Origin.z - 8.0;
				if (org.z < FloorZ)
				{
					org.z = FloorZ;
				}
				Spawn(BlasterSmoke, org);
			}
		}
	}
	return true;
}

//===========================================================================
//
//  PlayerLandedOnThing
//
//===========================================================================

void PlayerLandedOnThing()
{
	Player(Player).DeltaViewHeight = Velocity.z / 8.0;
	if (Velocity.z < -GRAVITY * 0.375)
	{
		PlaySound('*land', CHAN_VOICE);
	}
}

//===========================================================================
//
//	Physics
//
//===========================================================================

bool Physics(float DeltaTime)
{
	Actor			onmo;
	SectorThinker	SecThink;
	float			scrollx;
	float			scrolly;
	float			height;
	float			waterheight;	// killough 4/4/98: add waterheight

	if (bBlaster)
	{
		return BlasterPhysics(DeltaTime);
	}

	if (Sector->AffectorData && bColideWithWorld)
	{

		// killough 3/7/98: Carry things on floor
		// killough 3/20/98: use new sector list which reflects true members
		// killough 3/27/98: fix carrier bug
		// killough 4/4/98: Underwater, carry things even w/o gravity

		// Move objects only if on floor or underwater,
		// non-floating, and clipped.

		for (SecThink = SectorThinker(Sector->AffectorData); SecThink;
			SecThink = SecThink.NextAffector)
		{
			if (!Scroller(SecThink))
			{
				continue;
			}
			scrollx = Scroller(SecThink).CarryScrollX;
			scrolly = Scroller(SecThink).CarryScrollY;
			if (!scrollx && !scrolly)
			{
				continue;
			}
			if (bNoGravity && (!Sector->heightsec ||
				(Sector->heightsec->bIgnoreHeightSec)))
			{
				continue;
			}
			height = GetPlanePointZ(&Sector->floor, Origin);
			if (Origin.z > height)
			{
				if (!Sector->heightsec || (Sector->heightsec->bIgnoreHeightSec))
				{
					continue;
				}

				waterheight = GetPlanePointZ(&Sector->heightsec->floor, Origin);
				if (waterheight > height && Origin.z >= waterheight)
				{
					continue;
				}
			}

			Velocity.x += scrollx;
			Velocity.y += scrolly;
		}
	}

	CheckWater();
	if (!bFloatBob)
	{
		UpdateVelocity();
	}

	// Handle X and Y momentums
	Level.Game.tmtrace->BlockingMobj = none;
	if (Velocity.x || Velocity.y)
	{
		XYMovement(DeltaTime);
		if (IsDestroyed())
		{
			// mobj was removed
			return false;
		}
	}
	else if (bSkullFly)
	{
		// A flying mobj slammed into something
		bSkullFly = false;
		Velocity = vector(0.0, 0.0, 0.0);
		SetState(SeeState);
		if (IsDestroyed())
		{
			// mobj was removed
			return false;
		}
	}
	if (bFloatBob)
	{
		// Floating item bobbing motion (special1 is height)
		if (Sector->bHasExtrafloors)
		{
			//	Make sure FloorZ is from bottom region.
			Origin.z = ONFLOORZ;
			LinkToWorld();
		}
		Origin.z = FloorZ + Special1f + Level.Game.FloatBobOffsets[(Health++) & 63];
	}
	else if ((Origin.z != FloorZ) || Velocity.z || Level.Game.tmtrace->BlockingMobj)
	{
		// Handle Z momentum and gravity
		if (!bNoPassMobj && !bMissile)
		{
			onmo = Actor(CheckOnmobj());
			if (!onmo)
			{
				ZMovement(DeltaTime);
				bOnMobj = false;
			}
			else
			{
				if (bIsPlayer)
				{
					if (Velocity.z < -GRAVITY * 0.25 && !bFly)
					{
						PlayerLandedOnThing();
					}
				}
				if (onmo.Origin.z + onmo.Height - Origin.z <= MaxStepHeight)
				{
					if (bIsPlayer)
					{
						Player(Player).ViewHeight -=
							onmo.Origin.z + onmo.Height - Origin.z;
						Player(Player).DeltaViewHeight =
							(Player::VIEWHEIGHT - Player(Player).ViewHeight) * 4.0;
					}
					Origin.z = onmo.Origin.z + onmo.Height;
				}
				bOnMobj = true;
				Velocity.z = 0.0;

				if (onmo.bIsPlayer || onmo.Class == Pod)
				{
					Velocity.x = onmo.Velocity.x;
					Velocity.y = onmo.Velocity.y;
					if (onmo.Origin.z < onmo.FloorZ)
					{
						Origin.z += onmo.FloorZ - onmo.Origin.z;
						if (onmo.bIsPlayer)
						{
							Player(onmo.Player).ViewHeight -=
								onmo.FloorZ - onmo.Origin.z;
							Player(onmo.Player).DeltaViewHeight =
								(Player::VIEWHEIGHT - Player(onmo.Player).ViewHeight) * 4.0;
						}
						onmo.Origin.z = onmo.FloorZ;
					}
				}
			}
		}
		else
		{
			ZMovement(DeltaTime);
		}
		if (IsDestroyed())
		{
			// mobj was removed
			return false;
		}
	}
	return true;
}

//==========================================================================
//
//	Tick
//
//==========================================================================

void Tick(float deltaTime)
{
	if (!Physics(deltaTime))
	{
		return;
	}

	//
	// cycle through states, calling action functions at transitions
	//
	if (StateTime != -1.0)
	{
		StateTime -= deltaTime;
		if (StateTime <= 0.0)
		{
			// you can cycle through multiple states in a tic
			if (!SetState(NextState))
			{
				// mobj was removed
				return;
			}
		}
	}
	else
	{
		// Check for monster respawn
		if (!bCountKill)
		{
			return;
		}
		if (!MainGameInfo(Level.Game).respawnmonsters)
		{
			return;
		}
		MoveCount++;
		if (MoveCount < 12 * 35)
		{
			return;
		}
		if (Level.Game.level->tictime & 31)
		{
			return;
		}
		if (P_Random() > 4)
		{
			return;
		}
		NightmareRespawn();
	}
}

//==========================================================================
//
//  HeightClip
//
//  Takes a valid thing and adjusts the thing->FloorZ, thing->CeilingZ, and
// possibly thing->z. This is called for all nearby monsters whenever a
// sector changes height. If the thing doesn't fit, the z will be set to the
// lowest value and false will be returned.
//
//==========================================================================

bool HeightClip()
{
	bool onfloor;

	onfloor = (Origin.z == FloorZ);

	CheckRelPosition(Origin);
	// what about stranding a monster partially off an edge?

	Floor = Level.Game.tmtrace->Floor;
	Ceiling = Level.Game.tmtrace->Ceiling;
	FloorZ = Level.Game.tmtrace->FloorZ;
	CeilingZ = Level.Game.tmtrace->CeilingZ;

	if (onfloor)
	{
		// walking monsters rise and fall with the floor
		Origin.z = FloorZ;
	}
	else
	{
		// don't adjust a floating monster unless forced to
		if (Origin.z + Height > CeilingZ)
			Origin.z = CeilingZ - Height;
	}

	if (CeilingZ - FloorZ < Height)
		return false;

	return true;
}

//==========================================================================
//
//	SectorChanged
//
//==========================================================================

bool SectorChanged(int CrushChange)
{
	Actor A;

	if (HeightClip())
	{
		return true;
	}

	//	Crunch bodies to giblets
	if (Health <= 0)
	{
		bSolid = false;
		Height = 0.0;
		Radius = 0.0;
		return true;	//fit
	}

	//	Crunch dropped items
	if (bDropped)
	{
		Remove();
		return true;	//fit
	}

	if (!bShootable)
	{
		//	Assume it is bloody gibs or something
		return true;	//fit
	}

	if (CrushChange && !(Level.Game.level->tictime & 3))
	{
		Damage(none, none, CrushChange);

		//	Spray blood in a random direction
		A = Spawn(Blood, Origin + vector(0.0, 0.0, Height / 2.0));
		A.Velocity.x = (Random() - Random()) * 16.0 * 35.0;
		A.Velocity.y = (Random() - Random()) * 16.0 * 35.0;
	}
	return false;	//don't fit
}

//**************************************************************************
//
//  RADIUS ATTACK
//
//**************************************************************************

//==========================================================================
//
//  PIT_RadiusAttack
//
//  "bombsource" is the creature that caused the explosion at "bombspot".
//
//==========================================================================

bool PIT_RadiusAttack(Entity Other)
{
	float dist;

	if (!Actor(Other).bShootable)
		return true;

	if (Other.Class == Minotaur ||
		Other.Class == Sorcerer1 || Other.Class == Sorcerer2)
	{
		// Episode 2 and 3 bosses take no damage from PIT_RadiusAttack
		return true;
	}

	dist = Length(MobjCenter(Other) - MobjCenter(self)) - Other.Radius;

	if (dist < 0.0)
		dist = 0.0;

	if (dist >= bombdamage)
		return true;	// out of range

	if (Actor(Other).CanSee(self))
	{
		// must be in direct path
		Actor(Other).Damage(self, Instigator, ftoi(bombdamage - dist));
	}

	return true;
}

//==========================================================================
//
//  RadiusAttack
//
//  Source is the creature that caused the explosion at spot.
//
//==========================================================================

void RadiusAttack(int damage, int distance, bool damageSource)
{
	int x;
	int y;

	int xl;
	int xh;
	int yl;
	int yh;

	float dist;

	dist = itof(damage);
	yh = MapBlock(Origin.y + dist - XLevel.BlockMapOrgY);
	yl = MapBlock(Origin.y - dist - XLevel.BlockMapOrgY);
	xh = MapBlock(Origin.x + dist - XLevel.BlockMapOrgX);
	xl = MapBlock(Origin.x - dist - XLevel.BlockMapOrgX);
	bombdamage = itof(damage);

	for (y = yl; y <= yh; y++)
		for (x = xl; x <= xh; x++)
			P_BlockThingsIterator(x, y, self, 'PIT_RadiusAttack');
}

//==========================================================================
//
//  CheckMissileSpawn
//
//  Returns true if the missile is at a valid spawn point, otherwise
// explodes it and returns false.
//
//==========================================================================

bool CheckMissileSpawn()
{
	// move a little forward so an angle can be computed if it
	// immediately explodes
	Origin += Velocity * 0.0142857143;
	if (!TryMove(Origin))
	{
		ExplodeMissile();
		return false;
	}
	return true;
}

//==========================================================================
//
//  SpawnMissile
//
//  Returns NULL if the missile exploded immediately, otherwise returns
// a Actor reference to the missile.
//
//==========================================================================

Actor SpawnMissile(Actor dest, classid type)
{
	TVec org;
	Actor A;
	TVec dir;

	org = Origin;
	if (type == MinotaurMissile)
	{
		// Minotaur swing attack missile
		org.z = Origin.z + 40.0;
	}
	else if (type == MinotaurFloorFire)
	{
		// Minotaur floor fire missile
		org.z = ONFLOORZ + FloorClip;
	}
	else if (type == Sorcerer1Missile)
	{
		// Sorcerer Demon fireball
		org.z = Origin.z + 48.0;
	}
	else if (type == KnightAxe||	// Knight normal axe
			type == KnightRedAxe)	// Knight red power axe
	{
		org.z = Origin.z + 36.0;
	}
	else
	{
		org.z = Origin.z + 32.0;
	}
	org.z -= FloorClip;
	A = Spawn(type, org);
	if (A.SightSound)
	{
		A.PlaySound(A.SightSound, CHAN_VOICE);
	}
	A.Instigator = self;	// Originator
	dir = dest.Origin - Origin;
	if (dest.Translucency)
	{
		// Invisible target
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0);
	}
	dir = Normalise(dir);
	A.Velocity = dir * A.Speed;
	VectorAngles(&dir, &A.Angles);
	return A.CheckMissileSpawn() ? A : none;
}

//==========================================================================
//
//  SpawnMissileAngles
//
//  Returns NULL if the missile exploded immediately, otherwise returns
// a Actor reference to the missile.
//
//==========================================================================

Actor SpawnMissileAngles(classid type, float yaw, float pitch)
{
	TVec org;
	Actor A;
	TVec dir;

	org = Origin;
	if (type == MinotaurMissile)
	{
		// Minotaur swing attack missile
		org.z = Origin.z + 40.0;
	}
	else if (type == MinotaurFloorFire)
	{
		// Minotaur floor fire missile
		org.z = ONFLOORZ + FloorClip;
	}
	if (type == Sorcerer1Missile)
	{
		// Sorcerer Demon fireball
		org.z = Origin.z + 48.0;
	}
	else
	{
		org.z = Origin.z + 32.0;
	}
	org.z -= FloorClip;
	A = Spawn(type, org);
	if (A.SightSound)
	{
		A.PlaySound(A.SightSound, CHAN_VOICE);
	}
	A.Instigator = self;	// Originator
	A.Angles.yaw = yaw;
	A.Angles.pitch = pitch;
	AngleVector(&A.Angles, &dir);
	A.Velocity = A.Speed * dir;
	return A.CheckMissileSpawn() ? A : none;
}

//==========================================================================
//
//  SpawnPlayerMissile
//
//  Tries to aim at a nearby monster
//
//==========================================================================

Actor SpawnPlayerMissile(classid type)
{
	TVec dir;
	TVec org;
	Actor MissileMobj;

	// Try to find a target
	dir = Aim(Angles.yaw, 16.0 * 64.0);
	org = Origin;
	org.z = Origin.z + 32.0 - tan(Angles.pitch);
	org.z -= FloorClip;
	MissileMobj = Spawn(type, org);
	MainGameInfo(Level.Game).MissileMobj = MissileMobj;
	if (MissileMobj.SightSound)
	{
		MissileMobj.PlaySound(MissileMobj.SightSound, CHAN_VOICE);
	}
	MissileMobj.Instigator = self;
	MissileMobj.Velocity = dir * MissileMobj.Speed;
	VectorAngles(&dir, &MissileMobj.Angles);
	if (MissileMobj.Class == BlasterFX1)
	{
		// Ultra-fast ripper spawning missile
		MissileMobj.Origin += MissileMobj.Velocity * 0.00357;
	}
	else
	{
		// Normal missile
		MissileMobj.Origin += MissileMobj.Velocity * 0.01429;
	}
	if (!MissileMobj.TryMove(MissileMobj.Origin))
	{
		// Exploded immediately
		MissileMobj.ExplodeMissile();
		return none;
	}
	return MissileMobj;
}

//==========================================================================
//
//  SpawnPlayerMissileAngle
//
//==========================================================================

Actor SpawnPlayerMissileAngle(classid type, float angle)
{
	Actor A;
	TVec dir;
	TVec org;

	dir = Aim(angle, 16.0 * 64.0);
	org = Origin;
	org.z = Origin.z + 4.0 * 8.0 - tan(Angles.pitch);
	org.z -= FloorClip;
	A = Spawn(type, org);
	if (A.SightSound)
	{
		A.PlaySound(A.SightSound, CHAN_VOICE);
	}
	A.Instigator = self;
	A.Velocity = dir * A.Speed;
	VectorAngles(&dir, &A.Angles);
	return A.CheckMissileSpawn() ? A : none;
}

//==========================================================================
//
//  SeekerMissile
//
//  The missile Enemy field must be Actor target. Returns true if
// target was tracked, false if not.
//
//==========================================================================

bool SeekerMissile(float thresh, float turnMax)
{
	int dir;
	float dist;
	float delta;
	float angle;

	if (!Enemy)
	{
		return false;
	}
	if (!Enemy.bShootable)
	{
		// Target died
		Enemy = none;
		return false;
	}
	dir = FaceActor(Enemy, &delta);
	if (delta > thresh)
	{
		delta /= 2.0;
		if (delta > turnMax)
		{
			delta = turnMax;
		}
	}
	if (dir)
	{
		// Turn clockwise
		Angles.yaw = AngleMod360(Angles.yaw + delta);
	}
	else
	{
		// Turn counter clockwise
		Angles.yaw = AngleMod360(Angles.yaw - delta);
	}
	angle = Angles.yaw;
	Velocity.x = Speed * cos(angle);
	Velocity.y = Speed * sin(angle);
	if (Origin.z + Height < Enemy.Origin.z ||
		Enemy.Origin.z + Enemy.Height < Origin.z)
	{
		// Need to seek vertically
		dist = DistTo2(Enemy);
		dist = dist / Speed;
		if (dist < 1.0)
		{
			dist = 1.0;
		}
		Velocity.z = (Enemy.Origin.z - Origin.z) / dist;
	}
	return true;
}

//==========================================================================
//
//  PIT_StompThing
//
//==========================================================================

bool PIT_StompThing(Entity Other)
{
	float blockdist;

	if (!Actor(Other).bShootable)
	{
		return true;
	}

	blockdist = Other.Radius + Radius;

	if (fabs(Other.Origin.x - teleport_x) >= blockdist ||
		fabs(Other.Origin.y - teleport_y) >= blockdist)
	{
		// didn't hit it
		return true;
	}

	// don't clip against self
	if (Other == self)
	{
		return true;
	}

	//  Check if allowed to stomp things
	if (!bTelestomp)
	{
		return false;
	}

	Actor(Other).Damage(self, self, 10000);

	return true;
}

//==========================================================================
//
//  TeleportMove
//
//==========================================================================

bool TeleportMove(TVec newOrg)
{
	int xl;
	int xh;
	int yl;
	int yh;
	int bx;
	int by;

	// kill anything occupying the position
	teleport_x = newOrg.x;
	teleport_y = newOrg.y;

	// stomp on any things contacted
	xl = MapBlock(newOrg.x - Radius - XLevel.BlockMapOrgX - MAXRADIUS);
	xh = MapBlock(newOrg.x + Radius - XLevel.BlockMapOrgX + MAXRADIUS);
	yl = MapBlock(newOrg.y - Radius - XLevel.BlockMapOrgY - MAXRADIUS);
	yh = MapBlock(newOrg.y + Radius - XLevel.BlockMapOrgY + MAXRADIUS);

	for (bx = xl; bx <= xh; bx++)
		for (by = yl; by <= yh; by++)
			if (!P_BlockThingsIterator(bx, by, self, 'PIT_StompThing'))
				return false;

	// the move is ok,
	// so link the thing into its new position
	UnlinkFromWorld();
	Origin = newOrg;
	LinkToWorld();
	if (newOrg.z == ONFLOORZ)
	{
		Origin.z = FloorZ;
	}

	return true;
}

//==========================================================================
//
//  Teleport
//
//==========================================================================

bool Teleport(TVec Dst, float angle, bool DstFog, bool SrcFog, bool KeepDir)
{
	TVec oldOrg;
	float aboveFloor;
	float fogDelta;
	Actor fog;

	oldOrg = Origin;
	aboveFloor = Origin.z - FloorZ;
	if (!TeleportMove(Dst))
	{
		return false;
	}
	if (bIsPlayer)
	{
		if (Player(Player).Powers[pw_flight] && aboveFloor)
		{
			Origin.z = Origin.z + aboveFloor;
			if (Origin.z + Height > CeilingZ)
			{
				Origin.z = CeilingZ - Height;
			}
			Player.ViewOrg.z = Origin.z + Player(Player).ViewHeight;
		}
		else
		{
			Player.ViewOrg.z = Origin.z + Player(Player).ViewHeight;
			if (!KeepDir)
			{
				Angles.pitch = 0.0;
			}
		}
		Player.bFixAngle = true;
	}
	else if (bMissile)
	{
		Origin.z = Origin.z + aboveFloor;
		if (Origin.z + Height > CeilingZ)
		{
			Origin.z = CeilingZ - Height;
		}
	}
	// Spawn teleport fog at source and destination
	fogDelta = bMissile ? 0.0 : TELEFOGHEIGHT;
	if (SrcFog)
	{
		fog = Spawn(TeleportFog, oldOrg + vector(0.0, 0.0, fogDelta));
		fog.PlaySound('misc/teleport', CHAN_VOICE);
	}
	if (DstFog)
	{
		fog = Spawn(TeleportFog, vector(Origin.x + 20.0 * cos(angle),
			Origin.y + 20.0 * sin(angle), Origin.z + fogDelta));
		fog.PlaySound('misc/teleport', CHAN_VOICE);
	}
	if (!KeepDir)
	{
		if (bIsPlayer && !Player(Player).Powers[pw_weaponlevel2])
		{
			// Freeze player for about .5 sec
			ReactionTime = 0.5;
		}
		Angles.yaw = angle;
	}
	if (bFloorClip && GetFloorType() != FLOOR_SOLID)
	{
		FloorClip = FOOTCLIPSIZE;
	}
	else
	{
		FloorClip = 0.0;
	}
	if (bMissile)
	{
		Velocity.x = Speed * cos(angle);
		Velocity.y = Speed * sin(angle);
	}
	else if (!KeepDir)
	{
		Velocity = vector(0.0, 0.0, 0.0);
	}
	return true;
}

//==========================================================================
//
//  CheckMeleeRange
//
//==========================================================================

bool CheckMeleeRange()
{
	float dist;

	if (!Enemy)
	{
		return false;
	}
	dist = DistTo(Enemy);
	if (dist >= MELEERANGE)
	{
		return false;
	}
	// Don't melee things too far above or below actor.
	if (Enemy.Origin.z > Origin.z + Height)
		return false;
	if (Enemy.Origin.z + Enemy.Height < Origin.z)
		return false;
	if (!CanSee(Enemy))
	{
		return false;
	}
	return true;
}

//==========================================================================
//
//  CheckMissileRange
//
//==========================================================================

bool CheckMissileRange()
{
	float dist;

	if (!CanSee(Enemy))
	{
		return false;
	}
	if (bJustHit)
	{
		// The target just hit the enemy, so fight back!
		bJustHit = false;
		return true;
	}
	if (ReactionCount)
	{
		// Don't attack yet
		return false;
	}
	dist = DistTo(Enemy) - 64.0;
	if (!MeleeState)
	{
		// No melee attack, so fire more frequently
		dist -= 128.0;
	}
	if (Class == Imp)
	{
		// Imp's fly attack from far away
		dist /= 2.0;
	}
	if (dist > 200.0)
	{
		dist = 200.0;
	}
	if (Random() * 256.0 < dist)
	{
		return false;
	}
	return true;
}

//==========================================================================
//
//  LookForMonsters
//
//==========================================================================

bool LookForMonsters()
{
	int count;
	Actor mo;

	if (!Level.Game.Players[0].MO.CanSee(self))
	{
		// Player can't see monster
		return false;
	}
	count = 0;
	FOREACH(Actor, mo)
	{
		if (!mo.bCountKill || (mo == self) || (mo.Health <= 0))
		{
			// Not a valid monster
			continue;
		}
		if (DistTo(mo) > MONS_LOOK_RANGE)
		{
			// Out of range
			continue;
		}
		if (P_Random() < 16)
		{
			// Skip
			continue;
		}
		if (count++ > MONS_LOOK_LIMIT)
		{
			// Stop searching
			return (false);
		}
		if (!CanSee(mo))
		{
			// Out of sight
			continue;
		}
		// Found a target monster
		Enemy = mo;
		return true;
	}
	return false;
}

//==========================================================================
//
//  LookForPlayers
//
//  If allaround is false, only look 180 degrees in front
//  returns true if a player is targeted
//
//==========================================================================

bool LookForPlayers(bool allaround)
{
	int c;
	int stop;
	Player P;
	float an;
	float dist;

	if (!Level.Game.netgame && Level.Game.Players[0] && Level.Game.Players[0].bSpawned && Level.Game.Players[0].Health <= 0)
	{
		// Single player game and player is dead, look for monsters
		return LookForMonsters();
	}
	c = 0;
	stop = (LastLook - 1) & (MAXPLAYERS - 1);
	for (;; LastLook = (LastLook + 1) & (MAXPLAYERS - 1))
	{
		if (LastLook == stop)
			return false;	// done looking

		if (!Level.Game.Players[LastLook])
			continue;

		if (c++ == 2)
			return false;	// done looking

		P = Player(Level.Game.Players[LastLook]);
		if (!P.bSpawned || !P.MO)
			continue;	// not spawned yet
		if (P.Health <= 0)
			continue;	// dead
		if (!CanSee(P.MO))
			continue;	// out of sight

		if (!allaround)
		{
			an = AngleMod360(atan2(P.MO.Origin.y - Origin.y,
				P.MO.Origin.x - Origin.x) - Angles.yaw);
			if (an > 90.0 && an < 270.0)
			{
				dist = DistTo(P.MO);
				// if real close, react anyway
				if (dist > MELEERANGE)
					continue;	// behind back
			}
		}
		if (P.MO.Translucency)
		{
			// Player is invisible
			if ((DistTo(P.MO) > 2.0 * MELEERANGE) &&
				Length(P.MO.Velocity) < 5.0 * 35.0)
			{
				// Player is sneaking - can't detect
				return false;
			}
			if (P_Random() < 225)
			{
				// Player isn't sneaking, but still didn't detect
				return false;
			}
		}
		Enemy = Actor(P.MO);
		return true;
	}
	return false;
}

//==========================================================================
//
//  StepMove
//
//  Move in the current direction, returns false if the move is blocked.
//
//==========================================================================

bool StepMove()
{
	float tryx, deltax, origx;
	float tryy, deltay, origy;
	float maxmove;
	int steps;
	float xspeed;
	float yspeed;
	int i;
	bool try_ok;

	line_t *ld;
	bool good;

	if (MoveDir == DI_NODIR)
		return false;

	// [RH] Instead of yanking non-floating monsters to the ground,
	// let gravity drop them down, unless they're moving down a step.
	if (!bNoGravity && Origin.z > FloorZ && !bOnMobj)
	{
		if (Origin.z > FloorZ + MaxStepHeight)
		{
			return false;
		}
		else
		{
			Origin.z = FloorZ;
		}
	}

#ifdef RANGECHECK
	if (MoveDir >= 8 || MoveDir < 0)
		Error("Weird MoveDir!");
#endif

	origx = Origin.x;
	origy = Origin.y;
	deltax = StepSpeed * MainGameInfo(Level.Game).xspeed[MoveDir];
	deltay = StepSpeed * MainGameInfo(Level.Game).yspeed[MoveDir];
	tryx = origx + deltax;
	tryy = origy + deltay;

	// Like P_XYMovement this should do multiple moves if the step size is too large
	maxmove = Radius;
	steps = 1;

	if (maxmove > 0.0)
	{ 
		xspeed = fabs(deltax);
		yspeed = fabs(deltay);

		if (xspeed > yspeed)
		{
			if (xspeed > maxmove)
			{
				steps = 1 + ftoi(xspeed / maxmove);
			}
		}
		else
		{
			if (yspeed > maxmove)
			{
				steps = 1 + ftoi(yspeed / maxmove);
			}
		}
	}

	try_ok = true;
	for(i=1; i < steps; i++)
	{
		try_ok = TryMove(vector(origx + (deltax / itof(steps * i)), origy +
					(deltay / itof(steps * i)), Origin.z));
		if (!try_ok)
			break;
	}

	// killough 3/15/98: don't jump over dropoffs:
	if (try_ok)
		try_ok = TryMove (vector(tryx, tryy, Origin.z));

	if (!try_ok)
	{
		// open any specials
		if (bFloat && Level.Game.tmtrace->bFloatOk)
		{
			// must adjust height
			if (Origin.z < Level.Game.tmtrace->FloorZ)
				Origin.z += FLOATSPEED * Level.Game.frametime;
			else
				Origin.z -= FLOATSPEED * Level.Game.frametime;

			// Check to make sure there's nothing in the way of the float
			if(TestMobjZ())
			{
				bInFloat = true;
				return true;
			}
		}

		if (!Level.Game.tmtrace->NumSpecHit)
			return false;

		MoveDir = DI_NODIR;
		good = false;
		while (Level.Game.tmtrace->NumSpecHit--)
		{
			ld = Level.Game.tmtrace->SpecHit[Level.Game.tmtrace->NumSpecHit];
			// if the special is not a door
			// that can be opened,
			// return false
			if (HereticLevelInfo(Level).ActivateLine(ld, self, 0, SPAC_USE))
			{
				good = true;
			}
		}
		return good;
	}
	else
	{
		bInFloat = false;
	}

	if (!bFloat)
	{
		if (Origin.z > FloorZ)
		{
			HitFloorEffect();
		}
		Origin.z = FloorZ;
	}
	return true;
}

//==========================================================================
//
//  TryWalk
//
//  Attempts to move actor in its current (ob->moveangle) direction.
//  If blocked by either a wall or an actor returns FALSE.
//  If move is either clear of block only by a door, returns TRUE and sets.
//  If a door is in the way, an OpenDoor call is made to start it opening.
//
//==========================================================================

bool TryWalk()
{
	if (!StepMove())
	{
		return false;
	}
	MoveCount = P_Random() & 15;
	return true;
}

//==========================================================================
//
//  DO_NewChaseDir
//
//==========================================================================

void DO_NewChaseDir(float deltax, float deltay)
{
	int d[3];

	int tdir;
	int olddir;

	int turnaround;

	olddir = MoveDir;
	turnaround = MainGameInfo(Level.Game).opposite[olddir];

	if (deltax > 10.0)
		d[1] = DI_EAST;
	else if (deltax < -10.0)
		d[1] = DI_WEST;
	else
		d[1] = DI_NODIR;
	if (deltay < -10.0)
		d[2] = DI_SOUTH;
	else if (deltay > 10.0)
		d[2] = DI_NORTH;
	else
		d[2] = DI_NODIR;

	// try direct route
	if (d[1] != DI_NODIR && d[2] != DI_NODIR)
	{
		MoveDir = MainGameInfo(Level.Game).diags[((deltay < 0.0) << 1) + (deltax > 0.0)];
		if (MoveDir != turnaround && TryWalk())
			return;
	}

	// try other directions
	if (P_Random() > 200 || fabs(deltay) > fabs(deltax))
	{
		tdir = d[1];
		d[1] = d[2];
		d[2] = tdir;
	}

	if (d[1] == turnaround)
		d[1] = DI_NODIR;
	if (d[2] == turnaround)
		d[2] = DI_NODIR;

	if (d[1] != DI_NODIR)
	{
		MoveDir = d[1];
		if (TryWalk())
			return;	/*either moved forward or attacked */
	}

	if (d[2] != DI_NODIR)
	{
		MoveDir = d[2];
		if (TryWalk())
			return;
	}

	/* there is no direct path to the player, so pick another direction */

	if (olddir != DI_NODIR)
	{
		MoveDir = olddir;
		if (TryWalk())
			return;
	}

	if (P_Random() & 1)	/*randomly determine direction of search */
	{
		for (tdir = DI_EAST; tdir <= DI_SOUTHEAST; tdir++)
		{
			if (tdir != turnaround)
			{
				MoveDir = tdir;
				if (TryWalk())
					return;
			}
		}
	}
	else
	{
		for (tdir = DI_SOUTHEAST; tdir >= DI_EAST; tdir--)
		{
			if (tdir != turnaround)
			{
				MoveDir = tdir;
				if (TryWalk())
					return;
			}
		}
	}

	if (turnaround != DI_NODIR)
	{
		MoveDir = turnaround;
		if (TryWalk())
			return;
	}

	MoveDir = DI_NODIR;	// can't move
}

//=============================================================================
//
// NewChaseDir
//
// killough 9/8/98: Split into two functions
//
//=============================================================================

void NewChaseDir()
{
	float deltax, deltaxx;
	float deltay, deltayy;
	float angle;

	deltax = Enemy.Origin.x - Origin.x;
	deltay = Enemy.Origin.y - Origin.y;
	deltaxx = 0.0;
	deltayy = 0.0;

	if(!Enemy)
		Error("NewChaseDir: called with no Enemy");
	
	// Try to move away from a dropoff
	if (FloorZ - Level.Game.tmtrace->DropOffZ > MaxDropoffHeight && 
		Origin.z <= FloorZ && !bDropOff && !bOnMobj && !bFloat)
	{
		// We call the CheckDropoff here to determine if the
		// bounding box actually needs to be used below
		angle = CheckDropOff();

		if (angle)
		{
			// [Graf Zahl] I have changed TryMove to only apply this logic when
			// being called from here. bAavoidingDropoff activates the code that
			// allows monsters to move away from a dropoff. This is different from
			// MBF which requires unconditional use of the altered logic and therefore
			// forcing a massive change in the monster behavior to use this.

			// Move away from dropoff at a standard speed.
			// Multiple contacted linedefs are cumulative (e.g. hanging over corner)
			deltaxx -= sin(angle) * 32.0;
			deltayy += cos(angle) * 32.0;

			// use different dropoff movement logic in TryMove
			bAvoidingDropoff = true;
			DO_NewChaseDir(deltaxx, deltayy);
			bAvoidingDropoff = false;
		
			// If moving away from dropoff, set MoveCount to 1 so that
			// small steps are taken to get monster away from dropoff.
			MoveCount = 1;
			return;
		}
	}
	DO_NewChaseDir(deltax, deltay);
}

//**************************************************************************
//
//  AIMING
//
//**************************************************************************

//==========================================================================
//
//  PTR_AimTraverse
//
//  Sets linetaget and aim_slope when a target is aimed at.
//
//==========================================================================

bool PTR_AimTraverse(intercept_t * in)
{
	line_t *li;
	Actor th;
	float thingtopslope;
	float thingbottomslope;
	float dist;
	float slope;
	opening_t *open;

	if (in->bIsALine)
	{
		TVec hit_point;

		li = in->line;

		if (!(li->flags & ML_TWOSIDED))
			return false;	// stop

		// Crosses a two sided line.
		// A two sided line will restrict
		// the possible target ranges.
		dist = aim_range * in->frac;
		hit_point = Origin + dist * aim_dir;
		open = LineOpenings(li, hit_point);
		open = FindOpening(open, hit_point.z, hit_point.z);

		if (!open || open->bottom >= open->top)
			return false;	// stop

		dist = aim_range2d * in->frac;
		if (li->frontsector->floorheight != li->backsector->floorheight)
		{
			slope = (open->bottom - aim_z) / dist;
			if (slope > aim_bottomslope)
				aim_bottomslope = slope;
		}

		if (li->frontsector->ceilingheight != li->backsector->ceilingheight)
		{
			slope = (open->top - aim_z) / dist;
			if (slope < aim_topslope)
				aim_topslope = slope;
		}

		if (aim_topslope <= aim_bottomslope)
			return false;	// stop

		return true;	// shot continues
	}

	// shoot a thing
	th = Actor(in->Thing);
	if (th == self)
		return true;	// can't shoot self

	if (!th.bShootable)
		return true;	// corpse or something

	if (th.Class == Pod)
	{
		// Can't auto-aim at pods
		return true;
	}

#ifdef FIXME	//  Maybe enable this
	if (th.player && netgame && !deathmatch)
	{
		// don't aim at fellow co-op players
		return true;
	}
#endif

	// check angles to see if the thing can be aimed at
	dist = aim_range2d * in->frac;
	thingtopslope = (th.Origin.z + th.Height - aim_z) / dist;

	if (thingtopslope < aim_bottomslope)
		return true;	// shot over the thing

	thingbottomslope = (th.Origin.z - aim_z) / dist;

	if (thingbottomslope > aim_topslope)
		return true;	// shot under the thing

	// this thing can be hit!
	if (thingtopslope > aim_topslope)
		thingtopslope = aim_topslope;

	if (thingbottomslope < aim_bottomslope)
		thingbottomslope = aim_bottomslope;

	aim_slope = (thingtopslope + thingbottomslope) / 2.0;
	linetarget = th;

	return false;	// don't go any farther
}

//==========================================================================
//
//  AimLineAttack
//
//==========================================================================

TVec AimLineAttack(TAVec angles, float distance)
{
	float x2;
	float y2;
	float topangle;
	float botangle;
	TVec vOut;

	AngleVector(&angles, &aim_dir);
	x2 = Origin.x + distance * aim_dir.x;
	y2 = Origin.y + distance * aim_dir.y;
	aim_z = Origin.z + Height / 2.0 + 8.0 - FloorClip;
	aim_range2d =
		Length(vector(distance * aim_dir.x, distance * aim_dir.y, 0.0));

	// can't shoot outside view angles
	topangle = AngleMod180(-angles.pitch + 30.0);
	botangle = AngleMod180(-angles.pitch - 30.0);
	if (topangle > 89.0)
		topangle = 89.0;
	if (botangle < -89.0)
		botangle = -89.0;
	aim_topslope = tan(topangle);
	aim_bottomslope = tan(botangle);

	aim_range = distance;
	linetarget = none;

	P_PathTraverse(Origin.x, Origin.y, x2, y2,
		PT_ADDLINES | PT_ADDTHINGS, self, 'PTR_AimTraverse');

	if (linetarget)
	{
		angles.pitch = -atan(aim_slope);
	}

	AngleVector(&angles, &vOut);
	return vOut;
}

//===========================================================================
//
//	Aim
//
//===========================================================================

TVec Aim(float yaw, float dist)
{
	TAVec angles;
	TVec dir;

	//
	// see which target is to be aimed at
	//
	angles = Angles;
	angles.yaw = yaw;

	dir = AimLineAttack(angles, dist);
	if (!linetarget)
	{
		angles.yaw = AngleMod360(angles.yaw + 45.0 / 8.0);
		dir = AimLineAttack(angles, dist);
		if (!linetarget)
		{
			angles.yaw = AngleMod360(angles.yaw - 45.0 / 4.0);
			dir = AimLineAttack(angles, dist);
			if (!linetarget)
			{
				angles.yaw = AngleMod360(angles.yaw + 45.0 / 8.0);
				AngleVector(&angles, &dir);
			}
		}
	}
	return dir;
}

//**************************************************************************
//
//  SHOOTING
//
//**************************************************************************

//==========================================================================
//
//  ShootHitPlane
//
//==========================================================================

bool ShootHitPlane(sec_plane_t * plane)
{
	float org_dist;
	float hit_dist;

	if (plane->flags & SPF_NOBLOCKSHOOT)
	{
		//  Doesn't block shooting
		return true;
	}
	org_dist = DotProduct(shoot_linestart, plane->normal) - plane->dist;
	if (org_dist < 0.0)
	{
		//  Don't shoot back side
		return true;
	}
	hit_dist = DotProduct(shoot_lineend, plane->normal) - plane->dist;
	if (hit_dist >= 0.0)
	{
		//  Didn't hit plane
		return true;
	}

	//  Hit plane
	if (plane->pic == Level.Game.skyflatnum)
	{
		// don't shoot the sky!
		return false;
	}

	//  If we are shooting floor or ceiling we are adjusting position
	// to spawn puff on floor or ceiling, not on wall
	shoot_lineend -= (shoot_lineend - shoot_linestart) * hit_dist / (hit_dist - org_dist);

	// position a bit closer
	shoot_lineend += 4.0 * plane->normal;

	// Spawn bullet puffs.
	SpawnPuff(shoot_lineend, shootPuffType);

	// don't go any farther
	return false;
}

//==========================================================================
//
//  ShootCheckPlanes
//
//==========================================================================

bool ShootCheckPlanes(sector_t * sec)
{
	sec_region_t *reg;
	sec_region_t *startreg;

	startreg = PointInRegion(sec, shoot_linestart);
	for (reg = startreg; reg; reg = reg->next)
	{
		if (!ShootHitPlane(reg->floor))
		{
			//  Hit floor
			return false;
		}
		if (!ShootHitPlane(reg->ceiling))
		{
			//  Hit ceiling
			return false;
		}
	}
	for (reg = startreg->prev; reg; reg = reg->prev)
	{
		if (!ShootHitPlane(reg->floor))
		{
			//  Hit floor
			return false;
		}
		if (!ShootHitPlane(reg->ceiling))
		{
			//  Hit ceiling
			return false;
		}
	}
	return true;
}

//==========================================================================
//
//  PTR_ShootTraverse
//
//==========================================================================

bool PTR_ShootTraverse(intercept_t * in)
{
	TVec hit_point;
	line_t *li;
	Actor th;

	if (in->bIsALine)
	{
		sector_t *sec;

		li = in->line;
		hit_point = shoot_origin + (shoot_range * in->frac) * shoot_dir;
		if (li->flags & ML_TWOSIDED && PointOnPlaneSide(shoot_origin, li))
		{
			sec = li->backsector;
		}
		else
		{
			sec = li->frontsector;
		}

		shoot_lineend = hit_point;

		//  Check for shooting floor or ceiling
		if (!ShootCheckPlanes(sec))
		{
			return false;
		}

		shoot_linestart = shoot_lineend;

		//  Execute line special after checking for hitting floor or ceiling
		// when we know that it actally hits line
		if (li->special)
		{
			HereticLevelInfo(Level).ActivateLine(li, self, 0, SPAC_IMPACT);
		}

		if (li->flags & ML_TWOSIDED)
		{
			// crosses a two sided line
			opening_t *open;
			float opentop = 0.0;

			open = LineOpenings(li, hit_point);
			if (open)
			{
				opentop = open->top;
			}
			while (open)
			{
				if (open->bottom <= hit_point.z && open->top >= hit_point.z)
				{
					// shot continues
					return true;
				}
				open = open->next;
			}
			if (li->frontsector->ceiling.pic == Level.Game.skyflatnum &&
				li->backsector->ceiling.pic == Level.Game.skyflatnum &&
				hit_point.z > opentop)
			{
				// it's a sky hack wall
				return false;
			}
		}

		//  Hit line

		// position a bit closer
		hit_point -= 4.0 * shoot_dir;

		// Spawn bullet puffs.
		SpawnPuff(hit_point, shootPuffType);

		// don't go any farther
		return false;
	}

	// shoot a thing
	th = Actor(in->Thing);

	if (th == self)
		return true;	// can't shoot self

	if (!th.bShootable)
		return true;	// corpse or something

	// check angles to see if the thing can be aimed at
	hit_point = shoot_origin + (shoot_range * in->frac) * shoot_dir;

	if (th.Origin.z + th.Height < hit_point.z)
		return true;	// shot over the thing

	if (th.Origin.z > hit_point.z)
		return true;	// shot under the thing

	// hit thing
	// position a bit closer
	hit_point -= 10.0 * shoot_dir;

	//  check for physical attacks on a ghost
	if (th.Translucency && Player(Player).ReadyWeapon == wp_staff)
	{
		return true;
	}

	if (shootPuffType == BlasterPuff1)
	{
		// Make blaster big puff
		Actor A;

		A = Spawn(BlasterPuff2, hit_point);
		A.PlaySound('weapons/blastershoot', CHAN_VOICE);

		MSG_Select(MSG_SV_DATAGRAM);
		if (MSG_CheckSpace(8))
		{
			MSG_WriteByte(HereticDefs::svc_explosion);
			MSG_WriteByte(HereticDefs::EF_DL_BLUE);
			MSG_WriteShort(ftoi(hit_point.x));
			MSG_WriteShort(ftoi(hit_point.y));
			MSG_WriteShort(ftoi(hit_point.z));
		}
	}
	else
	{
		SpawnPuff(hit_point, shootPuffType);
	}
	if (la_damage)
	{
		if (!th.bNoBlood && P_Random() < 192)
		{
			MSG_Select(MSG_SV_DATAGRAM);
			if (MSG_CheckSpace(8))
			{
				MSG_WriteByte(HereticDefs::svc_blood);
				MSG_WriteShort(ftoi(hit_point.x));
				MSG_WriteShort(ftoi(hit_point.y));
				MSG_WriteShort(ftoi(hit_point.z));
				MSG_WriteByte(la_damage > 255 ? 255 : la_damage);
			}

			th.SpawnBloodSplatter(hit_point);
		}
		th.Damage(self, self, la_damage);
	}

	// don't go any farther
	return false;
}

//==========================================================================
//
//  LineAttack
//
//  If damage == 0, it is just a test trace that will leave linetarget set.
//
//==========================================================================

int LineAttack(TVec dir, float distance, int damage, classid PuffType)
{
	TVec dst;

	la_damage = damage;
	shootPuffType = PuffType;

	shoot_origin = Origin;
	shoot_origin.z += Height * 0.5 + 8.0 - FloorClip;

	shoot_dir = dir;
	shoot_range = distance;

	dst = shoot_origin + shoot_range * shoot_dir;
	shoot_linestart = shoot_origin;
	if (!P_PathTraverse(Origin.x, Origin.y, dst.x, dst.y,
			PT_ADDLINES | PT_ADDTHINGS, self, 'PTR_ShootTraverse'))
	{
		return false;
	}
	shoot_lineend = dst;
	return ShootCheckPlanes(XLevel.PointInSector(dst));
}

//==========================================================================
//
//  A_FreeTargMobj
//
//==========================================================================

void A_FreeTargMobj()
{
	Velocity = vector(0.0, 0.0, 0.0);
	Origin.z = CeilingZ + 4.0;
	bSolid = false;
	bShootable = false;
	bFloat = false;
	bSkullFly = false;
	bNoGravity = true;
	bDropOff = true;
	bCorpse = true;
	bNoPassMobj = true;
	Player = none;
	bIsPlayer = false;
}

//==========================================================================
//
//  A_Scream
//
//==========================================================================

void A_Scream()
{
	if (Class == ChickenPlayer || Class == Sorcerer1 || Class == Minotaur)
	{
		// Make boss death sounds full volume
		PlayFullVolumeSound(DeathSound, CHAN_VOICE);
	}
	else
	{
		PlaySound(DeathSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//  A_Explode
//
//  Handles a bunch of exploding things.
//
//==========================================================================

void A_Explode()
{
	int damage;

	damage = 128;
	if (Class == FireBomb)
	{
		// Time Bombs
		Origin.z += 32.0;
		Translucency = 0;
	}
	else if (Class == MinotaurFloorFire)
	{
		// Minotaur floor fire
		damage = 24;
	}
	else if (Class == Sorcerer2Missile1)
	{
		// D'Sparil missile
		damage = 80 + (P_Random() & 31);
	}
	RadiusAttack(damage, 0, 0);
	HitFloorEffect();
	if (Class == FireBomb)
	{
		MSG_Select(MSG_SV_DATAGRAM);
		if (MSG_CheckSpace(8))
		{
			MSG_WriteByte(HereticDefs::svc_explosion);
			MSG_WriteByte(HereticDefs::EF_DL_WHITE);
			MSG_WriteShort(ftoi(Origin.x));
			MSG_WriteShort(ftoi(Origin.y));
			MSG_WriteShort(ftoi(Origin.z));
		}
	}
	if (Class == Pod)
	{
		MSG_Select(MSG_SV_DATAGRAM);
		if (MSG_CheckSpace(8))
		{
			MSG_WriteByte(HereticDefs::svc_explosion);
			MSG_WriteByte(HereticDefs::EF_DL_GREEN);
			MSG_WriteShort(ftoi(Origin.x));
			MSG_WriteShort(ftoi(Origin.y));
			MSG_WriteShort(ftoi(Origin.z));
		}
	}
	if (ExplodeEffect)
	{
		MSG_Select(MSG_SV_DATAGRAM);
		if (MSG_CheckSpace(8))
		{
			MSG_WriteByte(HereticDefs::svc_explosion);
			MSG_WriteByte(ExplodeEffect);
			MSG_WriteShort(ftoi(Origin.x));
			MSG_WriteShort(ftoi(Origin.y));
			MSG_WriteShort(ftoi(Origin.z));
		}
	}
}

//==========================================================================
//
//  SpawnPuff
//
//==========================================================================

void SpawnPuff(TVec org, classid PuffType)
{
	Actor puff;

	org.z += (Random() - Random()) * 4.0;
	puff = Spawn(PuffType, org);
	if (puff.AttackSound)
	{
		puff.PlaySound(puff.AttackSound, CHAN_VOICE);
	}
	if (PuffType == BeakPuff || PuffType == StaffPuff)
	{
		puff.Velocity.z = 1.0 * 35.0;
	}
	else if (PuffType == GauntletPuff1 || PuffType == GauntletPuff2)
	{
		puff.Velocity.z = 0.8 * 35.0;
	}
	if (PuffType == GoldWandPuff1)
	{
		MSG_Select(MSG_SV_DATAGRAM);
		if (MSG_CheckSpace(8))
		{
			MSG_WriteByte(HereticDefs::svc_explosion);
			MSG_WriteByte(HereticDefs::EF_DL_WHITE);
			MSG_WriteShort(ftoi(org.x));
			MSG_WriteShort(ftoi(org.y));
			MSG_WriteShort(ftoi(org.z));
		}
	}
	if (PuffType == BlasterPuff1)
	{
		MSG_Select(MSG_SV_DATAGRAM);
		if (MSG_CheckSpace(8))
		{
			MSG_WriteByte(HereticDefs::svc_explosion);
			MSG_WriteByte(HereticDefs::EF_DL_BLUE);
			MSG_WriteShort(ftoi(org.x));
			MSG_WriteShort(ftoi(org.y));
			MSG_WriteShort(ftoi(org.z));
		}
	}
}

__states__
{
	S_FREETARGMOBJ('ACLO', 4, 30.0, none) { A_FreeTargMobj(); }
}

defaultproperties
{
	MaxStepHeight = 24.0;
	bCheckLineBlocking = true;
	bCheckLineBlockMonsters = false;
	LightOffset = vector(0.0, 0.0, 0.0);
	LightColour = 0xffffffff;
	LightRadius = 128.0;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.32  2006/04/14 14:57:30  firebrand_kh
//  Added static light flag and properties
//
//  Revision 1.31  2006/04/09 15:36:11  dj_jl
//  Fixed uninitialised blocking mobj pointer.
//
//  Revision 1.30  2006/03/28 14:36:12  firebrand_kh
//  Properly remove onmobj flag
//
//  Revision 1.29  2006/03/21 15:07:40  firebrand_kh
//  Fixes for onmobj checks
//
//  Revision 1.28  2006/03/13 18:46:37  dj_jl
//  Added function to check if a state is in the range.
//
//  Revision 1.27  2006/03/12 19:56:46  dj_jl
//  States as objects, added state variable type.
//
//  Revision 1.26  2006/03/02 18:33:23  dj_jl
//  Don't use game specific classes in common.
//
//  Revision 1.25  2006/02/28 22:45:45  dj_jl
//  Replaced defines with constants.
//
//  Revision 1.24  2006/02/17 19:06:52  dj_jl
//  Moved common defs to classes.
//
//  Revision 1.23  2006/02/15 23:33:11  dj_jl
//  Moved all server progs global variables to classes.
//
//  Revision 1.22  2006/02/13 18:30:16  dj_jl
//  Moved all server progs global functions to classes.
//
//  Revision 1.21  2006/02/05 18:50:55  dj_jl
//  Moved common utils to level info class or built-in.
//
//  Revision 1.20  2005/12/27 22:22:28  dj_jl
//  Created level info class, moved action special handling to it.
//
//  Revision 1.19  2005/12/12 20:33:49  dj_jl
//  Cleaned up state types.
//
//  Revision 1.18  2005/12/11 21:31:40  dj_jl
//  Made path traversal callbacks class members.
//
//  Revision 1.17  2005/12/07 22:54:18  dj_jl
//  Moved compiler generated data out of globals.
//
//  Revision 1.16  2005/11/30 23:52:04  dj_jl
//  Switch statement requires integer.
//
//  Revision 1.15  2005/11/18 23:36:50  dj_jl
//  Renamed sounds.
//
//  Revision 1.14  2005/07/09 13:55:46  dj_jl
//  Scrolers carrying objects.
//
//  Revision 1.13  2005/05/26 17:04:11  dj_jl
//  Some fixes
//
//  Revision 1.12  2005/03/28 07:43:29  dj_jl
//  Some Boom line specials and other improvements.
//
//  Revision 1.11  2005/03/16 15:04:21  dj_jl
//  More work on line specials.
//
//  Revision 1.10  2004/12/27 12:23:12  dj_jl
//  Multiple small changes for version 1.16
//
//  Revision 1.9  2004/11/22 07:36:25  dj_jl
//  Implemented all sector specials in all games.
//
//  Revision 1.8  2004/11/01 07:38:22  dj_jl
//  Almost all Hexen line specials are available in all games.
//
//  Revision 1.7  2004/08/23 19:23:56  dj_jl
//  Moved weapon utilites to player class.
//
//  Revision 1.6  2004/08/22 19:23:24  dj_jl
//  Moved many functions to player class.
//
//  Revision 1.5  2004/03/12 07:21:39  dj_jl
//  Monster desth special action
//
//  Revision 1.4  2003/11/12 16:49:43  dj_jl
//  Changed player structure into a class
//
//  Revision 1.3  2003/07/11 16:47:39  dj_jl
//  Made array of players with pointers
//
//  Revision 1.2  2003/03/08 12:34:45  dj_jl
//  Removing class pointers.
//
//  Revision 1.1  2002/10/26 16:32:22  dj_jl
//  New style of defining classes.
//
//**************************************************************************
