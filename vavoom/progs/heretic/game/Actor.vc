//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class Actor : EntityEx
	abstract;

const float TELEFOGHEIGHT 	= 32.0;

const int BASETHRESHOLD		= 100;	// follow a player exlusively for 3 seconds

const float FLOATRANDZ		= 99998.0;

const float MELEERANGE		= 64.0;
const float MISSILERANGE	= (32.0 * 64.0);

const float BONUSADD		= 0.2;

const float MONS_LOOK_RANGE	= (20.0 * 64.0);
const int MONS_LOOK_LIMIT	= 64;

bool bThruGhost;		// missile will pass through ghosts
bool bSpawnFloat;		// spawn random float z
bool bRip;				// missile rips through solid targets
bool bPushable;			// can be pushed by other moving mobjs
bool bBoss;				// mobj is a major boss
bool bFireDamage;		// does fire damage
bool bNoDamageThrust;	// does not thrust target when damaging
bool bNoMorph;			// Don't morph into chicken.

int Special1;	// Special info
class<Actor> SpecialCID;

//===========================================================================
//
//  SetInstigator
//
//===========================================================================

void SetInstigator(Entity NewInstigator)
{
	Target = Actor(NewInstigator);
}

//===========================================================================
//
//  PlaySightSound
//
//===========================================================================

void PlaySightSound()
{
	if (SightSound)
	{
		PlaySound(SightSound, CHAN_VOICE);
	}
}

//===========================================================================
//
//  SetDropped
//
//===========================================================================

void SetDropped()
{
	bDropped = true;
}

//===========================================================================
//
//  StartFloatBob
//
//===========================================================================

void StartFloatBob(Entity Src)
{
	if (bFloatBob)
	{
		Origin.z = Src.Origin.z - Src.FloorZ;
		SetOrigin2(Origin);
	}
}

//===========================================================================
//
//  SaveFloatBobOffset
//
//===========================================================================

void SaveFloatBobOffset()
{
	if (bFloatBob)
	{
		Special1f = Origin.z - FloorZ;
	}
}

//===========================================================================
//
//  ThingDestroy
//
//===========================================================================

bool ThingDestroy()
{
	if (bShootable)
	{
		Damage(none, none, 10000);
		return true;
	}
	return false;
}

//===========================================================================
//
//  ThingDamage
//
//===========================================================================

void ThingDamage(int Amount)
{
	Damage(none, none, Amount);
}

//===========================================================================
//
//  IsTeleportSpot
//
//===========================================================================

bool IsTeleportSpot()
{
	return !!TeleportDest(self);
}

//===========================================================================
//
//  IsTeleportSpot2
//
//===========================================================================

bool IsTeleportSpot2()
{
	return !!TeleportDest2(self);
}

//===========================================================================
//
//  CanTeleport
//
//===========================================================================

bool CanTeleport()
{
	return !bNoTeleport;
}

//===========================================================================
//
//  SetPainState
//
//===========================================================================

void SetPainState()
{
	SetState(PainState);
}

//===========================================================================
//
//  IsPointPusher
//
//===========================================================================

bool IsPointPusher()
{
	return !!PointPusher(self);
}

//===========================================================================
//
//  IsPointPuller
//
//===========================================================================

bool IsPointPuller()
{
	return !!PointPuller(self);
}

//===========================================================================
//
//  CanWindThrust
//
//===========================================================================

bool CanWindThrust()
{
	return bWindThrust;
}

//===========================================================================
//
//  GetPlayerViewHeight
//
//===========================================================================

float GetPlayerViewHeight()
{
	return Player(Player).ViewHeight;
}

//===========================================================================
//
//  MoveThing
//
//===========================================================================

bool MoveThing(TVec Pos, bool Fog)
{
	TVec OldOrg = Origin;

	UnlinkFromWorld();
	Origin = Pos;
	LinkToWorld();
	if (TestLocation())
	{
		if (Fog)
		{
			LineSpecialLevelInfo(Level).SpawnTeleportFog(Pos);
			LineSpecialLevelInfo(Level).SpawnTeleportFog(OldOrg);
		}
		return true;
	}
	else
	{
		UnlinkFromWorld();
		Origin = OldOrg;
		LinkToWorld();
		return false;
	}
}

//==========================================================================
//
//  HITDICE
//
//  Most damage in HERETIC and HEXEN defined using HITDICE
//
//==========================================================================

int HITDICE(int a)
{
	return (1 + (P_Random() & 7)) * a;
}

//==========================================================================
//
//  SetOrigin2
//
//==========================================================================

void SetOrigin2(TVec origin)
{
	float space;

	Origin = origin;
	// Set subsector and/or block links.
	LinkToWorld();
	if (origin.z == ONFLOORZ)
	{
		Origin.z = FloorZ;
	}
	else if (origin.z == ONCEILINGZ)
	{
		Origin.z = CeilingZ - Height;
	}
	else if (origin.z == FLOATRANDZ)
	{
		space = CeilingZ - Height - FloorZ;
		if (space > 48.0)
		{
			space -= 40.0;
			Origin.z = space * Random() + FloorZ + 40.0;
		}
		else
		{
			Origin.z = FloorZ;
		}
	}
	else if (bFloatBob)
	{
		origin.z = FloorZ + origin.z;	// artifact z passed in as height
	}
	VTerrainInfo* TInfo = GetFloorType();
	if (bFloorClip && TInfo->bLiquid && FloorZ == Sector->floorheight)
	{
		FloorClip = TInfo->FootClip;
	}
	else
	{
		FloorClip = 0.0;
	}
}

//==========================================================================
//
//	OnMapSpawn
//
//==========================================================================

void OnMapSpawn(mthing_t * mthing)
{
	if (Level.Game.gameskill == sk_nightmare)
	{
		ReactionCount = 0;
	}

	LastLook = P_Random() % MAXPLAYERS;

	bCheckLineBlocking = false;
	bCheckLineBlockMonsters = false;
	if (!bMissile)
	{
		bCheckLineBlocking = true;
		if (Class != HereticPlayer)
		{
			bCheckLineBlockMonsters = true;
		}
	}
	else
	{
		MaxStepHeight = 4.0;
	}

	// Set the state, but do not use P_SetMobjState, because action
	// routines can't be called yet.  If the spawnstate has an action
	// routine, it will not be called.
	SetInitialState(IdleState);

	if (mthing)
	{
		float x, y, z;

		x = mthing->x;
		y = mthing->y;
		if (bSpawnCeiling)
		{
			z = ONCEILINGZ;
		}
		else if (bSpawnFloat)
		{
			z = FLOATRANDZ;
		}
		else if (bFloatBob)
		{
			z = mthing->height;
		}
		else
		{
			z = ONFLOORZ;
		}
		SetOrigin2(vector(x, y, z));
		if (bFloatBob)
		{
			// Seed random starting index for bobbing motion
			Health = P_Random();
			Special1f = mthing->height;
		}
		if (z == ONFLOORZ)
		{
			Origin.z += mthing->height;
		}
		else if (z == ONCEILINGZ)
		{
			Origin.z -= mthing->height;
		}
		LinkToWorld();
		TID = mthing->tid;
		Special = mthing->special;
		Args[0] = mthing->arg1;
		Args[1] = mthing->arg2;
		Args[2] = mthing->arg3;
		Args[3] = mthing->arg4;
		Args[4] = mthing->arg5;
		if (StateTime > 0.0)
		{
			StateTime = 0.1 + Random() * StateTime;
		}
		if (bCountKill)
		{
			Level.TotalKills++;
			Level.CopyMThing(mthing, &SpawnPoint);
		}
		if (bCountItem)
		{
			Level.TotalItems++;
		}
		Angles.yaw = itof(45 * (mthing->angle / 45));
		if (mthing->options & HereticLevelInfo::MTF_AMBUSH)
		{
			bAmbush = true;
		}
		if (mthing->options & HereticLevelInfo::MTF_DORMANT)
		{
			bDormant = true;
			StateTime = -1.0;
		}
	}
	else
	{
		SetOrigin2(Origin);
	}

	if (bStaticLight && mthing && !TID)
	{
		if (LightColour == 0xffffffff)
		{
			Level.AddStaticLight(Origin + LightOffset, mthing->arg1 ?
				itof(mthing->arg1) * 8.0 : LightRadius);
		}
		else
		{
			Level.AddStaticLightRGB(Origin + LightOffset, mthing->arg1 ?
				itof(mthing->arg1) * 8.0 : LightRadius, LightColour);
		}
	}
}

//===========================================================================
//
//  FaceActor
//
//  Returns 1 if 'source' needs to turn clockwise, or 0 if 'source' needs
// to turn counter clockwise.  'delta' is set to the amount 'source'
// needs to turn.
//
//===========================================================================

int FaceActor(Actor Other, float * delta)
{
	float diff;
	float angle1;
	float angle2;

	angle1 = Angles.yaw;
	angle2 = atan2(Other.Origin.y - Origin.y, Other.Origin.x - Origin.x);
	if (angle2 > angle1)
	{
		diff = AngleMod360(angle2 - angle1);
		if (diff > 180.0)
		{
			*delta = 360.0 - diff;
			return 0;
		}
		else
		{
			*delta = diff;
			return 1;
		}
	}
	else
	{
		diff = AngleMod360(angle1 - angle2);
		if (diff > 180.0)
		{
			*delta = 360.0 - diff;
			return 1;
		}
		else
		{
			*delta = diff;
			return 0;
		}
	}
}

//===========================================================================
//
//  ExplodeMissile
//
//===========================================================================

bool ExplodeMissile()
{
	Velocity = vector(0.0, 0.0, 0.0);
	SetState(DeathState);
	//tics -= P_Random()&3;
	bMissile = false;
	if (DeathSound)
	{
		PlaySound(DeathSound, CHAN_VOICE);
	}
	if (Effects & HereticDefs::EF_DLIGHT_MASK)
	{
		SendExplosion(Effects & HereticDefs::EF_DLIGHT_MASK, Origin);
		Effects &= ~HereticDefs::EF_DLIGHT_MASK;
	}
	return true;
}

//==========================================================================
//
//  SendExplosion
//
//==========================================================================

final void SendExplosion(int etype, TVec org)
{
	int i;

	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (!Level.Game.Players[i])
			continue;
		if (!Level.Game.Players[i].bSpawned)
			continue;
		Player(Level.Game.Players[i]).ClientExplosion(etype, org);
	}
}

//==========================================================================
//
//  Died
//
//==========================================================================

void Died(EntityEx source)
{
	bShootable = false;
	bNoGravity = false;
	bFloat = false;
	bSkullFly = false;
	bDropOff = true;
	bCorpse = true;
	bNoPassMobj = true;
	Height /= 4.0;
	if (bCountKill && Special)
	{
		// Initiate monster death actions
		Level.ExecuteActionSpecial(Special, Args[0], Args[1], Args[2],
			Args[3], Args[4], NULL, 0, self);
	}
	if (source && source.bIsPlayer)
	{
		if (bCountKill)
		{
			// Count for intermission
			source.Player.KillCount++;
		}
		if (bIsPlayer)
		{
			if (source.Player.bIsBot)
			{
				Player(source.Player).Bot.Killed(self);
			}

			if (Player.bIsBot)
			{
				Player(Player).Bot.Died(Actor(source));
			}

			// Frag stuff
			if (self == source)
			{
				// Self-frag
				Player.FragsStats[Player.GetPlayerNum()]--;
				Player.Frags--;
			}
			else
			{
				source.Player.FragsStats[Player.GetPlayerNum()]++;
				source.Player.Frags++;
				source.PlaySound('misc/frag', CHAN_ITEM);
				if (Player(source.Player).ChickenTime)
				{
					// Make a super chicken
					Player(source.Player).GivePower(pw_weaponlevel2);
				}
			}
		}
	}
	else if (!Level.Game.netgame && bCountKill)
	{
		// Count all monster deaths
		Level.Game.Players[0].KillCount++;
	}
	if (bCountKill)
		Level.CurrentKills++;
	if (bIsPlayer)
	{
		if (!source)
		{
			// Self-frag
			Player.FragsStats[Player.GetPlayerNum()]--;
			Player.Frags--;
		}
		bSolid = false;
		bFly = false;
		Player(Player).Powers[pw_flight] = 0.0;
		Player(Player).Powers[pw_weaponlevel2] = 0.0;
		Player.PlayerState = PST_DEAD;
		Player(Player).DropWeapon();
		if (bFireDamage)
		{
			// Player flame death
			SetState(PlayerPawn(self).FireDeathState);
			return;
		}
	}
	if (Health < GibsHealth && GibsDeathState)
	{
		// Extreme death
		SetState(GibsDeathState);
	}
	else
	{
		// Normal death
		SetState(DeathState);
	}
	StateTime -= Random() * 0.1;
}

//==========================================================================
//
//  MinotaurSlam
//
//==========================================================================

void MinotaurSlam(Actor Other)
{
	float angle;
	float thrust;

	angle = atan2(Other.Origin.y - Origin.y, Other.Origin.x - Origin.x);
	thrust = 16.0 + Random() * 4.0;
	Other.Velocity.x += thrust * cos(angle) * 35.0;
	Other.Velocity.y += thrust * sin(angle) * 35.0;
	Other.Damage(none, none, HITDICE(6));
	if (Other.Player)
	{
		Other.ReactionTime = 0.4 + Random() * 0.2;
	}
}

//==========================================================================
//
//  TouchWhirlwind
//
//==========================================================================

void TouchWhirlwind(Actor Other)
{
	float randVal;

	Other.Angles.yaw = AngleMod360(Other.Angles.yaw +
		(Random() - Random()) * 45.0 / 2.0);
	Other.Velocity.x += (Random() - Random()) * 4.0 * 35.0;
	Other.Velocity.y += (Random() - Random()) * 4.0 * 35.0;
	if (XLevel.TicTime & 16 && !Other.bBoss)
	{
		randVal = Random() * 4.0;
		if (randVal > 2.5)
		{
			randVal = 2.5;
		}
		Other.Velocity.z += randVal * 35.0;
		if (Other.Velocity.z > 12.0 * 35.0)
		{
			Other.Velocity.z = 12.0 * 35.0;
		}
	}
	if (!(XLevel.TicTime & 7))
	{
		Other.Damage(none, none, 3);
	}
}

//==========================================================================
//
//  ChickenMorphPlayer
//
//  Returns true if the player gets turned into a chicken.
//
//==========================================================================

bool ChickenMorphPlayer()
{
	Actor fog;
	Actor chicken;

	if (Player(Player).ChickenTime)
	{
		if ((Player(Player).ChickenTime < Player::CHICKENTIME - 1.0) &&
			!Player(Player).Powers[pw_weaponlevel2])
		{
			// Make a super chicken
			Player(Player).GivePower(pw_weaponlevel2);
		}
		return false;
	}
	if (Player(Player).Powers[pw_invulnerability])
	{
		// Immune when invulnerable
		return false;
	}

	fog = Spawn(TeleportFog, Origin + vector(0.0, 0.0, TELEFOGHEIGHT));
	fog.PlaySound('misc/teleport', CHAN_VOICE);

	chicken = Spawn(ChickenPlayer, Origin);
	chicken.Special1 = Player(Player).ReadyWeapon;
	chicken.Angles.yaw = Angles.yaw;
	chicken.Player = Player;
	chicken.bIsPlayer = true;
	chicken.Health = Player::MAXCHICKENHEALTH;
	Player.Health = chicken.Health;
	Player.MO = chicken;
	Player(Player).ArmorPoints = 0;
	Player(Player).ArmorType = 0;
	Player(Player).Powers[pw_invisibility] = 0.0;
	Player(Player).Powers[pw_weaponlevel2] = 0.0;
	chicken.bFly = bFly;
	Player(Player).ChickenTime = Player::CHICKENTIME;
	Player(Player).ActivateBeak();

	SetState(S_FREETARGMOBJ);

	return true;
}

//==========================================================================
//
//  ChickenMorph
//
//==========================================================================

bool ChickenMorph()
{
	Actor fog;
	Actor chicken;
	int i;

	if (bIsPlayer)
	{
		return false;
	}
	if (bNoMorph)
	{
		return false;
	}

	fog = Spawn(TeleportFog, Origin + vector(0.0, 0.0, TELEFOGHEIGHT));
	fog.PlaySound('misc/teleport', CHAN_VOICE);

	chicken = Spawn(Chicken, Origin);
	chicken.SpecialCID = class<Actor>(Class);
	chicken.Special1 = ftoi(Player::CHICKENTIME * 35.0) + P_Random();
	chicken.Alpha = Alpha;
	chicken.Target = Target;
	chicken.Angles.yaw = Angles.yaw;
	chicken.TID = TID;
	chicken.Special = Special;
	chicken.InsertIntoTIDList(TID);
	for (i = 0; i < 5; i++)
	{
		chicken.Args[i] = Args[i];
	}

	RemoveFromTIDList();

	SetState(S_FREETARGMOBJ);

	return true;
}

//==========================================================================
//
//  AutoUseChaosDevice
//
//==========================================================================

bool AutoUseChaosDevice()
{
	int i;

	for (i = 0; i < Player(Player).InventorySlotNum; i++)
	{
		if (Player(Player).Inventory[i].type == HereticDefs::arti_teleport)
		{
			Player(Player).PlayerUseArtifact(HereticDefs::arti_teleport);
			Health = (Health + 1) / 2;
			Player.Health = Health;
			return true;
		}
	}
	return false;
}

//==========================================================================
//
//  AutoUseHealth
//
//==========================================================================

void AutoUseHealth(int saveHealth)
{
	int i;
	int count;
	int normalCount;
	int normalSlot;
	int superCount;
	int superSlot;

	normalCount = 0;
	superCount = 0;
	for (i = 0; i < Player(Player).InventorySlotNum; i++)
	{
		if (Player(Player).Inventory[i].type == HereticDefs::arti_health)
		{
			normalSlot = i;
			normalCount = Player(Player).Inventory[i].count;
		}
		else if (Player(Player).Inventory[i].type == HereticDefs::arti_superhealth)
		{
			superSlot = i;
			superCount = Player(Player).Inventory[i].count;
		}
	}
	if ((Level.Game.gameskill == sk_baby) && (normalCount * 25 >= saveHealth))
	{
		// Use quartz flasks
		count = (saveHealth + 24) / 25;
		for (i = 0; i < count; i++)
		{
			Health += 25;
			Player(Player).PlayerRemoveArtifact(normalSlot);
		}
	}
	else if (superCount * 100 >= saveHealth)
	{
		// Use mystic urns
		count = (saveHealth + 99) / 100;
		for (i = 0; i < count; i++)
		{
			Health += 100;
			Player(Player).PlayerRemoveArtifact(superSlot);
		}
	}
	else if ((Level.Game.gameskill == sk_baby)
		&& (superCount * 100 + normalCount * 25 >= saveHealth))
	{
		// Use mystic urns and quartz flasks
		count = (saveHealth + 24) / 25;
		saveHealth -= count * 25;
		for (i = 0; i < count; i++)
		{
			Health += 25;
			Player(Player).PlayerRemoveArtifact(normalSlot);
		}
		count = (saveHealth + 99) / 100;
		for (i = 0; i < count; i++)
		{
			Health += 100;
			//  I found a bug. There must be used superSlot, not normalSlot.
			//  Also if player used all quartz flasks, superSlot may be
			// invalid, so it must be found again.
			Player(Player).PlayerRemoveArtifact(superSlot);
		}
	}
	Player.Health = Health;
}

//==========================================================================
//
//  Damage
//
//  Damages both enemies and players.
//  inflictor is the thing that caused the damage creature or missile, can
// be NULL (slime, etc)
//  source is the thing to target after taking damage creature or NULL
//  Source and inflictor are the same for melee attacks
//  source can be null for barrel explosions and other environmental stuff
//
//==========================================================================

void Damage(EntityEx inflictor, EntityEx source, int damage)
{
	int saved;

	if (!bShootable)
	{
		// Shouldn't happen
		return;
	}
	if (Health <= 0)
	{
		return;
	}
	if (bSkullFly)
	{
		if (Class == Minotaur)
		{
			// Minotaur is invulnerable during charge attack
			return;
		}
		Velocity = vector(0.0, 0.0, 0.0);
		SetState(SeeState);
	}
	if (bDormant)
	{
		// Invulnerable, and won't wake up
		return;
	}
	if (bIsPlayer && Level.Game.gameskill == sk_baby)
	{
		// Take half damage in trainer mode
		damage >>= 1;
	}
	// Special damage types
	if (inflictor)
	{
		if (inflictor.Class == EggFX)
		{
			if (bIsPlayer)
			{
				ChickenMorphPlayer();
			}
			else
			{
				ChickenMorph();
			}
			return;	// Always return
		}
		else if (inflictor.Class == Whirlwind)
		{
			Actor(inflictor).TouchWhirlwind(self);
			return;
		}
		else if (inflictor.Class == Minotaur)
		{
			if (inflictor.bSkullFly)
			{
				// Slam only when in charge mode
				Actor(inflictor).MinotaurSlam(self);
				return;
			}
		}
		else if (inflictor.Class == MaceFX4)	// Death ball
		{
			if (bBoss || Class == Ironlich)
			{
				// Don't allow cheap boss kills
			}
			else if (bIsPlayer)
			{
				// Player specific checks
				if (Player(Player).Powers[pw_invulnerability])
				{
					// Can't hurt invulnerable players
				}
				else if (AutoUseChaosDevice())
				{
					// Player was saved using chaos device
					return;
				}
				else
					damage = 10000;	// Something's gonna die
			}
			else
				damage = 10000;	// Something's gonna die
		}
		else if (inflictor.Class == PhoenixFX2)
		{
			// Flame thrower
			if (Player && P_Random() < 128)
			{
				// Freeze player for a bit
				ReactionTime += 0.125;
			}
		}
		else if (inflictor.Class == RainPillar ||	// Rain missiles
			inflictor.Class == RainPlayer2 ||
			inflictor.Class == RainPlayer3 ||
			inflictor.Class == RainPlayer4)
		{
			if (bBoss)
			{
				// Decrease damage for bosses
				damage = (P_Random() & 7) + 1;
			}
		}
		else if (inflictor.Class == HornRodFX2 ||
			inflictor.Class == PhoenixFX1)
		{
			if (Class == Sorcerer2 && P_Random() < 96)
			{
				// D'Sparil teleports away
				Sorcerer2(self).DSparilTeleport();
				return;
			}
		}
		else if (inflictor.Class == BlasterFX1 ||
			inflictor.Class == Ripper)
		{
			if (Class == Ironlich)
			{
				// Less damage to Ironlich bosses
				damage = P_Random() & 1;
				if (!damage)
				{
					return;
				}
			}
		}
	}
	// Push the target unless source is using the gauntlets
	if (inflictor && (!source || !source.bIsPlayer ||
			Player(source.Player).ReadyWeapon != wp_gauntlets) &&
			!Actor(inflictor).bNoDamageThrust)
	{
		TVec dir;
		float thrust;

		if (source && source.bIsPlayer && (source == inflictor)
			&& Player(source.Player).Powers[pw_weaponlevel2]
			&& Player(source.Player).ReadyWeapon == wp_staff)
		{
			// Staff power level 2
			thrust = 350.0;
		}
		else
		{
			thrust = itof(damage) / Mass * 656.25;
		}

		dir = GetCentre() - inflictor.GetCentre();
		if (bNoGravity)
		{
			dir.z = 0.0;
		}
		Velocity += Normalise(dir) * thrust;
	}

	//
	// player specific
	//
	if (bIsPlayer)
	{
		//	End of game hell hack.
		if ((Sector->special & SECSPEC_BASE_MASK) ==
			SECSPEC_DamageSuperHellslimeExit && damage >= Health)
		{
			damage = Health - 1;
		}

		if (damage < 1000 && ((Player(Player).Cheats & Player::CF_GODMODE) ||
			Player(Player).Powers[pw_invulnerability]))
		{
			return;
		}
		if (Player(Player).ArmorType)
		{
			if (Player(Player).ArmorType == 1)
			{
				saved = damage >> 1;
			}
			else
			{
				saved = (damage >> 1) + (damage >> 2);
			}
			if (Player(Player).ArmorPoints <= saved)
			{
				// armor is used up
				saved = Player(Player).ArmorPoints;
				Player(Player).ArmorType = 0;
			}
			Player(Player).ArmorPoints -= saved;
			damage -= saved;
		}
		if (damage >= Player.Health && ((Level.Game.gameskill == sk_baby) ||
			Level.Game.deathmatch) && !Player(Player).ChickenTime)
		{
			// Try to use some inventory health
			AutoUseHealth(damage - Health + 1);
		}
		Player.Health -= damage;	// mirror mobj health here for Dave
		if (Player.Health < 0)
		{
			Player.Health = 0;
		}
		Player(Player).Attacker = Actor(source);
		Player(Player).DamageFlash += itof(damage) / 35.0;	// add damage after armor / invuln
		if (Player(Player).DamageFlash > 3.0)
		{
			Player(Player).DamageFlash = 3.0;	// teleport stomp does 10k points...
		}
	}

	//
	// do the damage
	//
	Health -= damage;
	if (Health <= 0)
	{
		// Death
		Special1 = damage;
		if (Class == Pod && source && source.Class != Pod)
		{
			// Make sure players get frags for chain-reaction kills
			Target = Actor(source);
		}
		if (bIsPlayer && inflictor && !Player(Player).ChickenTime)
		{
			// Check for flame death
			if (Actor(inflictor).bFireDamage
				|| ((inflictor.Class == PhoenixFX1)
					&& (Health > -50) && (damage > 25)))
			{
				bFireDamage = true;
			}
		}
		Died(source);
		return;
	}
	if ((Random() < PainChance) && !bSkullFly)
	{
		bJustHit = true;	// fight back!
		SetState(PainState);
	}
	ReactionCount = 0;	// we're awake now...
	if (!Threshold && source && !Actor(source).bBoss &&
		!(Class == Sorcerer2 && source.Class == Wizard))
	{
		// Target actor is not intent on another actor,
		// so make him chase after source
		Target = Actor(source);
		Threshold = BASETHRESHOLD;
		if (State == IdleState && SeeState)
		{
			SetState(SeeState);
		}
	}
}

//==========================================================================
//
//  SpawnBloodSplatter
//
//==========================================================================

void SpawnBloodSplatter(TVec org, int damage)
{
	Actor mo;
	int i;

	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (!Level.Game.Players[i])
			continue;
		if (!Level.Game.Players[i].bSpawned)
			continue;
		Player(Level.Game.Players[i]).ClientBlood(org,
			damage > 255 ? 255 : damage);
	}

	mo = Spawn(BloodSplatter, org);
	mo.Target = self;
	mo.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
	mo.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
	mo.Velocity.z = 2.0 * 35.0;
}

//==========================================================================
//
//  SpawnRipperBlood
//
//==========================================================================

void SpawnRipperBlood()
{
	Actor th;
	TVec org;

	org.x = Origin.x + (Random() - Random()) * 16.0;
	org.y = Origin.y + (Random() - Random()) * 16.0;
	org.z = Origin.z + (Random() - Random()) * 16.0;
	th = Spawn(Blood, org);
	th.bNoGravity = true;
	th.Velocity.x = Velocity.x / 2.0;
	th.Velocity.y = Velocity.y / 2.0;
	th.StateTime += Random() * 0.1;
}

//===========================================================================
//
//  GetDamageTypeInflictor
//
//===========================================================================

EntityEx GetDamageTypeInflictor(name DamageType)
{
	return DamageType == 'lava' ? HereticLevelInfo(Level).GLavaInflictor : none;
}

//===========================================================================
//
//  Thrust
//
//===========================================================================

void Thrust(float angle, float move)
{
	Velocity.x += move * cos(angle) * 35.0;
	Velocity.y += move * sin(angle) * 35.0;
}

//===========================================================================
//
//  NightmareRespawn
//
//===========================================================================

void NightmareRespawn()
{
	float x, y, z;
	Actor A;

	x = SpawnPoint.x;
	y = SpawnPoint.y;

	if (!CheckPosition(vector(x, y, ONFLOORZ)))
		return;	// somthing is occupying it's position

	// spawn a teleport fog at old spot
	A = Spawn(TeleportFog, vector(Origin.x, Origin.y, ONFLOORZ));
	A.Origin.z += TELEFOGHEIGHT;
	A.PlaySound('misc/teleport', CHAN_VOICE);

	// spawn a teleport fog at the new spot
	A = Spawn(TeleportFog, vector(x, y, ONFLOORZ));
	A.Origin.z += TELEFOGHEIGHT;
	A.PlaySound('misc/teleport', CHAN_VOICE);

	// spawn the new monster

	// spawn it
	if (bSpawnCeiling)
		z = ONCEILINGZ;
	else
		z = ONFLOORZ;
	A = Spawn(class<Actor>(Class), vector(x, y, z));
	Level.CopyMThing(&SpawnPoint, &A.SpawnPoint);
	A.Angles.yaw = itof(45 * (SpawnPoint.angle / 45));
	if (SpawnPoint.options & HereticLevelInfo::MTF_AMBUSH)
		A.bAmbush = true;

	A.ReactionCount = 18;

	// remove the old monster
	Destroy();
}

//===========================================================================
//
//  TestLocation
//
//  Returns true if the actor is not blocked by anything at its current
// location, otherwise returns false.
//
//===========================================================================

bool TestLocation()
{
	if (!bColideWithThings && !bColideWithWorld)
		return true;

	if (CheckPosition(Origin))
	{
		// XY is ok, now check Z
		if ((Origin.z < FloorZ) || (Origin.z + Height > CeilingZ))
		{
			// Bad Z
			return false;
		}
		return true;
	}
	return false;
}

//==========================================================================
//
//	Touch
//
//==========================================================================

bool Touch(Entity InOther)
{
	bool solid;
	int damage;
	Actor Other;

	Other = Actor(InOther);
	if (!Other.bSolid && !Other.bSpecial && !Other.bShootable)
		return true;

	// check for skulls slamming into things
	if (bSkullFly)
	{
		damage = ((P_Random() % 8) + 1) * MissileDamage;
		Other.Damage(self, self, damage);
		bSkullFly = false;
		Velocity = vector(0.0, 0.0, 0.0);
		SetState(SeeState);
		return false;
	}

	// missiles can hit other things
	if (bMissile)
	{
		// Check for passing through a ghost
		if (Other.Alpha < 1.0 && bThruGhost)
		{
			return true;
		}

		if (Target && Target.Class == Other.Class)
		{
			// Don't hit same species as originator
			if (Other == Target)
			{
				// Don't missile self
				return true;
			}
			if (Other.Class != HereticPlayer)
			{
				// Hit same species as originator, explode, no damage
				return false;
			}
		}

		if (!Other.bShootable)
		{
			// didn't do any damage
			return !Other.bSolid;
		}

		if (bRip)
		{
			if (!Other.bNoBlood)
			{
				// Ok to spawn some blood
				SpawnRipperBlood();
			}
			PlaySound('misc/ripslop', CHAN_VOICE);
			damage = ((P_Random() & 3) + 2) * MissileDamage;
			Other.Damage(self, Target, damage);
			if (Other.bPushable && !bCannotPush)
			{
				// Push	thing
				Other.Velocity.x += Velocity.x / 4.0;
				Other.Velocity.y += Velocity.y / 4.0;
			}
//WTAT A FUCK IS THIS???????			numspechit = 0;
			return true;
		}
		// Do damage
		damage = ((P_Random() % 8) + 1) * MissileDamage;
		if (damage)
		{
			if (!Other.bNoBlood && P_Random() < 192)
			{
				Other.SpawnBloodSplatter(Origin, damage);
			}
			Other.Damage(self, Target, damage);
		}
		// don't traverse any more
		return false;
	}

	if (Other.bPushable && !bCannotPush)
	{
		// Push thing
		Other.Velocity.x += Velocity.x / 4.0;
		Other.Velocity.y += Velocity.y / 4.0;
	}

	// check for special pickup
	if (Other.bSpecial)
	{
		solid = Other.bSolid;
		Pickup(Other).TouchSpecial(self);
		return !solid;
	}

	return !Other.bSolid;
}

//===========================================================================
//
//	CheckForPushSpecial
//
//===========================================================================

void CheckForPushSpecial(line_t * line, int side)
{
	if (line->special)
	{
		if (bActivatePushWall)
		{
			HereticLevelInfo(Level).ActivateLine(line, self, side, SPAC_PUSH);
		}
		else if (bActivateImpact)
		{
			HereticLevelInfo(Level).ActivateLine(line,
				bMissile ? Actor(Target) : self, side, SPAC_IMPACT);
		}
	}
}

//==========================================================================
//
//	BlockedByLine
//
//==========================================================================

void BlockedByLine(line_t * ld)
{
	if (bBlasted)
	{
		Damage(none, none, ftoi(Mass) >> 5);
	}
	CheckForPushSpecial(ld, 0);
}

//==========================================================================
//
//  PushLine
//
//==========================================================================

void PushLine(tmtrace_t* tmtrace)
{
	if (bColideWithWorld)
	{
		int numSpecHitTemp;
		line_t *ld;
		int side;

		if (bBlasted)
		{
			Damage(none, none, ftoi(Mass) >> 5);
		}
		numSpecHitTemp = tmtrace->NumSpecHit;
		while (numSpecHitTemp > 0)
		{
			numSpecHitTemp--;
			// see if the line was crossed
			ld = tmtrace->SpecHit[numSpecHitTemp];
			side = PointOnPlaneSide(Origin, ld);
			CheckForPushSpecial(ld, side);
		}
	}
}

//==========================================================================
//
//	CrossSpecialLine
//
//==========================================================================

void CrossSpecialLine(line_t *ld, int side)
{
	if (bIsPlayer)
	{
		HereticLevelInfo(Level).ActivateLine(ld, self, side, SPAC_CROSS);
	}
	else if (bActivateMCross)
	{
		HereticLevelInfo(Level).ActivateLine(ld, self, side, SPAC_MCROSS);
	}
	else if (bActivatePCross)
	{
		HereticLevelInfo(Level).ActivateLine(ld, self, side, SPAC_PCROSS);
	}
	else if (ld->special == LNSPEC_Teleport)
	{
		//	Teleport hack
		HereticLevelInfo(Level).ActivateLine(ld, self, side, SPAC_MCROSS);
	}
}

//===========================================================================
//
//	SpawnBlasterEffects
//
//===========================================================================

void SpawnBlasterEffects()
{
	TVec org;

	if (P_Random() < 64)
	{
		org = Origin;
		org.z = Origin.z - 8.0;
		if (org.z < FloorZ)
		{
			org.z = FloorZ;
		}
		Spawn(BlasterSmoke, org);
	}
}

//==========================================================================
//
//	GetBaseViewHeight
//
//==========================================================================

float GetBaseViewHeight()
{
	return Player::VIEWHEIGHT;
}

//==========================================================================
//
//	Tick
//
//==========================================================================

void Tick(float deltaTime)
{
	if (!Physics(deltaTime))
	{
		return;
	}

	//
	// cycle through states, calling action functions at transitions
	//
	if (StateTime != -1.0)
	{
		if (!AdvanceState(deltaTime))
		{
			// mobj was removed
			return;
		}
	}
	else
	{
		// Check for monster respawn
		if (!bCountKill)
		{
			return;
		}
		if (!MainGameInfo(Level.Game).respawnmonsters)
		{
			return;
		}
		MoveCount++;
		if (MoveCount < 12 * 35)
		{
			return;
		}
		if (XLevel.TicTime & 31)
		{
			return;
		}
		if (P_Random() > 4)
		{
			return;
		}
		NightmareRespawn();
	}
}

//==========================================================================
//
//  HeightClip
//
//  Takes a valid thing and adjusts the thing->FloorZ, thing->CeilingZ, and
// possibly thing->z. This is called for all nearby monsters whenever a
// sector changes height. If the thing doesn't fit, the z will be set to the
// lowest value and false will be returned.
//
//==========================================================================

bool HeightClip()
{
	bool onfloor;

	onfloor = (Origin.z == FloorZ);

	tmtrace_t tmtrace;
	CheckRelPosition(&tmtrace, Origin);
	// what about stranding a monster partially off an edge?

	Floor = tmtrace.Floor;
	Ceiling = tmtrace.Ceiling;
	FloorZ = tmtrace.FloorZ;
	CeilingZ = tmtrace.CeilingZ;

	if (onfloor)
	{
		// walking monsters rise and fall with the floor
		Origin.z = FloorZ;
	}
	else
	{
		// don't adjust a floating monster unless forced to
		if (Origin.z + Height > CeilingZ)
			Origin.z = CeilingZ - Height;
	}

	if (CeilingZ - FloorZ < Height)
		return false;

	return true;
}

//==========================================================================
//
//	SectorChanged
//
//==========================================================================

bool SectorChanged(int CrushChange)
{
	Actor A;

	if (HeightClip())
	{
		return true;
	}

	//	Crunch bodies to giblets
	if (Health <= 0)
	{
		bSolid = false;
		Height = 0.0;
		Radius = 0.0;
		return true;	//fit
	}

	//	Crunch dropped items
	if (bDropped)
	{
		Destroy();
		return true;	//fit
	}

	if (!bShootable)
	{
		//	Assume it is bloody gibs or something
		return true;	//fit
	}

	if (CrushChange && !(XLevel.TicTime & 3))
	{
		Damage(none, none, CrushChange);

		//	Spray blood in a random direction
		A = Spawn(Blood, Origin + vector(0.0, 0.0, Height / 2.0));
		A.Velocity.x = (Random() - Random()) * 16.0 * 35.0;
		A.Velocity.y = (Random() - Random()) * 16.0 * 35.0;
	}
	return false;	//don't fit
}

//==========================================================================
//
//  CheckMissileSpawn
//
//  Returns true if the missile is at a valid spawn point, otherwise
// explodes it and returns false.
//
//==========================================================================

bool CheckMissileSpawn()
{
	// move a little forward so an angle can be computed if it
	// immediately explodes
	Origin += Velocity * 0.0142857143;
	if (!TryMove(Origin))
	{
		ExplodeMissile();
		return false;
	}
	return true;
}

//==========================================================================
//
//  SpawnMissile
//
//  Returns NULL if the missile exploded immediately, otherwise returns
// a Actor reference to the missile.
//
//==========================================================================

Actor SpawnMissile(EntityEx dest, class<Actor> type)
{
	TVec org;
	Actor A;
	TVec dir;

	org = Origin;
	if (type == MinotaurFX1)
	{
		// Minotaur swing attack missile
		org.z = Origin.z + 40.0;
	}
	else if (type == MinotaurFX2)
	{
		// Minotaur floor fire missile
		org.z = ONFLOORZ + FloorClip;
	}
	else if (type == SorcererFX1)
	{
		// Sorcerer Demon fireball
		org.z = Origin.z + 48.0;
	}
	else if (type == KnightAxe||	// Knight normal axe
			type == RedAxe)	// Knight red power axe
	{
		org.z = Origin.z + 36.0;
	}
	else
	{
		org.z = Origin.z + 32.0;
	}
	org.z -= FloorClip;
	A = Spawn(type, org);
	if (A.SightSound)
	{
		A.PlaySound(A.SightSound, CHAN_VOICE);
	}
	A.Target = self;	// Originator
	dir = dest.Origin - Origin;
	if (dest.Alpha < 1.0)
	{
		// Invisible target
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0);
	}
	dir = Normalise(dir);
	A.Velocity = dir * A.Speed;
	VectorAngles(&dir, &A.Angles);
	return A.CheckMissileSpawn() ? A : none;
}

//==========================================================================
//
//  SpawnMissileAngles
//
//  Returns NULL if the missile exploded immediately, otherwise returns
// a Actor reference to the missile.
//
//==========================================================================

Actor SpawnMissileAngles(class<Actor> type, float yaw, float pitch)
{
	TVec org;
	Actor A;
	TVec dir;

	org = Origin;
	if (type == MinotaurFX1)
	{
		// Minotaur swing attack missile
		org.z = Origin.z + 40.0;
	}
	else if (type == MinotaurFX2)
	{
		// Minotaur floor fire missile
		org.z = ONFLOORZ + FloorClip;
	}
	if (type == SorcererFX1)
	{
		// Sorcerer Demon fireball
		org.z = Origin.z + 48.0;
	}
	else
	{
		org.z = Origin.z + 32.0;
	}
	org.z -= FloorClip;
	A = Spawn(type, org);
	if (A.SightSound)
	{
		A.PlaySound(A.SightSound, CHAN_VOICE);
	}
	A.Target = self;	// Originator
	A.Angles.yaw = yaw;
	A.Angles.pitch = pitch;
	AngleVector(&A.Angles, &dir);
	A.Velocity = A.Speed * dir;
	return A.CheckMissileSpawn() ? A : none;
}

//==========================================================================
//
//  SpawnPlayerMissile
//
//  Tries to aim at a nearby monster
//
//==========================================================================

Actor SpawnPlayerMissile(class<Actor> type)
{
	TVec dir;
	TVec org;
	Actor MissileMobj;

	// Try to find a target
	Aim(dir, 16.0 * 64.0);
	org = Origin;
	org.z = Origin.z + 32.0 - tan(Angles.pitch);
	org.z -= FloorClip;
	MissileMobj = Spawn(type, org);
	MainGameInfo(Level.Game).MissileMobj = MissileMobj;
	if (MissileMobj.SightSound)
	{
		MissileMobj.PlaySound(MissileMobj.SightSound, CHAN_VOICE);
	}
	MissileMobj.Target = self;
	MissileMobj.Velocity = dir * MissileMobj.Speed;
	VectorAngles(&dir, &MissileMobj.Angles);
	if (MissileMobj.Class == BlasterFX1)
	{
		// Ultra-fast ripper spawning missile
		MissileMobj.Origin += MissileMobj.Velocity * 0.00357;
	}
	else
	{
		// Normal missile
		MissileMobj.Origin += MissileMobj.Velocity * 0.01429;
	}
	if (!MissileMobj.TryMove(MissileMobj.Origin))
	{
		// Exploded immediately
		MissileMobj.ExplodeMissile();
		return none;
	}
	return MissileMobj;
}

//==========================================================================
//
//  SpawnPlayerMissileAngle
//
//==========================================================================

Actor SpawnPlayerMissileAngle(class<Actor> type, float angle)
{
	Actor A;
	TVec dir;
	TVec org;

	Aim(dir, 16.0 * 64.0, angle);
	org = Origin;
	org.z = Origin.z + 4.0 * 8.0 - tan(Angles.pitch);
	org.z -= FloorClip;
	A = Spawn(type, org);
	if (A.SightSound)
	{
		A.PlaySound(A.SightSound, CHAN_VOICE);
	}
	A.Target = self;
	A.Velocity = dir * A.Speed;
	VectorAngles(&dir, &A.Angles);
	return A.CheckMissileSpawn() ? A : none;
}

//==========================================================================
//
//  SeekerMissile
//
//  The missile Tracer field must be Actor target. Returns true if
// target was tracked, false if not.
//
//==========================================================================

bool SeekerMissile(float thresh, float turnMax)
{
	int dir;
	float dist;
	float delta;
	float angle;

	if (!Tracer)
	{
		return false;
	}
	if (!Tracer.bShootable)
	{
		// Target died
		Tracer = none;
		return false;
	}
	dir = FaceActor(Actor(Tracer), &delta);
	if (delta > thresh)
	{
		delta /= 2.0;
		if (delta > turnMax)
		{
			delta = turnMax;
		}
	}
	if (dir)
	{
		// Turn clockwise
		Angles.yaw = AngleMod360(Angles.yaw + delta);
	}
	else
	{
		// Turn counter clockwise
		Angles.yaw = AngleMod360(Angles.yaw - delta);
	}
	angle = Angles.yaw;
	Velocity.x = Speed * cos(angle);
	Velocity.y = Speed * sin(angle);
	if (Origin.z + Height < Tracer.Origin.z ||
		Tracer.Origin.z + Tracer.Height < Origin.z)
	{
		// Need to seek vertically
		dist = DistTo2(Tracer);
		dist = dist / Speed;
		if (dist < 1.0)
		{
			dist = 1.0;
		}
		Velocity.z = (Tracer.Origin.z - Origin.z) / dist;
	}
	return true;
}

//==========================================================================
//
//  PIT_StompThing
//
//==========================================================================

bool PIT_StompThing(Entity Other)
{
	float blockdist;

	if (!Actor(Other).bShootable)
	{
		return true;
	}

	blockdist = Other.Radius + Radius;

	if (fabs(Other.Origin.x - teleport_pos.x) >= blockdist ||
		fabs(Other.Origin.y - teleport_pos.y) >= blockdist)
	{
		// didn't hit it
		return true;
	}

	// don't clip against self
	if (Other == self)
	{
		return true;
	}

	//  Check if allowed to stomp things
	if (!bTelestomp && !Level.bAllowMonsterTelefrags)
	{
		return false;
	}

	Actor(Other).Damage(self, self, 10000);

	return true;
}

//==========================================================================
//
//  TeleportMove
//
//==========================================================================

bool TeleportMove(TVec newOrg)
{
	Entity Other;

	// kill anything occupying the position
	teleport_pos = newOrg;

	// stomp on any things contacted
	foreach RadiusThings(Other, newOrg, Radius)
		if (!PIT_StompThing(Other))
			return false;

	// the move is ok,
	// so link the thing into its new position
	UnlinkFromWorld();
	Origin = newOrg;
	LinkToWorld();
	if (newOrg.z == ONFLOORZ)
	{
		Origin.z = FloorZ;
	}

	return true;
}

//==========================================================================
//
//  Teleport
//
//==========================================================================

bool Teleport(TVec Dst, float angle, bool DstFog, bool SrcFog, bool KeepDir)
{
	TVec oldOrg;
	float aboveFloor;
	float fogDelta;
	Actor fog;

	oldOrg = Origin;
	aboveFloor = Origin.z - FloorZ;
	if (!TeleportMove(Dst))
	{
		return false;
	}
	if (bIsPlayer)
	{
		if (Player(Player).Powers[pw_flight] && aboveFloor)
		{
			Origin.z = Origin.z + aboveFloor;
			if (Origin.z + Height > CeilingZ)
			{
				Origin.z = CeilingZ - Height;
			}
			Player.ViewOrg.z = Origin.z + Player(Player).ViewHeight;
		}
		else
		{
			Player.ViewOrg.z = Origin.z + Player(Player).ViewHeight;
			if (!KeepDir)
			{
				Angles.pitch = 0.0;
			}
		}
		Player.bFixAngle = true;
	}
	else if (bMissile)
	{
		Origin.z = Origin.z + aboveFloor;
		if (Origin.z + Height > CeilingZ)
		{
			Origin.z = CeilingZ - Height;
		}
	}
	// Spawn teleport fog at source and destination
	fogDelta = bMissile ? 0.0 : TELEFOGHEIGHT;
	if (SrcFog)
	{
		fog = Spawn(TeleportFog, oldOrg + vector(0.0, 0.0, fogDelta));
		fog.PlaySound('misc/teleport', CHAN_VOICE);
	}
	if (DstFog)
	{
		fog = Spawn(TeleportFog, vector(Origin.x + 20.0 * cos(angle),
			Origin.y + 20.0 * sin(angle), Origin.z + fogDelta));
		fog.PlaySound('misc/teleport', CHAN_VOICE);
	}
	if (!KeepDir)
	{
		if (bIsPlayer && !Player(Player).Powers[pw_weaponlevel2])
		{
			// Freeze player for about .5 sec
			ReactionTime = 0.5;
		}
		Angles.yaw = angle;
	}
	HandleFloorclip();
	if (bMissile)
	{
		Velocity.x = Speed * cos(angle);
		Velocity.y = Speed * sin(angle);
	}
	else if (!KeepDir)
	{
		Velocity = vector(0.0, 0.0, 0.0);
	}
	return true;
}

//==========================================================================
//
//  CheckMeleeRange
//
//==========================================================================

bool CheckMeleeRange()
{
	float dist;

	if (!Target)
	{
		return false;
	}
	dist = DistTo(Target);
	if (dist >= MELEERANGE)
	{
		return false;
	}
	// Don't melee things too far above or below actor.
	if (Target.Origin.z > Origin.z + Height)
		return false;
	if (Target.Origin.z + Target.Height < Origin.z)
		return false;
	if (!CanSee(Target))
	{
		return false;
	}
	return true;
}

//==========================================================================
//
//  CheckMissileRange
//
//==========================================================================

bool CheckMissileRange()
{
	float dist;

	if (!CanSee(Target))
	{
		return false;
	}
	if (bJustHit)
	{
		// The target just hit the enemy, so fight back!
		bJustHit = false;
		return true;
	}
	if (ReactionCount)
	{
		// Don't attack yet
		return false;
	}
	dist = DistTo(Target) - 64.0;
	if (!MeleeState)
	{
		// No melee attack, so fire more frequently
		dist -= 128.0;
	}

	if (MissileMaxRange && dist > MissileMaxRange)
	{
		return false;	// too far away
	}

	if (MissileMinRange && dist < MissileMinRange)
	{
		return false;	// close for fist attack
	}

	if (bTriggerHappy)
	{
		//	Attack from far away
		dist /= 2.0;
	}

	if (dist > MissileChance)
	{
		dist = MissileChance;
	}
	if (Random() * 256.0 < dist)
	{
		return false;
	}
	return true;
}

//==========================================================================
//
//  LookForMonsters
//
//==========================================================================

bool LookForMonsters()
{
	int count;
	Actor mo;

	if (!Level.Game.Players[0].MO.CanSee(self))
	{
		// Player can't see monster
		return false;
	}
	count = 0;
	foreach AllThinkers(Actor, mo)
	{
		if (!mo.bCountKill || (mo == self) || (mo.Health <= 0))
		{
			// Not a valid monster
			continue;
		}
		if (DistTo(mo) > MONS_LOOK_RANGE)
		{
			// Out of range
			continue;
		}
		if (P_Random() < 16)
		{
			// Skip
			continue;
		}
		if (count++ > MONS_LOOK_LIMIT)
		{
			// Stop searching
			return (false);
		}
		if (!CanSee(mo))
		{
			// Out of sight
			continue;
		}
		// Found a target monster
		Target = mo;
		return true;
	}
	return false;
}

//==========================================================================
//
//  LookForPlayers
//
//  If allaround is false, only look 180 degrees in front
//  returns true if a player is targeted
//
//==========================================================================

bool LookForPlayers(bool allaround)
{
	int c;
	int stop;
	Player P;
	float an;
	float dist;

	if (!Level.Game.netgame && Level.Game.Players[0] && Level.Game.Players[0].bSpawned && Level.Game.Players[0].Health <= 0)
	{
		// Single player game and player is dead, look for monsters
		return LookForMonsters();
	}
	c = 0;
	stop = (LastLook - 1) & (MAXPLAYERS - 1);
	for (;; LastLook = (LastLook + 1) & (MAXPLAYERS - 1))
	{
		if (LastLook == stop)
			return false;	// done looking

		if (!Level.Game.Players[LastLook])
			continue;

		if (c++ == 2)
			return false;	// done looking

		P = Player(Level.Game.Players[LastLook]);
		if (!P.bSpawned || !P.MO)
			continue;	// not spawned yet
		if (P.Health <= 0)
			continue;	// dead
		if (!CanSee(P.MO))
			continue;	// out of sight

		if (!allaround)
		{
			an = AngleMod360(atan2(P.MO.Origin.y - Origin.y,
				P.MO.Origin.x - Origin.x) - Angles.yaw);
			if (an > 90.0 && an < 270.0)
			{
				dist = DistTo(P.MO);
				// if real close, react anyway
				if (dist > MELEERANGE)
					continue;	// behind back
			}
		}
		if (P.MO.Alpha < 1.0)
		{
			// Player is invisible
			if ((DistTo(P.MO) > 2.0 * MELEERANGE) &&
				Length(P.MO.Velocity) < 5.0 * 35.0)
			{
				// Player is sneaking - can't detect
				return false;
			}
			if (P_Random() < 225)
			{
				// Player isn't sneaking, but still didn't detect
				return false;
			}
		}
		Target = Actor(P.MO);
		return true;
	}
	return false;
}

//==========================================================================
//
//  StepMove
//
//  Move in the current direction, returns false if the move is blocked.
//
//==========================================================================

bool StepMove()
{
	float tryx, deltax, origx;
	float tryy, deltay, origy;
	float maxmove;
	int steps;
	float xspeed;
	float yspeed;
	int i;
	bool try_ok;

	line_t *ld;
	int good;

	if (MoveDir == DI_NODIR)
		return false;

	// [RH] Instead of yanking non-floating monsters to the ground,
	// let gravity drop them down, unless they're moving down a step.
	if (!bNoGravity && Origin.z > FloorZ && !bOnMobj)
	{
		if (Origin.z > FloorZ + MaxStepHeight)
		{
			return false;
		}
		else
		{
			Origin.z = FloorZ;
		}
	}

#ifdef RANGECHECK
	if (MoveDir >= 8 || MoveDir < 0)
		Error("Weird MoveDir!");
#endif

	origx = Origin.x;
	origy = Origin.y;
	deltax = StepSpeed * MainGameInfo(Level.Game).xspeed[MoveDir];
	deltay = StepSpeed * MainGameInfo(Level.Game).yspeed[MoveDir];
	tryx = origx + deltax;
	tryy = origy + deltay;

	// Like P_XYMovement this should do multiple moves if the step size is too large
	maxmove = Radius;
	steps = 1;

	if (maxmove > 0.0)
	{ 
		xspeed = fabs(deltax);
		yspeed = fabs(deltay);

		if (xspeed > yspeed)
		{
			if (xspeed > maxmove)
			{
				steps = 1 + ftoi(xspeed / maxmove);
			}
		}
		else
		{
			if (yspeed > maxmove)
			{
				steps = 1 + ftoi(yspeed / maxmove);
			}
		}
	}

	tmtrace_t tmtrace;
	try_ok = true;
	for(i=1; i < steps; i++)
	{
		try_ok = TryMoveEx(&tmtrace, vector(origx + (deltax / itof(steps * i)), origy +
					(deltay / itof(steps * i)), Origin.z));
		if (!try_ok)
			break;
	}

	// killough 3/15/98: don't jump over dropoffs:
	if (try_ok)
		try_ok = TryMoveEx(&tmtrace, vector(tryx, tryy, Origin.z));

	if (!try_ok)
	{
		// open any specials
		if (bFloat && tmtrace.bFloatOk)
		{
			// must adjust height
			if (Origin.z < tmtrace.FloorZ)
				Origin.z += FloatSpeed * Level.Game.frametime;
			else
				Origin.z -= FloatSpeed * Level.Game.frametime;

			// Check to make sure there's nothing in the way of the float
			if(TestMobjZ())
			{
				bInFloat = true;
				return true;
			}
		}

		if (!tmtrace.NumSpecHit)
			return false;

		MoveDir = DI_NODIR;

		// if the special is not a door that can be opened, return false
		//
		// killough 8/9/98: this is what caused monsters to get stuck in
		// doortracks, because it thought that the monster freed itself
		// by opening a door, even if it was moving towards the doortrack,
		// and not the door itself.
		//
		// killough 9/9/98: If a line blocking the monster is activated,
		// return true 90% of the time. If a line blocking the monster is
		// not activated, but some other line is, return false 90% of the
		// time. A bit of randomness is needed to ensure it's free from
		// lockups, but for most cases, it returns the correct result.
		//
		// Do NOT simply return false 1/4th of the time (causes monsters to
		// back out when they shouldn't, and creates secondary stickiness).

		good = 0;
		while (tmtrace.NumSpecHit--)
		{
			ld = tmtrace.SpecHit[tmtrace.NumSpecHit];
			// if the special is not a door
			// that can be opened,
			// return false
			if (HereticLevelInfo(Level).ActivateLine(ld, self, 0, SPAC_USE) ||
			    (bActivatePushWall && HereticLevelInfo(Level).ActivateLine(ld, self, 0, SPAC_PUSH)))
			{
				good |= ld == tmtrace.BlockingLine ? 1 : 2;//true;
			}
		}
		return good && ((Random() >= 203.0) ^ (good & 1));
	}
	else
	{
		bInFloat = false;
	}

	if (!bFloat)
	{
		if (Origin.z > FloorZ)
		{
			HitFloorType();
		}
		Origin.z = FloorZ;
	}
	return true;
}

//==========================================================================
//
//  TryWalk
//
//  Attempts to move actor in its current (ob->moveangle) direction.
//  If blocked by either a wall or an actor returns FALSE.
//  If move is either clear of block only by a door, returns TRUE and sets.
//  If a door is in the way, an OpenDoor call is made to start it opening.
//
//==========================================================================

bool TryWalk()
{
	if (!StepMove())
	{
		return false;
	}
	MoveCount = P_Random() & 15;
	return true;
}

//==========================================================================
//
//  DO_NewChaseDir
//
//==========================================================================

void DO_NewChaseDir(float deltax, float deltay)
{
	int d[3];

	int tdir;
	int olddir;

	int turnaround;

	olddir = MoveDir;
	turnaround = MainGameInfo(Level.Game).opposite[olddir];

	if (deltax > 10.0)
		d[1] = DI_EAST;
	else if (deltax < -10.0)
		d[1] = DI_WEST;
	else
		d[1] = DI_NODIR;
	if (deltay < -10.0)
		d[2] = DI_SOUTH;
	else if (deltay > 10.0)
		d[2] = DI_NORTH;
	else
		d[2] = DI_NODIR;

	// try direct route
	if (d[1] != DI_NODIR && d[2] != DI_NODIR)
	{
		MoveDir = MainGameInfo(Level.Game).diags[((deltay < 0.0) << 1) + (deltax > 0.0)];
		if (MoveDir != turnaround && TryWalk())
			return;
	}

	// try other directions
	if (P_Random() > 200 || fabs(deltay) > fabs(deltax))
	{
		tdir = d[1];
		d[1] = d[2];
		d[2] = tdir;
	}

	if (d[1] == turnaround)
		d[1] = DI_NODIR;
	if (d[2] == turnaround)
		d[2] = DI_NODIR;

	if (d[1] != DI_NODIR)
	{
		MoveDir = d[1];
		if (TryWalk())
			return;	/*either moved forward or attacked */
	}

	if (d[2] != DI_NODIR)
	{
		MoveDir = d[2];
		if (TryWalk())
			return;
	}

	/* there is no direct path to the player, so pick another direction */

	if (olddir != DI_NODIR)
	{
		MoveDir = olddir;
		if (TryWalk())
			return;
	}

	if (P_Random() & 1)	/*randomly determine direction of search */
	{
		for (tdir = DI_EAST; tdir <= DI_SOUTHEAST; tdir++)
		{
			if (tdir != turnaround)
			{
				MoveDir = tdir;
				if (TryWalk())
					return;
			}
		}
	}
	else
	{
		for (tdir = DI_SOUTHEAST; tdir >= DI_EAST; tdir--)
		{
			if (tdir != turnaround)
			{
				MoveDir = tdir;
				if (TryWalk())
					return;
			}
		}
	}

	if (turnaround != DI_NODIR)
	{
		MoveDir = turnaround;
		if (TryWalk())
			return;
	}

	MoveDir = DI_NODIR;	// can't move
}

//=============================================================================
//
// NewChaseDir
//
// killough 9/8/98: Split into two functions
//
//=============================================================================

void NewChaseDir()
{
	float deltax;
	float deltay;

	if (!Target)
		Error("NewChaseDir: called with no Target");

	deltax = Target.Origin.x - Origin.x;
	deltay = Target.Origin.y - Origin.y;

	tmtrace_t tmtrace;
	CheckRelPosition(&tmtrace, Origin);

	// Try to move away from a dropoff
	if (FloorZ - tmtrace.DropOffZ > MaxDropoffHeight && 
		Origin.z <= FloorZ && !bDropOff && !bOnMobj && !bFloat)
	{
		avoiddropoff_t a;
		// We call CheckDropoff here to determine if the
		// bounding box actually needs to be used below
		CheckDropOff(&a);

		if (a.deltax || a.deltay)
		{
			// [Graf Zahl] I have changed TryMove to only apply this logic when
			// being called from here. bAavoidingDropoff activates the code that
			// allows monsters to move away from a dropoff. This is different from
			// MBF which requires unconditional use of the altered logic and therefore
			// forcing a massive change in the monster behavior to use this.

			// use different dropoff movement logic in TryMove
			bAvoidingDropoff = true;
			DO_NewChaseDir(a.deltax, a.deltay);
			bAvoidingDropoff = false;
		
			// If moving away from dropoff, set MoveCount to 1 so that
			// small steps are taken to get monster away from dropoff.
			MoveCount = 1;
			return;
		}
	}
	DO_NewChaseDir(deltax, deltay);
}

//==========================================================================
//
//  A_FreeTargMobj
//
//==========================================================================

final void A_FreeTargMobj()
{
	Velocity = vector(0.0, 0.0, 0.0);
	Origin.z = CeilingZ + 4.0;
	Gravity = 1.0;
	bSolid = false;
	bShootable = false;
	bFloat = false;
	bSkullFly = false;
	bNoGravity = true;
	bDropOff = true;
	bCorpse = true;
	bNoPassMobj = true;
	Player = none;
	bIsPlayer = false;
}

//==========================================================================
//
//  A_Scream
//
//==========================================================================

final void A_Scream()
{
	if (bIsPlayer)
	{
		// Handle the different player death screams
		if (Special1 < 10)
		{
			// Wimpy death sound
			PlaySound('*wimpydeath', CHAN_VOICE);
		}
		else if (Health > -50)
		{
			// Normal death sound
			PlaySound(DeathSound, CHAN_VOICE);
		}
		else if (Health > -100)
		{
			// Crazy death sound
			PlaySound('*crazydeath', CHAN_VOICE);
		}
		else
		{
			// Extreme death sound
			PlaySound('*gibbed', CHAN_VOICE);
		}
	}
	else if (Class == ChickenPlayer || Class == Sorcerer1 || Class == Minotaur)
	{
		// Make boss death sounds full volume
		PlaySound(DeathSound, CHAN_VOICE, 1.0, ATTN_NONE);
	}
	else
	{
		PlaySound(DeathSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//  A_Explode
//
//  Handles a bunch of exploding things.
//
//==========================================================================

final void A_Explode()
{
	int damage;

	damage = 128;
	if (Class == ActivatedTimeBomb)
	{
		// Time Bombs
		Origin.z += 32.0;
		Alpha = 1.0;
	}
	else if (Class == MinotaurFX2)
	{
		// Minotaur floor fire
		damage = 24;
	}
	else if (Class == Sorcerer2FX1)
	{
		// D'Sparil missile
		damage = 80 + (P_Random() & 31);
	}
	RadiusAttack(Target, damage, itof(damage), true);
	if (Origin.z <= FloorZ + itof(damage))
	{
		HitFloorType();
	}
	if (Class == ActivatedTimeBomb)
	{
		SendExplosion(HereticDefs::EF_DL_WHITE, Origin);
	}
	if (Class == Pod)
	{
		SendExplosion(HereticDefs::EF_DL_GREEN, Origin);
	}
	if (ExplodeEffect)
	{
		SendExplosion(ExplodeEffect, Origin);
	}
}

//==========================================================================
//
//  SpawnPuff
//
//==========================================================================

void SpawnPuff(TVec org, float Range, class<EntityEx> PuffType, bool HitThing)
{
	EntityEx puff;

	if (PuffType == BlasterPuff1 && HitThing)
	{
		// Make blaster big puff
		Actor A;

		A = Spawn(BlasterPuff2, org);
		A.PlaySound('weapons/blastershoot', CHAN_VOICE);

		SendExplosion(HereticDefs::EF_DL_BLUE, org);
	}
	else
	{
		org.z += (Random() - Random()) * 4.0;
		puff = Spawn(PuffType, org);
		if (puff.AttackSound)
		{
			puff.PlaySound(puff.AttackSound, CHAN_VOICE);
		}
		if (PuffType == BeakPuff || PuffType == StaffPuff)
		{
			puff.Velocity.z = 1.0 * 35.0;
		}
		else if (PuffType == GauntletPuff1 || PuffType == GauntletPuff2)
		{
			puff.Velocity.z = 0.8 * 35.0;
		}
		if (PuffType == GoldWandPuff1)
		{
			SendExplosion(HereticDefs::EF_DL_WHITE, org);
		}
		if (PuffType == BlasterPuff1)
		{
			SendExplosion(HereticDefs::EF_DL_BLUE, org);
		}
	}
}

//==========================================================================
//
//	ClientTick
//
//==========================================================================

void ClientTick(float DeltaTime)
{
	dlight_t *dl;

	switch (Effects & HereticDefs::EF_DLIGHT_MASK)
	{
	case HereticDefs::EF_DL_NONE:
		break;

	case HereticDefs::EF_DL_WHITE:
		dl = AllocDlight(self);
		dl->origin = Origin;
		dl->radius = 200.0;
		dl->colour = RGB(255, 255, 255);
		dl->die = XLevel.Time + 0.1;
		break;

	case HereticDefs::EF_DL_RED:
		dl = AllocDlight(self);
		dl->origin = Origin;
		dl->radius = 200.0;
		dl->colour = RGB(255, 0, 0);
		dl->die = XLevel.Time + 0.1;
		break;

	case HereticDefs::EF_DL_GREEN:
		dl = AllocDlight(self);
		dl->origin = Origin;
		dl->radius = 200.0;
		dl->colour = RGB(0, 255, 0);
		dl->die = XLevel.Time + 0.1;
		break;

	case HereticDefs::EF_DL_BLUE:
		dl = AllocDlight(self);
		dl->origin = Origin;
		dl->radius = 200.0;
		dl->colour = RGB(0, 0, 255);
		dl->die = XLevel.Time + 0.1;
		break;

	case HereticDefs::EF_DL_MAGENTA:
		dl = AllocDlight(self);
		dl->origin = Origin;
		dl->radius = 200.0;
		dl->colour = RGB(255, 0, 255);
		dl->die = XLevel.Time + 0.1;
		break;
	}
}

__states__
{
	S_FREETARGMOBJ('ACLO', 4, 30.0, none) = A_FreeTargMobj
}

defaultproperties
{
	Health = 1000;
	GibsHealth = -1000;
	ReactionCount = 8;
	Radius = 20.0;
	Height = 16.0;
	Mass = 100.0;
	MaxStepHeight = 24.0;
	LightOffset = vector(0.0, 0.0, 0.0);
	LightColour = 0xffffffff;
	LightRadius = 128.0;
}
