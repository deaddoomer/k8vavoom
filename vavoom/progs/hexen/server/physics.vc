//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define GRAVITY 			1225.0
#define MAXMOVE 			1050.0
#define STOPSPEED			2.1875

#define FRICTION_NORMAL		3.28125
#define FRICTION_LOW		0.95703125
#define FRICTION_FLY		2.87109375
#define FRICTION_WATER		3.0

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  ClipVelocity
//
//  Slide off of the impacting object
//
//==========================================================================

TVec ClipVelocity(TVec in, TVec normal, float overbounce)
{
	return in - normal * (DotProduct(in, normal) * overbounce);
}

//**************************************************************************
//
//  SLIDE MOVE
//
//  Allows the player to slide along any angled walls.
//
//**************************************************************************

float bestslidefrac;
float secondslidefrac;

line_t *bestslideline;
line_t *secondslideline;

mobj_t *slidemo;
TVec slideorg;
TVec slidedir;

//==========================================================================
//
//  PTR_SlideTraverse
//
//==========================================================================

boolean PTR_SlideTraverse(intercept_t * in)
{
	line_t *li;
	TVec hit_point;
	opening_t *open;

	if (!in->isaline)
		Error("PTR_SlideTraverse: not a line?");

	li = in->line;

	if (li->flags & ML_TWOSIDED)
	{
		// set openrange, opentop, openbottom
		hit_point = slideorg + in->frac * slidedir;
		open = LineOpenings(li, hit_point);
		open =
			FindOpening(open, slidemo->origin.z,
			slidemo->origin.z + slidemo->height);

		if (open && (open->range >= slidemo->height) &&	//  fits
			(open->top - slidemo->origin.z >= slidemo->height) &&	// mobj is not too high
			(open->bottom - slidemo->origin.z <= 24.0))	// not too big a step up
		{
			// this line doesn't block movement
			return true;
		}
	}
	else
	{
		if (PointOnPlaneSide(slidemo->origin, li))
		{
			// don't hit the back side
			return true;
		}
	}

	// the line does block movement,
	// see if it is closer than best so far
	if (in->frac < bestslidefrac)
	{
		secondslidefrac = bestslidefrac;
		secondslideline = bestslideline;
		bestslidefrac = in->frac;
		bestslideline = li;
	}

	return false;	// stop
}

//==========================================================================
//
//  SlidePathTraverse
//
//==========================================================================

void SlidePathTraverse(float x, float y)
{
	slideorg = vector(x, y, slidemo->origin.z);
	slidedir = slidemo->velocity * frametime;
	P_PathTraverse(x, y, x + slidedir.x, y + slidedir.y,
		PT_ADDLINES, PTR_SlideTraverse);
}

//==========================================================================
//
//  P_SlideMove
//
//  The momx / momy move is bad, so try to slide along a wall.
//  Find the first line hit, move flush to it, and slide along it.
//  This is a kludgy mess.
//
//==========================================================================

void P_SlideMove(mobj_t * mo)
{
	float leadx;
	float leady;
	float trailx;
	float traily;
	float newx;
	float newy;
	int hitcount;

	slidemo = mo;
	hitcount = 0;

	do
	{
		if (++hitcount == 3)
		{
			// don't loop forever
			if (!P_TryMove(mo, mo->origin.x,
					mo->origin.y + mo->velocity.y * frametime))
				P_TryMove(mo, mo->origin.x + mo->velocity.x * frametime,
					mo->origin.y);
			return;
		}

		// trace along the three leading corners
		if (mo->velocity.x > 0.0)
		{
			leadx = mo->origin.x + mo->radius;
			trailx = mo->origin.x - mo->radius;
		}
		else
		{
			leadx = mo->origin.x - mo->radius;
			trailx = mo->origin.x + mo->radius;
		}

		if (mo->velocity.y > 0.0)
		{
			leady = mo->origin.y + mo->radius;
			traily = mo->origin.y - mo->radius;
		}
		else
		{
			leady = mo->origin.y - mo->radius;
			traily = mo->origin.y + mo->radius;
		}

		bestslidefrac = 1.00001;

		SlidePathTraverse(leadx, leady);
		SlidePathTraverse(trailx, leady);
		SlidePathTraverse(leadx, traily);

		// move up to the wall
		if (bestslidefrac == 1.00001)
		{
			// the move most have hit the middle, so stairstep
			if (!P_TryMove(mo, mo->origin.x,
					mo->origin.y + mo->velocity.y * frametime))
				P_TryMove(mo, mo->origin.x + mo->velocity.x * frametime,
					mo->origin.y);
			return;
		}

		// fudge a bit to make sure it doesn't hit
		bestslidefrac -= 0.03125;
		if (bestslidefrac > 0.0)
		{
			newx = mo->velocity.x * frametime * bestslidefrac;
			newy = mo->velocity.y * frametime * bestslidefrac;

			if (!P_TryMove(mo, mo->origin.x + newx, mo->origin.y + newy))
			{
				if (!P_TryMove(mo, mo->origin.x,
						mo->origin.y + mo->velocity.y * frametime))
					P_TryMove(mo, mo->origin.x + mo->velocity.x * frametime,
						mo->origin.y);
				return;
			}
		}

		// Now continue along the wall.
		// First calculate remainder.
		bestslidefrac = 1.0 - (bestslidefrac + 0.03125);

		if (bestslidefrac > 1.0)
			bestslidefrac = 1.0;

		if (bestslidefrac <= 0.0)
			return;

		// clip the moves
		mo->velocity =
			ClipVelocity(mo->velocity * bestslidefrac, bestslideline->normal,
			1.0);

	}
	while (!P_TryMove(mo, mo->origin.x + mo->velocity.x * frametime,
			mo->origin.y + mo->velocity.y * frametime));
}

//**************************************************************************
//
//  BOUNCING
//
//  Bounce missile against walls
//
//**************************************************************************

//============================================================================
//
//  PTR_BounceTraverse
//
//============================================================================

boolean PTR_BounceTraverse(intercept_t * in)
{
	line_t *li;
	TVec hit_point;
	opening_t *open;

	if (!in->isaline)
		Error("PTR_BounceTraverse: not a line?");

	li = in->line;
	if (li->flags & ML_TWOSIDED)
	{
		hit_point = slideorg + in->frac * slidedir;
		open = LineOpenings(li, hit_point);	// set openrange, opentop, openbottom
		open =
			FindOpening(open, slidemo->origin.z,
			slidemo->origin.z + slidemo->height);
		if (open && open->range >= slidemo->height &&	// fits
			open->top - slidemo->origin.z >= slidemo->height)	// mobj is not too high
		{
			return true;	// this line doesn't block movement
		}
	}
	else
	{
		if (PointOnPlaneSide(slidemo->origin, li))
		{
			return true;	// don't hit the back side
		}
	}

	// the line does block movement, see if it is closer than best so far
	if (in->frac < bestslidefrac)
	{
		secondslidefrac = bestslidefrac;
		secondslideline = bestslideline;
		bestslidefrac = in->frac;
		bestslideline = li;
	}
	return false;	// stop
}

//============================================================================
//
//  P_BounceWall
//
//============================================================================

void P_BounceWall(mobj_t * mo)
{
	float leadx, leady;

	slidemo = mo;

	//
	// trace along the three leading corners
	//
	if (mo->velocity.x > 0.0)
	{
		leadx = mo->origin.x + mo->radius;
	}
	else
	{
		leadx = mo->origin.x - mo->radius;
	}
	if (mo->velocity.y > 0.0)
	{
		leady = mo->origin.y + mo->radius;
	}
	else
	{
		leady = mo->origin.y - mo->radius;
	}
	bestslidefrac = 1.00001;
	slideorg = vector(leadx, leady, slidemo->origin.z);
	slidedir = mo->velocity * frametime;
	P_PathTraverse(leadx, leady, leadx + slidedir.x, leady + slidedir.y,
		PT_ADDLINES, PTR_BounceTraverse);
	mo->velocity =
		ClipVelocity(mo->velocity * 0.75, bestslideline->normal, 2.0);
}

//**************************************************************************
//
//  OBJECT MOVEMENT
//
//**************************************************************************

//==========================================================================
//
//  CheckWater
//
//==========================================================================

boolean CheckWater(mobj_t * mobj)
{
	TVec point;
	int cont;

	point = mobj->origin;
	point.z += 1.0;

	mobj->waterlevel = 0;
	mobj->watertype = CONTENTS_EMPTY;
	cont = PointContents(mobj->subsector->sector, point);
	if (cont >= CONTENTS_WATER)
	{
		mobj->watertype = cont;
		mobj->waterlevel = 1;
		point.z = mobj->origin.z + mobj->height * 0.5;
		cont = PointContents(mobj->subsector->sector, point);
		if (cont >= CONTENTS_WATER)
		{
			mobj->waterlevel = 2;
			if (mobj->player)
			{
				point = mobj->player->vieworg;
				cont = PointContents(mobj->subsector->sector, point);
				if (cont >= CONTENTS_WATER)
					mobj->waterlevel = 3;
			}
		}
	}
	return mobj->waterlevel > 1;
}

//==========================================================================
//
//  UpdateVelocity
//
//==========================================================================

void UpdateVelocity(mobj_t * mo)
{
	player_t *player;

	if (mo->waterlevel < 2)
	{
		if (mo->flags2 & MF2_LOGRAV)
		{
			mo->velocity.z -= GRAVITY / 8.0 * frametime;
		}
		else if (!(mo->flags & MF_NOGRAVITY))
		{
			mo->velocity.z -= GRAVITY * frametime;
		}
	}
	else if (!mo->player)
	{
		mo->velocity.z = -60.0;
	}

	// Friction

	if (mo->flags & (MF_MISSILE | MF_SKULLFLY))
	{
		// No friction for missiles
		return;
	}
	if (mo->origin.z > mo->floorz && mo->waterlevel < 2 &&
		!(mo->flags2 & MF2_FLY) && !(mo->flags2 & MF2_ONMOBJ))
	{
		// No friction when falling
		if (mo->type != MT_BLASTEFFECT)
			return;
	}

	if (mo->origin.z <= mo->floorz)
	{
		//  Clip velocity
		float dot = DotProduct(mo->velocity, mo->floor->normal);

		if (dot < 0.0)
		{
			mo->velocity -= dot * mo->floor->normal;
		}
	}

	if (mo->flags & MF_CORPSE)
	{
		// Don't stop sliding if halfway off a step with some momentum
		if (mo->velocity.x > 0.25 * 35.0 || mo->velocity.x < -0.25 * 35.0 ||
			mo->velocity.y > 0.25 * 35.0 || mo->velocity.y < -0.25 * 35.0)
		{
			if (mo->floorz != mo->subsector->sector->floorheight)
			{
				return;
			}
		}
	}
	player = mo->player;
	if (mo->velocity.x > -STOPSPEED && mo->velocity.x < STOPSPEED &&
		mo->velocity.y > -STOPSPEED && mo->velocity.y < STOPSPEED &&
		mo->velocity.z > -STOPSPEED && mo->velocity.z < STOPSPEED &&
		(!player || (!player->forwardmove && !player->sidemove)))
	{
		// If in a walking frame, stop moving
		if (player)
		{
			int sn;

			sn = player->mo->statenum - PStateRun[player->pclass];
			if (sn >= 0 && sn < 4)
			{
				SetMobjState(player->mo, PStateNormal[player->pclass]);
			}
		}
		mo->velocity.x = 0.0;
		mo->velocity.y = 0.0;
	}
	else
	{
		if (mo->waterlevel >= 2)
		{
			mo->velocity -= mo->velocity * FRICTION_WATER * frametime;
		}
		else if (mo->flags2 & MF2_FLY && !(mo->origin.z <= mo->floorz)
			&& !(mo->flags2 & MF2_ONMOBJ))
		{
			mo->velocity -= mo->velocity * FRICTION_FLY * frametime;
		}
		else if (P_GetThingFloorType(mo) == FLOOR_ICE)
		{
			mo->velocity -= mo->velocity * FRICTION_LOW * frametime;
		}
		else
		{
			mo->velocity -= mo->velocity * FRICTION_NORMAL * frametime;
		}
	}
}

//==========================================================================
//
//  P_XYMovement
//
//==========================================================================

void P_XYMovement(mobj_t * mo)
{
	float ptryx, ptryy;
	float xmove, ymove;
	int special;
	angle_t angle;

	if (!mo->velocity.x && !mo->velocity.y)
	{
		if (mo->flags & MF_SKULLFLY)
		{
			// A flying mobj slammed into something
			mo->flags &= ~MF_SKULLFLY;
			mo->velocity.x = mo->velocity.y = mo->velocity.z = 0.0;
			SetMobjState(mo, mo->seestate);
		}
		return;
	}
	special = mo->subsector->sector->special;
	if (mo->flags2 & MF2_WINDTHRUST)
	{
		switch (special)
		{
		case 40:
		case 41:
		case 42:	// Wind_East
			P_ThrustMobj(mo, 0, windTab[special - 40]);
			break;
		case 43:
		case 44:
		case 45:	// Wind_North
			P_ThrustMobj(mo, ANG90, windTab[special - 43]);
			break;
		case 46:
		case 47:
		case 48:	// Wind_South
			P_ThrustMobj(mo, ANG270, windTab[special - 46]);
			break;
		case 49:
		case 50:
		case 51:	// Wind_West
			P_ThrustMobj(mo, ANG180, windTab[special - 49]);
			break;
		}
	}
	if (mo->velocity.x > MAXMOVE)
	{
		mo->velocity.x = MAXMOVE;
	}
	else if (mo->velocity.x < -MAXMOVE)
	{
		mo->velocity.x = -MAXMOVE;
	}
	if (mo->velocity.y > MAXMOVE)
	{
		mo->velocity.y = MAXMOVE;
	}
	else if (mo->velocity.y < -MAXMOVE)
	{
		mo->velocity.y = -MAXMOVE;
	}
	xmove = mo->velocity.x * frametime;
	ymove = mo->velocity.y * frametime;
	do
	{
		if (xmove > MAXMOVE / (35.0 * 2.0) || ymove > MAXMOVE / (35.0 * 2.0))
		{
			ptryx = mo->origin.x + xmove / 2.0;
			ptryy = mo->origin.y + ymove / 2.0;
			xmove /= 2.0;
			ymove /= 2.0;
		}
		else
		{
			ptryx = mo->origin.x + xmove;
			ptryy = mo->origin.y + ymove;
			xmove = ymove = 0.0;
		}
		if (!P_TryMove(mo, ptryx, ptryy))
		{
			// Blocked move
			if (mo->flags2 & MF2_SLIDE)
			{
				// Try to slide along it
				if (!BlockingMobj)
				{
					// Slide against wall
					P_SlideMove(mo);
				}
				else
				{
					// Slide against mobj
					if (P_TryMove(mo, mo->origin.x, ptryy))
					{
						mo->velocity.x = 0.0;
					}
					else if (P_TryMove(mo, ptryx, mo->origin.y))
					{
						mo->velocity.y = 0.0;
					}
					else
					{
						mo->velocity.x = mo->velocity.y = 0.0;
					}
				}
			}
			else if (mo->flags & MF_MISSILE)
			{
				if (mo->flags2 & MF2_FLOORBOUNCE)
				{
					if (BlockingMobj)
					{
						if ((BlockingMobj->flags2 & MF2_REFLECTIVE) ||
							((!BlockingMobj->player) &&
								(!(BlockingMobj->flags & MF_COUNTKILL))))
						{
							float speed;

							angle =
								atan2(mo->origin.y - BlockingMobj->origin.y,
								mo->origin.x - BlockingMobj->origin.x) +
								ANGLE_1 * ((P_Random() % 16) - 8);
							speed = Length(mo->velocity);
							speed = speed * 0.75;
							mo->angles.yaw = angle;
							mo->velocity.x = speed * cos(angle);
							mo->velocity.y = speed * sin(angle);
							if (mo->sound_sight)
							{
								StartSound(mo, mo->sound_sight, CHAN_VOICE);
							}
							return;
						}
						else
						{
							// Struck a player/creature
							P_ExplodeMissile(mo);
						}
					}
					else
					{
						// Struck a wall
						P_BounceWall(mo);
						switch (mo->type)
						{
						case MT_SORCBALL1:
						case MT_SORCBALL2:
						case MT_SORCBALL3:
						case MT_SORCFX1:
							break;
						default:
							if (mo->sound_sight)
							{
								StartSound(mo, mo->sound_sight, CHAN_VOICE);
							}
							break;
						}
						return;
					}
				}
				if (BlockingMobj && (BlockingMobj->flags2 & MF2_REFLECTIVE))
				{
					int explode = false;

					angle = atan2(mo->origin.y - BlockingMobj->origin.y,
						mo->origin.x - BlockingMobj->origin.x);

					// Change angle for delflection/reflection
					switch (BlockingMobj->type)
					{
					case MT_CENTAUR:
					case MT_CENTAURLEADER:
						if (abs(angle - BlockingMobj->angles.yaw) >> 24 > 45)
						{
							explode = true;
							break;
						}
						if (mo->type == MT_HOLY_FX)
						{
							explode = true;
							break;
						}
						// Drop through to sorcerer full reflection
					case MT_SORCBOSS:
						// Deflection
						if (P_Random() < 128)
							angle += ANG45;
						else
							angle -= ANG45;
						break;
					default:
						// Reflection
						angle += ANGLE_1 * ((P_Random() % 16) - 8);
						break;
					}

					if (!explode)
					{
						// Reflect the missile along angle
						mo->angles.yaw = angle;
						mo->velocity.x = (mo->speed / 2.0) * cos(angle);
						mo->velocity.y = (mo->speed / 2.0) * sin(angle);
//                      mo->velocity.z = -mo->velocity.z;
						if (mo->flags2 & MF2_SEEKERMISSILE)
						{
							mo->specialmobj1 = mo->target;
						}
						mo->target = BlockingMobj;
						return;
					}
				}
				// Explode a missile
				if (ceilingline && ceilingline->backsector
					&& ceilingline->backsector->ceiling.pic == skyflatnum)
				{
					// Hack to prevent missiles exploding against the sky
					if (mo->type == MT_BLOODYSKULL)
					{
						mo->velocity.x = mo->velocity.y = 0.0;
						mo->velocity.z = -1.0 * 35.0;
					}
					else if (mo->type == MT_HOLY_FX)
					{
						P_ExplodeMissile(mo);
					}
					else
					{
						P_RemoveMobj(mo);
					}
					return;
				}
				P_ExplodeMissile(mo);
			}
			//else if(mo->crashstate)
			//{
			//  mo->velocity.x = mo->velocity.y = 0;
			//  P_SetMobjState(mo, mo->crashstate);
			//  return;
			//}
			else
			{
				mo->velocity.x = mo->velocity.y = 0.0;
			}
		}
	}
	while (xmove || ymove);
}

//==========================================================================
//
//  TEST ON MOBJ
//
//==========================================================================

mobj_t *tzmthing;
float tzmx;
float tzmy;
float tzmz;

mobj_t *onmobj;	//generic global onmobj...used for landing on pods/players

//==========================================================================
//
//  PIT_CheckOnmobjZ
//
//==========================================================================

boolean PIT_CheckOnmobjZ(mobj_t * thing)
{
	float blockdist;

	if (!(thing->flags & (MF_SOLID | MF_SPECIAL | MF_SHOOTABLE)))
	{
		// Can't hit thing
		return true;
	}
	blockdist = thing->radius + tzmthing->radius;
	if (fabs(thing->origin.x - tzmx) >= blockdist
		|| fabs(thing->origin.y - tzmy) >= blockdist)
	{
		// Didn't hit thing
		return true;
	}
	if (thing == tzmthing)
	{
		// Don't clip against self
		return true;
	}
	if (tzmz > thing->origin.z + thing->height)
	{
		return true;
	}
	else if (tzmz + tzmthing->height < thing->origin.z)
	{
		// under thing
		return true;
	}
	if (thing->flags & MF_SOLID)
	{
		onmobj = thing;
	}
	return (!(thing->flags & MF_SOLID));
}

//=============================================================================
//
//  P_FakeZMovement
//
//  Fake the zmovement so that we can check if a move is legal
//
//=============================================================================

void P_FakeZMovement(mobj_t * mo)
{
	float dist;
	float delta;

	//
	//  adjust height
	//
	tzmz += mo->velocity.z * frametime;
	if (mo->flags & MF_FLOAT && mo->target)
	{
		// float down towards target if too close
		if (!(mo->flags & MF_SKULLFLY) && !(mo->flags & MF_INFLOAT))
		{
			dist = MobjDist2(mo, mo->target);
			delta = mo->target->origin.z + mo->height / 2.0 - tzmz;
			if (delta < 0.0 && dist < -(delta * 3.0))
				tzmz -= FLOATSPEED * frametime;
			else if (delta > 0.0 && dist < (delta * 3.0))
				tzmz += FLOATSPEED * frametime;
		}
	}
	if (mo->player && mo->flags2 & MF2_FLY && !(tzmz <= mo->floorz)
		&& level->tictime & 2)
	{
		tzmz += sin(ANG90 / 20 * level->tictime);
	}

	//
	//  clip movement
	//
	if (tzmz <= mo->floorz)
	{
		// Hit the floor
		tzmz = mo->floorz;
		if (mo->crashstate && (mo->flags & MF_CORPSE))
		{
			return;
		}
	}

	if (tzmz + mo->height > mo->ceilingz)
	{
		// hit the ceiling
		tzmz = mo->ceilingz - mo->height;
	}
}

//=============================================================================
//
//  P_CheckOnmobj
//
//  Checks if the new Z position is legal
//
//=============================================================================

mobj_t *P_CheckOnmobj(mobj_t * thing)
{
	int xl, xh, yl, yh, bx, by;

	tzmthing = thing;
	tzmx = thing->origin.x;
	tzmy = thing->origin.y;
	tzmz = thing->origin.z;
	P_FakeZMovement(tzmthing);

	if (thing->flags & MF_NOCLIP)
		return NULL;

	//
	// check things first, possibly picking things up
	// the bounding box is extended by MAXRADIUS because mobj_ts are grouped
	// into mapblocks based on their origin point, and can overlap into adjacent
	// blocks by up to MAXRADIUS units
	//
	xl =
		MapBlock(thing->origin.x - thing->radius - level->bmaporgx -
		MAXRADIUS);
	xh =
		MapBlock(thing->origin.x + thing->radius - level->bmaporgx +
		MAXRADIUS);
	yl =
		MapBlock(thing->origin.y - thing->radius - level->bmaporgy -
		MAXRADIUS);
	yh =
		MapBlock(thing->origin.y + thing->radius - level->bmaporgy +
		MAXRADIUS);

	for (bx = xl; bx <= xh; bx++)
		for (by = yl; by <= yh; by++)
			if (!P_BlockThingsIterator(bx, by, PIT_CheckOnmobjZ))
			{
				return onmobj;
			}
	return NULL;
}

//==========================================================================
//
//  P_ZMovement
//
//==========================================================================

void P_ZMovement(mobj_t * mo)
{
	float dist;
	float delta;

	//
	// check for smooth step up
	//
	if (mo->player && mo->origin.z < mo->floorz)
	{
		mo->player->viewheight -= mo->floorz - mo->origin.z;
		mo->player->deltaviewheight =
			(VIEWHEIGHT - mo->player->viewheight) / 8.0;
	}
	//
	// adjust height
	//
	mo->origin.z += mo->velocity.z * frametime;
	if (mo->flags & MF_FLOAT && mo->target)
	{	// float down towards target if too close
		if (!(mo->flags & MF_SKULLFLY) && !(mo->flags & MF_INFLOAT))
		{
			dist = MobjDist2(mo, mo->target);
			delta = mo->target->origin.z + mo->height / 2.0 - mo->origin.z;
			if (delta < 0.0 && dist < -delta * 3.0)
				mo->origin.z -= FLOATSPEED * frametime;
			else if (delta > 0.0 && dist < delta * 3.0)
				mo->origin.z += FLOATSPEED * frametime;
		}
	}
	if (mo->player && mo->flags2 & MF2_FLY && !(mo->origin.z <= mo->floorz)
		&& level->tictime & 2)
	{
		mo->origin.z += sin(ANG90 / 20 * level->tictime);
	}

	//
	// clip movement
	//
	if (mo->origin.z <= mo->floorz)
	{	// Hit the floor
		if (mo->flags & MF_MISSILE)
		{
			mo->origin.z = mo->floorz;
			if (mo->flags2 & MF2_FLOORBOUNCE)
			{
				P_FloorBounceMissile(mo);
				return;
			}
			else if (mo->type == MT_HOLY_FX)
			{	// The spirit struck the ground
				mo->velocity.z = 0.0;
				P_HitFloor(mo);
				return;
			}
			else if (mo->type == MT_MNTRFX2 || mo->type == MT_LIGHTNING_FLOOR)
			{
				// Minotaur floor fire can go up steps
				return;
			}
			else
			{
				P_HitFloor(mo);
				P_ExplodeMissile(mo);
				return;
			}
		}
		if (mo->flags & MF_COUNTKILL)	// Blasted mobj falling
		{
			if (mo->velocity.z < -23.0 * 35.0)
			{
				P_MonsterFallingDamage(mo);
			}
		}
		if (mo->origin.z - mo->velocity.z * frametime > mo->floorz)
		{	// Spawn splashes, etc.
			P_HitFloor(mo);
		}
		mo->origin.z = mo->floorz;
		if (mo->velocity.z < 0.0)
		{
			if (mo->flags2 & MF2_ICEDAMAGE
				&& mo->velocity.z < -GRAVITY * 0.25)
			{
				mo->time = 0.1;
				mo->velocity.x = 0.0;
				mo->velocity.y = 0.0;
				mo->velocity.z = 0.0;
				return;
			}
			if (mo->player)
			{
				mo->player->jumpTics = 7;	// delay any jumping for a short time
				if (mo->velocity.z < -GRAVITY * 0.25
					&& !(mo->flags2 & MF2_FLY))
				{	// squat down
					mo->player->deltaviewheight =
						mo->velocity.z * frametime / 8.0;
					if (mo->velocity.z < -23.0 * 35.0)
					{
						P_FallingDamage(mo->player);
						P_NoiseAlert(mo, mo);
					}
					else if (mo->velocity.z < -GRAVITY * 0.375
						&& !mo->player->morphTics)
					{
						StartSoundName(mo, "PlayerLand", CHAN_BODY);
						switch (mo->player->pclass)
						{
						case PCLASS_FIGHTER:
							StartSoundName(mo, "PlayerFighterGrunt",
								CHAN_VOICE);
							break;
						case PCLASS_CLERIC:
							StartSoundName(mo, "PlayerClericGrunt",
								CHAN_VOICE);
							break;
						case PCLASS_MAGE:
							StartSoundName(mo, "PlayerMageGrunt", CHAN_VOICE);
							break;
						default:
							break;
						}
					}
					else if ((P_GetThingFloorType(mo) < FLOOR_LIQUID) &&
						(!mo->player->morphTics))
					{
						StartSoundName(mo, "PlayerLand", CHAN_BODY);
					}
//FIXME                 mo->player->centering = true;
				}
			}
			else if (mo->type >= MT_POTTERY1 && mo->type <= MT_POTTERY3)
			{
				DamageMobj(mo, NULL, NULL, 25);
			}
			else if (mo->flags & MF_COUNTKILL)
			{
				if (mo->velocity.z < -23.0 * 35.0)
				{
					// Doesn't get here
				}
			}
			mo->velocity.z = 0.0;
		}
		if (mo->flags & MF_SKULLFLY)
		{	// The skull slammed into something
			mo->velocity.z = -mo->velocity.z;
		}
		if (mo->crashstate &&
			(mo->flags & MF_CORPSE) && !(mo->flags2 & MF2_ICEDAMAGE))
		{
			SetMobjState(mo, mo->crashstate);
			return;
		}
	}

	if (mo->origin.z + mo->height > mo->ceilingz)
	{	// hit the ceiling
		if (mo->velocity.z > 0.0)
			mo->velocity.z = 0.0;
		mo->origin.z = mo->ceilingz - mo->height;
		if (mo->flags2 & MF2_FLOORBOUNCE)
		{
			// Maybe reverse momentum here for ceiling bounce
			// Currently won't happen

			if (mo->sound_sight)
			{
				StartSound(mo, mo->sound_sight, CHAN_VOICE);
			}
			return;
		}
		if (mo->flags & MF_SKULLFLY)
		{	// the skull slammed into something
			mo->velocity.z = -mo->velocity.z;
		}
		if (mo->flags & MF_MISSILE)
		{
			if (mo->type == MT_LIGHTNING_CEILING)
			{
				return;
			}
			if (mo->ceiling->pic == skyflatnum)
			{
				if (mo->type == MT_BLOODYSKULL)
				{
					mo->velocity.x = mo->velocity.y = 0.0;
					mo->velocity.z = -1.0 * 35.0;
				}
				else if (mo->type == MT_HOLY_FX)
				{
					P_ExplodeMissile(mo);
				}
				else
				{
					P_RemoveMobj(mo);
				}
				return;
			}
			P_ExplodeMissile(mo);
			return;
		}
	}
}

//==========================================================================
//
//  ResetBlasted
//
//==========================================================================

void ResetBlasted(mobj_t * mo)
{
	mo->flags2 &= ~MF2_BLASTED;
	if (!(mo->flags & MF_ICECORPSE))
	{
		mo->flags2 &= ~MF2_SLIDE;
	}
}

//===========================================================================
//
//  PlayerLandedOnThing
//
//===========================================================================

void PlayerLandedOnThing(mobj_t * mo, mobj_t * onmobj)
{
	mo->player->deltaviewheight = mo->velocity.z * frametime / 8.0;
	if (mo->velocity.z < -23.0 * 35.0)
	{
		P_FallingDamage(mo->player);
		P_NoiseAlert(mo, mo);
	}
	else if (mo->velocity.z < -GRAVITY * 0.375 && !mo->player->morphTics)
	{
		StartSoundName(mo, "PlayerLand", CHAN_BODY);
		switch (mo->player->pclass)
		{
		case PCLASS_FIGHTER:
			StartSoundName(mo, "PlayerFighterGrunt", CHAN_VOICE);
			break;
		case PCLASS_CLERIC:
			StartSoundName(mo, "PlayerClericGrunt", CHAN_VOICE);
			break;
		case PCLASS_MAGE:
			StartSoundName(mo, "PlayerMageGrunt", CHAN_VOICE);
			break;
		default:
			break;
		}
	}
	else if (!mo->player->morphTics)
	{
		StartSoundName(mo, "PlayerLand", CHAN_BODY);
	}
//FIXME mo->player->centering = true;
}

//==========================================================================
//
//  BlasterMobjThinker
//
//==========================================================================

void BlasterMobjThinker(mobj_t * mobj)
{
	int i;
	float xfrac;
	float yfrac;
	float zfrac;
	float z;
	boolean changexy;
	mobj_t *mo;

	// Handle movement
	if (mobj->velocity.x || mobj->velocity.y
		|| (mobj->origin.z != mobj->floorz) || mobj->velocity.z)
	{
		xfrac = mobj->velocity.x * frametime / 8.0;
		yfrac = mobj->velocity.y * frametime / 8.0;
		zfrac = mobj->velocity.z * frametime / 8.0;
		changexy = xfrac || yfrac;
		for (i = 0; i < 8; i++)
		{
			if (changexy)
			{
				if (!P_TryMove(mobj, mobj->origin.x + xfrac,
						mobj->origin.y + yfrac))
				{
					// Blocked move
					P_ExplodeMissile(mobj);
					return;
				}
			}
			mobj->origin.z += zfrac;
			if (mobj->origin.z <= mobj->floorz)
			{
				// Hit the floor
				mobj->origin.z = mobj->floorz;
				P_HitFloor(mobj);
				P_ExplodeMissile(mobj);
				return;
			}
			if (mobj->origin.z + mobj->height > mobj->ceilingz)
			{
				// Hit the ceiling
				mobj->origin.z = mobj->ceilingz - mobj->height;
				P_ExplodeMissile(mobj);
				return;
			}
			if (changexy)
			{
				if (mobj->type == MT_MWAND_MISSILE && (P_Random() < 128))
				{
					z = mobj->origin.z - 8.0;
					if (z < mobj->floorz)
					{
						z = mobj->floorz;
					}
					P_SpawnMobj(mobj->origin.x, mobj->origin.y, z,
						MT_MWANDSMOKE);
				}
				else if (!--mobj->special1)
				{
					mobj->special1 = 4;
					z = mobj->origin.z - 12.0;
					if (z < mobj->floorz)
					{
						z = mobj->floorz;
					}
					mo =
						P_SpawnMobj(mobj->origin.x, mobj->origin.y, z,
						MT_CFLAMEFLOOR);
					if (mo)
					{
						mo->angles.yaw = mobj->angles.yaw;
					}
				}
			}
		}
	}
	// Advance the state
	if (mobj->time != -1.0)
	{
		mobj->time -= frametime;
		if (mobj->time <= 0.0)
		{
			mobj->time = 0.0;
			if (!SetMobjState(mobj, mobj->nextstate))
			{	// mobj was removed
				return;
			}
		}
	}
}

//==========================================================================
//
//  P_MobjThinker
//
//==========================================================================

void P_MobjThinker(mobj_t * mobj)
{
	mobj_t *onmo;

	if (mobj->blaster)
	{
		BlasterMobjThinker(mobj);
		return;
	}

	CheckWater(mobj);
	if (!(mobj->flags2 & MF2_FLOATBOB))
		UpdateVelocity(mobj);

	// Handle X and Y momentums
	BlockingMobj = NULL;
	if (mobj->velocity.x || mobj->velocity.y || (mobj->flags & MF_SKULLFLY))
	{
		P_XYMovement(mobj);
		if (mobj->destroyed)
		{
			// mobj was removed
			return;
		}
	}
	else if (mobj->flags2 & MF2_BLASTED)
	{
		// Reset to not blasted when momentums are gone
		ResetBlasted(mobj);
	}

	if (mobj->flags2 & MF2_FLOATBOB)
	{
		// Floating item bobbing motion (special1 is height)
		mobj->origin.z = mobj->floorz +
			mobj->special1f + FloatBobOffsets[(mobj->health++) & 63];
	}
	else if ((mobj->origin.z != mobj->floorz) || mobj->velocity.z
		|| BlockingMobj)
	{
		// Handle Z momentum and gravity
		if (mobj->flags2 & MF2_PASSMOBJ)
		{
			if (!(onmo = P_CheckOnmobj(mobj)))
			{
				P_ZMovement(mobj);
				if (mobj->player && mobj->flags & MF2_ONMOBJ)
				{
					mobj->flags2 &= ~MF2_ONMOBJ;
				}
			}
			else
			{
				if (mobj->player)
				{
					if (mobj->velocity.z < -GRAVITY * 0.25 &&
						!(mobj->flags2 & MF2_FLY))
					{
						PlayerLandedOnThing(mobj, onmo);
					}
					if (onmo->origin.z + onmo->height - mobj->origin.z <=
						24.0)
					{
						mobj->player->viewheight -=
							onmo->origin.z + onmo->height - mobj->origin.z;
						mobj->player->deltaviewheight =
							(VIEWHEIGHT - mobj->player->viewheight) / 8.0;
						mobj->origin.z = onmo->origin.z + onmo->height;
						mobj->flags2 |= MF2_ONMOBJ;
						mobj->velocity.z = 0.0;
					}
					else
					{
						// hit the bottom of the blocking mobj
						mobj->velocity.z = 0.0;
					}
				}
/* Landing on another player, and mimicking his movements
				if(mobj->player && onmo->player)
				{
					mobj->velocity.x = onmo->velocity.x;
					mobj->velocity.y = onmo->velocity.y;
					if(onmo->origin.z < onmo->floorz)
					{
						mobj->origin.z += onmo->floorz-onmo->origin.z;
						if(onmo->player)
						{
							onmo->player->viewheight -= onmo->floorz-onmo->origin.z;
							onmo->player->deltaviewheight = (VIEWHEIGHT-
								onmo->player->viewheight)>>3;
						}
						onmo->origin.z = onmo->floorz;
					}
				}
*/
			}
		}
		else
		{
			P_ZMovement(mobj);
		}
		if (mobj->destroyed)
		{
			// mobj was removed
			return;
		}
	}

	// Cycle through states, calling action functions at transitions
	if (mobj->time != -1.0)
	{
		mobj->time -= frametime;
		// you can cycle through multiple states in a tic
		if (mobj->time <= 0.0)
		{
			mobj->time = 0.0;
			if (!SetMobjState(mobj, mobj->nextstate))
			{
				// mobj was removed
				return;
			}
		}
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.5  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.4  2001/09/20 16:20:00  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.3  2001/08/30 17:33:17  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
