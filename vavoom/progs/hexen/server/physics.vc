//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define FLOATSPEED		140.0

#define MAXMOVE 			1050.0
#define MAXMOVESTEP			15.0	//MAXMOVE / (35.0 * 2.0)
#define STOPSPEED			2.1875

#define FRICTION_NORMAL		3.28125
#define FRICTION_LOW		0.95703125
#define FRICTION_FLY		2.87109375
#define FRICTION_WATER		3.0

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  ClipVelocity
//
//  Slide off of the impacting object
//
//==========================================================================

TVec ClipVelocity(TVec in, TVec normal, float overbounce)
{
	return in - normal * (DotProduct(in, normal) * overbounce);
}

//**************************************************************************
//
//  SLIDE MOVE
//
//  Allows the player to slide along any angled walls.
//
//**************************************************************************

float bestslidefrac;
float secondslidefrac;

line_t *bestslideline;
line_t *secondslideline;

Actor slidemo;
TVec slideorg;
TVec slidedir;

//==========================================================================
//
//  PTR_SlideTraverse
//
//==========================================================================

boolean PTR_SlideTraverse(intercept_t * in)
{
	line_t *li;
	TVec hit_point;
	opening_t *open;

	if (!in->isaline)
		Error("PTR_SlideTraverse: not a line?");

	li = in->line;

	if (li->flags & ML_TWOSIDED)
	{
		// set openrange, opentop, openbottom
		hit_point = slideorg + in->frac * slidedir;
		open = LineOpenings(li, hit_point);
		open =
			FindOpening(open, slidemo.Origin.z,
			slidemo.Origin.z + slidemo.Height);

		if (open && (open->range >= slidemo.Height) &&	//  fits
			(open->top - slidemo.Origin.z >= slidemo.Height) &&	// mobj is not too high
			(open->bottom - slidemo.Origin.z <= slidemo.MaxStepHeight))	// not too big a step up
		{
			// this line doesn't block movement
			return true;
		}
	}
	else
	{
		if (PointOnPlaneSide(slidemo.Origin, li))
		{
			// don't hit the back side
			return true;
		}
	}

	// the line does block movement,
	// see if it is closer than best so far
	if (in->frac < bestslidefrac)
	{
		secondslidefrac = bestslidefrac;
		secondslideline = bestslideline;
		bestslidefrac = in->frac;
		bestslideline = li;
	}

	return false;	// stop
}

//==========================================================================
//
//  SlidePathTraverse
//
//==========================================================================

void SlidePathTraverse(float x, float y)
{
	slideorg = vector(x, y, slidemo.Origin.z);
	slidedir = slidemo.Velocity * frametime;
	P_PathTraverse(x, y, x + slidedir.x, y + slidedir.y,
		PT_ADDLINES, 'PTR_SlideTraverse');
}

//==========================================================================
//
//  Actor::SlideMove
//
//  The momx / momy move is bad, so try to slide along a wall.
//  Find the first line hit, move flush to it, and slide along it.
//  This is a kludgy mess.
//
//==========================================================================

void Actor::SlideMove(void)
{
	float leadx;
	float leady;
	float trailx;
	float traily;
	float newx;
	float newy;
	int hitcount;

	slidemo = self;
	hitcount = 0;

	do
	{
		if (++hitcount == 3)
		{
			// don't loop forever
			if (!TryMove(vector(Origin.x, Origin.y + Velocity.y * frametime, Origin.z)))
			{
				TryMove(vector(Origin.x + Velocity.x * frametime, Origin.y, Origin.z));
			}
			return;
		}

		// trace along the three leading corners
		if (Velocity.x > 0.0)
		{
			leadx = Origin.x + Radius;
			trailx = Origin.x - Radius;
		}
		else
		{
			leadx = Origin.x - Radius;
			trailx = Origin.x + Radius;
		}

		if (Velocity.y > 0.0)
		{
			leady = Origin.y + Radius;
			traily = Origin.y - Radius;
		}
		else
		{
			leady = Origin.y - Radius;
			traily = Origin.y + Radius;
		}

		bestslidefrac = 1.00001;

		SlidePathTraverse(leadx, leady);
		SlidePathTraverse(trailx, leady);
		SlidePathTraverse(leadx, traily);

		// move up to the wall
		if (bestslidefrac == 1.00001)
		{
			// the move most have hit the middle, so stairstep
			if (!TryMove(vector(Origin.x, Origin.y + Velocity.y * frametime, Origin.z)))
			{
				TryMove(vector(Origin.x + Velocity.x * frametime, Origin.y, Origin.z));
			}
			return;
		}

		// fudge a bit to make sure it doesn't hit
		bestslidefrac -= 0.03125;
		if (bestslidefrac > 0.0)
		{
			newx = Velocity.x * frametime * bestslidefrac;
			newy = Velocity.y * frametime * bestslidefrac;

			if (!TryMove(vector(Origin.x + newx, Origin.y + newy, Origin.z)))
			{
				if (!TryMove(vector(Origin.x, Origin.y + Velocity.y * frametime, Origin.z)))
				{
					TryMove(vector(Origin.x + Velocity.x * frametime, Origin.y, Origin.z));
				}
				return;
			}
		}

		// Now continue along the wall.
		// First calculate remainder.
		bestslidefrac = 1.0 - (bestslidefrac + 0.03125);

		if (bestslidefrac > 1.0)
			bestslidefrac = 1.0;

		if (bestslidefrac <= 0.0)
			return;

		// clip the moves
		Velocity = ClipVelocity(Velocity * bestslidefrac,
			bestslideline->normal, 1.0);

	}
	while (!TryMove(vector(Origin.x + Velocity.x * frametime,
			Origin.y + Velocity.y * frametime, Origin.z)));
}

//**************************************************************************
//
//  BOUNCING
//
//  Bounce missile against walls
//
//**************************************************************************

//============================================================================
//
//  PTR_BounceTraverse
//
//============================================================================

boolean PTR_BounceTraverse(intercept_t * in)
{
	line_t *li;
	TVec hit_point;
	opening_t *open;

	if (!in->isaline)
		Error("PTR_BounceTraverse: not a line?");

	li = in->line;
	if (li->flags & ML_TWOSIDED)
	{
		hit_point = slideorg + in->frac * slidedir;
		open = LineOpenings(li, hit_point);	// set openrange, opentop, openbottom
		open = FindOpening(open, slidemo.Origin.z,
			slidemo.Origin.z + slidemo.Height);
		if (open && open->range >= slidemo.Height &&	// fits
			open->top - slidemo.Origin.z >= slidemo.Height)	// mobj is not too high
		{
			return true;	// this line doesn't block movement
		}
	}
	else
	{
		if (PointOnPlaneSide(slidemo.Origin, li))
		{
			return true;	// don't hit the back side
		}
	}

	// the line does block movement, see if it is closer than best so far
	if (in->frac < bestslidefrac)
	{
		secondslidefrac = bestslidefrac;
		secondslideline = bestslideline;
		bestslidefrac = in->frac;
		bestslideline = li;
	}
	return false;	// stop
}

//============================================================================
//
//  Actor::BounceWall
//
//============================================================================

void Actor::BounceWall(void)
{
	float leadx, leady;

	slidemo = self;

	//
	// trace along the three leading corners
	//
	if (Velocity.x > 0.0)
	{
		leadx = Origin.x + Radius;
	}
	else
	{
		leadx = Origin.x - Radius;
	}
	if (Velocity.y > 0.0)
	{
		leady = Origin.y + Radius;
	}
	else
	{
		leady = Origin.y - Radius;
	}
	bestslidefrac = 1.00001;
	slideorg = vector(leadx, leady, Origin.z);
	slidedir = Velocity * frametime;
	bestslideline = NULL;
	P_PathTraverse(leadx, leady, leadx + slidedir.x, leady + slidedir.y,
		PT_ADDLINES, 'PTR_BounceTraverse');
	if (bestslideline)
	{
		Velocity = ClipVelocity(Velocity * 0.75, bestslideline->normal, 2.0);
	}
}

//**************************************************************************
//
//  OBJECT MOVEMENT
//
//**************************************************************************

//==========================================================================
//
//	Actor::ApplyFriction
//
//==========================================================================

void Actor::ApplyFriction(void)
{
	if (bSkullFly || bMissile)
	{
		return;
	}
	if (Origin.z > FloorZ && WaterLevel < 2 && !bFly && !bOnMobj)
	{
		// No friction when falling
		if (Class != BlastEffect)
			return;
	}

	if (Origin.z <= FloorZ)
	{
		//  Clip velocity
		float dot = DotProduct(Velocity, Floor->normal);

		if (dot < 0.0)
		{
			Velocity -= dot * Floor->normal;
		}
	}

	if (bCorpse)
	{
		// Don't stop sliding if halfway off a step with some momentum
		if (Velocity.x > 0.25 * 35.0 || Velocity.x < -0.25 * 35.0 ||
			Velocity.y > 0.25 * 35.0 || Velocity.y < -0.25 * 35.0)
		{
			if (FloorZ != Sector->floorheight)
			{
				return;
			}
		}
	}
	if (Velocity.x > -STOPSPEED && Velocity.x < STOPSPEED &&
		Velocity.y > -STOPSPEED && Velocity.y < STOPSPEED &&
		Velocity.z > -STOPSPEED && Velocity.z < STOPSPEED &&
		(!bIsPlayer || (!Player->ForwardMove && !Player->SideMove)))
	{
		// If in a walking frame, stop moving
		if (bIsPlayer)
		{
			int sn;

			sn = StateNum - SeeState;
			if (sn >= 0 && sn < 4)
			{
				SetState(SpawnState);
			}
		}
		Velocity = vector(0.0, 0.0, 0.0);
	}
	else
	{
		if (WaterLevel >= 2)
		{
			Velocity -= Velocity * FRICTION_WATER * frametime;
		}
		else if (bFly && !(Origin.z <= FloorZ) && !bOnMobj)
		{
			Velocity -= Velocity * FRICTION_FLY * frametime;
		}
		else if (GetFloorType() == FLOOR_ICE)
		{
			Velocity -= Velocity * FRICTION_LOW * frametime;
		}
		else
		{
			Velocity -= Velocity * FRICTION_NORMAL * frametime;
		}
	}
}

//==========================================================================
//
//	Actor::HitMobj
//
//==========================================================================

boolean Actor::HitMobj(Entity Other)
{
	float angle;

	if (bMissile)
	{
		if (bFloorBounce)
		{
			if (Actor(Other).bReflective || (!Other.bIsPlayer &&
				!Actor(Other).bCountKill))
			{
				float speed;

				angle = AngleMod360(atan2(Origin.y - Other.Origin.y,
					Origin.x - Other.Origin.x) + Random() * 16.0 - 8.0);
				speed = Length(Velocity);
				speed = speed * 0.75;
				Angles.yaw = angle;
				Velocity.x = speed * cos(angle);
				Velocity.y = speed * sin(angle);
				if (SightSound)
				{
					PlaySound(SightSound, CHAN_VOICE);
				}
				return true;
			}
			else
			{
				// Struck a player/creature
				return ExplodeMissile();
			}
		}
		if (Actor(Other).bReflective)
		{
			int explode = false;

			angle = atan2(Origin.y - Other.Origin.y,
				Origin.x - Other.Origin.x);

			// Change angle for delflection/reflection
			switch (Other.Class)
			{
			case Centaur:
			case CentaurLeader:
				if (fabs(AngleMod180(angle -
					Other.Angles.yaw)) > 45.0 * 45.0 / 32.0)
				{
					explode = true;
					break;
				}
				if (Class == HolyFX)
				{
					explode = true;
					break;
				}
				// Drop through to sorcerer full reflection
			case Sorcerer:
				// Deflection
				if (P_Random() < 128)
					angle = AngleMod360(angle + 45.0);
				else
					angle = AngleMod360(angle - 45.0);
				break;
			default:
				// Reflection
				angle = AngleMod360(angle + itof((P_Random() % 16) - 8));
				break;
			}

			if (!explode)
			{
				// Reflect the missile along angle
				Angles.yaw = angle;
				Velocity.x = (Speed / 2.0) * cos(angle);
				Velocity.y = (Speed / 2.0) * sin(angle);
//				Velocity.z = -Velocity.z;
				if (bSeekerMissile)
				{
					Enemy = Instigator;
				}
				Instigator = Other;
				return true;
			}
		}
		// Explode a missile
		return ExplodeMissile();
	}
	else
	{
		if (bSlide)
		{
			// Try to slide along it
			// Slide against mobj
//			if (TryMove(vector(Origin.x, ptryy, Origin.z)))
			if (TryMove(vector(Origin.x, Origin.y + Velocity.y * frametime, Origin.z)))
			{
				Velocity.x = 0.0;
			}
//			else if (TryMove(vector(ptryx, Origin.y, Origin.z)))
			else if (TryMove(vector(Origin.x + Velocity.x * frametime, Origin.y, Origin.z)))
			{
				Velocity.y = 0.0;
			}
			else
			{
				Velocity.x = 0.0;
				Velocity.y = 0.0;
			}
		}
		else
		{
			Velocity.x = 0.0;
			Velocity.y = 0.0;
		}
		return true;
	}
}

//==========================================================================
//
//	Actor::HitLine
//
//==========================================================================

boolean Actor::HitLine(void)
{
	if (bMissile)
	{
		if (bFloorBounce)
		{
			// Struck a wall
			BounceWall();
			switch (Class)
			{
			case SorcererBall1:
			case SorcererBall2:
			case SorcererBall3:
			case SorcererFX1:
				break;
			default:
				if (SightSound)
				{
					PlaySound(SightSound, CHAN_VOICE);
				}
				break;
			}
			return true;
		}

		// Explode a missile
		if (tmtrace->CeilingLine && tmtrace->CeilingLine->backsector &&
			tmtrace->CeilingLine->backsector->ceiling.pic == skyflatnum)
		{
			// Hack to prevent missiles exploding against the sky
			if (Class == BloodySkull)
			{
				Velocity = vector(0.0, 0.0, -1.0 * 35.0);
			}
			else if (Class == HolyFX)
			{
				if (!ExplodeMissile())
				{
					return false;
				}
			}
			else
			{
				Remove();
				return false;
			}
			return true;
		}
		if (!ExplodeMissile())
		{
			return false;
		}
	}
	else
	{
		if (bSlide)
		{
			// Try to slide along it
			// Slide against wall
			SlideMove();
		}
		else
		{
			Velocity.x = 0.0;
			Velocity.y = 0.0;
		}
	}
	return true;
}

//==========================================================================
//
//	Actor::XYMovement
//
//==========================================================================

boolean Actor::XYMovement(void)
{
	float ptryx, ptryy;
	float xmove, ymove;
	int special;

	if (bWindThrust)
	{
		special = Sector->special;
		switch (special)
		{
		case 40:
		case 41:
		case 42:	// Wind_East
			Thrust(0.0, windTab[special - 40]);
			break;
		case 43:
		case 44:
		case 45:	// Wind_North
			Thrust(90.0, windTab[special - 43]);
			break;
		case 46:
		case 47:
		case 48:	// Wind_South
			Thrust(270.0, windTab[special - 46]);
			break;
		case 49:
		case 50:
		case 51:	// Wind_West
			Thrust(180.0, windTab[special - 49]);
			break;
		}
	}
	if (Velocity.x > MAXMOVE)
	{
		Velocity.x = MAXMOVE;
	}
	else if (Velocity.x < -MAXMOVE)
	{
		Velocity.x = -MAXMOVE;
	}
	if (Velocity.y > MAXMOVE)
	{
		Velocity.y = MAXMOVE;
	}
	else if (Velocity.y < -MAXMOVE)
	{
		Velocity.y = -MAXMOVE;
	}
	xmove = Velocity.x * frametime;
	ymove = Velocity.y * frametime;
	do
	{
		if (xmove > MAXMOVESTEP || ymove > MAXMOVESTEP)
		{
			ptryx = Origin.x + xmove / 2.0;
			ptryy = Origin.y + ymove / 2.0;
			xmove /= 2.0;
			ymove /= 2.0;
		}
		else
		{
			ptryx = Origin.x + xmove;
			ptryy = Origin.y + ymove;
			xmove = 0.0;
			ymove = 0.0;
		}
		if (!TryMove(vector(ptryx, ptryy, Origin.z)))
		{
			// Blocked move
			if (tmtrace->BlockingMobj)
			{
				return HitMobj(Entity(tmtrace->BlockingMobj));
			}
			else
			{
				return HitLine();
			}
		}
	}
	while (xmove || ymove);

	return true;
}

//==========================================================================
//
//	Actor::HitFloor
//
//==========================================================================

boolean Actor::HitFloor(void)
{
	float vdot;

	if (bMissile)
	{
		Origin.z = FloorZ;
		if (bFloorBounce)
		{
			FloorBounceMissile();
			return true;
		}
		else if (Class == HolyFX)
		{
			// The spirit struck the ground
			Velocity.z = 0.0;
			HitFloorType();
			return true;
		}
		else if (Class == MinotaurFloorFire1 || Class == LightningFloor)
		{
			// Minotaur floor fire can go up steps
			return true;
		}
		else
		{
			HitFloorType();
			return ExplodeMissile();
		}
	}

	vdot = DotProduct(Velocity, Floor->normal);
	if (bCountKill)	// Blasted mobj falling
	{
		if (vdot < -23.0 * 35.0)
		{
			MonsterFallingDamage();
		}
	}
	if (Origin.z - Velocity.z * frametime > FloorZ)
	{
		// Spawn splashes, etc.
		HitFloorType();
	}
	Origin.z = FloorZ;
	if (vdot < -0.1)
	{
		if (bIceDamage && vdot < -GRAVITY * 0.25)
		{
			StateTime = 0.1;
			Velocity = vector(0.0, 0.0, 0.0);
			return true;
		}
		if (bIsPlayer)
		{
			Player->JumpTics = 7;	// delay any jumping for a short time
			if (vdot < -GRAVITY * 0.25 && !bFly)
			{
				// squat down
				Player->DeltaViewHeight = vdot * frametime / 8.0;
				if (vdot < -23.0 * 35.0)
				{
					FallingDamage();
					NoiseAlert(self, self);
				}
				else if (vdot < -GRAVITY * 0.375
					&& !Player->MorphTics)
				{
					PlaySound('PlayerLand', CHAN_BODY);
					switch (Player->PClass)
					{
					case PCLASS_FIGHTER:
						PlaySound('PlayerFighterGrunt', CHAN_VOICE);
						break;
					case PCLASS_CLERIC:
						PlaySound('PlayerClericGrunt', CHAN_VOICE);
						break;
					case PCLASS_MAGE:
						PlaySound('PlayerMageGrunt', CHAN_VOICE);
						break;
					default:
						break;
					}
				}
				else if (GetFloorType() < FLOOR_LIQUID && !Player->MorphTics)
				{
					PlaySound('PlayerLand', CHAN_BODY);
				}
//FIXME				Player->centering = true;
			}
		}
		else if (Class == Pottery1 || Class == Pottery2 || Class == Pottery3)
		{
			Damage(none, none, 25);
		}
		else if (bCountKill)
		{
			if (vdot < -23.0 * 35.0)
			{
				// Doesn't get here
			}
		}
		Velocity -= vdot * Floor->normal;
	}
	if (bSkullFly)
	{
		// The skull slammed into something
		Velocity = ClipVelocity(Velocity, Floor->normal, 2.0);
	}
	if (CrashState && bCorpse && !bIceDamage)
	{
		return SetState(CrashState);
	}
	return true;
}

//==========================================================================
//
//	Actor::HitCeiling
//
//==========================================================================

boolean Actor::HitCeiling(void)
{
	float vdot;

	vdot = DotProduct(Velocity, Ceiling->normal);
	if (vdot < 0.0)
	{
		Velocity -= vdot * Ceiling->normal;
	}
	Origin.z = CeilingZ - Height;
	if (bMissile)
	{
		if (bFloorBounce)
		{
			// Reverse momentum here for ceiling bounce
			Velocity -= vdot * Ceiling->normal;

			if (SightSound)
			{
				PlaySound(SightSound, CHAN_VOICE);
			}
			return true;
		}
		if (Class == LightningCeiling)
		{
			return true;
		}
		if (Ceiling->pic == skyflatnum)
		{
			if (Class == BloodySkull)
			{
				Velocity = vector(0.0, 0.0, -1.0 * 35.0);
			}
			else if (Class == HolyFX)
			{
				return ExplodeMissile();
			}
			else
			{
				Remove();
				return false;
			}
			return true;
		}
		return ExplodeMissile();
	}
	if (bSkullFly)
	{
		// the skull slammed into something
		Velocity.z = -Velocity.z;
	}
	return true;
}

//==========================================================================
//
//	Actor::ZMovement
//
//==========================================================================

boolean Actor::ZMovement(void)
{
	float dist;
	float delta;

	//
	// check for smooth step up
	//
	if (bIsPlayer && Origin.z < FloorZ)
	{
		Player->ViewHeight -= FloorZ - Origin.z;
		Player->DeltaViewHeight = (VIEWHEIGHT - Player->ViewHeight) / 8.0;
	}
	//
	// adjust height
	//
	Origin.z += Velocity.z * frametime;
	if (bFloat && Enemy)
	{
		// float down towards enemy if too close
		if (!bSkullFly && !bInFloat)
		{
			dist = MobjDist2(self, Enemy);
			delta = Enemy.Origin.z + Height / 2.0 - Origin.z;
			if (delta < 0.0 && dist < -delta * 3.0)
				Origin.z -= FLOATSPEED * frametime;
			else if (delta > 0.0 && dist < delta * 3.0)
				Origin.z += FLOATSPEED * frametime;
		}
	}
	if (bIsPlayer && bFly && !(Origin.z <= FloorZ) && level->tictime & 2)
	{
		Origin.z += sin(90.0 * 35.0 / 20.0 * level->time);
	}

	//
	// clip movement
	//
	if (Origin.z <= FloorZ + 0.1)
	{
		// Hit the floor
		return HitFloor();
	}

	if (Origin.z + Height > CeilingZ)
	{
		// hit the ceiling
		return HitCeiling();
	}
	return true;
}

//==========================================================================
//
//  Actor::ResetBlasted
//
//==========================================================================

void Actor::ResetBlasted(void)
{
	bBlasted = false;
	if (!bIceCorpse)
	{
		bSlide = false;
	}
}

//===========================================================================
//
//  Actor::PlayerLandedOnThing
//
//===========================================================================

void Actor::PlayerLandedOnThing(void)
{
	Player->DeltaViewHeight = Velocity.z * frametime / 8.0;
	if (Velocity.z < -23.0 * 35.0)
	{
		FallingDamage();
		NoiseAlert(self, self);
	}
	else if (Velocity.z < -GRAVITY * 0.375 && !Player->MorphTics)
	{
		PlaySound('PlayerLand', CHAN_BODY);
		switch (Player->PClass)
		{
		case PCLASS_FIGHTER:
			PlaySound('PlayerFighterGrunt', CHAN_VOICE);
			break;
		case PCLASS_CLERIC:
			PlaySound('PlayerClericGrunt', CHAN_VOICE);
			break;
		case PCLASS_MAGE:
			PlaySound('PlayerMageGrunt', CHAN_VOICE);
			break;
		default:
			break;
		}
	}
	else if (!Player->MorphTics)
	{
		PlaySound('PlayerLand', CHAN_BODY);
	}
//FIXME Player->centering = true;
}

//==========================================================================
//
//	Actor::BlasterPhysics
//
//==========================================================================

boolean Actor::BlasterPhysics(void)
{
	int i;
	float xfrac;
	float yfrac;
	float zfrac;
	float z;
	boolean changexy;
	Actor A;

	// Handle movement
	if (Velocity.x || Velocity.y || (Origin.z != FloorZ) || Velocity.z)
	{
		xfrac = Velocity.x * frametime / 8.0;
		yfrac = Velocity.y * frametime / 8.0;
		zfrac = Velocity.z * frametime / 8.0;
		changexy = xfrac || yfrac;
		for (i = 0; i < 8; i++)
		{
			if (changexy)
			{
				if (!TryMove(vector(Origin.x + xfrac, Origin.y + yfrac, Origin.z)))
				{
					// Blocked move
					return ExplodeMissile();
				}
			}
			Origin.z += zfrac;
			if (Origin.z <= FloorZ)
			{
				// Hit the floor
				Origin.z = FloorZ;
				HitFloorType();
				return ExplodeMissile();
			}
			if (Origin.z + Height > CeilingZ)
			{
				// Hit the ceiling
				Origin.z = CeilingZ - Height;
				return ExplodeMissile();
			}
			if (changexy)
			{
				if (Class == MageWandMissile && (P_Random() < 128))
				{
					z = Origin.z - 8.0;
					if (z < FloorZ)
					{
						z = FloorZ;
					}
					Spawn(MageWandSmoke, vector(Origin.x, Origin.y, z));
				}
				else if (Class != MageWandMissile && !--_Special1)
				{
					_Special1 = 4;
					z = Origin.z - 12.0;
					if (z < FloorZ)
					{
						z = FloorZ;
					}
					A = Spawn(ClericFlameFloor, vector(Origin.x, Origin.y, z));
					if (A)
					{
						A.Angles.yaw = Angles.yaw;
					}
				}
			}
		}
	}
	return true;
}

//==========================================================================
//
//	Actor::Physics
//
//==========================================================================

boolean Actor::Physics(void)
{
	Actor onmo;

	if (bBlaster)
	{
		return BlasterPhysics();
	}

	CheckWater();
	if (!bFloatBob)
		UpdateVelocity();

	// Handle X and Y momentums
	tmtrace->BlockingMobj = none;
	if (Velocity.x || Velocity.y)
	{
		if (!XYMovement())
		{
			return false;
		}
	}
	else if (bSkullFly)
	{
		// A flying mobj slammed into something
		bSkullFly = false;
		Velocity = vector(0.0, 0.0, 0.0);
		if (!SetState(SeeState))
		{
			return false;
		}
	}
	else if (bBlasted)
	{
		// Reset to not blasted when momentums are gone
		ResetBlasted();
	}

	if (bFloatBob)
	{
		// Floating item bobbing motion (special1 is height)
		Origin.z = FloorZ + Special1f + FloatBobOffsets[(Health++) & 63];
	}
	else if ((Origin.z != FloorZ) || Velocity.z || tmtrace->BlockingMobj)
	{
		// Handle Z momentum and gravity
		if (!bNoPassMobj && !bMissile)
		{
			onmo = Actor(CheckOnmobj());
			if (!onmo)
			{
				if (!ZMovement())
				{
					return false;
				}
				if (bIsPlayer && bOnMobj)
				{
					bOnMobj = false;
				}
			}
			else
			{
				if (bIsPlayer)
				{
					if (Velocity.z < -GRAVITY * 0.25 && !bFly)
					{
						PlayerLandedOnThing();
					}
					if (onmo.Origin.z + onmo.Height - Origin.z <= MaxStepHeight)
					{
						Player->ViewHeight -=
							onmo.Origin.z + onmo.Height - Origin.z;
						Player->DeltaViewHeight =
							(VIEWHEIGHT - Player->ViewHeight) / 8.0;
						Origin.z = onmo.Origin.z + onmo.Height;
						bOnMobj = true;
						Velocity.z = 0.0;
					}
					else
					{
						// hit the bottom of the blocking mobj
						Velocity.z = 0.0;
					}
				}
			}
		}
		else
		{
			if (!ZMovement())
			{
				return false;
			}
		}
	}
	return true;
}

//==========================================================================
//
//	Actor::Tick
//
//==========================================================================

void Actor::Tick(float deltaTime)
{
	if (!Physics())
	{
		return;
	}
	// Cycle through states, calling action functions at transitions
	if (StateTime != -1.0)
	{
		StateTime -= deltaTime;
		if (StateTime <= 0.0)
		{
			// you can cycle through multiple states in a tic
			do
			{
				if (!SetState(NextState))
				{
					// mobj was removed
					return;
				}
			}
			while (!StateTime);
		}
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.32  2002/04/11 16:50:53  dj_jl
//  Made TryMove native, Tick function.
//
//  Revision 1.31  2002/03/28 18:28:26  dj_jl
//  No checking for on-mobj for missiles.
//
//  Revision 1.30  2002/03/16 17:47:47  dj_jl
//  Got rid of mobj_t and some other legacy.
//
//  Revision 1.29  2002/03/09 17:57:02  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.28  2002/03/04 18:31:36  dj_jl
//  Replaced bNoClip with two seperate flags, beautification.
//
//  Revision 1.27  2002/03/02 18:00:15  dj_jl
//  Some smaller changes, beautification.
//
//  Revision 1.26  2002/02/26 17:49:49  dj_jl
//  no message
//
//  Revision 1.25  2002/02/22 18:00:23  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.24  2002/02/16 16:26:55  dj_jl
//  Removed precalculated sound IDs
//
//  Revision 1.23  2002/02/14 19:20:59  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.22  2002/02/06 17:28:53  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.21  2002/02/02 19:17:26  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.20  2002/01/28 18:50:19  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.19  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.18  2002/01/24 18:19:26  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.17  2002/01/17 18:15:55  dj_jl
//  Renamed all map object classes
//
//  Revision 1.16  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.15  2002/01/11 18:19:42  dj_jl
//  Started to use names in progs
//
//  Revision 1.14  2002/01/07 12:25:58  dj_jl
//  Changed copyright year
//
//  Revision 1.13  2001/12/27 17:52:23  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.12  2001/12/01 18:08:53  dj_jl
//  Physics functions as methods, started to use class references
//
//  Revision 1.11  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.10  2001/10/27 07:40:58  dj_jl
//  Switched some functions into class members
//
//  Revision 1.9  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.8  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.7  2001/10/04 17:27:52  dj_jl
//  Beautification
//
//  Revision 1.6  2001/10/02 17:42:38  dj_jl
//  Possibility to declare function's code inside class declaration
//
//  Revision 1.5  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.4  2001/09/20 16:20:00  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.3  2001/08/30 17:33:17  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
