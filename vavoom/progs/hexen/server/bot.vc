//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

int botskill = 2;

// CODE --------------------------------------------------------------------

/*

  This section contains the main bot AI. The
  main bot AI loop, B_Think, is called every tic.
  Also included are various bot decision-making
  procedures, such as B_CheckStuff and B_SetEnemy.

*/

#if 0
//
// B_ChooseWeapon
//
// Decide which weapon would be best to use in out situation
weapontype_t B_ChooseWeapon (skullb_s *bot)
{
	player_t *player = bot->player;
	AActor *MO = bot->player->MO;
	AActor *enemy = bot->enemy;
	fixed_t dist;

	if (!enemy)
		return player->readyweapon;

	dist = P_AproxDistance(MO->x - enemy->x, MO->y - enemy->y);

	if (dist <= MELEERANGE)
	{
		if (player->WeaponOwned[wp_supershotgun] && player->ammo[am_shell] >= 2)
			return wp_supershotgun;

		if (player->WeaponOwned[wp_plasma] && player->ammo[am_cell] >= 20)
			return wp_plasma;

		if (player->WeaponOwned[wp_railgun] && player->ammo[am_cell] >= 10)
			return wp_railgun;

		if (player->WeaponOwned[wp_chaingun] && player->ammo[am_clip] >= 20)
			return wp_chaingun;

		if (player->powers[pw_strength])
			return wp_fist;

		if (player->WeaponOwned[wp_chainsaw])
			return wp_chainsaw;

		if (player->WeaponOwned[wp_shotgun] && player->ammo[am_shell])
			return wp_shotgun;

		// Didn't find anything good
		return player->readyweapon;
	}

	else if (dist <= 512*FRACUNIT)
	{
		if (player->WeaponOwned[wp_plasma] && player->ammo[am_cell] >= 20)
			return wp_plasma;

		if (player->WeaponOwned[wp_supershotgun] && player->ammo[am_shell] >= 2)
			return wp_supershotgun;

		if (player->WeaponOwned[wp_grenlauncher] && player->ammo[am_misl] >= 2)
			return wp_grenlauncher;

		if (player->WeaponOwned[wp_missile] && player->ammo[am_misl] >= 2)
			return wp_missile;

		if (player->WeaponOwned[wp_railgun] && player->ammo[am_cell] >= 10)
			return wp_railgun;

		if (player->WeaponOwned[wp_chaingun] && player->ammo[am_clip])
			return wp_chaingun;

		if (player->WeaponOwned[wp_shotgun] && player->ammo[am_shell])
			return wp_shotgun;

		return player->readyweapon;
	}

	else
	{
		if (player->WeaponOwned[wp_railgun] && player->ammo[am_cell] >= 10)
			return wp_railgun;

		if (player->WeaponOwned[wp_chaingun] && player->ammo[am_clip])
			return wp_chaingun;

		if (player->WeaponOwned[wp_shotgun] && player->ammo[am_shell])
			return wp_shotgun;

		if (player->WeaponOwned[wp_plasma] && player->ammo[am_cell] >= 20)
			return wp_plasma;

		if (player->WeaponOwned[wp_missile] && player->ammo[am_misl] >= 2)
			return wp_missile;

		if (player->WeaponOwned[wp_grenlauncher] && player->ammo[am_misl] >= 2)
			return wp_grenlauncher;

		return player->readyweapon;
	}

	return player->readyweapon;
}

//
// B_Chat
//

// Tic down bot's typing time, and say our message if we're done
bool B_Chat (skullb_s *bot)
{
	// Chat ticker
	if (bot->t_chat)
	{
		if (!bot->chatline || !bot->chatline->string || !botchat.value)
		{
			bot->t_chat = 0;
			bot->player->icon = NULL;
			return false;
		}
		else
			bot->t_chat--;

		// Chat time has expired, time to say our line
		if (!bot->t_chat)
		{
			int plyrnum = P_GetPlayerNum(bot->player);
			Net_Command (DEM_SAY, 0, bot->chatline->string, plyrnum);

			// Handle responses
			for (int i=0; i<MAXPLAYERS; i++)
			{
				if (!GPlayers[i] || !GPlayers[i]->skullb)
					continue;
				if ((bot->info.chatinfo != CT_NONE) && (bot->chatline->bot == GPlayers[i]->skullb->info.chatinfo))
				{
					GPlayers[i]->skullb->chatline = bot->chatline->line;
					GPlayers[i]->skullb->t_chat = GPlayers[i]->skullb->info.chattime;
				}
			}
			bot->chatline = NULL;
		}
		
		// Don't do anything while "typing"
		return true;

	}

	return false;
}

/*

  This section of code contains the console commands
  related to the bots, such as "addbot" and "removebot".
  It also contains a console command that displays all
  of the bot path nodes on the level, which can be particularly
  helpful for developers, and for people who need to pay
  close attention to their movement.

*/

// Returns true if a given bot name is valid
BOOL B_CheckName (char *name)
{
	if (!name)
		return true;
	else
	{
		for (int i=0; i<NUMTOTALBOTS; i++)
			if (!stricmp (botinfo[i].name, name))
				return true;
		return false;
	}
}
#endif

//==========================================================================
//
//	IsDangerous
//
//	Checks if a sector is dangerous.
//
//==========================================================================

bool IsDangerous(sector_t *sec)
{
	switch (sec->special)
	{
	case 7:	// Damage_Sludge
	case 5:	// Damage_LavaWimpy
	case 16:	// Damage_LavaHefty
	case 4:	// Scroll_EastLavaDamage
		return true;
	}
	return false;
}

//==========================================================================
//
//	PTR_BotPathTraverse
//
//	[BC] For the bots
//
//==========================================================================

float bottracerange;
TVec bottracedir;

bool PTR_BotPathTraverse(intercept_t *in)
{
	Actor th;
	line_t *ld;
	BotPlayer bot;
	Actor botmo;
	TVec hit_point;

	bot = usething.Player->Bot;
	botmo = usething;

	if (in->bIsALine)
	{
		sector_t *back;
		sector_t *front;
		opening_t *open;
		float diffheight;

		ld = in->line;					// This linedef
		hit_point = botmo.Origin + (bottracerange * in->frac) * bottracedir;

		// Line is impassible
		if (!(ld->flags & ML_TWOSIDED) || (ld->flags & ML_BLOCKING))
			return false;

		// Line isn't two sided
		if (!ld->backsector)
			return false;

		if (!PointOnPlaneSide(botmo.Origin, ld))
		{
			back = ld->backsector;
			front = ld->frontsector;
		}
		else
		{
			back = ld->frontsector;
			front = ld->backsector;
		}

		// Sector is dangerous
		if (IsDangerous(back))
			return false;

		// crosses a two sided line
		open = LineOpenings(ld, hit_point);
		open = FindOpening(open, hit_point.z, hit_point.z + botmo.Height);
		// No valid openings
		if (!open)
		{
			return false;
		}

		// No cliff jumping unless we're going after something
		if ((front->floorheight - back->floorheight) > 32.0 && !bot.enemy)
		{
			return false;
		}

		diffheight = back->floorheight - front->floorheight;
		
		if (diffheight > 0.0)
		{
			if (diffheight > 48.0)
			{
/*				if (front->SSpecial == ThrustThingZ || front->springpadzone)
				{
					return true;
				}
				else*/
					return false;
			}
			else if (diffheight <= 48.0 && diffheight >= 24.0)
			{
				bot.player->Buttons |= BT_JUMP;
			}
		}

		return true;
	}

	th = Actor(in->Thing);

	if (th == botmo)
		return true;

	if (th.bSolid)
		return false;

/*	fixed_t diffheight = (th->z + th->height) - shootthing->z;

	if (diffheight > 0)
	{
		if (diffheight <= 48*FRACUNIT && diffheight >= 24*FRACUNIT)
		{
			bot->player->cmd.ucmd.buttons |= BT_JUMP;
			return true;
		}
		else if (diffheight <= 24*FRACUNIT)
			return true;
		else
			return false;
				
	}
*/
	return true;
}

#if 0
//
// B_SetAction
//
// Decide what to do in teamgame (defend, whatever)
//
void B_SetAction (skullb_s *bot)
{
	AActor *MO = bot->player->MO;
	int defenders = 0;
	int attackers = 0;

	if (bot->player->team == TM_NONE)
		return;

	if (bot->state == BST_NOTHING)
	{
		return;

		// Let's see what the other bots on our
		// team are doing, and decide our action based
		// off of that
		for (int i=0; i<MAXPLAYERS; i++)
		{
			if (GPlayers[i] && GPlayers[i]->MO->IsTeammate(MO) && GPlayers[i]->skullb)
			{
				if (GPlayers[i]->skullb->state == BST_OFFENSE)
					attackers++;
				if (GPlayers[i]->skullb->state == BST_DEFENSE)
					defenders++;
			}
		}

		// Defense wins championships...
		if (defenders <= attackers)
			bot->state = BST_DEFENSE;
		else
			bot->state = BST_OFFENSE;
	}
}

void B_SetGoal (skullb_s *bot)
{
	return;

	AActor *MO = bot->player->MO;
	AActor *actor;

	if (bot->player->team == TM_NONE)
		return;

	TThinkerIterator<AActor> iterator;

	while ((actor = iterator.Next ()) && !bot->goal)
	{
		if (bot->state == BST_OFFENSE)
		{
			if (actor->Class == teams[bot->player->team].theirs)
				bot->goal = actor;
		}
		else if (bot->state == BST_RETURN)
		{
			if (actor->Class == teams[bot->player->team].ours)
				bot->goal = actor;
		}
	}
}

//This function is called every
//tick (for each bot) to set
//the mate (teammate coop mate).
AActor *B_SetAlly (skullb_s *bot)
{
	return NULL;
	
	fixed_t closest_dist, test;
	AActor *target;
	bool p_leader[MAXPLAYERS];

	//is mate alive?
	if (bot->ally)
	{
		if (!bot->ally->health)
			bot->ally = NULL;
		else
		{
			bot->last_mate = bot->ally;
			return bot->ally;
		}
	}

	//Check old_mates status.
	if (bot->last_mate)
		if (!bot->last_mate->health)
			bot->last_mate = NULL;

	for (int i=0; i<MAXPLAYERS; i++)
	{
		if (!GPlayers[i] || !GPlayers[i]->team || i == consoleplayer)
			continue;
		if (GPlayers[i]->team == bot->player->team)
		{
			bot->ally = GPlayers[i]->MO;
			break;
		}

		p_leader[i] = false;
		for (int j=0; j<MAXPLAYERS; j++)
		{
			if (GPlayers[j]->skullb->ally == GPlayers[i]->MO)
			{
				p_leader[i] = true;
				break;
			}
		}
	}

	target = NULL;
	closest_dist = MAXINT;

	//Check for player friends
	for (i=0; i<MAXPLAYERS; i++)
	{
		if (GPlayers[i]
			&& GPlayers[i]->MO
			&& bot->player->MO != GPlayers[i]->MO
			&& (bot->player->MO->IsTeammate(GPlayers[i]->MO) || !deathmatch.value)
			&& GPlayers[i]->MO->health
			&& ((bot->player->health/2) <= GPlayers[i]->MO->health || !deathmatch.value)
			&& !p_leader[i]) //taken?
		{

			if (P_CheckSight(bot->player->MO, GPlayers[i]->MO, true))
			{
				test = P_AproxDistance(GPlayers[i]->MO->x - bot->player->MO->x,
										GPlayers[i]->MO->y - bot->player->MO->y);

				if (test < closest_dist)
				{
					closest_dist = test;
					target = GPlayers[i]->MO;
				}
			}
		}
	}

	return target;
}

// [RH] We absolutely do not want to pick things up here. The bot code is
// executed apart from all the other simulation code, so we don't want it
// creating side-effects during gameplay.
bool SafeCheckPosition (AActor *actor, fixed_t x, fixed_t y)
{
	int savedFlags = actor->flags;
	actor->flags &= ~MF_PICKUP;
	bool res = P_CheckPosition (actor, x, y) ? true : false;
	actor->flags = savedFlags;
	return res;
}
#endif

botinfo_t botinfo[NUMTOTALBOTS] =
{
	{
		"botf1",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf1\\color\\0\\class\\0\\model\\\\skin\\"
	},
	{
		"botf2",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf2\\color\\1\\class\\0\\model\\\\skin\\"
	},
	{
		"botf3",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf3\\color\\2\\class\\0\\model\\\\skin\\"
	},
	{
		"botf4",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf4\\color\\3\\class\\0\\model\\\\skin\\"
	},
	{
		"botf5",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf5\\color\\4\\class\\0\\model\\\\skin\\"
	},
	{
		"botf6",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf6\\color\\5\\class\\0\\model\\\\skin\\"
	},
	{
		"botf7",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf7\\color\\6\\class\\0\\model\\\\skin\\"
	},
	{
		"botf8",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf8\\color\\7\\class\\0\\model\\\\skin\\"
	},
	{
		"botc1",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc1\\color\\0\\class\\1\\model\\\\skin\\"
	},
	{
		"botc2",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc2\\color\\1\\class\\1\\model\\\\skin\\"
	},
	{
		"botc3",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc3\\color\\2\\class\\1\\model\\\\skin\\"
	},
	{
		"botc4",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc4\\color\\3\\class\\1\\model\\\\skin\\"
	},
	{
		"botc5",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc5\\color\\4\\class\\1\\model\\\\skin\\"
	},
	{
		"botc6",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc6\\color\\5\\class\\1\\model\\\\skin\\"
	},
	{
		"botc7",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc7\\color\\6\\class\\1\\model\\\\skin\\"
	},
	{
		"botc8",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc8\\color\\7\\class\\1\\model\\\\skin\\"
	},
	{
		"botm1",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm1\\color\\0\\class\\2\\model\\\\skin\\"
	},
	{
		"botm2",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm2\\color\\1\\class\\2\\model\\\\skin\\"
	},
	{
		"botm3",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm3\\color\\2\\class\\2\\model\\\\skin\\"
	},
	{
		"botm4",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm4\\color\\3\\class\\2\\model\\\\skin\\"
	},
	{
		"botm5",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm5\\color\\4\\class\\2\\model\\\\skin\\"
	},
	{
		"botm6",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm6\\color\\5\\class\\2\\model\\\\skin\\"
	},
	{
		"botm7",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm7\\color\\6\\class\\2\\model\\\\skin\\"
	},
	{
		"botm8",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm8\\color\\7\\class\\2\\model\\\\skin\\"
	}
};

//**************************************************************************
//
//  $Log$
//  Revision 1.11  2003/07/11 16:47:39  dj_jl
//  Made array of players with pointers
//
//  Revision 1.10  2002/11/02 08:24:10  dj_jl
//  New style classes.
//
//  Revision 1.9  2002/09/07 16:28:26  dj_jl
//  Added Level class.
//
//  Revision 1.8  2002/07/13 08:01:49  dj_jl
//  Moved some functions to the Entity class.
//
//  Revision 1.7  2002/04/11 16:49:50  dj_jl
//  Tick function.
//
//  Revision 1.6  2002/03/28 18:15:34  dj_jl
//  Renamed mo in player_t to MO.
//
//  Revision 1.5  2002/03/09 17:57:02  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.4  2002/02/26 17:49:48  dj_jl
//  no message
//
//  Revision 1.3  2002/02/22 18:00:20  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.2  2002/02/14 19:20:58  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.1  2002/02/06 17:35:13  dj_jl
//  Added Hexen bots.
//
//**************************************************************************
