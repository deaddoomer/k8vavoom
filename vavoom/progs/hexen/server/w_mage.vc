//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

#define SHARDSPAWN_LEFT		1
#define SHARDSPAWN_RIGHT	2
#define SHARDSPAWN_UP		4
#define SHARDSPAWN_DOWN		8

//**************************************************************************
//**************************************************************************
//
//	WeaponMageWand
//
//**************************************************************************
//**************************************************************************

class WeaponMageWand:Weapon
{

//============================================================================
//
//  A_MWandAttack
//
//============================================================================

void A_MWandAttack(void)
{
	Actor mo;

	mo = PlayerPawn(Player->MO).SpawnPlayerMissile(MageWandMissile);
	if (mo)
	{
		mo.bBlaster = true;
	}
	Player->MO.PlaySound('MageWandFire', CHAN_WEAPON);
}

__states__
{
	S_MWANDREADY('MWND', 0, 1.0 / 35.0, S_MWANDREADY) { A_WeaponReady(); }
	S_MWANDDOWN('MWND', 0, 1.0 / 35.0, S_MWANDDOWN) { A_Lower(); }
	S_MWANDUP('MWND', 0, 1.0 / 35.0, S_MWANDUP) { A_Raise(); }
	S_MWANDATK_1('MWND', 0, 6.0 / 35.0, S_MWANDATK_2) { }
	S_MWANDATK_2('MWND', 1 | FF_FULLBRIGHT, 6.0 / 35.0, S_MWANDATK_3) { SY = 48.0; A_MWandAttack(); }
	S_MWANDATK_3('MWND', 0, 3.0 / 35.0, S_MWANDATK_4) { SY = 40.0; }
	S_MWANDATK_4('MWND', 0, 3.0 / 35.0, S_MWANDREADY) { SY = 36.0; A_ReFire(); }
}

defaultproperties
{
	Mana = MANA_NONE;
	UpState = S_MWANDUP;
	DownState = S_MWANDDOWN;
	ReadyState = S_MWANDREADY;
	AttackState = S_MWANDATK_1;
	HoldAttackState = S_MWANDATK_1;
	PSpriteSY = 9.0;
}

}

//**************************************************************************
//**************************************************************************
//
//	WeaponMageCone
//
//**************************************************************************
//**************************************************************************

class WeaponMageCone:Weapon
{

//==========================================================================
//
//  A_FireConePL1
//
//==========================================================================

void A_FireConePL1(void)
{
	TAVec ang;
	int damage;
	int i;
	Actor pmo;
	Actor mo;
	int conedone = false;

	pmo = Player->MO;
	Player->Mana[MANA_1] -=
		WeaponManaUse(Player->PClass, Player->ReadyWeapon);
	pmo.PlaySound('MageShardsFire', CHAN_WEAPON);

	damage = 90 + (P_Random() & 15);
	for (i = 0; i < 16; i++)
	{
		ang = pmo.Angles;
		ang.yaw = AngleMod360(ang.yaw + itof(i) * (45.0 / 16.0));
		AimLineAttack(pmo, &ang, MELEERANGE);
		if (linetarget)
		{
			pmo.bIceDamage = true;
			linetarget.Damage(pmo, pmo, damage);
			pmo.bIceDamage = false;
			conedone = true;
			break;
		}
	}

	// didn't find any creatures, so fire projectiles
	if (!conedone)
	{
		mo = PlayerPawn(pmo).SpawnPlayerMissile(ShardMissile);
		if (mo)
		{
			mo._Special1 = SHARDSPAWN_LEFT | SHARDSPAWN_DOWN | SHARDSPAWN_UP
				| SHARDSPAWN_RIGHT;
			mo._Special2 = 3;	// Set sperm count (levels of reproductivity)
			mo.Instigator = pmo;
			mo.Args[0] = 3;	// Mark Initial shard as super damage
		}
	}
}

__states__
{
	S_CONEREADY('CONE', 0, 1.0 / 35.0, S_CONEREADY) { A_WeaponReady(); }
	S_CONEDOWN('CONE', 0, 1.0 / 35.0, S_CONEDOWN) { A_Lower(); }
	S_CONEUP('CONE', 0, 1.0 / 35.0, S_CONEUP) { A_Raise(); }
	S_CONEATK1_1('CONE', 1, 3.0 / 35.0, S_CONEATK1_2) { }
	S_CONEATK1_2('CONE', 2, 4.0 / 35.0, S_CONEATK1_3) { }
	S_CONEATK1_3('CONE', 3, 3.0 / 35.0, S_CONEATK1_4) { }
	S_CONEATK1_4('CONE', 4, 5.0 / 35.0, S_CONEATK1_5) { }
	S_CONEATK1_5('CONE', 5, 3.0 / 35.0, S_CONEATK1_6) { A_FireConePL1(); }
	S_CONEATK1_6('CONE', 6, 3.0 / 35.0, S_CONEATK1_7) { }
	S_CONEATK1_7('CONE', 0, 9.0 / 35.0, S_CONEATK1_8) { }
	S_CONEATK1_8('CONE', 0, 10.0 / 35.0, S_CONEREADY) { A_ReFire(); }
}

defaultproperties
{
	Mana = MANA_1;
	UpState = S_CONEUP;
	DownState = S_CONEDOWN;
	ReadyState = S_CONEREADY;
	AttackState = S_CONEATK1_1;
	HoldAttackState = S_CONEATK1_3;
	PSpriteSY = 20.0;
}

}

//**************************************************************************
//**************************************************************************
//
//	WeaponMageLightning
//
//**************************************************************************
//**************************************************************************

class WeaponMageLightning:Weapon
{

//============================================================================
//
//  A_LightningReady
//
//============================================================================

void A_LightningReady(void)
{
	A_WeaponReady();
	if (P_Random() < 160)
	{
		Player->MO.PlaySound('MageLightningReady', CHAN_WEAPON);
	}
}

//============================================================================
//
//  A_MLightningAttack
//
//============================================================================

void A_MLightningAttack(void)
{
	Actor fmo;
	Actor cmo;

	fmo = PlayerPawn(Player->MO).SpawnPlayerMissile(LightningFloor);
	cmo = PlayerPawn(Player->MO).SpawnPlayerMissile(LightningCeiling);
	if (fmo)
	{
		fmo._SpecialMobj1 = NULL;
		fmo.SpecialMobj2 = &cmo;
		fmo.A_LightningZap();
	}
	if (cmo)
	{
		cmo._SpecialMobj1 = NULL;	// mobj that it will track
		cmo.SpecialMobj2 = &fmo;
		cmo.A_LightningZap();
	}
	Player->MO.PlaySound('MageLightningFire', CHAN_WEAPON);
	Player->Mana[MANA_2] -= WeaponManaUse(Player->PClass,
		Player->ReadyWeapon);
}

__states__
{
	S_MLIGHTNINGREADY('MLNG', 0 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY2) { A_WeaponReady(); }
	S_MLIGHTNINGREADY2('MLNG', 0 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY3) { A_WeaponReady(); }
	S_MLIGHTNINGREADY3('MLNG', 0 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY4) { A_WeaponReady(); }
	S_MLIGHTNINGREADY4('MLNG', 0 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY5) { A_WeaponReady(); }
	S_MLIGHTNINGREADY5('MLNG', 0 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY6) { A_WeaponReady(); }
	S_MLIGHTNINGREADY6('MLNG', 0 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY7) { A_LightningReady(); }
	S_MLIGHTNINGREADY7('MLNG', 1 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY8) { A_WeaponReady(); }
	S_MLIGHTNINGREADY8('MLNG', 1 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY9) { A_WeaponReady(); }
	S_MLIGHTNINGREADY9('MLNG', 1 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY10) { A_WeaponReady(); }
	S_MLIGHTNINGREADY10('MLNG', 1 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY11) { A_WeaponReady(); }
	S_MLIGHTNINGREADY11('MLNG', 1 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY12) { A_WeaponReady(); }
	S_MLIGHTNINGREADY12('MLNG', 1 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY13) { A_WeaponReady(); }
	S_MLIGHTNINGREADY13('MLNG', 2 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY14) { A_WeaponReady(); }
	S_MLIGHTNINGREADY14('MLNG', 2 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY15) { A_WeaponReady(); }
	S_MLIGHTNINGREADY15('MLNG', 2 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY16) { A_WeaponReady(); }
	S_MLIGHTNINGREADY16('MLNG', 2 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY17) { A_WeaponReady(); }
	S_MLIGHTNINGREADY17('MLNG', 2 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY18) { A_WeaponReady(); }
	S_MLIGHTNINGREADY18('MLNG', 2 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY19) { A_LightningReady(); }
	S_MLIGHTNINGREADY19('MLNG', 1 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY20) { A_WeaponReady(); }
	S_MLIGHTNINGREADY20('MLNG', 1 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY21) { A_WeaponReady(); }
	S_MLIGHTNINGREADY21('MLNG', 1 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY22) { A_WeaponReady(); }
	S_MLIGHTNINGREADY22('MLNG', 1 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY23) { A_WeaponReady(); }
	S_MLIGHTNINGREADY23('MLNG', 1 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY24) { A_WeaponReady(); }
	S_MLIGHTNINGREADY24('MLNG', 1 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGREADY) { A_WeaponReady(); }
	S_MLIGHTNINGDOWN('MLNG', 0 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGDOWN) { A_Lower(); }
	S_MLIGHTNINGUP('MLNG', 0 | FF_FULLBRIGHT, 1.0 / 35.0, S_MLIGHTNINGUP) { A_Raise(); }
	S_MLIGHTNINGATK_1('MLNG', 3 | FF_FULLBRIGHT, 3.0 / 35.0, S_MLIGHTNINGATK_2) { }
	S_MLIGHTNINGATK_2('MLNG', 4 | FF_FULLBRIGHT, 3.0 / 35.0, S_MLIGHTNINGATK_3) { }
	S_MLIGHTNINGATK_3('MLNG', 5 | FF_FULLBRIGHT, 4.0 / 35.0, S_MLIGHTNINGATK_4) { A_MLightningAttack(); }
	S_MLIGHTNINGATK_4('MLNG', 6 | FF_FULLBRIGHT, 4.0 / 35.0, S_MLIGHTNINGATK_5) { }
	S_MLIGHTNINGATK_5('MLNG', 7 | FF_FULLBRIGHT, 3.0 / 35.0, S_MLIGHTNINGATK_6) { }
	S_MLIGHTNINGATK_6('MLNG', 8 | FF_FULLBRIGHT, 3.0 / 35.0, S_MLIGHTNINGATK_7) { }
	S_MLIGHTNINGATK_7('MLNG', 8 | FF_FULLBRIGHT, 6.0 / 35.0, S_MLIGHTNINGATK_8) { SY = 199.0; }
	S_MLIGHTNINGATK_8('MLNG', 2 | FF_FULLBRIGHT, 2.0 / 35.0, S_MLIGHTNINGATK_9) { SY = 55.0; }
	S_MLIGHTNINGATK_9('MLNG', 1 | FF_FULLBRIGHT, 2.0 / 35.0, S_MLIGHTNINGATK_10) { SY = 50.0; }
	S_MLIGHTNINGATK_10('MLNG', 1 | FF_FULLBRIGHT, 2.0 / 35.0, S_MLIGHTNINGATK_11) { SY = 45.0; }
	S_MLIGHTNINGATK_11('MLNG', 1 | FF_FULLBRIGHT, 2.0 / 35.0, S_MLIGHTNINGREADY) { SY = 40.0; }
}

defaultproperties
{
	Mana = MANA_2;
	UpState = S_MLIGHTNINGUP;
	DownState = S_MLIGHTNINGDOWN;
	ReadyState = S_MLIGHTNINGREADY;
	AttackState = S_MLIGHTNINGATK_1;
	HoldAttackState = S_MLIGHTNINGATK_1;
	PSpriteSY = 20.0;
}

}

//**************************************************************************
//**************************************************************************
//
//	WeaponMageStaff
//
//**************************************************************************
//**************************************************************************

class WeaponMageStaff:Weapon
{

//============================================================================
//
//	MStaffSpawn
//
//============================================================================

void MStaffSpawn(float angle)
{
	Actor mo;

	mo = PlayerPawn(Player->MO).SpawnPlayerMissileAngle(MageStaffFX2, angle);
	if (mo)
	{
		mo.Instigator = Player->MO;
		mo.Enemy = mo.RoughMonsterSearch(10);
	}
}

//============================================================================
//
//  A_MStaffAttack
//
//============================================================================

void A_MStaffAttack(void)
{
	float angle;

	Player->Mana[MANA_1] -=
		WeaponManaUse(Player->PClass, Player->ReadyWeapon);
	Player->Mana[MANA_2] -=
		WeaponManaUse(Player->PClass, Player->ReadyWeapon);
	angle = Player->MO.Angles.yaw;

	MStaffSpawn(angle);
	MStaffSpawn(angle - 5.0);
	MStaffSpawn(angle + 5.0);
	Player->MO.PlaySound('MageStaffFire', CHAN_WEAPON);
	Player->DamageCount = 0;
	Player->BonusCount = 0;
	Player->WeaponPalette = STARTSCOURGEPAL;
}

//============================================================================
//
//  A_MStaffPalette1
//
//============================================================================

void A_MStaffPalette1(void)
{
	Player->WeaponPalette = STARTSCOURGEPAL + 1;
}

//============================================================================
//
//  A_MStaffPalette2
//
//============================================================================

void A_MStaffPalette2(void)
{
	Player->WeaponPalette = STARTSCOURGEPAL + 2;
}

//============================================================================
//
//  A_MStaffPalette3
//
//============================================================================

void A_MStaffPalette3(void)
{
	// reset back to original playpal
	Player->WeaponPalette = 0;
}

__states__
{
	S_MSTAFFREADY('MSTF', 0, 1.0 / 35.0, S_MSTAFFREADY2) { A_WeaponReady(); }
	S_MSTAFFREADY2('MSTF', 0, 1.0 / 35.0, S_MSTAFFREADY3) { A_WeaponReady(); }
	S_MSTAFFREADY3('MSTF', 0, 1.0 / 35.0, S_MSTAFFREADY4) { A_WeaponReady(); }
	S_MSTAFFREADY4('MSTF', 0, 1.0 / 35.0, S_MSTAFFREADY5) { A_WeaponReady(); }
	S_MSTAFFREADY5('MSTF', 0, 1.0 / 35.0, S_MSTAFFREADY6) { A_WeaponReady(); }
	S_MSTAFFREADY6('MSTF', 0, 1.0 / 35.0, S_MSTAFFREADY7) { A_WeaponReady(); }
	S_MSTAFFREADY7('MSTF', 1, 1.0 / 35.0, S_MSTAFFREADY8) { A_WeaponReady(); }
	S_MSTAFFREADY8('MSTF', 1, 1.0 / 35.0, S_MSTAFFREADY9) { A_WeaponReady(); }
	S_MSTAFFREADY9('MSTF', 1, 1.0 / 35.0, S_MSTAFFREADY10) { A_WeaponReady(); }
	S_MSTAFFREADY10('MSTF', 1, 1.0 / 35.0, S_MSTAFFREADY11) { A_WeaponReady(); }
	S_MSTAFFREADY11('MSTF', 1, 1.0 / 35.0, S_MSTAFFREADY12) { A_WeaponReady(); }
	S_MSTAFFREADY12('MSTF', 1, 1.0 / 35.0, S_MSTAFFREADY13) { A_WeaponReady(); }
	S_MSTAFFREADY13('MSTF', 2, 1.0 / 35.0, S_MSTAFFREADY14) { A_WeaponReady(); }
	S_MSTAFFREADY14('MSTF', 2, 1.0 / 35.0, S_MSTAFFREADY15) { A_WeaponReady(); }
	S_MSTAFFREADY15('MSTF', 2, 1.0 / 35.0, S_MSTAFFREADY16) { A_WeaponReady(); }
	S_MSTAFFREADY16('MSTF', 2, 1.0 / 35.0, S_MSTAFFREADY17) { A_WeaponReady(); }
	S_MSTAFFREADY17('MSTF', 2, 1.0 / 35.0, S_MSTAFFREADY18) { A_WeaponReady(); }
	S_MSTAFFREADY18('MSTF', 2, 1.0 / 35.0, S_MSTAFFREADY19) { A_WeaponReady(); }
	S_MSTAFFREADY19('MSTF', 3, 1.0 / 35.0, S_MSTAFFREADY20) { A_WeaponReady(); }
	S_MSTAFFREADY20('MSTF', 3, 1.0 / 35.0, S_MSTAFFREADY21) { A_WeaponReady(); }
	S_MSTAFFREADY21('MSTF', 3, 1.0 / 35.0, S_MSTAFFREADY22) { A_WeaponReady(); }
	S_MSTAFFREADY22('MSTF', 3, 1.0 / 35.0, S_MSTAFFREADY23) { A_WeaponReady(); }
	S_MSTAFFREADY23('MSTF', 3, 1.0 / 35.0, S_MSTAFFREADY24) { A_WeaponReady(); }
	S_MSTAFFREADY24('MSTF', 3, 1.0 / 35.0, S_MSTAFFREADY25) { A_WeaponReady(); }
	S_MSTAFFREADY25('MSTF', 4, 1.0 / 35.0, S_MSTAFFREADY26) { A_WeaponReady(); }
	S_MSTAFFREADY26('MSTF', 4, 1.0 / 35.0, S_MSTAFFREADY27) { A_WeaponReady(); }
	S_MSTAFFREADY27('MSTF', 4, 1.0 / 35.0, S_MSTAFFREADY28) { A_WeaponReady(); }
	S_MSTAFFREADY28('MSTF', 4, 1.0 / 35.0, S_MSTAFFREADY29) { A_WeaponReady(); }
	S_MSTAFFREADY29('MSTF', 4, 1.0 / 35.0, S_MSTAFFREADY30) { A_WeaponReady(); }
	S_MSTAFFREADY30('MSTF', 4, 1.0 / 35.0, S_MSTAFFREADY31) { A_WeaponReady(); }
	S_MSTAFFREADY31('MSTF', 5, 1.0 / 35.0, S_MSTAFFREADY32) { A_WeaponReady(); }
	S_MSTAFFREADY32('MSTF', 5, 1.0 / 35.0, S_MSTAFFREADY33) { A_WeaponReady(); }
	S_MSTAFFREADY33('MSTF', 5, 1.0 / 35.0, S_MSTAFFREADY34) { A_WeaponReady(); }
	S_MSTAFFREADY34('MSTF', 5, 1.0 / 35.0, S_MSTAFFREADY35) { A_WeaponReady(); }
	S_MSTAFFREADY35('MSTF', 5, 1.0 / 35.0, S_MSTAFFREADY) { A_WeaponReady(); }
	S_MSTAFFDOWN('MSTF', 0, 1.0 / 35.0, S_MSTAFFDOWN) { A_Lower(); }
	S_MSTAFFUP('MSTF', 0, 1.0 / 35.0, S_MSTAFFUP) { A_Raise(); }
	S_MSTAFFATK_1('MSTF', 6, 4.0 / 35.0, S_MSTAFFATK_2) { SY = 40.0; }
	S_MSTAFFATK_2('MSTF', 7 | FF_FULLBRIGHT, 4.0 / 35.0, S_MSTAFFATK_3) { SY = 48.0; A_MStaffAttack(); }
	S_MSTAFFATK_3('MSTF', 7 | FF_FULLBRIGHT, 2.0 / 35.0, S_MSTAFFATK_4) { SY = 48.0; A_MStaffPalette1(); }
	S_MSTAFFATK_4('MSTF', 8, 2.0 / 35.0, S_MSTAFFATK_5) { SY = 48.0; A_MStaffPalette2(); }
	S_MSTAFFATK_5('MSTF', 8, 2.0 / 35.0, S_MSTAFFATK_6) { SY = 48.0; A_MStaffPalette3(); }
	S_MSTAFFATK_6('MSTF', 8, 1.0 / 35.0, S_MSTAFFATK_7) { SY = 40.0; }
	S_MSTAFFATK_7('MSTF', 9, 5.0 / 35.0, S_MSTAFFREADY) { SY = 36.0; }
}

defaultproperties
{
	Mana = MANA_BOTH;
	UpState = S_MSTAFFUP;
	DownState = S_MSTAFFDOWN;
	ReadyState = S_MSTAFFREADY;
	AttackState = S_MSTAFFATK_1;
	HoldAttackState = S_MSTAFFATK_1;
	PSpriteSY = 20.0;
}

}

//**************************************************************************
//**************************************************************************

//============================================================================
//
//  Actor::A_ShedShard
//
//============================================================================

void Actor::A_ShedShard(void)
{
	Actor mo;
	int spawndir = _Special1;
	int spermcount = _Special2;

	if (spermcount <= 0)
		return;	// No sperm left
	_Special2 = 0;
	spermcount--;

	// every so many calls, spawn a new missile in it's set directions
	if (spawndir & SHARDSPAWN_LEFT)
	{
		mo = SpawnMissileAngleSpeed(ShardMissile,
			Angles.yaw + (45.0 / 9.0), 0.0, itof(20 + 2 * spermcount) * 35.0);
		if (mo)
		{
			mo._Special1 = SHARDSPAWN_LEFT;
			mo._Special2 = spermcount;
			mo.Velocity.z = Velocity.z;
			mo.Instigator = Instigator;
			mo.Args[0] = (spermcount == 3) ? 2 : 0;
		}
	}
	if (spawndir & SHARDSPAWN_RIGHT)
	{
		mo = SpawnMissileAngleSpeed(ShardMissile,
			Angles.yaw - (45.0 / 9.0), 0.0, itof(20 + 2 * spermcount) * 35.0);
		if (mo)
		{
			mo._Special1 = SHARDSPAWN_RIGHT;
			mo._Special2 = spermcount;
			mo.Velocity.z = Velocity.z;
			mo.Instigator = Instigator;
			mo.Args[0] = (spermcount == 3) ? 2 : 0;
		}
	}
	if (spawndir & SHARDSPAWN_UP)
	{
		mo = SpawnMissileAngleSpeed(ShardMissile, Angles.yaw,
			0.0, itof(15 + 2 * spermcount) * 35.0);
		if (mo)
		{
			mo.Velocity.z = Velocity.z;
			mo.Origin.z += 8.0;
			if (spermcount & 1)	// Every other reproduction
				mo._Special1 =
					SHARDSPAWN_UP | SHARDSPAWN_LEFT | SHARDSPAWN_RIGHT;
			else
				mo._Special1 = SHARDSPAWN_UP;
			mo._Special2 = spermcount;
			mo.Instigator = Instigator;
			mo.Args[0] = (spermcount == 3) ? 2 : 0;
		}
	}
	if (spawndir & SHARDSPAWN_DOWN)
	{
		mo = SpawnMissileAngleSpeed(ShardMissile, Angles.yaw,
			0.0, itof(15 + 2 * spermcount) * 35.0);
		if (mo)
		{
			mo.Velocity.z = Velocity.z;
			mo.Origin.z -= 4.0;
			if (spermcount & 1)	// Every other reproduction
				mo._Special1 =
					SHARDSPAWN_DOWN | SHARDSPAWN_LEFT | SHARDSPAWN_RIGHT;
			else
				mo._Special1 = SHARDSPAWN_DOWN;
			mo._Special2 = spermcount;
			mo.Instigator = Instigator;
			mo.Args[0] = (spermcount == 3) ? 2 : 0;
		}
	}
}

//============================================================================
//
//  Actor::A_LightningClip
//
//============================================================================

#define ZAGSPEED		1.0

void Actor::A_LightningClip(void)
{
	Actor cMo;
	Actor targ;
	int zigZag;

	if (Class == LightningFloor)
	{
		Origin.z = FloorZ;
		targ = *SpecialMobj2->_SpecialMobj1;
	}
	else if (Class == LightningCeiling)
	{
		Origin.z = CeilingZ - Height;
		targ = *_SpecialMobj1;
	}
	if (Class == LightningFloor)
	{
		// floor lightning zig-zags, and forces the ceiling lightning to mimic
		cMo = *SpecialMobj2;
		zigZag = P_Random();
		if ((zigZag > 128 && _Special1 < 2) || _Special1 < -2)
		{
			Thrust(Angles.yaw + 90.0, ZAGSPEED);
			if (cMo)
			{
				cMo.Thrust(Angles.yaw + 90.0, ZAGSPEED);
			}
			_Special1++;
		}
		else
		{
			Thrust(Angles.yaw - 90.0, ZAGSPEED);
			if (cMo)
			{
				cMo.Thrust(cMo.Angles.yaw - 90.0, ZAGSPEED);
			}
			_Special1--;
		}
	}
	if (targ)
	{
		if (targ.Health <= 0)
		{
			ExplodeMissile();
		}
		else
		{
			Angles.yaw = atan2(targ.Origin.y - Origin.y,
				targ.Origin.x - Origin.x);
			Velocity.x = 0.0;
			Velocity.y = 0.0;
			Thrust(Angles.yaw, Speed * frametime / 2.0);
		}
	}
}

//============================================================================
//
//  Actor::A_LightningZap
//
//============================================================================

void Actor::A_LightningZap(void)
{
	Actor A;
	float deltaZ;

	A_LightningClip();

	Health -= 8;
	if (Health <= 0)
	{
		SetState(DeathState);
		return;
	}
	if (Class == LightningFloor)
	{
		deltaZ = 10.0;
	}
	else
	{
		deltaZ = -10.0;
	}
	A = Spawn(LightningZap, Origin + vector((Random() - 0.5) * Radius,
		(Random() - 0.5) * Radius, deltaZ));
	if (A)
	{
		A.SpecialMobj2 = this;
		A.Velocity.x = Velocity.x;
		A.Velocity.y = Velocity.y;
		A.Instigator = Instigator;
		if (Class == LightningFloor)
		{
			A.Velocity.z = 20.0 * 35.0;
		}
		else
		{
			A.Velocity.z = -20.0 * 35.0;
		}
	}
	if (Class == LightningFloor && P_Random() < 160)
	{
		PlaySound('MageLightningContinuous', CHAN_VOICE);
	}
}

//============================================================================
//
//  Actor::A_ZapMimic
//
//============================================================================

void Actor::A_ZapMimic(void)
{
	Actor A;

	A = *SpecialMobj2;
	if (A)
	{
		if (A.StateNum >= A.DeathState || A.StateNum == S_FREETARGMOBJ)
		{
			ExplodeMissile();
		}
		else
		{
			Velocity.x = A.Velocity.x;
			Velocity.y = A.Velocity.y;
		}
	}
}

//============================================================================
//
//  Actor::A_LastZap
//
//============================================================================

void Actor::A_LastZap(void)
{
	Actor A;

	A = Spawn(LightningZap, Origin);
	if (A)
	{
		A.SetState(S_LIGHTNING_ZAP_X1);
		A.Velocity.z = 40.0 * 35.0;
	}
}

//============================================================================
//
//  Actor::A_LightningRemove
//
//============================================================================

void Actor::A_LightningRemove(void)
{
	if (SpecialMobj2)
	{
		SpecialMobj2->SpecialMobj2 = NULL;
		SpecialMobj2->ExplodeMissile();
	}
}

//============================================================================
//
//  Actor::A_MStaffWeave
//
//============================================================================

void Actor::A_MStaffWeave(void)
{
	float newX, newY;
	int weaveXY, weaveZ;
	float angle;

	weaveXY = _Special2 >> 16;
	weaveZ = _Special2 & 0xFFFF;
	angle = AngleMod360(Angles.yaw + 90.0);
	newX = Origin.x - cos(angle) * FloatBobOffsets[weaveXY] * 4.0;
	newY = Origin.y - sin(angle) * FloatBobOffsets[weaveXY] * 4.0;
	weaveXY = (weaveXY + 6) & 63;
	newX += cos(angle) * FloatBobOffsets[weaveXY] * 4.0;
	newY += sin(angle) * FloatBobOffsets[weaveXY] * 4.0;
	TryMove(vector(newX, newY, Origin.z));
	Origin.z -= FloatBobOffsets[weaveZ] * 2.0;
	weaveZ = (weaveZ + 3) & 63;
	Origin.z += FloatBobOffsets[weaveZ] * 2.0;
	if (Origin.z <= FloorZ)
	{
		Origin.z = FloorZ + 1.0;
	}
	_Special2 = weaveZ + (weaveXY << 16);
}

//============================================================================
//
//  Actor::A_MStaffTrack
//
//============================================================================

void Actor::A_MStaffTrack(void)
{
	if (!Enemy && (P_Random() < 50))
	{
		Enemy = RoughMonsterSearch(10);
	}
	SeekerMissile(2.0, 10.0);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.26  2002/04/11 16:52:16  dj_jl
//  Made TryMove native.
//
//  Revision 1.25  2002/03/28 18:15:35  dj_jl
//  Renamed mo in player_t to MO.
//
//  Revision 1.24  2002/03/16 17:47:47  dj_jl
//  Got rid of mobj_t and some other legacy.
//
//  Revision 1.23  2002/03/09 17:57:02  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.22  2002/03/02 17:35:55  dj_jl
//  Weapon classes
//
//  Revision 1.21  2002/02/26 17:49:49  dj_jl
//  no message
//
//  Revision 1.20  2002/02/22 18:00:25  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.19  2002/02/14 19:20:59  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.18  2002/02/06 17:28:53  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.17  2002/01/28 18:50:19  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.16  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.15  2002/01/24 18:19:27  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.14  2002/01/17 18:15:55  dj_jl
//  Renamed all map object classes
//
//  Revision 1.13  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.12  2002/01/12 18:02:48  dj_jl
//  Replaced some C style casts with dynamic casts
//
//  Revision 1.11  2002/01/11 18:19:42  dj_jl
//  Started to use names in progs
//
//  Revision 1.10  2002/01/07 12:25:58  dj_jl
//  Changed copyright year
//
//  Revision 1.9  2001/12/27 17:52:24  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.8  2001/12/12 18:57:42  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.7  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.6  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.5  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/30 17:33:18  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:53  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
