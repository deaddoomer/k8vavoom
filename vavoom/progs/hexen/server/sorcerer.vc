//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

//============================================================================
//
//  Sorcerer stuff
//
// Sorcerer Variables
//      special1f       Angle of ball 1 (all others relative to that)
//      special2        which ball to stop at in stop mode (MT_???)
//      args[0]         Denfense time
//      args[1]         Number of full rotations since stopping mode
//      args[2]         Target orbit speed for acceleration/deceleration
//      args[3]         Movement mode (see SORC_ macros)
//      args[4]         Current ball orbit speed
//  Sorcerer Ball Variables
//      special1f       Previous angle of ball (for woosh)
//      special2        Countdown of rapid fire (FX4)
//      args[0]         If set, don't play the bounce sound when bouncing
//============================================================================

// MACROS ------------------------------------------------------------------

#define SORCBALL_INITIAL_SPEED 		7
#define SORCBALL_TERMINAL_SPEED		25
#define SORCBALL_SPEED_ROTATIONS 	5
#define SORCFX4_RAPIDFIRE_TIME		(6*3)	// 3 seconds
#define SORCFX4_SPREAD_ANGLE		20.0
#define SORC_DEFENSE_TIME			255
#define SORC_DEFENSE_HEIGHT			45.0
#define BOUNCE_TIME_UNIT			(35/2)

#define SORC_DECELERATE		0
#define SORC_ACCELERATE 	1
#define SORC_STOPPING		2
#define SORC_FIRESPELL		3
#define SORC_STOPPED		4
#define SORC_NORMAL			5
#define SORC_FIRING_SPELL	6

#define BALL1_ANGLEOFFSET	0.0
#define BALL2_ANGLEOFFSET	120.0
#define BALL3_ANGLEOFFSET	240.0

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//============================================================================
//
//	Set balls to speed mode - actor is sorcerer
//
//============================================================================

void Actor::A_SpeedBalls(void)
{
	args[3] = SORC_ACCELERATE;	// speed mode
	args[2] = SORCBALL_TERMINAL_SPEED;	// target speed
}

//============================================================================
//
// Set balls to slow mode - actor is sorcerer
//
//============================================================================

void A_SlowBalls(mobj_t * actor)
{
	actor->args[3] = SORC_DECELERATE;	// slow mode
	actor->args[2] = SORCBALL_INITIAL_SPEED;	// target speed
}

//============================================================================
//
//  Actor::A_SorcSpinBalls
//
//  Spawn spinning balls above head - actor is sorcerer.
//
//============================================================================

void Actor::A_SorcSpinBalls(void)
{
	mobj_t *mo;
	float z;

	A_SlowBalls(this);
	args[0] = 0;	// Currently no defense
	args[3] = SORC_NORMAL;
	args[4] = SORCBALL_INITIAL_SPEED;	// Initial orbit speed
	special1f = 1.0;
	z = origin.z - floorclip + height;

	mo = P_SpawnMobj(origin.x, origin.y, z, MT_SORCBALL1);
	if (mo)
	{
		mo->target = this;
		mo->special2 = SORCFX4_RAPIDFIRE_TIME;
	}
	mo = P_SpawnMobj(origin.x, origin.y, z, MT_SORCBALL2);
	if (mo)
		mo->target = this;
	mo = P_SpawnMobj(origin.x, origin.y, z, MT_SORCBALL3);
	if (mo)
		mo->target = this;
}

//============================================================================
//
//  A_StopBalls
//
//  Instant stop when rotation gets to ball in special2
// actor is sorcerer
//
//============================================================================

void A_StopBalls(mobj_t * actor)
{
	int chance = P_Random();

	actor->args[3] = SORC_STOPPING;	// stopping mode
	actor->args[1] = 0;	// Reset rotation counter

	if ((actor->args[0] <= 0) && (chance < 200))
	{
		actor->specialcid = MT_SORCBALL2;	// Blue
	}
	else if ((actor->health < (actor->spawnhealth >> 1)) && (chance < 200))
	{
		actor->specialcid = MT_SORCBALL3;	// Green
	}
	else
	{
		actor->specialcid = MT_SORCBALL1;	// Yellow
	}

}

//============================================================================
//
//  A_AccelBalls
//
//  Increase ball orbit speed - actor is ball
//
//============================================================================

void A_AccelBalls(mobj_t * actor)
{
	mobj_t *sorc = actor->target;

	if (sorc->args[4] < sorc->args[2])
	{
		sorc->args[4]++;
	}
	else
	{
		sorc->args[3] = SORC_NORMAL;
		if (sorc->args[4] >= SORCBALL_TERMINAL_SPEED)
		{
			// Reached terminal velocity - stop balls
			A_StopBalls(sorc);
		}
	}
}

//============================================================================
//
//  A_DecelBalls
//
//  Decrease ball orbit speed - actor is ball
//
//============================================================================

void A_DecelBalls(mobj_t * actor)
{
	mobj_t *sorc = actor->target;

	if (sorc->args[4] > sorc->args[2])
	{
		sorc->args[4]--;
	}
	else
	{
		sorc->args[3] = SORC_NORMAL;
	}
}

//============================================================================
//
//  A_SorcUpdateBallAngle
//
//  Update angle if first ball - actor is ball
//
//============================================================================

void A_SorcUpdateBallAngle(mobj_t * actor)
{
	if (actor->Class == MT_SORCBALL1)
	{
		actor->target->special1f = AngleMod360(actor->target->special1f +
			itof(actor->target->args[4]));
	}
}

//============================================================================
//
//  A_SorcOffense1
//
//  Actor is ball.
//
//============================================================================

void A_SorcOffense1(mobj_t * actor)
{
	mobj_t *mo;
	float ang1, ang2;
	mobj_t *parent = actor->target;

	ang1 = AngleMod360(actor->angles.yaw + 70.0);
	ang2 = AngleMod360(actor->angles.yaw - 70.0);
	mo = SpawnMissileAngle(parent, MT_SORCFX1, ang1, 0.0);
	if (mo)
	{
		mo->target = parent;
		mo->specialmobj1 = parent->target;
		mo->args[4] = BOUNCE_TIME_UNIT;
		mo->args[3] = 15;	// Bounce time in seconds
	}
	mo = SpawnMissileAngle(parent, MT_SORCFX1, ang2, 0.0);
	if (mo)
	{
		mo->target = parent;
		mo->specialmobj1 = parent->target;
		mo->args[4] = BOUNCE_TIME_UNIT;
		mo->args[3] = 15;	// Bounce time in seconds
	}
}

//============================================================================
//
//  A_SorcOffense2
//
//  Actor is ball
//
//============================================================================

void A_SorcOffense2(mobj_t * actor)
{
	float ang1;
	mobj_t *mo;
	float delta, index;
	mobj_t *parent = actor->target;
	mobj_t *dest = parent->target;
	float dist;

	index = itof(actor->args[4]) * 360.0 / 256.0;
	actor->args[4] = (actor->args[4] + 15) & 0xff;
	delta = sin(index) * SORCFX4_SPREAD_ANGLE;
	ang1 = AngleMod360(actor->angles.yaw + delta);
	mo = SpawnMissileAngle(parent, MT_SORCFX4, ang1, 0.0);
	if (mo)
	{
		mo->special2 = 35 * 5 / 2;	// 5 seconds
		dist = MobjDist2(dest, mo);
		dist = dist / mo->speed;
		if (dist < 1.0)
			dist = 1.0;
		mo->velocity.z = (dest->origin.z - mo->origin.z) / dist;
	}
}

//============================================================================
//
//  A_CastSorcererSpell
//
//  Actor is ball.
//
//============================================================================

void A_CastSorcererSpell(mobj_t * actor)
{
	mobj_t *mo;
	classid spell = actor->Class;
	float ang1, ang2;
	float z;
	mobj_t *parent = actor->target;

	StartSoundName(NULL, "SorcererSpellCast", CHAN_VOICE);

	// Put sorcerer into throw spell animation
	if (parent->health > 0)
		SetMobjStateNF(parent, S_SORC_ATTACK4);

	switch (spell)
	{
	case MT_SORCBALL1:	// Offensive
		A_SorcOffense1(actor);
		break;
	case MT_SORCBALL2:	// Defensive
		z = parent->origin.z - parent->floorclip + SORC_DEFENSE_HEIGHT;
		mo = P_SpawnMobj(actor->origin.x, actor->origin.y, z, MT_SORCFX2);
		parent->flags2 |= MF2_REFLECTIVE | MF2_INVULNERABLE;
		parent->args[0] = SORC_DEFENSE_TIME;
		if (mo)
			mo->target = parent;
		break;
	case MT_SORCBALL3:	// Reinforcements
		ang1 = AngleMod360(actor->angles.yaw - 45.0);
		ang2 = AngleMod360(actor->angles.yaw + 45.0);
		if (actor->health < (actor->spawnhealth / 3))
		{	// Spawn 2 at a time
			mo = SpawnMissileAngle(parent, MT_SORCFX3, ang1, 4.0);
			if (mo)
				mo->target = parent;
			mo = SpawnMissileAngle(parent, MT_SORCFX3, ang2, 4.0);
			if (mo)
				mo->target = parent;
		}
		else
		{
			if (P_Random() < 128)
				ang1 = ang2;
			mo = SpawnMissileAngle(parent, MT_SORCFX3, ang1, 4.0);
			if (mo)
				mo->target = parent;
		}
		break;
	default:
		break;
	}
}

//============================================================================
//
//  Actor::A_SorcBallOrbit
//
//============================================================================

void Actor::A_SorcBallOrbit(void)
{
	float x, y;
	float angle, baseangle;
	int mode = target->args[3];
	mobj_t *parent = target;
	float dist = parent->radius - (radius * 2.0);
	float prevangle = special1f;

	if (target->health <= 0)
		SetMobjState(this, painstate);

	baseangle = parent->special1f;
	switch (Class)
	{
	case MT_SORCBALL1:
		angle = AngleMod360(baseangle + BALL1_ANGLEOFFSET);
		break;
	case MT_SORCBALL2:
		angle = AngleMod360(baseangle + BALL2_ANGLEOFFSET);
		break;
	case MT_SORCBALL3:
		angle = AngleMod360(baseangle + BALL3_ANGLEOFFSET);
		break;
	default:
//		I_Error("corrupted sorcerer");
		break;
	}
	angles.yaw = angle;

	switch (mode)
	{
	case SORC_NORMAL:	// Balls rotating normally
		A_SorcUpdateBallAngle(this);
		break;
	case SORC_DECELERATE:	// Balls decelerating
		A_DecelBalls(this);
		A_SorcUpdateBallAngle(this);
		break;
	case SORC_ACCELERATE:	// Balls accelerating
		A_AccelBalls(this);
		A_SorcUpdateBallAngle(this);
		break;
	case SORC_STOPPING:	// Balls stopping
		if ((parent->specialcid == Class) &&
			(parent->args[1] > SORCBALL_SPEED_ROTATIONS) &&
			(fabs(AngleMod180(angle - parent->angles.yaw)) <
			15.0 * 45.0 / 16.0))
		{
			// Can stop now
			target->args[3] = SORC_FIRESPELL;
			target->args[4] = 0;
			// Set angle so ball angle == sorcerer angle
			switch (Class)
			{
			case MT_SORCBALL1:
				parent->special1f = AngleMod360(parent->angles.yaw -
					BALL1_ANGLEOFFSET);
				break;
			case MT_SORCBALL2:
				parent->special1f = AngleMod360(parent->angles.yaw -
					BALL2_ANGLEOFFSET);
				break;
			case MT_SORCBALL3:
				parent->special1f = AngleMod360(parent->angles.yaw -
					BALL3_ANGLEOFFSET);
				break;
			default:
				break;
			}
		}
		else
		{
			A_SorcUpdateBallAngle(this);
		}
		break;
	case SORC_FIRESPELL:	// Casting spell
		if (parent->specialcid == Class)
		{
			// Put sorcerer into special throw spell anim
			if (parent->health > 0)
				SetMobjStateNF(parent, S_SORC_ATTACK1);

			if (Class == MT_SORCBALL1 && P_Random() < 200)
			{
				StartSoundName(NULL, "SorcererSpellCast", CHAN_VOICE);
				special2 = SORCFX4_RAPIDFIRE_TIME;
				args[4] = 128;
				parent->args[3] = SORC_FIRING_SPELL;
			}
			else
			{
				A_CastSorcererSpell(this);
				parent->args[3] = SORC_STOPPED;
			}
		}
		break;
	case SORC_FIRING_SPELL:
		if (parent->specialcid == Class)
		{
			if (special2-- <= 0)
			{
				// Done rapid firing 
				parent->args[3] = SORC_STOPPED;
				// Back to orbit balls
				if (parent->health > 0)
					SetMobjStateNF(parent, S_SORC_ATTACK4);
			}
			else
			{
				// Do rapid fire spell
				A_SorcOffense2(this);
			}
		}
		break;
	case SORC_STOPPED:	// Balls stopped
	default:
		break;
	}

	if ((angle < prevangle) && (parent->args[4] == SORCBALL_TERMINAL_SPEED))
	{
		parent->args[1]++;	// Bump rotation counter
		// Completed full rotation - make woosh sound
		StartSoundName(this, "SorcererBallWoosh", CHAN_VOICE);
	}
	special1f = angle;	// Set previous angle
	x = parent->origin.x + dist * cos(angle);
	y = parent->origin.y + dist * sin(angle);
	origin.x = x;
	origin.y = y;
	origin.z = parent->origin.z - parent->floorclip + parent->height;
}

//============================================================================
//
//  Actor::A_SorcBossAttack
//
//  Resume ball spinning
//
//============================================================================

void Actor::A_SorcBossAttack(void)
{
	args[3] = SORC_ACCELERATE;
	args[2] = SORCBALL_INITIAL_SPEED;
}

//============================================================================
//
//  Actor::A_SpawnFizzle
//
//  Spell cast magic fizzle
//
//============================================================================

void Actor::A_SpawnFizzle(void)
{
	float x, y, z;
	float dist = 5.0;
	float angle = angles.yaw;
	float rangle;
	mobj_t *mo;
	int ix;

	x = origin.x + dist * cos(angle);
	y = origin.y + dist * sin(angle);
	z = origin.z - floorclip + height / 2.0;
	for (ix = 0; ix < 5; ix++)
	{
		mo = P_SpawnMobj(x, y, z, MT_SORCSPARK1);
		if (mo)
		{
			rangle = angle + Random() * 5.0 * 90.0 / 1024.0;
			mo->velocity.x = Random() * speed * cos(rangle);
			mo->velocity.y = Random() * speed * sin(rangle);
			mo->velocity.z = 2.0 * 35.0;
		}
	}
}

//============================================================================
//
//  Actor::A_SorcBallPop
//
//  Ball death - spawn stuff.
//
//============================================================================

void Actor::A_SorcBallPop(void)
{
	StartSoundName(NULL, "SorcererBallPop", CHAN_VOICE);
	flags &= ~MF_NOGRAVITY;
	flags2 |= MF2_LOGRAV;
	velocity.x = (Random() * 10.0 - 5.0) * 35.0;
	velocity.y = (Random() * 10.0 - 5.0) * 35.0;
	velocity.z = (2.0 + Random() * 3.0) * 35.0;
	//Not used
//	special2 = 4 * FRACUNIT;     // Initial bounce factor
	args[4] = BOUNCE_TIME_UNIT;	// Bounce time unit
	args[3] = 5;	// Bounce time in seconds
}

//============================================================================
//
//  Actor::A_BounceCheck
//
//============================================================================

void Actor::A_BounceCheck(void)
{
	if (args[4]-- <= 0)
	{
		if (args[3]-- <= 0)
		{
			SetMobjState(this, deathstate);
			switch (Class)
			{
			case MT_SORCBALL1:
			case MT_SORCBALL2:
			case MT_SORCBALL3:
				StartSoundName(NULL, "SorcererBigBallExplode", CHAN_VOICE);
				break;
			case MT_SORCFX1:
				StartSoundName(NULL, "SorcererHeadScream", CHAN_VOICE);
				break;
			default:
				break;
			}
		}
		else
		{
			args[4] = BOUNCE_TIME_UNIT;
		}
	}
}

//============================================================================
//
//  Actor::A_SorcFX1Seek
//
//  Yellow spell - offense
//
//============================================================================

void Actor::A_SorcFX1Seek(void)
{
	A_BounceCheck();
	SeekerMissile(this, 2.0, 6.0);
}

//============================================================================
// Blue spell - defense
//============================================================================
//
// FX2 Variables
//      special1f       current angle
//      special2
//      args[0]     0 = CW,  1 = CCW
//      args[1]     
//============================================================================

//============================================================================
//
//  Actor::A_SorcFX2Split
//
//  Split ball in two
//
//============================================================================

void Actor::A_SorcFX2Split(void)
{
	mobj_t *mo;

	mo = P_SpawnMobj(origin.x, origin.y, origin.z, MT_SORCFX2);
	if (mo)
	{
		mo->target = target;
		mo->args[0] = 0;	// CW
		mo->special1f = angles.yaw;	// Set angle
		SetMobjStateNF(mo, S_SORCFX2_ORBIT1);
	}
	mo = P_SpawnMobj(origin.x, origin.y, origin.z, MT_SORCFX2);
	if (mo)
	{
		mo->target = target;
		mo->args[0] = 1;	// CCW
		mo->special1f = angles.yaw;	// Set angle
		SetMobjStateNF(mo, S_SORCFX2_ORBIT1);
	}
	SetMobjState(this, S_NULL);
}

//============================================================================
//
//  Actor::A_SorcFX2Orbit
//
//  Orbit FX2 about sorcerer
//
//============================================================================

void Actor::A_SorcFX2Orbit(void)
{
	float angle;
	float x, y, z;
	mobj_t *parent = target;
	float dist = parent->radius;

	if ((parent->health <= 0) ||	// Sorcerer is dead
		(!parent->args[0]))	// Time expired
	{
		SetMobjStateNF(this, deathstate);
		parent->args[0] = 0;
		parent->flags2 &= ~MF2_REFLECTIVE;
		parent->flags2 &= ~MF2_INVULNERABLE;
	}

	if (args[0] && (parent->args[0]-- <= 0))	// Time expired
	{
		SetMobjStateNF(this, deathstate);
		parent->args[0] = 0;
		parent->flags2 &= ~MF2_REFLECTIVE;
	}

	// Move to new position based on angle
	if (args[0])	// Counter clock-wise
	{
		special1f = AngleMod360(special1f + 10.0);
		angle = special1f;
		x = parent->origin.x + dist * cos(angle);
		y = parent->origin.y + dist * sin(angle);
		z = parent->origin.z - parent->floorclip + SORC_DEFENSE_HEIGHT;
		z += 15.0 * cos(angle);
		// Spawn trailer
		P_SpawnMobj(x, y, z, MT_SORCFX2_T1);
	}
	else	// Clock wise
	{
		special1f = AngleMod360(special1f - 10.0);
		angle = special1f;
		x = parent->origin.x + dist * cos(angle);
		y = parent->origin.y + dist * sin(angle);
		z = parent->origin.z - parent->floorclip + SORC_DEFENSE_HEIGHT;
		z += 20.0 * sin(angle);
		// Spawn trailer
		P_SpawnMobj(x, y, z, MT_SORCFX2_T1);
	}

	origin.x = x;
	origin.y = y;
	origin.z = z;
}

//============================================================================
//
//  Actor::A_SpawnBishop
//
//  Green spell - spawn bishops
//
//============================================================================

void Actor::A_SpawnBishop(void)
{
	mobj_t *mo;

	mo = P_SpawnMobj(origin.x, origin.y, origin.z, MT_BISHOP);
	if (mo)
	{
		if (!P_TestMobjLocation(mo))
		{
			SetMobjState(mo, S_NULL);
		}
	}
	SetMobjState(this, S_NULL);
}

//============================================================================
//
//  Actor::A_SorcererBishopEntry
//
//============================================================================

void Actor::A_SorcererBishopEntry(void)
{
	P_SpawnMobj(origin.x, origin.y, origin.z, MT_SORCFX3_EXPLOSION);
	StartSound(this, sound_sight, CHAN_VOICE);
}

//============================================================================
//
//  Actor::A_SorcFX4Check
//
//  FX4 - rapid fire balls
//
//============================================================================

void Actor::A_SorcFX4Check(void)
{
	if (special2-- <= 0)
	{
		SetMobjStateNF(this, deathstate);
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.8  2001/12/27 17:52:24  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.7  2001/12/12 18:57:42  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.6  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.5  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/30 17:33:17  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
