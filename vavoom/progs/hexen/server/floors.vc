//**************************************************************************
//**
//**	##   ##    ##    ##   ##   ####     ####   ###     ###
//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**	   #    ##    ##    #      ####     ####   ##       ##
//**
//**	$Id$
//**
//**	Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**	This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**	This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// TYPES -------------------------------------------------------------------

enum
{
	FLEV_LOWERFLOOR,             // lower floor to highest surrounding floor
	FLEV_LOWERFLOORTOLOWEST,     // lower floor to lowest surrounding floor
	FLEV_LOWERFLOORBYVALUE,
	FLEV_RAISEFLOOR,             // raise floor to lowest surrounding CEILING
	FLEV_RAISEFLOORTONEAREST,  // raise floor to next highest surrounding floor
	FLEV_RAISEFLOORBYVALUE,
	FLEV_RAISEFLOORCRUSH,
	FLEV_RAISEBUILDSTEP,        // One step of a staircase
	FLEV_RAISEBYVALUETIMES8,
	FLEV_LOWERBYVALUETIMES8,
	FLEV_LOWERTIMES8INSTANT,
	FLEV_RAISETIMES8INSTANT,
	FLEV_MOVETOVALUETIMES8
};

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

special_t	activefloors;

// CODE --------------------------------------------------------------------

//==================================================================
//
//  AddActiveFloor
//
//	Add an active ceiling
//
//==================================================================

void AddActiveFloor(special_t *floor)
{
	floor->prev = activefloors.prev;
    floor->next = &activefloors;
	floor->prev->next = floor;
    floor->next->prev = floor;
}

//==================================================================
//
//  RemoveActiveFloor
//
//	Remove a ceiling's thinker
//
//==================================================================

void RemoveActiveFloor(special_t *floor)
{
	floor->prev->next = floor->next;
    floor->next->prev = floor->prev;
	floor->sector->specialdata = NULL;
	TagFinished(floor->sector->tag);
	RemoveSpecialThinker(floor);
}

//==========================================================================
//
//  T_MoveFloor
//
//	MOVE A FLOOR TO IT'S DESTINATION (UP OR DOWN)
//
//==========================================================================

void T_MoveFloor(special_t *floor)
{
	int			res;

	if (floor->resetDelayCount)
	{
		floor->resetDelayCount--;
		if (!floor->resetDelayCount)
		{
			floor->floordestheight = floor->resetHeight;
			floor->direction = -floor->direction;
			floor->resetDelay = 0;
			floor->delayCount = 0;
			floor->delayTotal = 0;
		}
	}					
	if (floor->delayCount)
	{
		floor->delayCount--;
		if (!floor->delayCount && floor->textureChange)
		{
			SetFloorPic(floor->sector, floor->sector->floor.pic + floor->textureChange);
		}
		return;
	}

	res = T_MovePlane(floor->sector, floor->speed,
			floor->floordestheight, floor->crush, 0, floor->direction);

	if (floor->type == FLEV_RAISEBUILDSTEP)
	{
		if ((floor->direction == 1 && floor->sector->floorheight >=
			floor->stairsDelayHeight) || (floor->direction == -1 &&
			floor->sector->floorheight <= floor->stairsDelayHeight))
		{
			floor->delayCount = floor->delayTotal;
			floor->stairsDelayHeight += floor->stairsDelayHeightDelta;
		}		
	}
	if (res == RES_PASTDEST)
	{
		SectorStopSequence(floor->sector);
		if (floor->delayTotal)
		{
			floor->delayTotal = 0;
		}
		if (floor->resetDelay)
		{
//			floor->resetDelayCount = floor->resetDelay;
//			floor->resetDelay = 0;
			return;
		}			
		floor->sector->specialdata = NULL;
		if (floor->textureChange)
		{
			SetFloorPic(floor->sector, floor->sector->floor.pic - floor->textureChange);
		}
		RemoveActiveFloor(floor);
	}
}

//==========================================================================
//
//  EV_DoFloor
//
//	HANDLE FLOOR TYPES
//
//==========================================================================

int EV_DoFloor(line_t *line, int *args, int floortype)
{
	int			secnum;
	int			rtn;
	sector_t	*sec;
	special_t	*floor = NULL;

	secnum = -1;
	rtn = 0;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &level->sectors[secnum];

		//      ALREADY MOVING?  IF SO, KEEP GOING...
		if (sec->specialdata)
			continue;

		//
		//      new floor thinker
		//
		rtn = 1;
		floor = NewSpecialThinker(special_t);
		floor->function = T_MoveFloor;
		sec->specialdata = floor;
        AddActiveFloor(floor);
		floor->sector = sec;
		floor->type = floortype;
		floor->crush = 0;
		floor->speed = itof(args[1]) / 8.0;
		if (floortype == FLEV_LOWERTIMES8INSTANT ||
			floortype == FLEV_RAISETIMES8INSTANT)
		{
			floor->speed = 2000.0;
		}
		switch (floortype)
		{
			case FLEV_LOWERFLOOR:
				floor->direction = -1;
				floor->floordestheight = FindHighestFloorSurrounding(sec);
				break;
			case FLEV_LOWERFLOORTOLOWEST:
				floor->direction = -1;
				floor->floordestheight = FindLowestFloorSurrounding(sec);
				break;
			case FLEV_LOWERFLOORBYVALUE:
				floor->direction = -1;
				floor->floordestheight = floor->sector->floorheight -
					itof(args[2]);
				break;
			case FLEV_LOWERTIMES8INSTANT:
			case FLEV_LOWERBYVALUETIMES8:
				floor->direction = -1;
				floor->floordestheight = floor->sector->floorheight -
					itof(args[2]) * 8.0;
				break;
			case FLEV_RAISEFLOORCRUSH:
				floor->crush = args[2]; // arg[2] = crushing value
				floor->direction = 1;
				floor->floordestheight = sec->ceilingheight - 8.0;
				break;
			case FLEV_RAISEFLOOR:
				floor->direction = 1;
				floor->floordestheight = FindLowestCeilingSurrounding(sec);
				if (floor->floordestheight > sec->ceilingheight)
					floor->floordestheight = sec->ceilingheight;
				break;
			case FLEV_RAISEFLOORTONEAREST:
				floor->direction = 1;
				floor->floordestheight = FindNextHighestFloor(sec, sec->floorheight);
				break;
			case FLEV_RAISEFLOORBYVALUE:
				floor->direction = 1;
				floor->floordestheight = floor->sector->floorheight +
					itof(args[2]);
				break;
			case FLEV_RAISETIMES8INSTANT:
			case FLEV_RAISEBYVALUETIMES8:
				floor->direction = 1;
				floor->floordestheight = floor->sector->floorheight +
					itof(args[2]) * 8.0;
				break;
			case FLEV_MOVETOVALUETIMES8:
				floor->floordestheight = itof(args[2]) * 8.0;
				if (args[3])
				{
					floor->floordestheight = -floor->floordestheight;
				}
				if (floor->floordestheight > floor->sector->floorheight)
				{
					floor->direction = 1;
				}
				else if (floor->floordestheight < floor->sector->floorheight)
				{
					floor->direction = -1;
				}
				else
				{ // already at lowest position
					rtn = 0;
				}
				break;
			default:
            	Error("Invalid floor type.");
				rtn = 0;
				break;
		}
	}
	if (rtn)
	{
		SectorStartSequence(floor->sector,
			seq_name[SEQ_PLATFORM + floor->sector->seqType]);
	}
	return rtn;
}

//==========================================================================
//
//	EV_DoFloorAndCeiling
//
//==========================================================================

int EV_DoFloorAndCeiling(line_t *line, int *args, boolean raise)
{
	boolean 	floor;
	boolean		ceiling;
	int			secnum;
	sector_t	*sec;

	if (raise)
	{
		floor = EV_DoFloor(line, args, FLEV_RAISEFLOORBYVALUE);
		secnum = -1;
		while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
		{
			sec = &level->sectors[secnum];
			sec->specialdata = NULL;
		}
		ceiling = EV_DoCeiling(line, args, CLEV_RAISEBYVALUE);
	}		
	else 
	{
		floor = EV_DoFloor(line, args, FLEV_LOWERFLOORBYVALUE);
		secnum = -1;
		while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
		{
			sec = &level->sectors[secnum];
			sec->specialdata = NULL;
		}
		ceiling = EV_DoCeiling(line, args, CLEV_LOWERBYVALUE);
	}
	return floor || ceiling;
}
			
//==========================================================================
//
// EV_FloorCrushStop
//
//==========================================================================

int EV_FloorCrushStop(line_t *line, int *args)
{
	special_t	*floor;
	boolean 	rtn;

	rtn = 0;
	for (floor = activefloors.next; floor != &activefloors; floor = floor->next)
	{
		if (floor->type != FLEV_RAISEFLOORCRUSH)
		{
			continue;
		}
		// Completely remove the crushing floor
		SectorStopSequence(floor->sector);
		floor->sector->specialdata = NULL;
		RemoveActiveFloor(floor);
		rtn = 1;
	}
	return rtn;
}

//**************************************************************************
//
//	STAIRS
//
//**************************************************************************

// ===== Build Stairs Private Data =====

#define STAIR_SECTOR_TYPE       26
#define STAIR_QUEUE_SIZE        32

enum
{
	STAIRS_NORMAL,
	STAIRS_SYNC,
	STAIRS_PHASED
};

struct stairqueue_t
{
	sector_t	*sector;
	int			type;
	float		height;
};

stairqueue_t	StairQueue[STAIR_QUEUE_SIZE];
int 			QueueHead;
int 			QueueTail;

float			StepDelta;
int 			Direction;
float			Speed;
int 			Texture;
int 			StartDelay;
int 			StartDelayDelta;
int 			TextureChange;
float			StartHeight;

//==========================================================================
//
//	QueueStairSector
//
//==========================================================================

void QueueStairSector(sector_t *sec, int type, float height)
{
	if ((QueueTail + 1) % STAIR_QUEUE_SIZE == QueueHead)
	{
		Error("BuildStairs:  Too many branches located.");
	}
	StairQueue[QueueTail].sector = sec;
	StairQueue[QueueTail].type = type;
	StairQueue[QueueTail].height = height;

	QueueTail = (QueueTail + 1) % STAIR_QUEUE_SIZE;
}

//==========================================================================
//
//	DequeueStairSector
//
//==========================================================================

sector_t *DequeueStairSector(int *type, float *height)
{
	sector_t *sec;

	if (QueueHead == QueueTail)
	{
		// queue is empty
		return NULL;
	}
	*type = StairQueue[QueueHead].type;
	*height = StairQueue[QueueHead].height;
	sec = StairQueue[QueueHead].sector;
	QueueHead = (QueueHead + 1) % STAIR_QUEUE_SIZE;

	return sec;
}

//==========================================================================
//
//	ProcessStairSector
//
//==========================================================================

void ProcessStairSector(sector_t *sec, int type, float height,
	int stairsType, int delay, int resetDelay)
{
	int			i;
	sector_t	*tsec;
	special_t	*floor;

	//
	// new floor thinker
	//
	height += StepDelta;
	floor = NewSpecialThinker(special_t);
	floor->function = T_MoveFloor;
	sec->specialdata = floor;
    AddActiveFloor(floor);
	floor->type = FLEV_RAISEBUILDSTEP;
	floor->direction = Direction;
	floor->sector = sec;
	floor->floordestheight = height;
	switch (stairsType)
	{
		case STAIRS_NORMAL:
			floor->speed = Speed;
			if(delay)
			{
				floor->delayTotal = delay;
				floor->stairsDelayHeight = sec->floorheight + StepDelta;
				floor->stairsDelayHeightDelta = StepDelta;
			}
			floor->resetDelay = resetDelay;
			floor->resetDelayCount = resetDelay;
			floor->resetHeight = sec->floorheight;
			break;
		case STAIRS_SYNC:
			floor->speed = Speed * (height - StartHeight) / StepDelta;
			floor->resetDelay = delay; //arg4
			floor->resetDelayCount = delay;
			floor->resetHeight = sec->floorheight;
			break;
/*
		case STAIRS_PHASED:
			floor->floordestheight = sec->floorheight + StepDelta;
			floor->speed = Speed;
			floor->delayCount = StartDelay;
			StartDelay += StartDelayDelta;
			floor->textureChange = TextureChange;
			floor->resetDelayCount = StartDelay;
			break;
*/
		default:
			break;
	}
	SectorStartSequence(sec, seq_name[SEQ_PLATFORM + sec->seqType]);
	//
	// Find next sector to raise
	// Find nearby sector with sector special equal to type
	//
	for (i = 0; i < sec->linecount; i++)
	{
        line_t*		line;

		line = sec->lines[i];
		if (!(line->flags & ML_TWOSIDED))
		{
			continue;
		}
		tsec = line->frontsector;
		if (tsec->special == type + STAIR_SECTOR_TYPE && !tsec->specialdata
			&& tsec->floor.pic == Texture && tsec->validcount != *validcount)
		{
			QueueStairSector(tsec, type ^ 1, height);
			tsec->validcount = *validcount;
			//tsec->special = 0;
		}
		tsec = line->backsector;
		if (tsec->special == type+STAIR_SECTOR_TYPE && !tsec->specialdata
			&& tsec->floor.pic == Texture && tsec->validcount != *validcount)
		{
			QueueStairSector(tsec, type ^ 1, height);
			tsec->validcount = *validcount;
			//tsec->special = 0;
		}
	}
}

//==========================================================================
//
//  EV_BuildStairs
//
//	BUILD A STAIRCASE!
//
//	Direction is either positive or negative, denoting build stairs
// up or down.
//
//==========================================================================

int EV_BuildStairs(line_t *line, int *args, int direction, int stairsType)
{
	int 		secnum;
	float		height;
	int			delay;
	int 		resetDelay;
	sector_t	*sec;
	sector_t	*qSec;
	int 		type;

	// Set global stairs variables
	TextureChange = 0;
	Direction = direction;
	StepDelta = itof(Direction * args[2]);
	Speed = itof(args[1]) / 8.0;
	resetDelay = args[4];
	delay = args[3];
	if (stairsType == STAIRS_PHASED)
	{
		StartDelayDelta = args[3];
		StartDelay = StartDelayDelta;
		resetDelay = StartDelayDelta;
		delay = 0;
		TextureChange = args[4];
	}

	secnum = -1;

	(*validcount)++;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &level->sectors[secnum];

		Texture = sec->floor.pic;
		StartHeight = sec->floorheight;

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (sec->specialdata)
			continue;

		QueueStairSector(sec, 0, sec->floorheight);
		sec->special = 0;
	}
	while ((qSec = DequeueStairSector(&type, &height)) != NULL)
	{
		ProcessStairSector(qSec, type, height, stairsType, delay, resetDelay);
	}
	return 1;
}

//**************************************************************************
//
//	PILLAR
//
//**************************************************************************

//==========================================================================
//
//	T_BuildPillar
//
//==========================================================================

void T_BuildPillar(special_t *pillar)
{
	int		res1;
	int		res2;

	// First, raise the floor
	res1 = T_MovePlane(pillar->sector, pillar->floorSpeed, pillar->floordest,
		pillar->crush, 0, pillar->direction); // floorOrCeiling, direction
	// Then, lower the ceiling
	res2 = T_MovePlane(pillar->sector, pillar->ceilingSpeed,
		pillar->ceilingdest, pillar->crush, 1, -pillar->direction);
	if (res1 == RES_PASTDEST && res2 == RES_PASTDEST)
	{
		pillar->sector->specialdata = NULL;
		SectorStopSequence(pillar->sector);
        TagFinished(pillar->sector->tag);
		RemoveSpecialThinker(pillar);
	}
}

//==========================================================================
//
//	EV_BuildPillar
//
//==========================================================================

int EV_BuildPillar(line_t *line, int *args, boolean crush)
{
	int 		secnum;
	sector_t 	*sec;
	special_t	*pillar;
	float		newHeight;
	int 		rtn;

	rtn = 0;
	secnum = -1;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &level->sectors[secnum];
		if (sec->specialdata)
			continue; // already moving
		if (sec->floorheight == sec->ceilingheight)
		{
			// pillar is already closed
			continue;
		}
		rtn = 1;
		if (!args[2])
		{
			newHeight = sec->floorheight +
				((sec->ceilingheight - sec->floorheight) / 2.0);
		}
		else
		{
			newHeight = sec->floorheight + itof(args[2]);
		}

		pillar = NewSpecialThinker(special_t);
		pillar->function = T_BuildPillar;
		sec->specialdata = pillar;
		pillar->sector = sec;
		if (!args[2])
		{
			pillar->ceilingSpeed = pillar->floorSpeed = itof(args[1]) / 8.0;
		}
		else if (newHeight - sec->floorheight > sec->ceilingheight - newHeight)
		{
			pillar->floorSpeed = itof(args[1]) / 8.0;
			pillar->ceilingSpeed = (sec->ceilingheight - newHeight) *
				pillar->floorSpeed / (newHeight - sec->floorheight);
		}
		else
		{
			pillar->ceilingSpeed = itof(args[1]) / 8.0;
			pillar->floorSpeed = (newHeight - sec->floorheight) *
				pillar->ceilingSpeed / (sec->ceilingheight - newHeight);
		}
		pillar->floordest = newHeight;
		pillar->ceilingdest = newHeight;
		pillar->direction = 1;
		pillar->crush = crush*args[3];
		SectorStartSequence(pillar->sector,
			seq_name[SEQ_PLATFORM + pillar->sector->seqType]);
	}
	return rtn;
}

//==========================================================================
//
// EV_OpenPillar
//
//==========================================================================

int EV_OpenPillar(line_t *line, int *args)
{
	int 		secnum;
	sector_t 	*sec;
	special_t	*pillar;
	int 		rtn;

	rtn = 0;
	secnum = -1;
	while((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &level->sectors[secnum];
		if(sec->specialdata)
			continue; // already moving
		if(sec->floorheight != sec->ceilingheight)
		{ // pillar isn't closed
			continue;
		}
		rtn = 1;
		pillar = NewSpecialThinker(special_t);
		pillar->function = T_BuildPillar;
		sec->specialdata = pillar;
		pillar->sector = sec;
		if(!args[2])
		{
			pillar->floordest = FindLowestFloorSurrounding(sec);
		}
		else
		{
			pillar->floordest = sec->floorheight - itof(args[2]);
		}
		if(!args[3])
		{
			pillar->ceilingdest = FindHighestCeilingSurrounding(sec);
		}
		else
		{
			pillar->ceilingdest = sec->ceilingheight + itof(args[3]);
		}
		if (sec->floorheight - pillar->floordest >= pillar->ceilingdest -
			sec->ceilingheight)
		{
			pillar->floorSpeed = itof(args[1]) / 8.0;
			pillar->ceilingSpeed = (sec->ceilingheight -
				pillar->ceilingdest) * pillar->floorSpeed /
				(pillar->floordest - sec->floorheight);
		}
		else
		{
			pillar->ceilingSpeed = itof(args[1]) / 8.0;
			pillar->floorSpeed = (pillar->floordest -
				sec->floorheight) * pillar->ceilingSpeed /
				(sec->ceilingheight - pillar->ceilingdest);
		}
		pillar->direction = -1; // open the pillar
		SectorStartSequence(pillar->sector,
			seq_name[SEQ_PLATFORM+pillar->sector->seqType]);
	}
	return rtn;
}

//**************************************************************************
//
//	FLOOR WAGGLE
//
//**************************************************************************

//==========================================================================
//
// T_FloorWaggle
//
//==========================================================================

#define WGLSTATE_EXPAND 1
#define WGLSTATE_STABLE 2
#define WGLSTATE_REDUCE 3

void T_FloorWaggle(special_t *waggle)
{
	switch (waggle->state)
	{
		case WGLSTATE_EXPAND:
			if ((waggle->scale += waggle->scaleDelta) >= waggle->targetScale)
			{
				waggle->scale = waggle->targetScale;
				waggle->state = WGLSTATE_STABLE;
			}
			break;
		case WGLSTATE_REDUCE:
			if ((waggle->scale -= waggle->scaleDelta) <= 0.0)
			{
				// Remove
				waggle->sector->floorheight = waggle->originalHeight;
				P_ChangeSector(waggle->sector, true);
				waggle->sector->specialdata = NULL;
                TagFinished(waggle->sector->tag);
				RemoveSpecialThinker(waggle);
				return;
			}
			break;
		case WGLSTATE_STABLE:
			if (waggle->ticker != -1)
			{
				if (!--waggle->ticker)
				{
					waggle->state = WGLSTATE_REDUCE;
				}
			}
			break;
	}
	waggle->accumulator += waggle->accDelta;
	waggle->sector->floorheight = waggle->originalHeight +
		FloatBobOffsets[ftoi(waggle->accumulator) & 63] * waggle->scale;
	P_ChangeSector(waggle->sector, true);
}

//==========================================================================
//
//	EV_StartFloorWaggle
//
//==========================================================================

boolean EV_StartFloorWaggle(int tag, int height, int speed, int offset,
	int timer)
{
	int 		sectorIndex;
	sector_t 	*sector;
	special_t 	*waggle;
	boolean 	retCode;

	retCode = false;
	sectorIndex = -1;
	while ((sectorIndex = FindSectorFromTag(tag, sectorIndex)) >= 0)
	{
		sector = &level->sectors[sectorIndex];
		if (sector->specialdata)
		{
			// Already busy with another thinker
			continue;
		}
		retCode = true;
		waggle = NewSpecialThinker(special_t);
		waggle->function = T_FloorWaggle;
		sector->specialdata = waggle;
		waggle->sector = sector;
		waggle->originalHeight = sector->floorheight;
		waggle->accumulator = itof(offset);
		waggle->accDelta = itof(speed) / 64.0;
		waggle->scale = 0.0;
		waggle->targetScale = itof(height) / 64.0;
		waggle->scaleDelta = waggle->targetScale
			/ itof(35 + ((3 * 35) * height) / 255);
		waggle->ticker = timer ? timer * 35 : -1;
		waggle->state = WGLSTATE_EXPAND;
	}
	return retCode;
}

//**************************************************************************
//
//	$Log$
//	Revision 1.3  2001/09/20 16:20:00  dj_jl
//	Start using object-oriented stuff, beautification
//
//	Revision 1.2  2001/07/27 14:27:52  dj_jl
//	Update with Id-s and Log-s, some fixes
//
//**************************************************************************
