//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**    Intercepts
//**
//**************************************************************************

// Mana

#define TXT_MANA_1				"BLUE MANA"
#define TXT_MANA_2				"GREEN MANA"
#define TXT_MANA_BOTH			"COMBINED MANA"

// Artifacts

#define TXT_ARTIINVULNERABILITY		"ICON OF THE DEFENDER"
#define TXT_ARTIHEALTH				"QUARTZ FLASK"
#define TXT_ARTISUPERHEALTH			"MYSTIC URN"
#define TXT_ARTISUMMON				"DARK SERVANT"
#define TXT_ARTITORCH				"TORCH"
#define TXT_ARTIEGG					"PORKALATOR"
#define TXT_ARTIFLY					"WINGS OF WRATH"
#define TXT_ARTITELEPORT			"CHAOS DEVICE"
#define TXT_ARTIPOISONBAG			"FLECHETTE"
#define TXT_ARTITELEPORTOTHER		"BANISHMENT DEVICE"
#define TXT_ARTISPEED				"BOOTS OF SPEED"
#define TXT_ARTIBOOSTMANA			"KRATER OF MIGHT"
#define TXT_ARTIBOOSTARMOR			"DRAGONSKIN BRACERS"
#define TXT_ARTIBLASTRADIUS			"DISC OF REPULSION"
#define TXT_ARTIHEALINGRADIUS		"MYSTIC AMBIT INCANT"

// Puzzle artifacts

#define TXT_ARTIPUZZSKULL			"YORICK'S SKULL"
#define TXT_ARTIPUZZGEMBIG			"HEART OF D'SPARIL"
#define TXT_ARTIPUZZGEMRED			"RUBY PLANET"
#define TXT_ARTIPUZZGEMGREEN1		"EMERALD PLANET"
#define TXT_ARTIPUZZGEMGREEN2		"EMERALD PLANET"
#define TXT_ARTIPUZZGEMBLUE1		"SAPPHIRE PLANET"
#define TXT_ARTIPUZZGEMBLUE2		"SAPPHIRE PLANET"
#define TXT_ARTIPUZZBOOK1			"DAEMON CODEX"
#define TXT_ARTIPUZZBOOK2			"LIBER OSCURA"
#define TXT_ARTIPUZZSKULL2			"FLAME MASK"
#define TXT_ARTIPUZZFWEAPON			"GLAIVE SEAL"
#define TXT_ARTIPUZZCWEAPON			"HOLY RELIC"
#define TXT_ARTIPUZZMWEAPON			"SIGIL OF THE MAGUS"
#define TXT_ARTIPUZZGEAR			"CLOCK GEAR"

// Items

#define TXT_ITEMHEALTH			"CRYSTAL VIAL"
#define TXT_ITEMBAGOFHOLDING	"BAG OF HOLDING"
#define TXT_ITEMSHIELD1			"SILVER SHIELD"
#define TXT_ITEMSHIELD2			"ENCHANTED SHIELD"
#define TXT_ITEMSUPERMAP		"MAP SCROLL"
#define TXT_ARMOR1				"MESH ARMOR"
#define TXT_ARMOR2				"FALCON SHIELD"
#define TXT_ARMOR3				"PLATINUM HELMET"
#define TXT_ARMOR4				"AMULET OF WARDING"

// Weapons

#define TXT_WEAPON_F2			"TIMON'S AXE"
#define TXT_WEAPON_F3			"HAMMER OF RETRIBUTION"
#define TXT_WEAPON_F4			"QUIETUS ASSEMBLED"
#define TXT_WEAPON_C2			"SERPENT STAFF"
#define TXT_WEAPON_C3			"FIRESTORM"
#define TXT_WEAPON_C4			"WRAITHVERGE ASSEMBLED"
#define TXT_WEAPON_M2			"FROST SHARDS"
#define TXT_WEAPON_M3			"ARC OF DEATH"
#define TXT_WEAPON_M4			"BLOODSCOURGE ASSEMBLED"
#define TXT_QUIETUS_PIECE		"SEGMENT OF QUIETUS"
#define TXT_WRAITHVERGE_PIECE	"SEGMENT OF WRAITHVERGE"
#define TXT_BLOODSCOURGE_PIECE	"SEGMENT OF BLOODSCOURGE"

#define BONUSADD 	6

void SetFighterAxe(player_t * player);
void P_HideSpecialThing(mobj_t * thing);
void SetDormantArtifact(mobj_t * arti);
void P_RemoveMobj(mobj_t * mobj);

float ArmorMax[NUMCLASSES] = { 20.0, 18.0, 16.0, 1.0 };

int pieceValueTrans[] = {
	0,	// 0: never
	WPIECE1 | WPIECE2 | WPIECE3,	// WPIECE1 (1)
	WPIECE2 | WPIECE3,	// WPIECE2 (2)
	0,	// 3: never
	WPIECE3	// WPIECE3 (4)
};

//
//  Pickup messages
//
string fourthWeaponText[] = {
	TXT_WEAPON_F4,
	TXT_WEAPON_C4,
	TXT_WEAPON_M4
};
string weaponPieceText[] = {
	TXT_QUIETUS_PIECE,
	TXT_WRAITHVERGE_PIECE,
	TXT_BLOODSCOURGE_PIECE
};
string artifactMessages[NUMARTIFACTS] = {
	"",
	TXT_ARTIINVULNERABILITY,
	TXT_ARTIHEALTH,
	TXT_ARTISUPERHEALTH,
	TXT_ARTIHEALINGRADIUS,
	TXT_ARTISUMMON,
	TXT_ARTITORCH,
	TXT_ARTIEGG,
	TXT_ARTIFLY,
	TXT_ARTIBLASTRADIUS,
	TXT_ARTIPOISONBAG,
	TXT_ARTITELEPORTOTHER,
	TXT_ARTISPEED,
	TXT_ARTIBOOSTMANA,
	TXT_ARTIBOOSTARMOR,
	TXT_ARTITELEPORT,

	TXT_ARTIPUZZSKULL,
	TXT_ARTIPUZZGEMBIG,
	TXT_ARTIPUZZGEMRED,
	TXT_ARTIPUZZGEMGREEN1,
	TXT_ARTIPUZZGEMGREEN2,
	TXT_ARTIPUZZGEMBLUE1,
	TXT_ARTIPUZZGEMBLUE2,
	TXT_ARTIPUZZBOOK1,
	TXT_ARTIPUZZBOOK2,
	TXT_ARTIPUZZSKULL2,
	TXT_ARTIPUZZFWEAPON,
	TXT_ARTIPUZZCWEAPON,
	TXT_ARTIPUZZMWEAPON,
	TXT_ARTIPUZZGEAR,	// All gear pickups use the same text
	TXT_ARTIPUZZGEAR,
	TXT_ARTIPUZZGEAR,
	TXT_ARTIPUZZGEAR
};

//==========================================================================
//
//  Actor::GiveMana
//
//  Returns true if the player accepted the mana, false if it was
// refused (player has MAX_MANA).
//
//==========================================================================

boolean Actor::GiveMana(int mana, int count)
{
	int prevMana;

	if (mana == MANA_NONE || mana == MANA_BOTH)
	{
		return false;
	}
	if (mana < 0 || mana > NUMMANA)
	{
		Error("Actor::GiveMana: bad type %i", mana);
	}
	if (player->mana[mana] == MAX_MANA)
	{
		return false;
	}
	if (gameskill == sk_baby || gameskill == sk_nightmare)
	{
		// extra mana in baby mode and nightmare mode
		count += count >> 1;
	}
	prevMana = player->mana[mana];

	player->mana[mana] += count;
	if (player->mana[mana] > MAX_MANA)
	{
		player->mana[mana] = MAX_MANA;
	}
	if (player->pclass == PCLASS_FIGHTER && player->readyweapon == WP_SECOND
		&& mana == MANA_1 && prevMana <= 0)
	{
		SetFighterAxe(player);
	}
	return true;
}

//==========================================================================
//
//	Actor::TryPickupWeapon
//
//==========================================================================

void Actor::TryPickupWeapon(int weaponClass, int weaponType,
	Actor weapon, string message)
{
	boolean remove;
	boolean gaveMana;
	boolean gaveWeapon;

	remove = true;
	if (player->pclass != weaponClass)
	{
		// Wrong class, but try to pick up for mana
		if (netgame && !deathmatch)
		{
			// Can't pick up weapons for other classes in coop netplay
			return;
		}
		if (weaponType == WP_SECOND)
		{
			if (!GiveMana(MANA_1, 25))
			{
				return;
			}
		}
		else
		{
			if (!GiveMana(MANA_2, 25))
			{
				return;
			}
		}
	}
	else if (netgame && !deathmatch)
	{
		// Cooperative net-game
		if (player->weaponowned[weaponType])
		{
			return;
		}
		player->weaponowned[weaponType] = true;
		if (weaponType == WP_SECOND)
		{
			GiveMana(MANA_1, 25);
		}
		else
		{
			GiveMana(MANA_2, 25);
		}
		player->pendingweapon = weaponType;
		remove = false;
	}
	else
	{
		// Deathmatch or single player game
		if (weaponType == WP_SECOND)
		{
			gaveMana = GiveMana(MANA_1, 25);
		}
		else
		{
			gaveMana = GiveMana(MANA_2, 25);
		}
		if (player->weaponowned[weaponType])
		{
			gaveWeapon = false;
		}
		else
		{
			gaveWeapon = true;
			player->weaponowned[weaponType] = true;
			if (weaponType > player->readyweapon)
			{
				// Only switch to more powerful weapons
				player->pendingweapon = weaponType;
			}
		}
		if (!gaveWeapon && !gaveMana)
		{
			// Player didn't need the weapon or any mana
			return;
		}
	}

	cprint(player, "%s\n", message);
	if (weapon.special)
	{
		ExecuteLineSpecial(weapon.special, &weapon.args[0], NULL, 0, this);
		weapon.special = 0;
	}

	if (remove)
	{
		if (deathmatch && !weapon.bDropped)
		{
			P_HideSpecialThing(&weapon);
		}
		else
		{
			P_RemoveMobj(&weapon);
		}
	}

	player->bonuscount += BONUSADD;
	StartSoundName(self, 'PickupWeapon', CHAN_ITEM);
}

//==========================================================================
//
//	Actor::TryPickupWeaponPiece
//
//==========================================================================

void Actor::TryPickupWeaponPiece(int matchClass, int pieceValue,
	Actor pieceMobj)
{
	boolean remove;
	boolean checkAssembled;
	boolean gaveWeapon;
	int gaveMana;

	remove = true;
	checkAssembled = true;
	gaveWeapon = false;
	if (player->pclass != matchClass)
	{
		// Wrong class, but try to pick up for mana
		if (netgame && !deathmatch)
		{
			// Can't pick up wrong-class weapons in coop netplay
			return;
		}
		checkAssembled = false;
		gaveMana = GiveMana(MANA_1, 20) + GiveMana(MANA_2, 20);
		if (!gaveMana)
		{
			// Didn't need the mana, so don't pick it up
			return;
		}
	}
	else if (netgame && !deathmatch)
	{
		// Cooperative net-game
		if (player->pieces & pieceValue)
		{
			// Already has the piece
			return;
		}
		pieceValue = pieceValueTrans[pieceValue];
		GiveMana(MANA_1, 20);
		GiveMana(MANA_2, 20);
		remove = false;
	}
	else
	{
		// Deathmatch or single player game
		gaveMana = GiveMana(MANA_1, 20) + GiveMana(MANA_2, 20);
		if (player->pieces & pieceValue)
		{
			// Already has the piece, check if mana needed
			if (!gaveMana)
			{
				// Didn't need the mana, so don't pick it up
				return;
			}
			checkAssembled = false;
		}
	}

	// Pick up the weapon piece
	if (pieceMobj.special)
	{
		ExecuteLineSpecial(pieceMobj.special, &pieceMobj.args[0], NULL, 0,
			this);
		pieceMobj.special = 0;
	}
	if (remove)
	{
		if (deathmatch && !pieceMobj.bDropped)
		{
			P_HideSpecialThing(&pieceMobj);
		}
		else
		{
			P_RemoveMobj(&pieceMobj);
		}
	}
	player->bonuscount += BONUSADD;

	// Check if fourth weapon assembled
	if (checkAssembled)
	{
		player->pieces |= pieceValue;
		if (player->pieces == (WPIECE1 | WPIECE2 | WPIECE3))
		{
			gaveWeapon = true;
			player->weaponowned[WP_FOURTH] = true;
			player->pendingweapon = WP_FOURTH;
		}
	}

	if (gaveWeapon)
	{
		cprint(player, "%s\n", fourthWeaponText[matchClass]);
		// Play the build-sound full volume for all players
		StartSoundName(none, 'WeaponBuild', CHAN_ITEM);
	}
	else
	{
		cprint(player, "%s\n", weaponPieceText[matchClass]);
		StartSoundName(none, 'PickupWeapon', CHAN_ITEM);	//FIXME must be PickupPiece
	}
}

//==========================================================================
//
//  Actor::GiveBody
//
//  Returns false if the body isn't needed at all.
//
//==========================================================================

boolean Actor::GiveBody(int num)
{
	int max;

	max = MAXHEALTH;
	if (player->morphTics)
	{
		max = MAXMORPHHEALTH;
	}
	if (player->health >= max)
	{
		return false;
	}
	player->health += num;
	if (player->health > max)
	{
		player->health = max;
	}
	Health = player->health;
	return true;
}

//==========================================================================
//
//  Actor::GiveArmor
//
//  Returns false if the armor is worse than the current armor.
//
//==========================================================================

boolean Actor::GiveArmor(int armortype, int amount)
{
	float hits;
	float totalArmor;

	if (amount == -1)
	{
		hits = ArmorIncrement[player->pclass * NUMARMOR + armortype];
		if (player->armorpoints[armortype] >= hits)
		{
			return false;
		}
		else
		{
			player->armorpoints[armortype] = hits;
		}
	}
	else
	{
		hits = itof(amount) * 5.0;
		totalArmor = player->armorpoints[ARMOR_ARMOR]
			+ player->armorpoints[ARMOR_SHIELD]
			+ player->armorpoints[ARMOR_HELMET]
			+ player->armorpoints[ARMOR_AMULET]
			+ AutoArmorSave[player->pclass];
		if (totalArmor < ArmorMax[player->pclass] * 5.0)
		{
			player->armorpoints[armortype] += hits;
		}
		else
		{
			return false;
		}
	}
	return true;
}

//==========================================================================
//
//  Actor::GiveKey
//
//==========================================================================

boolean Actor::GiveKey(int key)
{
	if (player->keys & (1 << key))
	{
		return false;
	}
	player->bonuscount += BONUSADD;
	player->keys |= 1 << key;
	return true;
}

//==========================================================================
//
//  Actor::GivePower
//
//  Returns true if power accepted.
//
//==========================================================================

boolean Actor::GivePower(int power)
{
	if (power == pw_invulnerability)
	{
		if (player->powers[power] > ftoi(BLINKTHRESHOLD * 35.0))
		{
			// Already have it
			return false;
		}
		player->powers[power] = ftoi(INVULNTIME * 35.0);
		bInvulnerable = true;
		if (player->pclass == PCLASS_MAGE)
		{
			bReflective = true;
		}
		return true;
	}
	if (power == pw_flight)
	{
		if (player->powers[power] > ftoi(BLINKTHRESHOLD * 35.0))
		{
			// Already have it
			return false;
		}
		player->powers[power] = ftoi(FLIGHTTIME * 35.0);
		bFly = true;
		bNoGravity = true;
		if (origin.z <= floorz)
		{
			player->flyheight = 10.0;	// thrust the player in the air a bit
		}
		return (true);
	}
	if (power == pw_infrared)
	{
		if (player->powers[power] > ftoi(BLINKTHRESHOLD * 35.0))
		{
			// Already have it
			return false;
		}
		player->powers[power] = ftoi(INFRATIME * 35.0);
		return true;
	}
	if (power == pw_speed)
	{
		if (player->powers[power] > ftoi(BLINKTHRESHOLD * 35.0))
		{
			// Already have it
			return false;
		}
		player->powers[power] = ftoi(SPEEDTIME * 35.0);
		return true;
	}
	if (power == pw_minotaur)
	{
		// Doesn't matter if already have power, renew ticker
		player->powers[power] = ftoi(MAULATORTIME * 35.0);
		return true;
	}
	if (player->powers[power])
	{
		return false;	// already got it
	}
	player->powers[power] = 1;
	return true;
}

//==========================================================================
//
//  Actor::GiveArtifact
//
//  Returns true if artifact accepted.
//
//==========================================================================

boolean Actor::GiveArtifact(int arti)
{
	int i;
	int j;
	boolean slidePointer;

	slidePointer = false;
	i = 0;
	while (player->inventory[i].type != arti && i < player->inventorySlotNum)
	{
		i++;
	}
	if (i == player->inventorySlotNum)
	{
		if (arti < arti_firstpuzzitem)
		{
			i = 0;
			while (player->inventory[i].type < arti_firstpuzzitem
				&& i < player->inventorySlotNum)
			{
				i++;
			}
			if (i != player->inventorySlotNum)
			{
				for (j = player->inventorySlotNum; j > i; j--)
				{
					player->inventory[j].count =
						player->inventory[j - 1].count;
					player->inventory[j].type = player->inventory[j - 1].type;
					slidePointer = true;
				}
			}
		}
		player->inventory[i].count = 1;
		player->inventory[i].type = arti;
		player->inventorySlotNum++;
	}
	else
	{
		if (arti >= arti_firstpuzzitem && netgame && !deathmatch)
		{
			// Can't carry more than 1 puzzle item in coop netplay
			return false;
		}
		if (player->inventory[i].count >= 25)
		{
			// Player already has 25 of this item
			return false;
		}
		player->inventory[i].count++;
	}
	if (!player->artifactCount)
	{
		player->readyArtifact = arti;
	}
	else if (slidePointer && i <= player->inv_ptr)
	{
		player->inv_ptr++;
		player->curpos++;
		if (player->curpos > 6)
		{
			player->curpos = 6;
		}
	}
	player->artifactCount++;
	return true;
}

//==========================================================================
//
//	Actor::TryPickupArtifact
//
//==========================================================================

void Actor::TryPickupArtifact(int artifactType, Actor artifact)
{
	if (GiveArtifact(artifactType))
	{
		if (artifact.special)
		{
			ExecuteLineSpecial(artifact.special, &artifact.args[0],
				NULL, 0, NULL);
			artifact.special = 0;
		}
		player->bonuscount += BONUSADD;
		if (artifactType < arti_firstpuzzitem)
		{
			SetDormantArtifact(&artifact);
			StartSoundName(artifact, 'PickupArtifact', CHAN_ITEM);
			cprint(player, "%s\n", artifactMessages[artifactType]);
		}
		else
		{
			// Puzzle item
			StartSoundName(none, 'PickupItem', CHAN_ITEM);
			cprint(player, "%s\n", artifactMessages[artifactType]);
			if (!netgame || deathmatch)
			{
				// Remove puzzle items if not cooperative netplay
				P_RemoveMobj(&artifact);
			}
		}
	}
}

//==========================================================================
//
//  Actor::TouchSpecial
//
//==========================================================================

void Actor::TouchSpecial(Actor Toucher)
{
	name sound;
	boolean respawn;
	int KeyType;

	if (!Toucher.bPickUp)
	{
		// Can't be picked up by toucher
		return;
	}
	if (Toucher.Health <= 0)
	{
		// Toucher is dead
		return;
	}
	sound = 'PickupItem';
	respawn = true;
	KeyType = -1;
	switch (SpriteName)
	{
		// Items
	case 'PTN1':	// Item_HealingPotion
		if (!Toucher.GiveBody(10))
		{
			return;
		}
		cprint(Toucher.player, "%s\n", TXT_ITEMHEALTH);
		break;
	case 'ARM1':
		if (!Toucher.GiveArmor(ARMOR_ARMOR, -1))
		{
			return;
		}
		cprint(Toucher.player, "%s\n", TXT_ARMOR1);
		break;
	case 'ARM2':
		if (!Toucher.GiveArmor(ARMOR_SHIELD, -1))
		{
			return;
		}
		cprint(Toucher.player, "%s\n", TXT_ARMOR2);
		break;
	case 'ARM3':
		if (!Toucher.GiveArmor(ARMOR_HELMET, -1))
		{
			return;
		}
		cprint(Toucher.player, "%s\n", TXT_ARMOR3);
		break;
	case 'ARM4':
		if (!Toucher.GiveArmor(ARMOR_AMULET, -1))
		{
			return;
		}
		cprint(Toucher.player, "%s\n", TXT_ARMOR4);
		break;

		// Keys
	case 'KEYB':
		KeyType++;
	case 'KEYA':
		KeyType++;
	case 'KEY9':
		KeyType++;
	case 'KEY8':
		KeyType++;
	case 'KEY7':
		KeyType++;
	case 'KEY6':
		KeyType++;
	case 'KEY5':
		KeyType++;
	case 'KEY4':
		KeyType++;
	case 'KEY3':
		KeyType++;
	case 'KEY2':
		KeyType++;
	case 'KEY1':
		KeyType++;
		if (!Toucher.GiveKey(KeyType))
		{
			return;
		}
		cprint(Toucher.player, "%s\n", TextKeyMessages[KeyType]);
		sound = 'PickupKey';
		break;

		// Artifacts
	case 'PTN2':
		Toucher.TryPickupArtifact(arti_health, self);
		return;
	case 'SOAR':
		Toucher.TryPickupArtifact(arti_fly, self);
		return;
	case 'INVU':
		Toucher.TryPickupArtifact(arti_invulnerability, self);
		return;
	case 'SUMN':
		Toucher.TryPickupArtifact(arti_summon, self);
		return;
	case 'PORK':
		Toucher.TryPickupArtifact(arti_egg, self);
		return;
	case 'SPHL':
		Toucher.TryPickupArtifact(arti_superhealth, self);
		return;
	case 'HRAD':
		Toucher.TryPickupArtifact(arti_healingradius, self);
		return;
	case 'TRCH':
		Toucher.TryPickupArtifact(arti_torch, self);
		return;
	case 'ATLP':
		Toucher.TryPickupArtifact(arti_teleport, self);
		return;
	case 'TELO':
		Toucher.TryPickupArtifact(arti_teleportother, self);
		return;
	case 'PSBG':
		Toucher.TryPickupArtifact(arti_poisonbag, self);
		return;
	case 'SPED':
		Toucher.TryPickupArtifact(arti_speed, self);
		return;
	case 'BMAN':
		Toucher.TryPickupArtifact(arti_boostmana, self);
		return;
	case 'BRAC':
		Toucher.TryPickupArtifact(arti_boostarmor, self);
		return;
	case 'BLST':
		Toucher.TryPickupArtifact(arti_blastradius, self);
		return;

		// Puzzle artifacts
	case 'ASKU':
		Toucher.TryPickupArtifact(arti_puzzskull, self);
		return;
	case 'ABGM':
		Toucher.TryPickupArtifact(arti_puzzgembig, self);
		return;
	case 'AGMR':
		Toucher.TryPickupArtifact(arti_puzzgemred, self);
		return;
	case 'AGMG':
		Toucher.TryPickupArtifact(arti_puzzgemgreen1, self);
		return;
	case 'AGG2':
		Toucher.TryPickupArtifact(arti_puzzgemgreen2, self);
		return;
	case 'AGMB':
		Toucher.TryPickupArtifact(arti_puzzgemblue1, self);
		return;
	case 'AGB2':
		Toucher.TryPickupArtifact(arti_puzzgemblue2, self);
		return;
	case 'ABK1':
		Toucher.TryPickupArtifact(arti_puzzbook1, self);
		return;
	case 'ABK2':
		Toucher.TryPickupArtifact(arti_puzzbook2, self);
		return;
	case 'ASK2':
		Toucher.TryPickupArtifact(arti_puzzskull2, self);
		return;
	case 'AFWP':
		Toucher.TryPickupArtifact(arti_puzzfweapon, self);
		return;
	case 'ACWP':
		Toucher.TryPickupArtifact(arti_puzzcweapon, self);
		return;
	case 'AMWP':
		Toucher.TryPickupArtifact(arti_puzzmweapon, self);
		return;
	case 'AGER':
		Toucher.TryPickupArtifact(arti_puzzgear1, self);
		return;
	case 'AGR2':
		Toucher.TryPickupArtifact(arti_puzzgear2, self);
		return;
	case 'AGR3':
		Toucher.TryPickupArtifact(arti_puzzgear3, self);
		return;
	case 'AGR4':
		Toucher.TryPickupArtifact(arti_puzzgear4, self);
		return;

		// Mana
	case 'MAN1':
		if (!Toucher.GiveMana(MANA_1, 15))
		{
			return;
		}
		cprint(Toucher.player, "%s\n", TXT_MANA_1);
		break;
	case 'MAN2':
		if (!Toucher.GiveMana(MANA_2, 15))
		{
			return;
		}
		cprint(Toucher.player, "%s\n", TXT_MANA_2);
		break;
	case 'MAN3':	// Double Mana Dodecahedron
		if (!Toucher.GiveMana(MANA_1, 20))
		{
			if (!Toucher.GiveMana(MANA_2, 20))
			{
				return;
			}
		}
		else
		{
			Toucher.GiveMana(MANA_2, 20);
		}
		cprint(Toucher.player, "%s\n", TXT_MANA_BOTH);
		break;

		// 2nd and 3rd Mage Weapons
	case 'WMCS':	// Frost Shards
		Toucher.TryPickupWeapon(PCLASS_MAGE, WP_SECOND,
			self, TXT_WEAPON_M2);
		return;
	case 'WMLG':	// Arc of Death
		Toucher.TryPickupWeapon(PCLASS_MAGE, WP_THIRD,
			self, TXT_WEAPON_M3);
		return;

		// 2nd and 3rd Fighter Weapons
	case 'WFAX':	// Timon's Axe
		Toucher.TryPickupWeapon(PCLASS_FIGHTER, WP_SECOND,
			self, TXT_WEAPON_F2);
		return;
	case 'WFHM':	// Hammer of Retribution
		Toucher.TryPickupWeapon(PCLASS_FIGHTER, WP_THIRD,
			self, TXT_WEAPON_F3);
		return;

		// 2nd and 3rd Cleric Weapons
	case 'WCSS':	// Serpent Staff
		Toucher.TryPickupWeapon(PCLASS_CLERIC, WP_SECOND,
			self, TXT_WEAPON_C2);
		return;
	case 'WCFM':	// Firestorm
		Toucher.TryPickupWeapon(PCLASS_CLERIC, WP_THIRD,
			self, TXT_WEAPON_C3);
		return;

		// Fourth Weapon Pieces
	case 'WFR1':
		Toucher.TryPickupWeaponPiece(PCLASS_FIGHTER, WPIECE1, self);
		return;
	case 'WFR2':
		Toucher.TryPickupWeaponPiece(PCLASS_FIGHTER, WPIECE2, self);
		return;
	case 'WFR3':
		Toucher.TryPickupWeaponPiece(PCLASS_FIGHTER, WPIECE3, self);
		return;
	case 'WCH1':
		Toucher.TryPickupWeaponPiece(PCLASS_CLERIC, WPIECE1, self);
		return;
	case 'WCH2':
		Toucher.TryPickupWeaponPiece(PCLASS_CLERIC, WPIECE2, self);
		return;
	case 'WCH3':
		Toucher.TryPickupWeaponPiece(PCLASS_CLERIC, WPIECE3, self);
		return;
	case 'WMS1':
		Toucher.TryPickupWeaponPiece(PCLASS_MAGE, WPIECE1, self);
		return;
	case 'WMS2':
		Toucher.TryPickupWeaponPiece(PCLASS_MAGE, WPIECE2, self);
		return;
	case 'WMS3':
		Toucher.TryPickupWeaponPiece(PCLASS_MAGE, WPIECE3, self);
		return;
	}
	if (special)
	{
		ExecuteLineSpecial(special, &args[0], NULL, 0, &Toucher);
		special = 0;
	}
	if (KeyType == -1 || !netgame)
	{
		// Only remove keys in single player game
		if (deathmatch && respawn && !bDropped)
		{
			P_HideSpecialThing(this);
		}
		else
		{
			P_RemoveMobj(this);
		}
	}
	Toucher.player->bonuscount += BONUSADD;
	StartSoundName(Toucher, sound, CHAN_ITEM);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.13  2002/02/09 18:12:25  dj_jl
//  Replaced identifying sprite name indexes with sprite names
//
//  Revision 1.12  2002/02/06 17:28:53  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.11  2002/02/02 19:17:26  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.10  2002/01/28 18:50:18  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.9  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.8  2002/01/17 18:15:54  dj_jl
//  Renamed all map object classes
//
//  Revision 1.7  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.6  2002/01/11 18:19:42  dj_jl
//  Started to use names in progs
//
//  Revision 1.5  2002/01/07 12:25:57  dj_jl
//  Changed copyright year
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
