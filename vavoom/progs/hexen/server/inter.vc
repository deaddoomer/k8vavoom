//**************************************************************************
//**
//**	##   ##    ##    ##   ##   ####     ####   ###     ###
//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**	   #    ##    ##    #      ####     ####   ##       ##
//**
//**	$Id$
//**
//**	Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**	This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**	This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**	Intercepts
//**
//**************************************************************************

// Mana

#define TXT_MANA_1				"BLUE MANA"
#define TXT_MANA_2				"GREEN MANA"
#define TXT_MANA_BOTH			"COMBINED MANA"

// Artifacts

#define TXT_ARTIINVULNERABILITY		"ICON OF THE DEFENDER"
#define TXT_ARTIHEALTH				"QUARTZ FLASK"
#define TXT_ARTISUPERHEALTH			"MYSTIC URN"
#define TXT_ARTISUMMON				"DARK SERVANT"
#define TXT_ARTITORCH				"TORCH"
#define TXT_ARTIEGG					"PORKALATOR"
#define TXT_ARTIFLY					"WINGS OF WRATH"
#define TXT_ARTITELEPORT			"CHAOS DEVICE"
#define TXT_ARTIPOISONBAG			"FLECHETTE"
#define TXT_ARTITELEPORTOTHER		"BANISHMENT DEVICE"
#define TXT_ARTISPEED				"BOOTS OF SPEED"
#define TXT_ARTIBOOSTMANA			"KRATER OF MIGHT"
#define TXT_ARTIBOOSTARMOR			"DRAGONSKIN BRACERS"
#define TXT_ARTIBLASTRADIUS			"DISC OF REPULSION"
#define TXT_ARTIHEALINGRADIUS		"MYSTIC AMBIT INCANT"

// Puzzle artifacts

#define TXT_ARTIPUZZSKULL			"YORICK'S SKULL"
#define TXT_ARTIPUZZGEMBIG			"HEART OF D'SPARIL"
#define TXT_ARTIPUZZGEMRED			"RUBY PLANET"
#define TXT_ARTIPUZZGEMGREEN1		"EMERALD PLANET"
#define TXT_ARTIPUZZGEMGREEN2		"EMERALD PLANET"
#define TXT_ARTIPUZZGEMBLUE1		"SAPPHIRE PLANET"
#define TXT_ARTIPUZZGEMBLUE2		"SAPPHIRE PLANET"
#define TXT_ARTIPUZZBOOK1			"DAEMON CODEX"
#define TXT_ARTIPUZZBOOK2			"LIBER OSCURA"
#define TXT_ARTIPUZZSKULL2			"FLAME MASK"
#define TXT_ARTIPUZZFWEAPON			"GLAIVE SEAL"
#define TXT_ARTIPUZZCWEAPON			"HOLY RELIC"
#define TXT_ARTIPUZZMWEAPON			"SIGIL OF THE MAGUS"
#define TXT_ARTIPUZZGEAR			"CLOCK GEAR"

// Items

#define TXT_ITEMHEALTH			"CRYSTAL VIAL"
#define TXT_ITEMBAGOFHOLDING	"BAG OF HOLDING"
#define TXT_ITEMSHIELD1			"SILVER SHIELD"
#define TXT_ITEMSHIELD2			"ENCHANTED SHIELD"
#define TXT_ITEMSUPERMAP		"MAP SCROLL"
#define TXT_ARMOR1				"MESH ARMOR"
#define TXT_ARMOR2				"FALCON SHIELD"
#define TXT_ARMOR3				"PLATINUM HELMET"
#define TXT_ARMOR4				"AMULET OF WARDING"

// Weapons

#define TXT_WEAPON_F2			"TIMON'S AXE"
#define TXT_WEAPON_F3			"HAMMER OF RETRIBUTION"
#define TXT_WEAPON_F4			"QUIETUS ASSEMBLED"
#define TXT_WEAPON_C2			"SERPENT STAFF"
#define TXT_WEAPON_C3			"FIRESTORM"
#define TXT_WEAPON_C4			"WRAITHVERGE ASSEMBLED"
#define TXT_WEAPON_M2			"FROST SHARDS"
#define TXT_WEAPON_M3			"ARC OF DEATH"
#define TXT_WEAPON_M4			"BLOODSCOURGE ASSEMBLED"
#define TXT_QUIETUS_PIECE		"SEGMENT OF QUIETUS"
#define TXT_WRAITHVERGE_PIECE	"SEGMENT OF WRAITHVERGE"
#define TXT_BLOODSCOURGE_PIECE	"SEGMENT OF BLOODSCOURGE"

#define BONUSADD 	6

void SetFighterAxe(player_t *player);
void P_HideSpecialThing(mobj_t *thing);
void SetDormantArtifact(mobj_t *arti);
void P_RemoveMobj(mobj_t *mobj);

float	ArmorMax[NUMCLASSES] = { 20.0, 18.0, 16.0, 1.0 };

int pieceValueTrans[] =
{
	0,							// 0: never
	WPIECE1|WPIECE2|WPIECE3,	// WPIECE1 (1)
	WPIECE2|WPIECE3,			// WPIECE2 (2)
	0,							// 3: never
	WPIECE3						// WPIECE3 (4)
};

//
//	Pickup messages
//
string fourthWeaponText[] =
{
	TXT_WEAPON_F4,
	TXT_WEAPON_C4,
	TXT_WEAPON_M4
};
string weaponPieceText[] =
{
	TXT_QUIETUS_PIECE,
	TXT_WRAITHVERGE_PIECE,
	TXT_BLOODSCOURGE_PIECE
};
string artifactMessages[NUMARTIFACTS] =
{
	"",
	TXT_ARTIINVULNERABILITY,
	TXT_ARTIHEALTH,
	TXT_ARTISUPERHEALTH,
	TXT_ARTIHEALINGRADIUS,
	TXT_ARTISUMMON,
	TXT_ARTITORCH,
	TXT_ARTIEGG,
	TXT_ARTIFLY,
	TXT_ARTIBLASTRADIUS,
	TXT_ARTIPOISONBAG,
	TXT_ARTITELEPORTOTHER,
	TXT_ARTISPEED,
	TXT_ARTIBOOSTMANA,
	TXT_ARTIBOOSTARMOR,
	TXT_ARTITELEPORT,

	TXT_ARTIPUZZSKULL,
	TXT_ARTIPUZZGEMBIG,
	TXT_ARTIPUZZGEMRED,
	TXT_ARTIPUZZGEMGREEN1,
	TXT_ARTIPUZZGEMGREEN2,
	TXT_ARTIPUZZGEMBLUE1,
	TXT_ARTIPUZZGEMBLUE2,
	TXT_ARTIPUZZBOOK1,
	TXT_ARTIPUZZBOOK2,
	TXT_ARTIPUZZSKULL2,
	TXT_ARTIPUZZFWEAPON,
	TXT_ARTIPUZZCWEAPON,
	TXT_ARTIPUZZMWEAPON,
	TXT_ARTIPUZZGEAR,	// All gear pickups use the same text
	TXT_ARTIPUZZGEAR,
	TXT_ARTIPUZZGEAR,
	TXT_ARTIPUZZGEAR
};

//==========================================================================
//
//	P_GiveMana
//
//	Returns true if the player accepted the mana, false if it was
// refused (player has MAX_MANA).
//
//==========================================================================

boolean P_GiveMana(player_t *player, int mana, int count)
{
	int 	prevMana;

	if (mana == MANA_NONE || mana == MANA_BOTH)
	{
		return false;
	}
	if (mana < 0 || mana > NUMMANA)
	{
//		I_Error("P_GiveMana: bad type %i", mana);
		Error("P_GiveMana: bad mana type");
	}
	if (player->mana[mana] == MAX_MANA)
	{
		return false;
	}
	if (gameskill == sk_baby || gameskill == sk_nightmare)
	{
		// extra mana in baby mode and nightmare mode
		count += count>>1;
	}
	prevMana = player->mana[mana];

	player->mana[mana] += count;
	if (player->mana[mana] > MAX_MANA)
	{
		player->mana[mana] = MAX_MANA;
	}
	if (player->pclass == PCLASS_FIGHTER && player->readyweapon == WP_SECOND
		&& mana == MANA_1 && prevMana <= 0)
	{
		SetFighterAxe(player);
	}
	return true;
}

//==========================================================================
//
// TryPickupWeapon
//
//==========================================================================

void TryPickupWeapon(player_t *player, int weaponClass,
					 int weaponType, mobj_t *weapon, string message)
{
	boolean		remove;
	boolean 	gaveMana;
	boolean 	gaveWeapon;

	remove = true;
	if (player->pclass != weaponClass)
	{
		// Wrong class, but try to pick up for mana
		if (netgame && !deathmatch)
		{
			// Can't pick up weapons for other classes in coop netplay
			return;
		}
		if (weaponType == WP_SECOND)
		{
			if (!P_GiveMana(player, MANA_1, 25))
			{
				return;
			}
		}
		else
		{
			if (!P_GiveMana(player, MANA_2, 25))
			{
				return;
			}
		}
	}
	else if (netgame && !deathmatch)
	{
		// Cooperative net-game
		if (player->weaponowned[weaponType])
		{
			return;
		}
		player->weaponowned[weaponType] = true;
		if (weaponType == WP_SECOND)
		{
			P_GiveMana(player, MANA_1, 25);
		}
		else
		{
			P_GiveMana(player, MANA_2, 25);
		}
		player->pendingweapon = weaponType;
		remove = false;
	}
	else
	{
		// Deathmatch or single player game
		if (weaponType == WP_SECOND)
		{
			gaveMana = P_GiveMana(player, MANA_1, 25);
		}
		else 
		{
			gaveMana = P_GiveMana(player, MANA_2, 25);
		}
		if (player->weaponowned[weaponType])
		{
			gaveWeapon = false;
		}
		else
		{
			gaveWeapon = true;
			player->weaponowned[weaponType] = true;
			if (weaponType > player->readyweapon)
			{
				// Only switch to more powerful weapons
				player->pendingweapon = weaponType;
			}
		}
		if (!gaveWeapon && !gaveMana)
		{
			// Player didn't need the weapon or any mana
			return;
		}
	}

	cprint(player, "%s\n", message);
	if (weapon->special)
	{
		ExecuteLineSpecial(weapon->special, &weapon->args[0],
			NULL, 0, player->mo);
		weapon->special = 0;
	}

	if (remove)
	{
		if (deathmatch && !(weapon->flags2&MF2_DROPPED))
		{
			P_HideSpecialThing(weapon);
		}
		else
		{
			P_RemoveMobj(weapon);
		}
	}

	player->bonuscount += BONUSADD;
	StartSoundName(player->mo, "PickupWeapon", CHAN_ITEM);
}

//==========================================================================
//
// TryPickupWeaponPiece
//
//==========================================================================

void TryPickupWeaponPiece(player_t *player, int matchClass,
							int pieceValue, mobj_t *pieceMobj)
{
	boolean 	remove;
	boolean 	checkAssembled;
	boolean 	gaveWeapon;
	int 		gaveMana;

	remove = true;
	checkAssembled = true;
	gaveWeapon = false;
	if (player->pclass != matchClass)
	{
		// Wrong class, but try to pick up for mana
		if (netgame && !deathmatch)
		{
			// Can't pick up wrong-class weapons in coop netplay
			return;
		}
		checkAssembled = false;
		gaveMana = P_GiveMana(player, MANA_1, 20)+
			P_GiveMana(player, MANA_2, 20);
		if (!gaveMana)
		{
			// Didn't need the mana, so don't pick it up
			return;
		}
	}
	else if (netgame && !deathmatch)
	{
		// Cooperative net-game
		if (player->pieces&pieceValue)
		{
			// Already has the piece
			return;
		}
		pieceValue = pieceValueTrans[pieceValue];
		P_GiveMana(player, MANA_1, 20);
		P_GiveMana(player, MANA_2, 20);
		remove = false;
	}
	else
	{
		// Deathmatch or single player game
		gaveMana = P_GiveMana(player, MANA_1, 20)+
			P_GiveMana(player, MANA_2, 20);
		if (player->pieces&pieceValue)
		{
			// Already has the piece, check if mana needed
			if (!gaveMana)
			{
				// Didn't need the mana, so don't pick it up
				return;
			}
			checkAssembled = false;
		}
	}

	// Pick up the weapon piece
	if (pieceMobj->special)
	{
		ExecuteLineSpecial(pieceMobj->special, &pieceMobj->args[0],
			NULL, 0, player->mo);
		pieceMobj->special = 0;
	}
	if (remove)
	{
		if (deathmatch && !(pieceMobj->flags2&MF2_DROPPED))
		{
			P_HideSpecialThing(pieceMobj);
		}
		else
		{
			P_RemoveMobj(pieceMobj);
		}
	}
	player->bonuscount += BONUSADD;

	// Check if fourth weapon assembled
	if (checkAssembled)
	{
		player->pieces |= pieceValue;
		if (player->pieces == (WPIECE1|WPIECE2|WPIECE3))
		{
			gaveWeapon = true;
			player->weaponowned[WP_FOURTH] = true;
			player->pendingweapon = WP_FOURTH;
		}
	}

	if (gaveWeapon)
	{
		cprint(player, "%s\n", fourthWeaponText[matchClass]);
		// Play the build-sound full volume for all players
		StartSoundName(NULL, "WeaponBuild", CHAN_ITEM);
	}
	else
	{
		cprint(player, "%s\n", weaponPieceText[matchClass]);
		StartSoundName(player->mo, "PickupWeapon", CHAN_ITEM);//FIXME must be PickupPiece
	}
}

//==========================================================================
//
//	P_GiveBody
//
//	Returns false if the body isn't needed at all.
//
//==========================================================================

boolean P_GiveBody(player_t *player, int num)
{
	int max;

	max = MAXHEALTH;
	if (player->morphTics)
	{
		max = MAXMORPHHEALTH;
	}
	if (player->health >= max)
	{
		return false;
	}
	player->health += num;
	if (player->health > max)
	{
		player->health = max;
	}
	player->mo->health = player->health;
	return true;
}

//==========================================================================
//
//	P_GiveArmor
//
//	Returns false if the armor is worse than the current armor.
//
//==========================================================================

boolean P_GiveArmor(player_t *player, int armortype, int amount)
{
	float 	hits;
	float 	totalArmor;

	if (amount == -1)
	{
		hits = ArmorIncrement[player->pclass * NUMARMOR + armortype];
		if (player->armorpoints[armortype] >= hits)
		{
			return false;
		}
		else
		{
			player->armorpoints[armortype] = hits;
		}
	}
	else
	{
		hits = itof(amount) * 5.0;
		totalArmor = player->armorpoints[ARMOR_ARMOR]
			+ player->armorpoints[ARMOR_SHIELD]
			+ player->armorpoints[ARMOR_HELMET]
			+ player->armorpoints[ARMOR_AMULET]
			+ AutoArmorSave[player->pclass];
		if (totalArmor < ArmorMax[player->pclass] * 5.0)
		{
			player->armorpoints[armortype] += hits;
		}
		else
		{
			return false;
		}
	}
	return true;
}

//==========================================================================
//
//	P_GiveKey
//
//==========================================================================

int P_GiveKey(player_t *player, int key)
{
	if (player->keys & (1 << key))
	{
		return false;
	}
	player->bonuscount += BONUSADD;
	player->keys |= 1 << key;
	return true;
}

//==========================================================================
//
//	P_GivePower
//
//	Returns true if power accepted.
//
//==========================================================================

boolean P_GivePower(player_t *player, int power)
{
	if (power == pw_invulnerability)
	{
		if (player->powers[power] > ftoi(BLINKTHRESHOLD * 35.0))
		{
			// Already have it
			return false;
		}
		player->powers[power] = ftoi(INVULNTIME * 35.0);
		player->mo->flags2 |= MF2_INVULNERABLE;
		if (player->pclass == PCLASS_MAGE)
		{
			player->mo->flags2 |= MF2_REFLECTIVE;
		}
		return true;
	}
	if (power == pw_flight)
	{
		if (player->powers[power] > ftoi(BLINKTHRESHOLD * 35.0))
		{
			// Already have it
			return false;
		}
		player->powers[power] = ftoi(FLIGHTTIME * 35.0);
		player->mo->flags2 |= MF2_FLY;
		player->mo->flags |= MF_NOGRAVITY;
		if (player->mo->origin.z <= player->mo->floorz)
		{
			player->flyheight = 10; // thrust the player in the air a bit
		}
		return(true);
	}
	if (power == pw_infrared)
	{
		if (player->powers[power] > ftoi(BLINKTHRESHOLD * 35.0))
		{
			// Already have it
			return false;
		}
		player->powers[power] = ftoi(INFRATIME * 35.0);
		return true;
	}
	if (power == pw_speed)
	{
		if (player->powers[power] > ftoi(BLINKTHRESHOLD * 35.0))
		{
			// Already have it
			return false;
		}
		player->powers[power] = ftoi(SPEEDTIME * 35.0);
		return true;
	}
	if (power == pw_minotaur)
	{
		// Doesn't matter if already have power, renew ticker
		player->powers[power] = ftoi(MAULATORTIME * 35.0);
		return true;
	}
	if (player->powers[power])
	{
		return false; // already got it
	}
	player->powers[power] = 1;
	return true;
}

//==========================================================================
//
//	P_GiveArtifact
//
//	Returns true if artifact accepted.
//
//==========================================================================

boolean P_GiveArtifact(player_t *player, int arti, mobj_t *mo)
{
	int 		i;
	int 		j;
	boolean 	slidePointer;

	slidePointer = false;
	i = 0;
	while (player->inventory[i].type != arti && i < player->inventorySlotNum)
	{
		i++;
	}
	if (i == player->inventorySlotNum)
	{
		if (arti < arti_firstpuzzitem)
		{
			i = 0;
			while (player->inventory[i].type < arti_firstpuzzitem
				&& i < player->inventorySlotNum)
			{
				i++;
			}
			if (i != player->inventorySlotNum)
			{
				for (j = player->inventorySlotNum; j > i; j--)
				{
					player->inventory[j].count = player->inventory[j-1].count;
					player->inventory[j].type = player->inventory[j-1].type;
					slidePointer = true;
				}
			}
		}
		player->inventory[i].count = 1;
		player->inventory[i].type = arti;
		player->inventorySlotNum++;
	}
	else
	{
		if (arti >= arti_firstpuzzitem && netgame && !deathmatch)
		{
			// Can't carry more than 1 puzzle item in coop netplay
			return false;
		}
		if (player->inventory[i].count >= 25)
		{
			// Player already has 25 of this item
			return false;
		}
		player->inventory[i].count++;
	}
	if (!player->artifactCount)
	{
		player->readyArtifact = arti;
	}
	else if (slidePointer && i <= player->inv_ptr)
	{
		player->inv_ptr++;
		player->curpos++;
		if (player->curpos > 6)
		{
			player->curpos = 6;
		}
	}
	player->artifactCount++;
	return true;
}

//==========================================================================
//
// TryPickupArtifact
//
//==========================================================================

void TryPickupArtifact(player_t *player, int artifactType, mobj_t *artifact)
{
	if (P_GiveArtifact(player, artifactType, artifact))
	{
		if (artifact->special)
		{
			ExecuteLineSpecial(artifact->special, &artifact->args[0],
				NULL, 0, NULL);
			artifact->special = 0;
		}
		player->bonuscount += BONUSADD;
		if (artifactType < arti_firstpuzzitem)
		{
			SetDormantArtifact(artifact);
			StartSoundName(artifact, "PickupArtifact", CHAN_ITEM);
			cprint(player, "%s\n", artifactMessages[artifactType]);
		}
		else
		{
			// Puzzle item
			StartSoundName(NULL, "PickupItem", CHAN_ITEM);
			cprint(player, "%s\n", artifactMessages[artifactType]);
			if (!netgame || deathmatch)
			{
				// Remove puzzle items if not cooperative netplay
				P_RemoveMobj(artifact);
			}
		}
	}
}

//==========================================================================
//
//	P_TouchSpecialThing
//
//==========================================================================

void P_TouchSpecialThing(mobj_t *special, mobj_t *toucher)
{
	player_t	*player;
	float	 	delta;
	string		sound;
	boolean 	respawn;

	delta = special->origin.z - toucher->origin.z;
	if (delta > toucher->height || delta < -32.0)
	{
		// Out of reach
		return;
	}
	if (toucher->health <= 0)
	{
		// Toucher is dead
		return;
	}
	sound = "PickupItem";
	player = toucher->player;
	respawn = true;
	switch (special->sprite)
	{
		// Items
		case SPR_PTN1: // Item_HealingPotion
			if (!P_GiveBody(player, 10))
			{
				return;
			}
			cprint(player, "%s\n", TXT_ITEMHEALTH);
			break;
		case SPR_ARM1:
			if (!P_GiveArmor(player, ARMOR_ARMOR, -1))
			{
				return;
			}
			cprint(player, "%s\n", TXT_ARMOR1);
			break;
		case SPR_ARM2:
			if (!P_GiveArmor(player, ARMOR_SHIELD, -1))
			{
				return;
			}
			cprint(player, "%s\n", TXT_ARMOR2);
			break;
		case SPR_ARM3:
			if (!P_GiveArmor(player, ARMOR_HELMET, -1))
			{
				return;
			}
			cprint(player, "%s\n", TXT_ARMOR3);
			break;
		case SPR_ARM4:
			if (!P_GiveArmor(player, ARMOR_AMULET, -1))
			{
				return;
			}
			cprint(player, "%s\n", TXT_ARMOR4);
			break;

		// Keys
		case SPR_KEY1:
		case SPR_KEY2:
		case SPR_KEY3:
		case SPR_KEY4:
		case SPR_KEY5:
		case SPR_KEY6:
		case SPR_KEY7:
		case SPR_KEY8:
		case SPR_KEY9:
		case SPR_KEYA:
		case SPR_KEYB:
			if (!P_GiveKey(player, special->sprite - SPR_KEY1))
			{
				return;
			}
			cprint(player, "%s\n", TextKeyMessages[special->sprite - SPR_KEY1]);
			sound = "PickupKey";

			// Check and process the special now in case the key doesn't
			// get removed for coop netplay
			if (special->special)
			{
				ExecuteLineSpecial(special->special, &special->args[0],
					NULL, 0, toucher);
				special->special = 0;
			}

			if (!netgame)
			{
				// Only remove keys in single player game
				break;
			}
			player->bonuscount += BONUSADD;
			StartSoundName(player->mo, sound, CHAN_ITEM);
			return;

		// Artifacts
		case SPR_PTN2:
			TryPickupArtifact(player, arti_health, special);
			return;
		case SPR_SOAR:
			TryPickupArtifact(player, arti_fly, special);
			return;
		case SPR_INVU:
			TryPickupArtifact(player, arti_invulnerability, special);
			return;
		case SPR_SUMN:
			TryPickupArtifact(player, arti_summon, special);
			return;
		case SPR_PORK:
			TryPickupArtifact(player, arti_egg, special);
			return;
		case SPR_SPHL:
			TryPickupArtifact(player, arti_superhealth, special);
			return;
		case SPR_HRAD:
			TryPickupArtifact(player, arti_healingradius, special);
			return;
		case SPR_TRCH:
			TryPickupArtifact(player, arti_torch, special);
			return;
		case SPR_ATLP:
			TryPickupArtifact(player, arti_teleport, special);
			return;
		case SPR_TELO:
			TryPickupArtifact(player, arti_teleportother, special);
			return;
		case SPR_PSBG:
			TryPickupArtifact(player, arti_poisonbag, special);
			return;
		case SPR_SPED:
			TryPickupArtifact(player, arti_speed, special);
			return;
		case SPR_BMAN:
			TryPickupArtifact(player, arti_boostmana, special);
			return;
		case SPR_BRAC:
			TryPickupArtifact(player, arti_boostarmor, special);
			return;
		case SPR_BLST:
			TryPickupArtifact(player, arti_blastradius, special);
			return;

		// Puzzle artifacts
		case SPR_ASKU:
			TryPickupArtifact(player, arti_puzzskull, special);
			return;
		case SPR_ABGM:
			TryPickupArtifact(player, arti_puzzgembig, special);
			return;
		case SPR_AGMR:
			TryPickupArtifact(player, arti_puzzgemred, special);
			return;
		case SPR_AGMG:
			TryPickupArtifact(player, arti_puzzgemgreen1, special);
			return;
		case SPR_AGG2:
			TryPickupArtifact(player, arti_puzzgemgreen2, special);
			return;
		case SPR_AGMB:
			TryPickupArtifact(player, arti_puzzgemblue1, special);
			return;
		case SPR_AGB2:
			TryPickupArtifact(player, arti_puzzgemblue2, special);
			return;
		case SPR_ABK1:
			TryPickupArtifact(player, arti_puzzbook1, special);
			return;
		case SPR_ABK2:
			TryPickupArtifact(player, arti_puzzbook2, special);
			return;
		case SPR_ASK2:
			TryPickupArtifact(player, arti_puzzskull2, special);
			return;
		case SPR_AFWP:
			TryPickupArtifact(player, arti_puzzfweapon, special);
			return;
		case SPR_ACWP:
			TryPickupArtifact(player, arti_puzzcweapon, special);
			return;
		case SPR_AMWP:
			TryPickupArtifact(player, arti_puzzmweapon, special);
			return;
		case SPR_AGER:
			TryPickupArtifact(player, arti_puzzgear1, special);
			return;
		case SPR_AGR2:
			TryPickupArtifact(player, arti_puzzgear2, special);
			return;
		case SPR_AGR3:
			TryPickupArtifact(player, arti_puzzgear3, special);
			return;
		case SPR_AGR4:
			TryPickupArtifact(player, arti_puzzgear4, special);
			return;

		// Mana
		case SPR_MAN1:
			if (!P_GiveMana(player, MANA_1, 15))
			{
				return;
			}
			cprint(player, "%s\n", TXT_MANA_1);
			break;
		case SPR_MAN2: 
			if (!P_GiveMana(player, MANA_2, 15))
			{
				return;
			}
			cprint(player, "%s\n", TXT_MANA_2);
			break;
		case SPR_MAN3: // Double Mana Dodecahedron
			if (!P_GiveMana(player, MANA_1, 20))
			{
				if (!P_GiveMana(player, MANA_2, 20))
				{
					return;
				}
			}
			else
			{
				P_GiveMana(player, MANA_2, 20);
			}
			cprint(player, "%s\n", TXT_MANA_BOTH);
			break;

		// 2nd and 3rd Mage Weapons
		case SPR_WMCS: // Frost Shards
			TryPickupWeapon(player, PCLASS_MAGE, WP_SECOND,
				special, TXT_WEAPON_M2);
			return;
		case SPR_WMLG: // Arc of Death
			TryPickupWeapon(player, PCLASS_MAGE, WP_THIRD,
				special, TXT_WEAPON_M3);
			return;

		// 2nd and 3rd Fighter Weapons
		case SPR_WFAX: // Timon's Axe
			TryPickupWeapon(player, PCLASS_FIGHTER, WP_SECOND,
				special, TXT_WEAPON_F2);
			return;
		case SPR_WFHM: // Hammer of Retribution
			TryPickupWeapon(player, PCLASS_FIGHTER, WP_THIRD,
				special, TXT_WEAPON_F3);
			return;

		// 2nd and 3rd Cleric Weapons
		case SPR_WCSS: // Serpent Staff
			TryPickupWeapon(player, PCLASS_CLERIC, WP_SECOND,
				special, TXT_WEAPON_C2);
			return;
		case SPR_WCFM: // Firestorm
			TryPickupWeapon(player, PCLASS_CLERIC, WP_THIRD,
				special, TXT_WEAPON_C3);
			return;

		// Fourth Weapon Pieces
		case SPR_WFR1:
			TryPickupWeaponPiece(player, PCLASS_FIGHTER, WPIECE1,
				special);
			return;
		case SPR_WFR2:
			TryPickupWeaponPiece(player, PCLASS_FIGHTER, WPIECE2,
				special);
			return;
		case SPR_WFR3:
			TryPickupWeaponPiece(player, PCLASS_FIGHTER, WPIECE3,
				special);
			return;
		case SPR_WCH1:
			TryPickupWeaponPiece(player, PCLASS_CLERIC, WPIECE1,
				special);
			return;
		case SPR_WCH2:
			TryPickupWeaponPiece(player, PCLASS_CLERIC, WPIECE2,
				special);
			return;
		case SPR_WCH3:
			TryPickupWeaponPiece(player, PCLASS_CLERIC, WPIECE3,
				special);
			return;
		case SPR_WMS1:
			TryPickupWeaponPiece(player, PCLASS_MAGE, WPIECE1,
				special);
			return;
		case SPR_WMS2:
			TryPickupWeaponPiece(player, PCLASS_MAGE, WPIECE2,
				special);
			return;
		case SPR_WMS3:
			TryPickupWeaponPiece(player, PCLASS_MAGE, WPIECE3,
				special);
			return;

		default:
			Error("P_TouchSpecialThing: Unknown gettable thing");
	}
	if (special->special)
	{
		ExecuteLineSpecial(special->special, &special->args[0], NULL,
			0, toucher);
		special->special = 0;
	}
	if (deathmatch && respawn && !(special->flags2&MF2_DROPPED))
	{
		P_HideSpecialThing(special);
	}
	else
	{
		P_RemoveMobj(special);
	}
	player->bonuscount += BONUSADD;
	StartSoundName(player->mo, sound, CHAN_ITEM);
}

//**************************************************************************
//
//	$Log$
//	Revision 1.3  2001/08/29 17:42:13  dj_jl
//	Added sound channel
//
//	Revision 1.2  2001/07/27 14:27:52  dj_jl
//	Update with Id-s and Log-s, some fixes
//
//**************************************************************************
