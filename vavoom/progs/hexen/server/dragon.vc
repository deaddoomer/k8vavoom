//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//============================================================================
//
// DragonSeek
//
//============================================================================

void DragonSeek(mobj_t * actor, float thresh, float turnMax)
{
	int dir;
	float dist;
	float delta;
	mobj_t *target;
	int search;
	int i;
	int bestArg;
	float bestAngle;
	float angleToSpot, angleToTarget;
	mobj_t *mo;
	mobj_t *oldTarget;

	target = actor->specialmobj1;
	if (!target)
	{
		return;
	}
	dir = P_FaceMobj(actor, target, &delta);
	if (delta > thresh)
	{
		delta /= 2.0;
		if (delta > turnMax)
		{
			delta = turnMax;
		}
	}
	if (dir)
	{
		// Turn clockwise
		actor->angles.yaw = AngleMod360(actor->angles.yaw + delta);
	}
	else
	{
		// Turn counter clockwise
		actor->angles.yaw = AngleMod360(actor->angles.yaw - delta);
	}
	actor->velocity.x = actor->speed * cos(actor->angles.yaw);
	actor->velocity.y = actor->speed * sin(actor->angles.yaw);
	if (actor->origin.z + actor->height < target->origin.z ||
		target->origin.z + target->height < actor->origin.z)
	{
		dist = MobjDist2(target, actor);
		dist = dist / actor->speed;
		if (dist < 1.0)
		{
			dist = 1.0;
		}
		actor->velocity.z = (target->origin.z - actor->origin.z) / dist;
	}
	else
	{
		dist = MobjDist2(target, actor);
		dist = dist / actor->speed;
	}
	if (target->flags & MF_SHOOTABLE && P_Random() < 64)
	{
		// attack the destination mobj if it's attackable
		if (fabs(AngleMod180(actor->angles.yaw -
			atan2(target->origin.y - actor->origin.y,
			target->origin.x - actor->origin.x))) < 45.0 / 2.0)
		{
			oldTarget = actor->target;
			actor->target = target;
			if (CheckMeleeRange(actor))
			{
				actor->target->Damage(actor, actor, HITDICE(10));
				StartSoundName(actor, 'DragonAttack', CHAN_WEAPON);
			}
			else if (P_Random() < 128 && CheckMissileRange(actor))
			{
				SpawnMissile(actor, target, MT_DRAGON_FX);
				StartSoundName(actor, 'DragonAttack', CHAN_WEAPON);
			}
			actor->target = oldTarget;
		}
	}
	if (dist * 35.0 < 4.0)
	{	// Hit the target thing
		if (actor->target && P_Random() < 200)
		{
			bestArg = -1;
			bestAngle = 360.0;
			angleToTarget = atan2(actor->target->origin.y - actor->origin.y,
				actor->target->origin.x - actor->origin.x);
			for (i = 0; i < 5; i++)
			{
				if (!target->args[i])
				{
					continue;
				}
				search = -1;
				mo = P_FindMobjFromTID(target->args[i], &search);
				angleToSpot = atan2(mo->origin.y - actor->origin.y,
					mo->origin.x - actor->origin.x);
				delta = fabs(AngleMod180(angleToSpot - angleToTarget));
				if (delta < bestAngle)
				{
					bestAngle = delta;
					bestArg = i;
				}
			}
			if (bestArg != -1)
			{
				search = -1;
				actor->specialmobj1 = P_FindMobjFromTID(target->args[bestArg],
					&search);
			}
		}
		else
		{
			do
			{
				i = (P_Random() >> 2) % 5;
			}
			while (!target->args[i]);
			search = -1;
			actor->specialmobj1 = P_FindMobjFromTID(target->args[i], &search);
		}
	}
}

//============================================================================
//
//	Actor::A_DragonInitFlight
//
//============================================================================

void Actor::A_DragonInitFlight(void)
{
	int search;

	search = -1;
	do
	{
		// find the first tid identical to the dragon's tid
		specialmobj1 = P_FindMobjFromTID(tid, &search);
		if (search == -1)
		{
			SetMobjState(this, spawnstate);
			return;
		}
	}
	while (specialmobj1 == this);
	P_RemoveMobjFromTIDList(this);
}

//============================================================================
//
//	Actor::A_DragonFlight
//
//============================================================================

void Actor::A_DragonFlight(void)
{
	float angle;

	DragonSeek(this, 4.0, 8.0);
	if (target)
	{
		if (!(target->flags & MF_SHOOTABLE))
		{
			// target died
			target = NULL;
			return;
		}
		angle = atan2(target->origin.y - origin.y,
			target->origin.x - origin.x);
		if (fabs(AngleMod180(angles.yaw - angle)) < 45.0 / 2.0
			&& CheckMeleeRange(this))
		{
			target->Damage(this, this, HITDICE(8));
			StartSoundName(this, 'DragonAttack', CHAN_WEAPON);
		}
		else if (fabs(AngleMod180(angles.yaw - angle)) <= 20.0)
		{
			SetMobjState(this, missilestate);
			StartSoundName(this, 'DragonAttack', CHAN_WEAPON);
		}
	}
	else
	{
		P_LookForPlayers(this, true);
	}
}

//============================================================================
//
//	Actor::A_DragonFlap
//
//============================================================================

void Actor::A_DragonFlap(void)
{
	A_DragonFlight();
	if (P_Random() < 240)
	{
		StartSoundName(this, 'DragonWingflap', CHAN_BODY);
	}
	else
	{
		StartSound(this, sound_active, CHAN_VOICE);
	}
}

//============================================================================
//
//	Actor::A_DragonAttack
//
//============================================================================

void Actor::A_DragonAttack(void)
{
	SpawnMissile(this, target, MT_DRAGON_FX);
}

//============================================================================
//
//  Actor::A_DragonPain
//
//============================================================================

void Actor::A_DragonPain(void)
{
	A_Pain();
	if (!specialmobj1)
	{
		// no destination spot yet
		SetMobjState(this, S_DRAGON_INIT);
	}
}

//============================================================================
//
//	Actor::A_DragonCheckCrash
//
//============================================================================

void Actor::A_DragonCheckCrash(void)
{
	if (origin.z <= floorz)
	{
		SetMobjState(this, S_DRAGON_CRASH1);
	}
}

//============================================================================
//
//	Actor::A_DragonFX2
//
//============================================================================

void Actor::A_DragonFX2(void)
{
	mobj_t *mo;
	int i;
	float delay;

	delay = 0.5 + Random();
	for (i = 1 + (P_Random() & 3); i; i--)
	{
		mo = P_SpawnMobj(origin.x + (Random() - 0.5) * 64.0,
			origin.y + (Random() - 0.5) * 64.0,
			origin.z + (Random() - 0.5) * 16.0, MT_DRAGON_FX2);
		if (mo)
		{
			mo->time = delay + Random() * 0.2 * itof(i);
			mo->target = target;
		}
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.9  2002/01/11 18:19:42  dj_jl
//  Started to use names in progs
//
//  Revision 1.8  2002/01/07 12:25:57  dj_jl
//  Changed copyright year
//
//  Revision 1.7  2001/12/12 18:57:42  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.6  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.5  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/30 17:33:17  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
