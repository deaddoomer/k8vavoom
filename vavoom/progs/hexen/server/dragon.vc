//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//============================================================================
//
//	Actor::DragonSeek
//
//============================================================================

void Actor::DragonSeek(float thresh, float turnMax)
{
	int dir;
	float dist;
	float delta;
	mobj_t *tempTarget;
	int search;
	int i;
	int bestArg;
	float bestAngle;
	float angleToSpot, angleToTarget;
	mobj_t *mo;
	mobj_t *oldTarget;

	tempTarget = specialmobj1;
	if (!tempTarget)
	{
		return;
	}
	dir = P_FaceMobj(this, tempTarget, &delta);
	if (delta > thresh)
	{
		delta /= 2.0;
		if (delta > turnMax)
		{
			delta = turnMax;
		}
	}
	if (dir)
	{
		// Turn clockwise
		angles.yaw = AngleMod360(angles.yaw + delta);
	}
	else
	{
		// Turn counter clockwise
		angles.yaw = AngleMod360(angles.yaw - delta);
	}
	velocity.x = Speed * cos(angles.yaw);
	velocity.y = Speed * sin(angles.yaw);
	if (origin.z + Height < tempTarget->origin.z ||
		tempTarget->origin.z + tempTarget->Height < origin.z)
	{
		dist = MobjDist2(tempTarget, this);
		dist = dist / Speed;
		if (dist < 1.0)
		{
			dist = 1.0;
		}
		velocity.z = (tempTarget->origin.z - origin.z) / dist;
	}
	else
	{
		dist = MobjDist2(tempTarget, this);
		dist = dist / Speed;
	}
	if (tempTarget->Flags & MF_SHOOTABLE && P_Random() < 64)
	{
		// attack the destination mobj if it's attackable
		if (fabs(AngleMod180(angles.yaw -
			atan2(tempTarget->origin.y - origin.y,
			tempTarget->origin.x - origin.x))) < 45.0 / 2.0)
		{
			oldTarget = target;
			target = tempTarget;
			if (CheckMeleeRange())
			{
				target->Damage(self, self, HITDICE(10));
				StartSoundName(this, 'DragonAttack', CHAN_WEAPON);
			}
			else if (P_Random() < 128 && CheckMissileRange())
			{
				SpawnMissile(this, tempTarget, DragonMissile);
				StartSoundName(this, 'DragonAttack', CHAN_WEAPON);
			}
			target = oldTarget;
		}
	}
	if (dist * 35.0 < 4.0)
	{
		// Hit the target thing
		if (target && P_Random() < 200)
		{
			bestArg = -1;
			bestAngle = 360.0;
			angleToTarget = atan2(target->origin.y - origin.y,
				target->origin.x - origin.x);
			for (i = 0; i < 5; i++)
			{
				if (!tempTarget->args[i])
				{
					continue;
				}
				search = -1;
				mo = P_FindMobjFromTID(tempTarget->args[i], &search);
				angleToSpot = atan2(mo->origin.y - origin.y,
					mo->origin.x - origin.x);
				delta = fabs(AngleMod180(angleToSpot - angleToTarget));
				if (delta < bestAngle)
				{
					bestAngle = delta;
					bestArg = i;
				}
			}
			if (bestArg != -1)
			{
				search = -1;
				specialmobj1 = P_FindMobjFromTID(tempTarget->args[bestArg],
					&search);
			}
		}
		else
		{
			do
			{
				i = (P_Random() >> 2) % 5;
			}
			while (!tempTarget->args[i]);
			search = -1;
			specialmobj1 = P_FindMobjFromTID(tempTarget->args[i], &search);
		}
	}
}

//============================================================================
//
//	Actor::A_DragonInitFlight
//
//============================================================================

void Actor::A_DragonInitFlight(void)
{
	int search;

	search = -1;
	do
	{
		// find the first tid identical to the dragon's tid
		specialmobj1 = P_FindMobjFromTID(tid, &search);
		if (search == -1)
		{
			SetState(SpawnState);
			return;
		}
	}
	while (specialmobj1 == this);
	P_RemoveMobjFromTIDList(this);
}

//============================================================================
//
//	Actor::A_DragonFlight
//
//============================================================================

void Actor::A_DragonFlight(void)
{
	float angle;

	DragonSeek(4.0, 8.0);
	if (target)
	{
		if (!(target->Flags & MF_SHOOTABLE))
		{
			// target died
			target = NULL;
			return;
		}
		angle = atan2(target->origin.y - origin.y,
			target->origin.x - origin.x);
		if (fabs(AngleMod180(angles.yaw - angle)) < 45.0 / 2.0
			&& CheckMeleeRange())
		{
			target->Damage(self, self, HITDICE(8));
			StartSoundName(this, 'DragonAttack', CHAN_WEAPON);
		}
		else if (fabs(AngleMod180(angles.yaw - angle)) <= 20.0)
		{
			SetState(MissileState);
			StartSoundName(this, 'DragonAttack', CHAN_WEAPON);
		}
	}
	else
	{
		LookForPlayers(true);
	}
}

//============================================================================
//
//	Actor::A_DragonFlap
//
//============================================================================

void Actor::A_DragonFlap(void)
{
	A_DragonFlight();
	if (P_Random() < 240)
	{
		StartSoundName(this, 'DragonWingflap', CHAN_BODY);
	}
	else
	{
		StartSound(this, sound_active, CHAN_VOICE);
	}
}

//============================================================================
//
//	Actor::A_DragonAttack
//
//============================================================================

void Actor::A_DragonAttack(void)
{
	SpawnMissile(this, target, DragonMissile);
}

//============================================================================
//
//  Actor::A_DragonPain
//
//============================================================================

void Actor::A_DragonPain(void)
{
	A_Pain();
	if (!specialmobj1)
	{
		// no destination spot yet
		SetState(S_DRAGON_INIT);
	}
}

//============================================================================
//
//	Actor::A_DragonCheckCrash
//
//============================================================================

void Actor::A_DragonCheckCrash(void)
{
	if (origin.z <= floorz)
	{
		SetState(S_DRAGON_CRASH1);
	}
}

//============================================================================
//
//	Actor::A_DragonFX2
//
//============================================================================

void Actor::A_DragonFX2(void)
{
	mobj_t *mo;
	int i;
	float delay;

	delay = 0.5 + Random();
	for (i = 1 + (P_Random() & 3); i; i--)
	{
		mo = P_SpawnMobj(origin.x + (Random() - 0.5) * 64.0,
			origin.y + (Random() - 0.5) * 64.0,
			origin.z + (Random() - 0.5) * 16.0, DragonFX2);
		if (mo)
		{
			mo->time = delay + Random() * 0.2 * itof(i);
			mo->target = target;
		}
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.13  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.12  2002/01/24 18:19:26  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.11  2002/01/17 18:15:54  dj_jl
//  Renamed all map object classes
//
//  Revision 1.10  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.9  2002/01/11 18:19:42  dj_jl
//  Started to use names in progs
//
//  Revision 1.8  2002/01/07 12:25:57  dj_jl
//  Changed copyright year
//
//  Revision 1.7  2001/12/12 18:57:42  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.6  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.5  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/30 17:33:17  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
