//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// ===== Polyobj Event Code =====

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

enum
{
	PODOOR_NONE,
	PODOOR_SLIDE,
	PODOOR_SWING
};

// TYPES -------------------------------------------------------------------

class PolyobjThinker:Thinker
{
	float thrust_force;
};

class TRotatePoly:PolyobjThinker
{
	int polyobj;
	int rot_dist;
	angle_t rot_speed;//FIXME

	void Think(void);
};

class TMovePoly:PolyobjThinker
{
	float speed;
	int polyobj;
	float dist;
	angle_t angle;
	float xSpeed;	// for sliding walls
	float ySpeed;

	void Think(void);
};

class TPolyDoor:PolyobjThinker
{
	int type;
	float speed;
	int polyobj;
	float dist;
	int rot_dist;
	angle_t rot_speed;
	float xSpeed;	// for sliding walls
	float ySpeed;
	float totalDist;
	int rot_totalDist;
	int tics;
	int waitTics;
	boolean close;

	void Think(void);
};

addfields polyobj_t
{
	PolyobjThinker *specialdata;	// pointer a thinker, if the poly is moving
};

// FUNCTION PROTOTYPES -----------------------------------------------------

void DamageMobj(mobj_t * target, mobj_t * inflictor, mobj_t * source,
	int damage);
boolean P_CheckPosition(mobj_t * thing, float x, float y);

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//	TRotatePoly::Think
//
//==========================================================================

void TRotatePoly::Think(void)
{
	int absSpeed;
	polyobj_t *poly;

	if (PO_RotatePolyobj(polyobj, rot_speed))
	{
		absSpeed = abs(rot_speed);

		if (rot_dist == -1)
		{
			// perpetual polyobj
			return;
		}
		rot_dist -= absSpeed;
		if (rot_dist <= 0)
		{
			poly = GetPolyobj(polyobj);
			if (poly->specialdata == this)
			{
				poly->specialdata = NULL;
			}
			PolyobjStopSequence(poly);
			PolyobjFinished(poly->tag);
			RemoveSpecialThinker(this);
			return;
		}
		if (rot_dist < absSpeed)
		{
			rot_speed = rot_dist * (rot_speed < 0 ? -1 : 1);
		}
	}
}

//==========================================================================
//
//  EV_RotatePoly
//
//==========================================================================

boolean EV_RotatePoly(line_t * line, int *args, int direction, boolean
	overRide)
{
	int mirror;
	int polyNum;
	TRotatePoly *pe;
	polyobj_t *poly;

	polyNum = args[0];
	if ((poly = GetPolyobj(polyNum)))
	{
		if (poly->specialdata && !overRide)
		{	// poly is already moving
			return false;
		}
	}
	else
	{
		Error("EV_RotatePoly:  Invalid polyobj num");	//: %d\n", polyNum);
	}
	pe = NewSpecialThinker(TRotatePoly);
	pe->polyobj = polyNum;
	if (args[2])
	{
		if (args[2] == 255)
		{
			pe->rot_dist = -1;
		}
		else
		{
			pe->rot_dist = args[2] * (ANG90 / 64);	// Angle
		}
	}
	else
	{
		pe->rot_dist = ANGLE_MAX - 1;
	}
	pe->rot_speed = (args[1] * direction * (ANG90 / 64)) >> 3;

	//THRUST
	pe->thrust_force = itof(pe->rot_speed) / 256.0 / 65536.0;

	poly->specialdata = pe;
	PolyobjStartSequence(poly, seq_name[SEQ_DOOR_STONE + poly->seqType]);

	while ((mirror = GetPolyobjMirror(polyNum)))
	{
		poly = GetPolyobj(mirror);
		if (poly && poly->specialdata && !overRide)
		{	// mirroring poly is already in motion
			break;
		}
		pe = NewSpecialThinker(TRotatePoly);
		poly->specialdata = pe;
		pe->polyobj = mirror;
		if (args[2])
		{
			if (args[2] == 255)
			{
				pe->rot_dist = -1;
			}
			else
			{
				pe->rot_dist = args[2] * (ANG90 / 64);	// Angle
			}
		}
		else
		{
			pe->rot_dist = ANGLE_MAX - 1;
		}
		if ((poly = GetPolyobj(polyNum)))
		{
			poly->specialdata = pe;
		}
		else
		{
			Error("EV_RotatePoly:  Invalid polyobj num");	//: %d\n", polyNum);
		}
		direction = -direction;
		pe->rot_speed = (args[1] * direction * (ANG90 / 64)) >> 3;

		//THRUST
		pe->thrust_force = itof(pe->rot_speed) / 256.0 / 65536.0;

		polyNum = mirror;
		PolyobjStartSequence(poly, seq_name[SEQ_DOOR_STONE + poly->seqType]);
	}
	return true;
}

//==========================================================================
//
//	TMovePoly::Think
//
//==========================================================================

void TMovePoly::Think(void)
{
	float absSpeed;
	polyobj_t *poly;

	if (PO_MovePolyobj(polyobj, xSpeed, ySpeed))
	{
		absSpeed = fabs(speed);
		dist -= absSpeed;
		if (dist <= 0.0)
		{
			poly = GetPolyobj(polyobj);
			if (poly->specialdata == this)
			{
				poly->specialdata = NULL;
			}
			PolyobjStopSequence(poly);
			PolyobjFinished(poly->tag);
			RemoveSpecialThinker(this);
			return;
		}
		if (dist < absSpeed)
		{
			speed = dist * (speed < 0.0 ? -1.0 : 1.0);
			xSpeed = speed * cos(angle);
			ySpeed = speed * sin(angle);
		}
	}
}

//==========================================================================
//
// EV_MovePoly
//
//==========================================================================

boolean EV_MovePoly(line_t * line, int *args, boolean timesEight, boolean
	overRide)
{
	int mirror;
	int polyNum;
	TMovePoly *pe;
	polyobj_t *poly;
	angle_t an;

	polyNum = args[0];
	if ((poly = GetPolyobj(polyNum)))
	{
		if (poly->specialdata && !overRide)
		{	// poly is already moving
			return false;
		}
	}
	else
	{
		Error("EV_MovePoly:  Invalid polyobj num");	//: %d\n", polyNum);
	}
	pe = NewSpecialThinker(TMovePoly);
	pe->polyobj = polyNum;
	if (timesEight)
	{
		pe->dist = itof(args[3]) * 8.0;
	}
	else
	{
		pe->dist = itof(args[3]);	// Distance
	}
	pe->speed = itof(args[1]) / 8.0;

	//THRUST
	pe->thrust_force = pe->speed / 8.0;

	poly->specialdata = pe;

	an = args[2] * (ANG90 / 64);

	pe->angle = an;
	pe->xSpeed = pe->speed * cos(pe->angle);
	pe->ySpeed = pe->speed * sin(pe->angle);
	PolyobjStartSequence(poly, seq_name[SEQ_DOOR_STONE + poly->seqType]);

	while ((mirror = GetPolyobjMirror(polyNum)))
	{
		poly = GetPolyobj(mirror);
		if (poly && poly->specialdata && !overRide)
		{	// mirroring poly is already in motion
			break;
		}
		pe = NewSpecialThinker(TMovePoly);
		pe->polyobj = mirror;
		poly->specialdata = pe;
		if (timesEight)
		{
			pe->dist = itof(args[3]) * 8.0;
		}
		else
		{
			pe->dist = itof(args[3]);	// Distance
		}
		pe->speed = itof(args[1]) / 8.0;

		//THRUST
		pe->thrust_force = pe->speed / 8.0;

		an = an + ANG180;	// reverse the angle
		pe->angle = an;
		pe->xSpeed = pe->speed * cos(pe->angle);
		pe->ySpeed = pe->speed * sin(pe->angle);
		polyNum = mirror;
		PolyobjStartSequence(poly, seq_name[SEQ_DOOR_STONE + poly->seqType]);
	}
	return true;
}

//==========================================================================
//
//  TPolyDoor::Think
//
//==========================================================================

void TPolyDoor::Think(void)
{
	int absSpeed;
	float fabsSpeed;
	polyobj_t *poly;

	if (tics)
	{
		if (!--tics)
		{
			poly = GetPolyobj(polyobj);
			PolyobjStartSequence(poly,
				seq_name[SEQ_DOOR_STONE + poly->seqType]);
		}
		return;
	}
	switch (type)
	{
	case PODOOR_SLIDE:
		if (PO_MovePolyobj(polyobj, xSpeed, ySpeed))
		{
			fabsSpeed = fabs(speed);
			dist -= fabsSpeed;
			if (dist <= 0.0)
			{
				poly = GetPolyobj(polyobj);
				PolyobjStopSequence(poly);
				if (!close)
				{
					dist = totalDist;
					close = true;
					tics = waitTics;
					xSpeed = -xSpeed;
					ySpeed = -ySpeed;
				}
				else
				{
					if (poly->specialdata == this)
					{
						poly->specialdata = NULL;
					}
					PolyobjFinished(poly->tag);
					RemoveSpecialThinker(this);
				}
			}
		}
		else
		{
			poly = GetPolyobj(polyobj);
			if (poly->crush || !close)
			{	// continue moving if the poly is a crusher, or is opening
				return;
			}
			else
			{	// open back up
				dist = totalDist - dist;
				xSpeed = -xSpeed;
				ySpeed = -ySpeed;
				close = false;
				PolyobjStartSequence(poly,
					seq_name[SEQ_DOOR_STONE + poly->seqType]);
			}
		}
		break;

	case PODOOR_SWING:
		if (PO_RotatePolyobj(polyobj, rot_speed))
		{
			absSpeed = abs(rot_speed);
			if (rot_dist == -1)
			{	// perpetual polyobj
				return;
			}
			rot_dist -= absSpeed;
			if (rot_dist <= 0)
			{
				poly = GetPolyobj(polyobj);
				PolyobjStopSequence(poly);
				if (!close)
				{
					rot_dist = rot_totalDist;
					close = true;
					tics = waitTics;
					rot_speed = -rot_speed;
				}
				else
				{
					if (poly->specialdata == this)
					{
						poly->specialdata = NULL;
					}
					PolyobjFinished(poly->tag);
					RemoveSpecialThinker(this);
				}
			}
		}
		else
		{
			poly = GetPolyobj(polyobj);
			if (poly->crush || !close)
			{	// continue moving if the poly is a crusher, or is opening
				return;
			}
			else
			{	// open back up and rewait
				rot_dist = rot_totalDist - rot_dist;
				rot_speed = -rot_speed;
				close = false;
				PolyobjStartSequence(poly,
					seq_name[SEQ_DOOR_STONE + poly->seqType]);
			}
		}
		break;

	default:
		break;
	}
}

//==========================================================================
//
// EV_OpenPolyDoor
//
//==========================================================================

boolean EV_OpenPolyDoor(line_t * line, int *args, int type)
{
	int mirror;
	int polyNum;
	TPolyDoor *pd;
	polyobj_t *poly;
	angle_t an = 0;

	polyNum = args[0];
	if ((poly = GetPolyobj(polyNum)))
	{
		if (poly->specialdata)
		{	// poly is already moving
			return false;
		}
	}
	else
	{
		Error("EV_OpenPolyDoor:  Invalid polyobj num");	//: %d\n", polyNum);
	}
	pd = NewSpecialThinker(TPolyDoor);
	pd->type = type;
	pd->polyobj = polyNum;
	if (type == PODOOR_SLIDE)
	{
		pd->waitTics = args[4];
		pd->speed = itof(args[1]) / 8.0;
		pd->totalDist = itof(args[3]);	// Distance
		pd->dist = pd->totalDist;
		an = args[2] * (ANG90 / 64);
		pd->xSpeed = pd->speed * cos(an);
		pd->ySpeed = pd->speed * sin(an);

		//THRUST
		pd->thrust_force = pd->speed / 8.0;

		PolyobjStartSequence(poly, seq_name[SEQ_DOOR_STONE + poly->seqType]);
	}
	else if (type == PODOOR_SWING)
	{
		pd->waitTics = args[3];
		pd->rot_speed = (args[1] * (ANG90 / 64)) >> 3;
		pd->rot_totalDist = args[2] * (ANG90 / 64);
		pd->rot_dist = pd->rot_totalDist;

		//THRUST
		pd->thrust_force = itof(pd->rot_speed) / 8.0 / 65536.0;

		PolyobjStartSequence(poly, seq_name[SEQ_DOOR_STONE + poly->seqType]);
	}

	poly->specialdata = pd;

	while ((mirror = GetPolyobjMirror(polyNum)))
	{
		poly = GetPolyobj(mirror);
		if (poly && poly->specialdata)
		{	// mirroring poly is already in motion
			break;
		}
		pd = NewSpecialThinker(TPolyDoor);
		pd->polyobj = mirror;
		pd->type = type;
		poly->specialdata = pd;
		if (type == PODOOR_SLIDE)
		{
			pd->waitTics = args[4];
			pd->speed = itof(args[1]) / 8.0;
			pd->totalDist = itof(args[3]);	// Distance
			pd->dist = pd->totalDist;
			an = an + ANG180;	// reverse the angle
			pd->xSpeed = pd->speed * cos(an);
			pd->ySpeed = pd->speed * sin(an);

			//THRUST
			pd->thrust_force = pd->speed / 8.0;

			PolyobjStartSequence(poly,
				seq_name[SEQ_DOOR_STONE + poly->seqType]);
		}
		else if (type == PODOOR_SWING)
		{
			pd->waitTics = args[3];
			pd->rot_speed = (-args[1] * (ANG90 / 64)) >> 3;
			pd->rot_totalDist = args[2] * (ANG90 / 64);
			pd->rot_dist = pd->rot_totalDist;

			//THRUST
			pd->thrust_force = itof(pd->rot_speed) / 8.0 / 65536.0;

			PolyobjStartSequence(poly,
				seq_name[SEQ_DOOR_STONE + poly->seqType]);
		}
		polyNum = mirror;
	}
	return true;
}

//==========================================================================
//
//  PolyThrustMobj
//
//==========================================================================

void PolyThrustMobj(mobj_t * mobj, angle_t angle, polyobj_t * po)
{
	float thrustX;
	float thrustY;
	float force;
	PolyobjThinker *pe;

	if (!(mobj->flags & MF_SHOOTABLE) && !mobj->player)
	{
		return;
	}

	pe = po->specialdata;
	if (pe)
	{
		force = pe->thrust_force;
		if (force < 1.0)
		{
			force = 1.0;
		}
		else if (force > 4.0)
		{
			force = 4.0;
		}
	}
	else
	{
		force = 1.0;
	}

	thrustX = force * cos(angle);
	thrustY = force * sin(angle);
	mobj->velocity.x += thrustX * 35.0;
	mobj->velocity.y += thrustY * 35.0;
	if (po->crush)
	{
		if (!P_CheckPosition(mobj, mobj->origin.x + thrustX,
				mobj->origin.y + thrustY))
		{
			DamageMobj(mobj, NULL, NULL, 3);
		}
	}
}

//==========================================================================
//
//  PolyBusy
//
//==========================================================================

boolean PolyBusy(int polyobj)
{
	polyobj_t *poly;

	poly = GetPolyobj(polyobj);
	if (!poly->specialdata)
	{
		return false;
	}
	else
	{
		return true;
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.5  2001/10/02 17:42:38  dj_jl
//  Possibility to declare function's code inside class declaration
//
//  Revision 1.4  2001/09/24 17:18:15  dj_jl
//  Created thinker classes
//
//  Revision 1.3  2001/09/20 16:20:00  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
