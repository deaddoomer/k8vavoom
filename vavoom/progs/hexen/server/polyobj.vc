//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// ===== Polyobj Event Code =====

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

enum
{
	PODOOR_NONE,
	PODOOR_SLIDE,
	PODOOR_SWING
};

// TYPES -------------------------------------------------------------------

class PolyobjThinker:Thinker
{
	float thrust_force;
};

class TRotatePoly:PolyobjThinker
{
	int polyobj;
	float dist;
	float speed;

	void Think(void);
};

class TMovePoly:PolyobjThinker
{
	int polyobj;
	float speed;
	float dist;
	float angle;

	void Think(void);
};

class TPolyDoor:PolyobjThinker
{
	int type;
	int polyobj;
	float speed;
	float dist;
	float xSpeed;	// for sliding walls
	float ySpeed;
	float totalDist;
	float time;
	float waitTime;
	boolean close;

	void Think(void);
};

addfields polyobj_t
{
	PolyobjThinker *specialdata;	// pointer a thinker, if the poly is moving
};

// FUNCTION PROTOTYPES -----------------------------------------------------

void DamageMobj(mobj_t * target, mobj_t * inflictor, mobj_t * source,
	int damage);
boolean P_CheckPosition(mobj_t * thing, float x, float y);

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//	TRotatePoly::Think
//
//==========================================================================

void TRotatePoly::Think(void)
{
	float move;
	float absMove;
	polyobj_t *poly;

	move = speed * frametime;
	absMove = fabs(move);
	if (dist >= 0.0 && dist < absMove)
	{
		move = dist * (speed < 0.0 ? -1.0 : 1.0);
	}
	if (PO_RotatePolyobj(polyobj, move))
	{
		if (dist < 0.0)
		{
			// perpetual polyobj
			return;
		}
		dist -= absMove;
		if (dist <= 0.0)
		{
			poly = GetPolyobj(polyobj);
			if (poly->specialdata == this)
			{
				poly->specialdata = NULL;
			}
			PolyobjStopSequence(poly);
			PolyobjFinished(poly->tag);
			RemoveSpecialThinker(this);
			return;
		}
	}
}

//==========================================================================
//
//  EV_RotatePoly
//
//==========================================================================

boolean EV_RotatePoly(line_t * line, int *args, int direction, boolean
	overRide)
{
	int mirror;
	int polyNum;
	TRotatePoly *pe;
	polyobj_t *poly;

	polyNum = args[0];
	if ((poly = GetPolyobj(polyNum)))
	{
		if (poly->specialdata && !overRide)
		{	// poly is already moving
			return false;
		}
	}
	else
	{
		Error("EV_RotatePoly:  Invalid polyobj num");	//: %d\n", polyNum);
	}
	pe = NewSpecialThinker(TRotatePoly);
	pe->polyobj = polyNum;
	if (args[2])
	{
		if (args[2] == 255)
		{
			pe->dist = -1.0;
		}
		else
		{
			pe->dist = itof(args[2]) * (90.0 / 64.0);	// Angle
		}
	}
	else
	{
		pe->dist = 360.0;
	}
	pe->speed = AngleMod180(32.0 * itof(args[1]) * itof(direction) * 90.0 / 64.0 / 8.0);

	//THRUST
	pe->thrust_force = pe->speed / 32.0 * itof(0x800) / 90.0;

	poly->specialdata = pe;
	PolyobjStartSequence(poly, seq_name[SEQ_DOOR_STONE + poly->seqType]);

	while ((mirror = GetPolyobjMirror(polyNum)))
	{
		poly = GetPolyobj(mirror);
		if (poly && poly->specialdata && !overRide)
		{	// mirroring poly is already in motion
			break;
		}
		pe = NewSpecialThinker(TRotatePoly);
		poly->specialdata = pe;
		pe->polyobj = mirror;
		if (args[2])
		{
			if (args[2] == 255)
			{
				pe->dist = -1.0;
			}
			else
			{
				pe->dist = itof(args[2]) * (90.0 / 64.0);	// Angle
			}
		}
		else
		{
			pe->dist = 360.0;
		}
		if ((poly = GetPolyobj(polyNum)))
		{
			poly->specialdata = pe;
		}
		else
		{
			Error("EV_RotatePoly:  Invalid polyobj num");	//: %d\n", polyNum);
		}
		direction = -direction;
		pe->speed = AngleMod180(32.0 * itof(args[1]) * itof(direction) * 90.0 / 64.0 / 8.0);

		//THRUST
		pe->thrust_force = pe->speed / 32.0 * itof(0x800) / 90.0;

		polyNum = mirror;
		PolyobjStartSequence(poly, seq_name[SEQ_DOOR_STONE + poly->seqType]);
	}
	return true;
}

//==========================================================================
//
//	TMovePoly::Think
//
//==========================================================================

void TMovePoly::Think(void)
{
	float move;
	float absMove;
	float xMove;
	float yMove;
	polyobj_t *poly;

	move = speed * frametime;
	absMove = fabs(move);
	if (dist < absMove)
	{
		move = dist * (move < 0.0 ? -1.0 : 1.0);
	}
	xMove = move * cos(angle);
	yMove = move * sin(angle);
	if (PO_MovePolyobj(polyobj, xMove, yMove))
	{
		dist -= absMove;
		if (dist <= 0.0)
		{
			poly = GetPolyobj(polyobj);
			if (poly->specialdata == this)
			{
				poly->specialdata = NULL;
			}
			PolyobjStopSequence(poly);
			PolyobjFinished(poly->tag);
			RemoveSpecialThinker(this);
			return;
		}
	}
}

//==========================================================================
//
// EV_MovePoly
//
//==========================================================================

boolean EV_MovePoly(line_t * line, int *args, boolean timesEight, boolean
	overRide)
{
	int mirror;
	int polyNum;
	TMovePoly *pe;
	polyobj_t *poly;
	float an;

	polyNum = args[0];
	if ((poly = GetPolyobj(polyNum)))
	{
		if (poly->specialdata && !overRide)
		{	// poly is already moving
			return false;
		}
	}
	else
	{
		Error("EV_MovePoly:  Invalid polyobj num");	//: %d\n", polyNum);
	}
	pe = NewSpecialThinker(TMovePoly);
	pe->polyobj = polyNum;
	if (timesEight)
	{
		pe->dist = itof(args[3]) * 8.0;
	}
	else
	{
		pe->dist = itof(args[3]);	// Distance
	}
	pe->speed = itof(args[1]) * 4.0;

	//THRUST
	pe->thrust_force = pe->speed / 8.0;

	poly->specialdata = pe;

	an = itof(args[2]) * (90.0 / 64.0);

	pe->angle = an;
	PolyobjStartSequence(poly, seq_name[SEQ_DOOR_STONE + poly->seqType]);

	while ((mirror = GetPolyobjMirror(polyNum)))
	{
		poly = GetPolyobj(mirror);
		if (poly && poly->specialdata && !overRide)
		{	// mirroring poly is already in motion
			break;
		}
		pe = NewSpecialThinker(TMovePoly);
		pe->polyobj = mirror;
		poly->specialdata = pe;
		if (timesEight)
		{
			pe->dist = itof(args[3]) * 8.0;
		}
		else
		{
			pe->dist = itof(args[3]);	// Distance
		}
		pe->speed = itof(args[1]) * 4.0;

		//THRUST
		pe->thrust_force = pe->speed / 8.0;

		an = AngleMod360(an + 180.0);	// reverse the angle
		pe->angle = an;
		polyNum = mirror;
		PolyobjStartSequence(poly, seq_name[SEQ_DOOR_STONE + poly->seqType]);
	}
	return true;
}

//==========================================================================
//
//  TPolyDoor::Think
//
//==========================================================================

void TPolyDoor::Think(void)
{
	polyobj_t *poly;
	float move;

	if (time)
	{
		time -= frametime;
		if (time <= 0.0)
		{
			time = 0.0;
			poly = GetPolyobj(polyobj);
			PolyobjStartSequence(poly,
				seq_name[SEQ_DOOR_STONE + poly->seqType]);
		}
		return;
	}
	switch (type)
	{
	case PODOOR_SLIDE:
		move = speed * frametime;
		if (PO_MovePolyobj(polyobj, move * xSpeed, move * ySpeed))
		{
			dist -= fabs(move);
			if (dist <= 0.0)
			{
				poly = GetPolyobj(polyobj);
				PolyobjStopSequence(poly);
				if (!close)
				{
					dist = totalDist;
					close = true;
					time = waitTime;
					xSpeed = -xSpeed;
					ySpeed = -ySpeed;
				}
				else
				{
					if (poly->specialdata == this)
					{
						poly->specialdata = NULL;
					}
					PolyobjFinished(poly->tag);
					RemoveSpecialThinker(this);
				}
			}
		}
		else
		{
			poly = GetPolyobj(polyobj);
			if (poly->crush || !close)
			{
				// continue moving if the poly is a crusher, or is opening
				return;
			}
			else
			{
				// open back up
				dist = totalDist - dist;
				xSpeed = -xSpeed;
				ySpeed = -ySpeed;
				close = false;
				PolyobjStartSequence(poly,
					seq_name[SEQ_DOOR_STONE + poly->seqType]);
			}
		}
		break;

	case PODOOR_SWING:
		move = speed * frametime;
		if (PO_RotatePolyobj(polyobj, move))
		{
			dist -= fabs(move);
			if (dist <= 0.0)
			{
				poly = GetPolyobj(polyobj);
				PolyobjStopSequence(poly);
				if (!close)
				{
					dist = totalDist;
					close = true;
					time = waitTime;
					speed = -speed;
				}
				else
				{
					if (poly->specialdata == this)
					{
						poly->specialdata = NULL;
					}
					PolyobjFinished(poly->tag);
					RemoveSpecialThinker(this);
				}
			}
		}
		else
		{
			poly = GetPolyobj(polyobj);
			if (poly->crush || !close)
			{
				// continue moving if the poly is a crusher, or is opening
				return;
			}
			else
			{
				// open back up and rewait
				dist = totalDist - dist;
				speed = -speed;
				close = false;
				PolyobjStartSequence(poly,
					seq_name[SEQ_DOOR_STONE + poly->seqType]);
			}
		}
		break;

	default:
		break;
	}
}

//==========================================================================
//
// EV_OpenPolyDoor
//
//==========================================================================

boolean EV_OpenPolyDoor(line_t * line, int *args, int type)
{
	int mirror;
	int polyNum;
	TPolyDoor *pd;
	polyobj_t *poly;
	float an = 0.0;

	polyNum = args[0];
	if ((poly = GetPolyobj(polyNum)))
	{
		if (poly->specialdata)
		{	// poly is already moving
			return false;
		}
	}
	else
	{
		Error("EV_OpenPolyDoor:  Invalid polyobj num");	//: %d\n", polyNum);
	}
	pd = NewSpecialThinker(TPolyDoor);
	pd->type = type;
	pd->polyobj = polyNum;
	if (type == PODOOR_SLIDE)
	{
		pd->waitTime = itof(args[4]) / 35.0;
		pd->speed = itof(args[1]) * 4.0;
		pd->totalDist = itof(args[3]);	// Distance
		pd->dist = pd->totalDist;
		an = itof(args[2]) * (90.0 / 64.0);
		pd->xSpeed = cos(an);
		pd->ySpeed = sin(an);

		//THRUST
		pd->thrust_force = pd->speed / 8.0;

		PolyobjStartSequence(poly, seq_name[SEQ_DOOR_STONE + poly->seqType]);
	}
	else if (type == PODOOR_SWING)
	{
		pd->waitTime = itof(args[3]) / 35.0;
		pd->speed = AngleMod180(4.0 * itof(args[1]) * (90.0 / 64.0));
		pd->totalDist = itof(args[2]) * (90.0 / 64.0);
		pd->dist = pd->totalDist;

		//THRUST
		pd->thrust_force = pd->speed * itof(0x1000) / 180.0;

		PolyobjStartSequence(poly, seq_name[SEQ_DOOR_STONE + poly->seqType]);
	}

	poly->specialdata = pd;

	while ((mirror = GetPolyobjMirror(polyNum)))
	{
		poly = GetPolyobj(mirror);
		if (poly && poly->specialdata)
		{	// mirroring poly is already in motion
			break;
		}
		pd = NewSpecialThinker(TPolyDoor);
		pd->polyobj = mirror;
		pd->type = type;
		poly->specialdata = pd;
		if (type == PODOOR_SLIDE)
		{
			pd->waitTime = itof(args[4]) / 35.0;
			pd->speed = itof(args[1]) * 4.0;
			pd->totalDist = itof(args[3]);	// Distance
			pd->dist = pd->totalDist;
			an = AngleMod360(an + 180.0);	// reverse the angle
			pd->xSpeed = cos(an);
			pd->ySpeed = sin(an);

			//THRUST
			pd->thrust_force = pd->speed / 8.0;

			PolyobjStartSequence(poly,
				seq_name[SEQ_DOOR_STONE + poly->seqType]);
		}
		else if (type == PODOOR_SWING)
		{
			pd->waitTime = itof(args[3]) / 35.0;
			pd->speed = AngleMod180(4.0 * itof(-args[1]) * (90.0 / 64.0));
			pd->totalDist = itof(args[2]) * (90.0 / 64.0);
			pd->dist = pd->totalDist;

			//THRUST
			pd->thrust_force = pd->speed * itof(0x1000) / 180.0;

			PolyobjStartSequence(poly,
				seq_name[SEQ_DOOR_STONE + poly->seqType]);
		}
		polyNum = mirror;
	}
	return true;
}

//==========================================================================
//
//  PolyThrustMobj
//
//==========================================================================

void PolyThrustMobj(mobj_t * mobj, TVec thrustDir, polyobj_t * po)
{
	float force;
	PolyobjThinker *pe;

	if (!(mobj->flags & MF_SHOOTABLE) && !mobj->player)
	{
		return;
	}

	pe = po->specialdata;
	if (pe)
	{
		force = pe->thrust_force;
		if (force < 1.0)
		{
			force = 1.0;
		}
		else if (force > 128.0)
		{
			force = 128.0;
		}
	}
	else
	{
		force = 1.0;
	}

	mobj->velocity += force * thrustDir;
	if (po->crush)
	{
		TVec testPos;

		testPos = mobj->origin + force * thrustDir * frametime;
		if (!P_CheckPosition(mobj, testPos.x, testPos.y))
		{
			DamageMobj(mobj, NULL, NULL, 3);
		}
	}
}

//==========================================================================
//
//  PolyBusy
//
//==========================================================================

boolean PolyBusy(int polyobj)
{
	polyobj_t *poly;

	poly = GetPolyobj(polyobj);
	if (!poly->specialdata)
	{
		return false;
	}
	else
	{
		return true;
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.7  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.6  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.5  2001/10/02 17:42:38  dj_jl
//  Possibility to declare function's code inside class declaration
//
//  Revision 1.4  2001/09/24 17:18:15  dj_jl
//  Created thinker classes
//
//  Revision 1.3  2001/09/20 16:20:00  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
