//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define MAX_TID_COUNT		200

#define SMALLSPLASHCLIP		12.0

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

void ActivateMorphWeapon(player_t * player);
void DropWeapon(player_t * player);
void SetupPsprites(player_t * player);
void NoiseAlert(Actor target, Actor emmiter);

// DATA DECLARATIONS -------------------------------------------------------

classid PuffType;
Actor PuffSpawned;
Actor linetarget;	// who got hit (or none)

int TIDList[MAX_TID_COUNT + 1];	// +1 for termination marker
Actor TIDMobj[MAX_TID_COUNT];

int classFlags[] = {
	MTF_FIGHTER,
	MTF_CLERIC,
	MTF_MAGE
};

float windTab[3] = { 5.0 / 32.0, 10.0 / 32.0, 25.0 / 32.0 };

// CODE --------------------------------------------------------------------

//===========================================================================
//
//  Actor::GetFloorType
//
//===========================================================================

int Actor::GetFloorType(void)
{
	return TerrainType(Floor->pic);
}

//==========================================================================
//
//  Actor::SetOrigin2
//
//==========================================================================

void Actor::SetOrigin2(TVec origin)
{
	float space;

	SetOrigin(origin);
	// Set subsector and/or block links.
	P_SetThingPosition(self);
	if (origin.z == ONFLOORZ)
	{
		origin.z = FloorZ;
	}
	else if (origin.z == ONCEILINGZ)
	{
		origin.z = CeilingZ - Height;
	}
	else if (origin.z == FLOATRANDZ)
	{
		space = CeilingZ - Height - FloorZ;
		if (space > 48.0)
		{
			space -= 40.0;
			origin.z = space * Random() + FloorZ + 40.0;
		}
		else
		{
			origin.z = FloorZ;
		}
	}
	else if (bFloatBob)
	{
		origin.z = FloorZ + origin.z;	// artifact z passed in as height
	}
	SetOrigin(origin);
	if (bFloorClip && GetFloorType() >= FLOOR_LIQUID && Origin.z == FloorZ)
	{
		FloorClip = 10.0;
	}
	else
	{
		FloorClip = 0.0;
	}
}

//==========================================================================
//
//  CopyMThing
//
//==========================================================================

void CopyMThing(mthing_t * from, mthing_t * to)
{
	to->tid = from->tid;
	to->x = from->x;
	to->y = from->y;
	to->height = from->height;
	to->angle = from->angle;
	to->type = from->type;
	to->options = from->options;
	to->special = from->special;
	to->arg1 = from->arg1;
	to->arg2 = from->arg2;
	to->arg3 = from->arg3;
	to->arg4 = from->arg4;
	to->arg5 = from->arg5;
}

//==========================================================================
//
//	Actor::OnMapSpawn
//
//==========================================================================

void Actor::OnMapSpawn(mthing_t * mthing)
{
	state_t *st;

	SpawnHealth = Health;
	bCheckLineBlocking = false;
	bCheckLineBlockMonsters = false;
	if (!bMissile)
	{
		bCheckLineBlocking = true;
		if (Class != PlayerFighter && Class != PlayerCleric &&
			Class != PlayerMage && Class != PlayerPig)
		{
			bCheckLineBlockMonsters = true;
		}
	}

	// Set the state, but do not use P_SetMobjState, because action
	// routines can't be called yet.  If the spawnstate has an action
	// routine, it will not be called.
	StateNum = IdleState;
	st = &states[StateNum];
	StateTime = st->time;
	SpriteIndex = st->sprite;
	SpriteName = sprite_names[st->sprite];
	SpriteFrame = st->frame;
	ModelIndex = st->model_index;
	ModelFrame = st->model_frame;
	NextState = st->nextstate;

	if (mthing)
	{
		float x, y, z;

		x = mthing->x;
		y = mthing->y;
		if (Class == ZLynchedNoHeart)
		{
			// Special stuff
			Spawn(BloodPool, vector(x, y, ONFLOORZ));
		}

		if (bSpawnCeiling)
		{
			z = ONCEILINGZ;
		}
		else if (bSpawnFloat)
		{
			z = FLOATRANDZ;
		}
		else if (bFloatBob)
		{
			z = mthing->height;
		}
		else
		{
			z = ONFLOORZ;
		}
		SetOrigin2(vector(x, y, z));
		if (z == ONFLOORZ)
		{
			Origin.z += mthing->height;
		}
		else if (z == ONCEILINGZ)
		{
			Origin.z -= mthing->height;
		}
		P_SetThingPosition(self);
		TID = mthing->tid;
		Special = mthing->special;
		Args[0] = mthing->arg1;
		Args[1] = mthing->arg2;
		Args[2] = mthing->arg3;
		Args[3] = mthing->arg4;
		Args[4] = mthing->arg5;
		if (bFloatBob)
		{
			// Seed random starting index for bobbing motion
			Health = P_Random();
			Special1f = mthing->height;
		}
		if (StateTime > 0.0)
		{
			StateTime = 0.1 + Random() * StateTime;
		}
		if (bCountKill)
		{
			// Quantize angle to 45 degree increments
			Angles.yaw = itof(45 * (mthing->angle / 45));
		}
		else
		{
			// Scale angle correctly (source is 0..359)
			Angles.yaw = itof(mthing->angle);
		}
		if (mthing->options & MTF_AMBUSH)
		{
			bAmbush = true;
		}
		if (mthing->options & MTF_DORMANT)
		{
			SetDormant();
		}
	}
	else
	{
		SetOrigin2(Origin);
	}
}

//==========================================================================
//
//	Pawn::OnMapSpawn
//
//==========================================================================

void Pawn::OnMapSpawn(mthing_t * mthing)
{
	if (bCheckNoMonsters && nomonsters)
	{
		RemoveMobjThinker(self);
		return;
	}
	if (gameskill == sk_nightmare)
	{
		ReactionCount = 0;
	}

	LastLook = P_Random() % MAXPLAYERS;

	::OnMapSpawn(mthing);
}

//==========================================================================
//
//	Spawn
//
//==========================================================================

Actor Spawn(classid type, TVec position)
{
	Actor A;

	A = Actor(NewMobjThinker(type));
	A.Origin = position;
	A.OnMapSpawn(NULL);
	return A;
}

//==========================================================================
//
//	Actor::Remove
//
//==========================================================================

void Actor::Remove(void)
{
	// Remove from creature queue
	if (bCountKill && bCorpse)
	{
		A_DeQueueCorpse();
	}

	if (TID)
	{
		// Remove from TID list
		RemoveFromTIDList();
	}

	// Free block
	::Remove();
}

//==========================================================================
//
//  Actor::HitFloorType
//
//==========================================================================

int Actor::HitFloorType(void)
{
	Actor A;
	int smallsplash = false;

	if (FloorZ != Sector->floorheight)
	{
		// don't splash if landing on the edge above water/lava/etc....
		return FLOOR_SOLID;
	}

	// Things that don't splash go here
	switch (Class)
	{
	case Leaf1:
	case Leaf2:
//	case MT_BLOOD:          // I set these to low mass -- pm
//	case MT_BLOODSPLATTER:
	case Splash:
	case SludgeChunk:
		return FLOOR_SOLID;
	default:
		break;
	}

	// Small splash for small masses
	if (Mass < 10.0)
		smallsplash = true;

	switch (GetFloorType())
	{
	case FLOOR_WATER:
		if (smallsplash)
		{
			A = Spawn(SplashBase, vector(Origin.x, Origin.y, ONFLOORZ));
			if (A)
				A.FloorClip += SMALLSPLASHCLIP;
			A.PlaySound('Ambient10', CHAN_VOICE);	// small drip
		}
		else
		{
			A = Spawn(Splash, vector(Origin.x, Origin.y, ONFLOORZ));
			A.Instigator = self;
			A.Velocity.x = (Random() - Random()) * 35.0;
			A.Velocity.y = (Random() - Random()) * 35.0;
			A.Velocity.z = (2.0 + Random()) * 35.0;
			A = Spawn(SplashBase, vector(Origin.x, Origin.y, ONFLOORZ));
			if (bIsPlayer)
				NoiseAlert(self, self);
			A.PlaySound('WaterSplash', CHAN_VOICE);
		}
		return FLOOR_WATER;
	case FLOOR_LAVA:
		if (smallsplash)
		{
			A = Spawn(LavaSplash, vector(Origin.x, Origin.y, ONFLOORZ));
			if (A)
				A.FloorClip += SMALLSPLASHCLIP;
		}
		else
		{
			A = Spawn(LavaSmoke, vector(Origin.x, Origin.y, ONFLOORZ));
			A.Velocity.z = (1.0 + Random() / 2.0) * 35.0;
			A = Spawn(LavaSplash, vector(Origin.x, Origin.y, ONFLOORZ));
			if (bIsPlayer)
				NoiseAlert(self, self);
		}
		A.PlaySound('LavaSizzle', CHAN_VOICE);
		if (bIsPlayer && level->tictime & 31)
		{
			Damage(LavaInflictor, none, 5);
		}
		return FLOOR_LAVA;
	case FLOOR_SLUDGE:
		if (smallsplash)
		{
			A = Spawn(SludgeSplash, vector(Origin.x, Origin.y, ONFLOORZ));
			if (A)
				A.FloorClip += SMALLSPLASHCLIP;
		}
		else
		{
			A = Spawn(SludgeChunk, vector(Origin.x, Origin.y, ONFLOORZ));
			A.Instigator = self;
			A.Velocity.x = (Random() - Random()) * 35.0;
			A.Velocity.y = (Random() - Random()) * 35.0;
			A.Velocity.z = (1.0 + Random()) * 35.0;
			A = Spawn(SludgeSplash, vector(Origin.x, Origin.y, ONFLOORZ));
			if (bIsPlayer)
				NoiseAlert(self, self);
		}
		A.PlaySound('SludgeGloop', CHAN_VOICE);
		return FLOOR_SLUDGE;
	}
	return FLOOR_SOLID;
}

//==========================================================================
//
//  Actor::FloorBounceMissile
//
//==========================================================================

void Actor::FloorBounceMissile(void)
{
	if (HitFloorType() >= FLOOR_LIQUID)
	{
		switch (Class)
		{
		case SorcererFX1:
		case SorcererBall1:
		case SorcererBall2:
		case SorcererBall3:
			break;
		default:
			Remove();
			return;
		}
	}
	switch (Class)
	{
	case SorcererFX1:
		Velocity.z = -Velocity.z;	// no energy absorbed
		break;
	case StainedGlassShard1:
	case StainedGlassShard2:
	case StainedGlassShard3:
	case StainedGlassShard4:
	case StainedGlassShard5:
	case StainedGlassShard6:
	case StainedGlassShard7:
	case StainedGlassShard8:
	case StainedGlassShard9:
	case StainedGlassShard0:
		Velocity.z = Velocity.z * -0.3;
		if (fabs(Velocity.z) < 0.5 * 35.0)
		{
			SetState(S_NULL);
			return;
		}
		break;
	default:
		Velocity.z = Velocity.z * -0.7;
		break;
	}
	Velocity.x = 2.0 * Velocity.x / 3.0;
	Velocity.y = 2.0 * Velocity.y / 3.0;
	if (SightSound)
	{
		switch (Class)
		{
		case SorcererBall1:
		case SorcererBall2:
		case SorcererBall3:
			if (!Args[0])
				PlaySound(SightSound, CHAN_VOICE);
			break;
		default:
			PlaySound(SightSound, CHAN_VOICE);
			break;
		}
	}
}

//==========================================================================
//
//  Actor::Thrust
//
//==========================================================================

void Actor::Thrust(float angle, float move)
{
	Velocity.x += move * cos(angle) * 35.0;
	Velocity.y += move * sin(angle) * 35.0;
}

//==========================================================================
//
//  Actor::FaceActor
//
//  Returns 1 if 'source' needs to turn clockwise, or 0 if 'source' needs
// to turn counter clockwise.  'delta' is set to the amount 'source'
// needs to turn.
//
//==========================================================================

int Actor::FaceActor(Actor target, float *delta)
{
	float diff;
	float angle1;
	float angle2;

	angle1 = Angles.yaw;
	angle2 = atan2(target.Origin.y - Origin.y, target.Origin.x - Origin.x);
	if (angle2 > angle1)
	{
		diff = AngleMod360(angle2 - angle1);
		if (diff > 180.0)
		{
			*delta = 360.0 - diff;
			return 0;
		}
		else
		{
			*delta = diff;
			return 1;
		}
	}
	else
	{
		diff = AngleMod360(angle1 - angle2);
		if (diff > 180.0)
		{
			*delta = 360.0 - diff;
			return 1;
		}
		else
		{
			*delta = diff;
			return 0;
		}
	}
}

//==========================================================================
//
//  Actor::MonsterFallingDamage
//
//==========================================================================

void Actor::MonsterFallingDamage(void)
{
	int damage;
	float mom;

	mom = fabs(Velocity.z) / 35.0;
	if (mom > 35.0)
	{
		// automatic death
		damage = 10000;
	}
	else
	{
		damage = ftoi((mom - 23.0) * 6.0);
	}
	damage = 10000;	// always kill 'em
	Damage(none, none, damage);
}

//==========================================================================
//
//  Actor::ActiveMinotaur
//
//  Search thinker list for minotaur
//
//==========================================================================

Actor Actor::ActiveMinotaur(void)
{
	Actor mo;

	FOREACH(Actor, mo)
	{
		if (mo.Class != Minotaur)
			continue;
		if (mo.Health <= 0)
			continue;
		if (!mo.bCountKill)
			continue;	// for morphed minotaurs
		if (mo.bCorpse)
			continue;
		if ((level->tictime - mo.Args[0]) >= ftoi(MAULATORTIME * 35.0))
			continue;
		if (mo._SpecialMobj1 == this)
			return mo;
	}
	return none;
}

//==========================================================================
//
//  Actor::Died
//
//==========================================================================

void Actor::Died(Actor source)
{
	int dummy[5];
	Actor master;

	bShootable = false;
	bNoGravity = false;
	bFloat = false;
	bSkullFly = false;
	bDropOff = true;
	bCorpse = true;
	bNoPassMobj = true;
	Height /= 4.0;
	if ((bCountKill || Class == ZBell) && Special)
	{
		// Initiate monster death actions
		if (Class == Sorcerer)
		{
			dummy[0] = 0;
			dummy[1] = 0;
			dummy[2] = 0;
			dummy[3] = 0;
			dummy[4] = 0;
			StartACS(Special, 0, &dummy[0], self, NULL, 0);
		}
		else
		{
			ExecuteLineSpecial(Special, &Args[0], NULL, 0, self);
		}
	}
	if (source && source.bIsPlayer)
	{	// Check for frag changes
		if (bIsPlayer)
		{
			if (source.Player->bIsBot)
			{
				source.Player->Bot.Killed(self);
			}

			if (Player->bIsBot)
			{
				Player->Bot.Died(source);
			}

			if (self == source)
			{
				// Self-frag
				Player->Frags[P_GetPlayerNum(Player)]--;
			}
			else
			{
				source.Player->Frags[P_GetPlayerNum(Player)]++;
			}
		}
	}
	if (bIsPlayer)
	{
		// Player death
		if (!source)
		{
			// Self-frag
			Player->Frags[P_GetPlayerNum(Player)]--;
		}
		bSolid = false;
		bFly = false;
		Player->Powers[pw_flight] = 0.0;
		Player->PlayerState = PST_DEAD;
		DropWeapon(Player);
		if (bFireDamage)
		{
			// Player flame death
			switch (Player->PClass)
			{
			case PCLASS_FIGHTER:
				PlaySound('PlayerFighterBurnDeath', CHAN_VOICE);
				SetState(S_PLAY_F_FDTH1);
				return;
			case PCLASS_CLERIC:
				PlaySound('PlayerClericBurnDeath', CHAN_VOICE);
				SetState(S_PLAY_C_FDTH1);
				return;
			case PCLASS_MAGE:
				PlaySound('PlayerMageBurnDeath', CHAN_VOICE);
				SetState(S_PLAY_M_FDTH1);
				return;
			default:
				break;
			}
		}
		if (bIceDamage)
		{
			// Player ice death
			Translation = 0;	//no translation
			bIceCorpse  = true;
			SetState(IceDeathState);
			return;
		}
	}
	if (bFireDamage)
	{
		if (Class == FighterBoss)
 		{
			PlaySound('PlayerFighterBurnDeath', CHAN_VOICE);
			SetState(S_PLAY_F_FDTH1);
			return;
 		}
 		if (Class == ClericBoss)
		{
			PlaySound('PlayerClericBurnDeath', CHAN_VOICE);
			SetState(S_PLAY_C_FDTH1);
			return;
		}
		if (Class == MageBoss)
		{
			PlaySound('PlayerMageBurnDeath', CHAN_VOICE);
			SetState(S_PLAY_M_FDTH1);
			return;
		}
		if (Class == TreeDestructible)
		{
			SetState(S_ZTREEDES_X1);
			Height = 24.0;
			PlaySound('TreeExplode', CHAN_VOICE);
			return;
		}
	}
	if (bIceDamage && IceDeathState)
	{
		bIceCorpse = true;
		SetState(IceDeathState);
		return;
	}

	if (Class == Minotaur)
	{
		master = *_SpecialMobj1;
		if (master.Health > 0)
		{
			if (!master.ActiveMinotaur())
			{
				master.Player->Powers[pw_minotaur] = 0.0;
			}
		}
	}
	else if (Class == TreeDestructible)
	{
		Height = 24.0;
	}
	if (Health < GibsHealth && GibsDeathState)
	{
		// Extreme death
		SetState(GibsDeathState);
	}
	else
	{	// Normal death
		if ((Class == FireDemon) && (Origin.z <= FloorZ + 2.0) &&
			GibsDeathState)
		{
			// This is to fix the imps' staying in fall state
			SetState(GibsDeathState);
		}
		else
		{
			SetState(DeathState);
		}
	}
	StateTime -= Random() * 0.1;
}

//==========================================================================
//
//  Actor::MinotaurSlam
//
//==========================================================================

void Actor::MinotaurSlam(Actor source)
{
	float angle;
	float thrust;

	angle = atan2(Origin.y - source.Origin.y, Origin.x - source.Origin.x);
	thrust = 16.0 + Random() * 4.0;
	Velocity.x += thrust * cos(angle) * 35.0;
	Velocity.y += thrust * sin(angle) * 35.0;
	Damage(none, source, HITDICE(4));
	if (bIsPlayer)
	{
		ReactionTime = 0.4 + Random() * 0.2;
	}
	source.Args[4] = 0;	// Stop charging
}

//==========================================================================
//
//  Actor::MorphPlayer
//
//  Returns true if the player gets turned into a pig
//
//==========================================================================

boolean Actor::MorphPlayer(void)
{
	Actor fog;
	Actor beastMo;
	int i;

	if (Player->Powers[pw_invulnerability])
	{
		// Immune when invulnerable
		return (false);
	}
	if (Player->MorphTics)
	{
		// Player is already a beast
		return false;
	}

	fog = Spawn(TeleportFog, Origin + vector(0.0, 0.0, TELEFOGHEIGHT));
	fog.PlaySound('Teleport', CHAN_VOICE);

	beastMo = Spawn(PlayerPig, Origin);
	beastMo._Special1 = Player->ReadyWeapon;
	beastMo.Angles = Angles;
	beastMo.Player = Player;
	beastMo.bIsPlayer = true;
	beastMo.Health = MAXMORPHHEALTH;
	Player->Health = beastMo.Health;
	Player->MO = beastMo;
	for (i = 0; i < NUMARMOR; i++)
	{
		Player->ArmorPoints[i] = 0.0;
	}
	Player->PClass = PCLASS_PIG;
	beastMo.bFly = bFly;
	Player->MorphTics = ftoi(MORPHTIME * 35.0);
	ActivateMorphWeapon(Player);

	SetState(S_FREETARGMOBJ);

	return true;
}

//==========================================================================
//
//  Actor::MorphMonster
//
//==========================================================================

boolean Actor::MorphMonster(void)
{
	Actor master;
	Actor monster;
	Actor fog;
	int i;

	if (bIsPlayer)
		return false;
	if (!bCountKill)
		return false;
	if (bBoss)
		return false;
	switch (Class)
	{
	case Pig:
	case FighterBoss:
	case ClericBoss:
	case MageBoss:
		return false;
	}

	RemoveFromTIDList();

	fog = Spawn(TeleportFog, Origin + vector(0.0, 0.0, TELEFOGHEIGHT));
	fog.PlaySound('Teleport', CHAN_VOICE);

	monster = Spawn(Pig, Origin);
	monster.SpecialCID = Class;
	monster._Special1 = ftoi(MORPHTIME * 35.0) + P_Random();
	monster.Translucency = Translucency;
	monster.Enemy = Enemy;
	monster.Angles.yaw = Angles.yaw;
	monster.TID = TID;
	monster.Special = Special;
	monster.InsertIntoTIDList(TID);
	for (i = 0; i < 5; i++)
	{
		monster.Args[i] = Args[i];
	}

	// check for turning off minotaur power for active icon
	if (Class == Minotaur)
	{
		master = *_SpecialMobj1;
		if (master.Health > 0)
		{
			if (!master.ActiveMinotaur())
			{
				master.Player->Powers[pw_minotaur] = 0.0;
			}
		}
	}

	SetState(S_FREETARGMOBJ);

	return true;
}

//==========================================================================
//
//  Actor::AutoUseHealth
//
//==========================================================================

void Actor::AutoUseHealth(int saveHealth)
{
	int i;
	int count;
	int normalCount;
	int normalSlot = 0;
	int superCount;
	int superSlot = 0;

	normalCount = 0;
	superCount = 0;
	for (i = 0; i < Player->InventorySlotNum; i++)
	{
		if (Player->Inventory[i].type == arti_health)
		{
			normalSlot = i;
			normalCount = Player->Inventory[i].count;
		}
		else if (Player->Inventory[i].type == arti_superhealth)
		{
			superSlot = i;
			superCount = Player->Inventory[i].count;
		}
	}
	if ((gameskill == sk_baby) && (normalCount * 25 >= saveHealth))
	{
		// Use quartz flasks
		count = (saveHealth + 24) / 25;
		for (i = 0; i < count; i++)
		{
			Health += 25;
//FIXME
			PlayerPawn(self).PlayerRemoveArtifact(normalSlot);
		}
	}
	else if (superCount * 100 >= saveHealth)
	{
		// Use mystic urns
		count = (saveHealth + 99) / 100;
		for (i = 0; i < count; i++)
		{
			Health += 100;
//FIXME
			PlayerPawn(self).PlayerRemoveArtifact(superSlot);
		}
	}
	else if ((gameskill == sk_baby)
		&& (superCount * 100 + normalCount * 25 >= saveHealth))
	{
		// Use mystic urns and quartz flasks
		count = (saveHealth + 24) / 25;
		saveHealth -= count * 25;
		for (i = 0; i < count; i++)
		{
			Health += 25;
//FIXME
			PlayerPawn(self).PlayerRemoveArtifact(normalSlot);
		}
		count = (saveHealth + 99) / 100;
		for (i = 0; i < count; i++)
		{
			Health += 100;
			// The same as in HERETIC
//FIXME
			PlayerPawn(self).PlayerRemoveArtifact(normalSlot);
		}
	}
	Player->Health = Health;
}

//==========================================================================
//
//  Actor::Damage
//
//  Damages both enemies and players
//  inflictor is the thing that caused the damage - creature or missile,
// can be NULL (slime, etc)
//  source is the thing to target after taking damage - creature or NULL
//  Source and inflictor are the same for melee attacks
//  source can be null for barrel explosions and other environmental stuff
//
//==========================================================================

void Actor::Damage(Actor inflictor, Actor source, int damage)
{
	float saved;
	float savedPercent;
	Actor master;
	int i;

	if (!bShootable)
	{
		// Shouldn't happen
		return;
	}
	if (Health <= 0)
	{
		if (inflictor && inflictor.bIceDamage)
		{
			return;
		}
		else if (bIceCorpse)	// frozen
		{
			StateTime = 0.1;
			Velocity.x = 0.0;
			Velocity.y = 0.0;
		}
		return;
	}
	if (bInvulnerable && damage < 10000)
	{
		// mobj is invulnerable
		if (bIsPlayer)
			return;	// for player, no exceptions
		if (inflictor)
		{
			switch (inflictor.Class)
			{
				// These inflictors aren't foiled by invulnerability
			case HolyFX:
			case PoisonCloud:
			case FireBomb:
				break;
			default:
				return;
			}
		}
		else
		{
			return;
		}
	}
	if (bIsPlayer)
	{
		if (damage < 1000 && ((Player->Cheats & CF_GODMODE)
				|| Player->Powers[pw_invulnerability]))
		{
			return;
		}
	}
	if (bSkullFly)
	{
		Velocity = vector(0.0, 0.0, 0.0);
	}
	if (bDormant)
	{
		// Invulnerable, and won't wake up
		return;
	}
	if (bIsPlayer && gameskill == sk_baby)
	{
		// Take half damage in trainer mode
		damage >>= 1;
	}
	// Special damage types
	if (inflictor)
	{
		switch (inflictor.Class)
		{
		case EggMissile:
			if (bIsPlayer)
			{
				MorphPlayer();
			}
			else
			{
				MorphMonster();
			}
			return;	// Always return
		case TeleportOtherFX1:
		case TeleportOtherFX2:
		case TeleportOtherFX3:
		case TeleportOtherFX4:
		case TeleportOtherFX5:
			if (bCountKill && !bBoss &&
				(Class != Serpent) && (Class != SerpentLeader))
			{
				TeleportOther();
			}
			return;
		case Minotaur:
			if (inflictor.bSkullFly)
			{
				// Slam only when in charge mode
				MinotaurSlam(inflictor);
				return;
			}
			break;
		case BishopMissile:
			// Bishops are just too nasty
			damage >>= 1;
			break;
		case ShardMissile:
			switch (inflictor._Special2)
			{
			case 3:
				damage <<= 3;
				break;
			case 2:
				damage <<= 2;
				break;
			case 1:
				damage <<= 1;
				break;
			default:
				break;
			}
			break;
		case ClericStaffMissile:
			// Cleric Serpent Staff does poison damage
			if (bIsPlayer)
			{
				PoisonPlayer(source, 20);
				damage >>= 1;
			}
			break;
		case IceGuyMissile2:
			damage >>= 1;
			break;
		case PoisonDart:
			if (bIsPlayer)
			{
				PoisonPlayer(source, 20);
				damage >>= 1;
			}
			break;
		case PoisonCloud:
			if (bIsPlayer)
			{
				if (Player->PoisonCount < 4)
				{
					PoisonDamage(source, 15 + (P_Random() & 15), false);	// Don't play painsound
					PoisonPlayer(source, 50);
					PlaySound('PlayerPoisonCough', CHAN_VOICE);
				}
				return;
			}
			else if (!bCountKill)
			{
				// only damage monsters/players with the poison cloud
				return;
			}
			break;
		case FighterSwordMissile:
			if (bIsPlayer)
			{
				damage -= damage >> 2;
			}
			break;
		default:
			break;
		}
	}
	// Push the	target
	if (inflictor && (!source || !source.bIsPlayer) &&
		!inflictor.bNoDamageThrust)
	{
		TVec dir;
		float thrust;

		thrust = itof(damage) / Mass * 656.25;
		dir = Normalize(MobjCenter(self) - MobjCenter(inflictor));
		Velocity += dir * thrust;
	}

	//
	// player specific
	//
	if (bIsPlayer)
	{
		savedPercent = AutoArmorSave[Player->PClass]
			+ Player->ArmorPoints[ARMOR_ARMOR]
			+ Player->ArmorPoints[ARMOR_SHIELD]
			+ Player->ArmorPoints[ARMOR_HELMET]
			+ Player->ArmorPoints[ARMOR_AMULET];
		if (savedPercent)
		{
			// armor absorbed some damage
			if (savedPercent > 100.0)
			{
				savedPercent = 100.0;
			}
			for (i = 0; i < NUMARMOR; i++)
			{
				if (Player->ArmorPoints[i])
				{
					Player->ArmorPoints[i] -= itof(damage) *
						ArmorIncrement[Player->PClass * NUMARMOR + i] / 300.0;
					if (Player->ArmorPoints[i] < 2.0)
					{
						Player->ArmorPoints[i] = 0.0;
					}
				}
			}
			saved = itof(damage) * savedPercent / 100.0;
			if (saved > savedPercent * 2.0)
			{
				saved = savedPercent * 2.0;
			}
			damage -= ftoi(saved);
		}
		if (damage >= Player->Health
			&& ((gameskill == sk_baby) || deathmatch) && !Player->MorphTics)
		{
			// Try to use some inventory health
			AutoUseHealth(damage - Health + 1);
		}
		Player->Health -= damage;	// mirror mobj health here for Dave
		if (Player->Health < 0)
		{
			Player->Health = 0;
		}
		Player->Attacker = &source;
		Player->DamageCount += damage;	// add damage after armor / invuln
		if (Player->DamageCount > 100)
		{
			Player->DamageCount = 100;	// teleport stomp does 10k points...
		}
	}

	//
	// do the damage
	//
	Health -= damage;
	if (Health <= 0)
	{
		// Death
		if (inflictor)
		{
			// check for special fire damage or ice damage deaths
			if (inflictor.bFireDamage)
			{
				if (bIsPlayer && !Player->MorphTics)
				{
					// Check for flame death
					if (Health > -50 && damage > 25)
					{
						bFireDamage = true;
					}
				}
				else
				{
					bFireDamage = true;
				}
			}
			else if (inflictor.bIceDamage)
			{
				bIceDamage = true;
			}
		}
		if (source && (source.Class == Minotaur))
		{
			// Minotaur's kills go to his master
			master = *source._SpecialMobj1;
			// Make sure still alive and not a pointer to fighter head
			if (master.bIsPlayer && (master.Player->MO == master))
			{
				source = master;
			}
		}
		if (source && (source.bIsPlayer) &&
			(source.Player->ReadyWeapon == WP_FOURTH))
		{
			// Always extreme death from fourth weapon
			Health = -5000;
		}
		Died(source);
		return;
	}
	if ((P_Random() < PainChance) && !bSkullFly)
	{
		if (inflictor && (inflictor.Class == LightningFloor
				|| inflictor.Class == LightningZap))
		{
			if (P_Random() < 96)
			{
				bJustHit = true;	// fight back!
				SetState(PainState);
			}
			else
			{
				// "electrocute" the target
				SpriteFrame |= FF_FULLBRIGHT;
				if (bCountKill && P_Random() < 128
					&& !GetSoundPlayingInfo(self, GetSoundID('PuppyBeat')))
				{
					if ((Class == Centaur) ||
						(Class == CentaurLeader) ||
						(Class == Ettin))
					{
						PlaySound('PuppyBeat', CHAN_VOICE);
					}
				}
			}
		}
		else
		{
			bJustHit = true;	// fight back!
			SetState(PainState);
			if (inflictor && inflictor.Class == PoisonCloud)
			{
				if (bCountKill && P_Random() < 128
					&& !GetSoundPlayingInfo(self, GetSoundID('PuppyBeat')))
				{
					if ((Class == Centaur) ||
						(Class == CentaurLeader) ||
						(Class == Ettin))
					{
						PlaySound('PuppyBeat', CHAN_VOICE);
					}
				}
			}
		}
	}
	//FIXME
	if (!Pawn(self))
	{
		return;
	}
	Pawn(self).ReactionCount = 0;	// we're awake now...
	if (!Pawn(self).Threshold && source && !source.bBoss &&
		!(Class == Bishop) && !(Class == Minotaur))
	{
		// Target actor is not intent on another actor,
		// so make him chase after source
		if ((Class == Centaur && source.Class == CentaurLeader) ||
			(Class == CentaurLeader && source.Class == Centaur))
		{
			return;
		}
		Enemy = source;
		Pawn(self).Threshold = BASETHRESHOLD;
		if (StateNum == IdleState && SeeState != S_NULL)
		{
			SetState(SeeState);
		}
	}
}

//==========================================================================
//
//  Actor::FallingDamage
//
//==========================================================================

void Actor::FallingDamage(void)
{
	int damage;
	float mom;
	float dist;

	mom = fabs(Velocity.z);
	dist = mom / 35.0 * 16.0 / 23.0;

	if (mom >= 63.0 * 35.0)
	{
		// automatic death
		Damage(none, none, 10000);
		return;
	}
	damage = ftoi(dist * dist / 10.0) - 24;
	if (Velocity.z > -39.0 * 35.0 && damage > Health && Health != 1)
	{
		// No-death threshold
		damage = Health - 1;
	}
	PlaySound('PlayerLand', CHAN_BODY);
	Damage(none, none, damage);
}

//==========================================================================
//
//  Actor::PoisonPlayer - Sets up all data concerning poisoning
//
//==========================================================================

void Actor::PoisonPlayer(Actor poisoner, int poison)
{
	if ((Player->Cheats & CF_GODMODE) || Player->Powers[pw_invulnerability])
	{
		return;
	}
	Player->PoisonCount += poison;
	Player->Poisoner = &poisoner;
	if (Player->PoisonCount > 100)
	{
		Player->PoisonCount = 100;
	}
}

//==========================================================================
//
//  Actor::PoisonDamage
//
//  Similar to Actor::Damage
//
//==========================================================================

void Actor::PoisonDamage(Actor source, int damage, boolean playPainSound)
{
	Actor inflictor;

	inflictor = source;
	if (Health <= 0)
	{
		return;
	}
	if (bInvulnerable && damage < 10000)
	{	// mobj is invulnerable
		return;
	}
	if (bIsPlayer && gameskill == sk_baby)
	{
		// Take half damage in trainer mode
		damage >>= 1;
	}
	if (damage < 1000 && ((Player->Cheats & CF_GODMODE)
			|| Player->Powers[pw_invulnerability]))
	{
		return;
	}
	if (damage >= Player->Health && ((gameskill == sk_baby) || deathmatch) &&
		!Player->MorphTics)
	{
		// Try to use some inventory health
		AutoUseHealth(damage - Player->Health + 1);
	}
	Player->Health -= damage;	// mirror mobj health here for Dave
	if (Player->Health < 0)
	{
		Player->Health = 0;
	}
	Player->Attacker = &source;

	//
	// do the damage
	//
	Health -= damage;
	if (Health <= 0)
	{
		// Death
		_Special1 = damage;
		if (bIsPlayer && inflictor && !Player->MorphTics)
		{
			// Check for flame death
			if (inflictor.bFireDamage && (Health > -50) && (damage > 25))
			{
				bFireDamage = true;
			}
			if (inflictor.bIceDamage)
			{
				bIceDamage = true;
			}
		}
		Died(source);
		return;
	}
	if (!(level->tictime & 63) && playPainSound)
	{
		SetState(PainState);
	}
}

//==========================================================================
//
//  SpawnPuff
//
//==========================================================================

void SpawnPuff(TVec org)
{
	Actor puff;

	org.z += (Random() - Random()) * 4.0;
	puff = Spawn(PuffType, org);
	if (linetarget && puff.SightSound)
	{
		// Hit thing sound
		puff.PlaySound(puff.SightSound, CHAN_VOICE);
	}
	else if (puff.AttackSound)
	{
		puff.PlaySound(puff.AttackSound, CHAN_VOICE);
	}
	switch (PuffType)
	{
	case PunchPuff:
		puff.Velocity.z = 1.0 * 35.0;
		break;
	case HammerPuff:
		puff.Velocity.z = 8.0 / 10.0 * 35.0;
		break;
	}
	PuffSpawned = puff;
}

//==========================================================================
//
//  Actor::SpawnBloodSplatter
//
//==========================================================================

void Actor::SpawnBloodSplatter(TVec org)
{
	Actor mo;

	mo = Spawn(BloodSplatter, org);
	mo.Instigator = self;
	mo.Velocity.x = (Random() - Random()) * 4.0 * 35.0;
	mo.Velocity.y = (Random() - Random()) * 4.0 * 35.0;
	mo.Velocity.z = 3.0 * 35.0;
}

//===========================================================================
//
//  Actor::SpawnBloodSplatter2
//
//===========================================================================

void Actor::SpawnBloodSplatter2(TVec org)
{
	Actor mo;

	org.x += (Random() - 0.5) * 8.0;
	org.y += (Random() - 0.5) * 8.0;
	mo = Spawn(AxeBlood, org);
	mo.Instigator = self;
}

//==========================================================================
//
//  Actor::SpawnRipperBlood
//
//==========================================================================

void Actor::SpawnRipperBlood(void)
{
	Actor th;
	TVec org;

	org.x = Origin.x + (Random() - Random()) * 16.0;
	org.y = Origin.y + (Random() - Random()) * 16.0;
	org.z = Origin.z + (Random() - Random()) * 16.0;
	th = Spawn(Blood, org);
	th.Velocity.x = Velocity.x / 2.0;
	th.Velocity.y = Velocity.y / 2.0;
	th.StateTime += Random() * 0.1;
}

//============================================================================
//
//  Actor::SpawnDirt
//
//  Dirt stuff
//
//============================================================================

void Actor::SpawnDirt(float radius)
{
	float angle;
	TVec org;
	classid dtype;
	Actor dirt;

	angle = 360.0 * Random();
	org.x = Origin.x + radius * cos(angle);
	org.y = Origin.y + radius * sin(angle);
	org.z = Origin.z + Random() * 2.0 + 1.0;
	switch (P_Random() % 6)
	{
	case 0:
		dtype = Dirt1;
		break;
	case 1:
		dtype = Dirt2;
		break;
	case 2:
		dtype = Dirt3;
		break;
	case 3:
		dtype = Dirt4;
		break;
	case 4:
		dtype = Dirt5;
		break;
	case 5:
		dtype = Dirt6;
		break;
	}
	dirt = Spawn(dtype, org);
	if (dirt)
	{
		dirt.Velocity.z = Random() * 4.0 * 35.0;
	}
}

//==========================================================================
//
//  G_PlayerReborn
//
//  Called after a player dies almost everything is cleared and initialized
//
//==========================================================================

void G_PlayerReborn(int player)
{
	player_t *p;
	BotPlayer B;

	p = &players[player];

	B = p->Bot;
	ClearPlayer(p);
	p->Bot = B;

	p->PClass = p->BaseClass;

	p->bUseDown = true;	// don't do anything immediately
	p->bAttackDown = true;
	p->PlayerState = PST_LIVE;
	p->Health = MAXHEALTH;
	p->WeaponOwned[WP_FIRST] = true;
	SetWeapon(p, WP_FIRST);
	p->LocalQuakeHappening = 0;

	p->InvPtr = 0;	// reset the inventory pointer
	p->InvCurPos = 0;
}

//==========================================================================
//
//  P_SpawnPlayer
//
//  Called when a player is spawned on the level.  Most of the player
// structure stays unchanged between levels.
//
//==========================================================================

void P_SpawnPlayer(mthing_t * mthing)
{
	player_t *p;
	float x, y, z;
	PlayerPawn pp;

	p = &players[mthing->type - 1];
	if (!p->bActive)
	{
		// Not playing
		return;
	}

	if (p->PlayerState == PST_REBORN)
	{
		G_PlayerReborn(mthing->type - 1);
	}
	if (randomclass && deathmatch)
	{
		p->PClass = P_Random() % 3;
		if (p->PClass == p->BaseClass)
		{
			p->PClass = (p->PClass + 1) % 3;
		}
		p->BaseClass = p->PClass;
		SB_Start();
	}
	else
	{
		p->PClass = p->BaseClass;
	}
	x = mthing->x;
	y = mthing->y;
	z = ONFLOORZ;
	switch (p->PClass)
	{
	case PCLASS_FIGHTER:
		pp = PlayerPawn(Spawn(PlayerFighter, vector(x, y, z)));
		break;
	case PCLASS_CLERIC:
		pp = PlayerPawn(Spawn(PlayerCleric, vector(x, y, z)));
		break;
	case PCLASS_MAGE:
		pp = PlayerPawn(Spawn(PlayerMage, vector(x, y, z)));
		break;
	default:
		Error("P_SpawnPlayer: Unknown class type");
		break;
	}

	pp.Angles.yaw = itof(45 * (mthing->angle / 45));
	pp.Player = p;
	pp.bIsPlayer = true;
	pp.Health = p->Health;
	p->MO = pp;
	p->PlayerState = PST_LIVE;
	p->Refire = 0;
	p->DamageCount = 0;
	p->BonusCount = 0;
	p->PoisonCount = 0;
	p->MorphTics = 0;
	p->ExtraLight = 0;
	p->FixedColormap = 0;
	p->ViewHeight = VIEWHEIGHT;
	p->ViewAngles = pp.Angles;
	p->bFixAngle = true;
	SetupPsprites(p);
	if (deathmatch)
	{
		// Give all keys in death match mode
		p->Keys = 2047;
	}

	// Set translation table data
	SetPlayerColor(p);
	if (p->bIsBot)
	{
		p->Bot.OnSpawn();
	}
}

//==========================================================================
//
// P_SpawnMapThing
//
// The fields of the mapthing should already be in host byte order.
//
//==========================================================================

void P_SpawnMapThing(mthing_t * mthing, boolean spawn_thinkers)
{
	int i;
	int spawnMask;
	Actor A;

	if (mthing->type <= 0)
		return;

	// Count deathmatch start positions
	if (mthing->type == 11)
	{
		if (level->numdeathmatchstarts < MAXDEATHMATCHSTARTS)
		{
			CopyMThing(mthing,
				&level->deathmatchstarts[level->numdeathmatchstarts]);
			level->numdeathmatchstarts++;
		}
		return;
	}
	if (mthing->type == PO_SPAWN_TYPE || mthing->type == PO_SPAWNCRUSH_TYPE)
	{
		// Polyobj StartSpot Pt.
		SpawnPolyobj(mthing->x, mthing->y, mthing->angle,
			(mthing->type == PO_SPAWNCRUSH_TYPE));
		return;
	}
	if (mthing->type == PO_ANCHOR_TYPE)
	{
		// Polyobj Anchor Pt.
		AddAnchorPoint(mthing->x, mthing->y, mthing->angle);
		return;
	}

	// Check for player starts 1 to 4
	if (mthing->type <= 4)
	{
		CopyMThing(mthing,
			&level->playerstarts[mthing->arg1 * MAXPLAYERS + mthing->type -
				1]);
		return;
	}
	// Check for player starts 5 to 8
	if (mthing->type >= 9100 && mthing->type <= 9103)
	{
		mthing->type = 5 + mthing->type - 9100;	// Translate to 5 - 8
		CopyMThing(mthing,
			&level->playerstarts[mthing->arg1 * MAXPLAYERS + mthing->type -
				1]);
		return;
	}

	if (mthing->type >= 1400 && mthing->type < 1410)
	{
		PointInSubsector(mthing->x,
			mthing->y)->sector->seqType = mthing->type - 1400;
		return;
	}

	//  Don't spawn thinkers if we are loading a savegame
	if (!spawn_thinkers)
	{
		return;
	}

	// Check current game type with spawn flags
	if (netgame == false)
	{
		spawnMask = MTF_GSINGLE;
	}
	else if (deathmatch)
	{
		spawnMask = MTF_GDEATHMATCH;
	}
	else
	{
		spawnMask = MTF_GCOOP;
	}
	if (!(mthing->options & spawnMask))
	{
		return;
	}

	// Check current skill with spawn flags
	if (gameskill == sk_baby || gameskill == sk_easy)
	{
		spawnMask = MTF_EASY;
	}
	else if (gameskill == sk_hard || gameskill == sk_nightmare)
	{
		spawnMask = MTF_HARD;
	}
	else
	{
		spawnMask = MTF_NORMAL;
	}
	if (!(mthing->options & spawnMask))
	{
		return;
	}

	// Check current character classes with spawn flags
	if (!netgame)
	{
		// Single player
		if (!(mthing->options & classFlags[GetCvar("Class")]))
		{
			// Not for current class
			return;
		}
	}
#if 0	//  Because of client/server and in-game joining we can't do this
	else if (!deathmatch)
	{
		// Cooperative
		spawnMask = 0;
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				spawnMask |= classFlags[PlayerClass[i]];
			}
		}
		if (!(mthing->options & spawnMask))
		{
			return;
		}
	}
#endif

	// Find which type to spawn
	for (i = 0; i < num_mobj_types; i++)
	{
		if (mthing->type == mobjinfo[i].doomednum)
		{
			A = Actor(NewMobjThinker(mobjinfo[i].class_id));
			A.OnMapSpawn(mthing);
			return;
		}
	}
	// Can't find thing type
	dprint("P_SpawnMapThing: Unknown type %i at (%f, %f)\n",
		mthing->type, mthing->x, mthing->y);
}

//==========================================================================
//
// P_CreateTIDList
//
//==========================================================================

void P_CreateTIDList(void)
{
	int i;
	Actor mobj;

	i = 0;
	FOREACH(Actor, mobj)
	{
		if (mobj.TID != 0)
		{
			// Add to list
			if (i == MAX_TID_COUNT)
			{
				Error("P_CreateTIDList: MAX_TID_COUNT exceeded.");
			}
			TIDList[i] = mobj.TID;
			TIDMobj[i++] = mobj;
		}
	}
	// Add termination marker
	TIDList[i] = 0;
}

//==========================================================================
//
//	Actor::InsertIntoTIDList
//
//==========================================================================

void Actor::InsertIntoTIDList(int tid)
{
	int i;
	int index;

	index = -1;
	for (i = 0; TIDList[i] != 0; i++)
	{
		if (TIDList[i] == -1)
		{
			// Found empty slot
			index = i;
			break;
		}
	}
	if (index == -1)
	{
		// Append required
		if (i == MAX_TID_COUNT)
		{
			Error("P_InsertMobjIntoTIDList: MAX_TID_COUNT exceeded.");
		}
		index = i;
		TIDList[index + 1] = 0;
	}
	TID = tid;
	TIDList[index] = tid;
	TIDMobj[index] = self;
}

//==========================================================================
//
//	Actor::RemoveFromTIDList
//
//==========================================================================

void Actor::RemoveFromTIDList(void)
{
	int i;

	for (i = 0; TIDList[i] != 0; i++)
	{
		if (TIDMobj[i] == self)
		{
			TIDList[i] = -1;
			TIDMobj[i] = none;
			TID = 0;
			return;
		}
	}
	TID = 0;
}

//==========================================================================
//
//	FindMobjFromTID
//
//==========================================================================

Actor FindMobjFromTID(int tid, int *searchPosition)
{
	int i;

	for (i = *searchPosition + 1; TIDList[i] != 0; i++)
	{
		if (TIDList[i] == tid)
		{
			*searchPosition = i;
			return TIDMobj[i];
		}
	}
	*searchPosition = -1;
	return none;
}

//**************************************************************************
//
//      NOISE ALERT
//
//**************************************************************************

Actor soundtarget;

//==========================================================================
//
//  RecursiveSound
//
//  Called by NoiseAlert. Recursively traverse adjacent sectors, sound
// blocking lines cut off traversal.
//
//==========================================================================

void RecursiveSound(sector_t * sec, int soundblocks)
{
	int i;
	line_t *check;
	sector_t *other;

	// wake up all monsters in this sector
	if (sec->validcount == *validcount &&
		sec->soundtraversed <= soundblocks + 1)
	{
		return;	// already flooded
	}

	sec->validcount = *validcount;
	sec->soundtraversed = soundblocks + 1;
	sec->SoundTarget = soundtarget;

	for (i = 0; i < sec->linecount; i++)
	{
		check = sec->lines[i];
		if (!(check->flags & ML_TWOSIDED))
			continue;

		if (!LineOpenings(check, *check->v1))
		{
			if (!LineOpenings(check, *check->v2))
				continue;	// closed door
		}

		if (level->sides[check->sidenum[0]].sector == sec)
			other = level->sides[check->sidenum[1]].sector;
		else
			other = level->sides[check->sidenum[0]].sector;

		if (check->flags & ML_SOUNDBLOCK)
		{
			if (!soundblocks)
				RecursiveSound(other, 1);
		}
		else
			RecursiveSound(other, soundblocks);
	}
}

//==========================================================================
//
//  NoiseAlert
//
//  If a monster yells at a player, it will alert other monsters to the
// player.
//
//==========================================================================

void NoiseAlert(Actor target, Actor emmiter)
{
	soundtarget = target;
	(*validcount)++;
	RecursiveSound(emmiter.Sector, 0);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.43  2002/06/14 15:47:53  dj_jl
//  Added state names to the states.
//
//  Revision 1.42  2002/05/18 17:00:00  dj_jl
//  Renamed SpawnState to IdleState, other changes.
//
//  Revision 1.41  2002/03/28 18:15:35  dj_jl
//  Renamed mo in player_t to MO.
//
//  Revision 1.40  2002/03/16 17:47:47  dj_jl
//  Got rid of mobj_t and some other legacy.
//
//  Revision 1.39  2002/03/12 19:19:16  dj_jl
//  Pickup classes
//
//  Revision 1.38  2002/03/09 17:57:02  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.37  2002/03/04 18:31:36  dj_jl
//  Replaced bNoClip with two seperate flags, beautification.
//
//  Revision 1.36  2002/03/02 18:00:15  dj_jl
//  Some smaller changes, beautification.
//
//  Revision 1.35  2002/02/26 17:49:49  dj_jl
//  no message
//
//  Revision 1.34  2002/02/22 18:00:22  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.33  2002/02/16 16:26:55  dj_jl
//  Removed precalculated sound IDs
//
//  Revision 1.32  2002/02/14 19:20:58  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.31  2002/02/09 18:13:46  dj_jl
//  Added flags that determines what line blocking flags to check
//
//  Revision 1.30  2002/02/07 18:50:09  dj_jl
//  Made CheckPosition shared.
//
//  Revision 1.29  2002/02/06 17:28:53  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.28  2002/02/02 19:17:26  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.27  2002/01/28 18:50:19  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.26  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.25  2002/01/24 18:19:26  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.24  2002/01/17 18:15:54  dj_jl
//  Renamed all map object classes
//
//  Revision 1.23  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.22  2002/01/12 18:00:47  dj_jl
//  Sound names initialized as names
//
//  Revision 1.21  2002/01/11 18:19:42  dj_jl
//  Started to use names in progs
//
//  Revision 1.20  2002/01/07 12:25:57  dj_jl
//  Changed copyright year
//
//  Revision 1.19  2001/12/27 17:52:23  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.18  2001/12/12 18:57:42  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.17  2001/12/04 18:40:22  dj_jl
//  Some fixes
//
//  Revision 1.16  2001/12/01 18:14:09  dj_jl
//  Changed MSG_Select, beautification
//
//  Revision 1.15  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.14  2001/10/27 07:40:58  dj_jl
//  Switched some functions into class members
//
//  Revision 1.13  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.12  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.11  2001/10/09 17:41:17  dj_jl
//  Beautification
//
//  Revision 1.10  2001/10/02 17:42:38  dj_jl
//  Possibility to declare function's code inside class declaration
//
//  Revision 1.9  2001/09/27 17:08:19  dj_jl
//  Removed spawn functions, added mobj classes
//
//  Revision 1.8  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.7  2001/09/20 16:20:00  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.6  2001/08/31 17:17:23  dj_jl
//  Removed vector macros
//  
//  Revision 1.5  2001/08/30 17:33:17  dj_jl
//  Added sound channels
//  
//  Revision 1.4  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.3  2001/07/31 16:59:30  dj_jl
//  Set model when spawning object
//
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
