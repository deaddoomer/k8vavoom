//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

//============================================================================
//
// Minotaur variables
//
//  specialmobj1    pointer to player that spawned it (mobj_t)
//  special2        internal to minotaur AI
//  args[0]         minotaur start time
//  args[4]         charge duration countdown
//
//============================================================================

// MACROS ------------------------------------------------------------------

#define MINOTAUR_LOOK_DIST		(16.0 * 54.0)
#define MNTR_CHARGE_SPEED		805.0

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  Actor::A_Summon
//
//  Summon Minotaur
//
//==========================================================================

void Actor::A_Summon(void)
{
	mobj_t *mo;
	mobj_t *master;

	mo = P_SpawnMobj(origin.x, origin.y, origin.z, MT_MINOTAUR);
	if (mo)
	{
		if (P_TestMobjLocation(mo) == false || !specialmobj1)
		{
			// Didn't fit - change back to artifact
			SetMobjState(mo, S_NULL);
			mo = P_SpawnMobj(origin.x, origin.y, origin.z, MT_SUMMONMAULATOR);
			if (mo)
				mo->flags2 |= MF2_DROPPED;
			return;
		}

		mo->args[0] = level->tictime;
		master = specialmobj1;
		if (master->flags & MF_CORPSE)
		{
			// Master dead
			mo->specialmobj1 = NULL;	// No master
		}
		else
		{
			mo->specialmobj1 = specialmobj1;	// Pointer to master (mobj_t *)
			P_GivePower(master->player, pw_minotaur);
		}

		// Make smoke puff
		P_SpawnMobj(origin.x, origin.y, origin.z, MT_MNTRSMOKE);
		StartSoundName(this, "MaulatorActive", CHAN_VOICE);
	}
}

//============================================================================
//
//  Actor::A_MinotaurLook
//
//  Look for enemy of player
//
//============================================================================

void Actor::A_MinotaurLook(void)
{
	mobj_t *mo = NULL;
	float dist;
	int i;
	mobj_t *master = specialmobj1;

	target = NULL;

	if (deathmatch)	// Quick search for players
	{
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (!players[i].spawned)
				continue;
			mo = players[i].mo;
			if (mo == master)
				continue;
			if (mo->health <= 0)
				continue;
			dist = MobjDist(this, mo);
			if (dist > MINOTAUR_LOOK_DIST)
				continue;
			target = mo;
			break;
		}
	}

	if (!target)	// Near player monster search
	{
		if (master && (master->health > 0) && (master->player))
			mo = P_RoughMonsterSearch(master, 20);
		else
			mo = P_RoughMonsterSearch(this, 20);
		target = mo;
	}

	if (!target)	// Normal monster search
	{
		for (mo = NextMobj(NULL); mo; mo = NextMobj(mo))
		{
			if (!(mo->flags & MF_COUNTKILL))
				continue;
			if (mo->health <= 0)
				continue;
			if (!(mo->flags & MF_SHOOTABLE))
				continue;
			dist = MobjDist(this, mo);
			if (dist > MINOTAUR_LOOK_DIST)
				continue;
			if ((mo == master) || (mo == this))
				continue;
			if ((mo->Class == MT_MINOTAUR) &&
				(mo->specialmobj1 == specialmobj1)) continue;
			target = mo;
			break;	// Found mobj to attack
		}
	}

	if (target)
	{
		SetMobjStateNF(this, S_MNTR_WALK1);
	}
	else
	{
		SetMobjStateNF(this, S_MNTR_ROAM1);
	}
}

//============================================================================
//
//  Actor::A_MinotaurChase
//
//============================================================================

void Actor::A_MinotaurChase(void)
{
	int starttime = args[0];

	translucency = 0;	// In case pain caused him to skip his fade in.

	if ((level->tictime - starttime) >= ftoi(MAULATORTIME * 35.0))
	{
		Damage(NULL, NULL, 10000);
		return;
	}

	if (P_Random() < 30)
		A_MinotaurLook();	// adjust to closest target

	if (!target || (target->health <= 0) || !(target->flags & MF_SHOOTABLE))
	{
		// look for a new target
		SetMobjState(this, S_MNTR_LOOK1);
		return;
	}

	FaceMovementDirection(this);
	reactiontime = 0;

	// Melee attack
	if (meleestate && CheckMeleeRange(this))
	{
		if (sound_attack)
		{
			StartSound(this, sound_attack, CHAN_WEAPON);
		}
		SetMobjState(this, meleestate);
		return;
	}

	// Missile attack
	if (missilestate && CheckMissileRange(this))
	{
		SetMobjState(this, missilestate);
		return;
	}

	// chase towards target
	if (!P_Move(this))
	{
		P_NewChaseDir(this);
	}

	// Active sound
	if (sound_active && P_Random() < 6)
	{
		StartSound(this, sound_active, CHAN_VOICE);
	}

}

//============================================================================
//
//  Actor::A_MinotaurRoam
//
//============================================================================

void Actor::A_MinotaurRoam(void)
{
	int starttime = args[0];

	translucency = 0;	// In case pain caused him to skip his fade in.

	if ((level->tictime - starttime) >= ftoi(MAULATORTIME * 35.0))
	{
		Damage(NULL, NULL, 10000);
		return;
	}

	if (P_Random() < 30)
		A_MinotaurLook();	// adjust to closest target

	if (P_Random() < 6)
	{
		//Choose new direction
		movedir = P_Random() % 8;
		FaceMovementDirection(this);
	}
	if (!P_Move(this))
	{
		// Turn
		if (P_Random() & 1)
			movedir = (++movedir) % 8;
		else
			movedir = (movedir + 7) % 8;
		FaceMovementDirection(this);
	}
}

//============================================================================
//
//  Actor::A_MinotaurAtk1
//
//  Melee attack.
//
//============================================================================

void Actor::A_MinotaurAtk1(void)
{
	if (!target)
	{
		return;
	}

	StartSoundName(this, "MaulatorHamSwing", CHAN_WEAPON);
	if (CheckMeleeRange(this))
	{
		target->Damage(this, this, HITDICE(4));
	}
}

//============================================================================
//
//  Actor::A_MinotaurDecide
//
//  Choose a missile attack.
//
//============================================================================

void Actor::A_MinotaurDecide(void)
{
	float dist;

	if (!target)
		return;
	dist = MobjDist(this, target);

	if (target->origin.z + target->height > origin.z &&
		target->origin.z + target->height < origin.z + height &&
		dist < 16.0 * 64.0 && dist > 1.0 * 64.0 && P_Random() < 230)
	{
		// Charge attack
		// Don't call the state function right away
		SetMobjStateNF(this, S_MNTR_ATK4_1);
		flags |= MF_SKULLFLY;
		A_FaceTarget();
		velocity = Normalize(target->origin - origin) * MNTR_CHARGE_SPEED;
		args[4] = 35 / 2;	// Charge duration
	}
	else if (target->origin.z == target->floorz &&
		dist < 9.0 * 64.0 && P_Random() < 100)
	{
		// Floor fire attack
		SetMobjState(this, S_MNTR_ATK3_1);
		special2 = 0;
	}
	else
	{
		// Swing attack
		A_FaceTarget();
		// Don't need to call SetMobjState because the current state
		// falls through to the swing attack
	}
}

//============================================================================
//
//  Actor::A_MinotaurAtk2
//
//  Swing attack.
//
//============================================================================

void Actor::A_MinotaurAtk2(void)
{
	mobj_t *mo;
	float angle;
	float momz;

	if (!target)
		return;

	StartSoundName(this, "MaulatorHamSwing", CHAN_WEAPON);
	if (CheckMeleeRange(this))
	{
		target->Damage(this, this, HITDICE(3));
		return;
	}
	mo = SpawnMissile(this, target, MT_MNTRFX1);
	if (mo)
	{
		//StartSoundName(mo, sfx_minat2);
		momz = mo->velocity.z * frametime;
		angle = mo->angles.yaw;
		SpawnMissileAngle(this, MT_MNTRFX1,
			AngleMod360(angle - (45.0 / 8.0)), momz);
		SpawnMissileAngle(this, MT_MNTRFX1,
			AngleMod360(angle + (45.0 / 8.0)), momz);
		SpawnMissileAngle(this, MT_MNTRFX1,
			AngleMod360(angle - (45.0 / 16.0)), momz);
		SpawnMissileAngle(this, MT_MNTRFX1,
			AngleMod360(angle + (45.0 / 16.0)), momz);
	}
}

//============================================================================
//
//  Actor::A_MinotaurAtk3
//
//  Floor fire attack.
//
//============================================================================

void Actor::A_MinotaurAtk3(void)
{
	mobj_t *mo;

	if (!target)
	{
		return;
	}
	if (CheckMeleeRange(this))
	{
		target->Damage(this, this, HITDICE(3));
		if (target->player)
		{
			// Squish the player
			target->player->deltaviewheight = -16.0;
		}
	}
	else
	{
		mo = SpawnMissile(this, target, MT_MNTRFX2);
		if (mo != NULL)
		{
			StartSoundName(mo, "MaulatorHamHit", CHAN_VOICE);
		}
	}
	if (P_Random() < 192 && special2 == 0)
	{
		SetMobjState(this, S_MNTR_ATK3_4);
		special2 = 1;
	}
}

//============================================================================
//
//  Actor::A_MinotaurCharge
//
//============================================================================

void Actor::A_MinotaurCharge(void)
{
	mobj_t *puff;

	if (!target)
		return;

	if (args[4] > 0)
	{
		puff = P_SpawnMobj(origin.x, origin.y, origin.z, MT_PUNCHPUFF);
		puff->velocity.z = 2.0 * 35.0;
		args[4]--;
	}
	else
	{
		flags &= ~MF_SKULLFLY;
		SetMobjState(this, seestate);
	}
}

//============================================================================
//
//  Actor::A_MinotaurFade0
//
//============================================================================

void Actor::A_MinotaurFade0(void)
{
	translucency = 66;
}

//============================================================================
//
//  Actor::A_MinotaurFade1
//
//============================================================================

void Actor::A_MinotaurFade1(void)
{
	// Second level of transparency
	translucency = 33;
}

//============================================================================
//
//  Actor::A_MinotaurFade2
//
//============================================================================

void Actor::A_MinotaurFade2(void)
{
	// Make fully visible
	translucency = 0;
}

//============================================================================
//
//  Actor::A_MntrFloorFire
//
//============================================================================

void Actor::A_MntrFloorFire(void)
{
	mobj_t *mo;

	origin.z = floorz;
	mo = P_SpawnMobj(origin.x + (Random() - Random()) * 4.0,
		origin.y + (Random() - Random()) * 4.0, ONFLOORZ, MT_MNTRFX3);
	mo->target = target;
	mo->velocity.x = 0.00001;	// Force block checking
	CheckMissileSpawn(mo);
}

//============================================================================
//
//  Actor::A_SmokePuffExit
//
//============================================================================

void Actor::A_SmokePuffExit(void)
{
	P_SpawnMobj(origin.x, origin.y, origin.z, MT_MNTRSMOKEEXIT);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.10  2001/12/27 17:52:23  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.9  2001/12/12 18:57:42  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.8  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.7  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.6  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.5  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.4  2001/08/31 17:17:23  dj_jl
//  Removed vector macros
//  
//  Revision 1.3  2001/08/30 17:33:17  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
