//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

//**************************************************************************
//
//	WeaponClericMace
//
//**************************************************************************

class WeaponClericMace:Weapon
{

//===========================================================================
//
//  A_CMaceAttack
//
//===========================================================================

void A_CMaceAttack(void)
{
	int damage;
	int i;
	TAVec angles;
	TVec vforward;

	damage = 25 + (P_Random() & 15);
	PuffType = HammerPuff;
	for (i = 0; i < 16; i++)
	{
		angles = Player->MO.Angles;
		angles.yaw = AngleMod360(angles.yaw + itof(i) * (45.0 / 16.0));
		AimLineAttack(Player->MO, &angles, 2.0 * MELEERANGE);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			if (LineAttack(Player->MO, vforward, 2.0 * MELEERANGE, damage))
			{
				Player->MO.PlaySound('FighterHammerMiss', CHAN_WEAPON);
			}
			PlayerPawn(Player->MO).AdjustPlayerAngle();
			return;
		}
		angles = Player->MO.Angles;
		angles.yaw = AngleMod360(angles.yaw - itof(i) * (45.0 / 16.0));
		AimLineAttack(Player->MO, &angles, 2.0 * MELEERANGE);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			if (LineAttack(Player->MO, vforward, 2.0 * MELEERANGE, damage))
			{
				Player->MO.PlaySound('FighterHammerMiss', CHAN_WEAPON);
			}
			PlayerPawn(Player->MO).AdjustPlayerAngle();
			return;
		}
	}
	// didn't find any creatures, so try to strike any walls
	avcpy(Player->MO.Angles, angles);
	AimLineAttack(Player->MO, &angles, MELEERANGE);
	AngleVector(&angles, &vforward);
	if (LineAttack(Player->MO, vforward, MELEERANGE, damage))
	{
		Player->MO.PlaySound('FighterHammerMiss', CHAN_WEAPON);
	}
}

__states__
{
	S_CMACEREADY('CMCE', 0, 1.0 / 35.0, S_CMACEREADY) { A_WeaponReady(); }
	S_CMACEDOWN('CMCE', 0, 1.0 / 35.0, S_CMACEDOWN) { A_Lower(); }
	S_CMACEUP('CMCE', 0, 1.0 / 35.0, S_CMACEUP) { A_Raise(); }
	S_CMACEATK_1('CMCE', 1, 2.0 / 35.0, S_CMACEATK_2) { SX = 60.0; SY = 20.0; }
	S_CMACEATK_2('CMCE', 1, 1.0 / 35.0, S_CMACEATK_3) { SX = 30.0; SY = 33.0; }
	S_CMACEATK_3('CMCE', 1, 2.0 / 35.0, S_CMACEATK_4) { SX = 8.0; SY = 45.0; }
	S_CMACEATK_4('CMCE', 2, 1.0 / 35.0, S_CMACEATK_5) { SX = 8.0; SY = 45.0; }
	S_CMACEATK_5('CMCE', 3, 1.0 / 35.0, S_CMACEATK_6) { SX = 8.0; SY = 45.0; }
	S_CMACEATK_6('CMCE', 4, 1.0 / 35.0, S_CMACEATK_7) { SX = 8.0; SY = 45.0; }
	S_CMACEATK_7('CMCE', 4, 1.0 / 35.0, S_CMACEATK_8) { SX = -11.0; SY = 58.0; A_CMaceAttack(); }
	S_CMACEATK_8('CMCE', 5, 1.0 / 35.0, S_CMACEATK_9) { SX = 8.0; SY = 45.0; }
	S_CMACEATK_9('CMCE', 5, 2.0 / 35.0, S_CMACEATK_10) { SX = -8.0; SY = 74.0; }
	S_CMACEATK_10('CMCE', 5, 1.0 / 35.0, S_CMACEATK_11) { SX = -20.0; SY = 96.0; }
	S_CMACEATK_11('CMCE', 5, 8.0 / 35.0, S_CMACEATK_12) { SX = -33.0; SY = 160.0; }
	S_CMACEATK_12('CMCE', 0, 2.0 / 35.0, S_CMACEATK_13) { SX = 8.0; SY = 75.0; A_ReFire(); }
	S_CMACEATK_13('CMCE', 0, 1.0 / 35.0, S_CMACEATK_14) { SX = 8.0; SY = 65.0; }
	S_CMACEATK_14('CMCE', 0, 2.0 / 35.0, S_CMACEATK_15) { SX = 8.0; SY = 60.0; }
	S_CMACEATK_15('CMCE', 0, 1.0 / 35.0, S_CMACEATK_16) { SX = 8.0; SY = 55.0; }
	S_CMACEATK_16('CMCE', 0, 2.0 / 35.0, S_CMACEATK_17) { SX = 8.0; SY = 50.0; }
	S_CMACEATK_17('CMCE', 0, 1.0 / 35.0, S_CMACEREADY) { SX = 8.0; SY = 45.0; }
}

defaultproperties
{
	Mana = MANA_NONE;
	UpState = S_CMACEUP;
	DownState = S_CMACEDOWN;
	ReadyState = S_CMACEREADY;
	AttackState = S_CMACEATK_1;
	HoldAttackState = S_CMACEATK_1;
	PSpriteSY = -8.0;
}

}

//**************************************************************************
//
//	ClericStaffMissile
//
//**************************************************************************

class ClericStaffMissile:Projectile
{

int WeaveXY;

//============================================================================
//
//  A_CStaffMissileSlither
//
//============================================================================

void A_CStaffMissileSlither(void)
{
	float newX, newY;
	float angle;

	angle = AngleMod360(Angles.yaw + 90.0);
	newX = Origin.x - cos(angle) * FloatBobOffsets[WeaveXY];
	newY = Origin.y - sin(angle) * FloatBobOffsets[WeaveXY];
	WeaveXY = (WeaveXY + 3) & 63;
	newX += cos(angle) * FloatBobOffsets[WeaveXY];
	newY += sin(angle) * FloatBobOffsets[WeaveXY];
	TryMove(vector(newX, newY, Origin.z));
}

__states__
{
	S_CSTAFF_MISSILE1('CSSF', 3 | FF_FULLBRIGHT, 1.0 / 35.0, S_CSTAFF_MISSILE2) { A_CStaffMissileSlither(); }
	S_CSTAFF_MISSILE2('CSSF', 3 | FF_FULLBRIGHT, 1.0 / 35.0, S_CSTAFF_MISSILE3) { A_CStaffMissileSlither(); }
	S_CSTAFF_MISSILE3('CSSF', 4 | FF_FULLBRIGHT, 1.0 / 35.0, S_CSTAFF_MISSILE4) { A_CStaffMissileSlither(); }
	S_CSTAFF_MISSILE4('CSSF', 4 | FF_FULLBRIGHT, 1.0 / 35.0, S_CSTAFF_MISSILE1) { A_CStaffMissileSlither(); }
	S_CSTAFF_MISSILE_X1('CSSF', 5 | FF_FULLBRIGHT, 4.0 / 35.0, S_CSTAFF_MISSILE_X2) { }
	S_CSTAFF_MISSILE_X2('CSSF', 6 | FF_FULLBRIGHT, 4.0 / 35.0, S_CSTAFF_MISSILE_X3) { }
	S_CSTAFF_MISSILE_X3('CSSF', 7 | FF_FULLBRIGHT, 3.0 / 35.0, S_CSTAFF_MISSILE_X4) { }
	S_CSTAFF_MISSILE_X4('CSSF', 8 | FF_FULLBRIGHT, 3.0 / 35.0, S_NULL) { }
}

defaultproperties
{
	Radius = 12.0;
	Height = 10.0;
	Speed = 770.0;
	MissileDamage = 5;
	IdleState = S_CSTAFF_MISSILE1;
	DeathState = S_CSTAFF_MISSILE_X1;
	DeathSound = 'ClericCStaffExplode';
	Effects = EF_DL_GREEN;
}

}

//**************************************************************************
//
//	ClericStaffPuff
//
//**************************************************************************

class ClericStaffPuff:Effect
{

__states__
{
	S_CSTAFFPUFF1('FHFX', 18, 4.0 / 35.0, S_CSTAFFPUFF2) { }
	S_CSTAFFPUFF2('FHFX', 19, 4.0 / 35.0, S_CSTAFFPUFF3) { }
	S_CSTAFFPUFF3('FHFX', 20, 4.0 / 35.0, S_CSTAFFPUFF4) { }
	S_CSTAFFPUFF4('FHFX', 21, 4.0 / 35.0, S_CSTAFFPUFF5) { }
	S_CSTAFFPUFF5('FHFX', 22, 4.0 / 35.0, S_NULL) { }
}

defaultproperties
{
	Translucency = 66;
	IdleState = S_CSTAFFPUFF1;
	SightSound = 'ClericCStaffHitThing';
}

}

//**************************************************************************
//
//	WeaponClericStaff
//
//**************************************************************************

class WeaponClericStaff:Weapon
{

int BlinkCount;
int BlinkState;
int Attack2State;

//============================================================================
//
//  A_CStaffInitBlink
//
//============================================================================

void A_CStaffInitBlink(void)
{
	BlinkCount = (P_Random() >> 1) + 20;
}

//============================================================================
//
//  A_CStaffCheckBlink
//
//============================================================================

void A_CStaffCheckBlink(void)
{
	if (!--BlinkCount)
	{
		SetState(BlinkState);
		BlinkCount = (P_Random() + 50) >> 2;
	}
}

//============================================================================
//
//  A_CStaffCheck
//
//============================================================================

void A_CStaffCheck(void)
{
	Actor pmo;
	int damage;
	int newLife;
	int i;
	TAVec angles;
	TVec vforward;

	pmo = Player->MO;
	damage = 20 + (P_Random() & 15);
	PuffType = ClericStaffPuff;
	for (i = 0; i < 3; i++)
	{
		angles = pmo.Angles;
		angles.yaw = AngleMod360(angles.yaw + itof(i) * (45.0 / 16.0));
		AimLineAttack(pmo, &angles, 3.0 * MELEERANGE / 2.0);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			LineAttack(pmo, vforward, 1.5 * MELEERANGE, damage);
			pmo.Angles.yaw = atan2(linetarget.Origin.y - pmo.Origin.y,
				linetarget.Origin.x - pmo.Origin.x);
			if ((linetarget.bIsPlayer || linetarget.bCountKill) &&
				!linetarget.bDormant && !linetarget.bInvulnerable)
			{
				newLife = Player->Health + (damage >> 3);
				newLife = newLife > 100 ? 100 : newLife;
				pmo.Health = newLife;
				Player->Health = newLife;
				SetState(Attack2State);
			}
			Player->Mana[MANA_1] -=
				WeaponManaUse(Player->PClass, Player->ReadyWeapon);
			break;
		}
		angles = pmo.Angles;
		angles.yaw = AngleMod360(angles.yaw - itof(i) * (45.0 / 16.0));
		AimLineAttack(Player->MO, &angles, 3.0 * MELEERANGE / 2.0);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			LineAttack(pmo, vforward, 1.5 * MELEERANGE, damage);
			pmo.Angles.yaw = atan2(linetarget.Origin.y - pmo.Origin.y,
				linetarget.Origin.x - pmo.Origin.x);
			if (linetarget.bIsPlayer || linetarget.bCountKill)
			{
				newLife = Player->Health + (damage >> 4);
				newLife = newLife > 100 ? 100 : newLife;
				pmo.Health = newLife;
				Player->Health = pmo.Health;
				SetState(Attack2State);
			}
			Player->Mana[MANA_1] -=
				WeaponManaUse(Player->PClass, Player->ReadyWeapon);
			break;
		}
	}
}

//============================================================================
//
//  A_CStaffAttack
//
//============================================================================

void A_CStaffAttack(void)
{
	Actor mo;
	PlayerPawn playPawn;

	Player->Mana[MANA_1] -=
		WeaponManaUse(Player->PClass, Player->ReadyWeapon);
	playPawn = PlayerPawn(Player->MO);
	mo = playPawn.SpawnPlayerMissileAngle(ClericStaffMissile,
		playPawn.Angles.yaw - (45.0 / 15.0));
	if (mo)
	{
		ClericStaffMissile(mo).WeaveXY = 32;
	}
	mo = playPawn.SpawnPlayerMissileAngle(ClericStaffMissile,
		playPawn.Angles.yaw + (45.0 / 15.0));
	if (mo)
	{
		ClericStaffMissile(mo).WeaveXY = 0;
	}
	playPawn.PlaySound('ClericCStaffFire', CHAN_WEAPON);
}

__states__
{
	S_CSTAFFREADY('CSSF', 2, 4.0 / 35.0, S_CSTAFFREADY1) { }
	S_CSTAFFREADY1('CSSF', 1, 3.0 / 35.0, S_CSTAFFREADY2) { A_CStaffInitBlink(); }
	S_CSTAFFREADY2('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY3) { A_WeaponReady(); }
	S_CSTAFFREADY3('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY4) { A_WeaponReady(); }
	S_CSTAFFREADY4('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY5) { A_WeaponReady(); }
	S_CSTAFFREADY5('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY6) { A_WeaponReady(); }
	S_CSTAFFREADY6('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY7) { A_WeaponReady(); }
	S_CSTAFFREADY7('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY8) { A_WeaponReady(); }
	S_CSTAFFREADY8('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY9) { A_WeaponReady(); }
	S_CSTAFFREADY9('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY2) { A_CStaffCheckBlink(); }
	S_CSTAFFBLINK1('CSSF', 1, 1.0 / 35.0, S_CSTAFFBLINK2) { A_WeaponReady(); }
	S_CSTAFFBLINK2('CSSF', 1, 1.0 / 35.0, S_CSTAFFBLINK3) { A_WeaponReady(); }
	S_CSTAFFBLINK3('CSSF', 1, 1.0 / 35.0, S_CSTAFFBLINK4) { A_WeaponReady(); }
	S_CSTAFFBLINK4('CSSF', 2, 1.0 / 35.0, S_CSTAFFBLINK5) { A_WeaponReady(); }
	S_CSTAFFBLINK5('CSSF', 2, 1.0 / 35.0, S_CSTAFFBLINK6) { A_WeaponReady(); }
	S_CSTAFFBLINK6('CSSF', 2, 1.0 / 35.0, S_CSTAFFBLINK7) { A_WeaponReady(); }
	S_CSTAFFBLINK7('CSSF', 2, 1.0 / 35.0, S_CSTAFFBLINK8) { A_WeaponReady(); }
	S_CSTAFFBLINK8('CSSF', 2, 1.0 / 35.0, S_CSTAFFBLINK9) { A_WeaponReady(); }
	S_CSTAFFBLINK9('CSSF', 1, 1.0 / 35.0, S_CSTAFFBLINK10) { A_WeaponReady(); }
	S_CSTAFFBLINK10('CSSF', 1, 1.0 / 35.0, S_CSTAFFBLINK11) { A_WeaponReady(); }
	S_CSTAFFBLINK11('CSSF', 1, 1.0 / 35.0, S_CSTAFFREADY2) { A_WeaponReady(); }
	S_CSTAFFDOWN('CSSF', 1, 3.0 / 35.0, S_CSTAFFDOWN2) { }
	S_CSTAFFDOWN2('CSSF', 2, 4.0 / 35.0, S_CSTAFFDOWN3) { }
	S_CSTAFFDOWN3('CSSF', 2, 1.0 / 35.0, S_CSTAFFDOWN3) { A_Lower(); }
	S_CSTAFFUP('CSSF', 2, 1.0 / 35.0, S_CSTAFFUP) { A_Raise(); }
	S_CSTAFFATK_1('CSSF', 0, 1.0 / 35.0, S_CSTAFFATK_2) { SY = 45.0; A_CStaffCheck(); }
	S_CSTAFFATK_2('CSSF', 9, 1.0 / 35.0, S_CSTAFFATK_3) { SY = 50.0; A_CStaffAttack(); }
	S_CSTAFFATK_3('CSSF', 9, 2.0 / 35.0, S_CSTAFFATK_4) { SY = 50.0; }
	S_CSTAFFATK_4('CSSF', 9, 2.0 / 35.0, S_CSTAFFATK_5) { SY = 45.0; }
	S_CSTAFFATK_5('CSSF', 0, 2.0 / 35.0, S_CSTAFFATK_6) { SY = 40.0; }
	S_CSTAFFATK_6('CSSF', 0, 2.0 / 35.0, S_CSTAFFREADY2) { SY = 36.0; }
	S_CSTAFFATK2_1('CSSF', 10, 10.0 / 35.0, S_CSTAFFREADY2) { SY = 36.0; }
}

defaultproperties
{
	Mana = MANA_1;
	UpState = S_CSTAFFUP;
	DownState = S_CSTAFFDOWN;
	ReadyState = S_CSTAFFREADY;
	BlinkState = S_CSTAFFBLINK1;
	AttackState = S_CSTAFFATK_1;
	HoldAttackState = S_CSTAFFATK_1;
	Attack2State = S_CSTAFFATK2_1;
	PSpriteSY = 10.0;
}

}

//**************************************************************************
//
//	CircleFlame
//
//**************************************************************************

class CircleFlame:Projectile
{

//============================================================================
//
//	A_CFlameRotate
//
//============================================================================

#define FLAMEROTSPEED	2.0 * 35.0

void A_CFlameRotate(void)
{
	float an;

	an = AngleMod360(Angles.yaw + 90.0);
	Velocity.x = Special1f + FLAMEROTSPEED * cos(an);
	Velocity.y = Special2f + FLAMEROTSPEED * sin(an);
	Angles.yaw = AngleMod360(Angles.yaw + 90.0 / 15.0);
}

__states__
{
	S_CIRCLE_FLAME1('CFCF', 0 | FF_FULLBRIGHT, 4.0 / 35.0, S_CIRCLE_FLAME2) { }
	S_CIRCLE_FLAME2('CFCF', 1 | FF_FULLBRIGHT, 2.0 / 35.0, S_CIRCLE_FLAME3) { A_CFlameRotate(); }
	S_CIRCLE_FLAME3('CFCF', 2 | FF_FULLBRIGHT, 2.0 / 35.0, S_CIRCLE_FLAME4) { }
	S_CIRCLE_FLAME4('CFCF', 3 | FF_FULLBRIGHT, 1.0 / 35.0, S_CIRCLE_FLAME5) { }
	S_CIRCLE_FLAME5('CFCF', 4 | FF_FULLBRIGHT, 2.0 / 35.0, S_CIRCLE_FLAME6) { }
	S_CIRCLE_FLAME6('CFCF', 5 | FF_FULLBRIGHT, 2.0 / 35.0, S_CIRCLE_FLAME7) { A_CFlameRotate(); }
	S_CIRCLE_FLAME7('CFCF', 6 | FF_FULLBRIGHT, 1.0 / 35.0, S_CIRCLE_FLAME8) { }
	S_CIRCLE_FLAME8('CFCF', 7 | FF_FULLBRIGHT, 2.0 / 35.0, S_CIRCLE_FLAME9) { }
	S_CIRCLE_FLAME9('CFCF', 8 | FF_FULLBRIGHT, 2.0 / 35.0, S_CIRCLE_FLAME10) { }
	S_CIRCLE_FLAME10('CFCF', 9 | FF_FULLBRIGHT, 1.0 / 35.0, S_CIRCLE_FLAME11) { A_CFlameRotate(); }
	S_CIRCLE_FLAME11('CFCF', 10 | FF_FULLBRIGHT, 2.0 / 35.0, S_CIRCLE_FLAME12) { }
	S_CIRCLE_FLAME12('CFCF', 11 | FF_FULLBRIGHT, 3.0 / 35.0, S_CIRCLE_FLAME13) { }
	S_CIRCLE_FLAME13('CFCF', 12 | FF_FULLBRIGHT, 3.0 / 35.0, S_CIRCLE_FLAME14) { }
	S_CIRCLE_FLAME14('CFCF', 13 | FF_FULLBRIGHT, 2.0 / 35.0, S_CIRCLE_FLAME15) { A_CFlameRotate(); }
	S_CIRCLE_FLAME15('CFCF', 14 | FF_FULLBRIGHT, 3.0 / 35.0, S_CIRCLE_FLAME16) { }
	S_CIRCLE_FLAME16('CFCF', 15 | FF_FULLBRIGHT, 2.0 / 35.0, S_NULL) { }
	S_CIRCLE_FLAME_X1('CFCF', 16 | FF_FULLBRIGHT, 3.0 / 35.0, S_CIRCLE_FLAME_X2) { }
	S_CIRCLE_FLAME_X2('CFCF', 17 | FF_FULLBRIGHT, 3.0 / 35.0, S_CIRCLE_FLAME_X3) { }
	S_CIRCLE_FLAME_X3('CFCF', 18 | FF_FULLBRIGHT, 3.0 / 35.0, S_CIRCLE_FLAME_X4) { A_Explode(); }
	S_CIRCLE_FLAME_X4('CFCF', 19 | FF_FULLBRIGHT, 3.0 / 35.0, S_CIRCLE_FLAME_X5) { }
	S_CIRCLE_FLAME_X5('CFCF', 20 | FF_FULLBRIGHT, 3.0 / 35.0, S_CIRCLE_FLAME_X6) { }
	S_CIRCLE_FLAME_X6('CFCF', 21 | FF_FULLBRIGHT, 3.0 / 35.0, S_CIRCLE_FLAME_X7) { }
	S_CIRCLE_FLAME_X7('CFCF', 22 | FF_FULLBRIGHT, 3.0 / 35.0, S_CIRCLE_FLAME_X8) { }
	S_CIRCLE_FLAME_X8('CFCF', 23 | FF_FULLBRIGHT, 3.0 / 35.0, S_CIRCLE_FLAME_X9) { }
	S_CIRCLE_FLAME_X9('CFCF', 24 | FF_FULLBRIGHT, 3.0 / 35.0, S_CIRCLE_FLAME_X10) { }
	S_CIRCLE_FLAME_X10('CFCF', 25 | FF_FULLBRIGHT, 3.0 / 35.0, S_NULL) { }
}

defaultproperties
{
	Radius = 6.0;
	Height = 16.0;
	MissileDamage = 2;
	bFireDamage = true;
	bActivateImpact = false;
	bActivatePCross = false;
	IdleState = S_CIRCLE_FLAME1;
	DeathState = S_CIRCLE_FLAME_X1;
	DeathSound = 'ClericFlameCircle';
	Effects = EF_DL_WHITE;
}

}

//**************************************************************************
//
//	ClericFlameFloor
//
//**************************************************************************

class ClericFlameFloor:Effect
{

__states__
{
	S_CFLAMEFLOOR1('CFFX', 13 | FF_FULLBRIGHT, 5.0 / 35.0, S_CFLAMEFLOOR2) { }
	S_CFLAMEFLOOR2('CFFX', 14 | FF_FULLBRIGHT, 4.0 / 35.0, S_CFLAMEFLOOR3) { }
	S_CFLAMEFLOOR3('CFFX', 15 | FF_FULLBRIGHT, 3.0 / 35.0, S_NULL) { }
}

defaultproperties
{
	IdleState = S_CFLAMEFLOOR1;
}

}

//**************************************************************************
//
//	FlamePuff
//
//	UNUSED
//
//**************************************************************************

class FlamePuff:Effect
{

__states__
{
	S_FLAMEPUFF1('CFFX', 0 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF2) { }
	S_FLAMEPUFF2('CFFX', 1 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF3) { }
	S_FLAMEPUFF3('CFFX', 2 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF4) { }
	S_FLAMEPUFF4('CFFX', 3 | FF_FULLBRIGHT, 4.0 / 35.0, S_FLAMEPUFF5) { }
	S_FLAMEPUFF5('CFFX', 4 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF6) { }
	S_FLAMEPUFF6('CFFX', 5 | FF_FULLBRIGHT, 4.0 / 35.0, S_FLAMEPUFF7) { }
	S_FLAMEPUFF7('CFFX', 6 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF8) { }
	S_FLAMEPUFF8('CFFX', 7 | FF_FULLBRIGHT, 4.0 / 35.0, S_FLAMEPUFF9) { }
	S_FLAMEPUFF9('CFFX', 8 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF10) { }
	S_FLAMEPUFF10('CFFX', 9 | FF_FULLBRIGHT, 4.0 / 35.0, S_FLAMEPUFF11) { }
	S_FLAMEPUFF11('CFFX', 10 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF12) { }
	S_FLAMEPUFF12('CFFX', 11 | FF_FULLBRIGHT, 4.0 / 35.0, S_FLAMEPUFF13) { }
	S_FLAMEPUFF13('CFFX', 12 | FF_FULLBRIGHT, 3.0 / 35.0, S_NULL) { }
}

defaultproperties
{
	Radius = 1.0;
	Height = 1.0;
	IdleState = S_FLAMEPUFF1;
	SightSound = 'ClericFlameExplode';
	AttackSound = 'ClericFlameExplode';
}

}

//**************************************************************************
//
//	FlamePuff2
//
//	UNUSED but checked in map.vc
//
//**************************************************************************

class FlamePuff2:Effect
{

__states__
{
	S_FLAMEPUFF2_1('CFFX', 0 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF2_2) { }
	S_FLAMEPUFF2_2('CFFX', 1 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF2_3) { }
	S_FLAMEPUFF2_3('CFFX', 2 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF2_4) { }
	S_FLAMEPUFF2_4('CFFX', 3 | FF_FULLBRIGHT, 4.0 / 35.0, S_FLAMEPUFF2_5) { }
	S_FLAMEPUFF2_5('CFFX', 4 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF2_6) { }
	S_FLAMEPUFF2_6('CFFX', 5 | FF_FULLBRIGHT, 4.0 / 35.0, S_FLAMEPUFF2_7) { }
	S_FLAMEPUFF2_7('CFFX', 6 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF2_8) { }
	S_FLAMEPUFF2_8('CFFX', 7 | FF_FULLBRIGHT, 4.0 / 35.0, S_FLAMEPUFF2_9) { }
	S_FLAMEPUFF2_9('CFFX', 8 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF2_10) { }
	S_FLAMEPUFF2_10('CFFX', 2 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF2_11) { }
	S_FLAMEPUFF2_11('CFFX', 3 | FF_FULLBRIGHT, 4.0 / 35.0, S_FLAMEPUFF2_12) { }
	S_FLAMEPUFF2_12('CFFX', 4 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF2_13) { }
	S_FLAMEPUFF2_13('CFFX', 5 | FF_FULLBRIGHT, 4.0 / 35.0, S_FLAMEPUFF2_14) { }
	S_FLAMEPUFF2_14('CFFX', 6 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF2_15) { }
	S_FLAMEPUFF2_15('CFFX', 7 | FF_FULLBRIGHT, 4.0 / 35.0, S_FLAMEPUFF2_16) { }
	S_FLAMEPUFF2_16('CFFX', 8 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF2_17) { }
	S_FLAMEPUFF2_17('CFFX', 9 | FF_FULLBRIGHT, 4.0 / 35.0, S_FLAMEPUFF2_18) { }
	S_FLAMEPUFF2_18('CFFX', 10 | FF_FULLBRIGHT, 3.0 / 35.0, S_FLAMEPUFF2_19) { }
	S_FLAMEPUFF2_19('CFFX', 11 | FF_FULLBRIGHT, 4.0 / 35.0, S_FLAMEPUFF2_20) { }
	S_FLAMEPUFF2_20('CFFX', 12 | FF_FULLBRIGHT, 3.0 / 35.0, S_NULL) { }
}

defaultproperties
{
	Radius = 1.0;
	Height = 1.0;
	IdleState = S_FLAMEPUFF2_1;
	SightSound = 'ClericFlameExplode';
	AttackSound = 'ClericFlameExplode';
}

}

//**************************************************************************
//
//	ClericFlameMissile
//
//**************************************************************************

class ClericFlameMissile:Projectile
{

//============================================================================
//
//	A_CFlamePuff
//
//============================================================================

void A_CFlamePuff(void)
{
	A_UnHideThing();
	Velocity = vector(0.0, 0.0, 0.0);
	PlaySound('ClericFlameExplode', CHAN_VOICE);
}

//============================================================================
//
//  A_CFlameMissile
//
//============================================================================

#define FLAMESPEED		(9.0 / 20.0 * 35.0)

void A_CFlameMissile(void)
{
	int i;
	float an;
	float dist;
	Actor A;
	Actor bmo;

	A_UnHideThing();
	PlaySound('ClericFlameExplode', CHAN_VOICE);
	bmo = tmtrace->BlockingMobj;
	if (bmo && bmo.bShootable)
	{
		// Hit something, so spawn the flame circle around the thing
		dist = bmo.Radius + 18.0;
		for (i = 0; i < 4; i++)
		{
			an = itof(i) * 45.0;
			A = Spawn(CircleFlame, bmo.Origin +
				vector(dist * cos(an), dist * sin(an), 5.0));
			if (A)
			{
				A.Angles.yaw = an;
				A.Instigator = Instigator;
				A.Velocity.x = FLAMESPEED * cos(an);
				A.Velocity.y = FLAMESPEED * sin(an);
				A.Special1f = A.Velocity.x;
				A.Special2f = A.Velocity.y;
				A.StateTime -= Random() * 0.1;
			}
			A = Spawn(CircleFlame, bmo.Origin +
				vector(-dist * cos(an), -dist * sin(an), 5.0));
			if (A)
			{
				A.Angles.yaw = AngleMod360(180.0 + an);
				A.Instigator = Instigator;
				A.Velocity.x = -FLAMESPEED * cos(an);
				A.Velocity.y = -FLAMESPEED * sin(an);
				A.Special1f = A.Velocity.x;
				A.Special2f = A.Velocity.y;
				A.StateTime -= Random() * 0.1;
			}
		}
		SetState(S_FLAMEPUFF2_1);
	}
}

__states__
{
	S_CFLAME_MISSILE1('CFFX', 0 | FF_FULLBRIGHT, 4.0 / 35.0, S_CFLAME_MISSILE2) { }
	S_CFLAME_MISSILE2('CFFX', 0, 1.0 / 35.0, S_FLAMEPUFF1) { A_CFlamePuff(); }
	S_CFLAME_MISSILE_X('CFFX', 0 | FF_FULLBRIGHT, 1.0 / 35.0, S_FLAMEPUFF1) { A_CFlameMissile(); }
}

defaultproperties
{
	Radius = 14.0;
	Height = 8.0;
	Speed = 7000.0;
	MissileDamage = 8;
	Translucency = 100;
	bFireDamage = true;
	bBlaster = true;
	IdleState = S_CFLAME_MISSILE1;
	DeathState = S_CFLAME_MISSILE_X;
	Effects = EF_DL_WHITE;
}

}

//**************************************************************************
//
//	WeaponClericFire
//
//**************************************************************************

class WeaponClericFire:Weapon
{

//============================================================================
//
//  A_CFlameAttack
//
//============================================================================

void A_CFlameAttack(void)
{
	Actor mo;

	mo = PlayerPawn(Player->MO).SpawnPlayerMissile(ClericFlameMissile);
	if (mo)
	{
		mo._Special1 = 2;
	}

	Player->Mana[MANA_2] -=
		WeaponManaUse(Player->PClass, Player->ReadyWeapon);
	Player->MO.PlaySound('ClericFlameFire', CHAN_WEAPON);
}

__states__
{
	S_CFLAMEREADY1('CFLM', 0, 1.0 / 35.0, S_CFLAMEREADY2) { A_WeaponReady(); }
	S_CFLAMEREADY2('CFLM', 0, 1.0 / 35.0, S_CFLAMEREADY3) { A_WeaponReady(); }
	S_CFLAMEREADY3('CFLM', 0, 1.0 / 35.0, S_CFLAMEREADY4) { A_WeaponReady(); }
	S_CFLAMEREADY4('CFLM', 0, 1.0 / 35.0, S_CFLAMEREADY5) { A_WeaponReady(); }
	S_CFLAMEREADY5('CFLM', 1, 1.0 / 35.0, S_CFLAMEREADY6) { A_WeaponReady(); }
	S_CFLAMEREADY6('CFLM', 1, 1.0 / 35.0, S_CFLAMEREADY7) { A_WeaponReady(); }
	S_CFLAMEREADY7('CFLM', 1, 1.0 / 35.0, S_CFLAMEREADY8) { A_WeaponReady(); }
	S_CFLAMEREADY8('CFLM', 1, 1.0 / 35.0, S_CFLAMEREADY9) { A_WeaponReady(); }
	S_CFLAMEREADY9('CFLM', 2, 1.0 / 35.0, S_CFLAMEREADY10) { A_WeaponReady(); }
	S_CFLAMEREADY10('CFLM', 2, 1.0 / 35.0, S_CFLAMEREADY11) { A_WeaponReady(); }
	S_CFLAMEREADY11('CFLM', 2, 1.0 / 35.0, S_CFLAMEREADY12) { A_WeaponReady(); }
	S_CFLAMEREADY12('CFLM', 2, 1.0 / 35.0, S_CFLAMEREADY1) { A_WeaponReady(); }
	S_CFLAMEDOWN('CFLM', 0, 1.0 / 35.0, S_CFLAMEDOWN) { A_Lower(); }
	S_CFLAMEUP('CFLM', 0, 1.0 / 35.0, S_CFLAMEUP) { A_Raise(); }
	S_CFLAMEATK_1('CFLM', 0, 2.0 / 35.0, S_CFLAMEATK_2) { SY = 40.0; }
	S_CFLAMEATK_2('CFLM', 3, 2.0 / 35.0, S_CFLAMEATK_3) { SY = 50.0; }
	S_CFLAMEATK_3('CFLM', 3, 2.0 / 35.0, S_CFLAMEATK_4) { SY = 36.0; }
	S_CFLAMEATK_4('CFLM', 4 | FF_FULLBRIGHT, 4.0 / 35.0, S_CFLAMEATK_5) { }
	S_CFLAMEATK_5('CFLM', 5 | FF_FULLBRIGHT, 4.0 / 35.0, S_CFLAMEATK_6) { A_CFlameAttack(); }
	S_CFLAMEATK_6('CFLM', 4 | FF_FULLBRIGHT, 4.0 / 35.0, S_CFLAMEATK_7) { }
	S_CFLAMEATK_7('CFLM', 6, 2.0 / 35.0, S_CFLAMEATK_8) { SY = 40.0; }
	S_CFLAMEATK_8('CFLM', 6, 2.0 / 35.0, S_CFLAMEREADY1) { }
}

defaultproperties
{
	Mana = MANA_2;
	UpState = S_CFLAMEUP;
	DownState = S_CFLAMEDOWN;
	ReadyState = S_CFLAMEREADY1;
	AttackState = S_CFLAMEATK_1;
	HoldAttackState = S_CFLAMEATK_1;
	PSpriteSY = 10.0;
}

}

//**************************************************************************
//
//	HolyPuff
//
//**************************************************************************

class HolyPuff:Effect
{

__states__
{
	S_HOLY_PUFF1('SPIR', 10, 3.0 / 35.0, S_HOLY_PUFF2) { }
	S_HOLY_PUFF2('SPIR', 11, 3.0 / 35.0, S_HOLY_PUFF3) { }
	S_HOLY_PUFF3('SPIR', 12, 3.0 / 35.0, S_HOLY_PUFF4) { }
	S_HOLY_PUFF4('SPIR', 13, 3.0 / 35.0, S_HOLY_PUFF5) { }
	S_HOLY_PUFF5('SPIR', 14, 3.0 / 35.0, S_NULL) { }
}

defaultproperties
{
	Translucency = 66;
	IdleState = S_HOLY_PUFF1;
}

}

//**************************************************************************
//
//	HolyFX
//
//**************************************************************************

class HolyFX:Projectile
{

int WeaveXY;
int WeaveZ;

//==========================================================================
//
//	Touch
//
//==========================================================================

boolean Touch(Entity InOther)
{
	int damage;
	Actor Other;

	Other = Actor(InOther);
	if (!Other.bSolid && !Other.bSpecial && !Other.bShootable)
		return true;

	// Check for skulls slamming into things
	if (bSkullFly)
	{
		if (Other.bShootable && Other != Instigator)
		{
			if (netgame && !deathmatch && Other.bIsPlayer)
			{
				// don't attack other co-op players
				return true;
			}
			if (Other.bReflective && (Other.bIsPlayer || Other.bBoss))
			{
				Enemy = Instigator;
				Instigator = Other;
				return true;
			}
			if (Other.bCountKill || Other.bIsPlayer)
			{
				Enemy = Other;
			}
			if (P_Random() < 96)
			{
				damage = 12;
				if (Other.bIsPlayer || Other.bBoss)
				{
					damage = 3;
					// ghost burns out faster when attacking players/bosses
					Health -= 6;
				}
				Other.Damage(self, Instigator, damage);
				if (P_Random() < 128)
				{
					Spawn(HolyPuff, Origin);
					PlaySound('SpiritAttack', CHAN_VOICE);
					if (Other.bCountKill && P_Random() < 128
						&& !GetSoundPlayingInfo(Other,
							GetSoundID('PuppyBeat')))
					{
						if ((Other.Class == Centaur) ||
							(Other.Class == CentaurLeader) ||
							(Other.Class == Ettin))
						{
							Other.PlaySound('PuppyBeat', CHAN_VOICE);
						}
					}
				}
			}
			if (Other.Health <= 0)
			{
				Enemy = none;
			}
		}
		return true;
	}
	return ::Touch(InOther);
}

//============================================================================
//
//  CHolyFindTarget
//
//============================================================================

void CHolyFindTarget(void)
{
	Actor targ;

	targ = RoughMonsterSearch(6);
	if (targ)
	{
		Enemy = targ;
		bColideWithWorld = false;
		bSkullFly = true;
		bMissile = false;
	}
}

//============================================================================
//
//  CHolySeekerMissile
//
//  Similar to SeekerMissile, but seeks to a random Z on the target
//
//============================================================================

void CHolySeekerMissile(float thresh, float turnMax)
{
	int dir;
	float dist;
	float delta;
	float angle;
	float newZ;
	float deltaZ;

	if (!Enemy)
	{
		return;
	}
	if (!Enemy.bShootable || (!Enemy.bCountKill && !Enemy.bIsPlayer))
	{
		// Target died/target isn't a player or creature
		Enemy = none;
		bColideWithWorld = true;
		bSkullFly = false;
		bMissile = true;
		CHolyFindTarget();
		return;
	}
	dir = FaceActor(Enemy, &delta);
	if (delta > thresh)
	{
		delta /= 2.0;
		if (delta > turnMax)
		{
			delta = turnMax;
		}
	}
	if (dir)
	{
		// Turn clockwise
		Angles.yaw += delta;
	}
	else
	{
		// Turn counter clockwise
		Angles.yaw -= delta;
	}
	Angles.yaw = AngleMod360(Angles.yaw);
	angle = Angles.yaw;
	Velocity.x = Speed * cos(angle);
	Velocity.y = Speed * sin(angle);
	if (!(level->tictime & 15) ||
		Origin.z > Enemy.Origin.z + Enemy.Height ||
		Origin.z + Height < Enemy.Origin.z)
	{
		newZ = Enemy.Origin.z + Random() * Enemy.Height;
		deltaZ = newZ - Origin.z;
		if (fabs(deltaZ) > 15.0)
		{
			if (deltaZ > 0.0)
			{
				deltaZ = 15.0;
			}
			else
			{
				deltaZ = -15.0;
			}
		}
		dist = MobjDist2(Enemy, self);
		dist = dist / Speed;
		if (dist < 1.0)
		{
			dist = 1.0;
		}
		Velocity.z = deltaZ / dist;
	}
	return;
}

//============================================================================
//
//	CHolyWeave
//
//============================================================================

void CHolyWeave(void)
{
	float newX, newY;
	float angle;

	angle = AngleMod360(Angles.yaw + 90.0);
	newX = Origin.x - cos(angle) * FloatBobOffsets[WeaveXY] * 4.0;
	newY = Origin.y - sin(angle) * FloatBobOffsets[WeaveXY] * 4.0;
	WeaveXY = (WeaveXY + (P_Random() % 5)) & 63;
	newX += cos(angle) * FloatBobOffsets[WeaveXY] * 4.0;
	newY += sin(angle) * FloatBobOffsets[WeaveXY] * 4.0;
	TryMove(vector(newX, newY, Origin.z));
	Origin.z -= FloatBobOffsets[WeaveZ] * 2.0;
	WeaveZ = (WeaveZ + (P_Random() % 5)) & 63;
	Origin.z += FloatBobOffsets[WeaveZ] * 2.0;
}

//============================================================================
//
//	A_CHolySeek
//
//============================================================================

void A_CHolySeek(void)
{
	Health--;
	if (Health <= 0)
	{
		Velocity.x /= 4.0;
		Velocity.y /= 4.0;
		Velocity.z = 0.0;
		SetState(DeathState);
		StateTime -= Random() * 0.1;
		return;
	}
	if (Enemy)
	{
		CHolySeekerMissile(itof(Args[0]), itof(Args[0]) * 2.0);
		if (!((level->tictime + 7) & 15))
		{
			Args[0] = 5 + (P_Random() / 20);
		}
	}
	CHolyWeave();
}

//============================================================================
//
//	A_CHolyCheckScream
//
//============================================================================

void A_CHolyCheckScream(void)
{
	A_CHolySeek();
	if (P_Random() < 20)
	{
		PlaySound('SpiritActive', CHAN_VOICE);
	}
	if (!Enemy)
	{
		CHolyFindTarget();
	}
}

__states__
{
	S_HOLY_FX1('SPIR', 0, 2.0 / 35.0, S_HOLY_FX2) { A_CHolySeek(); }
	S_HOLY_FX2('SPIR', 0, 2.0 / 35.0, S_HOLY_FX3) { A_CHolySeek(); }
	S_HOLY_FX3('SPIR', 1, 2.0 / 35.0, S_HOLY_FX4) { A_CHolySeek(); }
	S_HOLY_FX4('SPIR', 1, 2.0 / 35.0, S_HOLY_FX1) { A_CHolyCheckScream(); }
	S_HOLY_FX_X1('SPIR', 3, 4.0 / 35.0, S_HOLY_FX_X2) { }
	S_HOLY_FX_X2('SPIR', 4, 4.0 / 35.0, S_HOLY_FX_X3) { A_Scream(); }
	S_HOLY_FX_X3('SPIR', 5, 4.0 / 35.0, S_HOLY_FX_X4) { }
	S_HOLY_FX_X4('SPIR', 6, 4.0 / 35.0, S_HOLY_FX_X5) { }
	S_HOLY_FX_X5('SPIR', 7, 4.0 / 35.0, S_HOLY_FX_X6) { }
	S_HOLY_FX_X6('SPIR', 8, 4.0 / 35.0, S_NULL) { }
}

defaultproperties
{
	Health = 105;
	Radius = 10.0;
	Height = 6.0;
	Speed = 420.0;
	MissileDamage = 3;
	Translucency = 33;
	bRip = true;
	bSeekerMissile = true;
	IdleState = S_HOLY_FX1;
	DeathState = S_HOLY_FX_X1;
	DeathSound = 'SpiritDie';
}

}

//**************************************************************************
//
//	HolyTail
//
//**************************************************************************

class HolyTail:Effect
{

Actor ParentSpirit;
HolyTail NextTail;

//============================================================================
//
//	CHolyTailFollow
//
//============================================================================

void CHolyTailFollow(float dist)
{
	Actor child;
	float an;
	float oldDistance, newDistance;

	child = NextTail;
	if (child)
	{
		an = atan2(child.Origin.y - Origin.y,
			Origin.x - child.Origin.x);
		oldDistance = MobjDist(child, self);
		if (child.TryMove(vector(Origin.x + dist * cos(an),
				Origin.y + dist * sin(an), child.Origin.z)))
		{
			newDistance = MobjDist2(child, self) - 1.0;
			if (oldDistance < 1.0)
			{
				if (child.Origin.z < Origin.z)
				{
					child.Origin.z = Origin.z - dist;
				}
				else
				{
					child.Origin.z = Origin.z + dist;
				}
			}
			else
			{
				child.Origin.z = Origin.z + newDistance / oldDistance *
					(child.Origin.z - Origin.z);
			}
		}
		HolyTail(child).CHolyTailFollow(dist - 1.0);
	}
}

//============================================================================
//
//	CHolyTailRemove
//
//============================================================================

void CHolyTailRemove(void)
{
	if (NextTail)
	{
		NextTail.CHolyTailRemove();
	}
	Remove();
}

//============================================================================
//
//	A_CHolyTail
//
//============================================================================

void A_CHolyTail(void)
{
	Actor parent;

	parent = ParentSpirit;

	if (parent)
	{
		if (parent.StateNum >= parent.DeathState)
		{
			// Ghost removed, so remove all tail parts
			CHolyTailRemove();
			return;
		}
		else if (TryMove(vector(
				parent.Origin.x - 14.0 * cos(parent.Angles.yaw),
				parent.Origin.y - 14.0 * sin(parent.Angles.yaw), Origin.z)))
		{
			Origin.z = parent.Origin.z - 5.0;
		}
		CHolyTailFollow(10.0);
	}
}

__states__
{
	S_HOLY_TAIL1('SPIR', 2, 1.0 / 35.0, S_HOLY_TAIL1) { A_CHolyTail(); }
	S_HOLY_TAIL2('SPIR', 3, -1.0, S_NULL) { }
}

defaultproperties
{
	Radius = 1.0;
	Height = 1.0;
	Translucency = 33;
	bDropOff = true;
	bColideWithWorld = false;
	bColideWithThings = false;
	bNoTeleport = true;
	IdleState = S_HOLY_TAIL1;
}

}

//**************************************************************************
//
//	HolyMissilePuff
//
//**************************************************************************

class HolyMissilePuff:Effect
{

__states__
{
	S_HOLY_MISSILE_P1('SPIR', 16, 3.0 / 35.0, S_HOLY_MISSILE_P2) { }
	S_HOLY_MISSILE_P2('SPIR', 17, 3.0 / 35.0, S_HOLY_MISSILE_P3) { }
	S_HOLY_MISSILE_P3('SPIR', 18, 3.0 / 35.0, S_HOLY_MISSILE_P4) { }
	S_HOLY_MISSILE_P4('SPIR', 19, 3.0 / 35.0, S_HOLY_MISSILE_P5) { }
	S_HOLY_MISSILE_P5('SPIR', 20, 3.0 / 35.0, S_NULL) { }
}

defaultproperties
{
	Radius = 4.0;
	Height = 8.0;
	Translucency = 33;
	bDropOff = true;
	bNoTeleport = true;
	IdleState = S_HOLY_MISSILE_P1;
}

}

//**************************************************************************
//
//	HolyMissile
//
//**************************************************************************

class HolyMissile:Projectile
{

//============================================================================
//
//	A_CHolySpawnPuff
//
//============================================================================

void A_CHolySpawnPuff(void)
{
	Spawn(HolyMissilePuff, Origin);
}

//============================================================================
//
//  A_CHolyAttack2
//
//  Spawns the spirits
//
//============================================================================

void A_CHolyAttack2(void)
{
	int j;
	int i;
	Actor A;
	Actor tail;
	Actor next;

	for (j = 0; j < 4; j++)
	{
		A = Spawn(HolyFX, Origin);
		if (!A)
		{
			continue;
		}
		switch (j)
		{	// float bob index
		case 0:
			HolyFX(A).WeaveZ = P_Random() & 7;	// upper-left
			break;
		case 1:
			HolyFX(A).WeaveZ = 32 + (P_Random() & 7);	// upper-right
			break;
		case 2:
			HolyFX(A).WeaveXY = 32 + (P_Random() & 7);	// lower-left
			break;
		case 3:
			HolyFX(A).WeaveXY = 32 + (P_Random() & 7);
			HolyFX(A).WeaveZ = 32 + (P_Random() & 7);
			break;
		}
		A.Origin.z = Origin.z;
		A.Angles.yaw = AngleMod360(Angles.yaw +
			(45.0 + 45.0 / 2.0) - 45.0 * itof(j));
		A.Thrust(A.Angles.yaw, A.Speed * frametime);
		A.Instigator = Instigator;
		A.Args[0] = 10;	// initial turn value
		A.Args[1] = 0;	// initial look angle
		if (deathmatch)
		{
			// Ghosts last slightly less longer in DeathMatch
			A.Health = 85;
		}
		if (linetarget)
		{
			A.Enemy = linetarget;
			//	Don't colide with world but colide with things, i.e explode
			A.bColideWithWorld = false;
			A.bSkullFly = true;
			A.bMissile = false;
		}
		tail = Spawn(HolyTail, A.Origin);
		HolyTail(tail).ParentSpirit = A;	// parent
		for (i = 1; i < 3; i++)
		{
			next = Spawn(HolyTail, A.Origin);
			next.SetState(next.IdleState + 1);
			HolyTail(tail).NextTail = HolyTail(next);
			tail = next;
		}
	}
}

__states__
{
	S_HOLY_MISSILE1('SPIR', 15 | FF_FULLBRIGHT, 3.0 / 35.0, S_HOLY_MISSILE2) { A_CHolySpawnPuff(); }
	S_HOLY_MISSILE2('SPIR', 15 | FF_FULLBRIGHT, 3.0 / 35.0, S_HOLY_MISSILE3) { A_CHolySpawnPuff(); }
	S_HOLY_MISSILE3('SPIR', 15 | FF_FULLBRIGHT, 3.0 / 35.0, S_HOLY_MISSILE4) { A_CHolySpawnPuff(); }
	S_HOLY_MISSILE4('SPIR', 15 | FF_FULLBRIGHT, 3.0 / 35.0, S_HOLY_MISSILE_X) { A_CHolySpawnPuff(); }
	S_HOLY_MISSILE_X('SPIR', 15 | FF_FULLBRIGHT, 1.0 / 35.0, S_NULL) { A_CHolyAttack2(); }
}

defaultproperties
{
	Radius = 15.0;
	Height = 8.0;
	Speed = 1050.0;
	MissileDamage = 4;
	bActivateImpact = false;
	bActivatePCross = false;
	IdleState = S_HOLY_MISSILE1;
	DeathState = S_HOLY_MISSILE_X;
	Effects = EF_DL_WHITE;
}

}

//**************************************************************************
//
//	WeaponClericHoly
//
//**************************************************************************

class WeaponClericHoly:Weapon
{

//============================================================================
//
//  A_CHolyAttack
//
//============================================================================

void A_CHolyAttack(void)
{
	Player->Mana[MANA_1] -=
		WeaponManaUse(Player->PClass, Player->ReadyWeapon);
	Player->Mana[MANA_2] -=
		WeaponManaUse(Player->PClass, Player->ReadyWeapon);
	PlayerPawn(Player->MO).SpawnPlayerMissile(HolyMissile);
	Player->DamageFlash = 0.0;
	Player->BonusFlash = 0.0;
	Player->WeaponPalette = STARTHOLYPAL;
	Player->MO.PlaySound('HolySymbolFire', CHAN_WEAPON);
}

//============================================================================
//
//  A_CHolyPalette1
//
//============================================================================

void A_CHolyPalette1(void)
{
	Player->WeaponPalette = STARTHOLYPAL + 1;
}

//============================================================================
//
//  A_CHolyPalette2
//
//============================================================================

void A_CHolyPalette2(void)
{
	Player->WeaponPalette = STARTHOLYPAL + 2;
}

//============================================================================
//
//  A_CHolyPalette3
//
//============================================================================

void A_CHolyPalette3(void)
{
	// reset back to original playpal
	Player->WeaponPalette = 0;
}

__states__
{
	S_CHOLYREADY('CHLY', 0, 1.0 / 35.0, S_CHOLYREADY) { A_WeaponReady(); }
	S_CHOLYDOWN('CHLY', 0, 1.0 / 35.0, S_CHOLYDOWN) { A_Lower(); }
	S_CHOLYUP('CHLY', 0, 1.0 / 35.0, S_CHOLYUP) { A_Raise(); }
	S_CHOLYATK_1('CHLY', 0 | FF_FULLBRIGHT, 1.0 / 35.0, S_CHOLYATK_2) { SY = 40.0; }
	S_CHOLYATK_2('CHLY', 1 | FF_FULLBRIGHT, 1.0 / 35.0, S_CHOLYATK_3) { SY = 40.0; }
	S_CHOLYATK_3('CHLY', 2 | FF_FULLBRIGHT, 2.0 / 35.0, S_CHOLYATK_4) { SY = 43.0; }
	S_CHOLYATK_4('CHLY', 3 | FF_FULLBRIGHT, 2.0 / 35.0, S_CHOLYATK_5) { SY = 43.0; }
	S_CHOLYATK_5('CHLY', 4 | FF_FULLBRIGHT, 2.0 / 35.0, S_CHOLYATK_6) { SY = 45.0; }
	S_CHOLYATK_6('CHLY', 5 | FF_FULLBRIGHT, 6.0 / 35.0, S_CHOLYATK_7) { SY = 48.0; A_CHolyAttack(); }
	S_CHOLYATK_7('CHLY', 6 | FF_FULLBRIGHT, 2.0 / 35.0, S_CHOLYATK_8) { SY = 40.0; A_CHolyPalette1(); }
	S_CHOLYATK_8('CHLY', 6 | FF_FULLBRIGHT, 2.0 / 35.0, S_CHOLYATK_9) { SY = 40.0; A_CHolyPalette2(); }
	S_CHOLYATK_9('CHLY', 6 | FF_FULLBRIGHT, 2.0 / 35.0, S_CHOLYREADY) { SY = 36.0; A_CHolyPalette3(); }
}

defaultproperties
{
	Mana = MANA_BOTH;
	UpState = S_CHOLYUP;
	DownState = S_CHOLYDOWN;
	ReadyState = S_CHOLYREADY;
	AttackState = S_CHOLYATK_1;
	HoldAttackState = S_CHOLYATK_1;
	PSpriteSY = 0.0;
}

}

//**************************************************************************
//
//  $Log$
//  Revision 1.31  2002/08/28 16:36:39  dj_jl
//  Merged MapObject with Entity, some natives, beautification.
//
//  Revision 1.30  2002/07/23 13:07:31  dj_jl
//  Final touches for switching to floating-point time, beautification.
//
//  Revision 1.29  2002/06/22 07:16:02  dj_jl
//  Added base classes for objects, split them into corresponding files.
//
//  Revision 1.28  2002/06/14 15:49:45  dj_jl
//  Added Projectile class.
//
//  Revision 1.27  2002/05/18 17:00:00  dj_jl
//  Renamed SpawnState to IdleState, other changes.
//
//  Revision 1.26  2002/04/11 16:52:16  dj_jl
//  Made TryMove native.
//
//  Revision 1.25  2002/03/28 18:15:35  dj_jl
//  Renamed mo in player_t to MO.
//
//  Revision 1.24  2002/03/20 19:07:47  dj_jl
//  Got rid of a lots of legacy, beautification.
//
//  Revision 1.23  2002/03/16 17:47:47  dj_jl
//  Got rid of mobj_t and some other legacy.
//
//  Revision 1.22  2002/03/09 17:57:02  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.21  2002/03/04 18:31:36  dj_jl
//  Replaced bNoClip with two seperate flags, beautification.
//
//  Revision 1.20  2002/03/02 17:35:55  dj_jl
//  Weapon classes
//
//  Revision 1.19  2002/02/26 17:49:49  dj_jl
//  no message
//
//  Revision 1.18  2002/02/22 18:00:25  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.17  2002/02/14 19:20:59  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.16  2002/02/06 17:28:53  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.15  2002/02/02 19:17:26  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.14  2002/01/28 18:50:19  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.13  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.12  2002/01/24 18:19:27  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.11  2002/01/17 18:15:55  dj_jl
//  Renamed all map object classes
//
//  Revision 1.10  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.9  2002/01/11 18:19:42  dj_jl
//  Started to use names in progs
//
//  Revision 1.8  2002/01/07 12:25:58  dj_jl
//  Changed copyright year
//
//  Revision 1.7  2001/12/12 18:57:42  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.6  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.5  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/30 17:33:18  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:53  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
