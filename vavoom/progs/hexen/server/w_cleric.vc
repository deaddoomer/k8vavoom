//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//===========================================================================
//
//  Weapon::A_CMaceAttack
//
//===========================================================================

void Weapon::A_CMaceAttack(void)
{
	int damage;
	int i;
	TAVec angles;
	TVec vforward;

	damage = 25 + (P_Random() & 15);
	PuffType = HammerPuff;
	for (i = 0; i < 16; i++)
	{
		angles = player->mo->angles;
		angles.yaw = AngleMod360(angles.yaw + itof(i) * (45.0 / 16.0));
		AimLineAttack(player->mo, &angles, 2.0 * MELEERANGE);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			if (LineAttack(player->mo, &vforward, 2.0 * MELEERANGE, damage))
			{
				StartSoundName(player->mo, 'FighterHammerMiss', CHAN_WEAPON);
			}
			AdjustPlayerAngle(player->mo);
			return;
		}
		angles = player->mo->angles;
		angles.yaw = AngleMod360(angles.yaw - itof(i) * (45.0 / 16.0));
		AimLineAttack(player->mo, &angles, 2.0 * MELEERANGE);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			if (LineAttack(player->mo, &vforward, 2.0 * MELEERANGE, damage))
			{
				StartSoundName(player->mo, 'FighterHammerMiss', CHAN_WEAPON);
			}
			AdjustPlayerAngle(player->mo);
			return;
		}
	}
	// didn't find any creatures, so try to strike any walls
	player->mo->special1 = 0;

	avcpy(player->mo->angles, angles);
	AimLineAttack(player->mo, &angles, MELEERANGE);
	AngleVector(&angles, &vforward);
	if (LineAttack(player->mo, &vforward, MELEERANGE, damage))
	{
		StartSoundName(player->mo, 'FighterHammerMiss', CHAN_WEAPON);
	}
}

//============================================================================
//
//  Weapon::A_CStaffInitBlink
//
//============================================================================

void Weapon::A_CStaffInitBlink(void)
{
	player->mo->special1 = (P_Random() >> 1) + 20;
}

//============================================================================
//
//  Weapon::A_CStaffCheckBlink
//
//============================================================================

void Weapon::A_CStaffCheckBlink(void)
{
	if (!--player->mo->special1)
	{
		SetPsprite(player, ps_weapon, S_CSTAFFBLINK1);
		player->mo->special1 = (P_Random() + 50) >> 2;
	}
}

//============================================================================
//
//  Weapon::A_CStaffCheck
//
//============================================================================

void Weapon::A_CStaffCheck(void)
{
	mobj_t *pmo;
	int damage;
	int newLife;
	int i;
	TAVec angles;
	TVec vforward;

	pmo = player->mo;
	damage = 20 + (P_Random() & 15);
	PuffType = ClericStaffPuff;
	for (i = 0; i < 3; i++)
	{
		angles = pmo->angles;
		angles.yaw = AngleMod360(angles.yaw + itof(i) * (45.0 / 16.0));
		AimLineAttack(pmo, &angles, 3.0 * MELEERANGE / 2.0);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			LineAttack(pmo, &vforward, 1.5 * MELEERANGE, damage);
			pmo->angles.yaw = atan2(linetarget->origin.y - pmo->origin.y,
				linetarget->origin.x - pmo->origin.x);
			if ((linetarget->player || linetarget->Flags & MF_COUNTKILL)
				&& (!(linetarget->Flags2 & (MF2_DORMANT + MF2_INVULNERABLE))))
			{
				newLife = player->health + (damage >> 3);
				newLife = newLife > 100 ? 100 : newLife;
				pmo->Health = player->health = newLife;
				SetPsprite(player, ps_weapon, S_CSTAFFATK2_1);
			}
			player->mana[MANA_1] -=
				WeaponManaUse(player->pclass, player->readyweapon);
			break;
		}
		angles = pmo->angles;
		angles.yaw = AngleMod360(angles.yaw - itof(i) * (45.0 / 16.0));
		AimLineAttack(player->mo, &angles, 3.0 * MELEERANGE / 2.0);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			LineAttack(pmo, &vforward, 1.5 * MELEERANGE, damage);
			pmo->angles.yaw = atan2(linetarget->origin.y - pmo->origin.y,
				linetarget->origin.x - pmo->origin.x);
			if (linetarget->player || linetarget->Flags & MF_COUNTKILL)
			{
				newLife = player->health + (damage >> 4);
				newLife = newLife > 100 ? 100 : newLife;
				pmo->Health = player->health = newLife;
				SetPsprite(player, ps_weapon, S_CSTAFFATK2_1);
			}
			player->mana[MANA_1] -=
				WeaponManaUse(player->pclass, player->readyweapon);
			break;
		}
	}
}

//============================================================================
//
//  Weapon::A_CStaffAttack
//
//============================================================================

void Weapon::A_CStaffAttack(void)
{
	mobj_t *mo;
	mobj_t *pmo;

	player->mana[MANA_1] -=
		WeaponManaUse(player->pclass, player->readyweapon);
	pmo = player->mo;
	mo = SpawnPlayerMissileAngle(pmo, ClericStaffMissile,
		pmo->angles.yaw - (45.0 / 15.0));
	if (mo)
	{
		mo->special2 = 32;
	}
	mo = SpawnPlayerMissileAngle(pmo, ClericStaffMissile,
		pmo->angles.yaw + (45.0 / 15.0));
	if (mo)
	{
		mo->special2 = 0;
	}
	StartSoundName(player->mo, 'ClericCStaffFire', CHAN_WEAPON);
}

//============================================================================
//
//  Actor::A_CStaffMissileSlither
//
//============================================================================

void Actor::A_CStaffMissileSlither(void)
{
	float newX, newY;
	int weaveXY;
	float angle;

	weaveXY = special2;
	angle = AngleMod360(angles.yaw + 90.0);
	newX = origin.x - cos(angle) * FloatBobOffsets[weaveXY];
	newY = origin.y - sin(angle) * FloatBobOffsets[weaveXY];
	weaveXY = (weaveXY + 3) & 63;
	newX += cos(angle) * FloatBobOffsets[weaveXY];
	newY += sin(angle) * FloatBobOffsets[weaveXY];
	P_TryMove(this, newX, newY);
	special2 = weaveXY;
}

//============================================================================
//
//  Weapon::A_CFlameAttack
//
//============================================================================

void Weapon::A_CFlameAttack(void)
{
	mobj_t *mo;

	mo = SpawnPlayerMissile(player->mo, ClericFlameMissile);
	if (mo)
	{
		mo->blaster = true;
		mo->special1 = 2;
	}

	player->mana[MANA_2] -=
		WeaponManaUse(player->pclass, player->readyweapon);
	StartSoundName(player->mo, 'ClericFlameFire', CHAN_WEAPON);
}

//============================================================================
//
//  Actor::A_CFlameMissile
//
//============================================================================

#define FLAMESPEED		(9.0 / 20.0 * 35.0)

void Actor::A_CFlameMissile(void)
{
	int i;
	float an;
	float dist;
	mobj_t *mo;
	mobj_t *bmo;

	A_UnHideThing();
	StartSoundName(this, 'ClericFlameExplode', CHAN_VOICE);
	bmo = BlockingMobj;
	if (bmo && bmo->Flags & MF_SHOOTABLE)
	{
		// Hit something, so spawn the flame circle around the thing
		dist = bmo->Radius + 18.0;
		for (i = 0; i < 4; i++)
		{
			an = itof(i) * 45.0;
			mo = P_SpawnMobj(bmo->origin.x + dist * cos(an),
				bmo->origin.y + dist * sin(an),
				bmo->origin.z + 5.0, CircleFlame);
			if (mo)
			{
				mo->angles.yaw = an;
				mo->target = target;
				mo->velocity.x = mo->special1f = FLAMESPEED * cos(an);
				mo->velocity.y = mo->special2f = FLAMESPEED * sin(an);
				mo->time -= Random() * 0.1;
			}
			mo = P_SpawnMobj(bmo->origin.x - dist * cos(an),
				bmo->origin.y - dist * sin(an),
				bmo->origin.z + 5.0, CircleFlame);
			if (mo)
			{
				mo->angles.yaw = AngleMod360(180.0 + an);
				mo->target = target;
				mo->velocity.x = mo->special1f = -FLAMESPEED * cos(an);
				mo->velocity.y = mo->special2f = -FLAMESPEED * sin(an);
				mo->time -= Random() * 0.1;
			}
		}
		SetState(S_FLAMEPUFF2_1);
	}
}

//============================================================================
//
//	Actor::A_CFlameRotate
//
//============================================================================

#define FLAMEROTSPEED	2.0 * 35.0

void Actor::A_CFlameRotate(void)
{
	float an;

	an = AngleMod360(angles.yaw + 90.0);
	velocity.x = special1f + FLAMEROTSPEED * cos(an);
	velocity.y = special2f + FLAMEROTSPEED * sin(an);
	angles.yaw = AngleMod360(angles.yaw + 90.0 / 15.0);
}

//============================================================================
//
//	Actor::A_CFlamePuff
//
//============================================================================

void Actor::A_CFlamePuff(void)
{
	A_UnHideThing();
	velocity = vector(0.0, 0.0, 0.0);
	StartSoundName(this, 'ClericFlameExplode', CHAN_VOICE);
}

//============================================================================
//
//  Weapon::A_CHolyAttack
//
//============================================================================

void Weapon::A_CHolyAttack(void)
{
	mobj_t *mo;

	player->mana[MANA_1] -=
		WeaponManaUse(player->pclass, player->readyweapon);
	player->mana[MANA_2] -=
		WeaponManaUse(player->pclass, player->readyweapon);
	mo = SpawnPlayerMissile(player->mo, HolyMissile);
	player->damagecount = 0;
	player->bonuscount = 0;
	player->weapon_palette = STARTHOLYPAL;
	StartSoundName(player->mo, 'HolySymbolFire', CHAN_WEAPON);
}

//============================================================================
//
//  Weapon::A_CHolyPalette
//
//============================================================================

void Weapon::A_CHolyPalette(void)
{
	int pal;

	pal = STARTHOLYPAL + statenum - S_CHOLYATK_6;
	if (pal == STARTHOLYPAL + 3)
	{
		// reset back to original playpal
		pal = 0;
	}
	player->weapon_palette = pal;
}

//============================================================================
//
//  Actor::A_CHolyAttack2
//
//  Spawns the spirits
//
//============================================================================

void Actor::A_CHolyAttack2(void)
{
	int j;
	int i;
	mobj_t *mo;
	mobj_t *tail;
	mobj_t *next;

	for (j = 0; j < 4; j++)
	{
		mo = P_SpawnMobj(origin.x, origin.y, origin.z, HolyFX);
		if (!mo)
		{
			continue;
		}
		switch (j)
		{	// float bob index
		case 0:
			mo->special2 = P_Random() & 7;	// upper-left
			break;
		case 1:
			mo->special2 = 32 + (P_Random() & 7);	// upper-right
			break;
		case 2:
			mo->special2 = (32 + (P_Random() & 7)) << 16;	// lower-left
			break;
		case 3:
			mo->special2 =
				((32 + (P_Random() & 7)) << 16) + 32 + (P_Random() & 7);
			break;
		}
		mo->origin.z = origin.z;
		mo->angles.yaw = AngleMod360(angles.yaw +
			(45.0 + 45.0 / 2.0) - 45.0 * itof(j));
		P_ThrustMobj(mo, mo->angles.yaw, mo->Speed * frametime);
		mo->target = target;
		mo->args[0] = 10;	// initial turn value
		mo->args[1] = 0;	// initial look angle
		if (deathmatch)
		{
			// Ghosts last slightly less longer in DeathMatch
			mo->Health = 85;
		}
		if (linetarget)
		{
			mo->specialmobj1 = linetarget;
			mo->Flags |= MF_NOCLIP | MF_SKULLFLY;
			mo->Flags &= ~MF_MISSILE;
		}
		tail = P_SpawnMobj(mo->origin.x, mo->origin.y, mo->origin.z,
			HolyTail);
		tail->specialmobj2 = mo;	// parent
		for (i = 1; i < 3; i++)
		{
			next = P_SpawnMobj(mo->origin.x, mo->origin.y, mo->origin.z,
				HolyTail);
			next->SetState(next->SpawnState + 1);
			tail->specialmobj1 = next;
			tail = next;
		}
		tail->specialmobj1 = NULL;	// last tail bit
	}
}

//============================================================================
//
//  Actor::CHolyFindTarget
//
//============================================================================

void Actor::CHolyFindTarget(void)
{
	Actor targ;

	targ = RoughMonsterSearch(6);
	if (targ)
	{
		specialmobj1 = &targ;
		Flags |= MF_NOCLIP | MF_SKULLFLY;
		Flags &= ~MF_MISSILE;
	}
}

//============================================================================
//
//  Actor::CHolySeekerMissile
//
//  Similar to SeekerMissile, but seeks to a random Z on the target
//
//============================================================================

void Actor::CHolySeekerMissile(float thresh, float turnMax)
{
	int dir;
	float dist;
	float delta;
	float angle;
	mobj_t *targ;
	float newZ;
	float deltaZ;

	targ = specialmobj1;
	if (!targ)
	{
		return;
	}
	if (!(targ->Flags & MF_SHOOTABLE)
		|| (!(targ->Flags & MF_COUNTKILL) && !targ->player))
	{
		// Target died/target isn't a player or creature
		specialmobj1 = NULL;
		Flags &= ~(MF_NOCLIP | MF_SKULLFLY);
		Flags |= MF_MISSILE;
		CHolyFindTarget();
		return;
	}
	dir = P_FaceMobj(this, targ, &delta);
	if (delta > thresh)
	{
		delta /= 2.0;
		if (delta > turnMax)
		{
			delta = turnMax;
		}
	}
	if (dir)
	{
		// Turn clockwise
		angles.yaw += delta;
	}
	else
	{
		// Turn counter clockwise
		angles.yaw -= delta;
	}
	angles.yaw = AngleMod360(angles.yaw);
	angle = angles.yaw;
	velocity.x = Speed * cos(angle);
	velocity.y = Speed * sin(angle);
	if (!(level->tictime & 15) ||
		origin.z > targ->origin.z + targ->Height ||
		origin.z + Height < targ->origin.z)
	{
		newZ = targ->origin.z + Random() * targ->Height;
		deltaZ = newZ - origin.z;
		if (fabs(deltaZ) > 15.0)
		{
			if (deltaZ > 0.0)
			{
				deltaZ = 15.0;
			}
			else
			{
				deltaZ = -15.0;
			}
		}
		dist = MobjDist2(targ, this);
		dist = dist / Speed;
		if (dist < 1.0)
		{
			dist = 1.0;
		}
		velocity.z = deltaZ / dist;
	}
	return;
}

//============================================================================
//
//	Actor::CHolyWeave
//
//============================================================================

void Actor::CHolyWeave(void)
{
	float newX, newY;
	int weaveXY, weaveZ;
	float angle;

	weaveXY = special2 >> 16;
	weaveZ = special2 & 0xFFFF;
	angle = AngleMod360(angles.yaw + 90.0);
	newX = origin.x - cos(angle) * FloatBobOffsets[weaveXY] * 4.0;
	newY = origin.y - sin(angle) * FloatBobOffsets[weaveXY] * 4.0;
	weaveXY = (weaveXY + (P_Random() % 5)) & 63;
	newX += cos(angle) * FloatBobOffsets[weaveXY] * 4.0;
	newY += sin(angle) * FloatBobOffsets[weaveXY] * 4.0;
	P_TryMove(this, newX, newY);
	origin.z -= FloatBobOffsets[weaveZ] * 2.0;
	weaveZ = (weaveZ + (P_Random() % 5)) & 63;
	origin.z += FloatBobOffsets[weaveZ] * 2.0;
	special2 = weaveZ + (weaveXY << 16);
}

//============================================================================
//
//	Actor::A_CHolySeek
//
//============================================================================

void Actor::A_CHolySeek(void)
{
	Health--;
	if (Health <= 0)
	{
		velocity.x /= 4.0;
		velocity.y /= 4.0;
		velocity.z = 0.0;
		SetState(DeathState);
		time -= Random() * 0.1;
		return;
	}
	if (specialmobj1)
	{
		CHolySeekerMissile(itof(args[0]), itof(args[0]) * 2.0);
		if (!((level->tictime + 7) & 15))
		{
			args[0] = 5 + (P_Random() / 20);
		}
	}
	CHolyWeave();
}

//============================================================================
//
//	Actor::A_CHolyCheckScream
//
//============================================================================

void Actor::A_CHolyCheckScream(void)
{
	A_CHolySeek();
	if (P_Random() < 20)
	{
		StartSoundName(this, 'SpiritActive', CHAN_VOICE);
	}
	if (!specialmobj1)
	{
		CHolyFindTarget();
	}
}

//============================================================================
//
//	Actor::CHolyTailFollow
//
//============================================================================

void Actor::CHolyTailFollow(float dist)
{
	mobj_t *child;
	float an;
	float oldDistance, newDistance;

	child = specialmobj1;
	if (child)
	{
		an = atan2(child->origin.y - origin.y,
			origin.x - child->origin.x);
		oldDistance = MobjDist(child, this);
		if (P_TryMove(child, origin.x + dist * cos(an),
				origin.y + dist * sin(an)))
		{
			newDistance = MobjDist2(child, this) - 1.0;
			if (oldDistance < 1.0)
			{
				if (child->origin.z < origin.z)
				{
					child->origin.z = origin.z - dist;
				}
				else
				{
					child->origin.z = origin.z + dist;
				}
			}
			else
			{
				child->origin.z = origin.z + newDistance / oldDistance *
					(child->origin.z - origin.z);
			}
		}
		child->CHolyTailFollow(dist - 1.0);
	}
}

//============================================================================
//
//	Actor::CHolyTailRemove
//
//============================================================================

void Actor::CHolyTailRemove(void)
{
	mobj_t *child;

	child = specialmobj1;
	if (child)
	{
		child->CHolyTailRemove();
	}
	P_RemoveMobj(this);
}

//============================================================================
//
//	A_CHolyTail
//
//============================================================================

void Actor::A_CHolyTail(void)
{
	mobj_t *parent;

	parent = specialmobj2;

	if (parent)
	{
		if (parent->statenum >= parent->DeathState)
		{
			// Ghost removed, so remove all tail parts
			CHolyTailRemove();
			return;
		}
		else if (P_TryMove(this,
				parent->origin.x - 14.0 * cos(parent->angles.yaw),
				parent->origin.y - 14.0 * sin(parent->angles.yaw)))
		{
			origin.z = parent->origin.z - 5.0;
		}
		CHolyTailFollow(10.0);
	}
}

//============================================================================
//
//	Actor::A_CHolySpawnPuff
//
//============================================================================

void Actor::A_CHolySpawnPuff(void)
{
	P_SpawnMobj(origin.x, origin.y, origin.z, HolyMissilePuff);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.13  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.12  2002/01/24 18:19:27  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.11  2002/01/17 18:15:55  dj_jl
//  Renamed all map object classes
//
//  Revision 1.10  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.9  2002/01/11 18:19:42  dj_jl
//  Started to use names in progs
//
//  Revision 1.8  2002/01/07 12:25:58  dj_jl
//  Changed copyright year
//
//  Revision 1.7  2001/12/12 18:57:42  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.6  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.5  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/30 17:33:18  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:53  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
