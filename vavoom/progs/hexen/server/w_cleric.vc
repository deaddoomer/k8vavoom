//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//===========================================================================
//
//  A_CMaceAttack
//
//===========================================================================

void A_CMaceAttack(mobj_t * actor)
{
	player_t *player = actor->player;
	int damage;
	int i;
	TAVec angles;
	TVec vforward;

	damage = 25 + (P_Random() & 15);
	PuffType = MT_HAMMERPUFF;
	for (i = 0; i < 16; i++)
	{
		angles = player->mo->angles;
		angles.yaw = AngleMod360(angles.yaw + itof(i) * (45.0 / 16.0));
		AimLineAttack(player->mo, &angles, 2.0 * MELEERANGE);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			if (LineAttack(player->mo, &vforward, 2.0 * MELEERANGE, damage))
			{
				StartSoundName(player->mo, "FighterHammerMiss", CHAN_WEAPON);
			}
			AdjustPlayerAngle(player->mo);
			return;
		}
		angles = player->mo->angles;
		angles.yaw = AngleMod360(angles.yaw - itof(i) * (45.0 / 16.0));
		AimLineAttack(player->mo, &angles, 2.0 * MELEERANGE);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			if (LineAttack(player->mo, &vforward, 2.0 * MELEERANGE, damage))
			{
				StartSoundName(player->mo, "FighterHammerMiss", CHAN_WEAPON);
			}
			AdjustPlayerAngle(player->mo);
			return;
		}
	}
	// didn't find any creatures, so try to strike any walls
	player->mo->special1 = 0;

	avcpy(player->mo->angles, angles);
	AimLineAttack(player->mo, &angles, MELEERANGE);
	AngleVector(&angles, &vforward);
	if (LineAttack(player->mo, &vforward, MELEERANGE, damage))
	{
		StartSoundName(player->mo, "FighterHammerMiss", CHAN_WEAPON);
	}
}

//============================================================================
//
//  A_CStaffInitBlink
//
//============================================================================

void A_CStaffInitBlink(mobj_t * actor)
{
	player_t *player = actor->player;

	player->mo->special1 = (P_Random() >> 1) + 20;
}

//============================================================================
//
//  A_CStaffCheckBlink
//
//============================================================================

void A_CStaffCheckBlink(mobj_t * actor)
{
	player_t *player = actor->player;

	if (!--player->mo->special1)
	{
		SetPsprite(player, ps_weapon, S_CSTAFFBLINK1);
		player->mo->special1 = (P_Random() + 50) >> 2;
	}
}

//============================================================================
//
//  A_CStaffCheck
//
//============================================================================

void A_CStaffCheck(mobj_t * actor)
{
	player_t *player = actor->player;
	mobj_t *pmo;
	int damage;
	int newLife;
	int i;
	TAVec angles;
	TVec vforward;

	pmo = player->mo;
	damage = 20 + (P_Random() & 15);
	PuffType = MT_CSTAFFPUFF;
	for (i = 0; i < 3; i++)
	{
		angles = pmo->angles;
		angles.yaw = AngleMod360(angles.yaw + itof(i) * (45.0 / 16.0));
		AimLineAttack(pmo, &angles, 3.0 * MELEERANGE / 2.0);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			LineAttack(pmo, &vforward, 1.5 * MELEERANGE, damage);
			pmo->angles.yaw = atan2(linetarget->origin.y - pmo->origin.y,
				linetarget->origin.x - pmo->origin.x);
			if ((linetarget->player || linetarget->flags & MF_COUNTKILL)
				&& (!(linetarget->flags2 & (MF2_DORMANT + MF2_INVULNERABLE))))
			{
				newLife = player->health + (damage >> 3);
				newLife = newLife > 100 ? 100 : newLife;
				pmo->health = player->health = newLife;
				SetPsprite(player, ps_weapon, S_CSTAFFATK2_1);
			}
			player->mana[MANA_1] -=
				WeaponManaUse(player->pclass, player->readyweapon);
			break;
		}
		angles = pmo->angles;
		angles.yaw = AngleMod360(angles.yaw - itof(i) * (45.0 / 16.0));
		AimLineAttack(player->mo, &angles, 3.0 * MELEERANGE / 2.0);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			LineAttack(pmo, &vforward, 1.5 * MELEERANGE, damage);
			pmo->angles.yaw = atan2(linetarget->origin.y - pmo->origin.y,
				linetarget->origin.x - pmo->origin.x);
			if (linetarget->player || linetarget->flags & MF_COUNTKILL)
			{
				newLife = player->health + (damage >> 4);
				newLife = newLife > 100 ? 100 : newLife;
				pmo->health = player->health = newLife;
				SetPsprite(player, ps_weapon, S_CSTAFFATK2_1);
			}
			player->mana[MANA_1] -=
				WeaponManaUse(player->pclass, player->readyweapon);
			break;
		}
	}
}

//============================================================================
//
//  A_CStaffAttack
//
//============================================================================

void A_CStaffAttack(mobj_t * actor)
{
	player_t *player = actor->player;
	mobj_t *mo;
	mobj_t *pmo;

	player->mana[MANA_1] -=
		WeaponManaUse(player->pclass, player->readyweapon);
	pmo = player->mo;
	mo = SpawnPlayerMissileAngle(pmo, MT_CSTAFF_MISSILE,
		pmo->angles.yaw - (45.0 / 15.0));
	if (mo)
	{
		mo->special2 = 32;
	}
	mo = SpawnPlayerMissileAngle(pmo, MT_CSTAFF_MISSILE,
		pmo->angles.yaw + (45.0 / 15.0));
	if (mo)
	{
		mo->special2 = 0;
	}
	StartSoundName(player->mo, "ClericCStaffFire", CHAN_WEAPON);
}

//============================================================================
//
//  A_CStaffMissileSlither
//
//============================================================================

void A_CStaffMissileSlither(mobj_t * actor)
{
	float newX, newY;
	int weaveXY;
	float angle;

	weaveXY = actor->special2;
	angle = AngleMod360(actor->angles.yaw + 90.0);
	newX = actor->origin.x - cos(angle) * FloatBobOffsets[weaveXY];
	newY = actor->origin.y - sin(angle) * FloatBobOffsets[weaveXY];
	weaveXY = (weaveXY + 3) & 63;
	newX += cos(angle) * FloatBobOffsets[weaveXY];
	newY += sin(angle) * FloatBobOffsets[weaveXY];
	P_TryMove(actor, newX, newY);
	actor->special2 = weaveXY;
}

//============================================================================
//
//  A_CFlameAttack
//
//============================================================================

void A_CFlameAttack(mobj_t * actor)
{
	player_t *player = actor->player;
	mobj_t *mo;

	mo = SpawnPlayerMissile(player->mo, MT_CFLAME_MISSILE);
	if (mo)
	{
		mo->blaster = true;
		mo->special1 = 2;
	}

	player->mana[MANA_2] -=
		WeaponManaUse(player->pclass, player->readyweapon);
	StartSoundName(player->mo, "ClericFlameFire", CHAN_WEAPON);
}

//============================================================================
//
//  A_CFlameMissile
//
//============================================================================

#define FLAMESPEED		(9.0 / 20.0 * 35.0)

void A_UnHideThing(mobj_t * actor);

void A_CFlameMissile(mobj_t * actor)
{
	int i;
	float an;
	float dist;
	mobj_t *mo;
	mobj_t *bmo;

	A_UnHideThing(actor);
	StartSoundName(actor, "ClericFlameExplode", CHAN_VOICE);
	bmo = BlockingMobj;
	if (bmo && bmo->flags & MF_SHOOTABLE)
	{
		// Hit something, so spawn the flame circle around the thing
		dist = bmo->radius + 18.0;
		for (i = 0; i < 4; i++)
		{
			an = itof(i) * 45.0;
			mo = P_SpawnMobj(bmo->origin.x + dist * cos(an),
				bmo->origin.y + dist * sin(an),
				bmo->origin.z + 5.0, MT_CIRCLEFLAME);
			if (mo)
			{
				mo->angles.yaw = an;
				mo->target = actor->target;
				mo->velocity.x = mo->special1f = FLAMESPEED * cos(an);
				mo->velocity.y = mo->special2f = FLAMESPEED * sin(an);
				mo->time -= Random() * 0.1;
			}
			mo = P_SpawnMobj(bmo->origin.x - dist * cos(an),
				bmo->origin.y - dist * sin(an),
				bmo->origin.z + 5.0, MT_CIRCLEFLAME);
			if (mo)
			{
				mo->angles.yaw = AngleMod360(180.0 + an);
				mo->target = actor->target;
				mo->velocity.x = mo->special1f = -FLAMESPEED * cos(an);
				mo->velocity.y = mo->special2f = -FLAMESPEED * sin(an);
				mo->time -= Random() * 0.1;
			}
		}
		SetMobjState(actor, S_FLAMEPUFF2_1);
	}
}

//============================================================================
//
// A_CFlameRotate
//
//============================================================================

#define FLAMEROTSPEED	2.0 * 35.0

void A_CFlameRotate(mobj_t * actor)
{
	float an;

	an = AngleMod360(actor->angles.yaw + 90.0);
	actor->velocity.x = actor->special1f + FLAMEROTSPEED * cos(an);
	actor->velocity.y = actor->special2f + FLAMEROTSPEED * sin(an);
	actor->angles.yaw = AngleMod360(actor->angles.yaw + 90.0 / 15.0);
}

//============================================================================
//
// A_CFlamePuff
//
//============================================================================

void A_CFlamePuff(mobj_t * actor)
{
	A_UnHideThing(actor);
	actor->velocity = vector(0.0, 0.0, 0.0);
	StartSoundName(actor, "ClericFlameExplode", CHAN_VOICE);
}

//============================================================================
//
//  A_CHolyAttack
//
//============================================================================

void A_CHolyAttack(mobj_t * actor)
{
	player_t *player = actor->player;
	mobj_t *mo;

	player->mana[MANA_1] -=
		WeaponManaUse(player->pclass, player->readyweapon);
	player->mana[MANA_2] -=
		WeaponManaUse(player->pclass, player->readyweapon);
	mo = SpawnPlayerMissile(player->mo, MT_HOLY_MISSILE);
	player->damagecount = 0;
	player->bonuscount = 0;
	player->weapon_palette = STARTHOLYPAL;
	StartSoundName(player->mo, "HolySymbolFire", CHAN_WEAPON);
}

//============================================================================
//
//  A_CHolyPalette
//
//============================================================================

void A_CHolyPalette(mobj_t * actor)
{
	player_t *player = actor->player;
	pspdef_t *psp = &player->psprites[ps_weapon];
	int pal;

	pal = STARTHOLYPAL + psp->statenum - S_CHOLYATK_6;
	if (pal == STARTHOLYPAL + 3)
	{
		// reset back to original playpal
		pal = 0;
	}
	player->weapon_palette = pal;
}

//============================================================================
//
//  A_CHolyAttack2
//
//  Spawns the spirits
//
//============================================================================

void A_CHolyAttack2(mobj_t * actor)
{
	int j;
	int i;
	mobj_t *mo;
	mobj_t *tail;
	mobj_t *next;

	for (j = 0; j < 4; j++)
	{
		mo =
			P_SpawnMobj(actor->origin.x, actor->origin.y, actor->origin.z,
			MT_HOLY_FX);
		if (!mo)
		{
			continue;
		}
		switch (j)
		{	// float bob index
		case 0:
			mo->special2 = P_Random() & 7;	// upper-left
			break;
		case 1:
			mo->special2 = 32 + (P_Random() & 7);	// upper-right
			break;
		case 2:
			mo->special2 = (32 + (P_Random() & 7)) << 16;	// lower-left
			break;
		case 3:
			mo->special2 =
				((32 + (P_Random() & 7)) << 16) + 32 + (P_Random() & 7);
			break;
		}
		mo->origin.z = actor->origin.z;
		mo->angles.yaw = AngleMod360(actor->angles.yaw +
			(45.0 + 45.0 / 2.0) - 45.0 * itof(j));
		P_ThrustMobj(mo, mo->angles.yaw, mo->speed * frametime);
		mo->target = actor->target;
		mo->args[0] = 10;	// initial turn value
		mo->args[1] = 0;	// initial look angle
		if (deathmatch)
		{
			// Ghosts last slightly less longer in DeathMatch
			mo->health = 85;
		}
		if (linetarget)
		{
			mo->specialmobj1 = linetarget;
			mo->flags |= MF_NOCLIP | MF_SKULLFLY;
			mo->flags &= ~MF_MISSILE;
		}
		tail = P_SpawnMobj(mo->origin.x, mo->origin.y, mo->origin.z,
			MT_HOLY_TAIL);
		tail->specialmobj2 = mo;	// parent
		for (i = 1; i < 3; i++)
		{
			next = P_SpawnMobj(mo->origin.x, mo->origin.y, mo->origin.z,
				MT_HOLY_TAIL);
			SetMobjState(next, next->spawnstate + 1);
			tail->specialmobj1 = next;
			tail = next;
		}
		tail->specialmobj1 = NULL;	// last tail bit
	}
}

//============================================================================
//
//  CHolyFindTarget
//
//============================================================================

void CHolyFindTarget(mobj_t * actor)
{
	mobj_t *target;

	if ((target = P_RoughMonsterSearch(actor, 6)))
	{
		actor->specialmobj1 = target;
		actor->flags |= MF_NOCLIP | MF_SKULLFLY;
		actor->flags &= ~MF_MISSILE;
	}
}

//============================================================================
//
//  CHolySeekerMissile
//
//  Similar to SeekerMissile, but seeks to a random Z on the target
//
//============================================================================

void CHolySeekerMissile(mobj_t * actor, float thresh, float turnMax)
{
	int dir;
	float dist;
	float delta;
	float angle;
	mobj_t *target;
	float newZ;
	float deltaZ;

	target = actor->specialmobj1;
	if (!target)
	{
		return;
	}
	if (!(target->flags & MF_SHOOTABLE)
		|| (!(target->flags & MF_COUNTKILL) && !target->player))
	{
		// Target died/target isn't a player or creature
		actor->specialmobj1 = NULL;
		actor->flags &= ~(MF_NOCLIP | MF_SKULLFLY);
		actor->flags |= MF_MISSILE;
		CHolyFindTarget(actor);
		return;
	}
	dir = P_FaceMobj(actor, target, &delta);
	if (delta > thresh)
	{
		delta /= 2.0;
		if (delta > turnMax)
		{
			delta = turnMax;
		}
	}
	if (dir)
	{
		// Turn clockwise
		actor->angles.yaw += delta;
	}
	else
	{
		// Turn counter clockwise
		actor->angles.yaw -= delta;
	}
	actor->angles.yaw = AngleMod360(actor->angles.yaw);
	angle = actor->angles.yaw;
	actor->velocity.x = actor->speed * cos(angle);
	actor->velocity.y = actor->speed * sin(angle);
	if (!(level->tictime & 15) ||
		actor->origin.z > target->origin.z + target->height ||
		actor->origin.z + actor->height < target->origin.z)
	{
		newZ = target->origin.z + Random() * target->height;
		deltaZ = newZ - actor->origin.z;
		if (fabs(deltaZ) > 15.0)
		{
			if (deltaZ > 0.0)
			{
				deltaZ = 15.0;
			}
			else
			{
				deltaZ = -15.0;
			}
		}
		dist = MobjDist2(target, actor);
		dist = dist / actor->speed;
		if (dist < 1.0)
		{
			dist = 1.0;
		}
		actor->velocity.z = deltaZ / dist;
	}
	return;
}

//============================================================================
//
// A_CHolyWeave
//
//============================================================================

void CHolyWeave(mobj_t * actor)
{
	float newX, newY;
	int weaveXY, weaveZ;
	float angle;

	weaveXY = actor->special2 >> 16;
	weaveZ = actor->special2 & 0xFFFF;
	angle = AngleMod360(actor->angles.yaw + 90.0);
	newX = actor->origin.x - cos(angle) * FloatBobOffsets[weaveXY] * 4.0;
	newY = actor->origin.y - sin(angle) * FloatBobOffsets[weaveXY] * 4.0;
	weaveXY = (weaveXY + (P_Random() % 5)) & 63;
	newX += cos(angle) * FloatBobOffsets[weaveXY] * 4.0;
	newY += sin(angle) * FloatBobOffsets[weaveXY] * 4.0;
	P_TryMove(actor, newX, newY);
	actor->origin.z -= FloatBobOffsets[weaveZ] * 2.0;
	weaveZ = (weaveZ + (P_Random() % 5)) & 63;
	actor->origin.z += FloatBobOffsets[weaveZ] * 2.0;
	actor->special2 = weaveZ + (weaveXY << 16);
}

//============================================================================
//
// A_CHolySeek
//
//============================================================================

void A_CHolySeek(mobj_t * actor)
{
	actor->health--;
	if (actor->health <= 0)
	{
		actor->velocity.x /= 4.0;
		actor->velocity.y /= 4.0;
		actor->velocity.z = 0.0;
		SetMobjState(actor, actor->deathstate);
		actor->time -= Random() * 0.1;
		return;
	}
	if (actor->specialmobj1)
	{
		CHolySeekerMissile(actor, itof(actor->args[0]),
			itof(actor->args[0]) * 2.0);
		if (!((level->tictime + 7) & 15))
		{
			actor->args[0] = 5 + (P_Random() / 20);
		}
	}
	CHolyWeave(actor);
}

//============================================================================
//
// A_CHolyCheckScream
//
//============================================================================

void A_CHolyCheckScream(mobj_t * actor)
{
	A_CHolySeek(actor);
	if (P_Random() < 20)
	{
		StartSoundName(actor, "SpiritActive", CHAN_VOICE);
	}
	if (!actor->specialmobj1)
	{
		CHolyFindTarget(actor);
	}
}

//============================================================================
//
// CHolyTailFollow
//
//============================================================================

void CHolyTailFollow(mobj_t * actor, float dist)
{
	mobj_t *child;
	float an;
	float oldDistance, newDistance;

	child = actor->specialmobj1;
	if (child)
	{
		an = atan2(child->origin.y - actor->origin.y,
			actor->origin.x - child->origin.x);
		oldDistance = MobjDist(child, actor);
		if (P_TryMove(child, actor->origin.x + dist * cos(an),
				actor->origin.y + dist * sin(an)))
		{
			newDistance = MobjDist2(child, actor) - 1.0;
			if (oldDistance < 1.0)
			{
				if (child->origin.z < actor->origin.z)
				{
					child->origin.z = actor->origin.z - dist;
				}
				else
				{
					child->origin.z = actor->origin.z + dist;
				}
			}
			else
			{
				child->origin.z = actor->origin.z +
					newDistance / oldDistance * (child->origin.z -
					actor->origin.z);
			}
		}
		CHolyTailFollow(child, dist - 1.0);
	}
}

//============================================================================
//
// CHolyTailRemove
//
//============================================================================

void CHolyTailRemove(mobj_t * actor)
{
	mobj_t *child;

	child = actor->specialmobj1;
	if (child)
	{
		CHolyTailRemove(child);
	}
	P_RemoveMobj(actor);
}

//============================================================================
//
// A_CHolyTail
//
//============================================================================

void A_CHolyTail(mobj_t * actor)
{
	mobj_t *parent;

	parent = actor->specialmobj2;

	if (parent)
	{
		if (parent->statenum >= parent->deathstate)
		{
			// Ghost removed, so remove all tail parts
			CHolyTailRemove(actor);
			return;
		}
		else if (P_TryMove(actor,
				parent->origin.x - 14.0 * cos(parent->angles.yaw),
				parent->origin.y - 14.0 * sin(parent->angles.yaw)))
		{
			actor->origin.z = parent->origin.z - 5.0;
		}
		CHolyTailFollow(actor, 10.0);
	}
}

//============================================================================
//
// A_CHolySpawnPuff
//
//============================================================================

void A_CHolySpawnPuff(mobj_t * actor)
{
	P_SpawnMobj(actor->origin.x, actor->origin.y, actor->origin.z,
		MT_HOLY_MISSILE_PUFF);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.6  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.5  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/30 17:33:18  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:53  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
