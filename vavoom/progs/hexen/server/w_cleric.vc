//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

//**************************************************************************
//**************************************************************************
//
//	WeaponClericMace
//
//**************************************************************************
//**************************************************************************

class WeaponClericMace:Weapon
{

//===========================================================================
//
//  A_CMaceAttack
//
//===========================================================================

void A_CMaceAttack(void)
{
	int damage;
	int i;
	TAVec angles;
	TVec vforward;

	damage = 25 + (P_Random() & 15);
	PuffType = HammerPuff;
	for (i = 0; i < 16; i++)
	{
		angles = Player->MO.Angles;
		angles.yaw = AngleMod360(angles.yaw + itof(i) * (45.0 / 16.0));
		AimLineAttack(Player->MO, &angles, 2.0 * MELEERANGE);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			if (LineAttack(Player->MO, vforward, 2.0 * MELEERANGE, damage))
			{
				Player->MO.PlaySound('FighterHammerMiss', CHAN_WEAPON);
			}
			PlayerPawn(Player->MO).AdjustPlayerAngle();
			return;
		}
		angles = Player->MO.Angles;
		angles.yaw = AngleMod360(angles.yaw - itof(i) * (45.0 / 16.0));
		AimLineAttack(Player->MO, &angles, 2.0 * MELEERANGE);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			if (LineAttack(Player->MO, vforward, 2.0 * MELEERANGE, damage))
			{
				Player->MO.PlaySound('FighterHammerMiss', CHAN_WEAPON);
			}
			PlayerPawn(Player->MO).AdjustPlayerAngle();
			return;
		}
	}
	// didn't find any creatures, so try to strike any walls
	avcpy(Player->MO.Angles, angles);
	AimLineAttack(Player->MO, &angles, MELEERANGE);
	AngleVector(&angles, &vforward);
	if (LineAttack(Player->MO, vforward, MELEERANGE, damage))
	{
		Player->MO.PlaySound('FighterHammerMiss', CHAN_WEAPON);
	}
}

__states__
{
	S_CMACEREADY('CMCE', 0, 1.0 / 35.0, S_CMACEREADY) { A_WeaponReady(); }
	S_CMACEDOWN('CMCE', 0, 1.0 / 35.0, S_CMACEDOWN) { A_Lower(); }
	S_CMACEUP('CMCE', 0, 1.0 / 35.0, S_CMACEUP) { A_Raise(); }
	S_CMACEATK_1('CMCE', 1, 2.0 / 35.0, S_CMACEATK_2) { SX = 60.0; SY = 20.0; }
	S_CMACEATK_2('CMCE', 1, 1.0 / 35.0, S_CMACEATK_3) { SX = 30.0; SY = 33.0; }
	S_CMACEATK_3('CMCE', 1, 2.0 / 35.0, S_CMACEATK_4) { SX = 8.0; SY = 45.0; }
	S_CMACEATK_4('CMCE', 2, 1.0 / 35.0, S_CMACEATK_5) { SX = 8.0; SY = 45.0; }
	S_CMACEATK_5('CMCE', 3, 1.0 / 35.0, S_CMACEATK_6) { SX = 8.0; SY = 45.0; }
	S_CMACEATK_6('CMCE', 4, 1.0 / 35.0, S_CMACEATK_7) { SX = 8.0; SY = 45.0; }
	S_CMACEATK_7('CMCE', 4, 1.0 / 35.0, S_CMACEATK_8) { SX = -11.0; SY = 58.0; A_CMaceAttack(); }
	S_CMACEATK_8('CMCE', 5, 1.0 / 35.0, S_CMACEATK_9) { SX = 8.0; SY = 45.0; }
	S_CMACEATK_9('CMCE', 5, 2.0 / 35.0, S_CMACEATK_10) { SX = -8.0; SY = 74.0; }
	S_CMACEATK_10('CMCE', 5, 1.0 / 35.0, S_CMACEATK_11) { SX = -20.0; SY = 96.0; }
	S_CMACEATK_11('CMCE', 5, 8.0 / 35.0, S_CMACEATK_12) { SX = -33.0; SY = 160.0; }
	S_CMACEATK_12('CMCE', 0, 2.0 / 35.0, S_CMACEATK_13) { SX = 8.0; SY = 75.0; A_ReFire(); }
	S_CMACEATK_13('CMCE', 0, 1.0 / 35.0, S_CMACEATK_14) { SX = 8.0; SY = 65.0; }
	S_CMACEATK_14('CMCE', 0, 2.0 / 35.0, S_CMACEATK_15) { SX = 8.0; SY = 60.0; }
	S_CMACEATK_15('CMCE', 0, 1.0 / 35.0, S_CMACEATK_16) { SX = 8.0; SY = 55.0; }
	S_CMACEATK_16('CMCE', 0, 2.0 / 35.0, S_CMACEATK_17) { SX = 8.0; SY = 50.0; }
	S_CMACEATK_17('CMCE', 0, 1.0 / 35.0, S_CMACEREADY) { SX = 8.0; SY = 45.0; }
}

defaultproperties
{
	Mana = MANA_NONE;
	UpState = S_CMACEUP;
	DownState = S_CMACEDOWN;
	ReadyState = S_CMACEREADY;
	AttackState = S_CMACEATK_1;
	HoldAttackState = S_CMACEATK_1;
	PSpriteSY = -8.0;
}

}

//**************************************************************************
//**************************************************************************
//
//	WeaponClericStaff
//
//**************************************************************************
//**************************************************************************

class WeaponClericStaff:Weapon
{

int BlinkCount;
int BlinkState;
int Attack2State;

//============================================================================
//
//  A_CStaffInitBlink
//
//============================================================================

void A_CStaffInitBlink(void)
{
	BlinkCount = (P_Random() >> 1) + 20;
}

//============================================================================
//
//  A_CStaffCheckBlink
//
//============================================================================

void A_CStaffCheckBlink(void)
{
	if (!--BlinkCount)
	{
		SetState(BlinkState);
		BlinkCount = (P_Random() + 50) >> 2;
	}
}

//============================================================================
//
//  A_CStaffCheck
//
//============================================================================

void A_CStaffCheck(void)
{
	Actor pmo;
	int damage;
	int newLife;
	int i;
	TAVec angles;
	TVec vforward;

	pmo = Player->MO;
	damage = 20 + (P_Random() & 15);
	PuffType = ClericStaffPuff;
	for (i = 0; i < 3; i++)
	{
		angles = pmo.Angles;
		angles.yaw = AngleMod360(angles.yaw + itof(i) * (45.0 / 16.0));
		AimLineAttack(pmo, &angles, 3.0 * MELEERANGE / 2.0);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			LineAttack(pmo, vforward, 1.5 * MELEERANGE, damage);
			pmo.Angles.yaw = atan2(linetarget.Origin.y - pmo.Origin.y,
				linetarget.Origin.x - pmo.Origin.x);
			if ((linetarget.bIsPlayer || linetarget.bCountKill) &&
				!linetarget.bDormant && !linetarget.bInvulnerable)
			{
				newLife = Player->Health + (damage >> 3);
				newLife = newLife > 100 ? 100 : newLife;
				pmo.Health = newLife;
				Player->Health = newLife;
				SetState(Attack2State);
			}
			Player->Mana[MANA_1] -=
				WeaponManaUse(Player->PClass, Player->ReadyWeapon);
			break;
		}
		angles = pmo.Angles;
		angles.yaw = AngleMod360(angles.yaw - itof(i) * (45.0 / 16.0));
		AimLineAttack(Player->MO, &angles, 3.0 * MELEERANGE / 2.0);
		if (linetarget)
		{
			AngleVector(&angles, &vforward);
			LineAttack(pmo, vforward, 1.5 * MELEERANGE, damage);
			pmo.Angles.yaw = atan2(linetarget.Origin.y - pmo.Origin.y,
				linetarget.Origin.x - pmo.Origin.x);
			if (linetarget.bIsPlayer || linetarget.bCountKill)
			{
				newLife = Player->Health + (damage >> 4);
				newLife = newLife > 100 ? 100 : newLife;
				pmo.Health = newLife;
				Player->Health = pmo.Health;
				SetState(Attack2State);
			}
			Player->Mana[MANA_1] -=
				WeaponManaUse(Player->PClass, Player->ReadyWeapon);
			break;
		}
	}
}

//============================================================================
//
//  A_CStaffAttack
//
//============================================================================

void A_CStaffAttack(void)
{
	Actor mo;
	PlayerPawn playPawn;

	Player->Mana[MANA_1] -=
		WeaponManaUse(Player->PClass, Player->ReadyWeapon);
	playPawn = PlayerPawn(Player->MO);
	mo = playPawn.SpawnPlayerMissileAngle(ClericStaffMissile,
		playPawn.Angles.yaw - (45.0 / 15.0));
	if (mo)
	{
		mo._Special2 = 32;
	}
	mo = playPawn.SpawnPlayerMissileAngle(ClericStaffMissile,
		playPawn.Angles.yaw + (45.0 / 15.0));
	if (mo)
	{
		mo._Special2 = 0;
	}
	playPawn.PlaySound('ClericCStaffFire', CHAN_WEAPON);
}

__states__
{
	S_CSTAFFREADY('CSSF', 2, 4.0 / 35.0, S_CSTAFFREADY1) { }
	S_CSTAFFREADY1('CSSF', 1, 3.0 / 35.0, S_CSTAFFREADY2) { A_CStaffInitBlink(); }
	S_CSTAFFREADY2('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY3) { A_WeaponReady(); }
	S_CSTAFFREADY3('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY4) { A_WeaponReady(); }
	S_CSTAFFREADY4('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY5) { A_WeaponReady(); }
	S_CSTAFFREADY5('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY6) { A_WeaponReady(); }
	S_CSTAFFREADY6('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY7) { A_WeaponReady(); }
	S_CSTAFFREADY7('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY8) { A_WeaponReady(); }
	S_CSTAFFREADY8('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY9) { A_WeaponReady(); }
	S_CSTAFFREADY9('CSSF', 0, 1.0 / 35.0, S_CSTAFFREADY2) { A_CStaffCheckBlink(); }
	S_CSTAFFBLINK1('CSSF', 1, 1.0 / 35.0, S_CSTAFFBLINK2) { A_WeaponReady(); }
	S_CSTAFFBLINK2('CSSF', 1, 1.0 / 35.0, S_CSTAFFBLINK3) { A_WeaponReady(); }
	S_CSTAFFBLINK3('CSSF', 1, 1.0 / 35.0, S_CSTAFFBLINK4) { A_WeaponReady(); }
	S_CSTAFFBLINK4('CSSF', 2, 1.0 / 35.0, S_CSTAFFBLINK5) { A_WeaponReady(); }
	S_CSTAFFBLINK5('CSSF', 2, 1.0 / 35.0, S_CSTAFFBLINK6) { A_WeaponReady(); }
	S_CSTAFFBLINK6('CSSF', 2, 1.0 / 35.0, S_CSTAFFBLINK7) { A_WeaponReady(); }
	S_CSTAFFBLINK7('CSSF', 2, 1.0 / 35.0, S_CSTAFFBLINK8) { A_WeaponReady(); }
	S_CSTAFFBLINK8('CSSF', 2, 1.0 / 35.0, S_CSTAFFBLINK9) { A_WeaponReady(); }
	S_CSTAFFBLINK9('CSSF', 1, 1.0 / 35.0, S_CSTAFFBLINK10) { A_WeaponReady(); }
	S_CSTAFFBLINK10('CSSF', 1, 1.0 / 35.0, S_CSTAFFBLINK11) { A_WeaponReady(); }
	S_CSTAFFBLINK11('CSSF', 1, 1.0 / 35.0, S_CSTAFFREADY2) { A_WeaponReady(); }
	S_CSTAFFDOWN('CSSF', 1, 3.0 / 35.0, S_CSTAFFDOWN2) { }
	S_CSTAFFDOWN2('CSSF', 2, 4.0 / 35.0, S_CSTAFFDOWN3) { }
	S_CSTAFFDOWN3('CSSF', 2, 1.0 / 35.0, S_CSTAFFDOWN3) { A_Lower(); }
	S_CSTAFFUP('CSSF', 2, 1.0 / 35.0, S_CSTAFFUP) { A_Raise(); }
	S_CSTAFFATK_1('CSSF', 0, 1.0 / 35.0, S_CSTAFFATK_2) { SY = 45.0; A_CStaffCheck(); }
	S_CSTAFFATK_2('CSSF', 9, 1.0 / 35.0, S_CSTAFFATK_3) { SY = 50.0; A_CStaffAttack(); }
	S_CSTAFFATK_3('CSSF', 9, 2.0 / 35.0, S_CSTAFFATK_4) { SY = 50.0; }
	S_CSTAFFATK_4('CSSF', 9, 2.0 / 35.0, S_CSTAFFATK_5) { SY = 45.0; }
	S_CSTAFFATK_5('CSSF', 0, 2.0 / 35.0, S_CSTAFFATK_6) { SY = 40.0; }
	S_CSTAFFATK_6('CSSF', 0, 2.0 / 35.0, S_CSTAFFREADY2) { SY = 36.0; }
	S_CSTAFFATK2_1('CSSF', 10, 10.0 / 35.0, S_CSTAFFREADY2) { SY = 36.0; }
}

defaultproperties
{
	Mana = MANA_1;
	UpState = S_CSTAFFUP;
	DownState = S_CSTAFFDOWN;
	ReadyState = S_CSTAFFREADY;
	BlinkState = S_CSTAFFBLINK1;
	AttackState = S_CSTAFFATK_1;
	HoldAttackState = S_CSTAFFATK_1;
	Attack2State = S_CSTAFFATK2_1;
	PSpriteSY = 10.0;
}

}

//**************************************************************************
//**************************************************************************
//
//	WeaponClericFire
//
//**************************************************************************
//**************************************************************************

class WeaponClericFire:Weapon
{

//============================================================================
//
//  A_CFlameAttack
//
//============================================================================

void A_CFlameAttack(void)
{
	Actor mo;

	mo = PlayerPawn(Player->MO).SpawnPlayerMissile(ClericFlameMissile);
	if (mo)
	{
		mo.bBlaster = true;
		mo._Special1 = 2;
	}

	Player->Mana[MANA_2] -=
		WeaponManaUse(Player->PClass, Player->ReadyWeapon);
	Player->MO.PlaySound('ClericFlameFire', CHAN_WEAPON);
}

__states__
{
	S_CFLAMEREADY1('CFLM', 0, 1.0 / 35.0, S_CFLAMEREADY2) { A_WeaponReady(); }
	S_CFLAMEREADY2('CFLM', 0, 1.0 / 35.0, S_CFLAMEREADY3) { A_WeaponReady(); }
	S_CFLAMEREADY3('CFLM', 0, 1.0 / 35.0, S_CFLAMEREADY4) { A_WeaponReady(); }
	S_CFLAMEREADY4('CFLM', 0, 1.0 / 35.0, S_CFLAMEREADY5) { A_WeaponReady(); }
	S_CFLAMEREADY5('CFLM', 1, 1.0 / 35.0, S_CFLAMEREADY6) { A_WeaponReady(); }
	S_CFLAMEREADY6('CFLM', 1, 1.0 / 35.0, S_CFLAMEREADY7) { A_WeaponReady(); }
	S_CFLAMEREADY7('CFLM', 1, 1.0 / 35.0, S_CFLAMEREADY8) { A_WeaponReady(); }
	S_CFLAMEREADY8('CFLM', 1, 1.0 / 35.0, S_CFLAMEREADY9) { A_WeaponReady(); }
	S_CFLAMEREADY9('CFLM', 2, 1.0 / 35.0, S_CFLAMEREADY10) { A_WeaponReady(); }
	S_CFLAMEREADY10('CFLM', 2, 1.0 / 35.0, S_CFLAMEREADY11) { A_WeaponReady(); }
	S_CFLAMEREADY11('CFLM', 2, 1.0 / 35.0, S_CFLAMEREADY12) { A_WeaponReady(); }
	S_CFLAMEREADY12('CFLM', 2, 1.0 / 35.0, S_CFLAMEREADY1) { A_WeaponReady(); }
	S_CFLAMEDOWN('CFLM', 0, 1.0 / 35.0, S_CFLAMEDOWN) { A_Lower(); }
	S_CFLAMEUP('CFLM', 0, 1.0 / 35.0, S_CFLAMEUP) { A_Raise(); }
	S_CFLAMEATK_1('CFLM', 0, 2.0 / 35.0, S_CFLAMEATK_2) { SY = 40.0; }
	S_CFLAMEATK_2('CFLM', 3, 2.0 / 35.0, S_CFLAMEATK_3) { SY = 50.0; }
	S_CFLAMEATK_3('CFLM', 3, 2.0 / 35.0, S_CFLAMEATK_4) { SY = 36.0; }
	S_CFLAMEATK_4('CFLM', 4 | FF_FULLBRIGHT, 4.0 / 35.0, S_CFLAMEATK_5) { }
	S_CFLAMEATK_5('CFLM', 5 | FF_FULLBRIGHT, 4.0 / 35.0, S_CFLAMEATK_6) { A_CFlameAttack(); }
	S_CFLAMEATK_6('CFLM', 4 | FF_FULLBRIGHT, 4.0 / 35.0, S_CFLAMEATK_7) { }
	S_CFLAMEATK_7('CFLM', 6, 2.0 / 35.0, S_CFLAMEATK_8) { SY = 40.0; }
	S_CFLAMEATK_8('CFLM', 6, 2.0 / 35.0, S_CFLAMEREADY1) { }
}

defaultproperties
{
	Mana = MANA_2;
	UpState = S_CFLAMEUP;
	DownState = S_CFLAMEDOWN;
	ReadyState = S_CFLAMEREADY1;
	AttackState = S_CFLAMEATK_1;
	HoldAttackState = S_CFLAMEATK_1;
	PSpriteSY = 10.0;
}

}

//**************************************************************************
//**************************************************************************
//
//	WeaponClericHoly
//
//**************************************************************************
//**************************************************************************

class WeaponClericHoly:Weapon
{

//============================================================================
//
//  A_CHolyAttack
//
//============================================================================

void A_CHolyAttack(void)
{
	Player->Mana[MANA_1] -=
		WeaponManaUse(Player->PClass, Player->ReadyWeapon);
	Player->Mana[MANA_2] -=
		WeaponManaUse(Player->PClass, Player->ReadyWeapon);
	PlayerPawn(Player->MO).SpawnPlayerMissile(HolyMissile);
	Player->DamageCount = 0;
	Player->BonusCount = 0;
	Player->WeaponPalette = STARTHOLYPAL;
	Player->MO.PlaySound('HolySymbolFire', CHAN_WEAPON);
}

//============================================================================
//
//  A_CHolyPalette1
//
//============================================================================

void A_CHolyPalette1(void)
{
	Player->WeaponPalette = STARTHOLYPAL + 1;
}

//============================================================================
//
//  A_CHolyPalette2
//
//============================================================================

void A_CHolyPalette2(void)
{
	Player->WeaponPalette = STARTHOLYPAL + 2;
}

//============================================================================
//
//  A_CHolyPalette3
//
//============================================================================

void A_CHolyPalette3(void)
{
	// reset back to original playpal
	Player->WeaponPalette = 0;
}

__states__
{
	S_CHOLYREADY('CHLY', 0, 1.0 / 35.0, S_CHOLYREADY) { A_WeaponReady(); }
	S_CHOLYDOWN('CHLY', 0, 1.0 / 35.0, S_CHOLYDOWN) { A_Lower(); }
	S_CHOLYUP('CHLY', 0, 1.0 / 35.0, S_CHOLYUP) { A_Raise(); }
	S_CHOLYATK_1('CHLY', 0 | FF_FULLBRIGHT, 1.0 / 35.0, S_CHOLYATK_2) { SY = 40.0; }
	S_CHOLYATK_2('CHLY', 1 | FF_FULLBRIGHT, 1.0 / 35.0, S_CHOLYATK_3) { SY = 40.0; }
	S_CHOLYATK_3('CHLY', 2 | FF_FULLBRIGHT, 2.0 / 35.0, S_CHOLYATK_4) { SY = 43.0; }
	S_CHOLYATK_4('CHLY', 3 | FF_FULLBRIGHT, 2.0 / 35.0, S_CHOLYATK_5) { SY = 43.0; }
	S_CHOLYATK_5('CHLY', 4 | FF_FULLBRIGHT, 2.0 / 35.0, S_CHOLYATK_6) { SY = 45.0; }
	S_CHOLYATK_6('CHLY', 5 | FF_FULLBRIGHT, 6.0 / 35.0, S_CHOLYATK_7) { SY = 48.0; A_CHolyAttack(); }
	S_CHOLYATK_7('CHLY', 6 | FF_FULLBRIGHT, 2.0 / 35.0, S_CHOLYATK_8) { SY = 40.0; A_CHolyPalette1(); }
	S_CHOLYATK_8('CHLY', 6 | FF_FULLBRIGHT, 2.0 / 35.0, S_CHOLYATK_9) { SY = 40.0; A_CHolyPalette2(); }
	S_CHOLYATK_9('CHLY', 6 | FF_FULLBRIGHT, 2.0 / 35.0, S_CHOLYREADY) { SY = 36.0; A_CHolyPalette3(); }
}

defaultproperties
{
	Mana = MANA_BOTH;
	UpState = S_CHOLYUP;
	DownState = S_CHOLYDOWN;
	ReadyState = S_CHOLYREADY;
	AttackState = S_CHOLYATK_1;
	HoldAttackState = S_CHOLYATK_1;
	PSpriteSY = 0.0;
}

}

//**************************************************************************
//**************************************************************************

//============================================================================
//
//  Actor::A_CStaffMissileSlither
//
//============================================================================

void Actor::A_CStaffMissileSlither(void)
{
	float newX, newY;
	int weaveXY;
	float angle;

	weaveXY = _Special2;
	angle = AngleMod360(Angles.yaw + 90.0);
	newX = Origin.x - cos(angle) * FloatBobOffsets[weaveXY];
	newY = Origin.y - sin(angle) * FloatBobOffsets[weaveXY];
	weaveXY = (weaveXY + 3) & 63;
	newX += cos(angle) * FloatBobOffsets[weaveXY];
	newY += sin(angle) * FloatBobOffsets[weaveXY];
	TryMove(vector(newX, newY, Origin.z));
	_Special2 = weaveXY;
}

//============================================================================
//
//  Actor::A_CFlameMissile
//
//============================================================================

#define FLAMESPEED		(9.0 / 20.0 * 35.0)

void Actor::A_CFlameMissile(void)
{
	int i;
	float an;
	float dist;
	Actor A;
	Actor bmo;

	A_UnHideThing();
	PlaySound('ClericFlameExplode', CHAN_VOICE);
	bmo = tmtrace->BlockingMobj;
	if (bmo && bmo.bShootable)
	{
		// Hit something, so spawn the flame circle around the thing
		dist = bmo.Radius + 18.0;
		for (i = 0; i < 4; i++)
		{
			an = itof(i) * 45.0;
			A = Spawn(CircleFlame, bmo.Origin +
				vector(dist * cos(an), dist * sin(an), 5.0));
			if (A)
			{
				A.Angles.yaw = an;
				A.Instigator = Instigator;
				A.Velocity.x = FLAMESPEED * cos(an);
				A.Velocity.y = FLAMESPEED * sin(an);
				A.Special1f = A.Velocity.x;
				A.Special2f = A.Velocity.y;
				A.StateTime -= Random() * 0.1;
			}
			A = Spawn(CircleFlame, bmo.Origin +
				vector(-dist * cos(an), -dist * sin(an), 5.0));
			if (A)
			{
				A.Angles.yaw = AngleMod360(180.0 + an);
				A.Instigator = Instigator;
				A.Velocity.x = -FLAMESPEED * cos(an);
				A.Velocity.y = -FLAMESPEED * sin(an);
				A.Special1f = A.Velocity.x;
				A.Special2f = A.Velocity.y;
				A.StateTime -= Random() * 0.1;
			}
		}
		SetState(S_FLAMEPUFF2_1);
	}
}

//============================================================================
//
//	Actor::A_CFlameRotate
//
//============================================================================

#define FLAMEROTSPEED	2.0 * 35.0

void Actor::A_CFlameRotate(void)
{
	float an;

	an = AngleMod360(Angles.yaw + 90.0);
	Velocity.x = Special1f + FLAMEROTSPEED * cos(an);
	Velocity.y = Special2f + FLAMEROTSPEED * sin(an);
	Angles.yaw = AngleMod360(Angles.yaw + 90.0 / 15.0);
}

//============================================================================
//
//	Actor::A_CFlamePuff
//
//============================================================================

void Actor::A_CFlamePuff(void)
{
	A_UnHideThing();
	Velocity = vector(0.0, 0.0, 0.0);
	PlaySound('ClericFlameExplode', CHAN_VOICE);
}

//============================================================================
//
//  Actor::A_CHolyAttack2
//
//  Spawns the spirits
//
//============================================================================

void Actor::A_CHolyAttack2(void)
{
	int j;
	int i;
	Actor A;
	Actor tail;
	Actor next;

	for (j = 0; j < 4; j++)
	{
		A = Spawn(HolyFX, Origin);
		if (!A)
		{
			continue;
		}
		switch (j)
		{	// float bob index
		case 0:
			A._Special2 = P_Random() & 7;	// upper-left
			break;
		case 1:
			A._Special2 = 32 + (P_Random() & 7);	// upper-right
			break;
		case 2:
			A._Special2 = (32 + (P_Random() & 7)) << 16;	// lower-left
			break;
		case 3:
			A._Special2 =
				((32 + (P_Random() & 7)) << 16) + 32 + (P_Random() & 7);
			break;
		}
		A.Origin.z = Origin.z;
		A.Angles.yaw = AngleMod360(Angles.yaw +
			(45.0 + 45.0 / 2.0) - 45.0 * itof(j));
		A.Thrust(A.Angles.yaw, A.Speed * frametime);
		A.Instigator = Instigator;
		A.Args[0] = 10;	// initial turn value
		A.Args[1] = 0;	// initial look angle
		if (deathmatch)
		{
			// Ghosts last slightly less longer in DeathMatch
			A.Health = 85;
		}
		if (linetarget)
		{
			A.Enemy = linetarget;
			//	Don't colide with world but colide with things, i.e explode
			A.bColideWithWorld = false;
			A.bSkullFly = true;
			A.bMissile = false;
		}
		tail = Spawn(HolyTail, A.Origin);
		tail.SpecialMobj2 = &A;	// parent
		for (i = 1; i < 3; i++)
		{
			next = Spawn(HolyTail, A.Origin);
			next.SetState(next.IdleState + 1);
			tail._SpecialMobj1 = &next;
			tail = next;
		}
		tail._SpecialMobj1 = NULL;	// last tail bit
	}
}

//============================================================================
//
//  Actor::CHolyFindTarget
//
//============================================================================

void Actor::CHolyFindTarget(void)
{
	Actor targ;

	targ = RoughMonsterSearch(6);
	if (targ)
	{
		Enemy = targ;
		bColideWithWorld = false;
		bSkullFly = true;
		bMissile = false;
	}
}

//============================================================================
//
//  Actor::CHolySeekerMissile
//
//  Similar to SeekerMissile, but seeks to a random Z on the target
//
//============================================================================

void Actor::CHolySeekerMissile(float thresh, float turnMax)
{
	int dir;
	float dist;
	float delta;
	float angle;
	float newZ;
	float deltaZ;

	if (!Enemy)
	{
		return;
	}
	if (!Enemy.bShootable || (!Enemy.bCountKill && !Enemy.bIsPlayer))
	{
		// Target died/target isn't a player or creature
		Enemy = none;
		bColideWithWorld = true;
		bSkullFly = false;
		bMissile = true;
		CHolyFindTarget();
		return;
	}
	dir = FaceActor(Enemy, &delta);
	if (delta > thresh)
	{
		delta /= 2.0;
		if (delta > turnMax)
		{
			delta = turnMax;
		}
	}
	if (dir)
	{
		// Turn clockwise
		Angles.yaw += delta;
	}
	else
	{
		// Turn counter clockwise
		Angles.yaw -= delta;
	}
	Angles.yaw = AngleMod360(Angles.yaw);
	angle = Angles.yaw;
	Velocity.x = Speed * cos(angle);
	Velocity.y = Speed * sin(angle);
	if (!(level->tictime & 15) ||
		Origin.z > Enemy.Origin.z + Enemy.Height ||
		Origin.z + Height < Enemy.Origin.z)
	{
		newZ = Enemy.Origin.z + Random() * Enemy.Height;
		deltaZ = newZ - Origin.z;
		if (fabs(deltaZ) > 15.0)
		{
			if (deltaZ > 0.0)
			{
				deltaZ = 15.0;
			}
			else
			{
				deltaZ = -15.0;
			}
		}
		dist = MobjDist2(Enemy, self);
		dist = dist / Speed;
		if (dist < 1.0)
		{
			dist = 1.0;
		}
		Velocity.z = deltaZ / dist;
	}
	return;
}

//============================================================================
//
//	Actor::CHolyWeave
//
//============================================================================

void Actor::CHolyWeave(void)
{
	float newX, newY;
	int weaveXY, weaveZ;
	float angle;

	weaveXY = _Special2 >> 16;
	weaveZ = _Special2 & 0xFFFF;
	angle = AngleMod360(Angles.yaw + 90.0);
	newX = Origin.x - cos(angle) * FloatBobOffsets[weaveXY] * 4.0;
	newY = Origin.y - sin(angle) * FloatBobOffsets[weaveXY] * 4.0;
	weaveXY = (weaveXY + (P_Random() % 5)) & 63;
	newX += cos(angle) * FloatBobOffsets[weaveXY] * 4.0;
	newY += sin(angle) * FloatBobOffsets[weaveXY] * 4.0;
	TryMove(vector(newX, newY, Origin.z));
	Origin.z -= FloatBobOffsets[weaveZ] * 2.0;
	weaveZ = (weaveZ + (P_Random() % 5)) & 63;
	Origin.z += FloatBobOffsets[weaveZ] * 2.0;
	_Special2 = weaveZ + (weaveXY << 16);
}

//============================================================================
//
//	Actor::A_CHolySeek
//
//============================================================================

void Actor::A_CHolySeek(void)
{
	Health--;
	if (Health <= 0)
	{
		Velocity.x /= 4.0;
		Velocity.y /= 4.0;
		Velocity.z = 0.0;
		SetState(DeathState);
		StateTime -= Random() * 0.1;
		return;
	}
	if (Enemy)
	{
		CHolySeekerMissile(itof(Args[0]), itof(Args[0]) * 2.0);
		if (!((level->tictime + 7) & 15))
		{
			Args[0] = 5 + (P_Random() / 20);
		}
	}
	CHolyWeave();
}

//============================================================================
//
//	Actor::A_CHolyCheckScream
//
//============================================================================

void Actor::A_CHolyCheckScream(void)
{
	A_CHolySeek();
	if (P_Random() < 20)
	{
		PlaySound('SpiritActive', CHAN_VOICE);
	}
	if (!Enemy)
	{
		CHolyFindTarget();
	}
}

//============================================================================
//
//	Actor::CHolyTailFollow
//
//============================================================================

void Actor::CHolyTailFollow(float dist)
{
	Actor child;
	float an;
	float oldDistance, newDistance;

	child = *_SpecialMobj1;
	if (child)
	{
		an = atan2(child.Origin.y - Origin.y,
			Origin.x - child.Origin.x);
		oldDistance = MobjDist(child, self);
		if (child.TryMove(vector(Origin.x + dist * cos(an),
				Origin.y + dist * sin(an), child.Origin.z)))
		{
			newDistance = MobjDist2(child, self) - 1.0;
			if (oldDistance < 1.0)
			{
				if (child.Origin.z < Origin.z)
				{
					child.Origin.z = Origin.z - dist;
				}
				else
				{
					child.Origin.z = Origin.z + dist;
				}
			}
			else
			{
				child.Origin.z = Origin.z + newDistance / oldDistance *
					(child.Origin.z - Origin.z);
			}
		}
		child.CHolyTailFollow(dist - 1.0);
	}
}

//============================================================================
//
//	Actor::CHolyTailRemove
//
//============================================================================

void Actor::CHolyTailRemove(void)
{
	if (_SpecialMobj1)
	{
		_SpecialMobj1->CHolyTailRemove();
	}
	Remove();
}

//============================================================================
//
//	A_CHolyTail
//
//============================================================================

void Actor::A_CHolyTail(void)
{
	Actor parent;

	parent = *SpecialMobj2;

	if (parent)
	{
		if (parent.StateNum >= parent.DeathState)
		{
			// Ghost removed, so remove all tail parts
			CHolyTailRemove();
			return;
		}
		else if (TryMove(vector(
				parent.Origin.x - 14.0 * cos(parent.Angles.yaw),
				parent.Origin.y - 14.0 * sin(parent.Angles.yaw), Origin.z)))
		{
			Origin.z = parent.Origin.z - 5.0;
		}
		CHolyTailFollow(10.0);
	}
}

//============================================================================
//
//	Actor::A_CHolySpawnPuff
//
//============================================================================

void Actor::A_CHolySpawnPuff(void)
{
	Spawn(HolyMissilePuff, Origin);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.27  2002/05/18 17:00:00  dj_jl
//  Renamed SpawnState to IdleState, other changes.
//
//  Revision 1.26  2002/04/11 16:52:16  dj_jl
//  Made TryMove native.
//
//  Revision 1.25  2002/03/28 18:15:35  dj_jl
//  Renamed mo in player_t to MO.
//
//  Revision 1.24  2002/03/20 19:07:47  dj_jl
//  Got rid of a lots of legacy, beautification.
//
//  Revision 1.23  2002/03/16 17:47:47  dj_jl
//  Got rid of mobj_t and some other legacy.
//
//  Revision 1.22  2002/03/09 17:57:02  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.21  2002/03/04 18:31:36  dj_jl
//  Replaced bNoClip with two seperate flags, beautification.
//
//  Revision 1.20  2002/03/02 17:35:55  dj_jl
//  Weapon classes
//
//  Revision 1.19  2002/02/26 17:49:49  dj_jl
//  no message
//
//  Revision 1.18  2002/02/22 18:00:25  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.17  2002/02/14 19:20:59  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.16  2002/02/06 17:28:53  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.15  2002/02/02 19:17:26  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.14  2002/01/28 18:50:19  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.13  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.12  2002/01/24 18:19:27  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.11  2002/01/17 18:15:55  dj_jl
//  Renamed all map object classes
//
//  Revision 1.10  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.9  2002/01/11 18:19:42  dj_jl
//  Started to use names in progs
//
//  Revision 1.8  2002/01/07 12:25:58  dj_jl
//  Changed copyright year
//
//  Revision 1.7  2001/12/12 18:57:42  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.6  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.5  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/30 17:33:18  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:53  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
