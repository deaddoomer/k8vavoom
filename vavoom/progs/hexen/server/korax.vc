//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

//===========================================================================
//
// Korax Variables
//  special1    last teleport destination
//  special2    set if "below half" script not yet run
//
// Korax Scripts (reserved)
//  249     Tell scripts that we are below half health
//  250-254 Control scripts
//  255     Death script
//
// Korax TIDs (reserved)
//  245     Reserved for Korax himself
//  248     Initial teleport destination
//  249     Teleport destination
//  250-254 For use in respective control scripts
//  255     For use in death script (spawn spots)
//
//===========================================================================
//
// Arm projectiles
//      arm positions numbered:
//          1   top left
//          2   middle left
//          3   lower left
//          4   top right
//          5   middle right
//          6   lower right
//
//===========================================================================

// MACROS ------------------------------------------------------------------

#define KORAX_FIRST_TELEPORT_TID	(248)
#define KORAX_TELEPORT_TID			(249)

#define KORAX_DELTAANGLE			85.0
#define KORAX_ARM_EXTENSION_SHORT	40.0
#define KORAX_ARM_EXTENSION_LONG	55.0

#define KORAX_ARM1_HEIGHT			108.0
#define KORAX_ARM2_HEIGHT			82.0
#define KORAX_ARM3_HEIGHT			54.0
#define KORAX_ARM4_HEIGHT			104.0
#define KORAX_ARM5_HEIGHT			86.0
#define KORAX_ARM6_HEIGHT			53.0

#define KORAX_COMMAND_HEIGHT		120.0
#define KORAX_COMMAND_OFFSET		27.0

#define KORAX_BOLT_HEIGHT			48.0
#define KORAX_BOLT_LIFETIME			3

#define KORAX_SPIRIT_LIFETIME		(5*(35/5))	// 5 seconds

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//============================================================================
//
//  Actor::A_KoraxStep
//
//============================================================================

void Actor::A_KoraxStep(void)
{
	A_Chase();
}

//============================================================================
//
//  Actor::A_KoraxStep2
//
//============================================================================

void Actor::A_KoraxStep2(void)
{
	StartSoundName(NULL, 'KoraxStep', CHAN_BODY);
	A_Chase();
}

//============================================================================
//
//  Actor::A_KoraxChase
//
//============================================================================

void Actor::A_KoraxChase(void)
{
	mobj_t *spot;
	int search;
	int args[3];

	args[0] = args[1] = args[2] = 0;
	if ((!special2) && (Health <= (spawnhealth / 2)))
	{
		search = 0;
		spot = P_FindMobjFromTID(KORAX_FIRST_TELEPORT_TID, &search);
		if (spot)
		{
			P_Teleport(this, spot->origin.x, spot->origin.y,
				spot->angles.yaw, true);
		}

		StartACS(249, 0, &args[0], this, NULL, 0);
		special2 = 1;	// Don't run again

		return;
	}

	if (!target)
		return;
	if (P_Random() < 30)
	{
		SetState(MissileState);
	}
	else if (P_Random() < 30)
	{
		StartSoundName(NULL, 'KoraxActive', CHAN_VOICE);
	}

	// Teleport away
	if (Health < (spawnhealth >> 1))
	{
		if (P_Random() < 10)
		{
			spot = P_FindMobjFromTID(KORAX_TELEPORT_TID, &special1);
			if (spot)
			{
				P_Teleport(this, spot->origin.x, spot->origin.y,
					spot->angles.yaw, true);
			}
		}
	}
}

//============================================================================
//
//  Actor::A_KoraxDecide
//
//============================================================================

void Actor::A_KoraxDecide(void)
{
	if (P_Random() < 220)
	{
		SetState(S_KORAX_MISSILE1);
	}
	else
	{
		SetState(S_KORAX_COMMAND1);
	}
}

//============================================================================
// Arm 1 projectile
//============================================================================

void KoraxFire1(mobj_t * actor, classid type)
{
	mobj_t *mo;
	float ang;
	float x, y, z;

	ang = AngleMod360(actor->angles.yaw - KORAX_DELTAANGLE);
	x = actor->origin.x + KORAX_ARM_EXTENSION_SHORT * cos(ang);
	y = actor->origin.y + KORAX_ARM_EXTENSION_SHORT * sin(ang);
	z = actor->origin.z - actor->floorclip + KORAX_ARM1_HEIGHT;
	mo = SpawnKoraxMissile(x, y, z, actor, actor->target, type);
}

//============================================================================
// Arm 2 projectile
//============================================================================

void KoraxFire2(mobj_t * actor, classid type)
{
	mobj_t *mo;
	float ang;
	float x, y, z;

	ang = AngleMod360(actor->angles.yaw - KORAX_DELTAANGLE);
	x = actor->origin.x + KORAX_ARM_EXTENSION_LONG * cos(ang);
	y = actor->origin.y + KORAX_ARM_EXTENSION_LONG * sin(ang);
	z = actor->origin.z - actor->floorclip + KORAX_ARM2_HEIGHT;
	mo = SpawnKoraxMissile(x, y, z, actor, actor->target, type);
}

//============================================================================
// Arm 3 projectile
//============================================================================

void KoraxFire3(mobj_t * actor, classid type)
{
	mobj_t *mo;
	float ang;
	float x, y, z;

	ang = AngleMod360(actor->angles.yaw - KORAX_DELTAANGLE);
	x = actor->origin.x + KORAX_ARM_EXTENSION_LONG * cos(ang);
	y = actor->origin.y + KORAX_ARM_EXTENSION_LONG * sin(ang);
	z = actor->origin.z - actor->floorclip + KORAX_ARM3_HEIGHT;
	mo = SpawnKoraxMissile(x, y, z, actor, actor->target, type);
}

//============================================================================
// Arm 4 projectile
//============================================================================

void KoraxFire4(mobj_t * actor, classid type)
{
	mobj_t *mo;
	float ang;
	float x, y, z;

	ang = AngleMod360(actor->angles.yaw + KORAX_DELTAANGLE);
	x = actor->origin.x + KORAX_ARM_EXTENSION_SHORT * cos(ang);
	y = actor->origin.y + KORAX_ARM_EXTENSION_SHORT * sin(ang);
	z = actor->origin.z - actor->floorclip + KORAX_ARM4_HEIGHT;
	mo = SpawnKoraxMissile(x, y, z, actor, actor->target, type);
}

//============================================================================
// Arm 5 projectile
//============================================================================

void KoraxFire5(mobj_t * actor, classid type)
{
	mobj_t *mo;
	float ang;
	float x, y, z;

	ang = AngleMod360(actor->angles.yaw + KORAX_DELTAANGLE);
	x = actor->origin.x + KORAX_ARM_EXTENSION_LONG * cos(ang);
	y = actor->origin.y + KORAX_ARM_EXTENSION_LONG * sin(ang);
	z = actor->origin.z - actor->floorclip + KORAX_ARM5_HEIGHT;
	mo = SpawnKoraxMissile(x, y, z, actor, actor->target, type);
}

//============================================================================
// Arm 6 projectile
//============================================================================

void KoraxFire6(mobj_t * actor, classid type)
{
	mobj_t *mo;
	float ang;
	float x, y, z;

	ang = AngleMod360(actor->angles.yaw + KORAX_DELTAANGLE);
	x = actor->origin.x + KORAX_ARM_EXTENSION_LONG * cos(ang);
	y = actor->origin.y + KORAX_ARM_EXTENSION_LONG * sin(ang);
	z = actor->origin.z - actor->floorclip + KORAX_ARM6_HEIGHT;
	mo = SpawnKoraxMissile(x, y, z, actor, actor->target, type);
}

//============================================================================
//
//  Actor::A_KoraxMissile
//
//============================================================================

void Actor::A_KoraxMissile(void)
{
	classid mtype;
	name sound;

	StartSoundName(this, 'KoraxAttack', CHAN_VOICE);

	switch (P_Random() % 6)
	{
	case 0:
		mtype = WraithMissile;
		sound = 'WraithMissileFire';
		break;
	case 1:
		mtype = DemonMissile;
		sound = 'DemonMissileFire';
		break;
	case 2:
		mtype = Demon2Missile;
		sound = 'DemonMissileFire';
		break;
	case 3:
		mtype = FireDemonMissile;
		sound = 'FireDemonAttack';
		break;
	case 4:
		mtype = CentaurMissile;
		sound = 'CentaurLeaderAttack';
		break;
	case 5:
		mtype = SerpentMissile;
		sound = 'CentaurLeaderAttack';
		break;
	}

	// Fire all 6 missiles at once
	StartSoundName(NULL, sound, CHAN_VOICE);
	KoraxFire1(this, mtype);
	KoraxFire2(this, mtype);
	KoraxFire3(this, mtype);
	KoraxFire4(this, mtype);
	KoraxFire5(this, mtype);
	KoraxFire6(this, mtype);
}

//============================================================================
// Call action code scripts (250-254)
//============================================================================

void Actor::A_KoraxCommand(void)
{
	float x, y, z;
	float ang;
	int numcommands;
	int args[3];

	args[0] = args[1] = args[2] = 0;
	StartSoundName(this, 'KoraxCommand', CHAN_VOICE);

	// Shoot stream of lightning to ceiling
	ang = AngleMod360(angles.yaw - 90.0);
	x = origin.x + KORAX_COMMAND_OFFSET * cos(ang);
	y = origin.y + KORAX_COMMAND_OFFSET * sin(ang);
	z = origin.z + KORAX_COMMAND_HEIGHT;
	P_SpawnMobj(x, y, z, KoraxBolt);

	if (Health <= (spawnhealth >> 1))
	{
		numcommands = 5;
	}
	else
	{
		numcommands = 4;
	}

	switch (P_Random() % numcommands)
	{
	case 0:
		StartACS(250, 0, &args[0], this, NULL, 0);
		break;
	case 1:
		StartACS(251, 0, &args[0], this, NULL, 0);
		break;
	case 2:
		StartACS(252, 0, &args[0], this, NULL, 0);
		break;
	case 3:
		StartACS(253, 0, &args[0], this, NULL, 0);
		break;
	case 4:
		StartACS(254, 0, &args[0], this, NULL, 0);
		break;
	}
}

//============================================================================
//
//  KSpiritInit
//
//============================================================================

void KSpiritInit(mobj_t * spirit, mobj_t * korax)
{
	int i;
	mobj_t *tail;
	mobj_t *next;

	spirit->Health = KORAX_SPIRIT_LIFETIME;

	spirit->specialmobj1 = korax;	// Swarm around korax
	spirit->special2 = 32 + (P_Random() & 7);	// Float bob index
	spirit->args[0] = 10;	// initial turn value
	spirit->args[1] = 0;	// initial look angle

	// Spawn a tail for spirit
	tail = P_SpawnMobj(spirit->origin.x, spirit->origin.y, spirit->origin.z,
		HolyTail);
	tail->specialmobj2 = spirit;	// parent
	for (i = 1; i < 3; i++)
	{
		next = P_SpawnMobj(spirit->origin.x, spirit->origin.y,
			spirit->origin.z, HolyTail);
		next->SetState(next->SpawnState + 1);
		tail->specialmobj1 = next;
		tail = next;
	}
	tail->specialmobj1 = NULL;	// last tail bit
}

//============================================================================
//
//  Actor::A_KoraxBonePop
//
//============================================================================

void Actor::A_KoraxBonePop(void)
{
	mobj_t *mo;
	int args[3];

	args[0] = args[1] = args[2] = 0;
	// Spawn 6 spirits equalangularly
	mo = SpawnMissileAngle(this, KoraxSpirit1, 60.0 * 0.0, 5.0);
	if (mo)
		KSpiritInit(mo, this);
	mo = SpawnMissileAngle(this, KoraxSpirit2, 60.0 * 1.0, 5.0);
	if (mo)
		KSpiritInit(mo, this);
	mo = SpawnMissileAngle(this, KoraxSpirit3, 60.0 * 2.0, 5.0);
	if (mo)
		KSpiritInit(mo, this);
	mo = SpawnMissileAngle(this, KoraxSpirit4, 60.0 * 3.0, 5.0);
	if (mo)
		KSpiritInit(mo, this);
	mo = SpawnMissileAngle(this, KoraxSpirit5, 60.0 * 4.0, 5.0);
	if (mo)
		KSpiritInit(mo, this);
	mo = SpawnMissileAngle(this, KoraxSpirit6, 60.0 * 5.0, 5.0);
	if (mo)
		KSpiritInit(mo, this);

	StartACS(255, 0, &args[0], this, NULL, 0);	// Death script
}

//============================================================================
//
//  A_KSpiritSeeker
//
//============================================================================

void A_KSpiritSeeker(mobj_t * actor, float thresh, float turnMax)
{
	int dir;
	float dist;
	float delta;
	float angle;
	mobj_t *target;
	float newZ;
	float deltaZ;

	target = actor->specialmobj1;
	if (target == NULL)
	{
		return;
	}
	dir = P_FaceMobj(actor, target, &delta);
	if (delta > thresh)
	{
		delta /= 2.0;
		if (delta > turnMax)
		{
			delta = turnMax;
		}
	}
	if (dir)
	{
		// Turn clockwise
		actor->angles.yaw = AngleMod360(actor->angles.yaw + delta);
	}
	else
	{
		// Turn counter clockwise
		actor->angles.yaw = AngleMod360(actor->angles.yaw - delta);
	}
	angle = actor->angles.yaw;
	actor->velocity.x = actor->Speed * cos(angle);
	actor->velocity.y = actor->Speed * sin(angle);

	if (!(level->tictime & 15) ||
		actor->origin.z > target->origin.z + target->Height ||
		actor->origin.z + actor->Height < target->origin.z)
	{
		newZ = target->origin.z + Random() * target->Height;
		deltaZ = newZ - actor->origin.z;
		if (fabs(deltaZ) > 15.0)
		{
			if (deltaZ > 0.0)
			{
				deltaZ = 15.0;
			}
			else
			{
				deltaZ = -15.0;
			}
		}
		dist = MobjDist2(target, actor);
		dist = dist / actor->Speed;
		if (dist < 1.0)
		{
			dist = 1.0;
		}
		actor->velocity.z = deltaZ / dist;
	}
	return;
}

//============================================================================
//
//  A_KSpiritWeave
//
//============================================================================

void A_KSpiritWeave(mobj_t * actor)
{
	float newX, newY;
	int weaveXY, weaveZ;
	float angle;

	weaveXY = actor->special2 >> 16;
	weaveZ = actor->special2 & 0xFFFF;
	angle = AngleMod360(actor->angles.yaw + 90.0);
	newX = actor->origin.x - cos(angle) * FloatBobOffsets[weaveXY] * 4.0;
	newY = actor->origin.y - sin(angle) * FloatBobOffsets[weaveXY] * 4.0;
	weaveXY = (weaveXY + (P_Random() % 5)) & 63;
	newX += cos(angle) * FloatBobOffsets[weaveXY] * 4.0;
	newY += sin(angle) * FloatBobOffsets[weaveXY] * 4.0;
	P_TryMove(actor, newX, newY);
	actor->origin.z -= FloatBobOffsets[weaveZ] * 2.0;
	weaveZ = (weaveZ + (P_Random() % 5)) & 63;
	actor->origin.z += FloatBobOffsets[weaveZ] * 2.0;
	actor->special2 = weaveZ + (weaveXY << 16);
}

//============================================================================
//
//  Actor::A_KSpiritRoam
//
//============================================================================

void Actor::A_KSpiritRoam(void)
{
	if (Health-- <= 0)
	{
		StartSoundName(this, 'SpiritDie', CHAN_VOICE);
		SetState(S_KSPIRIT_DEATH1);
	}
	else
	{
		if (specialmobj1)
		{
			A_KSpiritSeeker(this, itof(args[0]), itof(args[0]) * 2.0);
		}
		A_KSpiritWeave(this);
		if (P_Random() < 50)
		{
			StartSoundName(NULL, 'SpiritActive', CHAN_VOICE);
		}
	}
}

//============================================================================
//
//  Actor::A_KBoltRaise
//
//============================================================================

void Actor::A_KBoltRaise(void)
{
	mobj_t *mo;
	float z;

	// Spawn a child upward
	z = origin.z + KORAX_BOLT_HEIGHT;

	if (z + KORAX_BOLT_HEIGHT < ceilingz)
	{
		mo = P_SpawnMobj(origin.x, origin.y, z, KoraxBolt);
		if (mo)
		{
			mo->special1 = KORAX_BOLT_LIFETIME;
		}
	}
	else
	{
		// Maybe cap it off here
	}
}

//============================================================================
//
//  Actor::A_KBolt
//
//============================================================================

void Actor::A_KBolt(void)
{
	// Countdown lifetime
	if (special1-- <= 0)
	{
		SetState(S_NULL);
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.11  2002/01/24 18:19:26  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.10  2002/01/17 18:15:54  dj_jl
//  Renamed all map object classes
//
//  Revision 1.9  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.8  2002/01/11 18:19:42  dj_jl
//  Started to use names in progs
//
//  Revision 1.7  2002/01/07 12:25:57  dj_jl
//  Changed copyright year
//
//  Revision 1.6  2001/12/12 18:57:42  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.5  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/30 17:33:17  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
