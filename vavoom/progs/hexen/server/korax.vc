//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

//===========================================================================
//
// Korax Variables
//  special1    last teleport destination
//  special2    set if "below half" script not yet run
//
// Korax Scripts (reserved)
//  249     Tell scripts that we are below half health
//  250-254 Control scripts
//  255     Death script
//
// Korax TIDs (reserved)
//  245     Reserved for Korax himself
//  248     Initial teleport destination
//  249     Teleport destination
//  250-254 For use in respective control scripts
//  255     For use in death script (spawn spots)
//
//===========================================================================
//
// Arm projectiles
//      arm positions numbered:
//          1   top left
//          2   middle left
//          3   lower left
//          4   top right
//          5   middle right
//          6   lower right
//
//===========================================================================

// MACROS ------------------------------------------------------------------

#define KORAX_FIRST_TELEPORT_TID	(248)
#define KORAX_TELEPORT_TID			(249)

#define KORAX_DELTAANGLE			(85*ANGLE_1)
#define KORAX_ARM_EXTENSION_SHORT	40.0
#define KORAX_ARM_EXTENSION_LONG	55.0

#define KORAX_ARM1_HEIGHT			108.0
#define KORAX_ARM2_HEIGHT			82.0
#define KORAX_ARM3_HEIGHT			54.0
#define KORAX_ARM4_HEIGHT			104.0
#define KORAX_ARM5_HEIGHT			86.0
#define KORAX_ARM6_HEIGHT			53.0

#define KORAX_COMMAND_HEIGHT		120.0
#define KORAX_COMMAND_OFFSET		27.0

#define KORAX_BOLT_HEIGHT			48.0
#define KORAX_BOLT_LIFETIME			3

#define KORAX_SPIRIT_LIFETIME		(5*(35/5))	// 5 seconds

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//============================================================================
//
//  A_KoraxStep
//
//============================================================================

void A_KoraxStep(mobj_t * actor)
{
	A_Chase(actor);
}

//============================================================================
//
//  A_KoraxStep2
//
//============================================================================

void A_KoraxStep2(mobj_t * actor)
{
	StartSoundName(NULL, "KoraxStep", CHAN_BODY);
	A_Chase(actor);
}

//============================================================================
//
//  A_KoraxChase
//
//============================================================================

void A_KoraxChase(mobj_t * actor)
{
	mobj_t *spot;
	int search;
	int args[3];

	args[0] = args[1] = args[2] = 0;
	if ((!actor->special2) && (actor->health <= (actor->spawnhealth / 2)))
	{
		search = 0;
		spot = P_FindMobjFromTID(KORAX_FIRST_TELEPORT_TID, &search);
		if (spot)
		{
			P_Teleport(actor, spot->origin.x, spot->origin.y,
				spot->angles.yaw, true);
		}

		StartACS(249, 0, &args[0], actor, NULL, 0);
		actor->special2 = 1;	// Don't run again

		return;
	}

	if (!actor->target)
		return;
	if (P_Random() < 30)
	{
		SetMobjState(actor, actor->missilestate);
	}
	else if (P_Random() < 30)
	{
		StartSoundName(NULL, "KoraxActive", CHAN_VOICE);
	}

	// Teleport away
	if (actor->health < (actor->spawnhealth >> 1))
	{
		if (P_Random() < 10)
		{
			spot = P_FindMobjFromTID(KORAX_TELEPORT_TID, &actor->special1);
			if (spot)
			{
				P_Teleport(actor, spot->origin.x, spot->origin.y,
					spot->angles.yaw, true);
			}
		}
	}
}

//============================================================================
//
//  A_KoraxDecide
//
//============================================================================

void A_KoraxDecide(mobj_t * actor)
{
	if (P_Random() < 220)
	{
		SetMobjState(actor, S_KORAX_MISSILE1);
	}
	else
	{
		SetMobjState(actor, S_KORAX_COMMAND1);
	}
}

//============================================================================
// Arm 1 projectile
//============================================================================

void KoraxFire1(mobj_t * actor, int type)
{
	mobj_t *mo;
	angle_t ang;
	float x, y, z;

	ang = actor->angles.yaw - KORAX_DELTAANGLE;
	x = actor->origin.x + KORAX_ARM_EXTENSION_SHORT * cos(ang);
	y = actor->origin.y + KORAX_ARM_EXTENSION_SHORT * sin(ang);
	z = actor->origin.z - actor->floorclip + KORAX_ARM1_HEIGHT;
	mo = SpawnKoraxMissile(x, y, z, actor, actor->target, type);
}

//============================================================================
// Arm 2 projectile
//============================================================================

void KoraxFire2(mobj_t * actor, int type)
{
	mobj_t *mo;
	angle_t ang;
	float x, y, z;

	ang = actor->angles.yaw - KORAX_DELTAANGLE;
	x = actor->origin.x + KORAX_ARM_EXTENSION_LONG * cos(ang);
	y = actor->origin.y + KORAX_ARM_EXTENSION_LONG * sin(ang);
	z = actor->origin.z - actor->floorclip + KORAX_ARM2_HEIGHT;
	mo = SpawnKoraxMissile(x, y, z, actor, actor->target, type);
}

//============================================================================
// Arm 3 projectile
//============================================================================

void KoraxFire3(mobj_t * actor, int type)
{
	mobj_t *mo;
	angle_t ang;
	float x, y, z;

	ang = actor->angles.yaw - KORAX_DELTAANGLE;
	x = actor->origin.x + KORAX_ARM_EXTENSION_LONG * cos(ang);
	y = actor->origin.y + KORAX_ARM_EXTENSION_LONG * sin(ang);
	z = actor->origin.z - actor->floorclip + KORAX_ARM3_HEIGHT;
	mo = SpawnKoraxMissile(x, y, z, actor, actor->target, type);
}

//============================================================================
// Arm 4 projectile
//============================================================================

void KoraxFire4(mobj_t * actor, int type)
{
	mobj_t *mo;
	angle_t ang;
	float x, y, z;

	ang = actor->angles.yaw + KORAX_DELTAANGLE;
	x = actor->origin.x + KORAX_ARM_EXTENSION_SHORT * cos(ang);
	y = actor->origin.y + KORAX_ARM_EXTENSION_SHORT * sin(ang);
	z = actor->origin.z - actor->floorclip + KORAX_ARM4_HEIGHT;
	mo = SpawnKoraxMissile(x, y, z, actor, actor->target, type);
}

//============================================================================
// Arm 5 projectile
//============================================================================

void KoraxFire5(mobj_t * actor, int type)
{
	mobj_t *mo;
	angle_t ang;
	float x, y, z;

	ang = actor->angles.yaw + KORAX_DELTAANGLE;
	x = actor->origin.x + KORAX_ARM_EXTENSION_LONG * cos(ang);
	y = actor->origin.y + KORAX_ARM_EXTENSION_LONG * sin(ang);
	z = actor->origin.z - actor->floorclip + KORAX_ARM5_HEIGHT;
	mo = SpawnKoraxMissile(x, y, z, actor, actor->target, type);
}

//============================================================================
// Arm 6 projectile
//============================================================================

void KoraxFire6(mobj_t * actor, int type)
{
	mobj_t *mo;
	angle_t ang;
	float x, y, z;

	ang = actor->angles.yaw + KORAX_DELTAANGLE;
	x = actor->origin.x + KORAX_ARM_EXTENSION_LONG * cos(ang);
	y = actor->origin.y + KORAX_ARM_EXTENSION_LONG * sin(ang);
	z = actor->origin.z - actor->floorclip + KORAX_ARM6_HEIGHT;
	mo = SpawnKoraxMissile(x, y, z, actor, actor->target, type);
}

//============================================================================
//
//  A_KoraxMissile
//
//============================================================================

void A_KoraxMissile(mobj_t * actor)
{
	int type = P_Random() % 6;
	string sound;

	StartSoundName(actor, "KoraxAttack", CHAN_VOICE);

	switch (type)
	{
	case 0:
		type = MT_WRAITHFX1;
		sound = "WraithMissileFire";
		break;
	case 1:
		type = MT_DEMONFX1;
		sound = "DemonMissileFire";
		break;
	case 2:
		type = MT_DEMON2FX1;
		sound = "DemonMissileFire";
		break;
	case 3:
		type = MT_FIREDEMON_FX6;
		sound = "FireDemonAttack";
		break;
	case 4:
		type = MT_CENTAUR_FX;
		sound = "CentaurLeaderAttack";
		break;
	case 5:
		type = MT_SERPENTFX;
		sound = "CentaurLeaderAttack";
		break;
	}

	// Fire all 6 missiles at once
	StartSoundName(NULL, sound, CHAN_VOICE);
	KoraxFire1(actor, type);
	KoraxFire2(actor, type);
	KoraxFire3(actor, type);
	KoraxFire4(actor, type);
	KoraxFire5(actor, type);
	KoraxFire6(actor, type);
}

//============================================================================
// Call action code scripts (250-254)
//============================================================================

void A_KoraxCommand(mobj_t * actor)
{
	float x, y, z;
	angle_t ang;
	int numcommands;
	int args[3];

	args[0] = args[1] = args[2] = 0;
	StartSoundName(actor, "KoraxCommand", CHAN_VOICE);

	// Shoot stream of lightning to ceiling
	ang = actor->angles.yaw - ANG90;
	x = actor->origin.x + KORAX_COMMAND_OFFSET * cos(ang);
	y = actor->origin.y + KORAX_COMMAND_OFFSET * sin(ang);
	z = actor->origin.z + KORAX_COMMAND_HEIGHT;
	P_SpawnMobj(x, y, z, MT_KORAX_BOLT);

	if (actor->health <= (actor->spawnhealth >> 1))
	{
		numcommands = 5;
	}
	else
	{
		numcommands = 4;
	}

	switch (P_Random() % numcommands)
	{
	case 0:
		StartACS(250, 0, &args[0], actor, NULL, 0);
		break;
	case 1:
		StartACS(251, 0, &args[0], actor, NULL, 0);
		break;
	case 2:
		StartACS(252, 0, &args[0], actor, NULL, 0);
		break;
	case 3:
		StartACS(253, 0, &args[0], actor, NULL, 0);
		break;
	case 4:
		StartACS(254, 0, &args[0], actor, NULL, 0);
		break;
	}
}

//============================================================================
//
//  KSpiritInit
//
//============================================================================

void KSpiritInit(mobj_t * spirit, mobj_t * korax)
{
	int i;
	mobj_t *tail;
	mobj_t *next;

	spirit->health = KORAX_SPIRIT_LIFETIME;

	spirit->specialmobj1 = korax;	// Swarm around korax
	spirit->special2 = 32 + (P_Random() & 7);	// Float bob index
	spirit->args[0] = 10;	// initial turn value
	spirit->args[1] = 0;	// initial look angle

	// Spawn a tail for spirit
	tail =
		P_SpawnMobj(spirit->origin.x, spirit->origin.y, spirit->origin.z,
		MT_HOLY_TAIL);
	tail->specialmobj2 = spirit;	// parent
	for (i = 1; i < 3; i++)
	{
		next =
			P_SpawnMobj(spirit->origin.x, spirit->origin.y, spirit->origin.z,
			MT_HOLY_TAIL);
		SetMobjState(next, next->spawnstate + 1);
		tail->specialmobj1 = next;
		tail = next;
	}
	tail->specialmobj1 = NULL;	// last tail bit
}

//============================================================================
//
//  A_KoraxBonePop
//
//============================================================================

void A_KoraxBonePop(mobj_t * actor)
{
	mobj_t *mo;
	int args[3];

	args[0] = args[1] = args[2] = 0;
	// Spawn 6 spirits equalangularly
	mo = SpawnMissileAngle(actor, MT_KORAX_SPIRIT1, ANG60 * 0, 5.0);
	if (mo)
		KSpiritInit(mo, actor);
	mo = SpawnMissileAngle(actor, MT_KORAX_SPIRIT2, ANG60 * 1, 5.0);
	if (mo)
		KSpiritInit(mo, actor);
	mo = SpawnMissileAngle(actor, MT_KORAX_SPIRIT3, ANG60 * 2, 5.0);
	if (mo)
		KSpiritInit(mo, actor);
	mo = SpawnMissileAngle(actor, MT_KORAX_SPIRIT4, ANG60 * 3, 5.0);
	if (mo)
		KSpiritInit(mo, actor);
	mo = SpawnMissileAngle(actor, MT_KORAX_SPIRIT5, ANG60 * 4, 5.0);
	if (mo)
		KSpiritInit(mo, actor);
	mo = SpawnMissileAngle(actor, MT_KORAX_SPIRIT6, ANG60 * 5, 5.0);
	if (mo)
		KSpiritInit(mo, actor);

	StartACS(255, 0, &args[0], actor, NULL, 0);	// Death script
}

//============================================================================
//
//  A_KSpiritSeeker
//
//============================================================================

void A_KSpiritSeeker(mobj_t * actor, angle_t thresh, angle_t turnMax)
{
	int dir;
	float dist;
	angle_t delta;
	angle_t angle;
	mobj_t *target;
	float newZ;
	float deltaZ;

	target = actor->specialmobj1;
	if (target == NULL)
	{
		return;
	}
	dir = P_FaceMobj(actor, target, &delta);
	if (delta > thresh)
	{
		delta >>= 1;
		if (delta > turnMax)
		{
			delta = turnMax;
		}
	}
	if (dir)
	{	// Turn clockwise
		actor->angles.yaw += delta;
	}
	else
	{	// Turn counter clockwise
		actor->angles.yaw -= delta;
	}
	angle = actor->angles.yaw;
	actor->velocity.x = actor->speed * cos(angle);
	actor->velocity.y = actor->speed * sin(angle);

	if (!(level->tictime & 15) ||
		actor->origin.z > target->origin.z + target->height ||
		actor->origin.z + actor->height < target->origin.z)
	{
		newZ = target->origin.z + Random() * target->height;
		deltaZ = newZ - actor->origin.z;
		if (fabs(deltaZ) > 15.0)
		{
			if (deltaZ > 0.0)
			{
				deltaZ = 15.0;
			}
			else
			{
				deltaZ = -15.0;
			}
		}
		dist = MobjDist2(target, actor);
		dist = dist / actor->speed;
		if (dist < 1.0)
		{
			dist = 1.0;
		}
		actor->velocity.z = deltaZ / dist;
	}
	return;
}

//============================================================================
//
//  A_KSpiritWeave
//
//============================================================================

void A_KSpiritWeave(mobj_t * actor)
{
	float newX, newY;
	int weaveXY, weaveZ;
	angle_t angle;

	weaveXY = actor->special2 >> 16;
	weaveZ = actor->special2 & 0xFFFF;
	angle = actor->angles.yaw + ANG90;
	newX = actor->origin.x - cos(angle) * FloatBobOffsets[weaveXY] * 4.0;
	newY = actor->origin.y - sin(angle) * FloatBobOffsets[weaveXY] * 4.0;
	weaveXY = (weaveXY + (P_Random() % 5)) & 63;
	newX += cos(angle) * FloatBobOffsets[weaveXY] * 4.0;
	newY += sin(angle) * FloatBobOffsets[weaveXY] * 4.0;
	P_TryMove(actor, newX, newY);
	actor->origin.z -= FloatBobOffsets[weaveZ] * 2.0;
	weaveZ = (weaveZ + (P_Random() % 5)) & 63;
	actor->origin.z += FloatBobOffsets[weaveZ] * 2.0;
	actor->special2 = weaveZ + (weaveXY << 16);
}

//============================================================================
//
//  A_KSpiritRoam
//
//============================================================================

void A_KSpiritRoam(mobj_t * actor)
{
	if (actor->health-- <= 0)
	{
		StartSoundName(actor, "SpiritDie", CHAN_VOICE);
		SetMobjState(actor, S_KSPIRIT_DEATH1);
	}
	else
	{
		if (actor->specialmobj1)
		{
			A_KSpiritSeeker(actor, actor->args[0] * ANGLE_1,
				actor->args[0] * ANGLE_1 * 2);
		}
		A_KSpiritWeave(actor);
		if (P_Random() < 50)
		{
			StartSoundName(NULL, "SpiritActive", CHAN_VOICE);
		}
	}
}

//============================================================================
//
//  A_KBoltRaise
//
//============================================================================

void A_KBoltRaise(mobj_t * actor)
{
	mobj_t *mo;
	float z;

	// Spawn a child upward
	z = actor->origin.z + KORAX_BOLT_HEIGHT;

	if (z + KORAX_BOLT_HEIGHT < actor->ceilingz)
	{
		mo = P_SpawnMobj(actor->origin.x, actor->origin.y, z, MT_KORAX_BOLT);
		if (mo)
		{
			mo->special1 = KORAX_BOLT_LIFETIME;
		}
	}
	else
	{
		// Maybe cap it off here
	}
}

//============================================================================
//
//  A_KBolt
//
//============================================================================

void A_KBolt(mobj_t * actor)
{
	// Countdown lifetime
	if (actor->special1-- <= 0)
	{
		SetMobjState(actor, S_NULL);
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/30 17:33:17  dj_jl
//  Added sound channels
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
