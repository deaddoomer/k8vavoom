//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

int opposite[] = {
	DI_WEST, DI_SOUTHWEST, DI_SOUTH, DI_SOUTHEAST, DI_EAST, DI_NORTHEAST,
	DI_NORTH, DI_NORTHWEST, DI_NODIR
};

int diags[] = { DI_NORTHWEST, DI_NORTHEAST, DI_SOUTHWEST, DI_SOUTHEAST };

float xspeed[8] =
	{ 1.0, 0.7171630859, 0.0, -0.7171630859, -1.0, -0.7171630859, 0.0,
		0.7171630859 };
float yspeed[8] =
	{ 0.0, 0.7171630859, 1.0, 0.7171630859, 0.0, -0.7171630859, -1.0,
		-0.7171630859 };

//==========================================================================
//
//  Pawn::CheckMeleeRange
//
//==========================================================================

boolean Pawn::CheckMeleeRange(void)
{
	float dist;

	if (!Target)
	{
		return false;
	}
	dist = MobjDist(Target, self);
	if (dist >= MELEERANGE)
	{
		return false;
	}
	if (!P_CheckSight(self, Target))
	{
		return false;
	}
	if (Target.Origin.z > Origin.z + Height)
	{
		// Target is higher than the attacker
		return false;
	}
	else if (Origin.z > Target.Origin.z + Target.Height)
	{
		// Attacker is higher
		return false;
	}
	return true;
}

//==========================================================================
//
//  Pawn::CheckMeleeRange2
//
//==========================================================================

boolean Pawn::CheckMeleeRange2(void)
{
	float dist;

	if (!Target)
	{
		return false;
	}
	dist = MobjDist(Target, self);
	if (dist >= MELEERANGE * 2.0 || dist < MELEERANGE)
	{
		return false;
	}
	if (!P_CheckSight(self, Target))
	{
		return false;
	}
	if (Target.Origin.z > Origin.z + Height)
	{
		// Target is higher than the attacker
		return false;
	}
	else if (Origin.z > Target.Origin.z + Target.Height)
	{
		// Attacker is higher
		return false;
	}
	return true;
}

//==========================================================================
//
//  Pawn::CheckMissileRange
//
//==========================================================================

boolean Pawn::CheckMissileRange(void)
{
	float dist;

	if (!P_CheckSight(self, Target))
	{
		return false;
	}
	if (bJustHit)
	{
		// The target just hit the enemy, so fight back!
		bJustHit = false;
		return true;
	}
	if (ReactionCount)
	{
		// Don't attack yet
		return false;
	}
	dist = MobjDist(self, Target) - 64.0;
	if (!MeleeState)
	{
		// No melee attack, so fire more frequently
		dist -= 128.0;
	}
	if (dist > 200.0)
	{
		dist = 200.0;
	}
	if (Random() * 256.0 < dist)
	{
		return false;
	}
	return true;
}

//==========================================================================
//
//  Pawn::FaceMovementDirection
//
//==========================================================================

void Pawn::FaceMovementDirection(void)
{
	switch (MoveDir)
	{
	case DI_EAST:
		Angles.yaw = 0.0;
		break;
	case DI_NORTHEAST:
		Angles.yaw = 45.0;
		break;
	case DI_NORTH:
		Angles.yaw = 90.0;
		break;
	case DI_NORTHWEST:
		Angles.yaw = 135.0;
		break;
	case DI_WEST:
		Angles.yaw = 180.0;
		break;
	case DI_SOUTHWEST:
		Angles.yaw = 225.0;
		break;
	case DI_SOUTH:
		Angles.yaw = 270.0;
		break;
	case DI_SOUTHEAST:
		Angles.yaw = 315.0;
		break;
	}
}

//============================================================================
//
//  Pawn::LookForMonsters
//
//============================================================================

#define MONS_LOOK_RANGE (16.0 * 64.0)
#define MONS_LOOK_LIMIT 64

boolean Pawn::LookForMonsters(void)
{
	int count;
	Actor mo;

	if (!P_CheckSight(*players[0].mo, self))
	{
		// Player can't see monster
		return false;
	}
	count = 0;
	FOREACH(Actor, mo)
	{
		if (!mo.bCountKill || (mo == self) || (mo.Health <= 0))
		{
			// Not a valid monster
			continue;
		}
		if (MobjDist(self, mo) > MONS_LOOK_RANGE)
		{
			// Out of range
			continue;
		}
		if (P_Random() < 16)
		{
			// Skip
			continue;
		}
		if (count++ > MONS_LOOK_LIMIT)
		{
			// Stop searching
			return false;
		}
		if (!P_CheckSight(self, mo))
		{
			// Out of sight
			continue;
		}
		if (Class == Minotaur)
		{
			if ((mo.Class == Minotaur) && (mo.Target != *_SpecialMobj1))
			{
				continue;
			}
		}
		// Found a target monster
		Target = mo;
		return true;
	}
	return false;
}

//============================================================================
//
//  Pawn::LookForPlayers
//
//  If allaround is false, only look 180 degrees in front
//  returns true if a player is targeted
//
//============================================================================

boolean Pawn::LookForPlayers(boolean allaround)
{
	int c;
	int stop;
	player_t *P;
	float an;
	float dist;

	if (!netgame && players[0].bSpawned && players[0].Health <= 0)
	{
		// Single player game and player is dead, look for monsters
		return LookForMonsters();
	}
	c = 0;
	stop = (LastLook - 1) & (MAXPLAYERS - 1);
	for (;; LastLook = (LastLook + 1) & (MAXPLAYERS - 1))
	{
		if (LastLook == stop)
			return false;	// done looking

		if (!players[LastLook].bActive)
			continue;

		if (c++ == 2)
			return false;	// done looking

		P = &players[LastLook];
		if (!P->bSpawned || !P->mo)
			continue;	//  not spawned yet
		if (P->Health <= 0)
			continue;	// dead
		if (!P_CheckSight(self, *P->mo))
			continue;	// out of sight

		if (!allaround)
		{
			an = AngleMod360(atan2(P->mo->Origin.y - Origin.y,
				P->mo->Origin.x - Origin.x) - Angles.yaw);
			if (an > 90.0 && an < 270.0)
			{
				dist = MobjDist(*P->mo, self);
				// if real close, react anyway
				if (dist > MELEERANGE)
					continue;	// behind back
			}
		}
		if (P->mo->Translucency)
		{
			// Player is invisible
			if (MobjDist(*P->mo, self) > 2.0 * MELEERANGE &&
				Length(P->mo->Velocity) < 5.0 * 35.0)
			{
				// Player is sneaking - can't detect
				return false;
			}
			if (P_Random() < 225)
			{
				// Player isn't sneaking, but still didn't detect
				return false;
			}
		}
		if (Class == Minotaur)
		{
			if (_SpecialMobj1 == P->mo)
			{
				continue;	// Don't target master
			}
		}
		Target = *P->mo;
		return true;
	}
	return false;
}

//==========================================================================
//
//  Pawn::StepMove
//
//  Move in the current direction, returns false if the move is blocked.
//
//==========================================================================

boolean Pawn::StepMove(void)
{
	float tryx;
	float tryy;

	line_t *ld;
	boolean good;

	if (bBlasted)
		return true;
	if (MoveDir == DI_NODIR)
		return false;

#ifdef RANGECHECK
	if (MoveDir >= 8 || MoveDir < 0)
		Error("Weird actor->MoveDir!");
#endif

	tryx = Origin.x + StepSpeed * xspeed[MoveDir];
	tryy = Origin.y + StepSpeed * yspeed[MoveDir];

	if (!TryMove(tryx, tryy))
	{
		// open any specials
		if (bFloat && floatok)
		{
			// must adjust height
			if (Origin.z < saved_tmfloorz)
				Origin.z += FLOATSPEED * frametime;
			else
				Origin.z -= FLOATSPEED * frametime;

			bInFloat = true;
			return true;
		}

		if (!tmtrace->NumSpecHit)
			return false;

		MoveDir = DI_NODIR;
		good = false;
		while (tmtrace->NumSpecHit--)
		{
			ld = tmtrace->SpecHit[tmtrace->NumSpecHit];
			// if the special is not a door
			// that can be opened,
			// return false
			if (P_ActivateLine(ld, self, 0, SPAC_USE))
			{
				good = true;
			}
		}
		return good;
	}
	else
	{
		bInFloat = false;
	}

	if (!bFloat)
	{
		if (Origin.z > FloorZ)
		{
			HitFloorType();
		}
		Origin.z = FloorZ;
	}
	return true;
}

//==========================================================================
//
//  Pawn::TryWalk
//
//  Attempts to move actor in its current (ob->moveangle) direction.
//  If blocked by either a wall or an actor returns FALSE.
//  If move is either clear of block only by a door, returns TRUE and sets.
//  If a door is in the way, an OpenDoor call is made to start it opening.
//
//==========================================================================

boolean Pawn::TryWalk(void)
{
	if (!StepMove())
	{
		return false;
	}
	MoveCount = P_Random() & 15;
	return true;
}

//============================================================================
//
//  Pawn::NewChaseDir
//
//============================================================================

void Pawn::NewChaseDir(void)
{
	float deltax, deltay;
	int d[3];
	int tdir, olddir, turnaround;

	if (!Target)
		Error("NewChaseDir: called with no target");

	olddir = MoveDir;
	turnaround = opposite[olddir];

	deltax = Target.Origin.x - Origin.x;
	deltay = Target.Origin.y - Origin.y;
	if (deltax > 10.0)
		d[1] = DI_EAST;
	else if (deltax < -10.0)
		d[1] = DI_WEST;
	else
		d[1] = DI_NODIR;
	if (deltay < -10.0)
		d[2] = DI_SOUTH;
	else if (deltay > 10.0)
		d[2] = DI_NORTH;
	else
		d[2] = DI_NODIR;

	// try direct route
	if (d[1] != DI_NODIR && d[2] != DI_NODIR)
	{
		MoveDir = diags[((deltay < 0.0) << 1) + (deltax > 0.0)];
		if (MoveDir != turnaround && TryWalk())
			return;
	}

	// try other directions
	if (P_Random() > 200 || fabs(deltay) > fabs(deltax))
	{
		tdir = d[1];
		d[1] = d[2];
		d[2] = tdir;
	}

	if (d[1] == turnaround)
		d[1] = DI_NODIR;
	if (d[2] == turnaround)
		d[2] = DI_NODIR;

	if (d[1] != DI_NODIR)
	{
		MoveDir = d[1];
		if (TryWalk())
			return;	/*either moved forward or attacked */
	}

	if (d[2] != DI_NODIR)
	{
		MoveDir = d[2];
		if (TryWalk())
			return;
	}

	/* there is no direct path to the player, so pick another direction */

	if (olddir != DI_NODIR)
	{
		MoveDir = olddir;
		if (TryWalk())
			return;
	}

	if (P_Random() & 1)	/*randomly determine direction of search */
	{
		for (tdir = DI_EAST; tdir <= DI_SOUTHEAST; tdir++)
		{
			if (tdir != turnaround)
			{
				MoveDir = tdir;
				if (TryWalk())
					return;
			}
		}
	}
	else
	{
		for (tdir = DI_SOUTHEAST; tdir >= DI_EAST; tdir--)
		{
			if (tdir != turnaround)
			{
				MoveDir = tdir;
				if (TryWalk())
					return;
			}
		}
	}

	if (turnaround != DI_NODIR)
	{
		MoveDir = turnaround;
		if (TryWalk())
			return;
	}

	MoveDir = DI_NODIR;	// can't move
}

//===========================================================================
//
//  Actor::RoughBlockCheck
//
//===========================================================================

Actor Actor::RoughBlockCheck(int index)
{
	Actor link;
	float angle;

	for (link = Actor(BlockLink(index)); link;
		link = Actor(link.BlockMapNext))
	{
		if (bIsPlayer)	// Minotaur looking around player
		{
			if (link.bCountKill || (link.bIsPlayer && (link != self)))
			{
				if (!link.bShootable)
				{
					continue;
				}
				if (link.bDormant)
				{
					continue;
				}
				if ((link.Class == Minotaur) &&
					(*link._SpecialMobj1 == self))
				{
					continue;
				}
				if (netgame && !deathmatch && link.bIsPlayer)
				{
					continue;
				}
				if (P_CheckSight(self, link))
				{
					return link;
				}
			}
		}
		else if (Class == Minotaur)	// looking around minotaur
		{
			if (link.bCountKill || (link.bIsPlayer && (link != *_SpecialMobj1)))
			{
				if (!link.bShootable)
				{
					continue;
				}
				if (link.bDormant)
				{
					continue;
				}
				if ((link.Class == Minotaur) &&
					(link._SpecialMobj1 == _SpecialMobj1))
				{
					continue;
				}
				if (netgame && !deathmatch && link.bIsPlayer)
				{
					continue;
				}
				if (P_CheckSight(self, link))
				{
					return link;
				}
			}
		}
		else if (Class == MageStaffFX2)	// bloodscourge
		{
			if ((link.bCountKill || link.bIsPlayer) && link != Owner &&
				!link.bDormant)
			{
				if (!link.bShootable)
				{
					continue;
				}
				if (netgame && !deathmatch && link.bIsPlayer)
				{
					continue;
				}
				else if (P_CheckSight(self, link))
				{
					angle = AngleMod360(atan2(
						link.Origin.y - Owner.Origin.y,
						link.Origin.x - Owner.Origin.x) -
						Owner.Angles.yaw);
					if (angle > 226.0 * 360.0 / 256.0 ||
						angle < 30.0 * 360.0 / 256.0)
					{
						return link;
					}
				}
			}
		}
		else	// spirits
		{
			if ((link.bCountKill || link.bIsPlayer) && !link.bDormant)
			{
				if (!link.bShootable)
				{
					continue;
				}
				if (netgame && !deathmatch && link.bIsPlayer)
				{
					continue;
				}
				if (link == Owner)
				{
					continue;
				}
				else if (P_CheckSight(self, link))
				{
					return link;
				}
			}
		}
	}
	return none;
}

//===========================================================================
//
//	Actor::RoughMonsterSearch
//
//	Searches though the surrounding mapblocks for monsters/players
//      distance is in MAPBLOCKUNITS
//
//===========================================================================

Actor Actor::RoughMonsterSearch(int distance)
{
	int blockX;
	int blockY;
	int startX, startY;
	int blockIndex;
	int firstStop;
	int secondStop;
	int thirdStop;
	int finalStop;
	int count;
	Actor newEnemy;

	startX = MapBlock(Origin.x - level->bmaporgx);
	startY = MapBlock(Origin.y - level->bmaporgy);

	if (startX >= 0 && startX < level->bmapwidth && startY >= 0
		&& startY < level->bmapheight)
	{
		newEnemy = RoughBlockCheck(startY * level->bmapwidth + startX);
		if (newEnemy)
		{
			// found a target right away
			return newEnemy;
		}
	}
	for (count = 1; count <= distance; count++)
	{
		blockX = startX - count;
		blockY = startY - count;

		if (blockY < 0)
		{
			blockY = 0;
		}
		else if (blockY >= level->bmapheight)
		{
			blockY = level->bmapheight - 1;
		}
		if (blockX < 0)
		{
			blockX = 0;
		}
		else if (blockX >= level->bmapwidth)
		{
			blockX = level->bmapwidth - 1;
		}
		blockIndex = blockY * level->bmapwidth + blockX;
		firstStop = startX + count;
		if (firstStop < 0)
		{
			continue;
		}
		if (firstStop >= level->bmapwidth)
		{
			firstStop = level->bmapwidth - 1;
		}
		secondStop = startY + count;
		if (secondStop < 0)
		{
			continue;
		}
		if (secondStop >= level->bmapheight)
		{
			secondStop = level->bmapheight - 1;
		}
		thirdStop = secondStop * level->bmapwidth + blockX;
		secondStop = secondStop * level->bmapwidth + firstStop;
		firstStop += blockY * level->bmapwidth;
		finalStop = blockIndex;

		// Trace the first block section (along the top)
		for (; blockIndex <= firstStop; blockIndex++)
		{
			newEnemy = RoughBlockCheck(blockIndex);
			if (newEnemy)
			{
				return newEnemy;
			}
		}
		// Trace the second block section (right edge)
		for (blockIndex--; blockIndex <= secondStop;
			blockIndex += level->bmapwidth)
		{
			newEnemy = RoughBlockCheck(blockIndex);
			if (newEnemy)
			{
				return newEnemy;
			}
		}
		// Trace the third block section (bottom edge)
		for (blockIndex -= level->bmapwidth; blockIndex >= thirdStop;
			blockIndex--)
		{
			newEnemy = RoughBlockCheck(blockIndex);
			if (newEnemy)
			{
				return newEnemy;
			}
		}
		// Trace the final block section (left edge)
		for (blockIndex++; blockIndex > finalStop;
			blockIndex -= level->bmapwidth)
		{
			newEnemy = RoughBlockCheck(blockIndex);
			if (newEnemy)
			{
				return newEnemy;
			}
		}
	}
	return none;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.19  2002/03/16 17:47:46  dj_jl
//  Got rid of mobj_t and some other legacy.
//
//  Revision 1.18  2002/03/09 17:57:02  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.17  2002/03/02 18:00:15  dj_jl
//  Some smaller changes, beautification.
//
//  Revision 1.16  2002/02/26 17:49:48  dj_jl
//  no message
//
//  Revision 1.15  2002/02/22 18:00:20  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.14  2002/02/14 19:20:58  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.13  2002/02/06 17:28:52  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.12  2002/02/02 19:17:26  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.11  2002/01/28 18:50:18  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.10  2002/01/25 18:04:35  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.9  2002/01/17 18:15:54  dj_jl
//  Renamed all map object classes
//
//  Revision 1.8  2002/01/15 18:27:00  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.7  2002/01/07 12:25:57  dj_jl
//  Changed copyright year
//
//  Revision 1.6  2001/12/27 17:52:23  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.5  2001/10/22 17:23:12  dj_jl
//  Floatification of angles
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/31 17:17:23  dj_jl
//  Removed vector macros
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
