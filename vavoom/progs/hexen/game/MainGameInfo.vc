//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class MainGameInfo : GameInfo;

const int MAX_TAGGED_LINES	= 64;

const int NUMTOTALBOTS		= 24;
const int NUMBOTTYPES		= 24;

struct tagged_line_t
{
	line_t *line;
	int lineTag;
};

enum
{
	PO_ANCHOR_TYPE_HEXEN = 3000,
	PO_SPAWN_TYPE_HEXEN,
	PO_SPAWNCRUSH_TYPE_HEXEN,

	PO_ANCHOR_TYPE = 9300,
	PO_SPAWN_TYPE,
	PO_SPAWNCRUSH_TYPE
};

classid WeaponClasses[HexenDefs::NUMWEAPONS * HexenDefs::NUMCLASSES];

int terrain_contents[6];
int contents_transluc[6];

botinfo_t botinfo[NUMTOTALBOTS];
int botskill;

tagged_line_t TaggedLines[MAX_TAGGED_LINES];
int TaggedLineCount;

float AutoArmorSave[HexenDefs::NUMCLASSES];
float ArmorIncrement[HexenDefs::NUMCLASSES * HexenDefs::NUMARMOR];

//
//  Pickup messages
//
string weaponMessages[6];
string fourthWeaponText[3];
string weaponPieceText[3];
string artifactMessages[HexenDefs::NUMARTIFACTS];
string armorText[HexenDefs::NUMARMOR];
string manaText[4];
string TextKeyMessages[HexenDefs::NUMKEYS];

float windTab[3];
float pushTab[5];

float ArmorMax[HexenDefs::NUMCLASSES];

int pieceValueTrans[5];

int opposite[9];
int diags[4];
float xspeed[8];
float yspeed[8];

int WeaponManaUseTable[HexenDefs::NUMCLASSES * HexenDefs::NUMWEAPONS];

int classFlags[3];

float air_control;

bool randomclass;

Actor PuffSpawned;

//==========================================================================
//
//	Init
//
//==========================================================================

void Init()
{
	SetSeqTrans('Platform', 0, SEQ_Platform);
	SetSeqTrans('Platform', 1, SEQ_Platform);	// a 'heavy' platform is just a platform
	SetSeqTrans('PlatformMetal', 2, SEQ_Platform);
	SetSeqTrans('Platform', 3, SEQ_Platform);	// same with a 'creak' platform
	SetSeqTrans('Silence', 4, SEQ_Platform);
	SetSeqTrans('Lava', 5, SEQ_Platform);
	SetSeqTrans('Water', 6, SEQ_Platform);
	SetSeqTrans('Ice', 7, SEQ_Platform);
	SetSeqTrans('Earth', 8, SEQ_Platform);
	SetSeqTrans('PlatformMetal2', 9, SEQ_Platform);

	SetSeqTrans('DoorNormal', 0, SEQ_Door);
	SetSeqTrans('DoorHeavy', 1, SEQ_Door);
	SetSeqTrans('DoorMetal', 2, SEQ_Door);
	SetSeqTrans('DoorCreak', 3, SEQ_Door);
	SetSeqTrans('Silence', 4, SEQ_Door);
	SetSeqTrans('Lava', 5, SEQ_Door);
	SetSeqTrans('Water', 6, SEQ_Door);
	SetSeqTrans('Ice', 7, SEQ_Door);
	SetSeqTrans('Earth', 8, SEQ_Door);
	SetSeqTrans('DoorMetal2', 9, SEQ_Door);

	SetSeqTrans('Wind', 0, SEQ_Environment);

	InitBotTypes();
}

//==========================================================================
//
//  InitNewGame
//
//==========================================================================

void InitNewGame(int skill)
{
	nomonsters = GetCvar('NoMonsters');
	fastparm = gameskill == sk_nightmare || GetCvar('Fast');
	randomclass = GetCvar('RandomClass');
}

//==========================================================================
//
//  CreateLevelInfo
//
//==========================================================================

LevelInfo CreateLevelInfo()
{
	return LevelInfo(NewSpecialThinker(HexenLevelInfo));
}

//==========================================================================
//
//  InitBotTypes
//
//==========================================================================

void InitBotTypes()
{
	SetBotType(0,
		"botf1",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf1\\color\\0\\class\\0\\model\\\\skin\\"
	);
	SetBotType(1,
		"botf2",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf2\\color\\1\\class\\0\\model\\\\skin\\"
	);
	SetBotType(2,
		"botf3",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf3\\color\\2\\class\\0\\model\\\\skin\\"
	);
	SetBotType(3,
		"botf4",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf4\\color\\3\\class\\0\\model\\\\skin\\"
	);
	SetBotType(4,
		"botf5",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf5\\color\\4\\class\\0\\model\\\\skin\\"
	);
	SetBotType(5,
		"botf6",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf6\\color\\5\\class\\0\\model\\\\skin\\"
	);
	SetBotType(6,
		"botf7",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf7\\color\\6\\class\\0\\model\\\\skin\\"
	);
	SetBotType(7,
		"botf8",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botf8\\color\\7\\class\\0\\model\\\\skin\\"
	);
	SetBotType(8,
		"botc1",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc1\\color\\0\\class\\1\\model\\\\skin\\"
	);
	SetBotType(9,
		"botc2",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc2\\color\\1\\class\\1\\model\\\\skin\\"
	);
	SetBotType(10,
		"botc3",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc3\\color\\2\\class\\1\\model\\\\skin\\"
	);
	SetBotType(11,
		"botc4",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc4\\color\\3\\class\\1\\model\\\\skin\\"
	);
	SetBotType(12,
		"botc5",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc5\\color\\4\\class\\1\\model\\\\skin\\"
	);
	SetBotType(13,
		"botc6",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc6\\color\\5\\class\\1\\model\\\\skin\\"
	);
	SetBotType(14,
		"botc7",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc7\\color\\6\\class\\1\\model\\\\skin\\"
	);
	SetBotType(15,
		"botc8",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botc8\\color\\7\\class\\1\\model\\\\skin\\"
	);
	SetBotType(16,
		"botm1",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm1\\color\\0\\class\\2\\model\\\\skin\\"
	);
	SetBotType(17,
		"botm2",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm2\\color\\1\\class\\2\\model\\\\skin\\"
	);
	SetBotType(18,
		"botm3",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm3\\color\\2\\class\\2\\model\\\\skin\\"
	);
	SetBotType(19,
		"botm4",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm4\\color\\3\\class\\2\\model\\\\skin\\"
	);
	SetBotType(20,
		"botm5",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm5\\color\\4\\class\\2\\model\\\\skin\\"
	);
	SetBotType(21,
		"botm6",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm6\\color\\5\\class\\2\\model\\\\skin\\"
	);
	SetBotType(22,
		"botm7",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm7\\color\\6\\class\\2\\model\\\\skin\\"
	);
	SetBotType(23,
		"botm8",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\name\\botm8\\color\\7\\class\\2\\model\\\\skin\\"
	);
}

//==========================================================================
//
//  SetBotType
//
//==========================================================================

void SetBotType(int i, string Name, int accuracy, int intelect, int evade,
	int anticip, int reaction, string userinfo)
{
	botinfo[i].Name = Name;
	botinfo[i].accuracy = accuracy;
	botinfo[i].intelect = intelect;
	botinfo[i].evade = evade;
	botinfo[i].anticip = anticip;
	botinfo[i].reaction = reaction;
	botinfo[i].userinfo = userinfo;
}

//==========================================================================
//
//  MakeFloorSlope
//
//==========================================================================

void MakeFloorSlope(Level InLevel, mthing_t * mthing)
{
	sector_t *sec;
	line_t *line;
	int i;

	sec = InLevel.PointInSector(vector(mthing->x, mthing->y, 0.0));
	for (i = 0; i < sec->linecount; i++)
	{
		line = sec->lines[i];
		if (mthing->tid == line->arg1)
		{
			TVec v1;
			TVec v2;
			TVec p1;
			TVec p2;
			TVec p3;

			p1 = vector(line->v1->x, line->v1->y, sec->floor.minz);
			p2 = vector(line->v2->x, line->v2->y, sec->floor.minz);
			p3 = vector(mthing->x, mthing->y, mthing->height);
			if (PointOnPlaneSide(p3, line) == 0)
			{
				v1 = p2 - p3;
				v2 = p1 - p3;
			}
			else
			{
				v1 = p1 - p3;
				v2 = p2 - p3;
			}
			sec->floor.normal = Normalise(CrossProduct(v1, v2));
			if (sec->floor.normal.z <= 0.0)
			{
				Error("Floor with normal.z <= 0.0");
			}
			sec->floor.dist = DotProduct(sec->floor.normal, p3);
			sec->base_floorheight = sec->floor.dist;
			InLevel.SendFloorSlope(sec);
			return;
		}
	}
}

//==========================================================================
//
//  MakeCeilingSlope
//
//==========================================================================

void MakeCeilingSlope(Level InLevel, mthing_t * mthing)
{
	sector_t *sec;
	line_t *line;
	int i;

	sec = InLevel.PointInSector(vector(mthing->x, mthing->y, 0.0));
	for (i = 0; i < sec->linecount; i++)
	{
		line = sec->lines[i];
		if (mthing->tid == line->arg1)
		{
			TVec p1;
			TVec p2;
			TVec p3;
			TVec v1;
			TVec v2;

			p1 = vector(line->v1->x, line->v1->y, sec->ceiling.maxz);
			p2 = vector(line->v2->x, line->v2->y, sec->ceiling.maxz);
			p3 = vector(mthing->x, mthing->y, mthing->height);
			if (PointOnPlaneSide(p3, line) == 0)
			{
				v1 = p1 - p3;
				v2 = p2 - p3;
			}
			else
			{
				v1 = p2 - p3;
				v2 = p1 - p3;
			}
			sec->ceiling.normal = Normalise(CrossProduct(v1, v2));
			if (sec->ceiling.normal.z >= 0.0)
			{
				Error("Ceiling with normal.z >= 0.0");
			}
			sec->ceiling.dist = DotProduct(sec->ceiling.normal, p3);
			sec->base_ceilingheight = sec->ceiling.dist;
			InLevel.SendCeilingSlope(sec);
			return;
		}
	}
}

//==========================================================================
//
//	SetVertexHeights
//
//==========================================================================

bool SetVertexHeights(Level InLevel, int ThingID)
{
	int i;
	int j;
	bool ret;
	mthing_t * mthing;
	
	ret = false;
	//	Clean all
	for (i = 0; i < InLevel.NumVertexes; i++)
	{
		InLevel.Vertexes[i].z = 0.1;
	}
	for (j = 0; j < InLevel.NumThings; j++)
	{
		mthing = &InLevel.Things[j];
		if (mthing->type == ThingID)
		{
			for (i = 0; i < InLevel.NumVertexes; i++)
			{
				if (InLevel.Vertexes[i].x == mthing->x &&
					InLevel.Vertexes[i].y == mthing->y)
				{
					InLevel.Vertexes[i].z = mthing->height;
					ret = true;
				}
			}
		}
	}
	return ret;
}

//==========================================================================
//
//	CleanVertexHeights
//
//==========================================================================

void CleanVertexHeights(Level InLevel)
{
	int i;
	
	for (i = 0; i < InLevel.NumVertexes; i++)
	{
		InLevel.Vertexes[i].z = 0.0;
	}
}

//==========================================================================
//
//	MakeVertexFloorHeights
//
//==========================================================================

void MakeVertexFloorHeights(Level InLevel)
{
	int i;
	sector_t *sec;
	TVec p1;
	TVec p2;
	TVec p3;
	TVec v1;
	TVec v2;
	
	if (!SetVertexHeights(InLevel, 1504))
	{
		return;
	}
	for (i = 0; i < InLevel.NumSectors; i++)
	{
		sec = &InLevel.Sectors[i];
		if (sec->linecount != 3)
			continue;
		p1 = *sec->lines[0]->v1;
		p2 = *sec->lines[0]->v2;
		if (sec->lines[1]->v1 == sec->lines[0]->v1 ||
			sec->lines[1]->v1 == sec->lines[0]->v2)
		{
			p3 = *sec->lines[1]->v2;
		}
		else
		{
			p3 = *sec->lines[1]->v1;
		}
		if (p1.z == 0.1 && p2.z == 0.1 && p3.z == 0.1)
		{
			continue;
		}
		if (p1.z == 0.1)
		{
			p1.z = sec->floorheight;
		}
		if (p2.z == 0.1)
		{
			p2.z = sec->floorheight;
		}
		if (p3.z == 0.1)
		{
			p3.z = sec->floorheight;
		}
		if (PointOnPlaneSide(p3, sec->lines[0]) == 0)
		{
			v1 = p2 - p3;
			v2 = p1 - p3;
		}
		else
		{
			v1 = p1 - p3;
			v2 = p2 - p3;
		}
		sec->floor.normal = Normalise(CrossProduct(v1, v2));
		if (sec->floor.normal.z <= 0.0)
		{
			Error("Floor with normal.z <= 0.0");
		}
		sec->floor.dist = DotProduct(sec->floor.normal, p3);
		sec->base_floorheight = sec->floor.dist;
		InLevel.SendFloorSlope(sec);
	}
}

//==========================================================================
//
//	MakeVertexCeilingHeights
//
//==========================================================================

void MakeVertexCeilingHeights(Level InLevel)
{
	int i;
	sector_t *sec;
	TVec p1;
	TVec p2;
	TVec p3;
	TVec v1;
	TVec v2;
	
	if (!SetVertexHeights(InLevel, 1505))
	{
		return;
	}
	for (i = 0; i < InLevel.NumSectors; i++)
	{
		sec = &InLevel.Sectors[i];
		if (sec->linecount != 3)
			continue;
		p1 = *sec->lines[0]->v1;
		p2 = *sec->lines[0]->v2;
		if (sec->lines[1]->v1 == sec->lines[0]->v1 ||
			sec->lines[1]->v1 == sec->lines[0]->v2)
		{
			p3 = *sec->lines[1]->v2;
		}
		else
		{
			p3 = *sec->lines[1]->v1;
		}
		if (p1.z == 0.1 && p2.z == 0.1 && p3.z == 0.1)
		{
			continue;
		}
		if (p1.z == 0.1)
		{
			p1.z = sec->ceilingheight;
		}
		if (p2.z == 0.1)
		{
			p2.z = sec->ceilingheight;
		}
		if (p3.z == 0.1)
		{
			p3.z = sec->ceilingheight;
		}
		if (PointOnPlaneSide(p3, sec->lines[0]) == 0)
		{
			v1 = p1 - p3;
			v2 = p2 - p3;
		}
		else
		{
			v1 = p2 - p3;
			v2 = p1 - p3;
		}
		sec->ceiling.normal = Normalise(CrossProduct(v1, v2));
		if (sec->ceiling.normal.z >= 0.0)
		{
			Error("Ceiling with normal.z >= 0.0");
		}
		sec->ceiling.dist = DotProduct(sec->ceiling.normal, p3);
		sec->base_ceilingheight = sec->ceiling.dist;
		InLevel.SendCeilingSlope(sec);
	}
}

//==========================================================================
//
//	AlignPlane
//
//	Set slopes for sectors, based on line specials
//
//	Aligns the floor or ceiling of a sector to the corresponding plane
// on the other side of the reference line. (By definition, line must be
// two-sided.)
//
//	If (which & 1), sets floor.
//	If (which & 2), sets ceiling.
//
//==========================================================================

void AlignPlane(Level InLevel, sector_t *sec, line_t *line, int which)
{
	sector_t *refsec;
	float bestdist;
	TVec *refvert = (*sec->lines)->v1;
	int i;
	line_t **probe;
	float dist;
	TVec *vert;
	TVec p, v1, v2, cross;
	sec_plane_t *refplane;
	sec_plane_t *srcplane;
	float srcheight, destheight;

	if (line->backsector == NULL)
		return;

	//	Find furthest vertex from the reference line. It, along with the two
	// ends of the line will define the plane.
	bestdist = 0.0;
	for (i = sec->linecount * 2, probe = sec->lines; i > 0; i--)
	{
		if (i & 1)
		{
			vert = (*probe)->v2;
			probe = &probe[1];
		}
		else
			vert = (*probe)->v1;
		dist = fabs(DotProduct(*vert, line->normal));

		if (dist > bestdist)
		{
			bestdist = dist;
			refvert = vert;
		}
	}

	refsec = line->frontsector == sec ? line->backsector : line->frontsector;

	p = *line->v1;
	v1 = *line->v2 - *line->v1;
	v2 = *refvert - *line->v1;

	refplane = (which == 0) ? &refsec->floor : &refsec->ceiling;
	srcplane = (which == 0) ? &sec->floor : &sec->ceiling;
	srcheight = (which == 0) ? sec->floorheight : sec->ceilingheight;
	destheight = (which == 0) ? refsec->floorheight : refsec->ceilingheight;

	p.z = destheight;
	v1.z = 0.0;
	v2.z = srcheight - destheight;

	cross = Normalise(CrossProduct(v1, v2));

	// Fix backward normals
	if ((cross.z < 0.0 && which == 0) || (cross.z > 0.0 && which == 1))
	{
		cross = -cross;
	}

	srcplane->normal = cross;
	srcplane->dist = DotProduct(cross, p);
	if (which == 0)
		InLevel.SendFloorSlope(sec);
	else
		InLevel.SendCeilingSlope(sec);
}

//==========================================================================
//
//	SetSlopes
//
//==========================================================================

void SetSlopes(Level InLevel)
{
	int i, s;

	for (i = 0; i < InLevel.NumLines; i++)
	{
		if (InLevel.Lines[i].special == LNSPEC_PlaneAlign)
		{
			InLevel.Lines[i].special = 0;
//			InLevel.Lines[i].id = InLevel.Lines[i].args[2];
			if (InLevel.Lines[i].backsector != NULL)
			{
				// args[0] is for floor, args[1] is for ceiling
				//
				// As a special case, if args[1] is 0,
				// then args[0], bits 2-3 are for ceiling.
				for (s = 0; s < 2; s++)
				{
					int bits = (s == 0 ? InLevel.Lines[i].arg1 :
 						InLevel.Lines[i].arg2) & 3;

					if (s == 1 && bits == 0)
						bits = (InLevel.Lines[i].arg1 >> 2) & 3;

					if (bits == 1)			// align front side to back
						AlignPlane(InLevel, InLevel.Lines[i].frontsector,
							&InLevel.Lines[i], s);
					else if (bits == 2)		// align back side to front
						AlignPlane(InLevel, InLevel.Lines[i].backsector,
							&InLevel.Lines[i], s);
				}
			}
		}
	}
}

//==========================================================================
//
//  SpawnExtraFloors
//
//==========================================================================

void SpawnExtraFloors(Level InLevel, line_t * line)
{
	int j;

	for (j = 0; j < InLevel.NumSectors; j++)
	{
		if (line->arg1 == InLevel.Sectors[j].tag)
		{
			InLevel.AddExtraFloor(line, &InLevel.Sectors[j]);
		}
	}
}

//==========================================================================
//
//  CreateContents
//
//==========================================================================

void MakeContents(line_t * line)
{
	int contents;

	if (!line->arg1 && !line->arg2 && !line->arg3)
	{
		contents =
			terrain_contents[TerrainType(line->frontsector->floor.pic)];
		line->frontsector->params.contents = contents;
		if (line->frontsector->floor.dist == -line->frontsector->ceiling.dist)
		{
			line->frontsector->floor.translucency =
				contents_transluc[contents];
			line->frontsector->ceiling.translucency =
				contents_transluc[contents];
			line->frontsector->ceiling.flags |=
				SPF_NOBLOCKING | SPF_NOBLOCKSIGHT | SPF_NOBLOCKSHOOT;
			line->frontsector->floor.flags |=
				SPF_NOBLOCKING | SPF_NOBLOCKSIGHT | SPF_NOBLOCKSHOOT;
		}
	}
	else
	{
		line->frontsector->params.contents = line->arg1;

		line->frontsector->floor.translucency = line->arg2;
		line->frontsector->ceiling.translucency = line->arg2;

		line->frontsector->ceiling.flags = line->arg3;
		line->frontsector->floor.flags = line->arg3;
	}
}

//==========================================================================
//
//  MakeHeightSec
//
//	killough 3/7/98:
//	support for drawn heights coming from different sector
//
//==========================================================================

void MakeHeightSec(Level InLevel, line_t* Line)
{
	sector_t*	Sec;
	int			s;

	Sec = Line->frontsector;
	if (Line->arg2 & 2)
	{
		Sec->bFakeFloorOnly = true;
	}
	if (Line->arg2 & 4)
	{
		Sec->bClipFakePlanes = true;
	}
	if (Line->arg2 & 8)
	{
		Sec->bUnderWater = true;
	}
	if (Line->arg2 & 16)
	{
		Sec->bIgnoreHeightSec = true;
	}
	if (Line->arg2 & 32)
	{
		Sec->bNoFakeLight = true;
	}
	for (s = InLevel.FindSectorFromTag(Line->arg1, -1); s  >= 0;
		s = InLevel.FindSectorFromTag(Line->arg1, s))
	{
		InLevel.Sectors[s].heightsec = Sec;
		InLevel.SetHeightSector(&InLevel.Sectors[s], Sec, Line->arg2);
	}
}

//==========================================================================
//
//  SetSectorFriction
//
//==========================================================================

void SetSectorFriction(Level InLevel, int tag, int amount, bool alterFlag)
{
	int			s;
	int			OldFriction;
	int			OldMoveFactor;
	float		Friction;
	float		MoveFactor;

	// An amount of 100 should result in a friction of
	// ORIG_FRICTION (0xE800)
	OldFriction = (0x1EB8 * amount) / 0x80 + 0xD001;

	// killough 8/28/98: prevent odd situations
	if (OldFriction > 0x10000)
		OldFriction = 0x10000;
	if (OldFriction < 0)
		OldFriction = 0;

	// The following check might seem odd. At the time of movement,
	// the move distance is multiplied by 'friction/0x10000', so a
	// higher friction value actually means 'less friction'.

	// [RH] Twiddled these values so that momentum on ice (with
	//		friction 0xf900) is the same as in Heretic/Hexen.
	if (OldFriction >= 0xe800)	// ice
//		movefactor = ((0x10092 - friction)*(0x70))/0x158;
		OldMoveFactor = ((0x10092 - OldFriction) * 1024) / 4352 + 568;
	else
		OldMoveFactor = ((OldFriction - 0xDB34) * (0xA)) / 0x80;

	// killough 8/28/98: prevent odd situations
	if (OldMoveFactor < 32)
		OldMoveFactor = 32;

	Friction = (1.0 - itof(OldFriction) / itof(0x10000)) * 35.0;
	MoveFactor = itof(OldMoveFactor) / itof(0x10000);

	for (s = InLevel.FindSectorFromTag(tag, -1); s >= 0;
		s = InLevel.FindSectorFromTag(tag, s))
	{
		// killough 8/28/98:
		//
		// Instead of spawning thinkers, which are slow and expensive,
		// modify the sector's own friction values. Friction should be
		// a property of sectors, not objects which reside inside them.
		// Original code scanned every object in every friction sector
		// on every tic, adjusting its friction, putting unnecessary
		// drag on CPU. New code adjusts friction of sector only once
		// at level startup, and then uses this friction value.

		InLevel.Sectors[s].Friction = Friction;
		InLevel.Sectors[s].MoveFactor = MoveFactor;
		if (alterFlag)
		{
			// When used inside a script, the sectors' friction flags
			// can be enabled and disabled at will.
			if (OldFriction == 0xe800)
			{
				InLevel.Sectors[s].special &= ~SECSPEC_FRICTION_MASK;
			}
			else
			{
				InLevel.Sectors[s].special |= SECSPEC_FRICTION_MASK;
			}
		}
	}
}

//==========================================================================
//
//  SpawnWorld
//
//==========================================================================

void SpawnWorld(Level InLevel)
{
	int			i;
	int			j;
	int			length;
	int			SecNum;
	mthing_t*	mthing;

	//  Spawn slopes first
	SetSlopes(InLevel);
	for (i = 0; i < InLevel.NumThings; i++)
	{
		mthing = &InLevel.Things[i];

		if (mthing->type == 1500)
		{
			MakeFloorSlope(InLevel, mthing);
			mthing->type = 0;
			continue;
		}

		if (mthing->type == 1501)
		{
			MakeCeilingSlope(InLevel, mthing);
			mthing->type = 0;
			continue;
		}

		if (mthing->type == PO_SPAWN_TYPE_HEXEN ||
			mthing->type == PO_SPAWNCRUSH_TYPE_HEXEN ||
			mthing->type == PO_SPAWN_TYPE ||
			mthing->type == PO_SPAWNCRUSH_TYPE)
		{
			// Polyobj StartSpot Pt.
			InLevel.SpawnPolyobj(mthing->x, mthing->y, mthing->angle,
				mthing->type == PO_SPAWNCRUSH_TYPE_HEXEN ||
				mthing->type == PO_SPAWNCRUSH_TYPE);
			mthing->type = 0;
			continue;
		}
		if (mthing->type == PO_ANCHOR_TYPE_HEXEN ||
			mthing->type == PO_ANCHOR_TYPE)
		{
			// Polyobj Anchor Pt.
			InLevel.AddPolyAnchorPoint(mthing->x, mthing->y, mthing->angle);
			mthing->type = 0;
			continue;
		}
	}
	MakeVertexFloorHeights(InLevel);
	MakeVertexCeilingHeights(InLevel);
	CleanVertexHeights(InLevel);

	//	Initialise initial friction values.
	for (i = 0; i < InLevel.NumSectors; i++)
	{
		InLevel.Sectors[i].Friction = Actor::FRICTION_NORMAL;
	}

	//  Spawn 3D floors
	for (i = 0; i < InLevel.NumLines; i++)
	{
		switch (InLevel.Lines[i].special)
		{
		case LNSPEC_3DFloor:
			SpawnExtraFloors(InLevel, &InLevel.Lines[i]);
			InLevel.Lines[i].special = 0;
			break;

		case LNSPEC_Contents:
			MakeContents(&InLevel.Lines[i]);
			InLevel.Lines[i].special = 0;
			break;

		case LNSPEC_TransferFloorLight:
			for (SecNum = InLevel.FindSectorFromTag(InLevel.Lines[i].arg1, -1);
				SecNum >= 0;
				SecNum = InLevel.FindSectorFromTag(InLevel.Lines[i].arg1, SecNum))
			{
				InLevel.SetFloorLightSector(&InLevel.Sectors[SecNum],
					InLevel.Lines[i].frontsector);
			}
			InLevel.Lines[i].special = 0;
			break;

		case LNSPEC_TransferCeilingLight:
			for (SecNum = InLevel.FindSectorFromTag(InLevel.Lines[i].arg1, -1);
				SecNum >= 0;
				SecNum = InLevel.FindSectorFromTag(InLevel.Lines[i].arg1, SecNum))
			{
				InLevel.SetCeilingLightSector(&InLevel.Sectors[SecNum],
					InLevel.Lines[i].frontsector);
			}
			InLevel.Lines[i].special = 0;
			break;

		case LNSPEC_SectorSetFriction:
			if (InLevel.Lines[i].arg2)
			{
				//	Allow setting friction amount from parameter
				length = InLevel.Lines[i].arg2 <= 200 ?
					InLevel.Lines[i].arg2 : 200;
			}
			else
			{
				length = ftoi(Length(*InLevel.Lines[i].v2 -
					*InLevel.Lines[i].v1));
			}

			SetSectorFriction(InLevel, InLevel.Lines[i].arg1, length, false);
			InLevel.Lines[i].special = 0;
			break;

		case LNSPEC_TransferHeights:
			MakeHeightSec(InLevel, &InLevel.Lines[i]);
			break;
		}
	}

	TaggedLineCount = 0;
	for (i = 0; i < InLevel.NumLines; i++)
	{
		switch (InLevel.Lines[i].special)
		{
		case LNSPEC_LineSetIdentification:
		case LNSPEC_LineTranslucent:
		case LNSPEC_TeleportLine:
			if (InLevel.Lines[i].arg1)
			{
				if (TaggedLineCount == MAX_TAGGED_LINES)
				{
					Error("P_SpawnSpecials: MAX_TAGGED_LINES exceeded.");
				}
				TaggedLines[TaggedLineCount].line = &InLevel.Lines[i];
				TaggedLines[TaggedLineCount++].lineTag = InLevel.Lines[i].arg1;
			}
			if (InLevel.Lines[i].special == LNSPEC_LineSetIdentification)
			{
				InLevel.Lines[i].special = 0;
			}
			break;
		}
	}

	//	Process translucent lines
	for (i = 0; i < InLevel.NumLines; i++)
	{
		if (InLevel.Lines[i].special != 208)
		{
			continue;
		}

		int trans = (255 - InLevel.Lines[i].arg2) * 100 / 255;
		if (InLevel.Lines[i].arg1)
		{
			for (j = 0; j < TaggedLineCount; j++)
			{
				if (TaggedLines[j].lineTag == InLevel.Lines[i].arg1)
				{
					InLevel.SetLineTransluc(TaggedLines[j].line, trans);
				}
			}
		}
		else
		{
			InLevel.SetLineTransluc(&InLevel.Lines[i], trans);
		}
		InLevel.Lines[i].special = 0;
	}
}

defaultproperties
{
	num_stats = HexenDefs::NUMARMOR + HexenDefs::NUMMANA + 8 + HexenDefs::NUMARTIFACTS * 2;

	WeaponClasses[0] = WeaponFighterPunch;
	WeaponClasses[1] = WeaponClericMace;
	WeaponClasses[2] = WeaponMageWand;
	WeaponClasses[3] = WeaponPigSnout;
	WeaponClasses[4] = WeaponFighterAxe;
	WeaponClasses[5] = WeaponClericStaff;
	WeaponClasses[6] = WeaponMageCone;
	WeaponClasses[7] = WeaponPigSnout;
	WeaponClasses[8] = WeaponFighterHammer;
	WeaponClasses[9] = WeaponClericFire;
	WeaponClasses[10] = WeaponMageLightning;
	WeaponClasses[11] = WeaponPigSnout;
	WeaponClasses[12] = WeaponFighterSword;
	WeaponClasses[13] = WeaponClericHoly;
	WeaponClasses[14] = WeaponMageStaff;
	WeaponClasses[15] = WeaponPigSnout;

	terrain_contents[0] = CONTENTS_EMPTY;
	terrain_contents[1] = CONTENTS_EMPTY;
	terrain_contents[2] = CONTENTS_WATER;
	terrain_contents[3] = CONTENTS_WATER;
	terrain_contents[4] = CONTENTS_LAVA;
	terrain_contents[5] = CONTENTS_SLUDGE;

	contents_transluc[0] = 0;
	contents_transluc[1] = 50;
	contents_transluc[2] = 20;
	contents_transluc[3] = 30;

	AutoArmorSave[0] = 15.0;
	AutoArmorSave[1] = 10.0;
	AutoArmorSave[2] = 5.0;
	AutoArmorSave[3] = 0.0;

	ArmorIncrement[0] = 25.0; ArmorIncrement[1] = 20.0; ArmorIncrement[2] = 15.0; ArmorIncrement[3] = 5.0;
	ArmorIncrement[4] = 10.0; ArmorIncrement[5] = 25.0; ArmorIncrement[6] = 5.0; ArmorIncrement[7] = 20.0;
	ArmorIncrement[8] = 5.0; ArmorIncrement[9] = 15.0; ArmorIncrement[10] = 10.0; ArmorIncrement[11] = 25.0;
	ArmorIncrement[12] = 0.0; ArmorIncrement[13] = 0.0; ArmorIncrement[14] = 0.0; ArmorIncrement[15] = 0.0;

	weaponMessages[0] = "TIMON\'S AXE";
	weaponMessages[1] = "HAMMER OF RETRIBUTION";
	weaponMessages[2] = "SERPENT STAFF";
	weaponMessages[3] = "FIRESTORM";
	weaponMessages[4] = "FROST SHARDS";
	weaponMessages[5] = "ARC OF DEATH";

	fourthWeaponText[0] = "QUIETUS ASSEMBLED";
	fourthWeaponText[1] = "WRAITHVERGE ASSEMBLED";
	fourthWeaponText[2] = "BLOODSCOURGE ASSEMBLED";

	weaponPieceText[0] = "SEGMENT OF QUIETUS";
	weaponPieceText[1] = "SEGMENT OF WRAITHVERGE";
	weaponPieceText[2] = "SEGMENT OF BLOODSCOURGE";

	artifactMessages[0] = "";
	artifactMessages[1] = "ICON OF THE DEFENDER";
	artifactMessages[2] = "QUARTZ FLASK";
	artifactMessages[3] = "MYSTIC URN";
	artifactMessages[4] = "MYSTIC AMBIT INCANT";
	artifactMessages[5] = "DARK SERVANT";
	artifactMessages[6] = "TORCH";
	artifactMessages[7] = "PORKALATOR";
	artifactMessages[8] = "WINGS OF WRATH";
	artifactMessages[9] = "DISC OF REPULSION";
	artifactMessages[10] = "FLECHETTE";
	artifactMessages[11] = "BANISHMENT DEVICE";
	artifactMessages[12] = "BOOTS OF SPEED";
	artifactMessages[13] = "KRATER OF MIGHT";
	artifactMessages[14] = "DRAGONSKIN BRACERS";
	artifactMessages[15] = "CHAOS DEVICE";

	artifactMessages[16] = "YORICK\'S SKULL";
	artifactMessages[17] = "HEART OF D\'SPARIL";
	artifactMessages[18] = "RUBY PLANET";
	artifactMessages[19] = "EMERALD PLANET";
	artifactMessages[20] = "EMERALD PLANET";
	artifactMessages[21] = "SAPPHIRE PLANET";
	artifactMessages[22] = "SAPPHIRE PLANET";
	artifactMessages[23] = "DAEMON CODEX";
	artifactMessages[24] = "LIBER OSCURA";
	artifactMessages[25] = "FLAME MASK";
	artifactMessages[26] = "GLAIVE SEAL";
	artifactMessages[27] = "HOLY RELIC";
	artifactMessages[28] = "SIGIL OF THE MAGUS";
	artifactMessages[29] = "CLOCK GEAR";	// All gear pickups use the same text
	artifactMessages[30] = "CLOCK GEAR";
	artifactMessages[31] = "CLOCK GEAR";
	artifactMessages[32] = "CLOCK GEAR";

	armorText[0] = "MESH ARMOR";
	armorText[1] = "FALCON SHIELD";
	armorText[2] = "PLATINUM HELMET";
	armorText[3] = "AMULET OF WARDING";

	manaText[0] = "BLUE MANA";
	manaText[1] = "GREEN MANA";
	manaText[2] = "";
	manaText[3] = "COMBINED MANA";

	TextKeyMessages[0] = "STEEL KEY";
	TextKeyMessages[1] = "CAVE KEY";
	TextKeyMessages[2] = "AXE KEY";
	TextKeyMessages[3] = "FIRE KEY";
	TextKeyMessages[4] = "EMERALD KEY";
	TextKeyMessages[5] = "DUNGEON KEY";
	TextKeyMessages[6] = "SILVER KEY";
	TextKeyMessages[7] = "RUSTED KEY";
	TextKeyMessages[8] = "HORN KEY";
	TextKeyMessages[9] = "SWAMP KEY";
	TextKeyMessages[10] = "CASTLE KEY";

	windTab[0] = 5.0 / 32.0;
	windTab[1] = 10.0 / 32.0;
	windTab[2] = 25.0 / 32.0;

	pushTab[0] = 5.0 * 35.0 * 35.0 / 32.0;
	pushTab[1] = 10.0 * 35.0 * 35.0 / 32.0;
	pushTab[2] = 25.0 * 35.0 * 35.0 / 32.0;
	pushTab[3] = 30.0 * 35.0 * 35.0 / 32.0;
	pushTab[4] = 35.0 * 35.0 * 35.0 / 32.0;

	ArmorMax[0] = 20.0;
	ArmorMax[1] = 18.0;
	ArmorMax[2] = 16.0;
	ArmorMax[3] = 1.0;

	pieceValueTrans[0] = 0;	// 0: never
	pieceValueTrans[1] = WeaponPiece::WPIECE1 | WeaponPiece::WPIECE2 | WeaponPiece::WPIECE3;	// WPIECE1 (1)
	pieceValueTrans[2] = WeaponPiece::WPIECE2 | WeaponPiece::WPIECE3;	// WPIECE2 (2)
	pieceValueTrans[3] = 0;	// 3: never
	pieceValueTrans[4] = WeaponPiece::WPIECE3;	// WPIECE3 (4)

	opposite[0] = DI_WEST;
	opposite[1] = DI_SOUTHWEST;
	opposite[2] = DI_SOUTH;
	opposite[3] = DI_SOUTHEAST;
	opposite[4] = DI_EAST;
	opposite[5] = DI_NORTHEAST;
	opposite[6] = DI_NORTH;
	opposite[7] = DI_NORTHWEST;
	opposite[8] = DI_NODIR;

	diags[0] = DI_NORTHWEST;
	diags[1] = DI_NORTHEAST;
	diags[2] = DI_SOUTHWEST;
	diags[3] = DI_SOUTHEAST;

	xspeed[0] = 1.0;
	xspeed[1] = 0.7171630859;
	xspeed[2] = 0.0;
	xspeed[3] = -0.7171630859;
	xspeed[4] = -1.0;
	xspeed[5] = -0.7171630859;
	xspeed[6] = 0.0;
	xspeed[7] = 0.7171630859;

	yspeed[0] = 0.0;
	yspeed[1] = 0.7171630859;
	yspeed[2] = 1.0;
	yspeed[3] = 0.7171630859;
	yspeed[4] = 0.0;
	yspeed[5] = -0.7171630859;
	yspeed[6] = -1.0;
	yspeed[7] = -0.7171630859;

	WeaponManaUseTable[0] = 0; WeaponManaUseTable[1] = 2; WeaponManaUseTable[2] = 3; WeaponManaUseTable[3] = 14;	//  Fighter
	WeaponManaUseTable[4] = 0; WeaponManaUseTable[5] = 1; WeaponManaUseTable[6] = 4; WeaponManaUseTable[7] = 18;	//  Priest
	WeaponManaUseTable[8] = 0; WeaponManaUseTable[9] = 3; WeaponManaUseTable[10] = 5; WeaponManaUseTable[11] = 15;	//  Mage
	WeaponManaUseTable[12] = 0; WeaponManaUseTable[13] = 0; WeaponManaUseTable[14] = 0; WeaponManaUseTable[15] = 0;	//  Pig

	classFlags[0] = HexenLevelInfo::MTF_FIGHTER;
	classFlags[1] = HexenLevelInfo::MTF_CLERIC;
	classFlags[2] = HexenLevelInfo::MTF_MAGE;

	air_control = 1.0 / 256.0;

	botskill = 2;
}
