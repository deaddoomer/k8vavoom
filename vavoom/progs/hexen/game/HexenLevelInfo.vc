//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class HexenLevelInfo : LineSpecialLevelInfo;

const int BODYQUESIZE			= 32;
const int CORPSEQUEUESIZE		= 64;

EntityEx bodyque[BODYQUESIZE];
int bodyqueslot;

// Corpse queue for monsters
EntityEx corpseQueue[CORPSEQUEUESIZE];
int corpseQueueSlot;

//==========================================================================
//
//  ExecuteActionSpecial
//
//==========================================================================

bool ExecuteActionSpecial(int Special, int Arg1, int Arg2, int Arg3,
	int Arg4, int Arg5, line_t* Line, int Side, Entity E)
{
	bool buttonSuccess;
	EntityEx A;

	A = EntityEx(E);
	buttonSuccess = false;
	switch (Special)
	{
	case LNSPEC_QuakeTremor:
		buttonSuccess = A_LocalQuake(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_UsePuzzleItem:
		buttonSuccess = EV_LineSearchForPuzzleItem(Arg1, Arg2, Arg3, Arg4,
			Arg5, A);
		break;

	// Inert Line specials
	default:
		buttonSuccess = ::ExecuteActionSpecial(Special, Arg1, Arg2, Arg3,
			Arg4, Arg5, Line, Side, E);
		break;
	}
	return buttonSuccess;
}

//==========================================================================
//
//  CheckActivation
//
//==========================================================================

bool CheckActivation(int activationType, line_t * line, EntityEx A)
{
	int lineActivation;

	lineActivation = GET_SPAC(line->flags);
	if (lineActivation == SPAC_PTOUCH &&
		(activationType == SPAC_PCROSS || activationType == SPAC_IMPACT))
	{
		lineActivation = activationType;
	}
	else if (lineActivation == SPAC_USETHROUGH)
	{
		lineActivation = SPAC_USE;
	}
	else if (line->special == LNSPEC_Teleport &&
		lineActivation == SPAC_CROSS && activationType == SPAC_PCROSS &&
		A && A.bMissile)
	{
		// Let missiles use regular player teleports
		lineActivation = SPAC_PCROSS;
	}
	if (lineActivation != activationType)
	{
		return false;
	}
	if (!A.bIsPlayer && !A.bMissile)
	{
		if (lineActivation != SPAC_MCROSS)
		{
			// currently, monsters can only activate the MCROSS activation type
			return false;
		}
		if (line->flags & ML_SECRET)
			return false;	// never open secret doors
	}
	return true;
}

//============================================================================
//
//	CheckLock
//
//============================================================================

bool CheckLock(Entity A, int lock, bool door)
{
	if (!A.bIsPlayer)
	{
		return false;
	}
	if (!lock)
	{
		return true;
	}
	if (!(Player(A.Player).Keys & (1 << (lock - 1))))
	{
		A.Player.centreprint(MainGameInfo(Game).TextKeyLockedMessages[lock - 1]);
		A.PlaySound('DoorLocked', CHAN_ITEM);
		return false;
	}
	return true;
}

//===========================================================================
// Quake variables
//
//      Arg1     Intensity on richter scale (2..9)
//      Arg2     Duration in tics
//      Arg3     Radius for damage, in tile units (64 pixels)
//      Arg4     Radius for tremor in tile units (64 pixels)
//      Arg5     TID of map thing for focus of quake
//
//===========================================================================

//===========================================================================
//
//	A_LocalQuake
//
//===========================================================================

bool A_LocalQuake(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	QuakeFocus focus;
	EntityEx target;
	int lastfound = 0;
	int success = false;

	// Find all quake foci
	do
	{
		target = EntityEx(FindMobjFromTID(Arg5, &lastfound));
		if (target)
		{
			focus = QuakeFocus(Spawn(QuakeFocus, target.Origin));
			if (focus)
			{
				focus.Richters = Arg1;
				focus.QuakeDuration = Arg2 >> 1;	// decremented every 2 tics
				focus.DamageRadius = itof(Arg3) * 64.0;
				focus.TremorRadius = itof(Arg4) * 64.0;
				success = true;
			}
		}
	}
	while (target);

	return success;
}

//==========================================================================
//
// EV_LineSearchForPuzzleItem
//
//==========================================================================

bool EV_LineSearchForPuzzleItem(int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5, EntityEx A)
{
	Inventory Item;
	int type, arti;

	if (!A)
		return false;
	if (!A.bIsPlayer)
		return false;

	// Search player's inventory for puzzle items
	for (Item = A.Inventory; Item; Item = Item.Inventory)
	{
		if (!Artifact(Item))
			continue;
		arti = Artifact(Item).ArtifactType;
		type = arti - HexenDefs::arti_firstpuzzitem;
		if (type < 0)
			continue;
		if (type == Arg1)
		{
			// A puzzle item was found for the line
			if (Player(A.Player).UseArtifact(Item))
			{
				// A puzzle item was found for the line
				Player(A.Player).PlayerRemoveArtifact(Item);
				if (arti < HexenDefs::arti_firstpuzzitem)
				{
					A.PlaySound('UseArtifact', CHAN_ITEM);
				}
				else
				{
					A.PlaySound('PuzzleSuccess', CHAN_ITEM);
				}
				Player(A.Player).ArtifactFlash = 4;
				return true;
			}
		}
	}
	return false;
}

//==========================================================================
//
//  GetClassSpawnFlags
//
//==========================================================================

int GetPClassSpawnFlags()
{
	if (!Game.netgame)
	{
		// Single player
		return MainGameInfo(Game).classFlags[GetCvar('class')];
	}
#ifdef FIXME	//  Because of client/server and in-game joining we can't do this
	else if (!deathmatch)
	{
		// Cooperative
		int spawnMask = 0;
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (GPlayers[i])
			{
				spawnMask |= classFlags[PlayerClass[i]];
			}
		}
		return spawnMask;
	}
#endif
	return 0;
}

defaultproperties
{
	ExtPlayersBase = 9100;
}
