//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// Main bot class
class BotPlayer:Object;

player_t *player;		// Points to reference player
Actor botmo;

// Destinations
Actor item;			// Item (roam towards weapon, etc)
bool bItemIsWeapon;
bool bItemIsPowerup;
Actor goal;			// Teamgame goal spot
Actor node;			// Node we're heading towards
Actor prev;			// Previous node we were at
TVec posdest;			// Position of our destination (doesn't have to be an actor)
bool posdest_valid;
Actor enemy;			// The dead meat.
TVec lastpos;			// Last place we saw our enemy
bool lastpos_valid;
Actor missile;			// A threathing missile that got to be avoided.

Actor ally;			// Ally to tag along with
/*AActor		*last_mate;	// If bots mate dissapeared (not if died) that mate is
						// pointed to by this. Allows bot to roam to it if
						// necessary.

enemyinfo_t	enemyinfo;	// Things we know about our enemy

botstate_t	state;		// What we're doing in teamgame mode

fixed_t		lastx;		// Last known x location of bot's enemy (go there if enemy goes out of sight)
fixed_t		lasty;		// Last known y location of bot's enemy

// Tickers

float t_respawn;*/
float t_strafe;
float t_react;
/*float t_fight;
float t_rocket;
float t_turn;
float t_pissed;
float t_frust;*/
float t_fire;			// Tics left until our gun will actually fire again
float t_anticip;
/*float t_chat;			// Tics left until bots completes "typing" in what he's saying.
						// Bot also doesn't do anything during this time.*/

float forwardmove;	// For building ucmd
float sidemove;

// Misc booleans
bool bAllRound;
bool bNewItemIsWeapon;
bool bNewItemIsPowerup;

/*chatline_t	*chatline;	// For when t_chat expires

bottype_t	bottype;	// Bot type*/
botinfo_t info;			// Aiming, name, perfection, yadda yadda

/*fixed_t		oldx;
fixed_t		oldy;

int			thingnum;*/
int angerlevel;

/*AActor		*things[NUMMOBJTYPES];*/
float combatdist[NUMWEAPONS * NUMCLASSES]; //different for each weapon.

float angle;			// The wanted angle that the bot tries to get every tic.

/*	void LinkToPlayer (int playernum);*/

//==========================================================================
//
//	BotTick
//
//  Main bot function
//
//==========================================================================

void BotTick(float deltaTime)
{
	botmo = player->MO;

	player->ForwardMove = 0.0;
	player->SideMove = 0.0;
	player->FlyMove = 0.0;
	player->Buttons = 0;

	// Don't do anything if we're talking
//	if (B_Chat(bot))
//		return;

	// We're dead, so hit space to respawn
	if (!player->Health)
	{
		player->Buttons |= BT_USE;
		return;
	}

#if 0
	// Fix me: No other talking period while pissed/frustrated
	if (!(level.time & 0xff) && !bot->enemy && !bot->t_pissed && !bot->t_frust)
	{
		int x = P_Random (pr_botchat) % 100;

		if (x < bot->info.chatty)
		{
			if (x)
			{
				x = P_Random (pr_botchat)%10;
				bot->chatline = &chatinfo[bot->info.chatinfo].roam[x];
				bot->t_chat = bot->info.chattime;
			}
			else	// 1/100 chance this'll happen
			{
				// Rare chat strings. WHOO!!!!!
				x = P_Random (pr_botchat)%5;
				bot->chatline = &chatinfo[bot->info.chatinfo].rare[x];
				bot->t_chat = bot->info.chattime;
			}
		}

	}

	// Periodically let out some anger
	if (!(level.time & 0xff))
	{
		if (bot->angerlevel)
			bot->angerlevel--;
		else if (bot->angerlevel < 0)
			bot->angerlevel = 0;
	}

	// Set an ally if we're in a mode that has one
	if (teamgame.value || teamplay.value || !deathmatch.value)
		bot->ally = B_SetAlly (bot);
	else
		bot->ally = NULL;
	
	if (teamgame.value)
	{
		B_SetAction (bot);
		B_SetGoal (bot);
	}
#endif

	// Weed out any bad destinations/enemies
	CheckStuff();

	// Destination setting...
	SetEnemy();
	Scan();

	// Turning towards destination...
	BotAim();
	Turn();

	// Moving towards destination
	Attack();
	Move(deltaTime);

	Pitch();

	// Only walk if we're on skill 0
	if (!botskill)
	{
		if (forwardmove == FORWARDRUN)
			forwardmove = FORWARDWALK;
		if (forwardmove == -FORWARDRUN)
			forwardmove = -FORWARDWALK;
		if (sidemove == SIDERUN)
			sidemove = SIDEWALK;
		if (sidemove == -SIDERUN)
			sidemove = -SIDEWALK;
	}

	player->SideMove = sidemove;
	player->ForwardMove = forwardmove;

#define DECT(var) \
	var -= deltaTime; \
	if (var <= 0.0) \
	{ \
		var = 0.0; \
	}
	DECT(t_react)
//	DECT(t_fight)
//	DECT(t_rocket)
//	DECT(t_turn)
//	DECT(t_pissed)
//	DECT(t_frust)
//	DECT(t_fire)
	DECT(t_anticip)
#undef DECT
}

//==========================================================================
//
//	AngleTo
//
//==========================================================================

float AngleTo(TVec dest)
{
	TVec dir;
	TAVec ang;

	dir = dest - botmo.Origin;
	VectorAngles(&dir, &ang);
	return ang.yaw;
}

//==========================================================================
//
//	CheckItem
// 
//	Determines if we should bother picking up an item or not
//
//==========================================================================

bool CheckItem(Actor item)
{
	int weapon;
	int piece;
	int mana;

	bNewItemIsWeapon = false;
	bNewItemIsPowerup = false;
//?????
    if (!item)
		return false;
	if (!item.bSpecial)
		return false;

	weapon = WeapFromItem(item);
	if (weapon != -1)
	{
		bNewItemIsWeapon = true;

		// If we don't have the weapon, pick it up
		if (!player->WeaponOwned[weapon])
			return true;

		// If we have no more room for the mana it gives
		if ((weapon == WP_SECOND && player->Mana[MANA_1] == MAX_MANA) ||
			(weapon == WP_THIRD && player->Mana[MANA_2] == MAX_MANA))
			return false;
	}

	piece = WeapPieceFromItem(item);
	if (piece != -1)
	{
		bNewItemIsWeapon = true;

		// If we don't have the weapon, pick it up
		if (!(player->Pieces & piece))
			return true;

		// If we have no more room for the mana it gives
		if (player->Mana[MANA_1] == MAX_MANA &&
			player->Mana[MANA_2] == MAX_MANA)
			return false;
	}

	mana = ManaFromItem(item);
	if (mana != -1)
	{
		// If we have no more room for the mana it gives
		if (mana == MANA_1 && player->Mana[MANA_1] == MAX_MANA)
			return false;
		if (mana == MANA_2 && player->Mana[MANA_2] == MAX_MANA)
			return false;
		if (mana == MANA_BOTH && player->Mana[MANA_1] == MAX_MANA &&
			player->Mana[MANA_2] == MAX_MANA)
			return false;
	}

	if (item.Class == ItemHealingBottle && (botmo.Health >= MAXHEALTH))
		return false;
#if 0
	if ((item.Class == MT_MISC12 || item.Class == MT_MEGA) &&
		(botmo.health >= 2 * MAXHEALTH))
		return false;
	if (item.Class == MT_ARMOR_1 && (player->armorpoints >= 100))
		return false;
	if (teamgame.value && item->flags3 & MF3_KEY && !(item->flags & MF_DROPPED))
		return false;
#endif

	// Guess we're okay
	return true;
}

//==========================================================================
//
//	SetEnemy
//
//==========================================================================

void SetEnemy(void)
{
#if 0
	if (terminator.value)
	{
		// If we can see the terminator, go for him no matter what
		for (int i=0; i<MAXPLAYERS; i++)
		{
			if (!GPlayers[i] || GPlayers[i]->MO == bot->player->MO)
				continue;

			if (GPlayers[i]->powers[pw_terminator] &&
				P_CheckSight(bot->player->MO, GPlayers[i]->MO))
				bot->enemy = GPlayers[i]->MO;
		}
	}
#endif

	if (enemy && enemy.Health > 0 && player->MO &&
		player->MO.CanSee(enemy))
	{
		return;
	}

	bAllRound = !!enemy;
	enemy = FindEnemy();

	if (!enemy)
		return;
	
	// Double check the validity of the enemy
	if (!enemy.bShootable)
		enemy = none;
}

//==========================================================================
//
//	CheckTo
//
//	Checks if an location is reachable
//
//==========================================================================

bool CheckTo(TVec pos)
{
	float dist;
	float an;

	dist = Length(botmo.Origin - pos);
	an = GetAngle();

	if (!CheckPath(an, dist))
		return false;
	
	return true;
}

//==========================================================================
//
//	CheckStuff
//
//	Make sure that our destinations/enemies and everything are valid.
//
//==========================================================================

void CheckStuff(void)
{
	if (item)
	{
		if (!item.bSpecial || item.IsDestroyed() || // somebody picked
				!CheckTo(item.Origin)) // Can't reach
			item = none;
	}

	if (missile)
	{
		if (!missile.bMissile || missile.IsDestroyed())
			missile = none;
	}

	if (node)
	{
		if (!CheckTo(node.Origin) || (MobjDist2(botmo, node) < botmo.Radius))
		{
			prev = node;
			node = none;
		}
	}

	if (posdest_valid)
	{
		TVec dir;
		dir = posdest - botmo.Origin;
		dir.z = 0.0;
		if ((Length(dir) < botmo.Radius) || !CheckTo(posdest))
		{
			posdest_valid = false;
		}
	}

	if (lastpos_valid)
	{
		TVec dir;
		dir = lastpos - botmo.Origin;
		dir.z = 0.0;
		if ((Length(dir) < botmo.Radius) || !CheckTo(lastpos))
		{
			lastpos_valid = false;
		}
	}

	if (enemy)
	{
		if (enemy.Health <= 0 || !enemy.bShootable)
			enemy = none;
	}
}

//==========================================================================
//
//	Scan
//
//	Scan all mobj's visible to the bot for incoming missiles, enemies, and
// various items to pick up.
//
//==========================================================================

void Scan(void)
{
	Actor actor;

	FOREACH(Actor, actor)
	{
		if (!actor.bSpecial && !actor.bMissile)
		{
			// Not interested in this one
			continue;
		}
		if (Check_LOS(actor, 90.0))
		{
			// Look for special items
			if (!item && actor.bSpecial)
			{
				if (CheckItem(actor))
				{
					item = actor;
					bItemIsWeapon = bNewItemIsWeapon;
					bItemIsPowerup = bNewItemIsPowerup;
				}
			}
			else if (!missile && actor.bMissile &&
				(MobjDist(botmo, actor) < AVOID_DIST))
			{
				missile = actor;
			}
#if 0
			else if (!bot->node && actor->flags3 & MF3_NODE)// && P_CheckSight(MO, actor, false) && (bot->prev != actor && P_AproxDistance(MO->x - actor->x, MO->y - actor->y) <= 32*FRACUNIT))
			{
				if (actor->Class == MT_BOTPATH || actor->Class == MT_BOTSNIPE)
					bot->node = actor;
				else if (teamgame.value && bot->player->team != TM_NONE)
				{
					if (bot->player->team == TM_BLUE)
					{
						if (bot->state == BST_DEFENSE && ((int)actor->Class == (int)MT_BOTBLUEGUARD))
						{
							bot->node = actor;
						}
						else if (bot->state == BST_OFFENSE && ((int)actor->Class == (int)MT_BOTBLUEPATH))
						{
							bot->node = actor;
						}
						else if (bot->state == BST_RETURN && actor->Class == MT_BOTBLUEGOAL)
						{
							bot->node = actor;
						}
					}
					if (bot->player->team == TM_RED)
					{
						if (bot->state == BST_DEFENSE && ((int)actor->Class == (int)MT_BOTREDGUARD))
	
						{
							bot->node = actor;
						}
						else if (bot->state == BST_OFFENSE && ((int)actor->Class == MT_BOTREDPATH))
						{
							bot->node = actor;
						}
						else if (bot->state == BST_RETURN && ((int)actor->Class == MT_BOTREDGOAL))
						{
							bot->node = actor;
						}
					}
				}
			}
#endif
		}
	}
}

//==========================================================================
//
//	SkillLower
//
//==========================================================================

int SkillLower(int skill, int num)
{
	if (num <= 0)
		return skill;

	skill -= num;
	if (skill < 0)
		skill = 0;

	return skill;
}

//==========================================================================
//
//	SetAngle
//
//==========================================================================

void SetAngle(float an)
{
//	if (t_turn)
//		return;

	angle = AngleMod360(an);

#if 0//Meaningless
	if (!enemy)
		return;

	t_turn = 4;
	return;

	switch (info.accuracy)
	{
	case bsk_verypoor:
	case bsk_poor:
		t_turn = TICRATE;
		break;
	case bsk_low:
		t_turn = (TICRATE*2)/3;
		break;
	case bsk_medium:
		t_turn = TICRATE/2;
		break;
	case bsk_high:
		t_turn = TICRATE/4;
		break;
	case bsk_excellent:
		t_turn = 4;
		break;
	case bsk_supreme:
		break;
	}
#endif
}

//==========================================================================
//
//	GetAngle
//
//==========================================================================

float GetAngle(void)
{
	return angle;
}

//==========================================================================
//
//	WeapFromItem
//
//	Returns a weapon type from an actor
//
//==========================================================================

int WeapFromItem(Actor item)
{
	switch (player->PClass)
	{
	case PCLASS_FIGHTER:
		switch (item.Class)
		{
		case WeaponFAxe:
			return WP_SECOND;
		case WeaponFHammer:
			return WP_THIRD;
		}
		break;
	case PCLASS_CLERIC:
		switch (item.Class)
		{
		case WeaponCSerpentStaff:
			return WP_SECOND;
		case WeaponCFlame:
			return WP_THIRD;
		}
		break;
	case PCLASS_MAGE:
		switch (item.Class)
		{
		case WeaponMCone:
			return WP_SECOND;
		case WeaponMLightning:
			return WP_THIRD;
		}
		break;
	}
	return -1;
}

//==========================================================================
//
//	WeapPieceFromItem
//
//	Returns a weapon type from an actor
//
//==========================================================================

int WeapPieceFromItem(Actor item)
{
	switch (player->PClass)
	{
	case PCLASS_FIGHTER:
		switch (item.Class)
		{
		case WeaponFSwordPiece1:
			return WPIECE1;
		case WeaponFSwordPiece2:
			return WPIECE2;
		case WeaponFSwordPiece3:
			return WPIECE3;
		}
		break;
	case PCLASS_CLERIC:
		switch (item.Class)
		{
		case WeaponCHolyPiece1:
			return WPIECE1;
		case WeaponCHolyPiece2:
			return WPIECE2;
		case WeaponCHolyPiece3:
			return WPIECE3;
		}
		break;
	case PCLASS_MAGE:
		switch (item.Class)
		{
		case WeaponMStaffPiece1:
			return WPIECE1;
		case WeaponMStaffPiece2:
			return WPIECE2;
		case WeaponMStaffPiece3:
			return WPIECE3;
		}
		break;
	}
	return -1;
}

//==========================================================================
//
//	ManaFromItem
//
//
// Returns an mana type from an actor
//
//==========================================================================

int ManaFromItem(Actor item)
{
	switch (item.Class)
	{
	case ItemManaBlue:
		return MANA_1;
	case ItemManaGreen:
		return MANA_2;
	case ItemManaCombined:
		return MANA_BOTH;
	}
	return -1;
}

//==========================================================================
//
//	CheckPath
//
//	Checks for obstructions at a certain angle and distance. Returns true if
// the path is clear, and false is the path is blocked.
//
//==========================================================================

bool CheckPath(float ang, float dist)
{
	float x1, y1, x2, y2;

	bottracerange = dist;
	bottracedir.x = cos(ang);
	bottracedir.y = sin(ang);
	bottracedir.z = 0.0;
	x1 = botmo.Origin.x;
	y1 = botmo.Origin.y;
 	x2 = x1 + dist * bottracedir.x;
 	y2 = y1 + dist * bottracedir.y;
	usething = botmo;

	P_UseLines(player);

	if (!P_PathTraverse(x1, y1, x2, y2, PT_ADDLINES, 'PTR_BotPathTraverse'))
		return false;
	else
		return true;
}

//==========================================================================
//
//	Check_LOS
//
//	Doesnt check LOS, checks visibility with a set view angle.
//	B_Checksight checks LOS (straight line)
//
//	Check if mo1 has free line to mo2 and if mo2 is within mo1 viewangle
// (vangle) given with normal degrees. If these conditions are true, the
// function returns true. GOOD TO KNOW is that the players view angle in
// doom is 90 degrees infront.
//
//==========================================================================

bool Check_LOS(Actor to, float vangle)
{
	if (!botmo.CanSee(to))
		return false; // out of sight
	if (vangle == 360.0)
		return true;
	if (vangle == 0.0)
		return false; //Looker seems to be blind.

	return fabs(AngleMod180(AngleTo(to.Origin) - botmo.Angles.yaw)) <=
		vangle / 2.0;
}

//==========================================================================
//
//	BotAim
//
//==========================================================================

void BotAim(void)
{
	float dist;
	bool right;
	float an;

	if (!enemy)
		return;

	if (t_react)
		return;

	// Distance to enemy.
	dist = MobjDist2(botmo, enemy);

	right = !!(P_Random() & 1);
	an = AngleTo(enemy.Origin);

	// [BC] Cajun prediction... maybe use this somewhere
	/*
			{
			//Here goes the prediction.
			dist = P_AproxDistance(MO->x - enemy->x, MO->y - enemy->y);
			fixed_t m = (dist/FRACUNIT) / mobjinfo[MT_PLASMA].speed;
			bot->SetAngle(R_PointToAngle2(MO->x,
											MO->y,
											enemy->x + FixedMul (enemy->momx, (m*2*FRACUNIT)),
											enemy->y + FixedMul (enemy->momy, (m*2*FRACUNIT))));
			}
	*/

	// Fix me: Implement botskill, accuracy, and intelligence
	if ((player->PClass == PCLASS_FIGHTER && player->ReadyWeapon >= WP_THIRD) ||
		(player->PClass == PCLASS_CLERIC && player->ReadyWeapon >= WP_SECOND) ||
		(player->PClass == PCLASS_MAGE))
	{
		// Projectile weapons
		switch (info.intelect)
		{
		case bsk_verypoor:
		case bsk_poor:
		case bsk_low:
			// Aim right at the enemy
			SetAngle(an);
			break;
		case bsk_medium:
		case bsk_high:
		case bsk_excellent:
		case bsk_supreme:
			if (right)
				SetAngle(an + Random() * 20.0);
			else
				SetAngle(an - Random() * 20.0);
			break;

		default:
			Error("Unknown bot skill level: %d", info.accuracy);
			return;
		}
	}
	else
	{
		// Instant weapons
		switch (info.accuracy)
		{
		case bsk_verypoor:
			if (right)
				SetAngle(an + Random() * 60.0);
			else
				SetAngle(an - Random() * 60.0);
			break;
		case bsk_poor:
			if (right)
				SetAngle(an + Random() * 45.0);
			else
				SetAngle(an - Random() * 45.0);
			break;
		case bsk_low:
			if (right)
				SetAngle(an + Random() * 30.0);
			else
				SetAngle(an - Random() * 30.0);
			break;
		case bsk_medium:
			if (right)
				SetAngle(an + Random() * 15.0);
			else
				SetAngle(an - Random() * 15.0);
			break;
		case bsk_high:
			SetAngle(an);
			break;
		case bsk_excellent:
			SetAngle(AngleTo(enemy.Origin + enemy.Velocity * 0.1));
			break;
		case bsk_supreme://FIXME
			SetAngle(AngleTo(enemy.Origin + enemy.Velocity * 0.1));
			break;
		default:
			Error("Unknown bot skill level: %d", info.accuracy);
			return;
		}
	}
}

//==========================================================================
//
//	FindEnemy
//
//==========================================================================

Actor FindEnemy(void)
{
	float closest_dist, temp;
	Actor target;
	float vangle;
	int i;

	//Note: It's hard to ambush a bot who is not alone
	if (bAllRound || ally)
		vangle = 360.0;
	else
		vangle = ENEMY_SCAN_FOV;
	bAllRound = false;

#if 0
	// Look for monster enemy
	if (!deathmatch.value && !teamgame.value)
	{
		AActor *actor;
		TThinkerIterator<AActor> iterator;

		while (actor = iterator.Next())
		{
			if (!(actor->flags3 & MF3_ENEMY))
				continue;
			if (!Check_LOS(MO, actor, vangle))
				continue;
			if (!P_CheckSight(MO, actor))
				continue;

			return actor;
		}

		// Didn't find anything...
		return NULL;
	}
#endif

	target = none;
	closest_dist = 99999.0;

	// Search for player enemies
	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (GPlayers[i] /*&& !MO->IsTeammate(GPlayers[i]->MO)*/ &&
			GPlayers[i]->MO.Health > 0 && botmo != GPlayers[i]->MO)
		{
			 //Here's a strange one, when bot is standing still, the CanSee within Check_LOS almost always returns false. tought it should be the same checksight as below but.. (below works) something must be fuckin wierd screded up. 
			if (Check_LOS(GPlayers[i]->MO, vangle))
			{
				if (botmo.CanSee(GPlayers[i]->MO))
				{
					temp = MobjDist(GPlayers[i]->MO, botmo);

#if 0
					//Too dark?
					if (temp > DARK_DIST &&
						GPlayers[i]->MO->subsector->sector->lightlevel < WHATS_DARK &&
						bot->player->powers[pw_infrared])
						continue;
#endif
	
					if (temp < closest_dist)
					{
						closest_dist = temp;
						target = GPlayers[i]->MO;
					}
				}
			}
		}
	}

	return target;
}

//==========================================================================
//
//	Roam
//
//	Handle non-attack/dodging movement
//
//==========================================================================

void Roam(void)
{
	TVec dest;

	if (lastpos_valid)
	{
		TVec dir;

		dir = lastpos - botmo.Origin;
		dir.z = 0.0;
		if (Length(dir) <= 32.0)
		{
			lastpos_valid = false;
		}
	}

	// Order of item response precedence:
	if (goal)
	{
		dest = goal.Origin;
	}
	else if (lastpos_valid)
	{
		dest = lastpos;
	}
	else if (item)
	{
		dest = item.Origin;
	}
	else if (node)
	{
		dest = node.Origin;
	}
	else if (posdest_valid)
	{
		dest = posdest;
	}
	else
	{
		// No target, so just run around until we find something
		int r = P_Random();
		float an = GetAngle();
		float dist;

		for (dist = 256.0; dist >= 64.0; dist -= 64.0)
		{
			if (CheckPath(an, dist))
			{
				posdest_valid = true;
				posdest.x = botmo.Origin.x + dist * cos(an);
				posdest.y = botmo.Origin.y + dist * sin(an);
				posdest.z = botmo.Origin.z;
				SetAngle(an);
				break;
			}

			if (CheckPath(an + 45.0, dist))
			{
				posdest_valid = true;
				posdest.x = botmo.Origin.x + dist * cos(an + 45.0);
				posdest.y = botmo.Origin.y + dist * sin(an + 45.0);
				posdest.z = botmo.Origin.z;
				SetAngle(an + 45.0);
				break;
			}

			// Left is no good, try right
			if (CheckPath(an - 45.0, dist))
			{
				posdest_valid = true;
				posdest.x = botmo.Origin.x + dist * cos(an - 45.0);
				posdest.y = botmo.Origin.y + dist * sin(an - 45.0);
				posdest.z = botmo.Origin.z;
				SetAngle(an - 45.0);
				break;
			}
		}
		if (posdest_valid)
		{
			dest = posdest;
		}
		else
		{
			SetAngle(GetAngle() + 45.0 / 3.0);
			forwardmove = -FORWARDWALK;
			return;
		}
	}

	forwardmove = FORWARDRUN;
	SetAngle(AngleTo(dest));
}

//==========================================================================
//
//	Move
//
//	Main bot movement function. Dodging/attacking movement is also handled
// here
//
//==========================================================================

void Move(float deltaTime)
{
	float dist;
	
	// Worry about missiles above all else
	if (missile)
	{
		if (t_strafe)
		{
			t_strafe -= deltaTime;
			if (!t_strafe)
			{
				// Don't change direction while dodging missiles (that could be bad)
				//bot->sidemove = -bot->sidemove;
				t_strafe = 2.0;
			}
		}

		// Look at the missle and sidestep it
		SetAngle(AngleTo(missile.Origin));
		forwardmove = -FORWARDRUN;
		return;
	}

	// Anticipate a shot: time to dodge!
	if (enemy && t_anticip <= 0.25)
	{
		if (!sidemove)
			sidemove = SIDERUN;

		switch (info.anticip)
		{
		case bsk_verypoor:
			// Deer caught in the headlights
			sidemove = 0.0;
			return;

		case bsk_poor:
			// Always walk right
			sidemove = SIDEWALK;
			break;

		case bsk_low:
			// Always run right
			sidemove = SIDERUN;
			break;

		case bsk_medium:
			// Just switch directions every couple seconds
			if (t_strafe)
			{
				t_strafe -= deltaTime;
				if (t_strafe <= 0.0)
				{
					sidemove = -sidemove;
					t_strafe = 2.0;
				}
			}
			break;

		case bsk_high:
			// Switch directions when we think our opponent will fire
			if (!t_anticip)
				sidemove = -sidemove;
			break;

		case bsk_excellent:
			// Move in a somewhat random direction when we think our opponent will fire
			if (!t_anticip)
			{
				sidemove = Random() < 0.5 ? SIDERUN : -SIDERUN;

				if (Random() < 0.5)
				{
					forwardmove = -FORWARDWALK;
				}
			}
			break;

		case bsk_supreme:
			// What a squirmy little fucker!
			if (!t_anticip)
			{
				switch (P_Random() & 3)
				{
				case 0:
					sidemove = SIDERUN;
					break;
				case 1:
					sidemove = SIDEWALK;
					break;
				case 2:
					sidemove = -SIDERUN;
					break;
				case 3:
					sidemove = -SIDEWALK;
					break;
				}

				switch (P_Random() & 3)
				{
				case 0:
					forwardmove = FORWARDRUN;
					break;
				case 1:
					forwardmove = FORWARDWALK;
					break;
				case 2:
					forwardmove = -FORWARDRUN;
					break;
				case 3:
					forwardmove = -FORWARDWALK;
					break;
				}
			}
			break;

		default:
			Error("Unknown bot skill level: %d", info.anticip);
			return;
		}
	}

	// Now handle attack movement
	if (enemy)
	{
		bool noforward;
		bool noside;
		float an;

		noforward = false;
		noside = false;
		if (!sidemove )
			sidemove = SIDERUN;

		if (t_strafe)
		{
			t_strafe -= deltaTime;
			if (t_strafe <= 0.0)
			{
				sidemove = -sidemove;
				t_strafe = 2.0;
			}
		}

		dist = MobjDist(botmo, enemy);

		// Remember where we saw him last in case he gets away
		lastpos = enemy.Origin;
		lastpos_valid = true;

		// Check if we'd rather pick up something than fight
		if (item)
		{
			if (bItemIsPowerup ||
				(bItemIsWeapon && player->ReadyWeapon == WP_FIRST))
			{
				Roam();
				return;
			}
		}

		an = botmo.Angles.yaw;
		if (sidemove < 0.0)
			an -= 90.0;
		else
			an += 90.0;

		if (!CheckPath(an, 48.0)) // We're blocked, so go the other way!
			sidemove = -sidemove;
/*
		switch (bot->player->ReadyWeapon)
		{
		case wp_supershotgun:

		default:
			if (!B_CheckTo(MO, bot->enemy)
*/

		if (CheckTo(enemy.Origin) && dist >
				combatdist[player->PClass * NUMWEAPONS + player->ReadyWeapon])
			forwardmove = FORWARDRUN;
		else
			forwardmove = -FORWARDRUN;

		return;
	}

#if 0
	// Follow our buddy if we're tagging along
	if (ally)
	{
		float matedist;

		if (t_strafe)
		{
			t_strafe -= deltaTime;
			if (t_strafe)
			{
				sidemove = -sidemove;
				t_strafe = 2.0;
			}
		}

		SetAngle(R_PointToAngle2(MO->x, MO->y, bot->ally->x, bot->ally->y));
		matedist = MobjDist(&botmo, &ally);

		if (matedist > (FRIEND_DIST*2))
			bot->forwardmove = FORWARDRUN;
		else if (matedist > FRIEND_DIST)
			bot->forwardmove = FORWARDWALK;
		else if (matedist < FRIEND_DIST-(FRIEND_DIST/3)) //Got too close, so move away.
			bot->forwardmove = -FORWARDWALK;
		return;
	}
#endif

	if (t_strafe)
	{
		t_strafe -= deltaTime;
		if (t_strafe <= 0.0)
		{
			sidemove = -sidemove;
			t_strafe = 2.0;
		}
	}

	// Roam after an item
	Roam();
}

//==========================================================================
//
//	Attack
//
//==========================================================================

void Attack(void)
{
	// Still reacting to something or we don't have an enemy to fight
	if (t_react || !enemy)
		return;

	// No point in firing if we won't hit them
	if (!Check_LOS(enemy, SHOOTFOV))
		return;

#if 0
	switch (player->ReadyWeapon)
	{
	case wp_gauntlets:
		// Double tap the chaingun for extreme accuracy
		if (info.accuracy == bsk_supreme)
			if (t_fire)
				return;
		break;
	default:
		break;
	}
#endif

	player->Buttons |= BT_ATTACK;
}

//==========================================================================
//
//	Turn
//
//	[BC] Ahh, the new and improved turning...
//
//==========================================================================

void Turn(void)
{
	float distance;

	distance = GetAngle() - botmo.Angles.yaw;

	if (!enemy)
	{
		player->ViewAngles.yaw = GetAngle();
		return;
	}

	// [BC] Don't act crazy while trying to aim
	switch (info.accuracy)
	{
	case bsk_verypoor:
	case bsk_poor:
	case bsk_low:
		if (distance > 7.5)
			distance = 7.5;
		if (distance < -7.5)
			distance = -7.5;
		break;
	case bsk_medium:
		if (distance > 15.0)
			distance = 15.0;
		if (distance < -15.0)
			distance = -15.0;
		break;
	case bsk_high:
		if (distance > 22.5)
			distance = 22.5;
		if (distance < -22.5)
			distance = -22.5;
		break;
	case bsk_excellent:
		if (distance > 30.0)
			distance = 30.0;
		if (distance < -30.0)
			distance = -30.0;
		break;
	case bsk_supreme:
		if (distance > 37.5)
			distance = 37.5;
		if (distance < -37.5)
			distance = -37.5;
		break;
	}
	player->ViewAngles.yaw = AngleMod360(botmo.Angles.yaw + distance);
}

//==========================================================================
//
//	Pitch
//
//==========================================================================

void Pitch(void)
{
	if (enemy)
	{
		TVec dir;
		TAVec ang;

		dir = enemy.Origin - botmo.Origin;
		VectorAngles(&dir, &ang);
		botmo.Angles.pitch = ang.pitch;
	}
	else
	{
		botmo.Angles.pitch = 0.0;
	}
}

//==========================================================================
//
//	Killed
//
//==========================================================================

void Killed(Actor victim)
{
#if 0
	// [BC] Bot taunting
	if ((P_Random() % 100) < info.chatty)
	{
		x = P_Random() % 15;	// 15 death strings possible
		chatline = &chatinfo[info.chatinfo].frag[x];
		t_chat = info.chattime;
	}
#endif
			
	// [BC] Let some anger out
	angerlevel -= 5;
	enemy = none;

	// [BC] Don't need to worry about following him anymore
	lastpos_valid = false;
}

//==========================================================================
//
//	Died
//
//==========================================================================

void Died(Actor killer)
{
#if 0
	int x = P_Random() % 100;

	angerlevel += 10;
	if (angerlevel >= info.threshold)
	{
		if (x < info.pisschance)
		{
			x = P_Random (pr_botchat)%5;	// 5 pissed/frustration strings possible
			bot->chatline = &chatinfo[bot->info.chatinfo].pissed[x];
			bot->t_pissed = 120*TICRATE;
		}
		else
		{
			x = P_Random (pr_botchat)%5;	// 5 pissed/frustration strings possible
			bot->chatline = &chatinfo[bot->info.chatinfo].frustrated[x];
			bot->t_frust = 120*TICRATE;
		}
		bot->t_chat = bot->info.chattime;
		angerlevel = 0;
	}
	else if (x < bot->info.chatty)
	{
		x = P_Random (pr_botchat)%10;	// 10 death strings possible
		bot->chatline = &chatinfo[bot->info.chatinfo].died[x];
		bot->t_chat = bot->info.chattime;
	}
#endif
}

//==========================================================================
//
//	OnBeginPlay
//
//==========================================================================

void OnBeginPlay(void)
{
	int botskill = 2;
	int bottype = 0;
	botinfo_t *binfo;
	int i;

	if (strcmp(ARR2STR(player->Name), ""))
	{
		for (i = 0; i < NUMTOTALBOTS; i++)
		{
			if (!stricmp(botinfo[i].Name, ARR2STR(player->Name)))
			{
				bottype = i;
				break;
			}
		}
		// We've already handled the "what if there's no match" exception
	}
	else
	{
		// If the user doesn't input a name, don't
		// spawn one of the "special" bots, only one of the
		// normal ones.
		bottype = P_Random() % NUMBOTTYPES;
	}

	binfo = &botinfo[bottype];

	t_strafe = 1.0;

	if (botskill > 4)
		botskill = 4;
	if (botskill < 0)
		botskill = 0;

	// Implement skill settings
	info.accuracy = SkillLower(binfo->accuracy, 4 - botskill);
	info.intelect = SkillLower(binfo->intelect, 4 - botskill);
	info.evade = SkillLower(binfo->evade, 4 - botskill);
	info.anticip = SkillLower(binfo->anticip, 4 - botskill);
	info.reaction = SkillLower(binfo->reaction, 4 - botskill);
	strcpy(ARR2STR(player->UserInfo), binfo->userinfo);

	// Setup combat distance tables
	if (deathmatch/* || teamgame.value*/)
	{
		combatdist[WP_FIRST]		= 48.0;
		combatdist[WP_SECOND]		= 48.0;
		combatdist[WP_THIRD]		= 192.0;
		combatdist[WP_FOURTH]		= 256.0;
		combatdist[4 + WP_FIRST]	= 48.0;
		combatdist[4 + WP_SECOND]	= 192.0;
		combatdist[4 + WP_THIRD]	= 256.0;
		combatdist[4 + WP_FOURTH]	= 384.0;
		combatdist[8 + WP_FIRST]	= 192.0;
		combatdist[8 + WP_SECOND]	= 256.0;
		combatdist[8 + WP_THIRD]	= 384.0;
		combatdist[8 + WP_FOURTH]	= 384.0;
	}
	else
	{
		combatdist[WP_FIRST]		= 48.0;
		combatdist[WP_SECOND]		= 48.0;
		combatdist[WP_THIRD]		= 192.0 / 2.0;
		combatdist[WP_FOURTH]		= 256.0 / 2.0;
		combatdist[4 + WP_FIRST]	= 48.0;
		combatdist[4 + WP_SECOND]	= 192.0 / 2.0;
		combatdist[4 + WP_THIRD]	= 256.0 / 2.0;
		combatdist[4 + WP_FOURTH]	= 384.0 / 2.0;
		combatdist[8 + WP_FIRST]	= 192.0 / 2.0;
		combatdist[8 + WP_SECOND]	= 256.0 / 2.0;
		combatdist[8 + WP_THIRD]	= 384.0 / 2.0;
		combatdist[8 + WP_FOURTH]	= 384.0 / 2.0;
	}
}

//==========================================================================
//
//	OnSpawn
//
//==========================================================================

void OnSpawn(void)
{
}

defaultproperties
{
}
    
//**************************************************************************
//
//  $Log$
//  Revision 1.2  2003/07/11 16:47:39  dj_jl
//  Made array of players with pointers
//
//  Revision 1.1  2002/10/26 16:32:26  dj_jl
//  New style of defining classes.
//
//**************************************************************************
