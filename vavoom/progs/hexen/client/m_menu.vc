//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define MAX_MENU_ITEMS		32

#define MAX_MENU_STACK		32

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

class MenuObject;
class MenuScreen;

typedef void (*menufunc_t) (void);

// FUNCTION PROTOTYPES -----------------------------------------------------

void PopMenu(void);

// DATA DECLARATIONS -------------------------------------------------------

MenuScreen menu_stack[MAX_MENU_STACK];
int menu_sp;

MenuScreen CurrentMenuScreen;

float MenuTime;

// CODE --------------------------------------------------------------------

//**************************************************************************
//**
//**	MenuObject
//**
//**************************************************************************

class MenuObject:Object
{
	int X;
	int Y;
	int Width;
	int Height;
	MenuObject Parent;
	boolean bSelected;
	boolean bHidden;
	boolean bDisabled;

	void Init(void)
	{
	}

	void SetPos(int NewX, int NewY)
	{
		X = NewX;
		Y = NewY;
	}
	int GetX(void)
	{
		return X;
	}
	int GetY(void)
	{
		return Y;
	}

	void Draw(void)
	{
	}

	boolean Key(int key)
	{
		return false;
	}

	boolean IsVisible(void)
	{
		return !bHidden;
	}

	boolean IsDisabled(void)
	{
		return bDisabled;
	}

	void Destroyed(void)
	{
	}

	void FocusLost(void)
	{
	}

	void FocusReceived(void)
	{
	}

	void Show(void)
	{
		bHidden = false;
	}

	void Hide(void)
	{
		bHidden = true;
	}

	defaultproperties
	{
		bSelected = false;
		bHidden = false;
		bDisabled = true;
	}
}

//**************************************************************************
//**
//**	MenuChoice
//**
//**************************************************************************

class MenuChoice:MenuObject
{
	defaultproperties
	{
		bDisabled = false;
	}
}

//**************************************************************************
//**
//**	MenuTitleText
//**
//**************************************************************************

class MenuTitleText:MenuObject
{
	string Text;

	void Draw(void)
	{
		T_SetFont(font_big);
		T_SetAlign(hcenter, vbottom);
		T_DrawText(X, Y, Text);
	}

	defaultproperties
	{
	}
}

//**************************************************************************
//**
//**	MenuScreen
//**
//**************************************************************************

class MenuScreen:MenuObject
{
	MenuObject Items[MAX_MENU_ITEMS];
	int NumItems;
	int CursorPos;
	int CursorPrev;

	classid Choices[MAX_MENU_ITEMS];
	int ChoicesStartX;
	int ChoicesStartY;

	classid SelectorType;
	MenuObject Selector;

	string Title;
	int TitleX;
	int TitleY;

	MenuObject AddItem(classid type)
	{
		MenuObject item;

		if (NumItems >= MAX_MENU_ITEMS)
		{
			FatalError("Too many menu items");
		}
		item = Spawn(type, self);
		Items[NumItems++] = item;
		item.Parent = self;
		item.Init();
		return item;
	}

	void CreateTitle(void)
	{
		MenuTitleText newTitle;

		if (Title && Title != "")
		{
			newTitle = MenuTitleText(AddItem(MenuTitleText));
			newTitle.SetPos(TitleX, TitleY);
			newTitle.Text = Title;
		}
	}

	void CreateChoices(void)
	{
		MenuChoice newChoice;
		int currentY;
		int i;

		currentY = ChoicesStartY;
		for (i = 0; i < MAX_MENU_ITEMS; i++)
		{
			if (Choices[i] && Choices[i] != classidNone)
			{
				newChoice = MenuChoice(AddItem(Choices[i]));
				newChoice.SetPos(ChoicesStartX, currentY);
				currentY += newChoice.Height;
			}
		}
	}

	void CreateSelector(void)
	{
		if (SelectorType && SelectorType != classidNone)
		{
			Selector = AddItem(SelectorType);
		}
	}

	void CursorMoved(void)
	{
		if (CursorPrev == CursorPos)
			return;

		if (CursorPrev >= 0 && CursorPrev < NumItems)
		{
			Items[CursorPrev].FocusLost();
			Items[CursorPrev].bSelected = false;
		}

		if (CursorPos >= 0 && CursorPos < NumItems)
		{
			Items[CursorPos].FocusReceived();
			Items[CursorPos].bSelected = true;
		}

		if (Selector)
		{
			Selector.SetPos(Items[CursorPos].GetX(), Items[CursorPos].GetY());
		}
	}

	void SetDefaultChoice(void)
	{
		int i;

		// default cursor position
		CursorPos = 0;
		CursorPrev = 0;

		// force first available item to have focus
		for (i = 0; i < NumItems; i++)
		{
			if (!Items[i].IsDisabled())
			{
				CursorPrev = -1;
				CursorPos = i;
				CursorMoved();
				break;
			}
		}
	}

	void Init(void)
	{
		::Init();
		CreateTitle();
		CreateChoices();
		CreateSelector();
		SetDefaultChoice();
	}

	void SetCursor(int cursor)
	{
		if (Items[cursor].IsDisabled())
		{
			// cursor can't go there
			return;
		}

		CursorPrev = CursorPos;
		CursorPos = cursor;

		CursorMoved();
	}

	boolean Key(int key)
	{
		if (Items[CursorPos].Key(key))
		{
			return true;
		}

		switch (key)
		{
		case K_DOWNARROW:
			CursorPrev = CursorPos;
			do
			{
				if (CursorPos == NumItems - 1)
					CursorPos = 0;
				else
					CursorPos++;
			}
			while (Items[CursorPos].IsDisabled() && CursorPrev != CursorPos);
			CursorMoved();
			LocalSound('MenuMove');
			return true;

		case K_UPARROW:
			CursorPrev = CursorPos;
			do
			{
				if (!CursorPos)
					CursorPos = NumItems - 1;
				else
					CursorPos--;
			}
			while (Items[CursorPos].IsDisabled() && CursorPrev != CursorPos);
			CursorMoved();
			LocalSound('MenuMove');
			return true;

		case K_ESCAPE:
		case K_MOUSE2:
			PopMenu();
			return true;
		}

		return false;
	}

	void Draw(void)
	{
		int i;

		for (i = 0; i < NumItems; i++)
		{
			if (Items[i].IsVisible())
			{
				Items[i].Draw();
			}
		}
	}

	void Destroy(void)
	{
		int i;

		for (i = 0; i < MAX_MENU_ITEMS; i++)
		{
			if (Items[i] != none)
			{
				Items[i].Destroyed();
				Items[i].Destroy();
			}
		}
		::Destroy();
	}

	defaultproperties
	{
		TitleX = 160;
		TitleY = 24;
	}
}

//**************************************************************************
//**
//**
//**
//**************************************************************************

//==========================================================================
//
//	InputLine_Init
//
//  Initializes input line
//
//==========================================================================

void InputLine_Init(TILine * iline)
{
    iline->len = 0;
    strsetchar(ARR2STR(iline->Data), 0, 0);
}

//==========================================================================
//
//	InputLine_Key
//
// 	Wrapper function for handling general keyed input.
//	Returns true if it ate the key
//
//==========================================================================

boolean InputLine_Key(TILine * iline, int ch)
{
    if (ch >= 32 && ch < 128)
	{
  		ch = TranslateKey(ch);
	    if (iline->len < MAX_ILINE_LENGTH)
    	{
			strsetchar(ARR2STR(iline->Data), iline->len++, ch);
			strsetchar(ARR2STR(iline->Data), iline->len, 0);
    	}
	}
    else if (ch == K_BACKSPACE)
	{
	    if (iline->len)
		{
			strsetchar(ARR2STR(iline->Data), --iline->len, 0);
		}
	}
	else if (ch != K_ENTER)
	{
		return false; // did not eat key
	}
    return true; // ate the key
}

//==========================================================================
//
//	InputLine_SetValue
//
//  Sets input line value
//
//==========================================================================

void InputLine_SetValue(TILine * iline, string text)
{
	strcpy(ARR2STR(iline->Data), text);
	iline->len = strlen(text);
}

//==========================================================================
//
//  SpawnMenu
//
//==========================================================================

MenuScreen SpawnMenu(classid CID)
{
	MenuScreen S = Spawn(CID, none);
	S.Init();
	return S;
}

//**************************************************************************
//**
//**    Menu stack handling
//**
//**************************************************************************

//==========================================================================
//
//  PushMenuScreen
//
//==========================================================================

void PushMenuScreen(MenuScreen menu)
{
	int i;

	// avoid stacking menus invoked by hotkeys
	for (i = 0; i < menu_sp; i++)
	{
		if (menu_stack[i].Class == menu.Class)
		{
			int j;

			for (j = i; j < menu_sp; j++)
			{
				menu_stack[j].Destroy();
			}
			menu_sp = i;
			break;
		}
	}

	if (menu_sp >= MAX_MENU_STACK)
		FatalError("PushMenu: menu stack overflow");

	menu_stack[menu_sp++] = menu;

	if (!CurrentMenuScreen)
	{
		MenuTime = 0.0;
/*		if (cl.paused)
		{
			S_ResumeSound();
		}
		C_ClearNotify();*/
		CmdBuf_AddText("HideConsole\n");
		LocalSound('MenuActivate');
	}

	CurrentMenuScreen = menu;
}

//==========================================================================
//
//  PopMenu
//
//==========================================================================

void PopMenu(void)
{
	menu_sp--;

	if (menu_sp < 0)
		FatalError("PopMenu: menu stack underflow");

	menu_stack[menu_sp].Destroy();
	if (menu_sp)
	{
		CurrentMenuScreen = menu_stack[menu_sp - 1];
		LocalSound('MenuPrevious');
	}
	else
	{
		CurrentMenuScreen = none;
		LocalSound('MenuClose');
	}
}

//==========================================================================
//
//  ForceMenuOff
//
//==========================================================================

void ForceMenuOff(void)
{
	int i;

	for (i = 0; i < menu_sp; i++)
	{
		menu_stack[i].Destroy();
	}
	menu_sp = 0;
	CurrentMenuScreen = none;
}

//**************************************************************************
//**
//**    MenuStaticBitmap
//**
//**************************************************************************

class MenuStaticBitmap:MenuObject
{
	string PicName;
	int PicType;
	int Handle;

	void Init(void)
	{
		if (PicName)
		{
			Handle = R_RegisterPic(PicName, PicType);
		}
	}

	void Draw(void)
	{
		R_DrawPic(X, Y, Handle);
	}

	defaultproperties
	{
		PicType = PIC_PATCH;
	}
}

//**************************************************************************
//**
//**	MenuStaticAnim
//**
//**************************************************************************

class MenuStaticAnim:MenuObject
{
	int Speed;
	int NumFrames;
	int StartFrame;
	boolean bBackwards;
	int Frames[32];
	string FrameNames[32];

	void Init(void)
	{
		int i;

		::Init();

		NumFrames = 0;
		for (i = 0; i < 32; i++)
		{
			if (FrameNames[i] && FrameNames[i] != "")
			{
				Frames[NumFrames] = R_RegisterPic(FrameNames[i], PIC_PATCH);
				NumFrames++;
			}
		}
	}

	void Draw(void)
	{
		int frame = (ftoi(MenuTime * itof(Speed)) + StartFrame) % NumFrames;
		if (bBackwards)
		{
			frame = NumFrames - frame - 1;
		}
		R_DrawPic(X, Y, Frames[frame]);
	}

	defaultproperties
	{
	}
}

//**************************************************************************
//**
//**	MenuSpriteAnim
//**
//**************************************************************************

class MenuSpriteAnim:MenuObject
{
	int SprDef;
	int Speed;
	int NumFrames;
	int Translation;

	void Draw(void)
	{
		int frame = ftoi(MenuTime * itof(Speed)) % NumFrames;

		R_DrawSpritePatch(X, Y, SprDef, frame, 0, Translation);
	}

	defaultproperties
	{
	}
}

//**************************************************************************
//**    
//**	MenuSelector_BigArrow
//**    
//**************************************************************************

#define SELECTOR_XOFFSET	(-28)
#define SELECTOR_YOFFSET	(-1)

class MenuSelector_BigArrow:MenuObject
{
	int selector_pics[2];

	void Init(void)
	{
		::Init();
		selector_pics[0] = R_RegisterPic("M_SLCTR1", PIC_PATCH);
		selector_pics[1] = R_RegisterPic("M_SLCTR2", PIC_PATCH);
	}

	void Draw(void)
	{
		R_DrawPic(X + SELECTOR_XOFFSET, Y + SELECTOR_YOFFSET,
			selector_pics[ftoi(MenuTime * 2.0) & 1]);
	}

	defaultproperties
	{
	}
}

//**************************************************************************
//**    
//**	MenuSelector_SmallLeft
//**    
//**************************************************************************

class MenuSelector_SmallLeft:MenuObject
{
	void Draw(void)
	{
		T_SetFont(font_small);
		T_SetAlign(hright, vtop);
		T_DrawText(X - 2, Y, ">");
	}

	defaultproperties
	{
	}
}

//**************************************************************************
//**    
//**	MenuSelector_SmallRight
//**    
//**************************************************************************

class MenuSelector_SmallRight:MenuObject
{
	void Draw(void)
	{
		T_SetFont(font_small);
		T_SetAlign(hleft, vtop);
		T_DrawText(X + 2, Y, ">");
	}

	defaultproperties
	{
	}
}

//**************************************************************************
//**
//**	MenuTextButton
//**
//**************************************************************************

class MenuTextButton:MenuChoice
{
	name ActivateSound;
	string Text;
	int TextFont;
	int TextSelectedFont;
	int TextHAlign;
	int TextVAlign;

	defaultproperties
	{
		ActivateSound = 'MenuSelect';
	}

	void ActivateEvent(void)
	{
	}

	boolean Key(int key)
	{
		if (key == K_ENTER || key == K_MOUSE1 || key == K_JOY1)
		{
			ActivateEvent();
			LocalSound(ActivateSound);
			return true;
		}
		return false;
	}

	void Draw(void)
	{
		T_SetFont(bSelected ? TextSelectedFont : TextFont);
		T_SetAlign(TextHAlign, TextVAlign);
		T_DrawText(X, Y, Text);
	}
}

//**************************************************************************
//**
//**	MenuBigTextButton
//**
//**************************************************************************

class MenuBigTextButton:MenuTextButton
{
	defaultproperties
	{
		TextFont = font_big;
		TextSelectedFont = font_big;
		TextHAlign = hleft;
		TextVAlign = vtop;
		Height = 18;
	}
}

//**************************************************************************
//**
//**	MenuSmallTextButton
//**
//**************************************************************************

class MenuSmallTextButton:MenuTextButton
{
	defaultproperties
	{
		TextFont = font_small;
		TextSelectedFont = font_yellow;
		TextHAlign = hright;
		TextVAlign = vtop;
		Height = 10;
	}
}

//**************************************************************************
//**
//**	MenuChoiceEnum
//**
//**************************************************************************

class MenuChoiceEnum:MenuChoice
{
	string Text;
	boolean bLeftAlign;

	int Value;
	int MaxValue;
	string EnumNames[32];

	int GetInitialValue(void)
	{
		return 0;
	}

	boolean SetNewValue(int newValue)
	{
		return true;
	}

	void Init(void)
	{
		int i;

		MaxValue = 0;
		for (i = 0; i < 32; i++)
		{
			if (EnumNames[i] && EnumNames[i] != "")
			{
				MaxValue++;
			}
		}

		Value = GetInitialValue();
		if (Value < 0)
			Value = 0;
		if (Value >= MaxValue)
			Value = MaxValue - 1;
	}

	void Draw(void)
	{
		int xx;

		T_SetFont(font_small);
		if (bSelected)
		{
			T_SetFont(font_yellow);
		}
		if (bLeftAlign)
		{
			T_SetAlign(hleft, vtop);
		}
		else
		{
			T_SetAlign(hright, vtop);
		}
		T_DrawText(X, Y, Text);

		xx = X;
		if (bLeftAlign)
		{
			xx += T_TextWidth(Text) + 8;
		}
		else
		{
			xx += 10;
		}
		T_SetAlign(hleft, vtop);
		T_DrawText(xx, Y, EnumNames[Value]);
	}

	boolean Key(int key)
	{
		int newValue;

		switch (key)
		{
		case K_LEFTARROW:
			if (Value > 0)
				newValue = Value - 1;
			else
				newValue = MaxValue - 1;
			if (SetNewValue(newValue))
			{
				Value = newValue;
				LocalSound('MenuSwitch');
			}
			return true;
		case K_RIGHTARROW:
		case K_ENTER:
		case K_MOUSE1:
			if (Value < MaxValue - 1)
				newValue = Value + 1;
			else
				newValue = 0;
			if (SetNewValue(newValue))
			{
				Value = newValue;
				LocalSound('MenuSwitch');
			}
			return true;
		}
		return false;
	}

	defaultproperties
	{
		Height = 10;
	}
}

//**************************************************************************
//**
//**	MenuChoice_OnOff
//**
//**************************************************************************

class MenuChoice_OnOff:MenuChoiceEnum
{
	defaultproperties
	{
		EnumNames[0] = "Off";
		EnumNames[1] = "On";
	}
}

//**************************************************************************
//**
//**	MenuChoiceSlider
//**
//**************************************************************************

class MenuChoiceSlider:MenuChoice
{
	string Text;

	float Value;
	float ValueDelta;
	float MinValue;
	float MaxValue;

	int pic_M_SLDLT;
	int pic_M_SLDMD1;
	int pic_M_SLDMD2;
	int pic_M_SLDRT;
	int pic_M_SLDKB;

	float GetInitialValue(void)
	{
		return 0.0;
	}

	boolean SetNewValue(float newValue)
	{
		return true;
	}

	void Init(void)
	{
		::Init();

		Value = GetInitialValue();
		if (Value < MinValue)
			Value = MinValue;
		if (Value > MaxValue)
			Value = MaxValue;

		pic_M_SLDLT = R_RegisterPic("M_SLDLT", PIC_PATCH);
		pic_M_SLDMD1 = R_RegisterPic("M_SLDMD1", PIC_PATCH);
		pic_M_SLDMD2 = R_RegisterPic("M_SLDMD2", PIC_PATCH);
		pic_M_SLDRT = R_RegisterPic("M_SLDRT", PIC_PATCH);
		pic_M_SLDKB = R_RegisterPic("M_SLDKB", PIC_PATCH);
	}

	void Draw(void)
	{
		int i;
		int xx;

		T_SetFont(font_small);
		if (bSelected)
		{
			T_SetFont(font_yellow);
		}
		T_SetAlign(hright, vtop);
		T_DrawText(X, Y, Text);

		xx = X;
		R_DrawPic(xx, Y, pic_M_SLDLT);
		xx += 32;
		for (i = 0; i < 12; i++)
		{
			R_DrawPic(xx, Y, i & 1 ? pic_M_SLDMD1 : pic_M_SLDMD2);
			xx += 8;
		}
		R_DrawPic(xx, Y, pic_M_SLDRT);
		xx = X + 30 + ftoi((Value - MinValue) * 100.0 / (MaxValue - MinValue));
		R_DrawPic(xx, Y + 7, pic_M_SLDKB);
	}

	boolean Key(int key)
	{
		float newValue;

		switch (key)
		{
		case K_LEFTARROW:
			newValue = Value - ValueDelta;
			if (newValue < MinValue)
			{
				newValue = MinValue;
			}
			if (SetNewValue(newValue))
			{
				Value = newValue;
				LocalSound('MenuSwitch');
			}
			return true;

		case K_RIGHTARROW:
			newValue = Value + ValueDelta;
			if (newValue > MaxValue)
			{
				newValue = MaxValue;
			}
			if (SetNewValue(newValue))
			{
				Value = newValue;
				LocalSound('MenuSwitch');
			}
			return true;
		}
		return ::Key(key);
	}

	defaultproperties
	{
		Height = 20;
		Value = 0.0;
		ValueDelta = 1.0;
		MinValue = 0.0;
		MaxValue = 1.0;
	}
}

//**************************************************************************
//**
//**	Slot for saves and input lines
//**
//**************************************************************************

int pic_M_FSLOT;

//==========================================================================
//
//  DrawSlot
//
//==========================================================================

int DrawSlot(int x, int y, string text, boolean entering)
{
	int xx;
	int j;

	R_DrawPic(x, y, pic_M_FSLOT);

	T_SetFont(font_small);
	T_SetAlign(hleft, vtop);
	T_DrawText(x + 5, y + 5, text);
	if (entering)
	{
		T_DrawCursor();
	}
	return 20;
}

//==========================================================================
//
//  InitSlot
//
//==========================================================================

void InitSlot(void)
{
	pic_M_FSLOT = R_RegisterPic("M_FSLOT", PIC_PATCH);
}

//**************************************************************************
//**
//**	MenuSaveSlot
//**
//**************************************************************************

#define SLOTTEXTLEN 		24

boolean enteringText;
TILine slot_enter_text;

class MenuSaveSlot:MenuChoice
{
	int Status;
	int Text[(SLOTTEXTLEN + 4) / 4];
	int SlotNum;

	void Init(void)
	{
		::Init();
		InitSlot();
	}

	void Draw(void)
	{
		if (enteringText && bSelected)
		{
			DrawSlot(X, Y, ARR2STR(slot_enter_text.Data), true);
		}
		else
		{
			DrawSlot(X, Y, ARR2STR(Text), false);
		}
	}

	void ActivateSlot(void)
	{
	}

	boolean Key(int key)
	{
		if (enteringText)
		{
			// Save Game string input
			switch (key)
			{
			case K_ESCAPE:
			case K_MOUSE2:
				enteringText = false;
				break;

			case K_ENTER:
			case K_MOUSE1:
				enteringText = false;
				if (slot_enter_text.Data[0])
				{
					strcpy(ARR2STR(Text), ARR2STR(slot_enter_text.Data));
					CmdBuf_AddText("Save %d \"%s\"\n", SlotNum,
						ARR2STR(Text));
					ForceMenuOff();
				}
				break;

			default:
				InputLine_Key(&slot_enter_text, key);
				if (slot_enter_text.len >= SLOTTEXTLEN - 1)
				{
					InputLine_Key(&slot_enter_text, K_BACKSPACE);
				}
				break;
			}
			return true;
		}

		if (key == K_ENTER || key == K_MOUSE1 || key == K_JOY1)
		{
			ActivateSlot();
			return true;
		}
		return false;
	}

	defaultproperties
	{
	}
}

//**************************************************************************
//**
//**	MenuInputLine
//**
//**************************************************************************

class MenuInputLine:MenuChoice
{
	string Text;
	int Value[32 / 4];

	void Init(void)
	{
		::Init();
		InitSlot();
	}

	void ValueChanged(void)
	{
	}

	void Draw(void)
	{
		T_SetFont(font_small);
		T_SetAlign(hleft, vtop);
		T_DrawText(X, Y, Text);
		if (enteringText)
			DrawSlot(X, Y + 12, ARR2STR(slot_enter_text.Data), true);
		else
			DrawSlot(X, Y + 12, ARR2STR(Value), false);
	}

	boolean Key(int key)
	{
		if (enteringText)
		{
			switch (key)
			{
			case K_ESCAPE:
			case K_MOUSE2:
				enteringText = false;
				break;

			case K_ENTER:
			case K_MOUSE1:
				enteringText = false;
				strcpy(ARR2STR(Value), ARR2STR(slot_enter_text.Data));
				ValueChanged();
				break;

			default:
				InputLine_Key(&slot_enter_text, key);
				if (slot_enter_text.len >= 30)
				{
					InputLine_Key(&slot_enter_text, K_BACKSPACE);
				}
				break;
			}
			return true;
		}

		if (key == K_ENTER || key == K_MOUSE1 || key == K_JOY1)
		{
			// we are going to be intercepting all chars
			enteringText = true;
			InputLine_Init(&slot_enter_text);
			LocalSound('MenuSelect');
			InputLine_SetValue(&slot_enter_text, ARR2STR(Value));
			return true;
		}
		return false;
	}

	defaultproperties
	{
		Height = 30;
	}
}

//**************************************************************************
//**
//**	MenuSList
//**
//**************************************************************************

class MenuSList:MenuChoice
{
	int Cursor;
	slist_t* slist;

	void Init(void)
	{
		::Init();
		StartSearch();
	}

	void DrawTextBox(string text)
	{
		int x;
		int y;
		int w;
		int h;

		// Horiz. & Vertically center string and print it.
		T_SetFont(font_small);
		T_SetAlign(hcenter, vcenter);

		w = (T_TextWidth(text) + 16) & ~15;
		h = (T_TextHeight(text) + 16) & ~15;
		if (w > 304)
			w = 304;
		if (h > 184)
			h = 184;
		x = (320 - w) / 2;
		y = (200 - h) / 2;

		R_FillRectWithFlat(x, y, w, h, "F_019");
		DrawBorder(x, y, w, h);

		T_DrawText(160, 100, text);
	}

	void Draw(void)
	{
		int i;
		int x;
		int y;
		int w;

		slist = GetSlist();

		T_SetFont(font_small);
		T_SetAlign(hleft, vtop);
		for (i = 0; i < slist->count; i++)
		{
			T_DrawText(16, 32 + 10 * i, ARR2STR(slist->cache[i].Name));
			T_DrawText(16 + 128, 32 + 10 * i, ARR2STR(slist->cache[i].map));
			if (slist->cache[i].maxusers)
			{
				T_DrawText(16 + 256, 32 + 10 * i, va("%d/%d",
					slist->cache[i].users, slist->cache[i].maxusers));
			}
		}
		T_DrawText(8, 32 + Cursor * 10, ">");

		if (slist->return_reason[0])
			T_DrawText(16, 116, ARR2STR(slist->return_reason));

		if (slist->count)
		{
			x = 8;
			y = 124;
			for (i = 0; i < 20 && slist->cache[Cursor].wadfiles[i][0]; i++)
			{
				w = T_TextWidth(ARR2STR(slist->cache[Cursor].wadfiles[i]));
				if (x + w > 312)
				{
					x = 8;
					y += 9;
					if (y > 190)
						break;
				}
				T_DrawText(x, y, ARR2STR(slist->cache[Cursor].wadfiles[i]));
				x += w + 8;
			}
		}

		if (slist->inProgress)
		{
			DrawTextBox("Searching...");
		}
		else if (!slist->count)
		{
			DrawTextBox("No servers found");
		}
	}

	boolean Key(int key)
	{
		slist = GetSlist();

		if (slist->inProgress)
		{
			return true;
		}

		switch (key)
		{
		case K_DOWNARROW:
			if (slist->count)
			{
				Cursor++;
				if (Cursor >= slist->count)
					Cursor = 0;
				LocalSound('MenuMove');
			}
			return true;

		case K_UPARROW:
			if (slist->count)
			{
				Cursor--;
				if (Cursor < 0)
					Cursor = slist->count - 1;
				LocalSound('MenuMove');
			}
			return true;

		case K_ENTER:
			if (slist->count)
			{
				LocalSound('MenuSelect');
				CmdBuf_AddText("connect \"%s\"\n",
					slist->cache[Cursor].cname);
			}
			return true;

		case K_SPACE:
			Cursor = 0;
			StartSearch();
			return true;
		}
		return false;
	}

	defaultproperties
	{
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.18  2002/02/26 17:46:50  dj_jl
//  Fixes for menus.
//
//  Revision 1.17  2002/02/06 17:22:18  dj_jl
//  Some fixes for the menus.
//
//  Revision 1.16  2002/01/28 18:46:20  dj_jl
//  Some fixes, beautification
//
//  Revision 1.15  2002/01/23 17:54:23  dj_jl
//  Object-oriented menus, got rid of C-style type casting.
//
//  Revision 1.14  2002/01/21 18:21:33  dj_jl
//  Working on object-oriented menus
//
//  Revision 1.13  2002/01/11 18:19:41  dj_jl
//  Started to use names in progs
//
//  Revision 1.12  2002/01/11 08:03:13  dj_jl
//  Renamed 'name' to "Name'
//
//  Revision 1.11  2002/01/07 12:25:57  dj_jl
//  Changed copyright year
//
//  Revision 1.10  2001/12/12 19:14:11  dj_jl
//  Removed support for ASCII character constants
//
//  Revision 1.9  2001/12/04 18:22:08  dj_jl
//  Reworking menus
//
//  Revision 1.8  2001/12/01 18:04:24  dj_jl
//  Started reworking menus
//
//  Revision 1.7  2001/11/09 14:38:45  dj_jl
//  Moved input line to progs
//
//  Revision 1.6  2001/10/08 17:22:12  dj_jl
//  Changed slist to be returned by engine
//
//  Revision 1.5  2001/09/25 17:11:04  dj_jl
//  Seperated menu API
//
//  Revision 1.4  2001/09/24 17:24:10  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/29 17:46:25  dj_jl
//  Moved view border and message box to progs
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
