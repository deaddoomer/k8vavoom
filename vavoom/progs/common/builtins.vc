//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

//==========================================================================
//
//              COMMON BUILTINS
//
//==========================================================================

//
//  Error functions
//

//  Shut down client and server, go to title
extern void Error(string format, ...);

//  Exit programm with error
extern void FatalError(string format, ...);

//
//  Cvar functions
//

//  Create a new cvar
extern void CreateCvar(string name, string default_value, int flags);

//  Read value
extern int GetCvar(string name);

//  Set cvar value
extern void SetCvar(string name, int value);

//  Read float value
extern float GetCvarF(string name);

//  Set cvar float value
extern void SetCvarF(string name, float value);

//  Read string value
extern string GetCvarS(string name);

//  Set cvar string value
extern void SetCvarS(string name, string value);

//
//  Math functions
//

//  Normalizes angle in range 0..360
extern float AngleMod360(float angle);

//  Normalizes angle in range -180..180
extern float AngleMod180(float angle);

//  Sine
extern float sin(float angle);

//  Cosine
extern float cos(float angle);

//  Tangent
extern float tan(float angle);

//  Arctangent
extern float atan(float slope);

//  Arctangent
extern float atan2(float y, float x);

//  Vector length
extern float Length(TVec vec);

//  Normalizes vector
extern TVec Normalize(TVec vec);

//  Dot product
extern float DotProduct(TVec v1, TVec v2);

//  Cross product (perpendicular vector)
extern TVec CrossProduct(TVec v1, TVec v2);

//  Creates vectors for given angle vector
extern void AngleVectors(TAVec * angles, TVec * forward, TVec * right,
	TVec * up);

//  Simplified version of AngleVectors, creates only forward vector
extern void AngleVector(TAVec * angles, TVec * forward);

//  Create angle vector for a vector
extern void VectorAngles(TVec * vec, TAVec * angles);

//
//  Random numbers
//

//  Floating random number 0.0 ... 0.999999
extern float Random(void);

//  Integer random number 1 .. 255
extern int P_Random(void);

//
//  String functions
//

//  Pointer to string hack
extern string ptrtos(void *ptr);
#define ARR2STR(array)	ptrtos(&array[0])

//  Get char s[i]
extern int strgetchar(string s, int i);

//  Set char s[i]
extern void strsetchar(string s, int i, int c);

//  String length
extern int strlen(string s);

//  Compare strings
extern int strcmp(string s1, string s2);

//  Compare strings ingnoring case
extern int stricmp(string s1, string s2);

//  Copy string
extern void strcpy(string s1, string s2);

//  Clear string
extern void strclr(string s);

//  Append string to string
extern void strcat(string s1, string s2);

//  Print into a string
extern void sprint(string dest, string format, ...);

//  Does varargs print into a temporary buffer
extern string va(string format, ...);

//  Converts string to integer
extern int atoi(string str);

//  Converts string to float
extern float atof(string str);

//
//  Printing to console
//

//  Print to console
extern void print(string format, ...);

//  Print to console only when developer == 1
extern void dprint(string format, ...);

//
//  Texture / flat number retrieval
//

extern int CheckTextureNumForName(string name);
extern int TextureNumForName(string name);
extern int CheckFlatNumForName(string name);
extern int FlatNumForName(string name);
extern float TextureHeight(int pic);

//
//  Message IO functions
//

#ifdef SERVER
extern void MSG_Select(int msgtype, player_t * client);
#else
extern void MSG_Select(int msgtype, void *client);
#endif
extern void MSG_WriteByte(int data);
extern void MSG_WriteShort(int data);
extern void MSG_WriteLong(int data);
extern int MSG_ReadChar(void);
extern int MSG_ReadByte(void);
extern int MSG_ReadShort(void);
extern int MSG_ReadWord(void);
extern int MSG_ReadLong(void);

//
//  Misc
//

//  float -> int
extern int ftoi(float f);

//  int -> float
extern float itof(int f);
extern int Cmd_CheckParm(string str);

//  Adds text to command buffer, same as typing it in console
extern void CmdBuf_AddText(string format, ...);

//  Reads key value from info string (userinfo or serverinfo)
extern string Info_ValueForKey(string info, string key);

//  Checks if WAD lump is present, used to check for shareware/extended WADs
extern boolean WadLumpPresent(string name);

extern void *Spawn(classid cid);
extern void Destroy(void *ptr);

//==========================================================================
//
//              CLIENT BUILTINS
//
//==========================================================================

#ifdef CLIENT

//
//  Graphics
//

//  Registers a graphic, returns handle
extern int R_RegisterPic(string name, int type);

//  Registers a graphic with custom palette, returns handle
extern int R_RegisterPicPal(string name, int type, string palname);

//  Retrieves pic info
extern void R_GetPicInfo(int handle, picinfo_t * info);

//  Draws a pic
extern void R_DrawPic(int x, int y, int handle);

//  Draws a translucent pic
extern void R_DrawPic2(int x, int y, int handle, int trans);

//  Draws a shadowed pic
extern void R_DrawShadowedPic(int x, int y, int handle);

//  Installs a sprite model
extern void R_InstallSprite(string name, int index);

//  Draws a sprite
extern void R_DrawSpritePatch(int x, int y, int sprite, int frame, int rot,
	int translation);

//  Installs model
extern model_t *InstallModel(string name);

//  Draws a model
extern void R_DrawModelFrame(TVec origin, float angle, model_t * model,
	int frame, string skin);

//  Draws a rectangle filled with a flat
extern void R_FillRectWithFlat(int x, int y, int width, int height,
	string name);

//  Darkens a screen region
extern void R_ShadeRect(int x, int y, int w, int h, int shade);

//
//  Text
//

//  Selects active font
extern void T_SetFont(int font);

//  Changes text alignement
extern void T_SetAlign(int halign, int valign);

//  Enable/disable text shadow
extern void T_SetShadow(boolean on);

//  Calculates text width
extern int T_TextWidth(string text);

//  Calculates text height
extern int T_TextHeight(string text);

//  Draws text
extern void T_DrawText(int x, int y, string text);

//  Draws text, but no more than n characters
extern void T_DrawNText(int x, int y, string text, int n);

//  Draws a cursor at the end of last drawn string
extern void T_DrawCursor(void);

//
//  Client sound stuff
//

//  Plays a sound
extern void LocalSound(string name);

//  Plays a sound and waits untill it finishes
extern void LocalSoundTillDone(string name);

//  Handle shift+key
extern int TranslateKey(int c);

extern string P_GetMapName(int map);
extern string P_TranslateMap(int map);
extern boolean SV_GetSaveString(int i, string buf);
extern void StartSearch(void);
extern slist_t * GetSlist(void);
extern void KeyNameForNum(int KeyNr, string NameString);
extern void IN_GetBindingKeys(string cmd, int *key1, int *key2);
extern void IN_SetBinding(int key, string ondown, string onup);

extern void LoadTextLump(string name, void *buf, int bufsize);

extern dlight_t *AllocDlight(int key);
extern particle_t *NewParticle(void);

#endif

//==========================================================================
//
//              SERVER BUILTINS
//
//==========================================================================

#ifdef SERVER

//
//  Print functions
//

//  Broadcast message (print to all clients)
extern void bprint(string format, ...);

//  Print to client
extern void cprint(player_t * player, string format, ...);

//  Client's center message
extern void centerprint(player_t * player, string format, ...);

//
//  Map utilites
//

extern opening_t *LineOpenings(line_t * linedef, TVec point);

//  Returns 0 - front, 1 - back, -1 - on
extern int P_BoxOnLineSide(float *tmbox, line_t * ld);

//
extern boolean P_BlockThingsIterator(int x, int y, thing_iter_func_t func);

//
extern boolean P_BlockLinesIterator(int x, int y, line_iter_func_t func);

//
extern boolean P_PathTraverse(float x1, float y1, float x2, float y2,
	int flags, trav_func_t trav);

//  Find the best gap that the thing could fit in, given a certain Z
// position (z1 is foot, z2 is head).
extern sec_region_t *FindThingGap(sec_region_t * gaps, TVec point, float z1,
	float z2);

//  Find the best opening
extern opening_t *FindOpening(opening_t * gaps, float z1, float z2);

//  Find best region in sector for a given point
extern sec_region_t *PointInRegion(sector_t * sector, TVec p);
extern int PointContents(sector_t * sector, TVec p);
extern sec_region_t *AddExtraFloor(line_t * line, sector_t * dst);
extern int MapBlock(float val);

//
//  Mobj utilites
//

extern Entity *NewMobjThinker(classid cid);
extern void RemoveMobjThinker(Entity * mobj);
extern void P_SetThingPosition(Entity * thing);
extern void P_UnsetThingPosition(Entity * thing);
extern Entity *NextMobj(Entity * mo);
extern boolean P_CheckSight(Entity * mobj1, Entity * mobj2);

//
//  Special thinker utilites
//

extern void *NewSpecialThinker(classid);
extern void RemoveSpecialThinker(Thinker * spec);
extern void P_ChangeSwitchTexture(line_t * line, int useAgain);
extern Thinker *NextThinker(Thinker * last, classid id);

//
//  Polyobj functions
//

extern void SpawnPolyobj(float x, float y, int tag, int flags);
extern void AddAnchorPoint(float x, float y, int tag);
extern polyobj_t *GetPolyobj(int polyNum);
extern int GetPolyobjMirror(int poly);
extern boolean PO_RotatePolyobj(int num, float angle);
extern boolean PO_MovePolyobj(int num, float x, float y);

//
//  ACS functions
//

extern boolean StartACS(int number, int map, int *args, Entity * activator,
	line_t * line, int side);
extern boolean SuspendACS(int number, int map);
extern boolean TerminateACS(int number, int map);
extern void TagFinished(int tag);
extern void PolyobjFinished(int po);
extern void ACS::Think(void);
extern void ACS::Archive(void);
extern void ACS::Unarchive(void);

//
//  Sound functions
//

extern void StartSound(Entity * mobj, int sound, int channel);
extern void StartSoundAtVolume(Entity * mobj, int sound, int channel,
	int volume);
extern void StopSound(Entity * mobj, int channel);
extern void SectorStartSound(sector_t * sec, int sound, int channel);
extern void SectorStopSound(sector_t * sec, int channel);
extern boolean GetSoundPlayingInfo(Entity * mobj, int sound_id);
extern int GetSoundID(string name);
extern void SectorStartSequence(sector_t * sector, string sequence);
extern void SectorStopSequence(sector_t * sector);
extern void PolyobjStartSequence(polyobj_t * mobj, string sequence);
extern void PolyobjStopSequence(polyobj_t * mobj);

#define StartSoundName(origin, name, channel)	StartSound(origin, GetSoundID(name), channel)
#define SectorStartSoundName(sec, name, channel)	SectorStartSound(sec, GetSoundID(name), channel)

//
//  Savegame archieve / unarchieve utilite functions
//

extern sector_t *SectorToNum(sector_t * sector);
extern sector_t *NumToSector(sector_t * sector);
extern Entity *MobjToNum(Entity * mobj);
extern Entity *NumToMobj(Entity * mobj);

extern void G_ExitLevel(void);
extern void G_SecretExitLevel(void);

extern int P_GetPlayerNum(player_t * player);
extern subsector_t *PointInSubsector(float x, float y);
extern void ClearPlayer(player_t * p);
extern void G_Completed(int map, int position);
extern int TerrainType(int pic);
extern void P_ForceLightning(void);
extern void SB_Start(void);
extern void SetFloorPic(sector_t * sec, int texture);
extern void SetCeilPic(sector_t * sec, int texture);
extern void SetLineTransluc(line_t * line, int trans);
extern void SendFloorSlope(sector_t * sector);
extern void SendCeilingSlope(sector_t * sector);

#endif

//**************************************************************************
//
//  $Log$
//  Revision 1.17  2001/11/09 14:38:45  dj_jl
//  Moved input line to progs
//
//  Revision 1.16  2001/10/27 07:37:39  dj_jl
//  Possibility to create new console variables
//
//  Revision 1.15  2001/10/22 17:23:08  dj_jl
//  Floatification of angles
//
//  Revision 1.14  2001/10/18 17:39:33  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.13  2001/10/12 17:23:33  dj_jl
//  Start on first map in MAPINFO script
//
//  Revision 1.12  2001/10/08 17:22:12  dj_jl
//  Changed slist to be returned by engine
//
//  Revision 1.11  2001/10/02 17:37:19  dj_jl
//  Removed status bar widgets
//
//  Revision 1.10  2001/09/27 17:08:19  dj_jl
//  Removed spawn functions, added mobj classes
//
//  Revision 1.9  2001/09/25 17:13:50  dj_jl
//  Beautification
//
//  Revision 1.8  2001/09/24 17:11:23  dj_jl
//  Created thinker classes
//
//  Revision 1.7  2001/09/20 16:19:59  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.6  2001/08/29 17:42:11  dj_jl
//  Added sound channel
//  
//  Revision 1.5  2001/08/23 17:38:55  dj_jl
//  Fixed Heretic episode 2 finale
//  
//  Revision 1.4  2001/08/15 17:05:11  dj_jl
//  Model setup
//
//  Revision 1.3  2001/07/31 16:57:52  dj_jl
//  Checking for shareware/extended wad by the presence of wad lump
//
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
