//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//
//                              ENTITY DATA
//
//  NOTES: Entity
//
//  Entities are used to tell the refresh where to draw an image, tell the
// world simulation when objects are contacted, and tell the sound driver
// how to position a sound.
//
//  The refresh uses the snext and sprev links to follow lists of things in
// sectors as they are being drawn. The sprite, frame, and angle elements
// determine which patch_t is used to draw the sprite if it is visible.
// The sprite and frame values are allmost allways set from state_t
// structures. The xyz origin point represents a point at the bottom middle
// of the sprite (between the feet of a biped). This is the default origin
// position for patch_ts grabbed with lumpy.exe. A walking creature will have
// its z equal to the floor it is standing on.
//
//  The sound code uses the x,y, and z fields to do stereo positioning of any
// sound effited by the Entity.
//
//  The play simulation uses the BlockLinks, x,y,z, radius, height to
// determine when mobj_ts are touching each other, touching lines in the map,
// or hit by trace lines (gunshots, lines of sight, etc). The Entity->flags
// element has various bit flags used by the simulation.
//
//  Every Entity is linked into a single sector based on its origin
// coordinates. The subsector_t is found with R_PointInSubsector(x,y), and
// the sector_t can be found with subsector->sector. The sector links are
// only used by the rendering code, the play simulation does not care about
// them at all.
//
//  Any Entity that needs to be acted upon by something else in the play
// world (block movement, be shot, etc) will also need to be linked into the
// blockmap. If the thing has the MF_NOBLOCK flag set, it will not use the
// block links. It can still interact with other things, but only as the
// instigator (missiles will run into other things, but nothing can run into
// a missile). Each block in the grid is 128*128 units, and knows about every
// line_t that it contains a piece of, and every interactable Entity that has
// its origin contained.
//
//  A valid Entity is a Entity that has the proper subsector_t filled in for
// its xy coordinates and is linked into the sector from which the subsector
// was made, or has the MF_NOSECTOR flag set (the subsector_t needs to be
// valid even if MF_NOSECTOR is set), and is linked into a blockmap block or
// has the MF_NOBLOCKMAP flag set. Links should only be modified by the
// P_[Un]SetThingPosition() functions. Do not change the MF_NO? flags while
// a thing is valid.
//
//  Any questions?
//
//**************************************************************************

class Entity : Thinker
	native
	abstract;

enum
{
	STYLE_None,					// Do not draw
	STYLE_Normal,				// Normal; just copy the image to the screen
	STYLE_Fuzzy,				// Draw silhouette using "fuzz" effect
	STYLE_SoulTrans,			// Draw translucent with amount in r_transsouls
	STYLE_OptFuzzy,				// Draw as fuzzy or translucent, based on user preference
	STYLE_Translucent = 64,		// Draw translucent
	STYLE_Add					// Draw additive
};

//	Colour tralslation types.
enum
{
	//	No translation.
	TRANSL_None,
	//	Game's standard translations.
	TRANSL_Standard,
	//	Per-player translations.
	TRANSL_Player,
	//	ACS translations.
	TRANSL_Level,
	//	Translations of dead players.
	TRANSL_BodyQueue,
	//	Translations defined in DECORATE.
	TRANSL_Decorate,

	TRANSL_Max
};

const int TRANSL_TYPE_SHIFT = 16;

// Info for drawing: position.
TVec			Origin;

// Momentums, used to update position.
TVec			Velocity;

TAVec			Angles;				// orientation

readonly state	State;
float			StateTime;			// state tic counter

//More drawing info.
byte			SpriteType;				//  How to draw sprite
name			FixedSpriteName;
string			FixedModelName;
string			ModelSkin;
byte			ModelVersion;

byte			RenderStyle;
float			Alpha;
int				Translation;

float			FloorClip;	// value to use for floor clipping

//	Scaling.
float			ScaleX;
float			ScaleY;

native readonly subsector_t*	SubSector;
native readonly sector_t*		Sector;

// Interaction info, by BLOCKMAP.
// Links in blocks (if needed).
native readonly private Entity	BlockMapNext;
native readonly private Entity	BlockMapPrev;

// Links in sector (if needed).
native readonly Entity			SNext;
native readonly Entity			SPrev;

native readonly msecnode_t*		TouchingSectorList;

// The closest interval over all contacted Sectors.
native float	FloorZ;
native float	CeilingZ;
native float	DropOffZ;

//  Closest floor and ceiling, source of floorz and ceilingz
native sec_plane_t*	Floor;
native sec_plane_t*	Ceiling;

// If == validcount, already checked.
int				ValidCount;

//	Flags
bool bSolid;			// Blocks.
bool bNoSector;			// don't use the sector links (invisible but touchable)
bool bNoBlockmap;		// don't use the BlockLinks (inert but displayable)
bool bIsPlayer;			// PLayer or player-bot
bool bFixedModel;

bool bNoGravity;		// don't apply gravity every tic
bool bPassMobj;			// Enable z block checking.  If on,
						// this flag will allow the mobj
						// to pass over/under other mobjs.
bool bColideWithThings;
bool bColideWithWorld;
bool bCheckLineBlocking;
bool bCheckLineBlockMonsters;
bool bDropOff;			// allow jumps from high places
bool bFloat;			// allow moves to any height, no gravity
bool bFly;				// fly mode is active
bool bBlasted;			// missile will pass through ghosts
bool bCantLeaveFloorpic;// stay within a certain floor type
bool bFloorClip;		// if feet are allowed to be clipped
bool bIgnoreCeilingStep;// continue walk without lowering itself
bool bIgnoreFloorStep;	// continue walk ignoring floor height changes
bool bAvoidingDropoff;	// used to move monsters away from dropoffs
bool bOnMobj;			// mobj is resting on top of another mobj
bool bCorpse;			// don't stop moving halfway off a step
bool bFullBright;		// make current state full bright
native readonly bool bNetLocalPlayer;	// Mobj of player currently being updated
bool bInvisible;		// Don't draw this actor
bool bMissile;			// don't hit same species, explode on block

int				Health;

// For movement checking.
float			Radius;
float			Height;

// Additional info record for player avatars only.
// Only valid if type == MT_PLAYER
BasePlayer		Player;

int				TID;		// thing identifier
int				Special;	// special
int				Args[5];	// special arguments

readonly private int	NetID;

//  Params
float			Mass;
float			MaxStepHeight;
float			MaxDropoffHeight;
float			Gravity;

//  Water
byte			WaterLevel;
byte			WaterType;

//   For player sounds.
name			SoundClass;
name			SoundGender;

	//	Owner entity of inventory item
Entity			Owner;

replication
{
	reliable if (Role == ROLE_Authority)
		Origin, Angles, FloorClip, State, StateTime, SpriteType,
		FixedSpriteName, ModelSkin, ModelVersion, RenderStyle, Alpha,
		Translation, ScaleX, ScaleY, bFly, bNoSector, bInvisible, bFullBright,
		bFixedModel, bNetLocalPlayer, NetID;


	reliable if (Role == ROLE_Authority && bFixedModel)
		FixedModelName;

	reliable if (Role == ROLE_Authority && bNetOwner)
		Owner;
}

//
//	Natives
//

native final bool SetState(state State);
native final void SetInitialState(state State);
native final bool AdvanceState(float deltaTime);
native final state FindState(name StateName);

native final void PlaySound(name SoundName, int Channel, optional float Volume,
	optional float Atenuation);
native final void StopSound(int Channel);
native final bool AreSoundsEquivalent(name Sound1, name Sound2);

native final void StartSoundSequence(name sequence, int ModeNum);
native final void AddSoundSequenceChoice(name Choice);
native final void StopSoundSequence();

native final bool CheckSides(TVec lsPos);
native final void CheckDropOff(avoiddropoff_t* a);
native final bool CheckPosition(TVec Pos);
native final bool CheckRelPosition(tmtrace_t* tmtrace, TVec Pos);
native final bool TryMove(TVec newPos);
native final bool TryMoveEx(tmtrace_t* tmtrace, TVec newPos);
native final bool TestMobjZ();

native final void SlideMove();
native final void BounceWall(float overbounce);

native final bool CheckWater();

native final void UpdateVelocity();

native final Entity CheckOnmobj();

native final void LinkToWorld();
native final void UnlinkFromWorld();

native final bool CanSee(Entity Other);

native final Entity RoughMonsterSearch(int distance);

//===========================================================================
//
//  OnMapSpawn
//
//===========================================================================

void OnMapSpawn(mthing_t* mthing)
{
}

//==========================================================================
//
//	BeginPlay
//
//==========================================================================

void BeginPlay()
{
}

//==========================================================================
//
//	Destroyed
//
//==========================================================================

void Destroyed()
{
	if (TID)
	{
		// Remove from TID list
		RemoveFromTIDList();
	}
}

//==========================================================================
//
//	Touch
//
//==========================================================================

bool Touch(Entity Other)
{
	return !Other.bSolid;
}

//==========================================================================
//
//	BlockedByLine
//
//==========================================================================

void BlockedByLine(line_t * ld)
{
}

//==========================================================================
//
//	PushLine
//
//==========================================================================

void PushLine(tmtrace_t* tmtrace)
{
}

//==========================================================================
//
//	HandleFloorclip
//
//==========================================================================

void HandleFloorclip()
{
}

//==========================================================================
//
//	CrossSpecialLine
//
//==========================================================================

void CrossSpecialLine(line_t* ld, int side)
{
}

//==========================================================================
//
//	ApplyFriction
//
//==========================================================================

void ApplyFriction()
{
}

//==========================================================================
//
//	SectorChanged
//
//==========================================================================

bool SectorChanged(int CrushChange)
{
	return true;
}

//===========================================================================
//
//  RoughCheckThing
//
//===========================================================================

bool RoughCheckThing(Entity Other)
{
	return false;
}

//===========================================================================
//
//  ClearInventory
//
//===========================================================================

void ClearInventory()
{
}

//===========================================================================
//
//  GiveInventory
//
//===========================================================================

void GiveInventory(name ItemName, int Amount)
{
}

//===========================================================================
//
//  TakeInventory
//
//===========================================================================

void TakeInventory(name ItemName, int Amount)
{
}

//===========================================================================
//
//  CheckInventory
//
//===========================================================================

int CheckInventory(name ItemName)
{
	return 0;
}

//===========================================================================
//
//  GetSigilPieces
//
//===========================================================================

int GetSigilPieces()
{
	return 0;
}

//===========================================================================
//
//  GetArmorPoints
//
//===========================================================================

int GetArmorPoints()
{
	return 0;
}

//===========================================================================
//
//  CheckNamedWeapon
//
//===========================================================================

int CheckNamedWeapon(name Name)
{
	return 0;
}

//===========================================================================
//
//  SetNamedWeapon
//
//===========================================================================

int SetNamedWeapon(name Name)
{
	return 0;
}

//===========================================================================
//
//  GetAmmoCapacity
//
//===========================================================================

int GetAmmoCapacity(name Name)
{
	return 0;
}

//===========================================================================
//
//  SetAmmoCapacity
//
//===========================================================================

void SetAmmoCapacity(name Name, int Amount)
{
}

//===========================================================================
//
//  MoveThing
//
//===========================================================================

bool MoveThing(TVec Pos, bool Fog)
{
	return false;
}

//==========================================================================
//
//	GetStateTime
//
//==========================================================================

float GetStateTime(state AState, float AStateTime)
{
	return AStateTime;
}

//==========================================================================
//
//	SetActorProperty
//
//==========================================================================

void SetActorProperty(int Prop, int IntVal, string StrVal)
{
}

//==========================================================================
//
//	GetActorProperty
//
//==========================================================================

int GetActorProperty(int Prop)
{
	return 0;
}

//==========================================================================
//
//	SetOrigin
//
//==========================================================================

void SetOrigin(TVec NewOrigin)
{
	Origin = NewOrigin;
}

//==========================================================================
//
//	InsertIntoTIDList
//
//==========================================================================

void InsertIntoTIDList(int tid)
{
	int i;
	int index;

	index = -1;
	for (i = 0; i < Level.TIDList.Num; i++)
	{
		if (Level.TIDList[i] == -1)
		{
			// Found empty slot
			index = i;
			break;
		}
	}
	if (index == -1)
	{
		// Append required
		index = i;
	}
	TID = tid;
	Level.TIDList[index] = tid;
	Level.TIDMobj[index] = self;
}

//==========================================================================
//
//	RemoveFromTIDList
//
//==========================================================================

void RemoveFromTIDList()
{
	int i;

	for (i = 0; i < Level.TIDList.Num; i++)
	{
		if (Level.TIDMobj[i] == self)
		{
			Level.TIDList[i] = -1;
			Level.TIDMobj[i] = none;
			TID = 0;
			return;
		}
	}
	TID = 0;
}

//==========================================================================
//
//	Activate
//
//==========================================================================

bool Activate()
{
	return false;
}

//==========================================================================
//
//	Deactivate
//
//==========================================================================

bool Deactivate()
{
	return false;
}

//==========================================================================
//
//	RemoveThing
//
//==========================================================================

void RemoveThing()
{
	Destroy();
}

//==========================================================================
//
//  DistTo
//
//==========================================================================

float DistTo(Entity Other)
{
	return Length(Other.GetCentre() - GetCentre());
}

//==========================================================================
//
//  DistTo2
//
//==========================================================================

float DistTo2(Entity Other)
{
	TVec dir;

	dir = Other.Origin - Origin;
	dir.z = 0.0;
	return Length(dir);
}

//==========================================================================
//
//	GetCentre
//
//==========================================================================

TVec GetCentre()
{
	return Origin + vector(0.0, 0.0, Height * 0.5 - FloorClip);
}

defaultproperties
{
	RenderStyle = STYLE_Normal;
	Alpha = 1.0;
	ScaleX = 1.0;
	ScaleY = 1.0;
	bColideWithThings = true;
	bColideWithWorld = true;
	MaxDropoffHeight = 24.0;
	Gravity = 1.0;
	SoundClass = 'player';
	SoundGender = 'male';
}
