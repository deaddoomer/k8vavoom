//**************************************************************************
//**
//**	##   ##    ##    ##   ##   ####     ####   ###     ###
//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**	   #    ##    ##    #      ####     ####   ##       ##
//**
//**	$Id$
//**
//**	Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**	This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**	This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**	$Log$
//**	Revision 1.5  2001/08/15 17:07:10  dj_jl
//**	Fixed finale
//**
//**	Revision 1.4  2001/08/07 16:42:25  dj_jl
//**	Added player models, skins and weapon
//**	
//**	Revision 1.3  2001/08/04 17:20:28  dj_jl
//**	Changes to inform new clients about changed textures
//**	
//**	Revision 1.2  2001/07/27 14:27:51  dj_jl
//**	Update with Id-s and Log-s, some fixes
//**	
//**************************************************************************

typedef int boolean;
typedef uint angle_t;

struct special_t;
struct sector_t;
struct line_t;
struct mobj_t;
struct subsector_t;
struct player_t;
struct mthing_t;

typedef void (*special_func_t)(special_t *);
typedef void (*mobj_func_t)(mobj_t *);
typedef void (*spawnfunc_t)(mobj_t *, mthing_t*);
typedef boolean (*thing_iter_func_t)(mobj_t *);
typedef boolean (*line_iter_func_t)(line_t *);
// Weapon info: sprite frames, ammunition use.
typedef void (*weapon_func_t)(player_t *);

//==========================================================================
//
//	3D math - vectors and panes
//
//==========================================================================

vector TVec
{
	float		x;
	float		y;
	float		z;
};

struct TAVec
{
	angle_t		pitch;
	angle_t		yaw;
	angle_t		roll;
};

struct TPlane
{
	TVec		normal;
	float		dist;
};

//==========================================================================
//
//	Level
//
//==========================================================================

struct thinker_t
{
	void		*__prev;
    void		*__next;
	void		*real_function;
};

//
//	Level special
//
struct special_t : thinker_t
{
	special_func_t	function;
	addfields 128;
};

//
//	Each sector has a degenmobj_t in its center for sound origin purposes.
//
struct degenmobj_t : thinker_t
{
    // Info for drawing: position.
	TVec		origin;
};

//
// LineDef
//
struct line_t : TPlane
{
    // Vertices, from v1 to v2.
    TVec		*v1;
    TVec		*v2;

    // Precalculated v2 - v1 for side checking.
	TVec		__dir;

    // Animation related.
    int			flags;

    // Visual appearance: SideDefs.
    //  sidenum[1] will be -1 if one sided
    int			sidenum[2];

    // Neat. Another bounding box, for the extent
    //  of the LineDef.
	float		bbox[4];

    // To aid move clipping.
    int			__slopetype;

    // Front and back sector.
    // Note: redundant? Can be retrieved from SideDefs.
    sector_t	*frontsector;
    sector_t	*backsector;

    // if == validcount, already checked
    int         validcount;

    // thinker_t for reversable actions
    special_t	*__specialdata;

	int			translucency;

	int			special;
    int			arg1;
    int			arg2;
    int			arg3;
    int			arg4;
    int			arg5;
};

//
// The SideDef.
//
struct side_t
{
	// add this to the calculated texture column
	float		textureoffset;

	// add this to the calculated texture top
	float		rowoffset;

	float		__base_textureoffset;
	float		__base_rowoffset;

	// Texture indices.
	// We do not maintain names here.
	int			toptexture;
	int			bottomtexture;
	int			midtexture;

	int			__base_toptexture;
	int			__base_bottomtexture;
	int			__base_midtexture;

	// Sector the SideDef is facing.
	sector_t	*sector;
};

struct sec_plane_t : TPlane
{
	float		minz;
	float		maxz;

	int			pic;
	int			__base_pic;

	float		xoffs;
	float		yoffs;

	int			flags;
	int			translucency;
};

struct sec_params_t
{
    int		    lightlevel;
	int			contents;
};

struct sec_region_t
{
	//	Linked list of regions in bottom to top order
	sec_region_t	*prev;
	sec_region_t	*next;

	//	Planes
	sec_plane_t		*floor;
	sec_plane_t		*ceiling;

	sec_params_t	*params;
	line_t			*extraline;
};

//
//	The SECTORS record, at runtime.
//	Stores things/mobjs.
//
struct sector_t
{
	sec_plane_t		floor;
	sec_plane_t		ceiling;
	sec_params_t	params;

	sec_region_t	*topregion;	//	Highest region
	sec_region_t	*botregion;	//	Lowest region

	float		floorheight;
	float		ceilingheight;
    int		    special;
    int			tag;

	float		base_floorheight;
	float		base_ceilingheight;
    int		    __base_lightlevel;

	float		skyheight;

    // 0 = untraversed, 1,2 = sndlines -1
    int         soundtraversed;

    // thing that made a sound (or null)
    mobj_t		*soundtarget;

    // stone, metal, heavy, etc...
	int			seqType;

    // mapblock bounding box for height changes
    int         blockbox[4];

    // origin for any sounds played by the sector
    degenmobj_t soundorg;

    // if == validcount, already checked
    int         validcount;

    // thinker_t for reversable actions
    special_t	*specialdata;

	// list of subsectors in sector
	// used to check if client can see this sector (it needs to be updated)
	void		*__subsectors;

    int			linecount;
    line_t		**lines;  // [linecount] size
};

//
//	Polyobj data
//
struct polyobj_t
{
	int 		__numsegs;
	void 		*__segs;
	degenmobj_t startSpot;
	void	 	*__originalPts; 	// used as the base for the rotations
	void	 	*__prevPts; 		// use to restore the old point values
	angle_t 	angle;
	int 		tag;			// reference tag assigned in HereticEd
	int			__bbox[4];
	int 		validcount;
	boolean 	crush; 			// should the polyobj attempt to crush mobjs?
	int 		seqType;
	special_t	*specialdata; 	// pointer a thinker, if the poly is moving
	subsector_t	*__subsector;
	float		__base_x;
	float		__base_y;
	angle_t		__base_angle;
	boolean		__changed;
};

//
// 	A SubSector.
// 	References a Sector. Basically, this is a list of LineSegs, indicating
// the visible walls that define (all or some) sides of a convex BSP leaf.
//
struct subsector_t
{
    sector_t	*sector;
	void		*__seclink;
    int			__numlines;
    int			__firstline;
	polyobj_t	*__poly;

	void		*__parent;
	int			__visframe;
	void		*__regions;
};

//==========================================================================
//
//								MAPOBJ DATA
//
// 	NOTES: mobj_t
//
// 	mobj_ts are used to tell the refresh where to draw an image, tell the
// world simulation when objects are contacted, and tell the sound driver
// how to position a sound.
//
// 	The refresh uses the snext and sprev links to follow lists of things in
// sectors as they are being drawn. The sprite, frame, and angle elements
// determine which patch_t is used to draw the sprite if it is visible.
// The sprite and frame values are allmost allways set from state_t
// structures. The xyz origin point represents a point at the bottom middle
// of the sprite (between the feet of a biped). This is the default origin
// position for patch_ts grabbed with lumpy.exe. A walking creature will have
// its z equal to the floor it is standing on.
//
// 	The sound code uses the x,y, and z fields to do stereo positioning of any
// sound effited by the mobj_t.
//
// 	The play simulation uses the blocklinks, x,y,z, radius, height to
// determine when mobj_ts are touching each other, touching lines in the map,
// or hit by trace lines (gunshots, lines of sight, etc). The mobj_t->flags
// element has various bit flags used by the simulation.
//
// 	Every mobj_t is linked into a single sector based on its origin
// coordinates. The subsector_t is found with R_PointInSubsector(x,y), and
// the sector_t can be found with subsector->sector. The sector links are
// only used by the rendering code, the play simulation does not care about
// them at all.
//
// 	Any mobj_t that needs to be acted upon by something else in the play
// world (block movement, be shot, etc) will also need to be linked into the
// blockmap. If the thing has the MF_NOBLOCK flag set, it will not use the
// block links. It can still interact with other things, but only as the
// instigator (missiles will run into other things, but nothing can run into
// a missile). Each block in the grid is 128*128 units, and knows about every
// line_t that it contains a piece of, and every interactable mobj_t that has
// its origin contained.
//
// 	A valid mobj_t is a mobj_t that has the proper subsector_t filled in for
// its xy coordinates and is linked into the sector from which the subsector
// was made, or has the MF_NOSECTOR flag set (the subsector_t needs to be
// valid even if MF_NOSECTOR is set), and is linked into a blockmap block or
// has the MF_NOBLOCKMAP flag set. Links should only be modified by the
// P_[Un]SetThingPosition() functions. Do not change the MF_NO? flags while
// a thing is valid.
//
// 	Any questions?
//
//==========================================================================

//
// Map thing definition with initialised fields for global use.
//
struct mthing_t
{
	int 		tid;
	float		x;
	float		y;
	float		height;
	int 		angle;
	int			type;
	int			options;
	int 		special;
	int 		arg1;
	int 		arg2;
	int 		arg3;
	int 		arg4;
	int 		arg5;
};

struct state_t
{
	int			sprite;
	int			frame;
	int			model_index;
	int			model_frame;
	float		time;
	int			statenum;
	int			nextstate;
	float		misc1;
    float		misc2;
	mobj_func_t	function;
};

struct mobjinfo_t
{
	spawnfunc_t	spawnfunc;
    int			doomednum;
};

// Map Object definition.
struct mobj_t : degenmobj_t
{
    // Momentums, used to update position.
	TVec			velocity;

    //More drawing info: to determine current sprite.
	TAVec			angles;	// orientation
	int				spritetype;	//	How to draw sprite
    int				sprite;	// used to find patch_t and flip value
    int				frame;	// might be ORed with FF_FULLBRIGHT

	int				model_index;
	int				alias_frame;
	int				alias_skinnum;

    int				translucency;
    int				translation;

	float			floorclip;		// value to use for floor clipping

	int				effects;

    subsector_t*	subsector;

    // Interaction info, by BLOCKMAP.
    // Links in blocks (if needed).
    mobj_t*			bnext;
    mobj_t*			bprev;
    
    // The closest interval over all contacted Sectors.
	float			floorz;
	float			ceilingz;

	//	Closest floor and ceiling, source of floorz and ceilingz
	sec_plane_t		*floor;
	sec_plane_t		*ceiling;

    // If == validcount, already checked.
    int				validcount;

    int				type;

	int				damage;			// For missiles
    int				flags;
	int				flags2;			// Heretic flags
    int				health;

    // For movement checking.
	float			radius;
	float			height;

    // Thing being chased/attacked (or NULL),
    // also the originator for missiles.
    mobj_t*			target;

    // Additional info record for player avatars only.
    // Only valid if type == MT_PLAYER
    player_t		*player;

	int				__archiveNum;		// Identity during archive
	int				tid;			// thing identifier
	int				special;		// special
	int				args[5];		// special arguments

	int				__netID;

	//	128 integers for user defined fields in PROGS
	addfields 128;
};

addfields mobj_t
{
    float			time;	// state tic counter
	int				statenum;
	int				nextstate;
};

struct level_t
{
	//
	// MAP related Lookup tables.
	// Store VERTEXES, LINEDEFS, SIDEDEFS, etc.
	//
	// Lookup tables for map data.
	int			__numvertexes;
	void		*__vertexes;

	int			__numsegs;
	void		*__segs;

	int			numsectors;
	sector_t	*sectors;

	int			__numsubsectors;
	void		*__subsectors;

	int			__numnodes;
	void		*__nodes;

	int			numlines;
	line_t		*lines;

	int			numsides;
	side_t		*sides;

	int 		__numpolyobjs;
	void		*__polyobjs; // list of all poly-objects on the level

	// !!! Valid only during level loading
	int			numthings;
	mthing_t	*things;
	int			*behavior;

    //
	//	BLOCKMAP
	//	Created from axis aligned bounding box of the map, a rectangular
	// array of blocks of size ...
	// Used to speed up collision detection by spatial subdivision in 2D.
	//
	void		*__blockmaplump;	// offsets in blockmap are from here
	void		*__blockmap;		// int for larger maps
	int			bmapwidth;      // Blockmap size.
	int			bmapheight;     // size in mapblocks
	float		bmaporgx;       // origin of block map
	float		bmaporgy;
	mobj_t		**blocklinks;	// for thing chains
#define BlockLink(num)	level->blocklinks[num]
	void		*__PolyBlockMap;

	//
	//	REJECT
	//	For fast sight rejection.
	//	Speeds up enemy AI by skipping detailed LineOf Sight calculation.
	// 	Without special effect, this could be used as a PVS lookup as well.
	//
	void		*__rejectmatrix;

	// Maintain single and multi player starting spots.
	mthing_t	deathmatchstarts[MAXDEATHMATCHSTARTS];  // Player spawn spots for deathmatch.
	int			numdeathmatchstarts;
	mthing_t	playerstarts[MAX_PLAYER_STARTS * MAXPLAYERS];// Player spawn spots.

	float		time;
	int			tictime;

	int			totalkills;
	int			totalitems;
	int			totalsecret;    // for intermission
 
	int			__thinkers[3];// both the head and tail of the thinker list

	int			mapname[3];
	int			__nextmap[3];
	int			__level_name[8];

	void		*__vis_data;
};

//==========================================================================
//
//	Player
//
//==========================================================================

struct pspdef_t
{
	int			sprite;
	int			frame;
	int			model_index;
	int			alias_frame;
	int			alias_skinnum;
	float		sx;
	float		sy;
	int			statenum;	// a 0 state means not active
	int			nextstate;
    float		time;
};

//
// Extended player object info: player_t
//
#define MAXNAME		32
#define MAX_MSGLEN	8000
struct player_t
{
	boolean			active;
	boolean			spawned;
	boolean			is_bot;
	void			*__netcon;
	int				__message[7];
	int				__msgbuf[MAX_MSGLEN / 4];

	int				userinfo[MAX_INFO_STRING / 4];

	int				name[MAXNAME / 4];
	int				baseclass;
	int				pclass;			// player class type
	int				color;

	// Copied from cmd, needed for PROGS, which supports only 4 byte ints
	float			forwardmove;	// *2048 for move
	float			sidemove;		// *2048 for move
	float			flymove;		// fly up/down/centering
	int				buttons;		// fire, use
	int				impulse;		// weapon changes, inventory, etc

    mobj_t*			mo;
    int				playerstate;

	//	Model of current weapon
	int				weapon_model;

    // Determine POV,
    //  including viewpoint bobbing during movement.
    // Focal origin above r.z
	TVec			vieworg;

	boolean			fixangle;

    // This is only used between levels,
    // mo->health is used during levels.
    int				health;

	int				items;

    // Frags, kills of other players.
    int				frags[MAXPLAYERS];

    // True if button down last tic.
    int				attackdown;
    int				usedown;

     // For intermission stats.
    int				killcount;
    int				itemcount;
    int				secretcount;

    // So gun flashes light up areas.
    int				extralight;

	// For lite-amp and invulnarability powers
    int				fixedcolormap;

    // Current PLAYPAL index
    //  can be set to REDCOLORMAP for pain, etc.
    int				palette;

	//	color shifts for damage, powerups and content types
	uint			cshifts[NUM_CSHIFTS];

    // Overlay view sprites (gun, etc).
    pspdef_t		psprites[NUMPSPRITES];
	float			pspriteSY;

    // True if secret level has been done.
    boolean			didsecret;

	int 			worldTimer;				// total time the player's been playing

	int				old_stats[96];

	//	128 integers for user defined fields in PROGS
	addfields 128;
};

//==========================================================================
//
//	Other stuff
//
//==========================================================================

struct opening_t
{
	float		top;
	float		bottom;
	float		range;
	float		lowfloor;
	sec_plane_t	*floor;
	sec_plane_t	*ceiling;
	opening_t	*next;
};

#define PT_ADDLINES		1
#define PT_ADDTHINGS	2
#define PT_EARLYOUT		4

struct intercept_t
{
    float		frac;		// along trace line
    boolean		isaline;
	mobj_t		*thing;
	line_t		*line;
};

typedef boolean (*trav_func_t)(intercept_t*);

//**************************************************************************
//**
//**	Client side stuff
//**
//**************************************************************************

struct sb_widget_t
{
	sb_widget_t			*next;
    int					type;
    int					x;
    int					y;
	int					pindex;
    int					style;
    boolean				*on;
    int					pparam;
    int					*data;
};

struct model_t;

struct cl_pspdef_t
{
	int			sprite;
	int			frame;
	model_t		*__alias_model;
	int			alias_frame;
	int			alias_skinnum;
	float		sx;
	float		sy;
};

struct client_state_t
{
	int				clientnum;

	int				pclass;			// player class type

    // Determine POV,
    //  including viewpoint bobbing during movement.
    // Focal origin above r.z
	TVec			vieworg;
	TAVec			viewangles;
	boolean			centering;

    // This is only used between levels,
    // mo->health is used during levels.
    int				health;

	int				items;

    // Frags, kills of other players.
    int				frags[MAXPLAYERS];

    // So gun flashes light up areas.
    int				extralight;

	// For lite-amp and invulnarability powers
    int				fixedcolormap;

    // Current PLAYPAL index
    //  can be set to REDCOLORMAP for pain, etc.
    int				palette;

	uint			cshifts[NUM_CSHIFTS];		//	color shifts for damage,
	uint			prev_cshifts[NUM_CSHIFTS];	// powerups and content types

    // Overlay view sprites (gun, etc).
	cl_pspdef_t		psprites[NUMPSPRITES];
	float			pspriteSY;

    // True if secret level has been done.
    boolean			didsecret;

	int 			worldTimer;				// total time the player's been playing

	boolean			paused;

    // Overlay view sprites (gun, etc).
	int				translucency;

	int				maxclients;
	int				deathmatch;

	float			time;

	int				serverinfo[MAX_INFO_STRING / 4];

	int				intermission;

	//	128 integers for user defined fields in PROGS
	addfields 128;
};

//
//	Input Text Line widget
//

#define MAX_ILINE_LENGTH	79

struct TILine
{
    int			Data[(MAX_ILINE_LENGTH + 1) / 4];	// line of text
    int			len;		      		// current line length
    int			lm; // left margin past which I am not to delete characters
};

//
//	Server list
//

#define HOSTCACHESIZE		8

struct hostcache_t
{
	int			name[16 / 4];
	int			map[16 / 4];
	int			cname[32 / 4];
	int			wadfiles[20][16 / 4];
	int			users;
	int			maxusers;
};

struct slist_t
{
	boolean		inProgress;
	int			count;
	hostcache_t	cache[HOSTCACHESIZE];
	int			return_reason[32 / 4];
};

typedef void (*mb_func_t)(int key);

struct scores_t
{
	int			name[64 / 4];
	boolean		active;
	int			frags[MAXPLAYERS];
	int			killcount;
	int			itemcount;
	int			secretcount;
	float		time;
	int			userinfo[MAX_INFO_STRING / 4];
};

struct im_t
{
	int			leavemap[12 / 4];
	int			leavecluster;
	int			entermap[12 / 4];
	int			entercluster;
	int			leave_name[32 / 4];
	int			enter_name[32 / 4];
	int			totalkills;
	int			totalitems;
	int			totalsecret;
	float		time;
};

struct picinfo_t
{
	int		width;
	int		height;
	int		xoffset;
	int		yoffset;
};

struct dlight_t
{
	TVec	origin;
	float	radius;
	float	die;				// stop lighting after this time
	float	decay;				// drop this each second
	float	minlight;			// don't add when contributing less
	int		key;
	int		color;
};

struct particle_t
{
	TVec		org;
	int			color;
	particle_t	*next;
	TVec		vel;
	float		die;
	addfields 7;
};

struct clmobj_t
{
	boolean		in_use;

	TVec		origin;	// position
	TAVec		angles;	// orientation

	int			spritetype;	//	How to draw sprite
    int			sprite;	// used to find patch_t and flip value
    int			frame;	// might be ORed with FF_FULLBRIGHT

	int			model_index;
	model_t		*__alias_model;
	int			alias_frame;
	int			skin[64 / 4];

    int			translucency;
    int			translation;

	int			effects;
};

