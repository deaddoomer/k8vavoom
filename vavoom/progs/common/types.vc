//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

typedef int boolean;

struct sector_t;
struct line_t;
struct subsector_t;

//==========================================================================
//
//	Base class for all classes
//
//==========================================================================

class Object
{
	int ObjectInternal[7];
	classid Class;

	native void Destroy(void);
	native boolean IsA(classid cid);
	native boolean IsDestroyed(void);

	defaultproperties
	{
	}
}

//FIXME
#define classidNone		Object

//==========================================================================
//
//  3D math - vectors and panes
//
//==========================================================================

vector TVec
{
	float x;
	float y;
	float z;
};

vector TAVec
{
	float pitch;
	float yaw;
	float roll;
};

struct TPlane
{
	TVec normal;
	float dist;
	int __type;
	int __signbits;
	int __reserved1;
	int __reserved2;
};

//==========================================================================
//
//  Level
//
//==========================================================================

//
// LineDef
//
struct line_t:TPlane
{
	// Vertices, from v1 to v2.
	TVec *v1;
	TVec *v2;

	// Precalculated v2 - v1 for side checking.
	TVec __dir;

	// Animation related.
	int flags;

	// Visual appearance: SideDefs.
	//  sidenum[1] will be -1 if one sided
	int sidenum[2];

	// Neat. Another bounding box, for the extent
	//  of the LineDef.
	float bbox[4];

	// To aid move clipping.
	int __slopetype;

	// Front and back sector.
	// Note: redundant? Can be retrieved from SideDefs.
	sector_t *frontsector;
	sector_t *backsector;

	// if == validcount, already checked
	int validcount;

	int translucency;

	int special;
	int arg1;
	int arg2;
	int arg3;
	int arg4;
	int arg5;

	addfields 5;
};

//
// The SideDef.
//
struct side_t
{
	// add this to the calculated texture column
	float textureoffset;

	// add this to the calculated texture top
	float rowoffset;

	float __base_textureoffset;
	float __base_rowoffset;

	// Texture indices.
	// We do not maintain names here.
	int toptexture;
	int bottomtexture;
	int midtexture;

	int __base_toptexture;
	int __base_bottomtexture;
	int __base_midtexture;

	// Sector the SideDef is facing.
	sector_t *sector;
};

struct sec_plane_t:TPlane
{
	float minz;
	float maxz;

	int pic;
	int __base_pic;

	float xoffs;
	float yoffs;

	int flags;
	int translucency;
};

struct sec_params_t
{
	int lightlevel;
	int contents;
};

struct sec_region_t
{
	//  Linked list of regions in bottom to top order
	sec_region_t *prev;
	sec_region_t *next;

	//  Planes
	sec_plane_t *floor;
	sec_plane_t *ceiling;

	sec_params_t *params;
	line_t *extraline;
};

//
//  The SECTORS record, at runtime.
//  Stores things/mobjs.
//
struct sector_t
{
	sec_plane_t floor;
	sec_plane_t ceiling;
	sec_params_t params;

	sec_region_t *topregion;	//  Highest region
	sec_region_t *botregion;	//  Lowest region

	float floorheight;
	float ceilingheight;
	int special;
	int tag;

	float base_floorheight;
	float base_ceilingheight;
	int __base_lightlevel;

	float skyheight;

	// stone, metal, heavy, etc...
	int seqType;

	// mapblock bounding box for height changes
	int blockbox[4];

	// origin for any sounds played by the sector
	TVec soundorg;

	// if == validcount, already checked
	int validcount;

	// list of subsectors in sector
	// used to check if client can see this sector (it needs to be updated)
	void *__subsectors;

	int linecount;
	line_t **lines;	// [linecount] size

	addfields 8;
};

//
//  Polyobj data
//
struct polyobj_t
{
	int __numsegs;
	void *__segs;
	TVec startSpot;
	void *__originalPts;	// used as the base for the rotations
	void *__prevPts;	// use to restore the old point values
	float angle;
	int tag;	// reference tag assigned in HereticEd
	int __bbox[4];
	int validcount;
	boolean crush;	// should the polyobj attempt to crush mobjs?
	int seqType;
	subsector_t *__subsector;
	float __base_x;
	float __base_y;
	float __base_angle;
	boolean __changed;
	addfields 3;
};

//
// Map thing definition with initialised fields for global use.
//
struct mthing_t
{
	int tid;
	float x;
	float y;
	float height;
	int angle;
	int type;
	int options;
	int special;
	int arg1;
	int arg2;
	int arg3;
	int arg4;
	int arg5;
};

//
//  A SubSector.
//  References a Sector. Basically, this is a list of LineSegs, indicating
// the visible walls that define (all or some) sides of a convex BSP leaf.
//
struct subsector_t
{
	sector_t *sector;
	void *__seclink;
	int __numlines;
	int __firstline;
	polyobj_t *__poly;

	void *__parent;
	int __VisFrame;
	int __SkyVisFrame;
	void *__regions;
};

struct base_level_t
{
	//
	// MAP related Lookup tables.
	// Store VERTEXES, LINEDEFS, SIDEDEFS, etc.
	//
	// Lookup tables for map data.
	int __numvertexes;
	void *__vertexes;

	int __numsegs;
	void *__segs;

	int numsectors;
	sector_t *sectors;

	int __numsubsectors;
	void *__subsectors;

	int __numnodes;
	void *__nodes;

	int numlines;
	line_t *lines;

	int numsides;
	side_t *sides;

	int __numpolyobjs;
	void *__polyobjs;	// list of all poly-objects on the level

	float time;
	int tictime;

	int totalkills;
	int totalitems;
	int totalsecret;	// for intermission

	int mapname[3];
	int __nextmap[3];
	int __level_name[8];

	void *__vis_data;
};

//**************************************************************************
//
//  Server types
//
//**************************************************************************

#ifdef SERVER

typedef boolean(*line_iter_func_t) (line_t *);

//==========================================================================
//
//  Thinkers
//
//==========================================================================

class Thinker:Object
{
	void Think(void)
	{
	}

	void Archive(void)
	{
	}

	void Unarchive(void)
	{
	}
};

//==========================================================================
//
//                              MAPOBJ DATA
//
//  NOTES: Entity
//
//  Entities are used to tell the refresh where to draw an image, tell the
// world simulation when objects are contacted, and tell the sound driver
// how to position a sound.
//
//  The refresh uses the snext and sprev links to follow lists of things in
// sectors as they are being drawn. The sprite, frame, and angle elements
// determine which patch_t is used to draw the sprite if it is visible.
// The sprite and frame values are allmost allways set from state_t
// structures. The xyz origin point represents a point at the bottom middle
// of the sprite (between the feet of a biped). This is the default origin
// position for patch_ts grabbed with lumpy.exe. A walking creature will have
// its z equal to the floor it is standing on.
//
//  The sound code uses the x,y, and z fields to do stereo positioning of any
// sound effited by the Entity.
//
//  The play simulation uses the blocklinks, x,y,z, radius, height to
// determine when mobj_ts are touching each other, touching lines in the map,
// or hit by trace lines (gunshots, lines of sight, etc). The Entity->flags
// element has various bit flags used by the simulation.
//
//  Every Entity is linked into a single sector based on its origin
// coordinates. The subsector_t is found with R_PointInSubsector(x,y), and
// the sector_t can be found with subsector->sector. The sector links are
// only used by the rendering code, the play simulation does not care about
// them at all.
//
//  Any Entity that needs to be acted upon by something else in the play
// world (block movement, be shot, etc) will also need to be linked into the
// blockmap. If the thing has the MF_NOBLOCK flag set, it will not use the
// block links. It can still interact with other things, but only as the
// instigator (missiles will run into other things, but nothing can run into
// a missile). Each block in the grid is 128*128 units, and knows about every
// line_t that it contains a piece of, and every interactable Entity that has
// its origin contained.
//
//  A valid Entity is a Entity that has the proper subsector_t filled in for
// its xy coordinates and is linked into the sector from which the subsector
// was made, or has the MF_NOSECTOR flag set (the subsector_t needs to be
// valid even if MF_NOSECTOR is set), and is linked into a blockmap block or
// has the MF_NOBLOCKMAP flag set. Links should only be modified by the
// P_[Un]SetThingPosition() functions. Do not change the MF_NO? flags while
// a thing is valid.
//
//  Any questions?
//
//==========================================================================

struct player_t;
class Actor;

typedef void (*state_func_t) (Object);

struct state_t
{
	int sprite;
	int frame;
	int model_index;
	int model_frame;
	float time;
	int statenum;
	int nextstate;
	state_func_t function;
};

struct mobjinfo_t
{
	int doomednum;
	classid class_id;
};

// Map Object definition.
class MapObject:Thinker
{
	// Info for drawing: position.
	TVec Origin;

	// Momentums, used to update position.
	TVec Velocity;

	TAVec Angles;		// orientation

	//More drawing info: to determine current sprite.
	int SpriteType;		//  How to draw sprite
	int SpriteIndex;	// used to find patch_t and flip value
	int SpriteFrame;	// might be ORed with FF_FULLBRIGHT

	int ModelIndex;
	int ModelFrame;
	int ModelSkinNum;

	int Translucency;
	int Translation;

	float FloorClip;	// value to use for floor clipping

	int Effects;

	subsector_t *SubSector;
	sector_t *Sector;

	// Interaction info, by BLOCKMAP.
	// Links in blocks (if needed).
	MapObject BlockMapNext;
	MapObject BlockMapPrev;

	// The closest interval over all contacted Sectors.
	float FloorZ;
	float CeilingZ;

	//  Closest floor and ceiling, source of floorz and ceilingz
	sec_plane_t *Floor;
	sec_plane_t *Ceiling;

	// If == validcount, already checked.
	int ValidCount;

	//	Flags
	bool bSolid;		// Blocks.
	bool bHidden;		// don't update to clients (invisible but touchable)
	bool bNoBlockmap;	// don't use the blocklinks (inert but displayable)
	bool bIsPlayer;		// PLayer or player-bot

	int Health;

	// For movement checking.
	float Radius;
	float Height;

	// Additional info record for player avatars only.
	// Only valid if type == MT_PLAYER
	player_t *Player;

	int TID;	// thing identifier
	int Special;	// special
	int Args[5];	// special arguments

	int NetID;

	void SetOrigin(TVec NewOrigin)
	{
		Origin = NewOrigin;
	}
}

typedef boolean(*thing_iter_func_t) (MapObject);

//==========================================================================
//
//  Player
//
//==========================================================================

class ViewEntity:Object
{
	int SpriteIndex;
	int SpriteFrame;
	int ModelIndex;
	int ModelFrame;
	int ModelSkinNum;
	float SX;
	float SY;
	int StateNum;	// a 0 state means not active
	int NextState;
	float StateTime;
	player_t *Player;

//===========================================================================
//
//  SetState
//
//===========================================================================

void SetState(int stnum)
{
	state_t *state;

	do
	{
		if (!stnum)
		{
			// Object removed itself.
			StateNum = 0;
			break;
		}
		state = &states[stnum];
		StateTime = state->time;	// could be 0
		SpriteIndex = state->sprite;
		SpriteFrame = state->frame;
		ModelIndex = state->model_index;
		ModelFrame = state->model_frame;
		StateNum = state->statenum;
		NextState = state->nextstate;
		if (state->function)
		{
			// Call action routine.
			state->function(self);
			if (!StateNum)
			{
				break;
			}
		}
		stnum = NextState;
	}
	while (!StateTime);	// An initial state of 0 could cycle through.
}

//==========================================================================
//
//  SetStateNF
//
//  Identical to SetState, without calling the action function
//
//==========================================================================

void SetStateNF(int stnum)
{
	state_t *state;

	do
	{
		if (!stnum)
		{	// Object removed itself.
			StateNum = 0;
			break;
		}
		state = &states[stnum];
		StateTime = state->time;	// could be 0
		SpriteIndex = state->sprite;
		SpriteFrame = state->frame;
		ModelIndex = state->model_index;
		ModelFrame = state->model_frame;
		StateNum = state->statenum;
		NextState = state->nextstate;
		stnum = NextState;
	}
	while (!StateTime);	// An initial state of 0 could cycle through.
}

defaultproperties
{
}

}

//
// Extended player object info: player_t
//
#define MAXNAME		32
#define MAX_MSGLEN	8000
struct player_t
{
	bool bActive;
	bool bSpawned;
	bool bIsBot;
	bool bFixAngle;
	bool bAttackDown;	// True if button down last tic.
	bool bUseDown;
	bool bDidSecret;	// True if secret level has been done.

	void *__NetCon;
	int __Message[7];
	int __MsgBuf[MAX_MSGLEN / 4];
	int __MobjUpdateStart;
	float __LastMessage;

	int UserInfo[MAX_INFO_STRING / 4];

	int Name[MAXNAME / 4];
	int BaseClass;
	int PClass;	// player class type
	int Color;

	// Copied from cmd, needed for PROGS, which supports only 4 byte ints
	float ForwardMove;	// *2048 for move
	float SideMove;	// *2048 for move
	float FlyMove;	// fly up/down/centering
	int Buttons;	// fire, use
	int Impulse;	// weapon changes, inventory, etc

	Actor *mo;
	int PlayerState;

	//  Model of current weapon
	int WeaponModel;

	// Determine POV,
	//  including viewpoint bobbing during movement.
	// Focal origin above r.z
	TVec ViewOrg;

	TAVec ViewAngles;

	// This is only used between levels,
	// mo->health is used during levels.
	int Health;

	int Items;

	// Frags, kills of other players.
	int Frags[MAXPLAYERS];

	// For intermission stats.
	int KillCount;
	int ItemCount;
	int SecretCount;

	// So gun flashes light up areas.
	int ExtraLight;

	// For lite-amp and invulnarability powers
	int FixedColormap;

	// Current PLAYPAL index
	//  can be set to REDCOLORMAP for pain, etc.
	int Palette;

	//  color shifts for damage, powerups and content types
	int CShifts[NUM_CSHIFTS];

	// Overlay view sprites (gun, etc).
	ViewEntity ViewEnts[NUMPSPRITES];
	float PSpriteSY;

	int WorldTimer;	// total time the player's been playing

	int OldStats[96];

	//  256 integers for user defined fields in PROGS
	addfields 256;
};

// Weapon info: sprite frames, ammunition use.
typedef void (*weapon_func_t) (player_t *);

//==========================================================================
//
//	Level
//
//==========================================================================

#define BlockLink(num)	(*level->BlockLinks[num])

struct sv_level_t:base_level_t
{
	// !!! Valid only during level loading
	int numthings;
	mthing_t *things;
	int behaviorsize;
	int *behavior;

	//
	//  BLOCKMAP
	//  Created from axis aligned bounding box of the map, a rectangular
	// array of blocks of size ...
	// Used to speed up collision detection by spatial subdivision in 2D.
	//
	void *__blockmaplump;	// offsets in blockmap are from here
	void *__blockmap;	// int for larger maps
	int bmapwidth;	// Blockmap size.
	int bmapheight;	// size in mapblocks
	float bmaporgx;	// origin of block map
	float bmaporgy;
	MapObject **BlockLinks;	// for thing chains
	void *__PolyBlockMap;

	//
	//  REJECT
	//  For fast sight rejection.
	//  Speeds up enemy AI by skipping detailed LineOf Sight calculation.
	//  Without special effect, this could be used as a PVS lookup as well.
	//
	void *__rejectmatrix;

	// Maintain single and multi player starting spots.
	mthing_t deathmatchstarts[MAXDEATHMATCHSTARTS];	// Player spawn spots for deathmatch.
	int numdeathmatchstarts;
	mthing_t playerstarts[MAX_PLAYER_STARTS * MAXPLAYERS];	// Player spawn spots.
};

//==========================================================================
//
//  Other stuff
//
//==========================================================================

struct opening_t
{
	float top;
	float bottom;
	float range;
	float lowfloor;
	sec_plane_t *floor;
	sec_plane_t *ceiling;
	opening_t *next;
};

#define PT_ADDLINES		1
#define PT_ADDTHINGS	2
#define PT_EARLYOUT		4

struct intercept_t
{
	float frac;	// along trace line
	boolean isaline;
	MapObject Thing;
	line_t *line;
};

typedef boolean(*trav_func_t) (intercept_t *);

//==========================================================================
//
//  ACS
//
//==========================================================================

#define MAX_ACS_SCRIPT_VARS	10
#define ACS_STACK_DEPTH 	32

class ACS:Thinker
{
	MapObject activator;
	line_t *line;
	int side;
	int number;
	int infoIndex;
	int delayCount;
	int stack[ACS_STACK_DEPTH];
	int stackPtr;
	int vars[MAX_ACS_SCRIPT_VARS];
	int *ip;

	native void Think(void);
	native void Archive(void);
	native void Unarchive(void);

	defaultproperties
	{
	}
}

addfields sector_t
{
	// 0 = untraversed, 1,2 = sndlines -1
	int soundtraversed;

	// thing that made a sound (or null)
	MapObject SoundTarget;

	// Thinker for reversable actions
	Thinker SpecialData;
};

#endif

//**************************************************************************
//
//  Client types
//
//**************************************************************************

#ifdef CLIENT

struct cl_level_t:base_level_t
{
};

struct model_t;

struct cl_pspdef_t
{
	int sprite;
	int frame;
	model_t *__alias_model;
	int alias_frame;
	int alias_skinnum;
	float sx;
	float sy;
};

struct client_state_t
{
	int clientnum;

	int pclass;	// player class type

	// Determine POV,
	//  including viewpoint bobbing during movement.
	// Focal origin above r.z
	TVec vieworg;
	TAVec viewangles;
	boolean centering;

	// This is only used between levels,
	// mo->health is used during levels.
	int health;

	int items;

	// Frags, kills of other players.
	int frags[MAXPLAYERS];

	// So gun flashes light up areas.
	int extralight;

	// For lite-amp and invulnarability powers
	int fixedcolormap;

	// Current PLAYPAL index
	//  can be set to REDCOLORMAP for pain, etc.
	int palette;

	int cshifts[NUM_CSHIFTS];	//  color shifts for damage,
	int prev_cshifts[NUM_CSHIFTS];	// powerups and content types

	// Overlay view sprites (gun, etc).
	cl_pspdef_t psprites[NUMPSPRITES];
	float pspriteSY;

	// True if secret level has been done.
	boolean didsecret;

	int worldTimer;	// total time the player's been playing

	boolean paused;

	// Overlay view sprites (gun, etc).
	int translucency;

	int maxclients;
	int deathmatch;

	float time;

	int serverinfo[MAX_INFO_STRING / 4];

	int intermission;

	//  128 integers for user defined fields in PROGS
	addfields 128;
};

//
//  Input Text Line widget
//

#define MAX_ILINE_LENGTH	79

struct TILine
{
	int Data[(MAX_ILINE_LENGTH + 1) / 4];	// line of text
	int len;	// current line length
	int lm;	// left margin past which I am not to delete characters
};

//
//  Server list
//

#define HOSTCACHESIZE		8

struct hostcache_t
{
	int Name[16 / 4];
	int map[16 / 4];
	int cname[32 / 4];
	int wadfiles[20][16 / 4];
	int users;
	int maxusers;
};

struct slist_t
{
	boolean inProgress;
	int count;
	hostcache_t cache[HOSTCACHESIZE];
	int return_reason[32 / 4];
};

typedef void (*mb_func_t) (int key);

struct scores_t
{
	int Name[64 / 4];
	boolean active;
	int frags[MAXPLAYERS];
	int killcount;
	int itemcount;
	int secretcount;
	float time;
	int userinfo[MAX_INFO_STRING / 4];
};

struct im_t
{
	int leavemap[12 / 4];
	int leavecluster;
	int entermap[12 / 4];
	int entercluster;
	int leave_name[32 / 4];
	int enter_name[32 / 4];
	int totalkills;
	int totalitems;
	int totalsecret;
	float time;
};

struct picinfo_t
{
	int width;
	int height;
	int xoffset;
	int yoffset;
};

struct dlight_t
{
	TVec origin;
	float radius;
	float die;	// stop lighting after this time
	float decay;	// drop this each second
	float minlight;	// don't add when contributing less
	int key;
	int color;
};

struct particle_t
{
	TVec org;
	int color;
	particle_t *next;
	TVec vel;
	float die;
	addfields 7;
};

struct clmobj_t
{
	boolean in_use;

	TVec origin;	// position
	TAVec angles;	// orientation

	int spritetype;	//  How to draw sprite
	int sprite;	// used to find patch_t and flip value
	int frame;	// might be ORed with FF_FULLBRIGHT

	int model_index;
	model_t *__alias_model;
	int alias_frame;
	int skin[64 / 4];

	int translucency;
	int translation;

	int effects;
};

#endif

//**************************************************************************
//
//  $Log$
//  Revision 1.32  2002/02/22 18:00:05  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.31  2002/02/16 16:27:44  dj_jl
//  Added bool variables
//
//  Revision 1.30  2002/02/14 19:20:54  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.29  2002/02/06 17:28:50  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.28  2002/02/02 19:17:25  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.27  2002/01/21 18:21:32  dj_jl
//  Working on object-oriented menus
//
//  Revision 1.26  2002/01/17 18:15:50  dj_jl
//  Renamed all map object classes
//
//  Revision 1.25  2002/01/15 18:26:58  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.24  2002/01/15 08:12:25  dj_jl
//  Replaced some pointers with references
//
//  Revision 1.23  2002/01/11 08:03:09  dj_jl
//  Renamed 'name' to "Name'
//
//  Revision 1.22  2002/01/07 12:19:56  dj_jl
//  Changed copyright year
//
//  Revision 1.21  2001/12/27 17:52:19  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.20  2001/12/18 18:38:11  dj_jl
//  Base object got some new fields, new thinker list
//
//  Revision 1.19  2001/12/12 19:15:27  dj_jl
//  Some little changes for state methods
//
//  Revision 1.18  2001/12/01 18:10:10  dj_jl
//  Started to use class references
//
//  Revision 1.17  2001/10/22 17:23:08  dj_jl
//  Floatification of angles
//
//  Revision 1.16  2001/10/18 17:39:33  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.15  2001/10/12 17:26:06  dj_jl
//  Removed Actor define
//
//  Revision 1.14  2001/10/09 17:38:36  dj_jl
//  Got rid of mobj addfields
//
//  Revision 1.13  2001/10/08 17:23:15  dj_jl
//  Different client and server level structures
//
//  Revision 1.12  2001/10/04 17:28:47  dj_jl
//  Fixed thinkers size in level structure
//
//  Revision 1.11  2001/10/02 17:37:19  dj_jl
//  Removed status bar widgets
//
//  Revision 1.10  2001/09/27 17:08:19  dj_jl
//  Removed spawn functions, added mobj classes
//
//  Revision 1.9  2001/09/25 17:13:50  dj_jl
//  Beautification
//
//  Revision 1.8  2001/09/24 17:11:23  dj_jl
//  Created thinker classes
//
//  Revision 1.7  2001/09/20 16:19:59  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.6  2001/08/29 17:42:12  dj_jl
//  Added sound channel
//  
//  Revision 1.5  2001/08/15 17:07:10  dj_jl
//  Fixed finale
//
//  Revision 1.4  2001/08/07 16:42:25  dj_jl
//  Added player models, skins and weapon
//
//  Revision 1.3  2001/08/04 17:20:28  dj_jl
//  Changes to inform new clients about changed textures
//
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
