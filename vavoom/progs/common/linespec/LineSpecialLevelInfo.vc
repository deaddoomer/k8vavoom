//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id: DoomLevelInfo.vc 1744 2006-10-01 12:40:46Z dj_jl $
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class LineSpecialLevelInfo : LevelInfo;

name			DefaultDoorSound;
name			DefaultCeilingSound;
name			DefaultSilentCeilingSound;
name			DefaultFloorSound;
name			DefaultFloorAltSound;
name			DefaultStairStepSound;
name			DefaultPlatformSound;

//==========================================================================
//
//  ExecuteActionSpecial
//
//==========================================================================

bool ExecuteActionSpecial(int Special, int Arg1, int Arg2, int Arg3,
	int Arg4, int Arg5, line_t* Line, int Side, Entity A)
{
	bool buttonSuccess = false;
	switch (Special)
	{
//LNSPEC_PolyDoorSlide:
	case LNSPEC_DoorClose:
		buttonSuccess = EV_DoDoor(Arg1, Arg2, Arg3, Arg4, Arg5,
			VerticalDoor::DOOREV_Close, Line, A);
		break;
	case LNSPEC_DoorOpen:
		buttonSuccess = EV_DoDoor(Arg1, Arg2, Arg3, Arg4, Arg5,
			VerticalDoor::DOOREV_Open, Line, A);
		break;
	case LNSPEC_DoorRaise:
		buttonSuccess = EV_DoDoor(Arg1, Arg2, Arg3, Arg4, Arg5,
			VerticalDoor::DOOREV_Raise, Line, A);
		break;
	case LNSPEC_DoorLockedRaise:
		if (CheckLock(A, Arg4))
		{
			buttonSuccess = EV_DoDoor(Arg1, Arg2, Arg3, Arg4, Arg5,
				VerticalDoor::DOOREV_RaiseLocked, Line, A);
		}
		break;
	case LNSPEC_FloorLowerByValue:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_LowerByValue, Line);
		break;
	case LNSPEC_FloorLowerToLowest:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_LowerToLowest, Line);
		break;
	case LNSPEC_FloorLowerToNearest:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_LowerToNearest, Line);
		break;
	case LNSPEC_FloorRaiseByValue:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_RaiseByValue, Line);
		break;
	case LNSPEC_FloorRaiseToHighest:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_RaiseToHighest, Line);
		break;
	case LNSPEC_FloorRaiseToNearest:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_RaiseToNearest, Line);
		break;
	case LNSPEC_StairsBuildDownNormal:
		buttonSuccess = EV_BuildStairs(Arg1, Arg2, Arg3, Arg4, Arg5,
			StairStepMover::STAIRSEV_DownNormal);
		break;
	case LNSPEC_StairsBuildUpNormal:
		buttonSuccess = EV_BuildStairs(Arg1, Arg2, Arg3, Arg4, Arg5,
			StairStepMover::STAIRSEV_UpNormal);
		break;
	case LNSPEC_FloorRaiseAndCrush:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_RaiseAndCrush, Line);
		break;
//LNSPEC_PillarBuild:
//LNSPEC_PillarOpen:
	case LNSPEC_StairsBuildDownSync:
		buttonSuccess = EV_BuildStairs(Arg1, Arg2, Arg3, Arg4, Arg5,
			StairStepMover::STAIRSEV_DownSync);
		break;
	case LNSPEC_StairsBuildUpSync:
		buttonSuccess = EV_BuildStairs(Arg1, Arg2, Arg3, Arg4, Arg5,
			StairStepMover::STAIRSEV_UpSync);
		break;
//LNSPEC_ForceField:
//LNSPEC_ClearForceField:
	case LNSPEC_FloorRaiseByValueTimes8:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_RaiseByValueTimes8, Line);
		break;
	case LNSPEC_FloorLowerByValueTimes8:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_LowerByValueTimes8, Line);
		break;
	case LNSPEC_CeilingWaggle:
		buttonSuccess = EV_StartCeilingWaggle(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
//LNSPEC_TeleportZombieChanger:
	case LNSPEC_CeilingLowerByValue:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_LowerByValue, Line);
		break;
	case LNSPEC_CeilingRaiseByValue:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_RaiseByValue, Line);
		break;
	case LNSPEC_CeilingCrushAndRaise:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_CrushAndRaise, Line);
		break;
	case LNSPEC_CeilingLowerAndCrush:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_LowerAndCrush, Line);
		break;
	case LNSPEC_CeilingCrushStop:
		buttonSuccess = EV_CeilingCrushStop(Line, Arg1, Arg2, Arg3, Arg4,
			Arg5);
		break;
	case LNSPEC_CeilingCrushRaiseAndStay:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_CrushRaiseAndStay, Line);
		break;
	case LNSPEC_FloorCrushStop:
		buttonSuccess = EV_FloorCrushStop(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_PlatPerpetualRaise:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			Platform::PLATEV_PerpetualRaise, Line);
		break;
	case LNSPEC_PlatStop:
		buttonSuccess = EV_StopPlat(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_PlatDownWaitUpStay:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			Platform::PLATEV_DownWaitUpStay, Line);
		break;
	case LNSPEC_PlatDownByValueWaitUpStay:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			Platform::PLATEV_DownByValueWaitUpStay, Line);
		break;
	case LNSPEC_PlatUpWaitDownStay:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			Platform::PLATEV_UpWaitDownStay, Line);
		break;
	case LNSPEC_PlatUpByValueWaitDownStay:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			Platform::PLATEV_UpByValueWaitDownStay, Line);
		break;
	case LNSPEC_FloorLowerTimes8Instant:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_LowerTimes8Instant, Line);
		break;
	case LNSPEC_FloorRaiseTimes8Instant:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_RaiseTimes8Instant, Line);
		break;
	case LNSPEC_FloorMoveToValueTimes8:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_MoveToValueTimes8, Line);
		break;
	case LNSPEC_CeilingMoveToValueTimes8:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_MoveToValueTimes8, Line);
		break;
//LNSPEC_Teleport:
//LNSPEC_ThingSpawnNoFog:
	case LNSPEC_FloorWaggle:
		buttonSuccess = EV_StartFloorWaggle(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
//LNSPEC_SectorSoundChange:
	case LNSPEC_PlaneUpNearestWaitDownStay:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			Platform::PLATEV_UpNearestWaitDownStay, Line);
		break;
//LNSPEC_NoiseAlert:
	case LNSPEC_CeilingLowerToHighestFloor:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_LowerToHighestFloor, Line);
		break;
	case LNSPEC_CeilingLowerInstant:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_LowerTimes8Instant, Line);
		break;
	case LNSPEC_CeilingRaiseInstant:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_RaiseTimes8Instant, Line);
		break;
	case LNSPEC_CeilingCrushRaiseAndStayA:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_CrushRaiseAndStayA, Line);
		break;
	case LNSPEC_CeilingCrushAndRaiseA:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_CrushAndRaiseA, Line);
		break;
	case LNSPEC_CeilingCrushAndRaiseSilentA:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_CrushAndRaiseSilA, Line);
		break;
	case LNSPEC_CeilingRaiseByValueTimes8:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_RaiseByValueTimes8, Line);
		break;
	case LNSPEC_CeilingLowerByValueTimes8:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_LowerByValueTimes8, Line);
		break;
	case LNSPEC_FloorGeneric:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_Generic, Line);
		break;
	case LNSPEC_CeilingGeneric:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_Generic, Line);
		break;
	case LNSPEC_DoorGeneric:
		buttonSuccess = EV_GenericDoor(Arg1, Arg2, Arg3, Arg4, Arg5, Line, A);
		break;
	case LNSPEC_PlatGeneric:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			Platform::PLATEV_Generic, Line);
		break;
	case LNSPEC_StairsGeneric:
		buttonSuccess = EV_BuildStairsOld(Arg1, Arg2, Arg3, Arg4, Arg5,
			true, Line);
		break;
	case LNSPEC_CeilingGenericCrush:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_GenericCrush, Line);
		break;
	case LNSPEC_PlatDownWaitUpStayLip:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			Platform::PLATEV_DownWaitUpStayLip, Line);
		break;
	case LNSPEC_PlatPerpetualRaiseLip:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			Platform::PLATEV_PerpetualRaiseLip, Line);
		break;
//LNSPEC_SectorSetDamage:
//LNSPEC_TeleportLine:
	case LNSPEC_StairsBuildUpDoom:
		buttonSuccess = EV_BuildStairsOld(Arg1, Arg2, Arg3, Arg4, Arg5,
			false, Line);
		break;
//LNSPEC_SectorSetWind:
//LNSPEC_ACSExecuteAlways:
	case LNSPEC_FloorRaiseToNearestChange:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_RaiseToNearestChange, Line);
		break;
	case LNSPEC_FloorRaiseByValueChangeTex:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_RaiseByValueChange2, Line);
		break;
	case LNSPEC_PlatToggle:
		buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5,
			Platform::PLATEV_Toggle, Line);
		break;
//LNSPEC_LightStrobeDoom:
//LNSPEC_FloorTransferNumeric:
	case LNSPEC_FloorRaiseToLowestCeiling:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_RaiseToLowestCeiling, Line);
		break;
	case LNSPEC_FloorRaiseByValueChange:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_RaiseByValueChange, Line);
		break;
	case LNSPEC_FloorRaiseByTexture:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_RaiseByTexture, Line);
		break;
	case LNSPEC_FloorLowerToLowestChange:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_LowerToLowestChange, Line);
		break;
	case LNSPEC_FloorLowerToHighest:
		buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5,
			FloorMover::FLOOREV_LowerToHighest, Line);
		break;
//LNSPEC_ExitNormal:
//LNSPEC_ElevatorLowerToNearest:
	case LNSPEC_DoorCloseWaitOpen:
		buttonSuccess = EV_DoDoor(Arg1, Arg2, Arg3, Arg4, Arg5,
			VerticalDoor::DOOREV_CloseWaitOpen, Line, A);
		break;
	case LNSPEC_FloorDonut:
		buttonSuccess = EV_DoDonut(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
	case LNSPEC_FloorAndCeilingLowerRaise:
		buttonSuccess = EV_DoCeiling(Arg1, Arg3, 0, 0, 0,
			CeilingMover::CEILEV_RaiseToHighest, Line);
		buttonSuccess |= EV_DoFloor(Arg1, Arg2, 0, 0, 0,
			FloorMover::FLOOREV_LowerToLowest, Line);
		break;
	case LNSPEC_CeilingRaiseToNearest:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_RaiseToNearest, Line);
		break;
	case LNSPEC_CeilingLowerToLowest:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_LowerToLowest, Line);
		break;
	case LNSPEC_CeilingLowerToFloor:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_LowerToFloor, Line);
		break;
	case LNSPEC_CeilingCrushRaiseAndStaySilentA:
		buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5,
			CeilingMover::CEILEV_CrushRaiseAndStaySilA, Line);
		break;
	}
	return buttonSuccess;
}

//**************************************************************************
//
//  Doors
//
//**************************************************************************

//==========================================================================
//
//  EV_DoDoor
//
//  Move a door up/down
//
//==========================================================================

int EV_DoDoor(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type,
	line_t* Line, Entity Thing)
{
	int				SecNum;
	int				RetCode;
	sector_t*		Sec;
	VerticalDoor	Door;

	RetCode = false;
	if (!Arg1)
	{
		if (!Line)
			return false;
	
		//	Make sure it's a two-sided line.
		if (Line->sidenum[1] < 0)
			return false;
	
		// if the sector has an active thinker, use it
		Sec = XLevel.Sides[Line->sidenum[1]].sector;
		if (Sec->CeilingData)
		{
			Door = VerticalDoor(Sec->CeilingData);
			if (Door)
			{
				return Door.ReUse(Type, Line, Thing);
			}
			return false;
		}
	
		// new door thinker
		Door = VerticalDoor(NewSpecialThinker(VerticalDoor));
		Door.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type);
		RetCode = true;
	}
	else
	{
		for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
			SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
		{
			Sec = &XLevel.Sectors[SecNum];
			if (Sec->CeilingData)
			{
				continue;
			}
			// Add new door thinker
			RetCode = true;
			Door = VerticalDoor(NewSpecialThinker(VerticalDoor));
			Door.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type);
		}
	}
	return RetCode;
}

//==========================================================================
//
//  EV_GenericDoor
//
//	Boom's generic doors.
//
//==========================================================================

int EV_GenericDoor(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	line_t* Line, Entity Thing)
{
	int			Tag;
	int			LightTag;

	//	Check for locked door.
	if (Arg5 && !CheckLock(Thing, Arg5))
	{
		return false;
	}

	//	Check for Boom's local door light special.
	if (Arg3 & 128)
	{
		Tag = 0;
		LightTag = Arg1;
	}
	else
	{
		Tag = Arg1;
		LightTag = 0;
	}

	switch (Arg3 & 127)
	{
	case 0:
		return EV_DoDoor(Tag, Arg2, Arg4, LightTag, 0,
			VerticalDoor::DOOREV_Raise, Line, Thing);
	case 1:
		return EV_DoDoor(Tag, Arg2, LightTag, 0, 0,
			VerticalDoor::DOOREV_Open, Line, Thing);
	case 2:
		return EV_DoDoor(Tag, Arg2, Arg4, LightTag, 0,
			VerticalDoor::DOOREV_CloseWaitOpen, Line, Thing);
	case 3:
		return EV_DoDoor(Tag, Arg2, LightTag, 0, 0,
			VerticalDoor::DOOREV_Close, Line, Thing);
	}
	return false;
}

//==========================================================================
//
//  SpawnDoorCloseIn30
//
//  Spawn a door that closes after 30 seconds
//
//==========================================================================

void SpawnDoorCloseIn30(sector_t* sec)
{
	VerticalDoor	Door;

	Door = VerticalDoor(NewSpecialThinker(VerticalDoor));
	Door.InitCloseIn30(sec);
	sec->special = 0;
}

//==========================================================================
//
//  SpawnDoorRaiseIn5Mins
//
//  Spawn a door that opens after 5 minutes
//
//==========================================================================

void SpawnDoorRaiseIn5Mins(sector_t* sec)
{
	VerticalDoor Door;

	sec->special = 0;
	Door = VerticalDoor(NewSpecialThinker(VerticalDoor));
	Door.Init(sec, 0, 16, 150, 0, 0, VerticalDoor::DOOREV_RaiseIn5Mins);
}

//**************************************************************************
//
//	Ceilings
//
//**************************************************************************

//==========================================================================
//
//  EV_DoCeiling
//
//  Move a ceiling up/down and all around!
//
//==========================================================================

int EV_DoCeiling(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type,
	line_t* Line)
{
	int				SecNum;
	int				Rtn;
	sector_t*		Sec;
	CeilingMover	Ceiling;

	Rtn = false;

	if (!Arg1)
	{
		if (!Line || !Line->backsector)
			return false;

		//  Reactivate in-stasis ceilings...for certain types.
		if ((Type == CeilingMover::CEILEV_CrushAndRaiseA ||
			Type == CeilingMover::CEILEV_CrushAndRaiseSilA) &&
			CeilingMover(Line->backsector->CeilingData))
		{
			CeilingMover(Line->backsector->CeilingData).ActivateInStasis(0);
		}

		if (!Line->backsector->CeilingData)
		{
			// new ceiling thinker
			Rtn = true;
			Ceiling = CeilingMover(NewSpecialThinker(CeilingMover));
			Ceiling.Init(Line->backsector, Arg1, Arg2, Arg3, Arg4, Arg5,
				Type, Line);
		}
	}
	else
	{
		//  Reactivate in-stasis ceilings...for certain types.
		if (Type == CeilingMover::CEILEV_CrushAndRaiseA ||
			Type == CeilingMover::CEILEV_CrushAndRaiseSilA)
		{
			FOREACH(CeilingMover, Ceiling)
			{
				Ceiling.ActivateInStasis(Arg1);
			}
		}

		for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
			SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
		{
			Sec = &XLevel.Sectors[SecNum];
			if (Sec->CeilingData)
				continue;

			// new ceiling thinker
			Rtn = true;
			Ceiling = CeilingMover(NewSpecialThinker(CeilingMover));
			Ceiling.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type, Line);
		}
	}
	return Rtn;
}

//==========================================================================
//
//  EV_CeilingCrushStop
//
//  Stop a ceiling from crushing!
//
//==========================================================================

int EV_CeilingCrushStop(line_t* line, int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5)
{
	int				rtn;
	CeilingMover	Ceiling;

	rtn = false;
	FOREACH(CeilingMover, Ceiling)
	{
		if (Ceiling.CrushStop(Arg1))
		{
			rtn = true;
		}
	}
	return rtn;
}

//==========================================================================
//
//	EV_StartCeilingWaggle
//
//==========================================================================

bool EV_StartCeilingWaggle(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int				SectorIndex;
	sector_t*		Sector;
	CeilingWaggle	Waggle;
	bool			RetCode;

	RetCode = false;
	for (SectorIndex = XLevel.FindSectorFromTag(Arg1, -1); SectorIndex >= 0;
		SectorIndex = XLevel.FindSectorFromTag(Arg1, SectorIndex))
	{
		Sector = &XLevel.Sectors[SectorIndex];
		if (Sector->CeilingData)
		{
			// Already busy with another thinker
			continue;
		}
		RetCode = true;
		Waggle = CeilingWaggle(NewSpecialThinker(CeilingWaggle));
		Waggle.Init(Sector, Arg1, Arg2, Arg3, Arg4, Arg5);
	}
	return RetCode;
}

//**************************************************************************
//
//	Floors
//
//**************************************************************************

//==========================================================================
//
//  EV_DoFloor
//
//  HANDLE FLOOR TYPES
//
//==========================================================================

int EV_DoFloor(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type,
	line_t* Line)
{
	int			SecNum;
	int			Rtn;
	sector_t*	Sec;
	FloorMover	Floor;

	Rtn = false;
	if (!Arg1)
	{
		if (!Line || !Line->backsector)
			return false;

		if (!Line->backsector->FloorData)
		{
			// new floor thinker
			Rtn = true;
			Floor = FloorMover(NewSpecialThinker(FloorMover));
			Floor.Init(Line->backsector, Arg1, Arg2, Arg3, Arg4, Arg5, Type,
				Line);
		}
	}
	else
	{
		for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
			SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
		{
			Sec = &XLevel.Sectors[SecNum];

			// ALREADY MOVING?  IF SO, KEEP GOING...
			if (Sec->FloorData)
				continue;

			// new floor thinker
			Rtn = true;
			Floor = FloorMover(NewSpecialThinker(FloorMover));
			Floor.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type, Line);
		}
	}
	return Rtn;
}

//==========================================================================
//
// EV_FloorCrushStop
//
//==========================================================================

int EV_FloorCrushStop(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	FloorMover	Floor;
	bool		Rtn;

	Rtn = false;
	FOREACH(FloorMover, Floor)
	{
		if (Floor.CrushStop(Arg1))
		{
			Rtn = true;
		}
	}
	return Rtn;
}

//==========================================================================
//
//  EV_DoDonut()
//
//  Handle donut function: lower pillar, raise surrounding pool, both to
// height, texture and type of the sector surrounding the pool.
//  Passed the linedef that triggered the donut
//  Returns whether a thinker was created
//
//==========================================================================

int EV_DoDonut(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	sector_t*	s1;
	sector_t*	s2;
	sector_t*	s3;
	int			secnum;
	int			rtn;
	int			i;
	FloorMover	Floor;

	rtn = 0;
	// do function on all sectors with same tag as linedef
	for (secnum = XLevel.FindSectorFromTag(Arg1, -1); secnum >= 0;
		secnum = XLevel.FindSectorFromTag(Arg1, secnum))
	{
		s1 = &XLevel.Sectors[secnum];	// s1 is pillar's sector

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (s1->FloorData)
			continue;

		s2 = getNextSector(s1->lines[0], s1);	// s2 is pool's sector
		rtn = 1;

		// find a two sided line around the pool whose other side isn't the pillar
		for (i = 0; i < s2->linecount; i++)
		{
			if ((!s2->lines[i]->flags & ML_TWOSIDED) ||
				(s2->lines[i]->backsector == s1))
				continue;
			s3 = s2->lines[i]->backsector;

			//  Spawn rising slime
			Floor = FloorMover(NewSpecialThinker(FloorMover));
			Floor.InitDonut(s2, s3, Arg2);

			//  Spawn lowering donut-hole
			Floor = FloorMover(NewSpecialThinker(FloorMover));
			Floor.InitDonut2(s1, s3, Arg3);
			break;
		}
	}
	return rtn;
}

//==========================================================================
//
//	EV_StartFloorWaggle
//
//==========================================================================

bool EV_StartFloorWaggle(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	int				SectorIndex;
	sector_t*		Sector;
	FloorWaggle		Waggle;
	bool			RetCode;

	RetCode = false;
	for (SectorIndex = XLevel.FindSectorFromTag(Arg1, -1); SectorIndex >= 0;
		SectorIndex = XLevel.FindSectorFromTag(Arg1, SectorIndex))
	{
		Sector = &XLevel.Sectors[SectorIndex];
		if (Sector->FloorData)
		{
			// Already busy with another thinker
			continue;
		}
		RetCode = true;
		Waggle = FloorWaggle(NewSpecialThinker(FloorWaggle));
		Waggle.Init(Sector, Arg1, Arg2, Arg3, Arg4, Arg5);
	}
	return RetCode;
}

//**************************************************************************
//
//	Stairs
//
//**************************************************************************

//==========================================================================
//
//	EV_BuildStairsOld
//
//	Build a staircase!
//
//==========================================================================

int EV_BuildStairsOld(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	bool Generic, line_t* Line)
{
	int			SecNum;
	float		Height;
	int			i;
	int			j;
	int			Ok;
	int			Texture;
	int			Rtn;
	sector_t*	Sec;
	sector_t*	TSec;
	FloorMover	Floor;
	line_t*		SecLine;
	int			Direction;
	float		StairSize;
	bool		IgnTxt;
	int			OldSecNum;

	if (!Arg1 && (!Line || !Line->backsector))
		return false;

	if (Generic)
	{
		Direction = Arg4 & 1 ? 1 : -1;
		IgnTxt = !!(Arg4 & 2);
	}
	else
	{
		Direction = 1;
		IgnTxt = false;
	}
	StairSize = itof(Arg3 * Direction);
	Rtn = 0;
	for (SecNum = Arg1 ? XLevel.FindSectorFromTag(Arg1, -1) : 1; SecNum >= 0;
		SecNum = Arg1 ? XLevel.FindSectorFromTag(Arg1, SecNum) : -1)
	{
		Sec = Arg1 ? &XLevel.Sectors[SecNum] : Line->backsector;

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (Sec->FloorData)
			continue;

		// new floor thinker
		Rtn = 1;
		Height = GetPlanePointZ(&Sec->floor, vector(0.0, 0.0, 0.0)) +
			StairSize;
		Floor = FloorMover(NewSpecialThinker(FloorMover));
		Floor.InitStair(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Generic, Height);

		Texture = Sec->floor.pic;
		OldSecNum = SecNum;	//jff 3/4/98 preserve loop index

		// Find next sector to raise
		// 1. Find 2-sided line with same sector side[0]
		// 2. Other side is the next sector to raise
		// 3. Unless already moving, or different texture, then stop building
		do
		{
			Ok = false;
			for (i = 0; i < Sec->linecount; i++)
			{
				SecLine = Sec->lines[i];

				if (!(SecLine->flags & ML_TWOSIDED))
					continue;

				TSec = SecLine->frontsector;
				if (Sec != TSec)
					continue;
				TSec = SecLine->backsector;
				if (!TSec)
					continue;	//jff 5/7/98 if no backside, continue
				if (!IgnTxt && TSec->floor.pic != Texture)
					continue;

				Height += StairSize;
				if (TSec->FloorData)
					continue;

				Sec = TSec;
				//	SecNum = TSec - XLevel.Sectors;
				for (j = 0; j < XLevel.NumSectors; j++)
				{
					if (TSec == &XLevel.Sectors[j])
					{
						SecNum = j;
						break;
					}
				}
				Floor = FloorMover(NewSpecialThinker(FloorMover));
				Floor.InitStair(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Generic,
					Height);
				Ok = true;
				break;
			}
		}
		while (Ok);
		SecNum = OldSecNum;	//jff 3/4/98 restore loop index
	}
	return Rtn;
}

//==========================================================================
//
//	EV_BuildStairs
//
//	Build a staircase!
//
//	StairDirection is either positive or negative, denoting build stairs
// up or down.
//
//==========================================================================

int EV_BuildStairs(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	int StairsType)
{
	int				SecNum;
	sector_t*		Sec;
	StairStepMover	StairStep;
	StairStepMover	StairQueueHead;

	StairQueueHead = none;
	for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &XLevel.Sectors[SecNum];

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (Sec->FloorData)
			continue;

		StairStep = StairStepMover(NewSpecialThinker(StairStepMover));
		StairStep.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5,
			StairsType);
		if (StairQueueHead)
		{
			StairQueueHead.AppendToQueue(StairStep);
		}
		else
		{
			StairQueueHead = StairStep;
		}
		Sec->special &= ~SECSPEC_BASE_MASK;
	}
	for (StairStep = StairQueueHead; StairStep;
		StairStep = StairStep.QueueNext)
	{
		StairStep.ProcessStairSector();
	}
	return 1;
}

//**************************************************************************
//
//	Platforms
//
//**************************************************************************

//==========================================================================
//
//  EV_DoPlat
//
//  Do Platforms.
//
//==========================================================================

int EV_DoPlat(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type,
	line_t* Line)
{
	Platform	Plat;
	int			SecNum;
	int			Rtn;
	sector_t*	Sec;

	Rtn = false;

	if (!Arg1)
	{
		if (!Line || !Line->backsector)
			return false;

		//  Activate all <type> plats that are in stasis.
		if ((Type == Platform::PLATEV_PerpetualRaise ||
			Type == Platform::PLATEV_PerpetualRaiseLip ||
			Type == Platform::PLATEV_Toggle) && Platform(Line->backsector->FloorData))
		{
			//  Activate in stasis
			Platform(Line->backsector->FloorData).ActivateInStasis(Arg1);
			if (Type == Platform::PLATEV_Toggle)
			{
				Rtn = true;
			}
		}

		if (!Line->backsector->FloorData)
		{
			// Find lowest & highest floors around sector
			Rtn = 1;
			Plat = Platform(NewSpecialThinker(Platform));
			Plat.Init(Line->backsector, Arg1, Arg2, Arg3, Arg4, Arg5, Type);
		}
	}
	else
	{
		//  Activate all <type> plats that are in stasis.
		if (Type == Platform::PLATEV_PerpetualRaise ||
			Type == Platform::PLATEV_PerpetualRaiseLip ||
			Type == Platform::PLATEV_Toggle)
		{
			//  Activate in stasis
			FOREACH(Platform, Plat)
			{
				Plat.ActivateInStasis(Arg1);
			}
			if (Type == Platform::PLATEV_Toggle)
			{
				Rtn = true;
			}
		}

		for (SecNum = XLevel.FindSectorFromTag(Arg1, -1); SecNum >= 0;
			SecNum = XLevel.FindSectorFromTag(Arg1, SecNum))
		{
			Sec = &XLevel.Sectors[SecNum];
			if (Sec->FloorData)
				continue;

			// Find lowest & highest floors around sector
			Rtn = 1;
			Plat = Platform(NewSpecialThinker(Platform));
			Plat.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type);
		}
	}
	return Rtn;
}

//==========================================================================
//
//  EV_StopPlat
//
//==========================================================================

int EV_StopPlat(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	Platform	Plat;

	FOREACH(Platform, Plat)
	{
		Plat.StopPlat(Arg1);
	}
	return 1;
}

//==========================================================================
//
//  CheckLock
//
//==========================================================================

bool CheckLock(Entity user, int lock)
{
}

defaultproperties
{
}
