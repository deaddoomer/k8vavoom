//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id: Entity.vc 1755 2006-10-03 19:24:11Z dj_jl $
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class EntityEx : Entity
	abstract;

const float ONFLOORZ		= -99999.0;
const float ONCEILINGZ		= 99999.0;

const float FRICTION_NORMAL	= 3.28125;
const float FRICTION_LOW	= 0.95703125;
const float FRICTION_FLY	= 2.87109375;
const float FRICTION_WATER	= 3.0;

const float MAXMOVE			= 1050.0;
const float MAXMOVESTEP		= MAXMOVE / (35.0 * 2.0);
const float STOPSPEED		= 2.1875;

const float BOUNCE_VAL		= 1.5;

enum
{
	BOUNCE_None,
	BOUNCE_Doom,
	BOUNCE_Heretic,
	BOUNCE_Hexen
};

//  States
state			IdleState;
state			SeeState;
state			MeleeState;
state			MissileState;
state			PainState;
state			WoundState;
state			DeathState;
state			GibsDeathState;
state			IceDeathState;
state			FireDeathState;
state			DisruptDeathState;
state			CrashState;
state			RaiseState;

//	Sounds
name			SightSound;
name			ActiveSound;
name			AttackSound;
name			PainSound;
name			DeathSound;

//	Flags
bool bSpecial;			// call P_SpecialThing when touched
bool bShootable;		// Can be hit.
bool bAmbush;
bool bJustHit;			// try to attack right back
bool bJustAttacked;		// take at least one step before attacking
bool bSpawnCeiling;		// hang from ceiling instead of floor
// movement flags
bool bPickUp;			// for players to pick up items
bool bMissile;			// don't hit same species, explode on block
bool bDropped;			// dropped by a demon, not level spawned
bool bNoBlood;			// don't bleed when shot (use puff)
bool bInFloat;			// floating to a height for a move, don't
						// auto float to target's height
bool bSkullFly;			// skull in flight
bool bCountKill;		// count towards intermission kill total
bool bCountItem;		// count towards intermission item total
bool bWindThrust;		// gets pushed around by the wind specials
bool bActivateImpact;	// an MF_MISSILE mobj can activate
						// SPAC_IMPACT
bool bActivatePushWall;	// mobj can push walls
bool bActivateMCross;	// can activate monster cross lines
bool bActivatePCross;	// can activate projectile cross lines
bool bDormant;			// thing is dormant
bool bWaterJump;
bool bNoTeleport;		// does not teleport
bool bTelestomp;		// mobj can stomp another
bool bCannotPush;		// cannot push other pushable mobjs
bool bSmallSplash;		// Always use small splash
bool bNoSplash;			// Things that don't splash
bool bStaticLight;		// Static light source.
bool bTriggerHappy;
bool bBlaster;
bool bFloatBob;			// use float bobbing z movement
bool bOnmobjCopyVel;
bool bNoBounceSound;	//	Don't make sound when bouncing
bool bNoWallBounceSnd;	//	Don't make sound when bouncing off a wall
bool bBounceSky;		//	Bounce when hitting the sky
bool bExplodeOnSky;		//	Explodes when hits the sky
bool bBounceOnActors;	//	Bounces against other actors
bool bSlide;			// slides against walls
bool bReflective;		// reflects missiles
bool bSeekerMissile;	// is a seeker (for reflection)
bool bNoExplodeFloor;	//	Don't explode when hitting the floor
bool bIceDamage;		// does ice damage
bool bIceCorpse;		// a frozen corpse (for blasting)
bool bExplodeOnWater;	//	Explode on water surfaces
bool bCanBounceWater;	//	Bounce on water surfaces
bool bFallingFriction;	//	Apply friction while falling

//  Params
float			Speed;
float			StepSpeed;
float			FloatSpeed;
float			PainChance;
int				GibsHealth;

float			MissileChance;
float			MissileMinRange;
float			MissileMaxRange;

byte			BounceType;
byte			BounceCount;
float			BounceFactor;

// Thing being chased/attacked (or NULL).
// Also the originator for missiles.
EntityEx		Target;
EntityEx		Tracer;

// Player number last looked for.
int				LastLook;

int				MissileDamage;	// For missiles

// For nightmare respawn.
mthing_t		SpawnPoint;

// Reaction time: if non 0, don't attack yet.
int				ReactionCount;
// Used by player to freeze a bit after teleporting.
float			ReactionTime;

// If >0, the target will be chased
// no matter what (even if shot)
int				Threshold;

// Movement direction, movement generation (zig-zagging).
int				MoveDir;	// 0-7
int				MoveCount;	// when 0, select a new dir

int				bombdamage;
float			bombdistance;
bool			DamageSource;

TVec			teleport_pos;

// Height if not aiming up or down
// ???: use slope for monsters?
float			aim_z;
float			aim_range;
float			aim_slope;
TVec			aim_dir;
float			aim_topslope;
float			aim_bottomslope;	// slopes to top and bottom of target
float			aim_range2d;
EntityEx		linetarget;	// who got hit (or NULL)

float			shoot_range;
TVec			shoot_origin;
TVec			shoot_dir;
int				la_damage;
TVec			shoot_linestart;
TVec			shoot_lineend;
class<EntityEx>	shootPuffType;

// Static light parameters.
TVec			LightOffset;
int				LightColour;
float			LightRadius;

int				ExplodeEffect;

float			Special1f;

//**************************************************************************
//
//  OBJECT MOVEMENT
//
//**************************************************************************

//==========================================================================
//
//	Physics
//
//==========================================================================

bool Physics(float DeltaTime)
{
	EntityEx		onmo;
	SectorThinker	SecThink;
	float			scrollx;
	float			scrolly;
	float			height;
	float			waterheight;	// killough 4/4/98: add waterheight

	if (bBlaster)
	{
		return BlasterPhysics(DeltaTime);
	}

	if (Sector->AffectorData && bColideWithWorld)
	{
		// killough 3/7/98: Carry things on floor
		// killough 3/20/98: use new sector list which reflects true members
		// killough 3/27/98: fix carrier bug
		// killough 4/4/98: Underwater, carry things even w/o gravity

		// Move objects only if on floor or underwater,
		// non-floating, and clipped.

		for (SecThink = SectorThinker(Sector->AffectorData); SecThink;
			SecThink = SecThink.NextAffector)
		{
			if (!Scroller(SecThink))
			{
				continue;
			}
			scrollx = Scroller(SecThink).CarryScrollX;
			scrolly = Scroller(SecThink).CarryScrollY;
			if (!scrollx && !scrolly)
			{
				continue;
			}
			if (bNoGravity && (!Sector->heightsec ||
				(Sector->heightsec->bIgnoreHeightSec)))
			{
				continue;
			}
			height = GetPlanePointZ(&Sector->floor, Origin);
			if (Origin.z > height)
			{
				if (!Sector->heightsec || (Sector->heightsec->bIgnoreHeightSec))
				{
					continue;
				}

				waterheight = GetPlanePointZ(&Sector->heightsec->floor, Origin);
				if (waterheight > height && Origin.z >= waterheight)
				{
					continue;
				}
			}

			Velocity.x += scrollx;
			Velocity.y += scrolly;
		}
	}

	CheckWater();
	if (!bFloatBob)
	{
		UpdateVelocity();
	}

	// momentum movement
	if (Velocity.x || Velocity.y)
	{
		// Handle X and Y momentums
		XYMovement(DeltaTime);
		if (IsDestroyed())
		{
			// mobj was removed
			return false;
		}
	}
	else if (bSkullFly)
	{
		//	A flying mobj slammed into something
		bSkullFly = false;
		Velocity = vector(0.0, 0.0, 0.0);
		if (!SetState(SeeState ? SeeState : IdleState))
		{
			// mobj was removed
			return false;
		}
	}
	else if (bBlasted)
	{
		// Reset to not blasted when momentums are gone
		ResetBlasted();
	}

	if (bFloatBob)
	{
		// Floating item bobbing motion (special1 is height)
		if (Sector->bHasExtrafloors)
		{
			//	Make sure FloorZ is from bottom region.
			Origin.z = ONFLOORZ;
			LinkToWorld();
		}
		Origin.z = FloorZ + Special1f + Level.Game.FloatBobOffsets[(Health++) & 63];
	}
	else if (!bNoPassMobj && !bMissile)
	{
		// Handle Z momentum and gravity
		onmo = EntityEx(CheckOnmobj());
		if (onmo)
		{
			if (bIsPlayer)
			{
				if (Velocity.z < -DEFAULT_GRAVITY * 0.25 && !bFly)
				{
					PlayerLandedOnThing();
				}
			}
			if (onmo.Origin.z + onmo.Height - Origin.z <= MaxStepHeight)
			{
				if (bIsPlayer)
				{
					PlayerEx(Player).ViewHeight -=
						onmo.Origin.z + onmo.Height - Origin.z;
					PlayerEx(Player).DeltaViewHeight =
						(GetBaseViewHeight() - PlayerEx(Player).ViewHeight) * 4.0;
				}
				Origin.z = onmo.Origin.z + onmo.Height;
			}
			bOnMobj = true;
			Velocity.z = 0.0;

			if (onmo.bOnmobjCopyVel)
			{
				Velocity.x = onmo.Velocity.x;
				Velocity.y = onmo.Velocity.y;
				if (onmo.Origin.z < onmo.FloorZ)
				{
					Origin.z += onmo.FloorZ - onmo.Origin.z;
					if (onmo.bIsPlayer)
					{
						PlayerEx(onmo.Player).ViewHeight -=
							onmo.FloorZ - onmo.Origin.z;
						PlayerEx(onmo.Player).DeltaViewHeight =
							(GetBaseViewHeight() - PlayerEx(onmo.Player).ViewHeight) * 4.0;
					}
					onmo.Origin.z = onmo.FloorZ;
				}
			}
		}
		else if ((Origin.z != FloorZ) || Velocity.z)
		{
			ZMovement(DeltaTime);
			bOnMobj = false;
		}
		if (IsDestroyed())
		{
			// entity was removed
			return false;
		}
	}
	else if ((Origin.z != FloorZ) || Velocity.z)
	{
		// Handle Z momentum and gravity
		ZMovement(DeltaTime);
		if (IsDestroyed())
		{
			// entity was removed
			return false;
		}
	}
	return true;
}

//==========================================================================
//
//  XYMovement
//
//==========================================================================

final void XYMovement(float DeltaTime)
{
	float	ptryx;
	float	ptryy;
	float	xmove;
	float	ymove;
	int		special;

	if (bWindThrust)
	{
		special = Sector->special & SECSPEC_BASE_MASK;
		switch (special)
		{
		case SECSPEC_WindEastSlow:
		case SECSPEC_WindEastMedium:
		case SECSPEC_WindEastFast:
			Thrust(0.0, LineSpecialGameInfo(Level.Game).windTab[special - SECSPEC_WindEastSlow]);
			break;
		case SECSPEC_WindNorthSlow:
		case SECSPEC_WindNorthMedium:
		case SECSPEC_WindNorthFast:
			Thrust(90.0, LineSpecialGameInfo(Level.Game).windTab[special - SECSPEC_WindNorthSlow]);
			break;
		case SECSPEC_WindSouthSlow:
		case SECSPEC_WindSouthMedium:
		case SECSPEC_WindSouthFast:
			Thrust(270.0, LineSpecialGameInfo(Level.Game).windTab[special - SECSPEC_WindSouthSlow]);
			break;
		case SECSPEC_WindWestSlow:
		case SECSPEC_WindWestMedium:
		case SECSPEC_WindWestFast:
			Thrust(180.0, LineSpecialGameInfo(Level.Game).windTab[special - SECSPEC_WindWestSlow]);
			break;
		}
	}
	if (Velocity.x > MAXMOVE)
	{
		Velocity.x = MAXMOVE;
	}
	else if (Velocity.x < -MAXMOVE)
	{
		Velocity.x = -MAXMOVE;
	}
	if (Velocity.y > MAXMOVE)
	{
		Velocity.y = MAXMOVE;
	}
	else if (Velocity.y < -MAXMOVE)
	{
		Velocity.y = -MAXMOVE;
	}

	xmove = Velocity.x * DeltaTime;
	ymove = Velocity.y * DeltaTime;

	do
	{
		if (xmove > MAXMOVESTEP || ymove > MAXMOVESTEP)
		{
			ptryx = Origin.x + xmove / 2.0;
			ptryy = Origin.y + ymove / 2.0;
			xmove /= 2.0;
			ymove /= 2.0;
		}
		else
		{
			ptryx = Origin.x + xmove;
			ptryy = Origin.y + ymove;
			xmove = 0.0;
			ymove = 0.0;
		}

		tmtrace_t tmtrace;
		if (!TryMoveEx(&tmtrace, vector(ptryx, ptryy, Origin.z)))
		{
			// blocked move
			if (tmtrace.BlockingMobj)
			{
				HitMobj(tmtrace.BlockingMobj);
			}
			else
			{
				HitLine(&tmtrace);
			}
			return;
		}
	}
	while (xmove || ymove);
}

//==========================================================================
//
//	ZMovement
//
//==========================================================================

final void ZMovement(float DeltaTime)
{
	float	dist;
	float	delta;

	// check for smooth step up
	if (bIsPlayer && Origin.z < FloorZ)
	{
		PlayerEx(Player).ViewHeight -= FloorZ - Origin.z;
		PlayerEx(Player).DeltaViewHeight = (GetBaseViewHeight() -
			PlayerEx(Player).ViewHeight) * 4.0;
	}

	// adjust height
	Origin.z += Velocity.z * DeltaTime;

	if (bFloat && Target)
	{
		// float down towards enemy if too close
		if (!bSkullFly && !bInFloat)
		{
			dist = DistTo2(Target);
			delta = Target.Origin.z + Height / 2.0 - Origin.z;
			if (delta < 0.0 && dist < -delta * 3.0)
				Origin.z -= FloatSpeed * DeltaTime;
			else if (delta > 0.0 && dist < delta * 3.0)
				Origin.z += FloatSpeed * DeltaTime;
		}
	}
	if (bIsPlayer && bFly && !(Origin.z <= FloorZ) && XLevel.TicTime & 2)
	{
		Origin.z += sin(90.0 * 35.0 / 20.0 * XLevel.Time);
	}

	// clip movement
	if (Origin.z <= FloorZ + 0.1)
	{
		// hit the floor
		if (!HitFloor(DeltaTime))
		{
			return;
		}
	}

	if (Origin.z + Height > CeilingZ)
	{
		// hit the ceiling
		if (!HitCeiling())
		{
			return;
		}
	}
}

//==========================================================================
//
//	HitLine
//
//==========================================================================

final void HitLine(tmtrace_t* tmtrace)
{
	if (bMissile)
	{
		if (BounceType == BOUNCE_Doom ||
			BounceType == BOUNCE_Hexen)
		{
			//	If number of bounces is limited.
			if (BounceCount > 0 && --BounceCount <= 0)
			{
				ExplodeMissile();
				return;
			}

			// Struck a wall
			BounceWall(BOUNCE_VAL);
			if (!bNoBounceSound && !bNoWallBounceSnd && SightSound)
			{
				PlaySound(SightSound, CHAN_VOICE);
			}
			return;
		}

		// explode a missile
		if (tmtrace->CeilingLine && tmtrace->CeilingLine->backsector &&
			tmtrace->CeilingLine->backsector->ceiling.pic == Level.Game.skyflatnum)
		{
			// Hack to prevent missiles exploding against the sky.
			// Does not handle sky floors.
			if (bBounceSky)
			{
				Velocity = vector(0.0, 0.0, -1.0 * 35.0);
			}
			else if (bExplodeOnSky)
			{
				ExplodeMissile();
			}
			else
			{
				Destroy();
			}
			return;
		}
		ExplodeMissile();
	}
	else if (bSlide)
	{
		// try to slide along it
		SlideMove();
	}
	else
	{
		Velocity.x = 0.0;
		Velocity.y = 0.0;
	}
}

//==========================================================================
//
//	HitMobj
//
//==========================================================================

final void HitMobj(Entity Other)
{
	float	angle;
	float	speed;

	if (bMissile)
	{
		if (BounceType == BOUNCE_Doom ||
			BounceType == BOUNCE_Hexen)
		{
			//  Bounce against walls and non-killable ofjects
			if (bBounceOnActors || EntityEx(Other).bReflective ||
				(!Other.bIsPlayer && !EntityEx(Other).bCountKill))
			{
				angle = AngleMod360(atan2(Origin.y - Other.Origin.y,
					Origin.x - Other.Origin.x) + (Random() * 16.0 - 8.0));
				speed = Length(Velocity);
				speed = speed * 0.75;
				Angles.yaw = angle;
				Velocity.x = speed * cos(angle);
				Velocity.y = speed * sin(angle);
				if (!bNoBounceSound && SightSound)
				{
					PlaySound(SightSound, CHAN_VOICE);
				}
			}
			else
			{
				// Struck a player/creature
				ExplodeMissile();
			}
			return;
		}
		if (EntityEx(Other).bReflective)
		{
			angle = EntityEx(Other).GetReflectedAngle(self);
			if (angle != -1.0)
			{
				// Reflect the missile along angle
				Angles.yaw = angle;
				Velocity.x = (Speed / 2.0) * cos(angle);
				Velocity.y = (Speed / 2.0) * sin(angle);
				Velocity.z = -Velocity.z * 0.5;
				if (bSeekerMissile)
				{
					Tracer = Target;
				}
				Target = EntityEx(Other);
				return;
			}
		}
		// Explode a missile
		ExplodeMissile();
	}
	else if (bSlide)
	{
		// Try to slide along it
		// Slide against mobj
//		if (TryMove(vector(Origin.x, ptryy, Origin.z)))
		if (TryMove(vector(Origin.x, Origin.y + Velocity.y * Level.Game.frametime, Origin.z)))
		{
			Velocity.x = 0.0;
		}
//		else if (TryMove(vector(ptryx, Origin.y, Origin.z)))
		else if (TryMove(vector(Origin.x + Velocity.x * Level.Game.frametime, Origin.y, Origin.z)))
		{
			Velocity.y = 0.0;
		}
		else
		{
			Velocity.x = 0.0;
			Velocity.y = 0.0;
		}
	}
	else
	{
		Velocity.x = 0.0;
		Velocity.y = 0.0;
	}
}

//==========================================================================
//
//	HitFloor
//
//==========================================================================

final bool HitFloor(float DeltaTime)
{
	float	vdot;

	if (bMissile && (bColideWithWorld ||
		!LineSpecialGameInfo(Level.Game).bNoClipIgnoreFloor))
	{
		Origin.z = FloorZ;
		if (BounceType != BOUNCE_None)
		{
			FloorBounceMissile();
			return false;
		}
		if (bNoExplodeFloor)
		{
			// The spirit struck the ground
			Velocity.z = 0.0;
			HitFloorType();
			return false;
		}
		if (bIgnoreFloorStep)
		{
			// Minotaur floor fire can go up steps
			return false;
		}
		HitFloorType();
		ExplodeMissile();
		return false;
	}

	vdot = DotProduct(Velocity, Floor->normal);
	if (bCountKill)	// Blasted mobj falling
	{
		if (vdot < -23.0 * 35.0)
		{
			MonsterFallingDamage();
		}
	}
	Origin.z = FloorZ;
	if (vdot < -0.1)
	{
		// Spawn splashes, etc.
		HitFloorType();
		if (bIceDamage && vdot < -DEFAULT_GRAVITY * 0.25)
		{
			StateTime = 0.1;
			Velocity = vector(0.0, 0.0, 0.0);
			return false;
		}
		//	Do some special action when hitting the floor.
		OnHitFloor();
		if (bIsPlayer)
		{
			PlayerEx(Player).JumpTime = 0.2;	// delay any jumping for a short time
			if (vdot < -DEFAULT_GRAVITY * 0.25 && !bNoGravity)
			{
				// Squat down.
				// Decrease ViewHeight for a moment after hitting the ground
				// (hard), and utter appropriate sound.
				PlayerLandedOnThing();
			}
		}
		//Velocity -= vdot * Floor->normal;
		Velocity.z = 0.0;
	}
	if (bSkullFly)
	{
		// The skull slammed into something
		Velocity.z = -Velocity.z;
	}
	Crash();
	return true;
}

//==========================================================================
//
//	HitCeiling
//
//==========================================================================

final bool HitCeiling()
{
	float	vdot;

	vdot = DotProduct(Velocity, Ceiling->normal);
	if (vdot < 0.0)
	{
		Velocity -= vdot * Ceiling->normal;
	}
	Origin.z = CeilingZ - Height;

	if (bMissile && (bColideWithWorld ||
		!LineSpecialGameInfo(Level.Game).bNoClipIgnoreFloor))
	{
		if (BounceType != BOUNCE_None)
		{
			CeilingBounceMissile();
			return false;
		}
		if (bIgnoreCeilingStep)
		{
			return false;
		}
		if (Ceiling->pic == Level.Game.skyflatnum)
		{
			if (bBounceSky)
			{
				Velocity = vector(0.0, 0.0, -1.0 * 35.0);
			}
			else if (bExplodeOnSky)
			{
				ExplodeMissile();
			}
			else
			{
				Destroy();
			}
			return false;
		}
		ExplodeMissile();
		return false;
	}
	if (bSkullFly)
	{
		// the skull slammed into something
		Velocity.z = -Velocity.z;
	}
	return true;
}

//==========================================================================
//
//	FloorBounceMissile
//
//==========================================================================

void FloorBounceMissile()
{
	float	vdot;

	if (HitFloorType())
	{
		//	Landed on some kind of liquid.
		if (bExplodeOnWater)
		{
			ExplodeMissile();
			return;
		}
		if (!bCanBounceWater)
		{
			Destroy();
			return;
		}
	}

	//	If number of bounces is limited.
	if (BounceCount > 0 && --BounceCount <= 0)
	{
		ExplodeMissile();
		return;
	}

	vdot = DotProduct(Velocity, Floor->normal);

	if (BounceType == BOUNCE_Heretic)
	{
		Velocity -= 2.0 * vdot * Floor->normal;
		Angles.yaw = atan2(Velocity.y, Velocity.x);
		SetState(DeathState);
		return;
	}

	Velocity = (Velocity - 2.0 * vdot * Floor->normal) * BounceFactor;
	Angles.yaw = atan2(Velocity.y, Velocity.x);

	if (!bNoBounceSound && SightSound)
	{
		PlaySound(SightSound, CHAN_VOICE);
	}

	if (BounceType == BOUNCE_Doom)
	{
		if (!bNoGravity && Velocity.z < 3.0 * 35.0)
		{
			BounceType = BOUNCE_None;
		}
	}
}

//==========================================================================
//
//	CeilingBounceMissile
//
//==========================================================================

final void CeilingBounceMissile()
{
	float	vdot;

	//	If number of bounces is limited.
	if (BounceCount > 0 && --BounceCount <= 0)
	{
		ExplodeMissile();
		return;
	}

	vdot = DotProduct(Velocity, Ceiling->normal);

	if (BounceType == BOUNCE_Heretic)
	{
		Velocity -= 2.0 * vdot * Ceiling->normal;
		Angles.yaw = atan2(Velocity.y, Velocity.x);
		SetState(DeathState);
		return;
	}

	// Reverse momentum here for ceiling bounce
	Velocity = (Velocity - 2.0 * vdot * Ceiling->normal) * BounceFactor;
	Angles.yaw = atan2(Velocity.y, Velocity.x);

	if (!bNoBounceSound && SightSound)
	{
		PlaySound(SightSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	GetReflectedAngle
//
//==========================================================================

float GetReflectedAngle(EntityEx Other)
{
	float angle = atan2(Other.Origin.y - Origin.y,
		Other.Origin.x - Origin.x);

	// Change angle for reflection
	angle = AngleMod360(angle + Random() * 16.0 - 8.0);
	return angle;
}

//==========================================================================
//
//	Crash
//
//==========================================================================

final void Crash()
{
	if (CrashState && bCorpse && !bIceDamage)
	{
		SetState(CrashState);
	}
}

//===========================================================================
//
//  PlayerLandedOnThing
//
//===========================================================================

final void PlayerLandedOnThing()
{
	PlayerEx(Player).DeltaViewHeight = Velocity.z / 8.0;
	FallingDamage();
	if (Health > 0 && !PlayerIsMorphed())
	{
		if (Velocity.z < -DEFAULT_GRAVITY * 0.375)
		{
			PlaySound('*grunt', CHAN_VOICE);
		}
		if ((Origin.z > FloorZ || !GetFloorType()->bLiquid) &&
			!AreSoundsEquivalent('*grunt', '*land'))
		{
			PlaySound('*land', CHAN_BODY);
		}
	}
//FIXME Player.centreing = true;
}

//==========================================================================
//
//	BlasterPhysics
//
//  Thinker for the ultra-fast blaster PL2 ripper-spawning missile.
//
//==========================================================================

final bool BlasterPhysics(float DeltaTime)
{
	int			i;
	float		xfrac;
	float		yfrac;
	float		zfrac;
	bool		changexy;
	tmtrace_t	tmtrace;

	// Handle movement
	if (Velocity.x || Velocity.y || (Origin.z != FloorZ) || Velocity.z)
	{
		xfrac = Velocity.x * DeltaTime / 8.0;
		yfrac = Velocity.y * DeltaTime / 8.0;
		zfrac = Velocity.z * DeltaTime / 8.0;
		changexy = xfrac || yfrac;
		for (i = 0; i < 8; i++)
		{
			if (changexy)
			{
				if (!TryMoveEx(&tmtrace, vector(Origin.x + xfrac,
					Origin.y + yfrac, Origin.z)))
				{
					// Blocked move
					if (tmtrace.BlockingMobj)
					{
						BlasterHitMobj(tmtrace.BlockingMobj);
					}
					else
					{
						ExplodeMissile();
					}
					return !IsDestroyed();
				}
			}
			Origin.z += zfrac;
			if (Origin.z <= FloorZ)
			{
				// Hit the floor
				Origin.z = FloorZ;
				HitFloorType();
				ExplodeMissile();
				return !IsDestroyed();
			}
			if (Origin.z + Height > CeilingZ)
			{
				// Hit the ceiling
				Origin.z = CeilingZ - Height;
				ExplodeMissile();
				return !IsDestroyed();
			}
			if (changexy)
			{
				SpawnBlasterEffects();
			}
		}
	}
	return true;
}

//==========================================================================
//
//  ResetBlasted
//
//==========================================================================

final void ResetBlasted()
{
	bBlasted = false;
	if (!bIceCorpse)
	{
		bSlide = false;
	}
}

//==========================================================================
//
//	OnHitFloor
//
//==========================================================================

void OnHitFloor()
{
}

//==========================================================================
//
//	BlasterHitMobj
//
//==========================================================================

bool BlasterHitMobj(Entity Other)
{
	return ExplodeMissile();
}

//==========================================================================
//
//  SpawnBlasterEffects
//
//==========================================================================

void SpawnBlasterEffects()
{
}

//==========================================================================
//
//  HitFloorType
//
//==========================================================================

final bool HitFloorType()
{
	EntityEx		A;
	TVec			org;
	bool			smallsplash = false;
	VTerrainInfo*	TInfo;
	VSplashInfo*	SInfo;

	if (FloorZ != GetPlanePointZ(&Sector->floor, Origin))
	{
		// don't splash if landing on the edge above water/lava/etc....
		return false;
	}

	// Things that don't splash go here
	if (bNoSplash)
	{
		return false;
	}

	TInfo = GetFloorType();

	// Small splash for small masses
	if (Mass < 10.0 || bSmallSplash)
		smallsplash = true;

	if (TInfo->DamageAmount && bIsPlayer &&
		XLevel.TicTime & TInfo->DamageTimeMask)
	{
		Damage(GetDamageTypeInflictor(TInfo->DamageType), none,
			TInfo->DamageAmount);
	}

	SInfo = GetSplashInfo(TInfo->Splash);
	if (!SInfo)
	{
		return TInfo->bLiquid;
	}

	org = Origin;
	org.z = FloorZ;

	if (smallsplash)
	{
		if (SInfo->SmallClass)
		{
			A = Spawn(class<EntityEx>(SInfo->SmallClass), org);
			A.FloorClip += SInfo->SmallClip;
			if (SInfo->SmallSound)
			{
				A.PlaySound(SInfo->SmallSound, CHAN_VOICE);
			}
		}
	}
	else
	{
		if (SInfo->BaseClass)
		{
			Spawn(class<EntityEx>(SInfo->BaseClass), org);
			if (SInfo->Sound && !SInfo->ChunkClass)
			{
				A.PlaySound(SInfo->Sound, CHAN_VOICE);
			}
		}
		if (SInfo->ChunkClass)
		{
			A = Spawn(class<EntityEx>(SInfo->ChunkClass), org);
			A.Target = self;
			A.Velocity.x = (Random() - Random()) * SInfo->ChunkXVelMul * 35.0;
			A.Velocity.y = (Random() - Random()) * SInfo->ChunkYVelMul * 35.0;
			A.Velocity.z = (SInfo->ChunkBaseZVel + Random() *
				SInfo->ChunkZVelMul) * 35.0;
			if (SInfo->Sound)
			{
				A.PlaySound(SInfo->Sound, CHAN_VOICE);
			}
		}
		if (SInfo->Sound && !SInfo->BaseClass && !SInfo->ChunkClass)
		{
			PlaySound(SInfo->Sound, CHAN_BODY);
		}
		if (!SInfo->bNoAlert && bIsPlayer)
		{
			LineSpecialLevelInfo(Level).NoiseAlert(self, self);
		}
	}
	return TInfo->bLiquid;
}

//===========================================================================
//
//  GetFloorType
//
//===========================================================================

final VTerrainInfo* GetFloorType()
{
	return TerrainType(Floor->pic);
}

//==========================================================================
//
//	HandleFloorclip
//
//==========================================================================

final void HandleFloorclip()
{
	if (bFloorClip)
	{
		VTerrainInfo* TInfo = GetFloorType();
		if (Origin.z == FloorZ && TInfo->bLiquid)
		{
			FloorClip = TInfo->FootClip;
		}
		else
		{
			FloorClip = 0.0;
		}
	}
}

//==========================================================================
//
//  ApplyFriction
//
//==========================================================================

final void ApplyFriction()
{
	float dot;

	if (bMissile || bSkullFly)
	{
		// no friction for missiles ever
		return;
	}

	if (Origin.z > FloorZ && !bOnMobj && WaterLevel < 2 && !bFly &&
		!bFallingFriction)
	{
		// no friction when airborne
		return;
	}

	//  Clip velocity
	if (Origin.z <= FloorZ)
	{
		dot = DotProduct(Velocity, Floor->normal);
		if (dot < 0.0)
		{
			Velocity -= dot * Floor->normal;
		}
	}

	if (bCorpse)
	{
		// Don't stop sliding if halfway off a step with some momentum
		if (Velocity.x > 0.25 * 35.0 || Velocity.x < -0.25 * 35.0 ||
			Velocity.y > 0.25 * 35.0 || Velocity.y < -0.25 * 35.0)
		{
			if (FloorZ != GetPlanePointZ(&Sector->floor, Origin))
			{
				return;
			}
		}
	}

	if (Velocity.x > -STOPSPEED && Velocity.x < STOPSPEED &&
		Velocity.y > -STOPSPEED && Velocity.y < STOPSPEED &&
		Velocity.z > -STOPSPEED && Velocity.z < STOPSPEED &&
		(!bIsPlayer || (!Player.ForwardMove && !Player.SideMove)))
	{
		if (bIsPlayer)
		{
			// if in a walking frame, stop moving
			if (StateIsInRange(State, SeeState, none, 4))
			{
				SetState(IdleState);
			}
		}
		Velocity = vector(0.0, 0.0, 0.0);
	}
	else
	{
		// slow down
		Velocity -= Velocity * (GetFriction() * Level.Game.frametime);
	}
}

//===========================================================================
//
//  GetFriction
//
//===========================================================================

final float GetFriction()
{
	if (WaterLevel > 1)
	{
		return FRICTION_WATER;
	}
	if (bFly && Origin.z > FloorZ && !bOnMobj)
	{
		return FRICTION_FLY;
	}
	if ((Sector->special & SECSPEC_BASE_MASK) == SECSPEC_FrictionLow)
	{
		return FRICTION_LOW;
	}
	VTerrainInfo* TInfo = GetFloorType();
	if (TInfo->Friction)
	{
		return TInfo->Friction;
	}
	if (Sector->special & SECSPEC_FRICTION_MASK)
	{
		return Sector->Friction;
	}
	return FRICTION_NORMAL;
}

bool ExplodeMissile()
{
	return true;
}

float GetBaseViewHeight()
{
	return 0.0;
}

void MonsterFallingDamage()
{
}

EntityEx GetDamageTypeInflictor(name DamageType)
{
	return none;
}

void FallingDamage()
{
}

bool PlayerIsMorphed()
{
	return false;
}

//**************************************************************************
//**************************************************************************

//==========================================================================
//
//  SetInstigator
//
//==========================================================================

void SetInstigator(Entity NewInstigator)
{
}

//==========================================================================
//
//  PlaySightSound
//
//==========================================================================

void PlaySightSound()
{
}

//==========================================================================
//
//  CheckMissileSpawn
//
//==========================================================================

bool CheckMissileSpawn()
{
	return true;
}

//==========================================================================
//
//  SetDropped
//
//==========================================================================

void SetDropped()
{
}

//==========================================================================
//
//  StartFloatBob
//
//==========================================================================

void StartFloatBob(Entity Src)
{
}

//==========================================================================
//
//  SaveFloatBobOffset
//
//==========================================================================

void SaveFloatBobOffset()
{
}

//==========================================================================
//
//  TestLocation
//
//==========================================================================

bool TestLocation()
{
}

//==========================================================================
//
//  ThingDestroy
//
//==========================================================================

bool ThingDestroy()
{
	return false;
}

//==========================================================================
//
//  Thrust
//
//==========================================================================

void Thrust(float Angle, float Force)
{
}

//==========================================================================
//
//  ThingDamage
//
//==========================================================================

void ThingDamage(int Amount)
{
}

//==========================================================================
//
//  IsTeleportSpot
//
//==========================================================================

bool IsTeleportSpot()
{
	return false;
}

//==========================================================================
//
//  IsTeleportSpot2
//
//==========================================================================

bool IsTeleportSpot2()
{
	return false;
}

//==========================================================================
//
//  CanTeleport
//
//==========================================================================

bool CanTeleport()
{
	return false;
}

//==========================================================================
//
//  Teleport
//
//==========================================================================

bool Teleport(TVec Dst, float angle, bool DstFog, bool SrcFog, bool KeepDir)
{
	return false;
}

//==========================================================================
//
//  TeleportMove
//
//==========================================================================

bool TeleportMove(TVec Pos)
{
	return false;
}

//==========================================================================
//
//  SetPainState
//
//==========================================================================

void SetPainState()
{
}

//==========================================================================
//
//  IsPointPusher
//
//==========================================================================

bool IsPointPusher()
{
	return false;
}

//==========================================================================
//
//  IsPointPuller
//
//==========================================================================

bool IsPointPuller()
{
	return false;
}

//==========================================================================
//
//  CanWindThrust
//
//==========================================================================

bool CanWindThrust()
{
	return false;
}

//==========================================================================
//
//  GetPlayerViewHeight
//
//==========================================================================

float GetPlayerViewHeight()
{
	return 0.0;
}

//==========================================================================
//
//  Damage
//
//==========================================================================

void Damage(EntityEx inflictor, EntityEx source, int damage)
{
}

defaultproperties
{
	MissileChance = 200.0;
	FloatSpeed = 140.0;
	BounceFactor = 0.7;
}
