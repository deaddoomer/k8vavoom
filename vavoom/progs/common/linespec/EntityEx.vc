//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id: Entity.vc 1755 2006-10-03 19:24:11Z dj_jl $
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class EntityEx : Entity
	abstract;

const float ONFLOORZ		= -99999.0;
const float ONCEILINGZ		= 99999.0;

const float FRICTION_NORMAL	= 3.28125;
const float FRICTION_LOW	= 0.95703125;
const float FRICTION_FLY	= 2.87109375;
const float FRICTION_WATER	= 3.0;

const float MAXMOVE			= 1050.0;
const float MAXMOVESTEP		= MAXMOVE / (35.0 * 2.0);
const float STOPSPEED		= 2.1875;

const float BOUNCE_VAL		= 1.5;

enum
{
	BOUNCE_None,
	BOUNCE_Doom,
	BOUNCE_Heretic,
	BOUNCE_Hexen
};

//  States
state			IdleState;
state			SeeState;
state			MeleeState;
state			MissileState;
state			PainState;
state			WoundState;
state			DeathState;
state			GibsDeathState;
state			IceDeathState;
state			FireDeathState;
state			DisruptDeathState;
state			CrashState;
state			RaiseState;

//	Sounds
name			SightSound;
name			ActiveSound;
name			AttackSound;
name			PainSound;
name			DeathSound;

//	Flags
bool bSpecial;			// call P_SpecialThing when touched
bool bShootable;		// Can be hit.
bool bAmbush;
bool bJustHit;			// try to attack right back
bool bJustAttacked;		// take at least one step before attacking
bool bSpawnCeiling;		// hang from ceiling instead of floor
// movement flags
bool bPickUp;			// for players to pick up items
bool bMissile;			// don't hit same species, explode on block
bool bDropped;			// dropped by a demon, not level spawned
bool bNoBlood;			// don't bleed when shot (use puff)
bool bInFloat;			// floating to a height for a move, don't
						// auto float to target's height
bool bSkullFly;			// skull in flight
bool bCountKill;		// count towards intermission kill total
bool bCountItem;		// count towards intermission item total
bool bWindThrust;		// gets pushed around by the wind specials
bool bActivateImpact;	// an MF_MISSILE mobj can activate
						// SPAC_IMPACT
bool bActivatePushWall;	// mobj can push walls
bool bActivateMCross;	// can activate monster cross lines
bool bActivatePCross;	// can activate projectile cross lines
bool bDormant;			// thing is dormant
bool bWaterJump;
bool bNoTeleport;		// does not teleport
bool bTelestomp;		// mobj can stomp another
bool bCannotPush;		// cannot push other pushable mobjs
bool bSmallSplash;		// Always use small splash
bool bNoSplash;			// Things that don't splash
bool bStaticLight;		// Static light source.
bool bTriggerHappy;
bool bBlaster;
bool bFloatBob;			// use float bobbing z movement
bool bOnmobjCopyVel;
bool bNoBounceSound;	//	Don't make sound when bouncing
bool bNoWallBounceSnd;	//	Don't make sound when bouncing off a wall
bool bBounceSky;		//	Bounce when hitting the sky
bool bExplodeOnSky;		//	Explodes when hits the sky
bool bBounceOnActors;	//	Bounces against other actors
bool bSlide;			// slides against walls
bool bReflective;		// reflects missiles
bool bSeekerMissile;	// is a seeker (for reflection)
bool bNoExplodeFloor;	//	Don't explode when hitting the floor
bool bIceDamage;		// does ice damage
bool bIceCorpse;		// a frozen corpse (for blasting)
bool bExplodeOnWater;	//	Explode on water surfaces
bool bCanBounceWater;	//	Bounce on water surfaces
bool bFallingFriction;	//	Apply friction while falling
bool bNoRadiusDamage;	//	Does not take radius damage
bool bCantAutoAim;		//	Can't auto aim at this actor
bool bPuffOnActors;		//	Spawn this puff when hitting actors
bool bInvulnerable;		// mobj is invulnerable
bool bAxeBlood;			//	Use axe's blood splatter

//  Params
float			Speed;
float			StepSpeed;
float			FloatSpeed;
float			PainChance;
int				GibsHealth;

float			MissileChance;
float			MissileMinRange;
float			MissileMaxRange;

byte			BounceType;
byte			BounceCount;
float			BounceFactor;

// Thing being chased/attacked (or NULL).
// Also the originator for missiles.
EntityEx		Target;
EntityEx		Tracer;

// Player number last looked for.
int				LastLook;

int				MissileDamage;	// For missiles

// For nightmare respawn.
mthing_t		SpawnPoint;

// Reaction time: if non 0, don't attack yet.
int				ReactionCount;
// Used by player to freeze a bit after teleporting.
float			ReactionTime;

// If >0, the target will be chased
// no matter what (even if shot)
int				Threshold;

// Movement direction, movement generation (zig-zagging).
int				MoveDir;	// 0-7
int				MoveCount;	// when 0, select a new dir

float			RDFactor;

TVec			teleport_pos;

EntityEx		linetarget;	// who got hit (or NULL)

// Static light parameters.
TVec			LightOffset;
int				LightColour;
float			LightRadius;

int				ExplodeEffect;

float			Special1f;

//**************************************************************************
//
//  OBJECT MOVEMENT
//
//**************************************************************************

//==========================================================================
//
//	Physics
//
//==========================================================================

bool Physics(float DeltaTime)
{
	EntityEx		onmo;
	SectorThinker	SecThink;
	float			scrollx;
	float			scrolly;
	float			height;
	float			waterheight;	// killough 4/4/98: add waterheight

	if (bBlaster)
	{
		return BlasterPhysics(DeltaTime);
	}

	if (Sector->AffectorData && bColideWithWorld)
	{
		// killough 3/7/98: Carry things on floor
		// killough 3/20/98: use new sector list which reflects true members
		// killough 3/27/98: fix carrier bug
		// killough 4/4/98: Underwater, carry things even w/o gravity

		// Move objects only if on floor or underwater,
		// non-floating, and clipped.

		for (SecThink = SectorThinker(Sector->AffectorData); SecThink;
			SecThink = SecThink.NextAffector)
		{
			if (!Scroller(SecThink))
			{
				continue;
			}
			scrollx = Scroller(SecThink).CarryScrollX;
			scrolly = Scroller(SecThink).CarryScrollY;
			if (!scrollx && !scrolly)
			{
				continue;
			}
			if (bNoGravity && (!Sector->heightsec ||
				(Sector->heightsec->bIgnoreHeightSec)))
			{
				continue;
			}
			height = GetPlanePointZ(&Sector->floor, Origin);
			if (Origin.z > height)
			{
				if (!Sector->heightsec || (Sector->heightsec->bIgnoreHeightSec))
				{
					continue;
				}

				waterheight = GetPlanePointZ(&Sector->heightsec->floor, Origin);
				if (waterheight > height && Origin.z >= waterheight)
				{
					continue;
				}
			}

			Velocity.x += scrollx;
			Velocity.y += scrolly;
		}
	}

	CheckWater();
	if (!bFloatBob)
	{
		UpdateVelocity();
	}

	// momentum movement
	if (Velocity.x || Velocity.y)
	{
		// Handle X and Y momentums
		XYMovement(DeltaTime);
		if (IsDestroyed())
		{
			// mobj was removed
			return false;
		}
	}
	else if (bSkullFly)
	{
		//	A flying mobj slammed into something
		bSkullFly = false;
		Velocity = vector(0.0, 0.0, 0.0);
		if (!SetState(SeeState ? SeeState : IdleState))
		{
			// mobj was removed
			return false;
		}
	}
	else if (bBlasted)
	{
		// Reset to not blasted when momentums are gone
		ResetBlasted();
	}

	if (bFloatBob)
	{
		// Floating item bobbing motion (special1 is height)
		if (Sector->bHasExtrafloors)
		{
			//	Make sure FloorZ is from bottom region.
			Origin.z = ONFLOORZ;
			LinkToWorld();
		}
		Origin.z = FloorZ + Special1f + Level.Game.FloatBobOffsets[(Health++) & 63];
	}
	else if (!bNoPassMobj && !bMissile)
	{
		// Handle Z momentum and gravity
		onmo = EntityEx(CheckOnmobj());
		if (onmo)
		{
			if (bIsPlayer)
			{
				if (Velocity.z < -DEFAULT_GRAVITY * 0.25 && !bFly)
				{
					PlayerLandedOnThing();
				}
			}
			if (onmo.Origin.z + onmo.Height - Origin.z <= MaxStepHeight)
			{
				if (bIsPlayer)
				{
					PlayerEx(Player).ViewHeight -=
						onmo.Origin.z + onmo.Height - Origin.z;
					PlayerEx(Player).DeltaViewHeight =
						(GetBaseViewHeight() - PlayerEx(Player).ViewHeight) * 4.0;
				}
				Origin.z = onmo.Origin.z + onmo.Height;
			}
			bOnMobj = true;
			Velocity.z = 0.0;

			if (onmo.bOnmobjCopyVel)
			{
				Velocity.x = onmo.Velocity.x;
				Velocity.y = onmo.Velocity.y;
				if (onmo.Origin.z < onmo.FloorZ)
				{
					Origin.z += onmo.FloorZ - onmo.Origin.z;
					if (onmo.bIsPlayer)
					{
						PlayerEx(onmo.Player).ViewHeight -=
							onmo.FloorZ - onmo.Origin.z;
						PlayerEx(onmo.Player).DeltaViewHeight =
							(GetBaseViewHeight() - PlayerEx(onmo.Player).ViewHeight) * 4.0;
					}
					onmo.Origin.z = onmo.FloorZ;
				}
			}
		}
		else if ((Origin.z != FloorZ) || Velocity.z)
		{
			ZMovement(DeltaTime);
			bOnMobj = false;
		}
		if (IsDestroyed())
		{
			// entity was removed
			return false;
		}
	}
	else if ((Origin.z != FloorZ) || Velocity.z)
	{
		// Handle Z momentum and gravity
		ZMovement(DeltaTime);
		if (IsDestroyed())
		{
			// entity was removed
			return false;
		}
	}
	return true;
}

//==========================================================================
//
//  XYMovement
//
//==========================================================================

final void XYMovement(float DeltaTime)
{
	float	ptryx;
	float	ptryy;
	float	xmove;
	float	ymove;
	int		special;

	if (bWindThrust)
	{
		special = Sector->special & SECSPEC_BASE_MASK;
		switch (special)
		{
		case SECSPEC_WindEastSlow:
		case SECSPEC_WindEastMedium:
		case SECSPEC_WindEastFast:
			Thrust(0.0, LineSpecialGameInfo(Level.Game).windTab[special - SECSPEC_WindEastSlow]);
			break;
		case SECSPEC_WindNorthSlow:
		case SECSPEC_WindNorthMedium:
		case SECSPEC_WindNorthFast:
			Thrust(90.0, LineSpecialGameInfo(Level.Game).windTab[special - SECSPEC_WindNorthSlow]);
			break;
		case SECSPEC_WindSouthSlow:
		case SECSPEC_WindSouthMedium:
		case SECSPEC_WindSouthFast:
			Thrust(270.0, LineSpecialGameInfo(Level.Game).windTab[special - SECSPEC_WindSouthSlow]);
			break;
		case SECSPEC_WindWestSlow:
		case SECSPEC_WindWestMedium:
		case SECSPEC_WindWestFast:
			Thrust(180.0, LineSpecialGameInfo(Level.Game).windTab[special - SECSPEC_WindWestSlow]);
			break;
		}
	}
	if (Velocity.x > MAXMOVE)
	{
		Velocity.x = MAXMOVE;
	}
	else if (Velocity.x < -MAXMOVE)
	{
		Velocity.x = -MAXMOVE;
	}
	if (Velocity.y > MAXMOVE)
	{
		Velocity.y = MAXMOVE;
	}
	else if (Velocity.y < -MAXMOVE)
	{
		Velocity.y = -MAXMOVE;
	}

	xmove = Velocity.x * DeltaTime;
	ymove = Velocity.y * DeltaTime;

	do
	{
		if (xmove > MAXMOVESTEP || ymove > MAXMOVESTEP)
		{
			ptryx = Origin.x + xmove / 2.0;
			ptryy = Origin.y + ymove / 2.0;
			xmove /= 2.0;
			ymove /= 2.0;
		}
		else
		{
			ptryx = Origin.x + xmove;
			ptryy = Origin.y + ymove;
			xmove = 0.0;
			ymove = 0.0;
		}

		tmtrace_t tmtrace;
		if (!TryMoveEx(&tmtrace, vector(ptryx, ptryy, Origin.z)))
		{
			// blocked move
			if (tmtrace.BlockingMobj)
			{
				HitMobj(tmtrace.BlockingMobj);
			}
			else
			{
				HitLine(&tmtrace);
			}
			return;
		}
	}
	while (xmove || ymove);
}

//==========================================================================
//
//	ZMovement
//
//==========================================================================

final void ZMovement(float DeltaTime)
{
	float	dist;
	float	delta;

	// check for smooth step up
	if (bIsPlayer && Origin.z < FloorZ)
	{
		PlayerEx(Player).ViewHeight -= FloorZ - Origin.z;
		PlayerEx(Player).DeltaViewHeight = (GetBaseViewHeight() -
			PlayerEx(Player).ViewHeight) * 4.0;
	}

	// adjust height
	Origin.z += Velocity.z * DeltaTime;

	if (bFloat && Target)
	{
		// float down towards enemy if too close
		if (!bSkullFly && !bInFloat)
		{
			dist = DistTo2(Target);
			delta = Target.Origin.z + Height / 2.0 - Origin.z;
			if (delta < 0.0 && dist < -delta * 3.0)
				Origin.z -= FloatSpeed * DeltaTime;
			else if (delta > 0.0 && dist < delta * 3.0)
				Origin.z += FloatSpeed * DeltaTime;
		}
	}
	if (bIsPlayer && bFly && !(Origin.z <= FloorZ) && XLevel.TicTime & 2)
	{
		Origin.z += sin(90.0 * 35.0 / 20.0 * XLevel.Time);
	}

	// clip movement
	if (Origin.z <= FloorZ + 0.1)
	{
		// hit the floor
		if (!HitFloor(DeltaTime))
		{
			return;
		}
	}

	if (Origin.z + Height > CeilingZ)
	{
		// hit the ceiling
		if (!HitCeiling())
		{
			return;
		}
	}
}

//==========================================================================
//
//	HitLine
//
//==========================================================================

final void HitLine(tmtrace_t* tmtrace)
{
	if (bMissile)
	{
		if (BounceType == BOUNCE_Doom ||
			BounceType == BOUNCE_Hexen)
		{
			//	If number of bounces is limited.
			if (BounceCount > 0 && --BounceCount <= 0)
			{
				ExplodeMissile();
				return;
			}

			// Struck a wall
			BounceWall(BOUNCE_VAL);
			if (!bNoBounceSound && !bNoWallBounceSnd && SightSound)
			{
				PlaySound(SightSound, CHAN_VOICE);
			}
			return;
		}

		// explode a missile
		if (tmtrace->CeilingLine && tmtrace->CeilingLine->backsector &&
			tmtrace->CeilingLine->backsector->ceiling.pic == Level.Game.skyflatnum)
		{
			// Hack to prevent missiles exploding against the sky.
			// Does not handle sky floors.
			if (bBounceSky)
			{
				Velocity = vector(0.0, 0.0, -1.0 * 35.0);
			}
			else if (bExplodeOnSky)
			{
				ExplodeMissile();
			}
			else
			{
				Destroy();
			}
			return;
		}
		ExplodeMissile();
	}
	else if (bSlide)
	{
		// try to slide along it
		SlideMove();
	}
	else
	{
		Velocity.x = 0.0;
		Velocity.y = 0.0;
	}
}

//==========================================================================
//
//	HitMobj
//
//==========================================================================

final void HitMobj(Entity Other)
{
	float	angle;
	float	speed;

	if (bMissile)
	{
		if (BounceType == BOUNCE_Doom ||
			BounceType == BOUNCE_Hexen)
		{
			//  Bounce against walls and non-killable ofjects
			if (bBounceOnActors || EntityEx(Other).bReflective ||
				(!Other.bIsPlayer && !EntityEx(Other).bCountKill))
			{
				angle = AngleMod360(atan2(Origin.y - Other.Origin.y,
					Origin.x - Other.Origin.x) + (Random() * 16.0 - 8.0));
				speed = Length(Velocity);
				speed = speed * 0.75;
				Angles.yaw = angle;
				Velocity.x = speed * cos(angle);
				Velocity.y = speed * sin(angle);
				if (!bNoBounceSound && SightSound)
				{
					PlaySound(SightSound, CHAN_VOICE);
				}
			}
			else
			{
				// Struck a player/creature
				ExplodeMissile();
			}
			return;
		}
		if (EntityEx(Other).bReflective)
		{
			angle = EntityEx(Other).GetReflectedAngle(self);
			if (angle != -1.0)
			{
				// Reflect the missile along angle
				Angles.yaw = angle;
				Velocity.x = (Speed / 2.0) * cos(angle);
				Velocity.y = (Speed / 2.0) * sin(angle);
				Velocity.z = -Velocity.z * 0.5;
				if (bSeekerMissile)
				{
					Tracer = Target;
				}
				Target = EntityEx(Other);
				return;
			}
		}
		// Explode a missile
		ExplodeMissile();
	}
	else if (bSlide)
	{
		// Try to slide along it
		// Slide against mobj
//		if (TryMove(vector(Origin.x, ptryy, Origin.z)))
		if (TryMove(vector(Origin.x, Origin.y + Velocity.y * Level.Game.frametime, Origin.z)))
		{
			Velocity.x = 0.0;
		}
//		else if (TryMove(vector(ptryx, Origin.y, Origin.z)))
		else if (TryMove(vector(Origin.x + Velocity.x * Level.Game.frametime, Origin.y, Origin.z)))
		{
			Velocity.y = 0.0;
		}
		else
		{
			Velocity.x = 0.0;
			Velocity.y = 0.0;
		}
	}
	else
	{
		Velocity.x = 0.0;
		Velocity.y = 0.0;
	}
}

//==========================================================================
//
//	HitFloor
//
//==========================================================================

final bool HitFloor(float DeltaTime)
{
	float	vdot;

	if (bMissile && (bColideWithWorld ||
		!LineSpecialGameInfo(Level.Game).bNoClipIgnoreFloor))
	{
		Origin.z = FloorZ;
		if (BounceType != BOUNCE_None)
		{
			FloorBounceMissile();
			return false;
		}
		if (bNoExplodeFloor)
		{
			// The spirit struck the ground
			Velocity.z = 0.0;
			HitFloorType();
			return false;
		}
		if (bIgnoreFloorStep)
		{
			// Minotaur floor fire can go up steps
			return false;
		}
		HitFloorType();
		ExplodeMissile();
		return false;
	}

	vdot = DotProduct(Velocity, Floor->normal);
	if (bCountKill)	// Blasted mobj falling
	{
		if (vdot < -23.0 * 35.0)
		{
			MonsterFallingDamage();
		}
	}
	Origin.z = FloorZ;
	if (vdot < -0.1)
	{
		// Spawn splashes, etc.
		HitFloorType();
		if (bIceDamage && vdot < -DEFAULT_GRAVITY * 0.25)
		{
			StateTime = 0.1;
			Velocity = vector(0.0, 0.0, 0.0);
			return false;
		}
		//	Do some special action when hitting the floor.
		OnHitFloor();
		if (bIsPlayer)
		{
			PlayerEx(Player).JumpTime = 0.2;	// delay any jumping for a short time
			if (vdot < -DEFAULT_GRAVITY * 0.25 && !bNoGravity)
			{
				// Squat down.
				// Decrease ViewHeight for a moment after hitting the ground
				// (hard), and utter appropriate sound.
				PlayerLandedOnThing();
			}
		}
		//Velocity -= vdot * Floor->normal;
		Velocity.z = 0.0;
	}
	if (bSkullFly)
	{
		// The skull slammed into something
		Velocity.z = -Velocity.z;
	}
	Crash();
	return true;
}

//==========================================================================
//
//	HitCeiling
//
//==========================================================================

final bool HitCeiling()
{
	float	vdot;

	vdot = DotProduct(Velocity, Ceiling->normal);
	if (vdot < 0.0)
	{
		Velocity -= vdot * Ceiling->normal;
	}
	Origin.z = CeilingZ - Height;

	if (bMissile && (bColideWithWorld ||
		!LineSpecialGameInfo(Level.Game).bNoClipIgnoreFloor))
	{
		if (BounceType != BOUNCE_None)
		{
			CeilingBounceMissile();
			return false;
		}
		if (bIgnoreCeilingStep)
		{
			return false;
		}
		if (Ceiling->pic == Level.Game.skyflatnum)
		{
			if (bBounceSky)
			{
				Velocity = vector(0.0, 0.0, -1.0 * 35.0);
			}
			else if (bExplodeOnSky)
			{
				ExplodeMissile();
			}
			else
			{
				Destroy();
			}
			return false;
		}
		ExplodeMissile();
		return false;
	}
	if (bSkullFly)
	{
		// the skull slammed into something
		Velocity.z = -Velocity.z;
	}
	return true;
}

//==========================================================================
//
//	FloorBounceMissile
//
//==========================================================================

void FloorBounceMissile()
{
	float	vdot;

	if (HitFloorType())
	{
		//	Landed on some kind of liquid.
		if (bExplodeOnWater)
		{
			ExplodeMissile();
			return;
		}
		if (!bCanBounceWater)
		{
			Destroy();
			return;
		}
	}

	//	If number of bounces is limited.
	if (BounceCount > 0 && --BounceCount <= 0)
	{
		ExplodeMissile();
		return;
	}

	vdot = DotProduct(Velocity, Floor->normal);

	if (BounceType == BOUNCE_Heretic)
	{
		Velocity -= 2.0 * vdot * Floor->normal;
		Angles.yaw = atan2(Velocity.y, Velocity.x);
		SetState(DeathState);
		return;
	}

	Velocity = (Velocity - 2.0 * vdot * Floor->normal) * BounceFactor;
	Angles.yaw = atan2(Velocity.y, Velocity.x);

	if (!bNoBounceSound && SightSound)
	{
		PlaySound(SightSound, CHAN_VOICE);
	}

	if (BounceType == BOUNCE_Doom)
	{
		if (!bNoGravity && Velocity.z < 3.0 * 35.0)
		{
			BounceType = BOUNCE_None;
		}
	}
}

//==========================================================================
//
//	CeilingBounceMissile
//
//==========================================================================

final void CeilingBounceMissile()
{
	float	vdot;

	//	If number of bounces is limited.
	if (BounceCount > 0 && --BounceCount <= 0)
	{
		ExplodeMissile();
		return;
	}

	vdot = DotProduct(Velocity, Ceiling->normal);

	if (BounceType == BOUNCE_Heretic)
	{
		Velocity -= 2.0 * vdot * Ceiling->normal;
		Angles.yaw = atan2(Velocity.y, Velocity.x);
		SetState(DeathState);
		return;
	}

	// Reverse momentum here for ceiling bounce
	Velocity = (Velocity - 2.0 * vdot * Ceiling->normal) * BounceFactor;
	Angles.yaw = atan2(Velocity.y, Velocity.x);

	if (!bNoBounceSound && SightSound)
	{
		PlaySound(SightSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	GetReflectedAngle
//
//==========================================================================

float GetReflectedAngle(EntityEx Other)
{
	float angle = atan2(Other.Origin.y - Origin.y,
		Other.Origin.x - Origin.x);

	// Change angle for reflection
	angle = AngleMod360(angle + Random() * 16.0 - 8.0);
	return angle;
}

//==========================================================================
//
//	Crash
//
//==========================================================================

final void Crash()
{
	if (CrashState && bCorpse && !bIceDamage)
	{
		SetState(CrashState);
	}
}

//===========================================================================
//
//  PlayerLandedOnThing
//
//===========================================================================

final void PlayerLandedOnThing()
{
	PlayerEx(Player).DeltaViewHeight = Velocity.z / 8.0;
	FallingDamage();
	if (Health > 0 && !PlayerIsMorphed())
	{
		if (Velocity.z < -DEFAULT_GRAVITY * 0.375)
		{
			PlaySound('*grunt', CHAN_VOICE);
		}
		if ((Origin.z > FloorZ || !GetFloorType()->bLiquid) &&
			!AreSoundsEquivalent('*grunt', '*land'))
		{
			PlaySound('*land', CHAN_BODY);
		}
	}
//FIXME Player.centreing = true;
}

//==========================================================================
//
//  FallingDamage
//
//==========================================================================

final void FallingDamage()
{
	int		damage;
	float	mom;
	float	dist;

	mom = fabs(Velocity.z);

	if (Level.bFallingDamage)
	{
		//	Hexen style falling damage.
		if (mom <= 23.0 * 35.0)
		{
			//	Not fast enough.
			return;
		}
		if (mom >= 63.0 * 35.0)
		{
			//	Automatic death.
			damage = 10000;
		}
		else
		{
			dist = mom / 35.0 * 16.0 / 23.0;
			damage = ftoi(dist * dist / 10.0) - 24;
			if (Velocity.z > -39.0 * 35.0 && damage > Health && Health != 1)
			{
				//	No-death threshold.
				damage = Health - 1;
			}
		}
	}
	else if (Level.bOldFallingDamage)
	{
		//	ZDoom style falling damage, less damaging.
		if (mom <= 19.0 * 35.0)
		{
			//	Not fast enough.
			return;
		}
		if (mom >= 84.0 * 35.0)
		{
			//	Automatic death.
			damage = 10000;
		}
		else
		{
			mom = mom / 35.0;
			damage = (ftoi(mom * mom * 11.0 / 128.0) - 30) / 2;
			if (damage < 1)
			{
				damage = 1;
			}
		}
	}
	else if (Level.bStrifeFallingDamage)
	{
		//	Strife style falling damage, very strong.
		if (mom <= 20.0 * 35.0)
		{
			//	Not fast enough.
			return;
		}
		damage = ftoi(mom * (8192.0 / 3125.0 / 35.0));
	}
	else
	{
		return;
	}

	PlaySound('*land', CHAN_BODY);
	Damage(none, none, damage);
	LineSpecialLevelInfo(Level).NoiseAlert(self, self);
}

//==========================================================================
//
//  MonsterFallingDamage
//
//==========================================================================

final void MonsterFallingDamage()
{
	int		damage;
	float	mom;

	if (!Level.bMonsterFallingDamage)
	{
		return;
	}

	mom = fabs(Velocity.z) / 35.0;
	if (mom > 35.0)
	{
		// automatic death
		damage = 10000;
	}
	else
	{
		damage = ftoi((mom - 23.0) * 6.0);
	}
	damage = 10000;	// always kill 'em
	Damage(none, none, damage);
}

//==========================================================================
//
//	BlasterPhysics
//
//  Thinker for the ultra-fast blaster PL2 ripper-spawning missile.
//
//==========================================================================

final bool BlasterPhysics(float DeltaTime)
{
	int			i;
	float		xfrac;
	float		yfrac;
	float		zfrac;
	bool		changexy;
	tmtrace_t	tmtrace;

	// Handle movement
	if (Velocity.x || Velocity.y || (Origin.z != FloorZ) || Velocity.z)
	{
		xfrac = Velocity.x * DeltaTime / 8.0;
		yfrac = Velocity.y * DeltaTime / 8.0;
		zfrac = Velocity.z * DeltaTime / 8.0;
		changexy = xfrac || yfrac;
		for (i = 0; i < 8; i++)
		{
			if (changexy)
			{
				if (!TryMoveEx(&tmtrace, vector(Origin.x + xfrac,
					Origin.y + yfrac, Origin.z)))
				{
					// Blocked move
					if (tmtrace.BlockingMobj)
					{
						BlasterHitMobj(tmtrace.BlockingMobj);
					}
					else
					{
						ExplodeMissile();
					}
					return !IsDestroyed();
				}
			}
			Origin.z += zfrac;
			if (Origin.z <= FloorZ)
			{
				// Hit the floor
				Origin.z = FloorZ;
				HitFloorType();
				ExplodeMissile();
				return !IsDestroyed();
			}
			if (Origin.z + Height > CeilingZ)
			{
				// Hit the ceiling
				Origin.z = CeilingZ - Height;
				ExplodeMissile();
				return !IsDestroyed();
			}
			if (changexy)
			{
				SpawnBlasterEffects();
			}
		}
	}
	return true;
}

//==========================================================================
//
//  ResetBlasted
//
//==========================================================================

final void ResetBlasted()
{
	bBlasted = false;
	if (!bIceCorpse)
	{
		bSlide = false;
	}
}

//==========================================================================
//
//	OnHitFloor
//
//==========================================================================

void OnHitFloor()
{
}

//==========================================================================
//
//	BlasterHitMobj
//
//==========================================================================

bool BlasterHitMobj(Entity Other)
{
	return ExplodeMissile();
}

//==========================================================================
//
//  SpawnBlasterEffects
//
//==========================================================================

void SpawnBlasterEffects()
{
}

//==========================================================================
//
//  HitFloorType
//
//==========================================================================

final bool HitFloorType()
{
	EntityEx		A;
	TVec			org;
	bool			smallsplash = false;
	VTerrainInfo*	TInfo;
	VSplashInfo*	SInfo;

	if (FloorZ != GetPlanePointZ(&Sector->floor, Origin))
	{
		// don't splash if landing on the edge above water/lava/etc....
		return false;
	}

	// Things that don't splash go here
	if (bNoSplash)
	{
		return false;
	}

	TInfo = GetFloorType();

	// Small splash for small masses
	if (Mass < 10.0 || bSmallSplash)
		smallsplash = true;

	if (TInfo->DamageAmount && bIsPlayer &&
		XLevel.TicTime & TInfo->DamageTimeMask)
	{
		Damage(GetDamageTypeInflictor(TInfo->DamageType), none,
			TInfo->DamageAmount);
	}

	SInfo = GetSplashInfo(TInfo->Splash);
	if (!SInfo)
	{
		return TInfo->bLiquid;
	}

	org = Origin;
	org.z = FloorZ;

	if (smallsplash)
	{
		if (SInfo->SmallClass)
		{
			A = Spawn(class<EntityEx>(SInfo->SmallClass), org);
			A.FloorClip += SInfo->SmallClip;
			if (SInfo->SmallSound)
			{
				A.PlaySound(SInfo->SmallSound, CHAN_VOICE);
			}
		}
	}
	else
	{
		if (SInfo->BaseClass)
		{
			Spawn(class<EntityEx>(SInfo->BaseClass), org);
			if (SInfo->Sound && !SInfo->ChunkClass)
			{
				A.PlaySound(SInfo->Sound, CHAN_VOICE);
			}
		}
		if (SInfo->ChunkClass)
		{
			A = Spawn(class<EntityEx>(SInfo->ChunkClass), org);
			A.Target = self;
			A.Velocity.x = (Random() - Random()) * SInfo->ChunkXVelMul * 35.0;
			A.Velocity.y = (Random() - Random()) * SInfo->ChunkYVelMul * 35.0;
			A.Velocity.z = (SInfo->ChunkBaseZVel + Random() *
				SInfo->ChunkZVelMul) * 35.0;
			if (SInfo->Sound)
			{
				A.PlaySound(SInfo->Sound, CHAN_VOICE);
			}
		}
		if (SInfo->Sound && !SInfo->BaseClass && !SInfo->ChunkClass)
		{
			PlaySound(SInfo->Sound, CHAN_BODY);
		}
		if (!SInfo->bNoAlert && bIsPlayer)
		{
			LineSpecialLevelInfo(Level).NoiseAlert(self, self);
		}
	}
	return TInfo->bLiquid;
}

//===========================================================================
//
//  GetFloorType
//
//===========================================================================

final VTerrainInfo* GetFloorType()
{
	return TerrainType(Floor->pic);
}

//==========================================================================
//
//	HandleFloorclip
//
//==========================================================================

final void HandleFloorclip()
{
	if (bFloorClip)
	{
		VTerrainInfo* TInfo = GetFloorType();
		if (Origin.z == FloorZ && TInfo->bLiquid)
		{
			FloorClip = TInfo->FootClip;
		}
		else
		{
			FloorClip = 0.0;
		}
	}
}

//==========================================================================
//
//  ApplyFriction
//
//==========================================================================

final void ApplyFriction()
{
	float dot;

	if (bMissile || bSkullFly)
	{
		// no friction for missiles ever
		return;
	}

	if (Origin.z > FloorZ && !bOnMobj && WaterLevel < 2 && !bFly &&
		!bFallingFriction)
	{
		// no friction when airborne
		return;
	}

	//  Clip velocity
	if (Origin.z <= FloorZ)
	{
		dot = DotProduct(Velocity, Floor->normal);
		if (dot < 0.0)
		{
			Velocity -= dot * Floor->normal;
		}
	}

	if (bCorpse)
	{
		// Don't stop sliding if halfway off a step with some momentum
		if (Velocity.x > 0.25 * 35.0 || Velocity.x < -0.25 * 35.0 ||
			Velocity.y > 0.25 * 35.0 || Velocity.y < -0.25 * 35.0)
		{
			if (FloorZ != GetPlanePointZ(&Sector->floor, Origin))
			{
				return;
			}
		}
	}

	if (Velocity.x > -STOPSPEED && Velocity.x < STOPSPEED &&
		Velocity.y > -STOPSPEED && Velocity.y < STOPSPEED &&
		Velocity.z > -STOPSPEED && Velocity.z < STOPSPEED &&
		(!bIsPlayer || (!Player.ForwardMove && !Player.SideMove)))
	{
		if (bIsPlayer)
		{
			// if in a walking frame, stop moving
			if (StateIsInRange(State, SeeState, none, 4))
			{
				SetState(IdleState);
			}
		}
		Velocity = vector(0.0, 0.0, 0.0);
	}
	else
	{
		// slow down
		Velocity -= Velocity * (GetFriction() * Level.Game.frametime);
	}
}

//===========================================================================
//
//  GetFriction
//
//===========================================================================

final float GetFriction()
{
	if (WaterLevel > 1)
	{
		return FRICTION_WATER;
	}
	if (bFly && Origin.z > FloorZ && !bOnMobj)
	{
		return FRICTION_FLY;
	}
	if ((Sector->special & SECSPEC_BASE_MASK) == SECSPEC_FrictionLow)
	{
		return FRICTION_LOW;
	}
	VTerrainInfo* TInfo = GetFloorType();
	if (TInfo->Friction)
	{
		return TInfo->Friction;
	}
	if (Sector->special & SECSPEC_FRICTION_MASK)
	{
		return Sector->Friction;
	}
	return FRICTION_NORMAL;
}

//**************************************************************************
//
//  RADIUS ATTACK
//
//**************************************************************************

//==========================================================================
//
//	RadiusAttack
//
//	Source is the creature that caused the explosion at spot.
//
//==========================================================================

final void RadiusAttack(EntityEx Source, int BombDamage, float BombDistance,
	bool DamageSource)
{
	EntityEx	Other;
	float		dist;
	int			damage;

	foreach RadiusThings(Other, Origin, BombDistance)
	{
		if (!Other.bShootable)
		{
			continue;
		}

		//	Check for actors that take no damage from concussion.
		if (bNoRadiusDamage)
		{
			continue;
		}

		if (!DamageSource && Other == Source)
		{
			// don't damage the source of the explosion
			continue;
		}

		dist = Length(Other.GetCentre() - GetCentre()) - Other.Radius;
		if (dist < 0.0)
		{
			dist = 0.0;
		}

		if (dist >= BombDistance)
		{
			// out of range
			continue;
		}

		if (Other.CanSee(self))
		{
			// OK to damage, target is in direct path
			damage = ftoi(itof(BombDamage) * RDFactor *
				(BombDistance - dist) / BombDistance);
			Other.Damage(self, Source, damage);
		}
	}
}

//**************************************************************************
//
//  AIMING
//
//**************************************************************************

//==========================================================================
//
//  AimLineAttack
//
//  Sets linetaget and aim_slope when a target is aimed at.
//
//==========================================================================

final TVec AimLineAttack(TAVec angles, float distance)
{
	float			x2;
	float			y2;
	float			topangle;
	float			botangle;
	TVec			dir;
	intercept_t*	in;

	// Height if not aiming up or down
	// ???: use slope for monsters?
	float			aim_z;
	float			aim_range;
	float			aim_slope;
	TVec			aim_dir;
	float			aim_topslope;
	float			aim_bottomslope;	// slopes to top and bottom of target
	float			aim_range2d;

	AngleVector(&angles, &aim_dir);
	x2 = Origin.x + distance * aim_dir.x;
	y2 = Origin.y + distance * aim_dir.y;
	aim_z = Origin.z + Height / 2.0 + 8.0 - FloorClip;
	aim_range2d = Length(vector(distance * aim_dir.x, distance * aim_dir.y,
		0.0));

	// can't shoot outside view angles
	topangle = AngleMod180(-angles.pitch + 30.0);
	botangle = AngleMod180(-angles.pitch - 30.0);
	if (topangle > 89.0)
		topangle = 89.0;
	if (botangle < -89.0)
		botangle = -89.0;
	aim_topslope = tan(topangle);
	aim_bottomslope = tan(botangle);

	aim_range = distance;
	linetarget = none;

	foreach PathTraverse(in, Origin.x, Origin.y, x2, y2,
		PT_ADDLINES | PT_ADDTHINGS)
	{
		line_t*		li;
		EntityEx	th;
		float		thingtopslope;
		float		thingbottomslope;
		float		dist;
		float		slope;
		opening_t*	open;

		if (in->bIsALine)
		{
			TVec hit_point;

			li = in->line;

			if (!(li->flags & ML_TWOSIDED))
				break;	// stop

			// Crosses a two sided line.
			// A two sided line will restrict
			// the possible target ranges.
			dist = aim_range * in->frac;
			hit_point = Origin + dist * aim_dir;
			open = LineOpenings(li, hit_point);
			open = FindOpening(open, hit_point.z, hit_point.z);

			if (!open || open->bottom >= open->top)
				break;	// stop

			dist = aim_range2d * in->frac;
			if (li->frontsector->floorheight != li->backsector->floorheight)
			{
				slope = (open->bottom - aim_z) / dist;
				if (slope > aim_bottomslope)
					aim_bottomslope = slope;
			}

			if (li->frontsector->ceilingheight != li->backsector->ceilingheight)
			{
				slope = (open->top - aim_z) / dist;
				if (slope < aim_topslope)
					aim_topslope = slope;
			}

			if (aim_topslope <= aim_bottomslope)
				break;	// stop

			continue;	// shot continues
		}

		// shoot a thing
		th = EntityEx(in->Thing);
		if (th == self)
			continue;	// can't shoot self

		if (!th.bShootable)
			continue;	// corpse or something

		if (th.bCantAutoAim)
		{
			// Can't auto-aim at pods
			continue;
		}

		if (IsTeammate(th))
		{
			// don't aim at fellow co-op players
			continue;
		}

		// check angles to see if the thing can be aimed at
		dist = aim_range2d * in->frac;
		thingtopslope = (th.Origin.z + th.Height - aim_z) / dist;

		if (thingtopslope < aim_bottomslope)
			continue;	// shot over the thing

		thingbottomslope = (th.Origin.z - aim_z) / dist;

		if (thingbottomslope > aim_topslope)
			continue;	// shot under the thing

		// this thing can be hit!
		if (thingtopslope > aim_topslope)
			thingtopslope = aim_topslope;

		if (thingbottomslope < aim_bottomslope)
			thingbottomslope = aim_bottomslope;

		aim_slope = (thingtopslope + thingbottomslope) / 2.0;
		linetarget = th;

		break;	// don't go any farther
	}

	if (linetarget)
	{
		angles.pitch = -atan(aim_slope);
	}
	AngleVector(&angles, &dir);
	return dir;
}

//===========================================================================
//
//	Aim
//
//  Sets a slope so a near miss is at aproximately the height of the
// intended target
//
//===========================================================================

final TVec Aim(float distance, optional float yaw)
{
	TAVec	ang;
	TVec	dir;

	// see which target is to be aimed at
	ang = Angles;
	if (specified_yaw)
	{
		ang.yaw = yaw;
	}

	dir = AimLineAttack(ang, distance);
	if (!linetarget)
	{
		ang.yaw = AngleMod360(ang.yaw + 45.0 / 8.0);
		dir = AimLineAttack(ang, distance);
		if (!linetarget)
		{
			ang.yaw = AngleMod360(ang.yaw - 45.0 / 4.0);
			dir = AimLineAttack(ang, distance);
			if (!linetarget)
			{
				ang.yaw = AngleMod360(ang.yaw + 45.0 / 8.0);
				AngleVector(&ang, &dir);
			}
		}
	}
	return dir;
}

//**************************************************************************
//
//  SHOOTING
//
//**************************************************************************

//==========================================================================
//
//  ShootHitPlane
//
//==========================================================================

final bool ShootHitPlane(sec_plane_t* plane, TVec linestart, TVec lineend,
	float range, class<EntityEx> PuffType)
{
	float	org_dist;
	float	hit_dist;

	if (plane->flags & SPF_NOBLOCKSHOOT)
	{
		//  Doesn't block shooting
		return true;
	}
	org_dist = DotProduct(linestart, plane->normal) - plane->dist;
	if (org_dist < 0.0)
	{
		//  Don't shoot back side
		return true;
	}
	hit_dist = DotProduct(lineend, plane->normal) - plane->dist;
	if (hit_dist >= 0.0)
	{
		//  Didn't hit plane
		return true;
	}

	//  Hit plane
	if (plane->pic == Level.Game.skyflatnum)
	{
		// don't shoot the sky!
		return false;
	}

	//  If we are shooting floor or ceiling we are adjusting position
	// to spawn puff on floor or ceiling, not on wall
	lineend -= (lineend - linestart) * hit_dist / (hit_dist - org_dist);

	// position a bit closer
	lineend += 4.0 * plane->normal;

	// Spawn bullet puffs.
	SpawnPuff(lineend, range, PuffType, false);

	// don't go any farther
	return false;
}

//==========================================================================
//
//  ShootCheckPlanes
//
//==========================================================================

final bool ShootCheckPlanes(sector_t* sec, TVec linestart, TVec lineend,
	float range, class<EntityEx> PuffType)
{
	sec_region_t *reg;
	sec_region_t *startreg;

	startreg = PointInRegion(sec, linestart);
	for (reg = startreg; reg; reg = reg->next)
	{
		if (!ShootHitPlane(reg->floor, linestart, lineend, range, PuffType))
		{
			//  Hit floor
			return false;
		}
		if (!ShootHitPlane(reg->ceiling, linestart, lineend, range, PuffType))
		{
			//  Hit ceiling
			return false;
		}
	}
	for (reg = startreg->prev; reg; reg = reg->prev)
	{
		if (!ShootHitPlane(reg->floor, linestart, lineend, range, PuffType))
		{
			//  Hit floor
			return false;
		}
		if (!ShootHitPlane(reg->ceiling, linestart, lineend, range, PuffType))
		{
			//  Hit ceiling
			return false;
		}
	}
	return true;
}

//==========================================================================
//
//  LineAttack
//
//  If damage == 0, it is just a test trace that will leave linetarget set.
//
//==========================================================================

final int LineAttack(TVec Dir, float Distance, int LADamage,
	class<EntityEx> PuffType, optional bool NoAttackGhosts,
	optional TVec* OutHitPoint)
{
	TVec			Dst;
	intercept_t*	in;
	TVec			LineStart;
	TVec			LineEnd;
	TVec			ShootOrigin;

	ShootOrigin = Origin;
	ShootOrigin.z += Height * 0.5 + 8.0 - FloorClip;

	Dst = ShootOrigin + Distance * Dir;
	LineStart = ShootOrigin;
	foreach PathTraverse(in, Origin.x, Origin.y, Dst.x, Dst.y,
		PT_ADDLINES | PT_ADDTHINGS)
	{
		TVec		hit_point;
		line_t*		li;
		EntityEx	th;

		if (in->bIsALine)
		{
			sector_t *sec;

			li = in->line;
			hit_point = ShootOrigin + (Distance * in->frac) * Dir;
			if (li->flags & ML_TWOSIDED && PointOnPlaneSide(ShootOrigin, li))
			{
				sec = li->backsector;
			}
			else
			{
				sec = li->frontsector;
			}

			LineEnd = hit_point;

			//  Check for shooting floor or ceiling
			if (!ShootCheckPlanes(sec, LineStart, LineEnd, Distance, PuffType))
			{
				return false;
			}

			LineStart = LineEnd;

			//  Execute line special after checking for hitting floor or ceiling
			// when we know that it actally hits line
			if (li->special)
			{
				LineSpecialLevelInfo(Level).ActivateLine(li, self, 0, SPAC_IMPACT);
			}

			if (li->flags & ML_TWOSIDED)
			{
				// crosses a two sided line
				opening_t *open;
				float opentop = 0.0;

				open = LineOpenings(li, hit_point);
				if (open)
				{
					opentop = open->top;
				}
				while (open)
				{
					if (open->bottom <= hit_point.z && open->top >= hit_point.z)
					{
						// shot continues
						break;
					}
					open = open->next;
				}
				if (open)
				{
					continue;
				}
				if (li->frontsector->ceiling.pic == Level.Game.skyflatnum &&
					li->backsector->ceiling.pic == Level.Game.skyflatnum &&
					hit_point.z > opentop)
				{
					// it's a sky hack wall
					return false;
				}
			}

			//  Hit line

			// position a bit closer
			hit_point -= 4.0 * Dir;

			// Spawn bullet puffs.
			SpawnPuff(hit_point, Distance, PuffType, false);

			// don't go any farther
			return false;
		}

		// shoot a thing
		th = EntityEx(in->Thing);

		if (th == self)
			continue;	// can't shoot self

		if (!th.bShootable)
			continue;	// corpse or something

		// check angles to see if the thing can be aimed at
		hit_point = ShootOrigin + (Distance * in->frac) * Dir;

		if (th.Origin.z + th.Height < hit_point.z)
			continue;	// shot over the thing

		if (th.Origin.z > hit_point.z)
			continue;	// shot under the thing

		// hit thing
		// position a bit closer
		hit_point -= 10.0 * Dir;

		//  check for physical attacks on a ghost
		if (th.Alpha < 1.0 && NoAttackGhosts)
		{
			continue;
		}

		if (OutHitPoint)
		{
			*OutHitPoint = hit_point;
		}

		// Spawn bullet puffs or blod spots, depending on target type.
		if (PuffType.default.bPuffOnActors || th.bNoBlood ||
			th.bInvulnerable || th.bDormant)
		{
			SpawnPuff(hit_point, Distance, PuffType, true);
		}
		if (!LineSpecialGameInfo(Level.Game).bBloodSplatter && !th.bNoBlood &&
			!th.bInvulnerable && !th.bDormant)
		{
			SpawnBlood(hit_point, LADamage);
		}
		if (LADamage && LineSpecialGameInfo(Level.Game).bBloodSplatter)
		{
			if (!th.bNoBlood && !th.bInvulnerable && !th.bDormant)
			{
				if (PuffType.default.bAxeBlood)
				{
					th.SpawnBloodSplatter2(hit_point);
				}
				if (P_Random() < 192)
				{
					th.SpawnBloodSplatter(hit_point, LADamage);
				}
			}
		}

		if (LADamage)
		{
			th.Damage(self, self, LADamage);
		}

		// don't go any farther
		return false;
	}
	LineEnd = Dst;
	return ShootCheckPlanes(XLevel.PointInSector(Dst), LineStart, LineEnd,
		Distance, PuffType);
}

bool ExplodeMissile()
{
	return true;
}

float GetBaseViewHeight()
{
	return 0.0;
}

EntityEx GetDamageTypeInflictor(name DamageType)
{
	return none;
}

bool PlayerIsMorphed()
{
	return false;
}

bool IsTeammate(EntityEx Other)
{
	return bIsPlayer && Other.bIsPlayer && Level.Game.netgame &&
		!Level.Game.deathmatch;
}

void SpawnPuff(TVec Org, float Range, class<EntityEx> PuffType, bool HitThing)
{
}

void SpawnBlood(TVec hit_point, int damage)
{
}

void SpawnBloodSplatter(TVec hit_point, int damage)
{
}

void SpawnBloodSplatter2(TVec hit_point)
{
}

//**************************************************************************
//**************************************************************************

//==========================================================================
//
//  SetInstigator
//
//==========================================================================

void SetInstigator(Entity NewInstigator)
{
}

//==========================================================================
//
//  PlaySightSound
//
//==========================================================================

void PlaySightSound()
{
}

//==========================================================================
//
//  CheckMissileSpawn
//
//==========================================================================

bool CheckMissileSpawn()
{
	return true;
}

//==========================================================================
//
//  SetDropped
//
//==========================================================================

void SetDropped()
{
}

//==========================================================================
//
//  StartFloatBob
//
//==========================================================================

void StartFloatBob(Entity Src)
{
}

//==========================================================================
//
//  SaveFloatBobOffset
//
//==========================================================================

void SaveFloatBobOffset()
{
}

//==========================================================================
//
//  TestLocation
//
//==========================================================================

bool TestLocation()
{
}

//==========================================================================
//
//  ThingDestroy
//
//==========================================================================

bool ThingDestroy()
{
	return false;
}

//==========================================================================
//
//  Thrust
//
//==========================================================================

void Thrust(float Angle, float Force)
{
}

//==========================================================================
//
//  ThingDamage
//
//==========================================================================

void ThingDamage(int Amount)
{
}

//==========================================================================
//
//  IsTeleportSpot
//
//==========================================================================

bool IsTeleportSpot()
{
	return false;
}

//==========================================================================
//
//  IsTeleportSpot2
//
//==========================================================================

bool IsTeleportSpot2()
{
	return false;
}

//==========================================================================
//
//  CanTeleport
//
//==========================================================================

bool CanTeleport()
{
	return false;
}

//==========================================================================
//
//  Teleport
//
//==========================================================================

bool Teleport(TVec Dst, float angle, bool DstFog, bool SrcFog, bool KeepDir)
{
	return false;
}

//==========================================================================
//
//  TeleportMove
//
//==========================================================================

bool TeleportMove(TVec Pos)
{
	return false;
}

//==========================================================================
//
//  SetPainState
//
//==========================================================================

void SetPainState()
{
}

//==========================================================================
//
//  IsPointPusher
//
//==========================================================================

bool IsPointPusher()
{
	return false;
}

//==========================================================================
//
//  IsPointPuller
//
//==========================================================================

bool IsPointPuller()
{
	return false;
}

//==========================================================================
//
//  CanWindThrust
//
//==========================================================================

bool CanWindThrust()
{
	return false;
}

//==========================================================================
//
//  GetPlayerViewHeight
//
//==========================================================================

float GetPlayerViewHeight()
{
	return 0.0;
}

//==========================================================================
//
//  Damage
//
//==========================================================================

void Damage(EntityEx inflictor, EntityEx source, int damage)
{
}

defaultproperties
{
	MissileChance = 200.0;
	FloatSpeed = 140.0;
	BounceFactor = 0.7;
	RDFactor = 1.0;
}
