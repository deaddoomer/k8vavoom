//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class PlayerEx : BasePlayer
	abstract;

//
// Player internal flags, for cheats and debug.
//
enum
{
	CF_NOCLIP		= 1 << 0,		// No clipping, walk through barriers.
	CF_GODMODE		= 1 << 1,		// No damage, no health loss.
	CF_REGENERATION	= 1 << 2,		// Regenerate Health points.
	CF_FRIGHTENING	= 1 << 3		// Scare monsters away.
};

const float USERANGE		= 64.0;
const float USETHINGRANGE	= 128.0;

const float BLINKTHRESHOLD	= 4.0;

// 16 pixels of bob
const float MAXBOB			= 16.0;

const int MAXHEALTH			= 100;
const int MAXMORPHHEALTH	= 30;

// For screen flashing (red or bright).
float			DamageFlash;
float			BonusFlash;

// Base height above floor for viewz.
float			ViewHeight;
// Bob/squat speed.
float			DeltaViewHeight;
// bounded/scaled total momentum.
float			Bob;

// Who did damage (none for floors/ceilings).
EntityEx		Attacker;

float			JumpTime;
int				LocalQuakeHappening;

TVec			MoveDir;

float			LastSectorDamageTime;

float			HazardTime;
float			LastHazardTime;

// Bit flags, for cheats and debug.
// See cheat_t, above.
int				Cheats;

Weapon			ReadyWeapon;
Weapon			PendingWeapon;	// Is none if not changing.

// Refired shots are less accurate.
int				Refire;

float			FlyHeight;

array<name>		RevealedMaps;

Inventory		InvFirst;
Inventory		InvPtr;
float			InventoryTime;
int				ArtifactFlash;
int				InvSize;

Inventory		SavedInventory;

bool			onground;
//	Revert camera if player moves.
bool			bRevertCamera;
//	Player cannot move.
bool			bFrozen;
//	Player cannot do anything except press use.
bool			bTotallyFrozen;
//	Monster don't target
bool			bNoTarget;
//	Switch weapons instantly.
bool			bInstantWeaponSwitch;
//	Player is flying
bool			bFly;
//	Inventory bar is always open
bool			bInventoryAlwaysOpen;
//	Auto aiming
bool			bAutoAim;

int				PoisonCount;	// screen flash for poison damage
float			LastPoisonTime;
EntityEx		Poisoner;		// none for non-player mobjs
PlayerEx		PoisonerPlayer;	// for KArena

int				Objectives;

float			MorphTime;	// player is morphed into something if > 0
int				MorphStyle;
class<Actor>	UnmorphFlash;

int				Accuracy;
int				Stamina;

float			BlendR;
float			BlendG;
float			BlendB;
float			BlendA;

int				ChickenPeck;	// chicken peck countdown

Actor			Rain1;	// active rain maker 1
Actor			Rain2;	// active rain maker 2

const int MAX_MAPS_VISITED = 100;

name			MapsVisited[MAX_MAPS_VISITED];

float			FOV;			// current Field Of Vision
float			DesiredFOV;		// desired Field Of Vision

replication
{
	reliable if (!bIsClient)
		Cheats, ReadyWeapon, InvFirst, InvPtr, InventoryTime, ArtifactFlash,
		Objectives, MorphTime, Accuracy, Stamina, MapsVisited, DamageFlash,
		BonusFlash, Attacker, bFrozen, bTotallyFrozen, DesiredFOV, FOV;

	unreliable if (!bIsClient)
		ParticleEffect, ClientExplosion, ClientParticleExplosion,
		ClientSparkParticles, ClientRailTrail;

	reliable if (!bIsClient)
		ClientVoice, ClientSpeech, ClientFinaleType, ClientSlideshow1,
		ClientSlideshow2, SetFOV;

	reliable if (bIsClient)
		bAutoAim;
}

//==========================================================================
//
//  ThrustPlayer
//
//  Moves the given origin along a given angle.
//
//==========================================================================

final void ThrustPlayer(float angle, float move, float deltaTime)
{
	if ((!EntityEx(MO).FindInventory(PowerFlight) ||
		MO.Origin.z <= MO.FloorZ) &&
		((EntityEx(MO).GetFloorType()->Friction &&
		EntityEx(MO).GetFloorType()->Friction < EntityEx::FRICTION_NORMAL) ||
		(MO.Sector->special & SECSPEC_BASE_MASK) == SECSPEC_FrictionLow))
	{
		move *= LineSpecialGameInfo(Level.Game).IceMoveFactor;
	}
	MO.Velocity.x += move * cos(angle) * deltaTime;
	MO.Velocity.y += move * sin(angle) * deltaTime;
}

//==========================================================================
//
//  CalcHeight
//
//  Calculate the walking / running height adjustment
//
//==========================================================================

final void CalcHeight(float deltaTime)
{
	float angle;
	float bob;

	// Regular movement bobbing
	// (needs to be calculated for gun swing even if not on ground)
	Bob = MO.Velocity.x * MO.Velocity.x + MO.Velocity.y * MO.Velocity.y;
	Bob /= 4.0 * 35.0 * 35.0;
	if (Bob > MAXBOB)
		Bob = MAXBOB;

	if (MO.bFly && !onground)
	{
		Bob = 0.5;
	}

	angle = 180.0 * 35.0 / 10.0 * Level.XLevel.Time;
	bob = Bob / 2.0 * sin(angle);

	// move viewheight
	if (PlayerState == PST_LIVE)
	{
		ViewHeight += DeltaViewHeight * deltaTime;

		if (ViewHeight > PlayerPawn(MO).ViewHeight)
		{
			ViewHeight = PlayerPawn(MO).ViewHeight;
			DeltaViewHeight = 0.0;
		}

		if (ViewHeight < PlayerPawn(MO).ViewHeight / 2.0)
		{
			ViewHeight = PlayerPawn(MO).ViewHeight / 2.0;
			if (DeltaViewHeight <= 0.0)
				DeltaViewHeight = 0.00001;
		}

		if (DeltaViewHeight)
		{
			DeltaViewHeight += 256.0 * deltaTime;
			if (!DeltaViewHeight)
				DeltaViewHeight = 0.00001;
		}
	}
	ViewOrg.z = MO.Origin.z + ViewHeight + bob;

	if (PlayerState != PST_DEAD && MO.Origin.z <= MO.FloorZ)
	{
		ViewOrg.z -= MO.FloorClip;
	}
	if (ViewOrg.z < MO.FloorZ + 4.0)
		ViewOrg.z = MO.FloorZ + 4.0;

	if (ViewOrg.z > MO.CeilingZ - 4.0)
		ViewOrg.z = MO.CeilingZ - 4.0;
}

//==========================================================================
//
//  MovePlayer
//
//==========================================================================

final void MovePlayer(float deltaTime)
{
	float forward;
	float side;
	float fly;

	// Do not let the player control movement
	//  if not onground.
	onground = MO.Origin.z <= MO.FloorZ || EntityEx(MO).bOnMobj;

	forward = ForwardMove * 5.0;
	side = SideMove * 5.0;

	PlayerPawn(MO).AdjustSpeed(forward, side);

	if (!onground && !MO.bNoGravity && !MO.WaterLevel)
	{
		//  not on ground, so we have little effect on velocity
		forward *= Level.AirControl;
		side *= Level.AirControl;
	}

	if (forward)
	{
		ThrustPlayer(MO.Angles.yaw, forward, deltaTime);
	}
	if (side)
	{
		ThrustPlayer(AngleMod360(MO.Angles.yaw - 90.0), side, deltaTime);
	}

	if (forward || side)
	{
		SetPlayerRunState();

		if (bRevertCamera)
		{
			Camera = MO;
			bRevertCamera = false;
		}
	}

	fly = FlyMove / 16.0;
	if (fly && (EntityEx(MO).FindInventory(PowerFlight) || bFly))
	{
		if (FlyMove != TOCENTRE)
		{
			FlyHeight = fly * 2.0;
			if (!MO.bFly)
			{
				MO.bFly = true;
				MO.bNoGravity = true;
				if (MO.Velocity.z <= -39.0 * 35.0)
				{
					// stop falling scream
					MO.StopSound(CHAN_VOICE);
				}
			}
		}
		else
		{
			MO.bFly = false;
			MO.bNoGravity = false;
		}
	}
	else if (fly > 0.0)
	{
		UseFlyPower();
	}
	if (MO.bFly)
	{
		MO.Velocity.z = FlyHeight * 35.0;
		if (FlyHeight)
		{
			FlyHeight /= 2.0;
		}
	}

	if ((Buttons & BT_JUMP) && onground && !JumpTime)
	{
		MO.Velocity.z = PlayerPawn(MO).JumpVelZ * 1.1;
		EntityEx(MO).bOnMobj = false;
		JumpTime = 0.5;
	}
}

//==========================================================================
//
//  CheckWaterJump
//
//==========================================================================

final void CheckWaterJump()
{
	TVec start;
	TVec end;
	TVec vforward;
	TVec HitPoint;
	TVec HitNormal;

	// check for a jump-out-of-water
	AngleVector(&MO.Angles, &vforward);
	start = MO.Origin;
	start.z += MO.Height * 0.5 + 8.0;
	vforward.z = 0.0;
	vforward = Normalise(vforward);
	end = start + vforward * 24.0;
	if (!Level.XLevel.TraceLine(start, end, HitPoint, HitNormal))
	{
		// solid at waist
		start.z = MO.Origin.z + MO.Height;
		end = start + vforward * 24.0;
		MoveDir = HitNormal * -50.0;
		if (Level.XLevel.TraceLine(start, end, HitPoint, HitNormal))
		{
			// open at eye level
			EntityEx(MO).bWaterJump = true;
			MO.Velocity.z = 350.0;
			EntityEx(MO).ReactionTime = 2.0;	// safety net
		}
	}
}

//==========================================================================
//
//  WaterMove
//
//==========================================================================

final void WaterMove(float deltaTime)
{
	float forward;
	float side;
	TVec vforward;
	TVec vright;
	TVec vup;
	TVec wishvel;

	// Do not let the player control movement
	//  if not onground.
	onground = (MO.Origin.z <= MO.FloorZ) || EntityEx(MO).bOnMobj;

	AngleVectors(&MO.Angles, &vforward, &vright, &vup);

	forward = ForwardMove;
	side = SideMove;

	PlayerPawn(MO).AdjustSpeed(forward, side);

	wishvel = vforward * forward + vright * side;
	if (!forward && !side /* && !cmd.upmove */ )
		wishvel.z -= 60.0;	// drift towards bottom
//  else
//      wishvel.z += cmd.upmove;

	MO.Velocity += 3.5 * deltaTime * wishvel;

	if (forward || side)
	{
		SetPlayerRunState();
	}

	if (Buttons & BT_JUMP)
	{
		if (MO.WaterType == CONTENTS_WATER)
			MO.Velocity.z = 100.0;
		else if (MO.WaterType == CONTENTS_NUKAGE ||
			MO.WaterType == CONTENTS_SLIME || MO.WaterType == CONTENTS_SLUDGE)
			MO.Velocity.z = 80.0;
		else
			MO.Velocity.z = 50.0;
	}
	CheckWaterJump();
}

//==========================================================================
//
//  WaterJump
//
//==========================================================================

final void WaterJump()
{
	if (!EntityEx(MO).ReactionTime || !MO.WaterLevel)
	{
		EntityEx(MO).bWaterJump = false;
		EntityEx(MO).ReactionTime = 0.0;
	}
	MO.Velocity.x = MoveDir.x;
	MO.Velocity.y = MoveDir.y;
}

//==========================================================================
//
//  PlayerInSpecialSector
//
//  Called every tic frame that the player origin is in a special sector.
//
//==========================================================================

final void PlayerInSpecialSector(float deltaTime)
{
	float speed;
	float finean;

	if (MO.Origin.z != GetPlanePointZ(&MO.Sector->floor, MO.Origin) &&
		!MO.WaterLevel)
	{
		// Player is not touching the floor
		return;
	}

	if (MO.Sector->special & SECSPEC_SECRET_MASK)
	{
		//	Secret area.
		SecretCount++;
		Level.CurrentSecret++;
		MO.Sector->special &= ~SECSPEC_SECRET_MASK;
		centreprint("You found a secret area");
		MO.PlaySound('misc/secret', CHAN_VOICE);
	}

	//	Search for iron feet power. Any subclass will do.
	Inventory IronFeet = EntityEx(MO).Inventory;
	while (IronFeet)
	{
		if (PowerIronFeet(IronFeet))
		{
			break;
		}
		IronFeet = IronFeet.Inventory;
	}

	if (MO.Sector->special >= SECSPEC_LightFlicker &&
		MO.Sector->special <= 255)
	{
		switch (MO.Sector->special)
		{
		case SECSPEC_DamageHellslime:
			if (!IronFeet &&
				Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				EntityEx(MO).Damage(none, none, 10, 'Slime');
			}
			break;
		case SECSPEC_DamageSludge:
			if (!IronFeet &&
				Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				EntityEx(MO).Damage(none, none, 4);
			}
			break;
		case SECSPEC_DamageNukage:
			if (!IronFeet &&
				Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				EntityEx(MO).Damage(none, none, 5, 'Slime');
			}
			break;
		case SECSPEC_LightStrobeFastDamage:
		case SECSPEC_DamageSuperHellslime:
			if (!IronFeet || (P_Random() < 5 && P_Random() < 5))
			{
				if (Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
				{
					LastSectorDamageTime = Level.XLevel.Time;
					EntityEx(MO).Damage(none, none, 20, 'Slime');
				}
			}
			break;
		case SECSPEC_DamageSuperHellslimeExit:
			// EXIT SUPER DAMAGE! (for E1M8 finale)
			Cheats &= ~CF_GODMODE;
	
			if (Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				EntityEx(MO).Damage(none, none, 20);
			}
	
			if (Health <= 10)
			{
				Level.ExitLevel(0);
			}
			break;
		case SECSPEC_DamageLavaWimpy:
			if (Level.XLevel.Time - LastSectorDamageTime >= 16.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				EntityEx(MO).Damage(none, none, 5, 'Fire');
				EntityEx(MO).HitFloorType();
			}
			break;
		case SECSPEC_DamageLavaHefty:
			if (Level.XLevel.Time - LastSectorDamageTime >= 16.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				EntityEx(MO).Damage(none, none, 8, 'Fire');
				EntityEx(MO).HitFloorType();
			}
			break;
		case SECSPEC_ScrollEastLavaDamage:
			ThrustPlayer(0.0, 1024.0, deltaTime);
			if (Level.XLevel.Time - LastSectorDamageTime >= 16.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				EntityEx(MO).Damage(none, none, 5, 'Fire');
				EntityEx(MO).HitFloorType();
			}
			break;
		case SECSPEC_DamageHazard:
			if (!IronFeet)
				HazardTime += 2.0 * deltaTime;
			break;
		case SECSPEC_DamageInstantDeath:
			EntityEx(MO).Damage(none, none, 999, 'InstantDeath');
			break;
		case SECSPEC_DamageSuperHazard:
			if (!IronFeet)
				HazardTime += 4.0 * deltaTime;
			break;
		}
	}
	else
	{
		//	Extended sector damage type.
		switch (MO.Sector->special & SECSPEC_DAMAGE_MASK)
		{
		case 0x0100:
			if (!IronFeet &&
				Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				EntityEx(MO).Damage(none, none, 5, 'Fire');
			}
			break;
		case 0x0200:
			if (!IronFeet &&
				Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				EntityEx(MO).Damage(none, none, 10, 'Slime');
			}
			break;
		case 0x0300:
			if (!IronFeet ||  (P_Random() < 5 && P_Random() < 5))
			{
				if (Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
				{
					LastSectorDamageTime = Level.XLevel.Time;
					EntityEx(MO).Damage(none, none, 20, 'Slime');
				}
			}
			break;
		}
	}

	//	Apply any customizable damage
	if (MO.Sector->Damage)
	{
		if (MO.Sector->Damage < 20)
		{
			if (!IronFeet &&
				Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				EntityEx(MO).Damage(none, none, MO.Sector->Damage);
			}
		}
		else if (MO.Sector->Damage < 50)
		{
			if (!IronFeet ||  (P_Random() < 5 && P_Random() < 5))
			{
				if (Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
				{
					LastSectorDamageTime = Level.XLevel.Time;
					EntityEx(MO).Damage(none, none, MO.Sector->Damage);
				}
			}
		}
		else if (Level.XLevel.Time - LastSectorDamageTime >= 1.0 / 35.0)
		{
			LastSectorDamageTime = Level.XLevel.Time;
			EntityEx(MO).Damage(none, none, MO.Sector->Damage);
		}
	}

	switch (MO.Sector->special & SECSPEC_BASE_MASK)
	{
	case SECSPEC_ScrollCurrent:
		speed = itof((MO.Sector->tag - 100) % 10) / 16.0 * 35.0;
		finean = itof((MO.Sector->tag - 100) / 10) * 45.0;
		MO.Velocity.x += speed * cos(finean);
		MO.Velocity.y += speed * sin(finean);
		break;
	case SECSPEC_ScrollNorthSlow:
	case SECSPEC_ScrollNorthMedium:
	case SECSPEC_ScrollNorthFast:
		ThrustPlayer(90.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollNorthSlow], deltaTime);
		break;
	case SECSPEC_ScrollEastSlow:
	case SECSPEC_ScrollEastMedium:
	case SECSPEC_ScrollEastFast:
		ThrustPlayer(0.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollEastSlow], deltaTime);
		break;
	case SECSPEC_ScrollSouthSlow:
	case SECSPEC_ScrollSouthMedium:
	case SECSPEC_ScrollSouthFast:
		ThrustPlayer(270.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollSouthSlow], deltaTime);
		break;
	case SECSPEC_ScrollWestSlow:
	case SECSPEC_ScrollWestMedium:
	case SECSPEC_ScrollWestFast:
		ThrustPlayer(180.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollWestSlow], deltaTime);
		break;
	case SECSPEC_ScrollNorthWestSlow:
	case SECSPEC_ScrollNorthWestMedium:
	case SECSPEC_ScrollNorthWestFast:
		ThrustPlayer(135.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollNorthWestSlow], deltaTime);
		break;
	case SECSPEC_ScrollNorthEastSlow:
	case SECSPEC_ScrollNorthEastMedium:
	case SECSPEC_ScrollNorthEastFast:
		ThrustPlayer(45.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollNorthEastSlow], deltaTime);
		break;
	case SECSPEC_ScrollSouthEastSlow:
	case SECSPEC_ScrollSouthEastMedium:
	case SECSPEC_ScrollSouthEastFast:
		ThrustPlayer(315.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollSouthEastSlow], deltaTime);
		break;
	case SECSPEC_ScrollSouthWestSlow:
	case SECSPEC_ScrollSouthWestMedium:
	case SECSPEC_ScrollSouthWestFast:
		ThrustPlayer(225.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollSouthWestSlow], deltaTime);
		break;
	case SECSPEC_ScrollEast5:
	case SECSPEC_ScrollEast10:
	case SECSPEC_ScrollEast25:
	case SECSPEC_ScrollEast30:
	case SECSPEC_ScrollEast35:
		ThrustPlayer(0.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollEast5], deltaTime);
		break;
	case SECSPEC_ScrollNorth5:
	case SECSPEC_ScrollNorth10:
	case SECSPEC_ScrollNorth25:
	case SECSPEC_ScrollNorth30:
	case SECSPEC_ScrollNorth35:
		ThrustPlayer(90.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollNorth5], deltaTime);
		break;
	case SECSPEC_ScrollSouth5:
	case SECSPEC_ScrollSouth10:
	case SECSPEC_ScrollSouth25:
	case SECSPEC_ScrollSouth30:
	case SECSPEC_ScrollSouth35:
		ThrustPlayer(270.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollSouth5], deltaTime);
		break;
	case SECSPEC_ScrollWest5:
	case SECSPEC_ScrollWest10:
	case SECSPEC_ScrollWest25:
	case SECSPEC_ScrollWest30:
	case SECSPEC_ScrollWest35:
		ThrustPlayer(180.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollWest5], deltaTime);
		break;
	};
}

//============================================================================
//
//  PlayerOnSpecialFlat
//
//============================================================================

final void PlayerOnSpecialFlat(VTerrainInfo* floorType)
{
	if (MO.Origin.z != MO.FloorZ)
	{
		// Player is not touching the floor
		return;
	}

	if (floorType->bAllowProtection)
	{
		//	Search for iron feet power. Any subclass will do.
		Inventory IronFeet = EntityEx(MO).Inventory;
		while (IronFeet)
		{
			if (PowerIronFeet(IronFeet))
			{
				return;
			}
			IronFeet = IronFeet.Inventory;
		}
	}

	if (floorType->DamageAmount && Level.XLevel.Time - LastSectorDamageTime >=
		itof(floorType->DamageTimeMask + 1) / 35.0)
	{
		LastSectorDamageTime = Level.XLevel.Time;
		EntityEx(MO).Damage(none, none, 10, 'Fire');
		MO.PlaySound('world/lavasizzle', CHAN_BODY);
	}
}

//==========================================================================
//
//  PlayerInContents
//
//==========================================================================

final void PlayerInContents(float deltaTime)
{
	if (!MO.WaterLevel)
	{
		return;
	}

	//	Search for iron feet power. Any subclass will do.
	Inventory IronFeet = EntityEx(MO).Inventory;
	while (IronFeet)
	{
		if (PowerIronFeet(IronFeet))
		{
			break;
		}
		IronFeet = IronFeet.Inventory;
	}

	switch (MO.WaterType)
	{
	case CONTENTS_LAVA:
		if (!IronFeet &&
			Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
		{
			LastSectorDamageTime = Level.XLevel.Time;
			EntityEx(MO).Damage(none, none, 10, 'Fire');
		}
		break;

	case CONTENTS_NUKAGE:
		if (!IronFeet &&
			Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
		{
			LastSectorDamageTime = Level.XLevel.Time;
			EntityEx(MO).Damage(none, none, 5);
		}
		break;

	case CONTENTS_SLIME:
		if (!IronFeet &&
			Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
		{
			LastSectorDamageTime = Level.XLevel.Time;
			EntityEx(MO).Damage(none, none, 10);
		}
		break;

	case CONTENTS_HELLSLIME:
		if ((!IronFeet || (P_Random() < 5)) &&
			Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
		{
			LastSectorDamageTime = Level.XLevel.Time;
			EntityEx(MO).Damage(none, none, 20);
		}
		break;

	case CONTENTS_SLUDGE:
		if (!IronFeet &&
			Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
		{
			LastSectorDamageTime = Level.XLevel.Time;
			EntityEx(MO).Damage(none, none, 4);
		}
		break;

	case CONTENTS_HAZARD:
		if (!IronFeet)
		{
			HazardTime += 2.0 * deltaTime;
		}
		break;
	}
}

//==========================================================================
//
//  SetPlayerRunState
//
//==========================================================================

final void SetPlayerRunState()
{
	if (MO.State == EntityEx(MO).IdleState)
	{
		MO.SetState(EntityEx(MO).SeeState);
	}
}

//***************************************************************************
//
//  WEAPON UTILITES
//
//***************************************************************************

//==========================================================================
//
//	SetWeapon
//
//==========================================================================

final void SetWeapon(Weapon NewWeapon)
{
	ReadyWeapon = NewWeapon;
	PendingWeapon = none;
	PSpriteSY = ReadyWeapon.PSpriteSY;
	MO.ModelVersion = ReadyWeapon.PlayerModelVersion;
}

//===========================================================================
//
//  BringUpWeapon
//
//  Starts bringing the pending weapon up from the bottom of the screen.
//
//===========================================================================

final void BringUpWeapon()
{
	if (ReadyWeapon.UpSound)
	{
		MO.PlaySound(ReadyWeapon.UpSound, CHAN_WEAPON);
	}

	PendingWeapon = none;
	ViewStates[ps_weapon].SY = bInstantWeaponSwitch ? Weapon::WEAPONTOP :
		Weapon::WEAPONBOTTOM;
	SetViewState(ps_weapon, ReadyWeapon.GetUpState());
	MO.ModelVersion = ReadyWeapon.PlayerModelVersion;
}

//===========================================================================
//
//  DropWeapon
//
//  Player died, so put the weapon away.
//
//===========================================================================

final void DropWeapon()
{
	if (ReadyWeapon)
	{
		SetViewState(ps_weapon, ReadyWeapon.GetDownState());
	}
}

//===========================================================================
//
//  SetupPsprites
//
//  Called at start of level for each player.
//
//===========================================================================

final void SetupPsprites()
{
	int i;

	// remove all psprites
	for (i = 0; i < NUMPSPRITES; i++)
	{
		SetViewState(i, none);
	}

	// spawn the gun
	BringUpWeapon();
}

//==========================================================================
//
//  MovePsprites
//
//  Called every tic by player thinking routine.
//
//==========================================================================

void MovePsprites(float deltaTime)
{
	AdvanceViewStates(deltaTime);
	ViewStates[ps_flash].SX = ViewStates[ps_weapon].SX;
	ViewStates[ps_flash].SY = ViewStates[ps_weapon].SY;
}

//===========================================================================
//
//  FireWeapon
//
//===========================================================================

void FireWeapon()
{
	if (!ReadyWeapon.CheckAmmo(Weapon::FIRE_Primary, true))
	{
		return;
	}

	MO.SetState(EntityEx(MO).MissileState);
	SetViewState(ps_weapon, ReadyWeapon.GetAttackState(Refire));
	ReadyWeapon.FireMode = Weapon::FIRE_Primary;
	if (!ReadyWeapon.bNoAlert)
	{
		LineSpecialLevelInfo(Level).NoiseAlert(EntityEx(MO), EntityEx(MO));
	}
}

//===========================================================================
//
//  AltFireWeapon
//
//===========================================================================

void AltFireWeapon()
{
	if (!ReadyWeapon.CheckAmmo(Weapon::FIRE_Secondary, true))
	{
		return;
	}

	MO.SetState(EntityEx(MO).MissileState);
	SetViewState(ps_weapon, ReadyWeapon.GetAltAttackState(Refire));
	ReadyWeapon.FireMode = Weapon::FIRE_Secondary;
	if (!ReadyWeapon.bNoAlert)
	{
		LineSpecialLevelInfo(Level).NoiseAlert(EntityEx(MO), EntityEx(MO));
	}
}

//==========================================================================
//
//  ChangeWeapon
//
//  The actual changing of the weapon is done when the weapon psprite can
// do it (read: not in the middle of an attack).
//
//==========================================================================

final void ChangeWeapon(int newweapon)
{
	if (MorphTime)
	{
		return;
	}
	Weapon NewWpn = GetSlotChangeWeapon(newweapon);
	if (NewWpn && NewWpn != ReadyWeapon && (!NewWpn.bGivenAsMorphWeapon &&
		!ReadyWeapon.bGivenAsMorphWeapon))
	{
		PendingWeapon = NewWpn;
	}
	else
	{
		return;
	}
}

//==========================================================================
//
//  PrevWeapon
//
//==========================================================================

final void PrevWeapon()
{
	if (MorphTime)
	{
		return;
	}
	Weapon Wpn = GetPrevWeapon(PendingWeapon ? PendingWeapon : ReadyWeapon);
	if (Wpn && Wpn != ReadyWeapon)
	{
		PendingWeapon = Wpn;
	}
}

//==========================================================================
//
//  NextWeapon
//
//==========================================================================

final void NextWeapon()
{
	if (MorphTime)
	{
		return;
	}
	Weapon Wpn = GetNextWeapon(PendingWeapon ? PendingWeapon : ReadyWeapon);
	if (Wpn && Wpn != ReadyWeapon)
	{
		PendingWeapon = Wpn;
	}
}

//==========================================================================
//
//	BestWeapon
//
//	Returns best weapon to use
//
//==========================================================================

final Weapon BestWeapon(optional class<Ammo> AmmoType)
{
	bool Powered = !!EntityEx(MO).FindInventory(PowerWeaponLevel2);
	Weapon Best = none;
	Inventory Item;
	for (Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory)
	{
		//	Must be a weapon
		Weapon Wpn = Weapon(Item);
		if (!Wpn)
		{
			continue;
		}
		//	Check if best one is better that this one.
		if (Best && Wpn.SelectionOrder > Best.SelectionOrder)
		{
			continue;
		}
		//	Possibly limit to specific ammo type.
		if (AmmoType && Wpn.AmmoType1 != AmmoType)
		{
			continue;
		}
		//	Check if it's for the current tome of power state.
		if (Powered && Wpn.SisterWeapon && Wpn.SisterWeapon.bPoweredUp)
		{
			continue;
		}
		if (!Powered && Wpn.bPoweredUp)
		{
			continue;
		}
		//	Make sure it has enough ammo.
		if (!Wpn.CheckAmmo(Weapon::FIRE_Either, false))
		{
			continue;
		}
		//	Good one.
		Best = Wpn;
	}
	return Best;
}

//==========================================================================
//
//	ChoosePowered
//
//==========================================================================

final Weapon ChoosePowered(Weapon Wpn)
{
	bool Powered = !!EntityEx(MO).FindInventory(PowerWeaponLevel2);
	if (Powered && Wpn.SisterWeapon && Wpn.SisterWeapon.bPoweredUp)
	{
		return Wpn.SisterWeapon;
	}
	return Wpn;
}

//==========================================================================
//
//	GetSlotChangeWeapon
//
//==========================================================================

final Weapon GetSlotChangeWeapon(int Slot)
{
	int			i;
	int			j;
	LineSpecialGameInfo GI = LineSpecialGameInfo(Level.Game);

	if (ReadyWeapon)
	{
		for (i = 0; i < LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT; i++)
		{
			if (GI.WeaponSlots[Slot].Weapons[i] == ReadyWeapon.Class ||
				(ReadyWeapon.bPoweredUp && ReadyWeapon.SisterWeapon &&
				GI.WeaponSlots[Slot].Weapons[i] == ReadyWeapon.SisterWeapon.Class))
			{
				for (j = (i + LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT - 1) %
					LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT; j != i;
					j = (j + LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT - 1) %
					LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT)
				{
					Weapon Wpn = Weapon(EntityEx(MO).FindInventory(
						GI.WeaponSlots[Slot].Weapons[j]));
					if (Wpn && Wpn.CheckAmmo(Weapon::FIRE_Either, false))
					{
						return ChoosePowered(Wpn);
					}
				}
			}
		}
	}

	for (i = LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT - 1; i >= 0; i--)
	{
		Weapon Wpn = Weapon(EntityEx(MO).FindInventory(
			GI.WeaponSlots[Slot].Weapons[i]));
		if (Wpn && Wpn.CheckAmmo(Weapon::FIRE_Either, false))
		{
			return ChoosePowered(Wpn);
		}
	}

	return ReadyWeapon;
}

//==========================================================================
//
//	GetPrevWeapon
//
//==========================================================================

final Weapon GetPrevWeapon(Weapon Current)
{
	LineSpecialGameInfo GI = LineSpecialGameInfo(Level.Game);
	int			Slot;
	int			Index;
	int			Start;
	int			i;

	if (GI.FindWeaponSlot(class<Weapon>(Current.Class), Slot, Index, Current.Position))
	{
		Start = Slot * LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT + Index;
	}
	else
	{
		Start = 0;
	}

	for (i = LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT *
		LineSpecialGameInfo::NUM_WEAPON_SLOTS - 1; i >= 0; i--)
	{
		Slot = ((Start + i) / LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT) %
			LineSpecialGameInfo::NUM_WEAPON_SLOTS;
		Index = (Start + i) % LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT;
		Weapon Wpn = Weapon(EntityEx(MO).FindInventory(
			GI.WeaponSlots[Slot].Weapons[Index]));
		if (Wpn && Wpn.CheckAmmo(Weapon::FIRE_Either, false))
		{
			return ChoosePowered(Wpn);
		}
	}
	return Current;
}

//==========================================================================
//
//	GetNextWeapon
//
//==========================================================================

final Weapon GetNextWeapon(Weapon Current)
{
	LineSpecialGameInfo GI = LineSpecialGameInfo(Level.Game);
	int			Slot;
	int			Index;
	int			Start;
	int			i;

	if (GI.FindWeaponSlot(class<Weapon>(Current.Class), Slot, Index, Current.Position))
	{
		Start = Slot * LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT + Index;
	}
	else
	{
		Start = -1;
	}

	for (i = 1; i <= LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT *
		LineSpecialGameInfo::NUM_WEAPON_SLOTS; i++)
	{
		Slot = ((Start + i) / LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT) %
			LineSpecialGameInfo::NUM_WEAPON_SLOTS;
		Index = (Start + i) % LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT;
		Weapon Wpn = Weapon(EntityEx(MO).FindInventory(
			GI.WeaponSlots[Slot].Weapons[Index]));
		if (Wpn && Wpn.CheckAmmo(Weapon::FIRE_Either, false))
		{
			return ChoosePowered(Wpn);
		}
	}
	return Current;
}

//==========================================================================
//
//  UsePuzzleItem
//
//  USING A PUZZLE ITEM
//
//  Returns true if the puzzle item was used on a line or a thing.
//
//==========================================================================

final bool UsePuzzleItem(int PuzzleItemType)
{
	float x1, y1, x2, y2;
	TVec PuzzleUseDir;
	intercept_t * in;

	AngleVector(&MO.Angles, &PuzzleUseDir);
	x1 = MO.Origin.x;
	y1 = MO.Origin.y;
	x2 = x1 + USERANGE * PuzzleUseDir.x;
	y2 = y1 + USERANGE * PuzzleUseDir.y;
	foreach MO.PathTraverse(in, x1, y1, x2, y2, PT_ADDLINES | PT_ADDTHINGS)
	{
		EntityEx mobj;
		TVec hit_point;
		opening_t *open;

		if (in->bIsALine)
		{
			// Check line
			hit_point = MO.Origin + (USERANGE * in->frac) * PuzzleUseDir;
			if (in->line->special != LNSPEC_UsePuzzleItem)
			{
				open = LineOpenings(in->line, hit_point);
				if (!open || open->range <= 0.0)
				{
					if (MO.bIsPlayer)
					{
						MO.PlaySound('*puzzfail', CHAN_VOICE);
					}
					break;	// can't use through a wall
				}
				continue;	// Continue searching
			}
			if (PointOnPlaneSide(MO.Origin, in->line) == 1)
			{
				// Don't use back sides
				break;
			}
			if (PuzzleItemType != in->line->arg1)
			{
				// Item type doesn't match
				break;
			}
			MO.XLevel.StartACS(in->line->arg2, 0, in->line->arg3,
				in->line->arg4, in->line->arg5, MO, in->line, 0, false,
				false);
			in->line->special = 0;
			return true;	// Stop searching
		}
		// Check thing
		mobj = EntityEx(in->Thing);
		if (mobj.Special != LNSPEC_UsePuzzleItem)
		{
			// Wrong special
			continue;
		}
		if (PuzzleItemType != mobj.Args[0])
		{
			// Item type doesn't match
			continue;
		}
		MO.XLevel.StartACS(mobj.Args[1], 0, mobj.Args[2], mobj.Args[3],
			mobj.Args[4], MO, NULL, 0, false, false);
		mobj.Special = 0;
		return true;	// Stop searching
	}
	return false;
}

//==========================================================================
//
//  AddRevealedMap
//
//==========================================================================

final bool AddRevealedMap()
{
	int			i;

	bAutomapRevealed = true;
	for (i = 0; i < RevealedMaps.Num; i++)
	{
		if (RevealedMaps[i] == Level.XLevel.MapName)
		{
			//	Already revealed.
			return false;
		}
	}
	RevealedMaps.Num = RevealedMaps.Num + 1;
	RevealedMaps[RevealedMaps.Num - 1] = Level.XLevel.MapName;
	return true;
}

//==========================================================================
//
//  RemoveRevealedMap
//
//==========================================================================

final void RemoveRevealedMap()
{
	int			i;

	bAutomapRevealed = false;
	for (i = 0; i < RevealedMaps.Num; i++)
	{
		if (RevealedMaps[i] == Level.XLevel.MapName)
		{
			RevealedMaps.Remove(i);
			return;
		}
	}
}

//==========================================================================
//
//  UpdateRevealedMap
//
//==========================================================================

final void UpdateRevealedMap()
{
	int			i;

	bAutomapRevealed = false;
	for (i = 0; i < RevealedMaps.Num; i++)
	{
		if (RevealedMaps[i] == Level.XLevel.MapName)
		{
			bAutomapRevealed = true;
			return;
		}
	}
}

//==========================================================================
//
//  ParticleEffect
//
//==========================================================================

void ParticleEffect(int count, int type1, int type2, TVec origin, float ornd,
	TVec velocity, float vrnd, float acceleration, float grav, int colour, float duration, float ramp)
{
	Level.ParticleEffect(count, type1, type2, origin, ornd, velocity, vrnd, acceleration,
				grav, colour, duration, ramp);
}

//==========================================================================
//
//  ClientExplosion
//
//==========================================================================

void ClientExplosion(int colour, float rad, TVec org)
{
	dlight_t*	dl;

	dl = Level.AllocDlight(none);
	dl->origin = org;
	dl->radius = rad + 150.0;
	dl->colour = colour;
	dl->die = Level.XLevel.Time + 0.5;
	dl->decay = 300.0;
}

//==========================================================================
//
//  ClientParticleExplosion
//
//==========================================================================

void ClientParticleExplosion(int colour, float rad, TVec org)
{
	int i;
	particle_t *p;
	dlight_t *dl;

	for (i = 0; i < 1024; i++)
	{
		p = Level.NewParticle();
		if (!p)
			return;
		p->die = Level.XLevel.Time + 5.0;
		p->colour = LineSpecialGameInfo.default.ramp1[0];
		p->Size = 1.0;
		p->ramp = Random() * 4.0;
		if (i & 1)
		{
			p->type = LineSpecialLevelInfo::pt_explode;
		}
		else
		{
			p->type = LineSpecialLevelInfo::pt_explode2;
		}
		p->org.x = org.x + ((Random() * 32.0) - 16.0);
		p->org.y = org.y + ((Random() * 32.0) - 16.0);
		p->org.z = org.z + ((Random() * 32.0) - 16.0);
		p->vel.x = (Random() * 512.0) - 256.0;
		p->vel.y = (Random() * 512.0) - 256.0;
		p->vel.z = (Random() * 512.0) - 256.0;
//		p->accel = (Random() * 512.0) - 256.0;
		p->gravity = 40.0 + (Random() * 512.0) - 256.0;
	}

	dl = Level.AllocDlight(none);
	dl->origin = org;
	dl->radius = rad + 150.0;
	dl->colour = colour;
	dl->die = Level.XLevel.Time + 0.5;
	dl->decay = 300.0;
}

//==========================================================================
//
//	ClientSparkParticles
//
//==========================================================================

void ClientSparkParticles(int Count, TVec Org, float Angle)
{
	int			i;

	for (i = 0; i < Count; i++)
	{
		particle_t *p = Level.NewParticle();
		if (!p)
		{
			break;
		}

		p->type = LineSpecialLevelInfo::pt_spark;
		p->Size = 0.5;
		p->colour = Random() < 0.5 ? RGBA(255, 120, 0, 255) :
			RGBA(255, 170, 0, 255);
		p->die = Level.XLevel.Time + 10.0 / 35.0;

		float an = Angle + Random() * 45.0;
		p->org.x = Org.x + (Random () * 15.0) * cos(an);
		p->org.y = Org.y + (Random () * 15.0) * sin(an);
		p->org.z = Org.z - Random () * 4.0;

		p->vel.x = (Random() - 0.5) * 2.0;
		p->vel.y = (Random() - 0.5) * 2.0;
		p->vel.z = (Random() - 0.5) * 2.0 - Random () * 70.0;

		p->accel.x = (Random() - 0.5) * 16.0 + (Random () - 0.5) * 35.0;
		p->accel.y = (Random() - 0.5) * 16.0 + (Random () - 0.5) * 35.0;
		p->accel.z = (Random() - 0.5) * 16.0 - 140.0;
	}
}

//==========================================================================
//
//	AddBlend
//
//==========================================================================

final void AddBlend(out float r, out float g, out float b, out float a,
	int Col)
{
	if (!(Col & 0xff000000))
	{
		//	No alpha
		return;
	}
	float r1 = itof((Col >> 16) & 0xff) / 255.0;
	float g1 = itof((Col >> 8) & 0xff) / 255.0;
	float b1 = itof(Col & 0xff) / 255.0;
	float a1 = itof((Col >> 24) & 0xff) / 255.0;
	float TmpA = 1.0 - (1.0 - a) * (1.0 - a1);
	if (!TmpA)
	{
		return;
	}
	r = (r * a * (1.0 - a1) + r1 * a1) / TmpA;
	g = (g * a * (1.0 - a1) + g1 * a1) / TmpA;
	b = (b * a * (1.0 - a1) + b1 * a1) / TmpA;
	a = TmpA;
}

//==========================================================================
//
//  PaletteFlash
//
//  Sets the new palette colour shift based upon the current values of
// Player.DamageFlash and Player.BonusFlash, contents and other inventory
// items.
//
//==========================================================================

void PaletteFlash()
{
	float r = 0.0;
	float g = 0.0;
	float b = 0.0;
	float a = 0.0;

	if (MO.WaterLevel == 3)
	{
		switch (MO.WaterType)
		{
		case CONTENTS_WATER:
			AddBlend(r, g, b, a, RGBA(130, 80, 50, 128));
			break;

		case CONTENTS_LAVA:
			AddBlend(r, g, b, a, RGBA(255, 80, 0, 150));
			break;

		case CONTENTS_NUKAGE:
			AddBlend(r, g, b, a, RGBA(50, 255, 50, 150));
			break;

		case CONTENTS_SLIME:
			AddBlend(r, g, b, a, RGBA(0, 25, 5, 150));
			break;

		case CONTENTS_HELLSLIME:
			AddBlend(r, g, b, a, RGBA(255, 80, 0, 150));
			break;

		case CONTENTS_BLOOD:
			AddBlend(r, g, b, a, RGBA(160, 16, 16, 150));
			break;

		case CONTENTS_SLUDGE:
			AddBlend(r, g, b, a, RGBA(128, 160, 128, 150));
			break;

		case CONTENTS_HAZARD:
			AddBlend(r, g, b, a, RGBA(128, 160, 128, 128));
			break;
		}
	}

	if (EntityEx(MO).DamageType == 'Ice')
	{
		// Frozen player
		AddBlend(r, g, b, a, RGBA(2, 2, 255, 113));
	}
	else
	{
		if (DamageFlash)
		{
			int Amount = ftoi(114.0 * DamageFlash);
			if (Amount >= 228)
			{
				Amount = 228;
			}
			AddBlend(r, g, b, a, (Amount << 24) |
				(PlayerPawn(MO).DamageScreenColour & 0x00ffffff));
		}

		if (BonusFlash)
		{
			int Amount = ftoi(256.0 * BonusFlash);
			if (Amount >= 128)
			{
				Amount = 128;
			}
			AddBlend(r, g, b, a, RGBA(215, 186, 68, Amount));
		}

		if (PoisonCount)
		{
			int Amount = PoisonCount * 160 / 32;
			if (Amount >= 160)
			{
				Amount = 160;
			}
			AddBlend(r, g, b, a, RGBA(56, 118, 46, Amount));
		}

		//FIXME add hazard flash.
		if (HazardTime > 16.0 || ftoi(4.0 * HazardTime) & 1)
		{
			AddBlend(r, g, b, a, RGBA(0, 255, 0, 32));
		}
	}

	Inventory Item;
	for (Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory)
	{
		int Blend = Item.GetBlend();
		if (Blend)
		{
			AddBlend(r, g, b, a, Blend);
		}
	}

	if (BlendA)
	{
		AddBlend(r, g, b, a, RGBA(ftoi(BlendR * 255.0), ftoi(BlendG * 255.0),
			ftoi(BlendB * 255.0), ftoi(BlendA * 255.0)));
	}

	if (r > 1.0)
	{
		r = 1.0;
	}
	if (g > 1.0)
	{
		g = 1.0;
	}
	if (b > 1.0)
	{
		b = 1.0;
	}
	CShift = RGBA(ftoi(r * 255.0), ftoi(g * 255.0), ftoi(b * 255.0),
		ftoi(a * 255.0));
}

//==========================================================================
//
//  PreTravel
//
//==========================================================================

void PreTravel()
{
	SavedInventory = EntityEx(MO).Inventory;
	EntityEx(MO).Inventory = none;
}

//==========================================================================
//
//  ClientSpeech
//
//==========================================================================

void ClientSpeech(EntityEx Speaker, int SpeechNum)
{
	LineSpecialClientGame(ClGame).StartSpeech(Speaker, SpeechNum);
}

//==========================================================================
//
//  ClientSlideshow1
//
//==========================================================================

void ClientSlideshow1()
{
	LineSpecialClientGame(ClGame).StartConSlideshow1();
}

//==========================================================================
//
//  ClientSlideshow2
//
//==========================================================================

void ClientSlideshow2()
{
	LineSpecialClientGame(ClGame).StartConSlideshow2();
}

//==========================================================================
//
//  ClientFinaleType
//
//==========================================================================

void ClientFinaleType(int Type)
{
	LineSpecialClientGame(ClGame).SetFinaleType(Type);
}

//==========================================================================
//
//	SetObjectives
//
//==========================================================================

final void SetObjectives(int NewObjectives)
{
	if (!NewObjectives)
	{
		return;
	}
	//	Check if log text lump exists in wad file.
	if (!WadLumpPresent(StrToName(va("log%d", NewObjectives))))
	{
		return;
	}
	Objectives = NewObjectives;
}

//==========================================================================
//
//	DisplayObituary
//
//==========================================================================

void DisplayObituary(EntityEx inflictor, EntityEx source, name DmgType)
{
	string		Msg;

	if (DmgType == 'Suicide')
	{
		//	Commited a suicide
		Msg = "$ob_suicide";
	}
	else if (DmgType == 'Falling')
	{
		//	Fell down
		Msg = "$ob_falling";
	}
	else if (DmgType == 'Crush')
	{
		//	Crushed by the environment
		Msg = "$ob_crush";
	}
	else if (DmgType == 'Exit')
	{
		//	Tried to exit when it's not allowed
		Msg = "$ob_exit";
	}
	else if (DmgType == 'Drowning')
	{
		//	Drowned int the water
		Msg = "$ob_water";
	}
	else if (DmgType == 'Slime')
	{
		//	Was standing in the slime
		Msg = "$ob_slime";
	}
	else if (DmgType == 'Fire' && !source)
	{
		//	Was standing in the lava
		Msg = "$ob_lava";
	}
	else if (source)
	{
		if (source.Player == self)
		{
			//	Killed self
			Msg = "$ob_killedself";
		}
		else if (!source.bIsPlayer)
		{
			//	Killed by monster
			if (DmgType == 'Telefrag')
			{
				//	Monster telefrag
				Msg = "$ob_montelefrag";
			}
			else if (DmgType == 'Melee' && source.HitObituary)
			{
				Msg = source.HitObituary;
			}
			else
			{
				Msg = source.Obituary;
			}
		}
	}

	if (!Msg && source && source.bIsPlayer)
	{
		if (Level.Game.netgame && !Level.Game.deathmatch)
		{
			//	Killed another player in cooperative net game
			Msg = va("$ob_friendly%d", P_Random() & 3);
		}
		else if (DmgType == 'Telefrag')
		{
			//	Telefrag
			Msg = "$ob_mptelefrag";
		}
		else if (inflictor && inflictor.Obituary)
		{
			//	Missile with it's own obituary.
			Msg = inflictor.Obituary;
		}
		else
		{
			Weapon Wpn = PlayerEx(inflictor.Player).ReadyWeapon;
			if (Wpn && Wpn.Obituary)
			{
				//	Weapon obituary message.
				Msg = Wpn.Obituary;
			}
			else if (DmgType == 'BFGSplash')
			{
				//	BFG splash damage
				Msg = "$ob_mpbfg_splash";
			}
			else if (DmgType == 'Railgun')
			{
				//	Railgun
				Msg = "$ob_railgun";
			}
			else
			{
				//	Default multiplayer kill message.
				Msg = "$ob_mpdefault";
			}
		}
	}
	else
	{
		source = EntityEx(MO);
	}

	if (!Msg)
	{
		//	Generic death
		Msg = "$ob_default";
	}

	//	Look up string in language lump is necesary.
	if (StrStartsWith(Msg, "$"))
	{
		Msg = GetLangString(StrToName(substr(Msg, 1, strlen(Msg) - 1)));
	}

	//	Do replacements.
	Msg = StrReplace(Msg, "%g", "he");
	Msg = StrReplace(Msg, "%h", "him");
	Msg = StrReplace(Msg, "%p", "his");
	Msg = StrReplace(Msg, "%o", PlayerName);
	Msg = StrReplace(Msg, "%k", source.Player.PlayerName);

	Level.bprint("%s", Msg);
}

//==========================================================================
//
//	ClientRailTrail
//
//==========================================================================

void ClientRailTrail(TVec From, TVec To, int Col1, int Col2, float MaxDiff)
{
	float Len = Length(To - From);
	TVec Dir = Normalise(To - From);
	TAVec Ang;
	VectorAngles(&Dir, &Ang);
	Ang.roll = 270.0;

	if (!Col1)
	{
		Col1 = RGBA(255, 255, 255, 255);
	}
	if (!Col2)
	{
		Col2 = RGBA(0, 0, 255, 255);
	}

	TVec Diff;
	float Offs;
	for (Offs = 0.0; Offs < Len; Offs += 3.0)
	{
		if (MaxDiff > 0.0)
		{
			int Rnd = P_Random();
			if (Rnd & 1)
			{
				Diff.x += Rnd & 8 ? 1.0 : -1.0;
				if (Diff.x > MaxDiff)
				{
					Diff.x = MaxDiff;
				}
				else if (Diff.x < -MaxDiff)
				{
					Diff.x = -MaxDiff;
				}
			}
			if (Rnd & 2)
			{
				Diff.y += Rnd & 16 ? 1.0 : -1.0;
				if (Diff.y > MaxDiff)
				{
					Diff.y = MaxDiff;
				}
				else if (Diff.y < -MaxDiff)
				{
					Diff.y = -MaxDiff;
				}
			}
			if (Rnd & 4)
			{
				Diff.z += Rnd & 32 ? 1.0 : -1.0;
				if (Diff.z > MaxDiff)
				{
					Diff.z = MaxDiff;
				}
				else if (Diff.z < -MaxDiff)
				{
					Diff.z = -MaxDiff;
				}
			}
		}

		particle_t *p = Level.NewParticle();
		if (!p)
		{
			break;
		}
		p->type = LineSpecialLevelInfo::pt_rail;
		p->Size = 0.5;
		p->colour = Col1;
		p->die = Level.XLevel.Time + 1.0;
		p->org = From + Dir * Offs + Diff;
		p->vel.x = (Random() - 0.5) * 2.0;
		p->vel.y = (Random() - 0.5) * 2.0;
		p->vel.z = (Random() - 0.5) * 2.0;
		p->accel = vector(0.0, 0.0, 0.0);

		Ang.roll += 14.0;
		TVec Forward;
		TVec Right;
		TVec Up;
		AngleVectors(&Ang, &Forward, &Right, &Up);

		p = Level.NewParticle();
		if (!p)
		{
			break;
		}
		p->type = LineSpecialLevelInfo::pt_rail;
		p->Size = 0.5;
		p->colour = Col2;
		p->die = Level.XLevel.Time + 1.0;
		p->org = From + Dir * Offs + Up * 3.0;
		p->vel = Up;
		p->accel = vector(0.0, 0.0, 0.0);
	}
}

//==========================================================================
//
//  ClientVoice
//
//==========================================================================

void ClientVoice(int VoiceNum)
{
	LocalSound(StrToName(va("svox/voc%d", VoiceNum)));
}

//==========================================================================
//
//	GiveAmmo
//
//	Returns false if the ammo can't be picked up at all
//
//==========================================================================

final bool GiveAmmo(class<Ammo> ammo, int count)
{
	int oldammo;

	if (!ammo)
	{
		return false;
	}

	Ammo AmmoItem = Ammo(EntityEx(MO).FindInventory(ammo));
	if (!AmmoItem)
	{
		AmmoItem = Level.Spawn(ammo,,,, false);
		AmmoItem.AttachToOwner(EntityEx(MO));
		AmmoItem.Amount = 0;
	}
	if (!count)
	{
		return false;
	}
	if (AmmoItem.Amount == AmmoItem.MaxAmount)
	{
		return false;
	}

	//	Extra ammo in baby mode and nightmare mode
	count = ftoi(itof(count) * Level.World.SkillAmmoFactor);

	oldammo = AmmoItem.Amount;
	AmmoItem.Amount += count;
	if (AmmoItem.Amount > AmmoItem.MaxAmount)
	{
		AmmoItem.Amount = AmmoItem.MaxAmount;
	}

	if (oldammo <= 0)
	{
		GotAmmo(AmmoItem);
	}
	return true;
}

//==========================================================================
//
//  PutClientIntoServer
//
//==========================================================================

void PutClientIntoServer()
{
	if (bIsBot)
	{
		CreateBot();
	}
}

//==========================================================================
//
//  SpawnClient
//
//==========================================================================

void SpawnClient()
{
	bool playerWasReborn;
	EntityEx OldMO = EntityEx(MO);

	Attacker = none;
	Poisoner = none;

	AddVisitedMap(Level.XLevel.MapName);

	if (Level.Game.netgame && !Level.Game.deathmatch)
	{
		// Cooperative net-play, retain keys and weapons
		playerWasReborn = (PlayerState == PST_REBORN);
	}

	//  Spawn player
	if (Level.Game.deathmatch)
	{
		DeathMatchSpawnPlayer();
	}
	else if (Level.Game.netgame || Level.bClusterHub)
	{
		SpawnPlayer(Level.GetPlayerStart(GetPlayerNum(),
			Level.Game.RebornPosition), false);
	}
	else
	{
		mthing_t* Best = NULL;
		bool Spawned = false;
		int i;
		for (i = 0; i < Level.PlayerStarts.Num; i++)
		{
			if (Level.PlayerStarts[i].type != GetPlayerNum() + 1)
			{
				continue;
			}
			if (Level.PlayerStarts[i].arg1 == Level.Game.RebornPosition)
			{
				SpawnPlayer(&Level.PlayerStarts[i], Spawned);
				Spawned = true;
				continue;
			}
			if (!Best)
			{
				Best = &Level.PlayerStarts[i];
			}
		}
		if (!Spawned)
		{
			if (!Best)
			{
				Error("Player %d has no start spots", GetPlayerNum() + 1);
			}
			print("Player %d has no start spot for position %d",
				GetPlayerNum() + 1, Level.Game.RebornPosition);
			SpawnPlayer(Best, false);
		}
	}

	if (Level.Game.netgame && !Level.Game.deathmatch && playerWasReborn)
	{
		OnNetReborn(OldMO);
	}

	// Destroy all things touching players
	Actor(MO).TeleportMove(MO.Origin);
}

//==========================================================================
//
//  NetGameReborn
//
//	Respawn at the start
//
//==========================================================================

void NetGameReborn()
{
	int i;
	bool foundSpot;
	EntityEx OldMO = EntityEx(MO);

	// remove pitch and roll angles from corpse
	MO.Angles.pitch = 0.0;
	MO.Angles.roll = 0.0;

	// first dissasociate the corpse
	MO.Player = none;
	MO.bIsPlayer = false;

	// spawn at random spot if in death match
	if (Level.Game.deathmatch)
	{
		OldMO.DestroyAllInventory();
		DeathMatchSpawnPlayer();
		return;
	}

	foundSpot = false;
	if (CheckSpot(Level.GetPlayerStart(GetPlayerNum(),
		Level.Game.RebornPosition)))
	{
		// Appropriate player start spot is open
		SpawnPlayer(Level.GetPlayerStart(GetPlayerNum(),
			Level.Game.RebornPosition), false);
		foundSpot = true;
	}
	else
	{
		// Try to spawn at one of the other player start spots
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (CheckSpot(Level.GetPlayerStart(i, Level.Game.RebornPosition)))
			{
				// Found an open start spot
				SpawnPlayer(Level.GetPlayerStart(i, Level.Game.RebornPosition),
					false);
				foundSpot = true;
				break;
			}
		}
	}

	if (!foundSpot)
	{
		// Player's going to be inside something. Too bad.
		SpawnPlayer(Level.GetPlayerStart(GetPlayerNum(),
			Level.Game.RebornPosition), false);
	}

	OnNetReborn(OldMO);
}

//==========================================================================
//
//  DisconnectClient
//
//==========================================================================

void DisconnectClient()
{
	DestroyBot();
	if (MO)
	{
		MO.Player = none;
		MO.bIsPlayer = false;
		Actor(MO).Damage(none, none, 10000);
	}
	Level.bprint("%s left the game\n", PlayerName);
	MO.PlaySound('misc/chat', CHAN_AUTO, 1.0, ATTN_NONE);
}

//==========================================================================
//
//  DeathMatchSpawnPlayer
//
//  Spawns a player at one of the random death match spots called at level
// load and each death
//
//==========================================================================

void DeathMatchSpawnPlayer()
{
	int i;
	int j;

	for (j = 0; j < 20; j++)
	{
		i = P_Random() % Level.DeathmatchStarts.Num;
		if (CheckSpot(&Level.DeathmatchStarts[i]))
		{
			SpawnPlayer(&Level.DeathmatchStarts[i], false);
			return;
		}
	}

	// no good spot, so the player will probably get stuck 
	SpawnPlayer(Level.GetPlayerStart(GetPlayerNum(), 0), false);
}

//==========================================================================
//
//  CheckSpot
//
//  Returns false if the player cannot be respawned at the given mthing_t
// spot because something is occupying it
//
//==========================================================================

bool CheckSpot(mthing_t * mthing)
{
	float x;
	float y;
	sector_t *sec;
	float an;
	int i;

	if (!MO)
	{
		// first spawn of level, before corpses
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (Level.Game.Players[i] && Level.Game.Players[i].MO &&
				Level.Game.Players[i].MO.Origin.x == mthing->x &&
				Level.Game.Players[i].MO.Origin.y == mthing->y)
			{
				return false;
			}
		}
		return true;
	}

	x = mthing->x;
	y = mthing->y;

	MO.bPassMobj = false;
	if (!MO.CheckPosition(vector(x, y, Actor::ONFLOORZ)))
	{
		MO.bPassMobj = true;
		return false;
	}
	MO.bPassMobj = true;

	if (!PlayerChunk(MO))
	{
		LineSpecialLevelInfo(Level).AddPlayerCorpse(EntityEx(MO));
	}

	// spawn a teleport fog 
	sec = Level.XLevel.PointInSector(vector(x, y, 0.0));
	an = itof(45 * (mthing->angle / 45));

	Level.Spawn(TeleportFog, vector(x + 20.0 * cos(an), y + 20.0 * sin(an),
		sec->floor.TexZ + LineSpecialGameInfo(Level.Game).TeleFogHeight));

	return true;
}

//==========================================================================
//
//  SetUpPlayerClass
//
//==========================================================================

void SetUpPlayerClass()
{
	if (LineSpecialGameInfo(Level.Game).bRandomClass &&
		Level.Game.deathmatch && Level.Game.PlayerClasses.Num > 1)
	{
		PClass = P_Random() % Level.Game.PlayerClasses.Num;
		if (PClass == BaseClass)
		{
			PClass = (PClass + 1) % Level.Game.PlayerClasses.Num;
		}
		BaseClass = PClass;
		SB_Start();
	}
	else
	{
		PClass = BaseClass;
	}
}

//==========================================================================
//
//  ResetPlayerOnSpawn
//
//==========================================================================

void ResetPlayerOnSpawn()
{
	PlayerState = PST_LIVE;
	Refire = 0;
	DamageFlash = 0.0;
	BonusFlash = 0.0;
	PoisonCount = 0;
	MorphTime = 0.0;
	ExtraLight = 0;
	FixedColourmap = 0;
	LastSectorDamageTime = 0.0;
	LastHazardTime = 0.0;
	Rain1 = none;
	Rain2 = none;
}

//==========================================================================
//
//  GiveDefaultDeathMatchInventory
//
//==========================================================================

void GiveDefaultDeathMatchInventory()
{
	class<Inventory>	Cls;

	//	Give all keys in death match mode.
	foreach AllClasses(Key, Cls)
	{
		if (!FindClassState(Cls, 'Spawn'))
		{
			//	Abstract class
			continue;
		}
		if (!AreStateSpritesPresent(FindClassState(Cls, 'Spawn')))
		{
			//	From a different game
			continue;
		}
		EntityEx(MO).GiveInventoryType(Cls);
	}
}

//==========================================================================
//
//  SpawnPlayer
//
//  Called when a player is spawned on the level. Most of the player
// structure stays unchanged between levels.
//
//==========================================================================

void SpawnPlayer(mthing_t * mthing, bool Voodoo)
{
	float				x;
	float				y;
	float				z;
	PlayerPawn			PP;
	bool				ResetInventory = false;
	Inventory			Item;

	if (PlayerState == PST_REBORN)
	{
		PlayerReborn();
		ResetInventory = true;
	}

	SetUpPlayerClass();

	x = mthing->x;
	y = mthing->y;
	z = Actor::ONFLOORZ;
	if (PClass >= Level.Game.PlayerClasses.Num)
	{
		Error("Player::SpawnPlayer : Unknown class type");
	}
	PP = Level.Spawn(class<PlayerPawn>(Level.Game.PlayerClasses[PClass]),
		vector(x, y, z),,, false);
	PP.Origin.z += mthing->height;
	PP.LinkToWorld();
	PP.FriendPlayer = GetPlayerNum() + 1;	//	Players are their own friends.

	//	Set colour translations for player sprites.
	TranslStart = PP.TranslStart;
	TranslEnd = PP.TranslEnd;
	PP.Translation = (Entity::TRANSL_Player << Entity::TRANSL_TYPE_SHIFT) +
		GetPlayerNum();

	//	If a voodoo doll has been spawned, take it's inventory.
	if (Voodoo)
	{
		PP.ObtainInventory(EntityEx(MO));
	}

	DesiredFOV = 90.0; //itof(GetCvar('FOV'));
	FOV = DesiredFOV;
	PP.Angles.yaw = itof(45 * (mthing->angle / 45));
	PP.Player = self;
	PP.bIsPlayer = true;
	PP.Health = Health;
	MO = PP;
	Camera = PP;
	ViewHeight = PP.ViewHeight;
	ViewOrg = MO.Origin;
	ViewOrg.z += ViewHeight;
	ViewAngles = PP.Angles;
	bFixAngle = true;

	ResetPlayerOnSpawn();

	if (!Voodoo)
	{
		PP.Inventory = SavedInventory;
		for (Item = PP.Inventory; Item; Item = Item.Inventory)
		{
			Item.Owner = MO;
		}

		if (ResetInventory)
		{
			while (PP.Inventory)
			{
				PP.Inventory.Destroy();
			}
			AddDefaultInventory();
		}
	}

	//	Set up gun psprite.
	SetupPsprites();

	if (Level.Game.deathmatch)
	{
		GiveDefaultDeathMatchInventory();
	}

	// wake up the status bar
	SB_Start();

	if (bIsBot)
	{
		BotOnSpawn();
	}

	SetClientModel();

	UpdateRevealedMap();

	if (ResetInventory)
	{
		Level.XLevel.StartTypedACScripts(Level::SCRIPT_Respawn, 0, 0, 0, MO,
			true, false);
	}
}

//===========================================================================
//
//	AddDefaultInventory
//
//===========================================================================

void AddDefaultInventory()
{
	HexenArmor HArmor = Level.Spawn(HexenArmor,,,, false);
	HArmor.AttachToOwner(EntityEx(MO));
	HArmor.Slots[4] = PlayerPawn(MO).HexenArmor[0];
	HArmor.SlotsIncrement[0] = PlayerPawn(MO).HexenArmor[1];
	HArmor.SlotsIncrement[1] = PlayerPawn(MO).HexenArmor[2];
	HArmor.SlotsIncrement[2] = PlayerPawn(MO).HexenArmor[3];
	HArmor.SlotsIncrement[3] = PlayerPawn(MO).HexenArmor[4];

	BasicArmor BArmor = Level.Spawn(BasicArmor,,,, false);
	BArmor.Amount = 0;
	BArmor.AttachToOwner(EntityEx(MO));

	int i;
	for (i = 0; i < EntityEx(MO).DropItemList.Num; i++)
	{
		Inventory Item = Inventory(Level.Spawn(EntityEx(MO).DropItemList[i].Type,,,, false));
		Item.bIgnoreSkill = true;
		if (EntityEx(MO).DropItemList[i].Amount > 0)
		{
			Item.Amount = EntityEx(MO).DropItemList[i].Amount;
		}
		if (Weapon(Item))
		{
			//	For better control empty weapon's ammo.
			Weapon(Item).AmmoGive1 = 0;
			Weapon(Item).AmmoGive2 = 0;
		}
		if (!Item.TryPickup(EntityEx(MO)))
		{
			Item.Destroy();
		}
		else if (Weapon(Item) && Weapon(Item).CheckAmmo(Weapon::FIRE_Either, false))
		{
			SetWeapon(Weapon(Item));
		}
	}
}

//==========================================================================
//
//  PlayerReborn
//
//  Called after a player dies almost everything is cleared and initialised
//
//==========================================================================

void PlayerReborn()
{
	//  Clear player struct
	DoClearPlayer();

	PClass = BaseClass;

	//  Set initial data
	bUseDown = true;	// don't do anything immediately
	bAttackDown = true;
	PlayerState = PST_LIVE;
	Health = GetRebornHealth();
	LocalQuakeHappening = 0;
}

//==========================================================================
//
//  DoClearPlayer
//
//==========================================================================

void DoClearPlayer()
{
	ClearPlayer();
}

//==========================================================================
//
//  PlayerExitMap
//
//  Called when a player completes a level.
//
//==========================================================================

void PlayerExitMap(bool clusterChange)
{
	Inventory	Item;

	if (clusterChange && !Level.bClusterHub && !Level.bKeepFullInventory)
	{
		for (Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory)
		{
			if (Item.bInvBar && Item.Amount > Item.InterHubAmount)
			{
				Item.Amount = Item.InterHubAmount;
			}
		}
	}

	// Strip all current powers
	for (Item = EntityEx(MO).Inventory; Item;)
	{
		Inventory Next = Item.Inventory;
		if (Powerup(Item) && (Level.Game.deathmatch || clusterChange ||
			!Item.bHubPower) && Item.InterHubAmount < 1)
		{
			Item.Destroy();
		}
		Item = Next;
	}

	if (clusterChange)
	{
		// Entering new cluster
		// Some items are stripped.
		for (Item = EntityEx(MO).Inventory; Item;)
		{
			Inventory Next = Item.Inventory;
			if (Item.bInterHubStrip)
			{
				Item.Destroy();
			}
			Item = Next;
		}
	}

	if (MorphTime)
	{
		SetWeapon(Weapon(Actor(MO).Tracer));	// Restore weapon
		MorphTime = 0.0;
	}

	MO.Angles.pitch = 0.0;
	MO.RenderStyle = Entity::STYLE_Normal;
	MO.Alpha = 1.0;
	EntityEx(MO).bShadow = false;	// cancel invisibility
	ExtraLight = 0;			// cancel gun flashes
	FixedColourmap = 0;		// cancel ir gogles
	DamageFlash = 0.0;		// no palette changes
	BonusFlash = 0.0;
	PoisonCount = 0;
	BlendR = 0.0;
	BlendG = 0.0;
	BlendB = 0.0;
	BlendA = 0.0;
	Rain1 = none;
	Rain2 = none;
}

//==========================================================================
//
//  InventoryLeft
//
//==========================================================================

final void InventoryLeft()
{
	if (!bInventoryAlwaysOpen)
	{
		if (!InventoryTime)
		{
			InventoryTime = 5.0;
			return;
		}
		InventoryTime = 5.0;
	}
	if (InvPtr)
	{
		Inventory Prev = InvPtr.PrevInv();
		if (Prev)
		{
			InvPtr = Prev;
			AdjustInvFirst();
		}
	}
}

//==========================================================================
//
//  InventoryRight
//
//==========================================================================

final void InventoryRight()
{
	if (!bInventoryAlwaysOpen)
	{
		if (!InventoryTime)
		{
			InventoryTime = 5.0;
			return;
		}
		InventoryTime = 5.0;
	}
	if (InvPtr)
	{
		Inventory Next = InvPtr.NextInv();
		if (Next)
		{
			InvPtr = Next;
			AdjustInvFirst();
		}
	}
}

//==========================================================================
//
//  InventoryUse
//
//==========================================================================

final void InventoryUse()
{
	// flag to denote that it's okay to use an artifact
	if (InventoryTime)
	{
		InventoryTime = 0.0;
	}
	else if (InvPtr)
	{
		EntityEx(MO).UseInventory(InvPtr);
	}
}

//==========================================================================
//
//  InventoryTick
//
//==========================================================================

final void InventoryTick(float deltaTime)
{
	// turn inventory off after a certain amount of time
	if (InventoryTime)
	{
		InventoryTime -= deltaTime;
		if (InventoryTime <= 0.0)
		{
			InventoryTime = 0.0;
		}
	}
	if (ArtifactFlash)
	{
		ArtifactFlash--;
	}
}

//==========================================================================
//
//	AdjustInvFirst
//
//==========================================================================

final void AdjustInvFirst()
{
	Inventory Item;

	if (!InvPtr)
	{
		InvFirst = none;
		return;
	}

	//	Count how many items are following the current one, also make sure
	// that first is not after this one.
	int NumFollowing = 0;
	for (Item = InvPtr.NextInv(); Item; Item = Item.NextInv())
	{
		NumFollowing++;
		if (InvFirst == Item)
		{
			InvFirst = InvPtr;
		}
	}
	int FirstOffs = 0;
	for (Item = InvPtr; Item && Item != InvFirst; Item = Item.PrevInv())
	{
		FirstOffs++;
	}
	while (FirstOffs > InvSize)
	{
		InvFirst = InvFirst.NextInv();
		FirstOffs--;
	}
	while (NumFollowing + FirstOffs < InvSize && InvFirst.PrevInv())
	{
		InvFirst = InvFirst.PrevInv();
		FirstOffs++;
	}
}

//==========================================================================
//
//	InventoryThrow
//
//==========================================================================

final EntityEx InventoryThrow()
{
	if (!InvPtr)
	{
		return none;
	}
	return EntityEx(MO).DropInventory(InvPtr);
}

//==========================================================================
//
//  UseFlyPower
//
//==========================================================================

final void UseFlyPower()
{
	PlayerUseArtifactType(ArtiFly);
}

//==========================================================================
//
//  PlayerUseArtifactType
//
//==========================================================================

final void PlayerUseArtifactType(class<Inventory> arti)
{
	Inventory Item = EntityEx(MO).FindInventory(arti);
	if (Item)
	{
		EntityEx(MO).UseInventory(Item);
	}
}

//==========================================================================
//
//  PlayerNextArtifact
//
//==========================================================================

final void PlayerNextArtifact()
{
	if (!InvPtr)
	{
		return;
	}
	Inventory NewPtr = InvPtr.PrevInv();
	if (!NewPtr)
	{
		NewPtr = InvPtr;
		while (NewPtr.NextInv())
		{
			NewPtr = NewPtr.NextInv();
		}
	}
	InvPtr = NewPtr;
	AdjustInvFirst();
}

//==========================================================================
//
//  DeathPlayerTick
//
//  Fall on your face when dying. Decrease POV height to floor height.
//
//==========================================================================

final void DeathPlayerTick(float deltaTime)
{
	int dir;
	float delta;

	MovePsprites(deltaTime);

	if (MO.WaterLevel > 1)
	{
		MO.Velocity.z = -60.0;	// drift towards bottom
	}

	onground = (MO.Origin.z <= MO.FloorZ);

	if (PlayerChunk(MO))
	{
		// Flying bloody skull or flying ice chunk
		ViewHeight = 6.0;
		DeltaViewHeight = 0.0;
		//damagecount = 20;
		if (onground)
		{
#ifdef FIXME
			if (lookdir < 60)
			{
				int lookDelta = (60 - lookdir) / 8;
				if (lookDelta < 1 && (level->tictime & 1))
				{
					lookDelta = 1;
				}
				else if (lookDelta > 6)
				{
					lookDelta = 6;
				}
				lookdir += lookDelta;
			}
#endif
		}
	}
	else if (Actor(MO).DamageType != 'Ice')
	{
		// Fall to ground (if not frozen)
		DeltaViewHeight = 0.0;
		if (ViewHeight > 6.0)
		{
			ViewHeight -= 35.0 * deltaTime;
		}
		if (ViewHeight < 6.0)
		{
			ViewHeight = 6.0;
		}
#ifdef FIXME
		if (lookdir > 0)
		{
			lookdir -= 6;
		}
		else if (lookdir < 0)
		{
			lookdir += 6;
		}
		if (abs(lookdir) < 6)
		{
			lookdir = 0;
		}
#endif
	}
	CalcHeight(deltaTime);

	if (Attacker && Attacker != MO)
	{
		// Watch killer
		dir = EntityEx(MO).FaceActor(EntityEx(Attacker), delta);
		if (delta < 10.0)
		{
			// Looking at killer, so fade damage and poison counters
			if (DamageFlash)
			{
				DamageFlash -= deltaTime;
				if (DamageFlash <= 0.0)
					DamageFlash = 0.0;
			}
			if (PoisonCount)
			{
				PoisonCount--;
			}
		}
		delta = delta / 8.0;
		if (delta > 5.0)
		{
			delta = 5.0;
		}
		if (dir)
		{
			// Turn clockwise
			MO.Angles.yaw += delta;
		}
		else
		{
			// Turn counter clockwise
			MO.Angles.yaw -= delta;
		}
	}
	else if (DamageFlash)
	{
		DamageFlash -= deltaTime;
		if (DamageFlash <= 0.0)
			DamageFlash = 0.0;
	}
	else if (PoisonCount)
	{
		PoisonCount--;
	}

	if (CheckForRespawn(deltaTime))
	{
		InvPtr = none;
		InvFirst = none;
		PlayerState = PST_REBORN;
	}
}

//==========================================================================
//
//  CheckForRespawn
//
//==========================================================================

bool CheckForRespawn(float deltaTime)
{
	return !!(Buttons & BT_USE);
}

//==========================================================================
//
//  PlayerTick
//
//==========================================================================

void PlayerTick(float deltaTime)
{
	if (bIsBot)
	{
		BotTick(deltaTime);
	}

	if ((MO.XLevel.TicTime % (3 * 35) == 0) && Cheats & CF_REGENERATION && Health > 0)
	{
		if (EntityEx(MO).GiveBody(5) &&
			!GetSoundPlayingInfo(MO, GetSoundID('*regenerate')))
		{
			MO.PlaySound('*regenerate', CHAN_VOICE);
		}
	}

	if (Actor(MO).bJustAttacked)
	{
		ForwardMove = 100.0;
		SideMove = 0.0;
		Actor(MO).bJustAttacked = false;
	}

	//	You can only press use while totally frozen
	if (bTotallyFrozen)
	{
		Buttons &= BT_USE;
		Impulse = 0;
		ViewAngles = MO.Angles;
		ForwardMove = 0.0;
		SideMove = 0.0;
		FlyMove = 0.0;
	}
	else if (bFrozen)
	{
		ForwardMove = 0.0;
		SideMove = 0.0;
		FlyMove = 0.0;
	}

	WorldTimer += deltaTime;
	InventoryTick(deltaTime);

	if (PlayerState == PST_DEAD)
	{
		DeathPlayerTick(deltaTime);
		return;
	}

	// Copy view angles
	if (MO == Camera)
	{
		MO.Angles = ViewAngles;
	}

	if (JumpTime)
	{
		JumpTime -= deltaTime;
		if (JumpTime <= 0.0)
		{
			JumpTime = 0.0;
		}
	}
	if (MorphTime)
	{
		PlayerPawn(MO).MorphPlayerThink();
	}

	//	Move around.
	//	ReactionTime is used to prevent movement for a bit after a teleport.
	if (Actor(MO).ReactionTime)
	{
		Actor(MO).ReactionTime -= deltaTime;
		if (Actor(MO).ReactionTime <= 0.0)
			Actor(MO).ReactionTime = 0.0;
		if (Actor(MO).bWaterJump)
			WaterJump();
	}
	else
	{
		if (MO.WaterLevel > 1)
			WaterMove(deltaTime);
		else
			MovePlayer(deltaTime);
		if (EntityEx(MO).FindInventory(PowerSpeed) &&
			!(Level.XLevel.TicTime & 1) && Length(MO.Velocity) > 12.0 * 35.0)
		{
			SpawnSpeedEffect();
		}
	}

	CalcHeight(deltaTime);

	if (MO.Sector->special || MO.Sector->Damage)
	{
		PlayerInSpecialSector(deltaTime);
	}
	PlayerOnSpecialFlat(Actor(MO).GetFloorType());
	PlayerInContents(deltaTime);

	if (MO.Velocity.z <= -35.0 * 35.0 && MO.Velocity.z >= -40.0 * 35.0 &&
		!MorphTime && MO.WaterLevel == 0 &&
		!GetSoundPlayingInfo(MO, GetSoundID('*falling')))
	{
		MO.PlaySound('*falling', CHAN_VOICE);
	}

	// Check for weapon change.
	if (Impulse)
	{
		PlayerImpulse();
	}

	// check for use
	if (Buttons & BT_USE)
	{
		if (!bUseDown)
		{
			EntityEx(MO).UseLines(USERANGE, USETHINGRANGE, '*usefail');
			bUseDown = true;
		}
	}
	else
	{
		bUseDown = false;
	}

	if (!ReadyWeapon && PendingWeapon)
	{
		SetWeapon(PendingWeapon);
		BringUpWeapon();
	}

	// Morph counter
	if (MorphTime)
	{
		if (ChickenPeck)
		{
			// Chicken attack counter
			ChickenPeck -= 3;
		}
		MorphTime -= deltaTime;
		if (MorphTime <= 0.0)
		{
			// Attempt to undo the chicken/pig
			MorphTime = 0.0;
			UndoPlayerMorph(false, self);
		}
	}

	//	Cycle psprites
	MovePsprites(deltaTime);

	//	Counters.
	if (PoisonCount && Level.XLevel.Time - LastPoisonTime >= 0.5)
	{
		PoisonCount -= 5;
		if (PoisonCount < 0)
		{
			PoisonCount = 0;
		}
		LastPoisonTime = Level.XLevel.Time;
		Actor(MO).PoisonDamage(Poisoner, Poisoner, 1, true);
	}

	if (DamageFlash)
	{
		DamageFlash -= deltaTime;
		if (DamageFlash <= 0.0)
			DamageFlash = 0.0;
	}

	if (BonusFlash)
	{
		BonusFlash -= deltaTime;
		if (BonusFlash <= 0.0)
			BonusFlash = 0.0;
	}

	if (HazardTime)
	{
		HazardTime -= deltaTime;
		if (HazardTime <= 0.0)
			HazardTime = 0.0;
		if (Level.XLevel.Time - LastHazardTime >= 32.0 / 35.0 &&
			HazardTime > 16.0)
		{
			LastHazardTime = Level.XLevel.Time;
			Actor(MO).Damage(none, none, 5);
		}
	}
	
	// [RH] Zoom the player's FOV
	float desired = DesiredFOV; // Default player FOV.
	// Adjust FOV using on the currently held weapon.
	if (PlayerState != PST_DEAD &&		// No adjustment while dead.
		ReadyWeapon &&					// No adjustment if no weapon.
		ReadyWeapon.FOVScale != 0.0)	// No adjustment if the adjustment is zero.
	{
		// A negative scale is used top prevent G_AddViewAngle/G_AddViewPitch
		// from scaling with the FOV scale.
		desired *= fabs(ReadyWeapon.FOVScale);
	}
	
	if (FOV != desired)
	{
		if (fabs(FOV - desired) < 7.0)
		{
			FOV = desired;
		}
		else
		{
			float zoom = FMax(7.0, fabs(FOV - desired) * 0.025);

			if (FOV > desired)
			{
				FOV = FOV - zoom;
			}
			else
			{
				FOV = FOV + zoom;
			}
		}
		SetFOV(ftoi(FOV));
	}
}

//==========================================================================
//
//  SetViewPos
//
//==========================================================================

final void SetViewPos()
{
	//	Just in a case camera entity has been destroyed
	if (!Camera)
	{
		Camera = MO;
	}

	if (MO != Camera)
	{
		ViewOrg = Camera.Origin;
		ViewOrg.z += EntityEx(Camera).CameraHeight;
		ViewAngles = Camera.Angles;
	}
	else
	{
		ViewOrg.x = MO.Origin.x;
		ViewOrg.y = MO.Origin.y;

		if (LocalQuakeHappening)
		{
			float intensity;

			intensity = itof(LocalQuakeHappening);
			ViewOrg.x += (Random() - 0.5) * (intensity * 4.0);
			ViewOrg.y += (Random() - 0.5) * (intensity * 4.0);
		}

		if (PlayerState != PST_DEAD)
		{
			ViewAngles = MO.Angles;
		}
		else
		{
			ViewAngles.yaw = MO.Angles.yaw;
			ViewAngles.pitch = MO.Angles.pitch;
		}

		if (MorphTime && ChickenPeck)
		{
			// Set chicken attack view position
			ViewOrg.x += itof(ChickenPeck) * cos(MO.Angles.yaw);
			ViewOrg.y += itof(ChickenPeck) * sin(MO.Angles.yaw);
		}
	}

	PaletteFlash();

	ClientSetViewOrg(ViewOrg.x, ViewOrg.y, ViewOrg.z);

	SoundEnvironment = Level.XLevel.Zones[Camera.Sector->Zone];
	if (!SoundEnvironment)
	{
		if (Camera.WaterLevel >= 3)
		{
			//	Under water
			SoundEnvironment = 0x1600;
		}
		else
		{
			//	Generic
			SoundEnvironment = 1;
		}
	}
}

//==========================================================================
//
//  ClientTick
//
//==========================================================================

void ClientTick(float deltaTime)
{
	bAutoAim = !!GetCvar('autoaim');
}

//==========================================================================
//
//  AdjustPlayerAngle
//
//==========================================================================

final void AdjustPlayerAngle(EntityEx AimTarget)
{
	float angle;
	float difference;

	angle = atan2(AimTarget.Origin.y - MO.Origin.y,
		AimTarget.Origin.x - MO.Origin.x);
	difference = AngleMod180(angle - MO.Angles.yaw);
	if (fabs(difference) > 5.0)
	{
		MO.Angles.yaw += difference > 0.0 ? 5.0 : -5.0;
	}
	else
	{
		MO.Angles.yaw = angle;
	}
	bFixAngle = true;
}

//==========================================================================
//
//  UndoPlayerMorph
//
//==========================================================================

final bool UndoPlayerMorph(bool Force, PlayerEx Activator)
{
	Actor A;

	if (EntityEx(MO).bInvulnerable && (self != Activator ||
		!(MorphStyle & EntityEx::MORPH_WHENINVULNERABLE)))
	{
		// Immune when invulnerable unless this is something we initiated.
		// If the WORLD is the initiator, the same player should be given
		// as the activator; WORLD initiated actions should always succeed.
		return false;
	}

	int CorrectWeapon = MorphStyle & EntityEx::MORPH_LOSEACTUALWEAPON;

	MO.UnlinkFromWorld();
	if (BaseClass >= Level.Game.PlayerClasses.Num)
	{
		Error("UndoPlayerMorph: Unknown class type");
	}
	A = Level.Spawn(class<PlayerPawn>(Level.Game.PlayerClasses[BaseClass]),
		MO.Origin,,, false);
	if (!Force && !A.TestLocation())
	{
		// Didn't fit
		A.Destroy();
		MO.LinkToWorld();
		MorphTime = 2.0;
		return false;
	}
	MO.LinkToWorld();
	// Set colour translation
	A.Translation = (Entity::TRANSL_Player << Entity::TRANSL_TYPE_SHIFT) +
		GetPlayerNum();
	A.Angles = MO.Angles;
	ViewHeight = PlayerPawn(A).ViewHeight;
	DeltaViewHeight = 0.0;
	A.Player = self;
	A.bIsPlayer = true;
	A.ReactionTime = 0.5;
	if (MO.bFly)
	{
		A.bFly = true;
		A.bNoGravity = true;
	}
	A.bShadow = EntityEx(MO).bShadow;
	A.bGhost = EntityEx(MO).bGhost;
	A.ObtainInventory(EntityEx(MO));
	if (MO.TID && (MorphStyle & EntityEx::MORPH_NEWTIDBEHAVIOUR))
	{
		A.SetTID(MO.TID);
	}
	MorphTime = 0.0;
	MorphStyle = 0;
	Inventory Pw = EntityEx(MO).FindInventory(PowerWeaponLevel2);
	if (Pw)
	{
		Pw.Destroy();
	}
	A.Health = GetRebornHealth();
	Health = A.Health;
	PClass = BaseClass;
	Weapon OldWeapon = ReadyWeapon;
	PostMorphWeapon(Weapon(Actor(MO).Tracer));
	if (CorrectWeapon)
	{
		// Better "lose morphed weapon" semantics
		class<Weapon> MorphWeapon = PlayerPawn(MO).MorphWeapon;
		if (MorphWeapon)
		{
			Weapon OrigWpn = Weapon(EntityEx(MO).FindInventory(MorphWeapon));
			if (OrigWpn && OrigWpn.bGivenAsMorphWeapon)
			{
				// You don't get to keep your morphed weapon.
				OrigWpn.Destroy();
			}
		}
	}
	else
	{
		if (OldWeapon)
		{
			OldWeapon.Destroy();
		}
	}

	Level.Spawn(UnmorphFlash ? UnmorphFlash : class<Actor>(TeleportFog),
		MO.Origin + vector(20.0 * cos(MO.Angles.yaw),
		20.0 * sin(MO.Angles.yaw),
		LineSpecialGameInfo(Level.Game).TeleFogHeight));

	MO.SetState(MO.FindState('FreeTargMobj'));
	MO = A;
	Camera = A;
	PlayerUnmorphed();
	return true;
}

//===========================================================================
//
//  ActivateMorphWeapon
//
//===========================================================================

final void ActivateMorphWeapon()
{
	class<Weapon> WpnClass = PlayerPawn(MO).MorphWeapon;
	Weapon Wpn;
	if (WpnClass)
	{
		Wpn = Level.Spawn(WpnClass);
		Wpn.bGivenAsMorphWeapon = true;
	}
	else
	{
		// Couldn't find any weapons, use the default weapon for this player
		// (from initial inventory)
		int i;
		for (i = 0; i < EntityEx(MO).DropItemList.Num; i++)
		{
			Inventory Item = Inventory(Level.Spawn(EntityEx(MO).DropItemList[i].Type,,,, false));
			if (EntityEx(MO).DropItemList[i].Amount > 0)
			{
				Item.Amount = EntityEx(MO).DropItemList[i].Amount;
			}
			if (Weapon(Item))
			{
				Wpn = Weapon(Item);
				WpnClass = class<Weapon>(Weapon(Item).Class);
			}
		}		
	}
	if (!Wpn.TryPickup(EntityEx(MO)))
	{
		Wpn.Destroy();
	}

	SetWeapon(Weapon(EntityEx(MO).FindInventory(WpnClass)));
	SetViewState(ps_weapon, ReadyWeapon.GetReadyState());
	ViewStates[ps_weapon].SY = Weapon::WEAPONTOP;
}

//===========================================================================
//
//  PostMorphWeapon
//
//===========================================================================

final void PostMorphWeapon(Weapon weapon)
{
	SetWeapon(weapon);
	ViewStates[ps_weapon].SY = Weapon::WEAPONBOTTOM;
	SetViewState(ps_weapon, ReadyWeapon.GetUpState());
}

//==========================================================================
//
//	AddVisitedMap
//
//==========================================================================

final void AddVisitedMap(name Map)
{
	int i;
	for (i = 0; i < MAX_MAPS_VISITED; i++)
	{
		if (MapsVisited[i] == Map)
		{
			return;
		}
		if (!MapsVisited[i])
		{
			MapsVisited[i] = Map;
			return;
		}
	}
}

//==========================================================================
//
//	GetMaxHealth
//
//==========================================================================

int GetMaxHealth()
{
	int Max = (PlayerPawn(MO).MaxHealth > 0 ? PlayerPawn(MO).MaxHealth :
		Level.CompatDehHealth ? MAXHEALTH :
		HealthBonus.default.MaxAmount / 2) + Stamina;
	if (MorphTime)
	{
		if (MorphStyle & EntityEx::MORPH_FULLHEALTH)
		{
			if (!(MorphStyle & EntityEx::MORPH_ADDSTAMINA))
			{
				Max -= Stamina;
			}
		}
		else
		{
			Max = MAXMORPHHEALTH;
			if (MorphStyle & EntityEx::MORPH_ADDSTAMINA)
			{
				Max += Stamina;
			}
		}
	}
	return Max;
}

//==========================================================================
//
//  Cheat_God
//
//==========================================================================

final void Cheat_God()
{
	Cheats ^= CF_GODMODE;
	if (Cheats & CF_GODMODE)
	{
		if (LineSpecialGameInfo(Level.Game).GOD_HEALTH)
		{
			if (MO)
			{
				MO.Health = LineSpecialGameInfo(Level.Game).GOD_HEALTH;
			}
			Health = LineSpecialGameInfo(Level.Game).GOD_HEALTH;
			cprint("Degreelessness Mode On");
		}
		else
		{
			cprint("GOD MODE ON");
		}
	}
	else
	{
		if (LineSpecialGameInfo(Level.Game).GOD_HEALTH)
		{
			cprint("Degreelessness Mode Off");
		}
		else
		{
			cprint("GOD MODE OFF");
		}
	}
}

//==========================================================================
//
//  Cheat_NoClip
//
//==========================================================================

final void Cheat_NoClip()
{
	Cheats ^= CF_NOCLIP;
	if (Cheats & CF_NOCLIP)
	{
		MO.bColideWithThings = false;
		MO.bColideWithWorld = false;
		cprint("No Clipping Mode ON");
	}
	else
	{
		MO.bColideWithThings = true;
		MO.bColideWithWorld = true;
		cprint("No Clipping Mode OFF");
	}
}

//==========================================================================
//
//  Cheat_KillAll
//
//==========================================================================

final void Cheat_KillAll()
{
	cprint("%d MONSTERS KILLED", LineSpecialLevelInfo(Level).P_Massacre());
}

//==========================================================================
//
//  Cheat_NoWeapons
//
//==========================================================================

final void Cheat_NoWeapons()
{
	if (MorphTime)
	{
		return;
	}
	//	Find weakest weapon.
	Inventory Item;
	Weapon Weakest = none;
	for (Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory)
	{
		if (Weapon(Item) && (!Weakest ||
			Weakest.SelectionOrder < Weapon(Item).SelectionOrder))
		{
			Weakest = Weapon(Item);
		}
	}
	//	Removed all others.
	for (Item = EntityEx(MO).Inventory; Item; )
	{
		Inventory Next = Item.Inventory;
		if ((Weapon(Item) && Item != Weakest) || FourthWeaponHolder(Item))
		{
			Item.Destroy();
		}
		Item = Next;
	}
	SetWeapon(Weakest);
	PendingWeapon = Weakest;
	cprint("CHEATER - YOU DON'T DESERVE WEAPONS");
}

//==========================================================================
//
//  Cheat_Fly
//
//==========================================================================

final void Cheat_Fly()
{
	if (!bFly)
	{
		bFly = true;
		MO.bFly = true;
		MO.bNoGravity = true;
		if (MO.Origin.z <= MO.FloorZ)
		{
			// thrust the player in the air a bit
			FlyHeight = 10.0;
		}
		if (MO.Velocity.z <= -35.0 * 35.0)
		{
			// stop falling scream
			MO.StopSound(CHAN_VOICE);
		}
		cprint("You feel lighter");
	}
	else
	{
		if (MO.Origin.z != MO.FloorZ)
		{
//FIXME			player->centreing = true;
		}
		bFly = false;
		MO.bFly = false;
		MO.bNoGravity = false;
		cprint("Gravity weights you down");
	}
}

//==========================================================================
//
//  Cheat_NoTarget
//
//==========================================================================

final void Cheat_NoTarget()
{
	bNoTarget = !bNoTarget;
	if (bNoTarget)
	{
		cprint("No Target Mode ON");
	}
	else
	{
		cprint("No Target Mode OFF");
	}
}

//==========================================================================
//
//  Cheat_Anubis
//
//==========================================================================

final void Cheat_Anubis()
{
	Cheats ^= CF_FRIGHTENING;
	if (Cheats & CF_FRIGHTENING)
	{
		cprint("\"Quake with fear!\"");
	}
	else
	{
		cprint("No more ogre armor");
	}
}

bool CheckFriendlyFire(EntityEx source, int damage)
{
	return false;
}

bool IsWeaponAlwaysExtremeDeath()
{
	return false;
}

//==========================================================================
//
//  SetFOV
//
//  Zoom the player's FOV
//
//==========================================================================

final void SetFOV(int New_FOV)
{
	SetCvar('FOV', New_FOV);
}

void StartDeathSlideShow()
{
}

void GotAmmo(Ammo NewAmmo)
{
}

void Damaged(EntityEx inflictor)
{
}

void KilledActor(EntityEx Victim)
{
}

void Killed(EntityEx source, EntityEx inflictor)
{
}

int GetSigilPieces()
{
	return 0;
}

void PlayerMorphed(EntityEx OldMO)
{
}

void CreateBot()
{
}

void OnNetReborn(EntityEx OldMO)
{
}

void DestroyBot()
{
}

void BotOnSpawn()
{
}

void SetClientModel()
{
}

int GetRebornHealth()
{
	return 0;
}

void BotTick(float deltaTime)
{
}

void SpawnSpeedEffect()
{
}

void PlayerImpulse()
{
}

void PlayerUnmorphed()
{
}

defaultproperties
{
	InvSize = 6;
}
