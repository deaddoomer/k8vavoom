//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**	Class for Actor state action methods. This will eventually be
//**  renamed to Actor.
//**
//**************************************************************************

class ScriptedEntity : EntityEx
	abstract;

//==========================================================================
//
//	A_Look
//
//	Stay in state until a player is sighted or has a goal.
//
//==========================================================================

final void A_Look()
{
	EntityEx	targ;
	Entity		Ent;

	//	Set goal now if appropriate.
	if (Special == LNSPEC_ThingSetGoal && Args[0] == 0)
	{
		int Searcher = -1;
		Goal = none;
		for (Ent = Level.FindMobjFromTID(Args[1], &Searcher); Ent;
			Ent = Level.FindMobjFromTID(Args[1], &Searcher))
		{
			if (!PatrolPoint(Ent))
			{
				continue;
			}
			Goal = PatrolPoint(Ent);
			break;
		}
		Special = 0;
		ReactionTime = itof(Args[2]) + XLevel.Time;
		bChaseGoal = !!Args[3];
	}

	Threshold = 0;	// any shot will wake up
	if (TIDToHate)
	{
		targ = Target;
	}
	else
	{
		targ = EntityEx(Sector->SoundTarget);
	}

	// No target
	if (targ && targ.Player && (targ.Player.Cheats & BasePlayer::CF_NOTARGET))
	{
		return;
	}

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = -1;
	}

	if (targ && targ.bShootable)
	{
		Target = targ;

		if (bAmbush)
		{
			if (!CanSee(Target))
			{
				if (!LookForPlayers(false))
					return;
			}
		}
	}
	else
	{
		if (!LookForPlayers(bLookAllAround))
			return;
	}

	//	Go into chase state
	//	Don't start chasing after a goal if it isn't time yet.
	if (Target == Goal)
	{
		if (ReactionTime > XLevel.Time)
		{
			Target = none;
		}
	}
	else if (SightSound)
	{
		if (bBoss)
		{
			// Full volume
			PlaySound(SightSound, CHAN_VOICE, 1.0, ATTN_NONE);
		}
		else
		{
			PlaySound(SightSound, CHAN_VOICE);
		}
	}

	if (Target)
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//	A_Stand
//
//==========================================================================

final void A_Stand()
{
	EntityEx	targ;

	Threshold = 0;	// any shot will wake up
	targ = EntityEx(Sector->SoundTarget);

	if (!bNeutral && targ && targ.bShootable)
	{
		if (bFriendly != targ.bFriendly || Level.bNoAllies)
		{
			Target = targ;
			if (!bStandMustSeeTarget || CanSee(targ))
			{
				Threshold = 10;
				SetState(SeeState);
				return;
			}
		}
		else
		{
			if (LookForPlayers(bLookAllAround))
			{
				SetState(SeeState);
				bInCombat = true;
				return;
			}
		}
	}
	if (P_Random() < 30)
	{
		if (!(P_Random() & 1))
			SetState(FindState('LookRight'));
		else
			SetState(FindState('LookLeft'));
	}
	if (!bStanding && P_Random() < 40)
	{
		SetState(FindState('Walk'));
	}
}

//==========================================================================
//
//	A_Walk
//
//==========================================================================

final void A_Walk()
{
	float	delta;

	//  Remove muzzle flash
	if (bMuzzleFlash)
	{
		bMuzzleFlash = false;
	}

	bInCombat = false;
	if (bStanding)
		return;

	if (Threshold != 0)
	{
		Threshold--;
		return;
	}

	// turn towards movement direction if not there yet
	if (MoveDir < DI_NODIR)
	{
		Angles.yaw = itof(ftoi(Angles.yaw / 45.0)) * 45.0;
		delta = AngleMod180(Angles.yaw - itof(MoveDir) * 45.0);

		if (delta > 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw - 45.0);
		}
		else if (delta < 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw + 45.0);
		}
	}

	if (--MoveCount < 0 || !StepMove())
	{
		RandomChaseDir();
		MoveCount += 5;
	}
}

//==========================================================================
//
//	DoChase
//
//	Actor has a melee attack, so it tries to close as fast as possible
//
//==========================================================================

void DoChase(bool FastChase, state AMeleeState, state AMissileState,
	bool NightmareFast, bool PlayActive)
{
	float		delta;
	float		dist;
	float		ang;
	float		oldX;
	float		oldY;
	int			oldFloor;

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = -1;
	}

	if (ReactionCount)
	{
		ReactionCount--;
	}

	//	Remove muzzle flash.
	if (bMuzzleFlash)
	{
		bMuzzleFlash = false;
	}

	bInCombat = true;
	//	Modify target threshold.
	if (Threshold)
	{
		if (!Target || Target.Health <= 0)
		{
			Threshold = 0;
		}
		else
		{
			Threshold--;
		}
	}

	if (NightmareFast && Level.Game.fastparm)
	{
		//	Monsters move faster in nightmare mode.
		StateTime *= 0.5;
		if (StateTime < 0.1)
		{
			StateTime = 0.1;
		}
	}

	//	Turn towards movement direction if not there yet.
	// killough 9/7/98: keep facing towards target if strafing or backing out
	if (strafecount)
	{
		A_FaceTarget();
	}
	else
	{
		if (MoveDir < 8)
		{
			Angles.yaw = itof(ftoi(Angles.yaw / 45.0)) * 45.0;
			delta = AngleMod180(Angles.yaw - itof(MoveDir) * 45.0);

			if (delta > 0.0)
			{
				Angles.yaw = AngleMod360(Angles.yaw - 45.0);
			}
			else if (delta < 0.0)
			{
				Angles.yaw = AngleMod360(Angles.yaw + 45.0);
			}
		}
	}

	//	If the target is dead and not a goal, stop chasing it.
	if (Target && Target != Goal && Target.Health <= 0)
	{
		Target = none;
	}

	if (!Target || !Target.bShootable)
	{
		//	Look for a new target.
		if (LookForPlayers(true) && Target != Goal)
		{
			//	Got a new target.
			return;
		}
		if (!Target)
		{
			SetState(IdleState);
			bInCombat = false;
			return;
		}
	}

	//	Do not attack twice in a row.
	if (bJustAttacked)
	{
		bJustAttacked = false;
		if (!Level.Game.fastparm)
		{
			NewChaseDir();
		}
		return;
	}

	//	Don't attack if just moving toward goal
	if (Target == Goal || (bChaseGoal && Goal))
	{
		EntityEx SavedTarget = Target;
		Target = Goal;
		bool Result = CheckMeleeRange();
		Target = SavedTarget;

		if (Result)
		{
			// reached the goal

			// Execute the specials of any PatrolSpecials with the same TID
			// as the goal.
			Entity Ent;
			int Searcher = -1;
			for (Ent = Level.FindMobjFromTID(Goal.TID, &Searcher); Ent;
				Ent = Level.FindMobjFromTID(Goal.TID, &Searcher))
			{
				if (!PatrolSpecial(Ent))
				{
					continue;
				}
				Level.ExecuteActionSpecial(Ent.Special, Ent.Args[0],
					Ent.Args[1], Ent.Args[2], Ent.Args[3], Ent.Args[4],
					NULL, 0, self);
			}

			float LastGoalAng = Goal.Angles.yaw;
			int Delay;
			EntityEx NewGoal = none;
			Searcher = -1;
			for (Ent = Level.FindMobjFromTID(Goal.Args[0], &Searcher); Ent;
				Ent = Level.FindMobjFromTID(Goal.Args[0], &Searcher))
			{
				if (!PatrolPoint(Ent))
				{
					continue;
				}
				NewGoal = PatrolPoint(Ent);
				break;
			}
			if (NewGoal && Goal == Target)
			{
				Delay = NewGoal.Args[1];
				ReactionTime = itof(Delay) + XLevel.Time;
			}
			else
			{
				Delay = 0;
				ReactionTime = default.ReactionTime;
				Angles.yaw = LastGoalAng;		// Look in direction of last goal
			}
			if (Target == Goal)
			{
				Target = none;
			}
			bJustAttacked = true;
			if (NewGoal && Delay != 0)
			{
				bInCombat = true;
				SetState(IdleState);
			}
			Goal = NewGoal;
			return;
		}
	}

	if (Goal != Target)
	{
		if (FastChase)
		{
			//	Strafe
			if (FastChaseStrafeCount > 0)
			{
				FastChaseStrafeCount--;
			}
			else
			{
				FastChaseStrafeCount = 0;
				Velocity.x = 0.0;
				Velocity.y = 0.0;
				dist = DistTo(Target);
				if (dist < 640.0)
				{
					if (P_Random() < 100)
					{
						ang = atan2(Target.Origin.y - Origin.y,
							Target.Origin.x - Origin.x);
						if (P_Random() < 128)
							ang = AngleMod360(ang + 90.0);
						else
							ang = AngleMod360(ang - 90.0);
						Velocity.x = 13.0 * cos(ang) * 35.0;
						Velocity.y = 13.0 * sin(ang) * 35.0;
						FastChaseStrafeCount = 3;	// strafe time
					}
				}
			}
		}

		//	Check for melee attack.
		if (AMeleeState && CheckMeleeRange())
		{
			if (AttackSound)
			{
				PlaySound(AttackSound, CHAN_WEAPON);
			}
			SetState(AMeleeState);
			return;
		}

		//	Check for missile attack.
		if (AMissileState)
		{
			if (Level.Game.fastparm || !MoveCount)
			{
				if (CheckMissileRange())
				{
					SetState(AMissileState);
					bJustAttacked = true;
					return;
				}
			}
		}
	}

	//	Possibly choose another target.
	if ((Level.Game.netgame || TIDToHate) && !Threshold)
	{
		if (!CanSee(Target))
		{
			bool PrevNoSightCheck = bNoSightCheck;
			bNoSightCheck = false;
			bool GotNew = LookForPlayers(true);
			bNoSightCheck = PrevNoSightCheck;
			if (GotNew)
			{
				//	Got a new target.
				return;
			}
		}
	}

	if (strafecount)
	{
		strafecount--;
	}

	//	Chase towards player.
	if (!FastChase || !FastChaseStrafeCount)
	{
		oldX = Origin.x;
		oldY = Origin.y;
		oldFloor = Sector->floor.pic;
		if (--MoveCount < 0 || !StepMove())
		{
			NewChaseDir();
		}
		if (bCantLeaveFloorpic && Sector->floor.pic != oldFloor)
		{
			TryMove(vector(oldX, oldY, Origin.z));
			NewChaseDir();
		}
	}

	//	Make active sound.
	if (PlayActive && P_Random() < 3)
	{
		PlayActiveSound();
	}
}

//==========================================================================
//
//	A_Chase
//
//==========================================================================

final void A_Chase()
{
	DoChase(false, MeleeState, MissileState,
		LineSpecialGameInfo(Level.Game).bNightmareFastChase, true);
}

//============================================================================
//
//  A_FastChase
//
//============================================================================

final void A_FastChase()
{
	DoChase(true, MeleeState, MissileState, true, true);
}

//==========================================================================
//
//	A_FaceTarget
//
//==========================================================================

final void A_FaceTarget()
{
	if (!Target)
		return;

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = 1;
	}

	bAmbush = false;

	Angles.yaw = atan2(Target.Origin.y - Origin.y,
		Target.Origin.x - Origin.x);

	if (Target.Alpha < 1.0)
	{
		Angles.yaw = AngleMod360(Angles.yaw + (Random() - Random()) * 45.0);
	}
}

//==========================================================================
//
//  A_Pain
//
//==========================================================================

final void A_Pain()
{
	//  Remove muzzle flash
	if (bMuzzleFlash)
	{
		bMuzzleFlash = false;
	}

	if (bIsPlayer && !PlayerIsMorphed())
	{
		if (Health < 25)
		{
			PlaySound('*pain25', CHAN_VOICE);
		}
		else if (Health < 50)
		{
			PlaySound('*pain50', CHAN_VOICE);
		}
		else if (Health < 75)
		{
			PlaySound('*pain75', CHAN_VOICE);
		}
		else
		{
			PlaySound('*pain100', CHAN_VOICE);
		}
	}
	else if (PainSound)
	{
		PlaySound(PainSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_Scream
//
//  Death sound.
//
//==========================================================================

final void A_Scream()
{
	//  Remove muzzle flash & other light effects
	if (bDynamicLight || bMuzzleFlash)
	{
		bDynamicLight = false;
		bMuzzleFlash = false;
	}

	if (DeathSound)
	{
		// Make boss death sounds full volume
		PlaySound(DeathSound, CHAN_VOICE, 1.0, bBoss ? ATTN_NONE : ATTN_NORMAL);
	}
}

//==========================================================================
//
//	A_XScream
//
//  Explode death sound.
//
//==========================================================================

final void A_XScream()
{
	//  Remove muzzle flash
	if (bMuzzleFlash)
	{
		bMuzzleFlash = false;
	}

	if (bIsPlayer)
	{
		PlaySound('*gibbed', CHAN_BODY);
	}
	else
	{
		PlaySound('misc/gibbed', CHAN_BODY);
	}
}

//==========================================================================
//
//  A_XXScream
//
//  Strife version of A_XScream.
//
//==========================================================================

final void A_XXScream()
{
	//  Remove muzzle flash
	if (bMuzzleFlash)
	{
		bMuzzleFlash = false;
	}

	if (!bNoBlood || !DeathSound)
	{
		A_XScream();
	}
	else
	{
		PlaySound(DeathSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//  A_NoBlocking
//
//  Unset blocking.
//
//==========================================================================

final void A_NoBlocking()
{
	int					SpeechNum;
	RogueConSpeech*		Speech;
	class<EntityEx>		DropItemType;

	//  Remove muzzle flash
	if (bMuzzleFlash)
	{
		bMuzzleFlash = false;
	}

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		Alpha = 1.0;
		VisDir = 0;
	}

	// actor is on ground, it can be walked over
	bSolid = false;

	SpeechNum = GetSpeech();
	if (SpeechNum)
	{
		//	Drop stuff as determined by conversation.
		if (SpeechNum < 0)
		{
			Speech = &XLevel.GenericSpeeches[-SpeechNum - 1];
		}
		else
		{
			Speech = &XLevel.LevelSpeeches[SpeechNum - 1];
		}
		DropItemType = LineSpecialLevelInfo(Level).GetClassFromID(Speech->DropItem);
		if (DropItemType)
		{
			DropItem(DropItemType, 0, 1.0);
			return;
		}
	}

	// Check for monsters dropping things
	NoBlockingSet();
}

//==========================================================================
//
//	A_Fall
//
//	For compatibility
//
//==========================================================================

final void A_Fall()
{
	A_NoBlocking();
}

//==========================================================================
//
//	A_ScreamAndUnblock
//
//	For breakable DECORATE decorations that have only one death state.
//
//==========================================================================

final void A_ScreamAndUnblock()
{
	A_Scream();
	A_NoBlocking();
}

//==========================================================================
//
//	A_RemoveForceField
//
//==========================================================================

final void A_RemoveForceField()
{
	int i;
	line_t* line;

	bSpecial = false;
	for (i = 0; i < Sector->linecount; i++)
	{
		line = Sector->lines[i];
		if (line->backsector && line->special == LNSPEC_ForceField)
		{
			line->flags &= ~(ML_BLOCKING|ML_BLOCKEVERYTHING);
			line->special = 0;
			XLevel.Sides[line->sidenum[0]].midtexture = 0;
			XLevel.Sides[line->sidenum[1]].midtexture = 0;
		}
	}
}

//==========================================================================
//
//	A_SetShadow
//
//==========================================================================

final void A_SetShadow()
{
	bUnknown2 = true;
	RenderStyle = STYLE_Translucent;
	Alpha = 0.333;
}

//==========================================================================
//
//	A_ClearShadow
//
//==========================================================================

final void A_ClearShadow()
{
	bUnknown2 = false;
	RenderStyle = STYLE_Normal;
	Alpha = 1.0;
}

//==========================================================================
//
//	A_BeShadowyFoe
//
//==========================================================================

final void A_BeShadowyFoe()
{
	RenderStyle = STYLE_Translucent;
	Alpha = 0.333;
	bFriendly = false;
}

//==========================================================================
//
//  A_Explode
//
//  Handles a bunch of exploding things.
//
//==========================================================================

final void A_Explode()
{
	int			damage;
	float		distance;
	byte		damageSelf;
	int			i;

	damage = 128;
	distance = 128.0;
	damageSelf = true;

	PreExplode();
	GetExplodeParms(damage, distance, damageSelf);

	RadiusAttack(Target, damage, distance, damageSelf);
	if (Origin.z <= FloorZ + distance)
	{
		HitFloorType();
	}

	if (bExplodeParticles)
	{
		//  Spawn explosion effects - dynamic light and particles
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (!Level.Game.Players[i])
				continue;
			if (!Level.Game.Players[i].bSpawned)
				continue;
			PlayerEx(Level.Game.Players[i]).ClientParticleExplosion(
				DLightColour, DLightRadius, Origin + vector(0.0, 0.0, Height * 0.5));
		}
	}
	else if (ExplodeEffect)
	{
		SendExplosion(ExplodeEffect, DLightRadius, Origin);
	}

	//  Clear old dynamic light and trail effects
	bDynamicLight = false;
	bLeaveTrail = false;
}

//==========================================================================
//
//  A_ExplodeAndAlert
//
//==========================================================================

final void A_ExplodeAndAlert()
{
	A_Explode();
	if (Target && Target.bIsPlayer)
	{
		LineSpecialLevelInfo(Level).NoiseAlert(Target, self);
	}
}

//==========================================================================
//
//  A_ExplodeParms
//
//==========================================================================

final void A_ExplodeParms()
{
	int			damage;
	float		distance;
	byte		damageSelf;
	int			i;

	damage = ExplosionDamage;
	distance = itof(ExplosionRadius);
	damageSelf = !bExplosionDontHurtSelf;

	if (!damage)
	{
		damage = 128;
	}
	if (!distance)
	{
		distance = itof(damage);
	}

	RadiusAttack(Target, damage, distance, damageSelf);
	if (Origin.z <= FloorZ + distance)
	{
		HitFloorType();
	}

	if (bExplodeParticles)
	{
		//  Spawn explosion effects - dynamic light and particles
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (!Level.Game.Players[i])
				continue;
			if (!Level.Game.Players[i].bSpawned)
				continue;
			PlayerEx(Level.Game.Players[i]).ClientParticleExplosion(
				DLightColour, DLightRadius, Origin + vector(0.0, 0.0, Height * 0.5));
		}
	}
	else if (ExplodeEffect)
	{
		SendExplosion(ExplodeEffect, DLightRadius, Origin);
	}

	//  Clear old dynamic light and trail effects
	bDynamicLight = false;
	bLeaveTrail = false;
}

//==========================================================================
//
//  A_BossDeath
//
//  Possibly trigger special effects if on first boss level
//
//==========================================================================

final void A_BossDeath()
{
	name Cls = GetClassName(Class);
	if (!((Cls == 'BaronOfHell' && Level.bBaronSpecial) ||
		(Cls == 'Cyberdemon' && Level.bCyberDemonSpecial) ||
		(Cls == 'SpiderMastermind' && Level.bSpiderMastermindSpecial) ||
		(Cls == 'Arachnotron' && Level.bMap07Special) ||
		(Cls == 'Fatso' && Level.bMap07Special) ||
		(Cls == 'Ironlich' && Level.bIronLichSpecial) ||
		(Cls == 'Minotaur' && Level.bMinotaurSpecial) ||
		(Cls == 'Sorcerer2' && Level.bDSparilSpecial)))
	{
		return;
	}

	if (!CheckBossDeath())
	{
		return;
	}

	// victory!
	if (Level.bSpecialActionKillMonsters)
	{
		// Kill any remaining monsters
		LineSpecialLevelInfo(Level).P_Massacre();
	}

	if (Level.bMap07Special)
	{
		if (GetClassName(Class) == 'Fatso')
		{
			Level.ExecuteActionSpecial(LNSPEC_FloorLowerToLowest, 666, 8,
				0, 0, 0, NULL, 0, none);
			return;
		}
		if (GetClassName(Class) == 'Arachnotron')
		{
			Level.ExecuteActionSpecial(LNSPEC_FloorRaiseByTexture, 667, 8,
				0, 0, 0, NULL, 0, none);
			return;
		}
	}
	else if (Level.bSpecialActionOpenDoor)
	{
		Level.ExecuteActionSpecial(LNSPEC_DoorOpen, 666, 64, 150, 0, 0,
			NULL, 0, none);
		return;
	}
	else if (Level.bSpecialActionLowerFloor)
	{
		Level.ExecuteActionSpecial(LNSPEC_FloorLowerToLowest, 666, 8, 0, 0,
			0, NULL, 0, none);
		return;
	}
	Level.ExitLevel(0);
}

//==========================================================================
//
//  A_FreeTargMobj
//
//==========================================================================

final void A_FreeTargMobj()
{
	Velocity = vector(0.0, 0.0, 0.0);
	Origin.z = CeilingZ + 4.0;
	Gravity = 1.0;
	bSolid = false;
	bShootable = false;
	bFloat = false;
	bCountKill = false;
	bMonster = false;
	bSkullFly = false;
	bNoGravity = true;
	bDropOff = true;
	bCorpse = true;
	bNoPassMobj = true;
	RenderStyle = STYLE_None;
	Alpha = 0.0;
	Player = none;
	bIsPlayer = false;
	Health = -1000;	// Don't resurrect
}

//==========================================================================
//
//  A_Metal
//
//  Cyberdemon move with metal sound.
//
//==========================================================================

final void A_Metal()
{
	PlaySound('spider/walk', CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  A_SpidRefire
//
//  Spider mastermind refire.
//
//==========================================================================

final void A_SpidRefire()
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 10)
		return;

	if (!Target || Target.Health <= 0 || !CanSee(Target))
	{
		SetState(SeeState);
	}
}

//===========================================================================
//
//  A_NoGravity
//
//===========================================================================

final void A_NoGravity()
{
	bNoGravity = true;
}

//==========================================================================
//
//  A_SetInvulnerable
//
//==========================================================================

final void A_SetInvulnerable()
{
	bInvulnerable = true;
}

//==========================================================================
//
//  A_UnSetInvulnerable
//
//==========================================================================

final void A_UnSetInvulnerable()
{
	bInvulnerable = false;
}

//==========================================================================
//
//  A_HideThing
//
//==========================================================================

final void A_HideThing()
{
	bHidden = true;
}

//==========================================================================
//
//  A_UnHideThing
//
//==========================================================================

final void A_UnHideThing()
{
	bHidden = false;
}

//==========================================================================
//
//	A_ActiveSound
//
//==========================================================================

final void A_ActiveSound()
{
	if (ActiveSound && !GetSoundPlayingInfo(self, GetSoundID(ActiveSound)))
	{
		PlaySound(ActiveSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_ActiveAndUnblock
//
//	For breakable DECORATE decorations that have only one death state.
//
//==========================================================================

final void A_ActiveAndUnblock()
{
	A_ActiveSound();
	A_NoBlocking();
}

states
{
FreeTargMobj:
	TNT1 A 1050 A_FreeTargMobj
	Stop
}

defaultproperties
{
}
