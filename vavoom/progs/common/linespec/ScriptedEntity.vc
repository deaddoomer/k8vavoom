//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**	Class for Actor state action methods. This will eventually be
//**  renamed to Actor.
//**
//**************************************************************************

class ScriptedEntity : EntityEx
	abstract;

//**************************************************************************
//	Monster AI
//**************************************************************************

//==========================================================================
//
//	A_Look
//
//	Stay in state until a player is sighted or has a goal.
//
//==========================================================================

final void A_Look()
{
	EntityEx	targ;
	Entity		Ent;

	//	Set goal now if appropriate.
	if (Special == LNSPEC_ThingSetGoal && Args[0] == 0)
	{
		int Searcher = -1;
		Goal = none;
		for (Ent = Level.FindMobjFromTID(Args[1], &Searcher); Ent;
			Ent = Level.FindMobjFromTID(Args[1], &Searcher))
		{
			if (!PatrolPoint(Ent))
			{
				continue;
			}
			Goal = PatrolPoint(Ent);
			break;
		}
		Special = 0;
		ReactionTime = itof(Args[2]) + XLevel.Time;
		bChaseGoal = !!Args[3];
	}

	Threshold = 0;	// any shot will wake up
	if (TIDToHate)
	{
		targ = Target;
	}
	else
	{
		targ = EntityEx(Sector->SoundTarget);
		//	If it's dead, don't chase it.
		if (targ && targ.Health <= 0)
		{
			targ = none;
		}
		if (targ && targ.bIsPlayer && PlayerEx(targ.Player).bNoTarget)
		{
			return;
		}
	}

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = -1;
	}

	if (targ && targ.bShootable)
	{
		Target = targ;

		if (bAmbush)
		{
			if (!CanSee(Target))
			{
				if (!LookForPlayers(false))
					return;
			}
		}
	}
	else
	{
		if (!LookForPlayers(bLookAllAround))
			return;
	}

	//	Go into chase state
	//	Don't start chasing after a goal if it isn't time yet.
	if (Target == Goal)
	{
		if (ReactionTime > XLevel.Time)
		{
			Target = none;
		}
	}
	else if (SightSound)
	{
		if (bBoss)
		{
			// Full volume
			PlaySound(SightSound, CHAN_VOICE, 1.0, ATTN_NONE);
		}
		else
		{
			PlaySound(SightSound, CHAN_VOICE);
		}
	}

	if (Target)
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//	A_Look2
//
//==========================================================================

final void A_Look2()
{
	EntityEx	targ;

	Threshold = 0;	// any shot will wake up
	targ = EntityEx(Sector->SoundTarget);

	if (!bNeutral && targ && targ.bShootable)
	{
		if (bFriendly != targ.bFriendly || Level.bNoAllies)
		{
			Target = targ;
			if (!bStandMustSeeTarget || CanSee(targ))
			{
				Threshold = 10;
				SetState(SeeState);
				return;
			}
		}
		else
		{
			if (LookForPlayers(bLookAllAround))
			{
				SetState(SeeState);
				bInCombat = true;
				return;
			}
		}
	}
	if (P_Random() < 30)
	{
		if (!(P_Random() & 1))
			SetState(FindState('LookRight'));
		else
			SetState(FindState('LookLeft'));
	}
	if (!bStanding && P_Random() < 40)
	{
		SetState(FindState('Walk'));
	}
}

//==========================================================================
//
//	A_Wander
//
//==========================================================================

final void A_Wander()
{
	float	delta;

	bInCombat = false;
	if (bStanding)
		return;

	if (Threshold != 0)
	{
		Threshold--;
		return;
	}

	// turn towards movement direction if not there yet
	if (MoveDir < DI_NODIR)
	{
		Angles.yaw = itof(ftoi(Angles.yaw / 45.0)) * 45.0;
		delta = AngleMod180(Angles.yaw - itof(MoveDir) * 45.0);

		if (delta > 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw - 45.0);
		}
		else if (delta < 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw + 45.0);
		}
	}

	if (--MoveCount < 0 || !StepMove())
	{
		RandomChaseDir();
		MoveCount += 5;
	}
}

//==========================================================================
//
//	DoChase
//
//	Actor has a melee attack, so it tries to close as fast as possible
//
//==========================================================================

void DoChase(bool FastChase, state AMeleeState, state AMissileState,
	bool NightmareFast, bool PlayActive, bool DontMove)
{
	float		delta;
	float		dist;
	float		ang;
	float		oldX;
	float		oldY;
	int			oldFloor;

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = -1;
	}

	if (ReactionCount)
	{
		ReactionCount--;
	}

	bInCombat = true;
	//	Modify target threshold.
	if (Threshold)
	{
		if (!Target || Target.Health <= 0)
		{
			Threshold = 0;
		}
		else
		{
			Threshold--;
		}
	}

	if (NightmareFast && Level.Game.fastparm)
	{
		//	Monsters move faster in nightmare mode.
		StateTime *= 0.5;
		if (StateTime < 0.1)
		{
			StateTime = 0.1;
		}
	}

	//	Turn towards movement direction if not there yet.
	// killough 9/7/98: keep facing towards target if strafing or backing out
	if (strafecount)
	{
		A_FaceTarget();
	}
	else
	{
		if (MoveDir < 8)
		{
			Angles.yaw = itof(ftoi(Angles.yaw / 45.0)) * 45.0;
			delta = AngleMod180(Angles.yaw - itof(MoveDir) * 45.0);

			if (delta > 0.0)
			{
				Angles.yaw = AngleMod360(Angles.yaw - 45.0);
			}
			else if (delta < 0.0)
			{
				Angles.yaw = AngleMod360(Angles.yaw + 45.0);
			}
		}
	}

	//	If the target is dead and not a goal, stop chasing it.
	if (Target && Target != Goal && Target.Health <= 0)
	{
		Target = none;
	}

	if (!Target || !Target.bShootable)
	{
		//	Look for a new target.
		if (LookForPlayers(true) && Target != Goal)
		{
			//	Got a new target.
			return;
		}
		if (!Target)
		{
			if (bFriendly)
			{
				A_Look();
				if (!Target)
				{
					if (!DontMove)
					{
						A_Wander();
					}
					return;
				}
			}
			else
			{
				SetState(IdleState);
				bInCombat = false;
				return;
			}
		}
	}

	//	Do not attack twice in a row.
	if (bJustAttacked)
	{
		bJustAttacked = false;
		if (!Level.Game.fastparm && !DontMove)
		{
			NewChaseDir();
		}
		return;
	}

	//	Don't attack if just moving toward goal
	if (Target == Goal || (bChaseGoal && Goal))
	{
		EntityEx SavedTarget = Target;
		Target = Goal;
		bool Result = CheckMeleeRange();
		Target = SavedTarget;

		if (Result)
		{
			// reached the goal

			// Execute the specials of any PatrolSpecials with the same TID
			// as the goal.
			Entity Ent;
			int Searcher = -1;
			for (Ent = Level.FindMobjFromTID(Goal.TID, &Searcher); Ent;
				Ent = Level.FindMobjFromTID(Goal.TID, &Searcher))
			{
				if (!PatrolSpecial(Ent))
				{
					continue;
				}
				Level.ExecuteActionSpecial(Ent.Special, Ent.Args[0],
					Ent.Args[1], Ent.Args[2], Ent.Args[3], Ent.Args[4],
					NULL, 0, self);
			}

			float LastGoalAng = Goal.Angles.yaw;
			int Delay;
			EntityEx NewGoal = none;
			Searcher = -1;
			for (Ent = Level.FindMobjFromTID(Goal.Args[0], &Searcher); Ent;
				Ent = Level.FindMobjFromTID(Goal.Args[0], &Searcher))
			{
				if (!PatrolPoint(Ent))
				{
					continue;
				}
				NewGoal = PatrolPoint(Ent);
				break;
			}
			if (NewGoal && Goal == Target)
			{
				Delay = NewGoal.Args[1];
				ReactionTime = itof(Delay) + XLevel.Time;
			}
			else
			{
				Delay = 0;
				ReactionTime = default.ReactionTime;
				Angles.yaw = LastGoalAng;		// Look in direction of last goal
			}
			if (Target == Goal)
			{
				Target = none;
			}
			bJustAttacked = true;
			if (NewGoal && Delay != 0)
			{
				bInCombat = true;
				SetState(IdleState);
			}
			Goal = NewGoal;
			return;
		}
	}

	if (Goal != Target)
	{
		if (FastChase && !DontMove)
		{
			//	Strafe
			if (FastChaseStrafeCount > 0)
			{
				FastChaseStrafeCount--;
			}
			else
			{
				FastChaseStrafeCount = 0;
				Velocity.x = 0.0;
				Velocity.y = 0.0;
				dist = DistTo(Target);
				if (dist < 640.0)
				{
					if (P_Random() < 100)
					{
						ang = atan2(Target.Origin.y - Origin.y,
							Target.Origin.x - Origin.x);
						if (P_Random() < 128)
							ang = AngleMod360(ang + 90.0);
						else
							ang = AngleMod360(ang - 90.0);
						Velocity.x = 13.0 * cos(ang) * 35.0;
						Velocity.y = 13.0 * sin(ang) * 35.0;
						FastChaseStrafeCount = 3;	// strafe time
					}
				}
			}
		}

		//	Check for melee attack.
		if (AMeleeState && CheckMeleeRange())
		{
			if (AttackSound)
			{
				PlaySound(AttackSound, CHAN_WEAPON);
			}
			SetState(AMeleeState);
			return;
		}

		//	Check for missile attack.
		if (AMissileState)
		{
			if (Level.Game.fastparm || !MoveCount)
			{
				if (CheckMissileRange())
				{
					SetState(AMissileState);
					bJustAttacked = true;
					return;
				}
			}
		}
	}

	//	Possibly choose another target.
	if ((Level.Game.netgame || TIDToHate) && !Threshold)
	{
		if (!CanSee(Target))
		{
			bool PrevNoSightCheck = bNoSightCheck;
			bNoSightCheck = false;
			bool GotNew = LookForPlayers(true);
			bNoSightCheck = PrevNoSightCheck;
			if (GotNew)
			{
				//	Got a new target.
				return;
			}
		}
	}

	if (strafecount)
	{
		strafecount--;
	}

	//	Chase towards player.
	if ((!FastChase || !FastChaseStrafeCount) && !DontMove)
	{
		oldX = Origin.x;
		oldY = Origin.y;
		oldFloor = Sector->floor.pic;
		if (--MoveCount < 0 || !StepMove())
		{
			NewChaseDir();
		}
		if (bCantLeaveFloorpic && Sector->floor.pic != oldFloor)
		{
			TryMove(vector(oldX, oldY, Origin.z));
			NewChaseDir();
		}
	}
	else if (DontMove && MoveCount > 0)
	{
		MoveCount = 0;
	}

	//	Make active sound.
	if (PlayActive && P_Random() < 3)
	{
		PlayActiveSound();
	}
}

//==========================================================================
//
//	A_Chase
//
//==========================================================================

final void A_Chase()
{
	DoChase(false, MeleeState, MissileState,
		LineSpecialGameInfo(Level.Game).bNightmareFastChase, true, false);
}

//==========================================================================
//
//	decorate_A_Chase
//
//==========================================================================

final void decorate_A_Chase(optional state AMeleeState,
	optional state AMissileState, optional int Flags)
{
	if (specified_AMeleeState)
	{
		//FIXME implement flag 8
		DoChase(!!(Flags & 1), AMeleeState, AMissileState, !!(Flags & 4),
			!(Flags & 2), !!(Flags & 16));
	}
	else
	{
		DoChase(false, MeleeState, MissileState,
			LineSpecialGameInfo(Level.Game).bNightmareFastChase, true, false);
	}
}

//============================================================================
//
//  A_FastChase
//
//============================================================================

final void A_FastChase()
{
	DoChase(true, MeleeState, MissileState, true, true, false);
}

//==========================================================================
//
//	A_FaceTarget
//
//==========================================================================

final void A_FaceTarget()
{
	if (!Target)
		return;

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = 1;
	}

	bAmbush = false;

	Angles.yaw = atan2(Target.Origin.y - Origin.y,
		Target.Origin.x - Origin.x);

	if (Target.Alpha < 1.0)
	{
		Angles.yaw = AngleMod360(Angles.yaw + (Random() - Random()) * 45.0);
	}
}

//==========================================================================
//
//	A_AlertMonsters
//
//==========================================================================

final void A_AlertMonsters()
{
	if (Target && Target.bIsPlayer)
	{
		LineSpecialLevelInfo(Level).NoiseAlert(Target, self);
	}
}

//**************************************************************************
//	Generic monster attacks
//**************************************************************************

//==========================================================================
//
//  DoExplode
//
//  Handles a bunch of exploding things.
//
//==========================================================================

final void DoExplode(int damage, float distance, bool damageSelf)
{
	int			i;

	RadiusAttack(Target, damage, distance, damageSelf);
	if (Origin.z <= FloorZ + distance)
	{
		HitFloorType();
	}

	if (bExplodeParticles)
	{
		//  Spawn explosion effects - dynamic light and particles
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (!Level.Game.Players[i])
				continue;
			if (!Level.Game.Players[i].bSpawned)
				continue;
			PlayerEx(Level.Game.Players[i]).ClientParticleExplosion(
				DLightColour, DLightRadius, Origin + vector(0.0, 0.0, Height * 0.5));
		}
	}
	else if (ExplodeEffect)
	{
		SendExplosion(ExplodeEffect, DLightRadius, Origin);
	}

	//  Clear old dynamic light and trail effects
	bDynamicLight = false;
	bLeaveTrail = false;
}

//==========================================================================
//
//  A_Explode
//
//  Handles a bunch of exploding things.
//
//==========================================================================

final void A_Explode()
{
	int			damage;
	float		distance;
	byte		damageSelf;

	damage = 128;
	distance = 128.0;
	damageSelf = true;

	PreExplode();
	GetExplodeParms(damage, distance, damageSelf);

	DoExplode(damage, distance, damageSelf);
}

//==========================================================================
//
//  A_ExplodeAndAlert
//
//==========================================================================

final void A_ExplodeAndAlert()
{
	A_Explode();
	if (Target && Target.bIsPlayer)
	{
		LineSpecialLevelInfo(Level).NoiseAlert(Target, self);
	}
}

//==========================================================================
//
//  A_ExplodeParms
//
//==========================================================================

final void A_ExplodeParms()
{
	int			damage;
	float		distance;
	byte		damageSelf;

	damage = ExplosionDamage;
	distance = itof(ExplosionRadius);
	damageSelf = !bExplosionDontHurtSelf;

	if (!damage)
	{
		damage = 128;
	}
	if (!distance)
	{
		distance = itof(damage);
	}

	DoExplode(damage, distance, damageSelf);
}

//==========================================================================
//
//  decorate_A_Explode
//
//==========================================================================

final void decorate_A_Explode(optional int damage, optional int distance,
	optional bool damageSelf)
{
	if (specified_damage)
	{
		if (!damage)
		{
			damage = 128;
		}
		if (!distance)
		{
			distance = 128;
		}
		if (!specified_damageSelf)
		{
			damageSelf = true;
		}
	}
	else
	{
		damage = ExplosionDamage;
		distance = ExplosionRadius;
		damageSelf = !bExplosionDontHurtSelf;
		if (!damage)
		{
			damage = 128;
		}
		if (!distance)
		{
			distance = damage;
		}
	}

	DoExplode(damage, itof(distance), damageSelf);
}

//**************************************************************************
//	Freeze death functions
//**************************************************************************

//**************************************************************************
//	Sound functions
//**************************************************************************

//==========================================================================
//
//  A_PlaySound
//
//==========================================================================

final void A_PlaySound(string Sound)
{
	PlaySound(StrToName(Sound), CHAN_BODY);
}

//==========================================================================
//
//  A_PlaySoundEx
//
//==========================================================================

final void A_PlaySoundEx(string Sound, string Channel, optional bool Loop,
	optional int Attenuation)
{
	//	Channel
	int Chan;
	if (!stricmp(Channel, "Auto"))
	{
		Chan = CHAN_AUTO;
	}
	else if (!stricmp(Channel, "Weapon"))
	{
		Chan = CHAN_WEAPON;
	}
	else if (!stricmp(Channel, "Voice"))
	{
		Chan = CHAN_VOICE;
	}
	else if (!stricmp(Channel, "Item"))
	{
		Chan = CHAN_ITEM;
	}
	else if (!stricmp(Channel, "Body"))
	{
		Chan = CHAN_BODY;
	}
	else if (!stricmp(Channel, "SoundSlot5"))
	{
		Chan = 5;
	}
	else if (!stricmp(Channel, "SoundSlot6"))
	{
		Chan = 6;
	}
	else if (!stricmp(Channel, "SoundSlot7"))
	{
		Chan = 7;
	}

	//	Attenuation
	float Atten = ATTN_NORMAL;
	switch (Attenuation)
	{
	case -1:
		Atten = ATTN_STATIC;
		break;
	case 1:
		Atten = ATTN_NONE;
		break;
	case 2:
		Atten = ATTN_SURROUND;
		break;
	}

	PlaySound(StrToName(Sound), Chan,, Atten, Loop);
}

//==========================================================================
//
//  A_PlayWeaponSound
//
//==========================================================================

final void A_PlayWeaponSound(string Sound)
{
	PlaySound(StrToName(Sound), CHAN_WEAPON);
}

//==========================================================================
//
//	A_ActiveSound
//
//==========================================================================

final void A_ActiveSound()
{
	if (ActiveSound)
	{
		PlaySound(ActiveSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_LoopActiveSound
//
//==========================================================================

final void A_LoopActiveSound()
{
	if (ActiveSound)
	{
		PlaySound(ActiveSound, CHAN_VOICE,,, true);
	}
}

//==========================================================================
//
//	A_FLoopActiveSound
//
//==========================================================================

final void A_FLoopActiveSound()
{
	if (ActiveSound && !GetSoundPlayingInfo(self, GetSoundID(ActiveSound)))
	{
		PlaySound(ActiveSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_StopSound
//
//==========================================================================

final void A_StopSound()
{
	StopSound(CHAN_VOICE);
}

//==========================================================================
//
//	A_StopSoundEx
//
//==========================================================================

final void A_StopSoundEx(string Channel)
{
	//	Channel
	int Chan;
	if (!stricmp(Channel, "Auto"))
	{
		Chan = CHAN_AUTO;
	}
	else if (!stricmp(Channel, "Weapon"))
	{
		Chan = CHAN_WEAPON;
	}
	else if (!stricmp(Channel, "Voice"))
	{
		Chan = CHAN_VOICE;
	}
	else if (!stricmp(Channel, "Item"))
	{
		Chan = CHAN_ITEM;
	}
	else if (!stricmp(Channel, "Body"))
	{
		Chan = CHAN_BODY;
	}
	else if (!stricmp(Channel, "SoundSlot5"))
	{
		Chan = 5;
	}
	else if (!stricmp(Channel, "SoundSlot6"))
	{
		Chan = 6;
	}
	else if (!stricmp(Channel, "SoundSlot7"))
	{
		Chan = 7;
	}

	StopSound(Chan);
}

//==========================================================================
//
//  A_Pain
//
//==========================================================================

final void A_Pain()
{
	if (bIsPlayer && !PlayerIsMorphed())
	{
		if (Health < 25)
		{
			PlaySound('*pain25', CHAN_VOICE);
		}
		else if (Health < 50)
		{
			PlaySound('*pain50', CHAN_VOICE);
		}
		else if (Health < 75)
		{
			PlaySound('*pain75', CHAN_VOICE);
		}
		else
		{
			PlaySound('*pain100', CHAN_VOICE);
		}
	}
	else if (PainSound)
	{
		PlaySound(PainSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_Scream
//
//  Death sound.
//
//==========================================================================

final void A_Scream()
{
	//  Remove muzzle flash & other light effects
	bDynamicLight = false;

	if (DeathSound)
	{
		// Make boss death sounds full volume
		PlaySound(DeathSound, CHAN_VOICE, 1.0, bBoss ? ATTN_NONE : ATTN_NORMAL);
	}
}

//==========================================================================
//
//	A_XScream
//
//  Explode death sound.
//
//==========================================================================

final void A_XScream()
{
	if (bIsPlayer)
	{
		PlaySound('*gibbed', CHAN_BODY);
	}
	else
	{
		PlaySound('misc/gibbed', CHAN_BODY);
	}
}

//**************************************************************************
//	Special actions
//**************************************************************************

//==========================================================================
//
//  A_BossDeath
//
//  Possibly trigger special effects if on first boss level
//
//==========================================================================

final void A_BossDeath()
{
	name Cls = GetClassName(Class);
	if (!((Cls == 'BaronOfHell' && Level.bBaronSpecial) ||
		(Cls == 'Cyberdemon' && Level.bCyberDemonSpecial) ||
		(Cls == 'SpiderMastermind' && Level.bSpiderMastermindSpecial) ||
		(Cls == 'Arachnotron' && Level.bMap07Special) ||
		(Cls == 'Fatso' && Level.bMap07Special) ||
		(Cls == 'Ironlich' && Level.bIronLichSpecial) ||
		(Cls == 'Minotaur' && Level.bMinotaurSpecial) ||
		(Cls == 'Sorcerer2' && Level.bDSparilSpecial)))
	{
		return;
	}

	if (!CheckBossDeath())
	{
		return;
	}

	// victory!
	if (Level.bSpecialActionKillMonsters)
	{
		// Kill any remaining monsters
		LineSpecialLevelInfo(Level).P_Massacre();
	}

	if (Level.bMap07Special)
	{
		if (GetClassName(Class) == 'Fatso')
		{
			Level.ExecuteActionSpecial(LNSPEC_FloorLowerToLowest, 666, 8,
				0, 0, 0, NULL, 0, none);
			return;
		}
		if (GetClassName(Class) == 'Arachnotron')
		{
			Level.ExecuteActionSpecial(LNSPEC_FloorRaiseByTexture, 667, 8,
				0, 0, 0, NULL, 0, none);
			return;
		}
	}
	else if (Level.bSpecialActionOpenDoor)
	{
		Level.ExecuteActionSpecial(LNSPEC_DoorOpen, 666, 64, 150, 0, 0,
			NULL, 0, none);
		return;
	}
	else if (Level.bSpecialActionLowerFloor)
	{
		Level.ExecuteActionSpecial(LNSPEC_FloorLowerToLowest, 666, 8, 0, 0,
			0, NULL, 0, none);
		return;
	}
	Level.ExitLevel(0);
}

//==========================================================================
//
//	A_CheckTerrain
//
//==========================================================================

final void A_CheckTerrain()
{
	int anglespeed;
	float speed;
	float finean;

	if (Origin.z == GetPlanePointZ(Floor, Origin))
	{
		if ((Sector->special & SECSPEC_BASE_MASK) == SECSPEC_DamageInstantDeath)
		{
			Damage(none, none, 999);
		}
		else if ((Sector->special & SECSPEC_BASE_MASK) == SECSPEC_ScrollCurrent)
		{
			anglespeed = Sector->tag - 100;
			speed = itof(anglespeed % 10) / 16.0 * 35.0;
			finean = itof(anglespeed / 10) * 45.0;
			Velocity.x += speed * cos(finean);
			Velocity.y += speed * sin(finean);
		}
	}
}

//**************************************************************************
//	Spawn functions
//**************************************************************************

//**************************************************************************
//	State jumps
//**************************************************************************

//**************************************************************************
//	Flags and appearance
//**************************************************************************

//==========================================================================
//
//  A_HideThing
//
//==========================================================================

final void A_HideThing()
{
	bInvisible = true;
}

//==========================================================================
//
//  A_UnHideThing
//
//==========================================================================

final void A_UnHideThing()
{
	bInvisible = false;
}

//==========================================================================
//
//  A_SetInvulnerable
//
//==========================================================================

final void A_SetInvulnerable()
{
	bInvulnerable = true;
}

//==========================================================================
//
//  A_UnSetInvulnerable
//
//==========================================================================

final void A_UnSetInvulnerable()
{
	bInvulnerable = false;
}

//===========================================================================
//
//  A_NoGravity
//
//===========================================================================

final void A_NoGravity()
{
	bNoGravity = true;
}

//==========================================================================
//
//  A_NoBlocking
//
//  Unset blocking.
//
//==========================================================================

final void A_NoBlocking()
{
	int					SpeechNum;
	RogueConSpeech*		Speech;
	class<EntityEx>		DropItemType;

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		Alpha = 1.0;
		VisDir = 0;
	}

	// actor is on ground, it can be walked over
	bSolid = false;

	SpeechNum = GetSpeech();
	if (SpeechNum)
	{
		//	Drop stuff as determined by conversation.
		if (SpeechNum < 0)
		{
			Speech = &XLevel.GenericSpeeches[-SpeechNum - 1];
		}
		else
		{
			Speech = &XLevel.LevelSpeeches[SpeechNum - 1];
		}
		DropItemType = LineSpecialLevelInfo(Level).GetClassFromID(Speech->DropItem);
		if (DropItemType)
		{
			DropItem(DropItemType, 0, 1.0);
			return;
		}
	}

	// Check for monsters dropping things
	NoBlockingSet();
}

//==========================================================================
//
//	A_Fall
//
//	For compatibility
//
//==========================================================================

final void A_Fall()
{
	A_NoBlocking();
}

//==========================================================================
//
//	A_ScreamAndUnblock
//
//	For breakable DECORATE decorations that have only one death state.
//
//==========================================================================

final void A_ScreamAndUnblock()
{
	A_Scream();
	A_NoBlocking();
}

//==========================================================================
//
//	A_ActiveAndUnblock
//
//	For breakable DECORATE decorations that have only one death state.
//
//==========================================================================

final void A_ActiveAndUnblock()
{
	A_ActiveSound();
	A_NoBlocking();
}

//==========================================================================
//
//	A_SetShadow
//
//==========================================================================

final void A_SetShadow()
{
	bUnknown2 = true;
	RenderStyle = STYLE_Translucent;
	Alpha = 0.333;
}

//==========================================================================
//
//	A_ClearShadow
//
//==========================================================================

final void A_ClearShadow()
{
	bUnknown2 = false;
	RenderStyle = STYLE_Normal;
	Alpha = 1.0;
}

//**************************************************************************
//	Missile movement
//**************************************************************************

//==========================================================================
//
//	A_CountdownArg
//
//==========================================================================

final void A_CountdownArg(int Index)
{
	if (Index <= 0 || Index > 5)
	{
		return;
	}
	if (!Args[Index - 1]--)
	{
		if (bMissile)
		{
			ExplodeMissile();
		}
		else if (bShootable)
		{
			Damage(none, none, Health);
		}
		else
		{
			SetState(FindState('Death'));
		}
	}
}

//**************************************************************************
//	Inventory functions
//**************************************************************************

//==========================================================================
//
//	DoGiveInventory
//
//==========================================================================

final void DoGiveInventory(class<Inventory> ItemType, int Amount,
	EntityEx Receiver)
{
	if (!Receiver)
	{
		return;
	}

	if (!Amount)
	{
		Amount = 1;
	}
	bool Ret = true;
	if (ItemType)
	{
		Inventory Item = Spawn(ItemType,,,, false);
		if (Health(Item))
		{
			Item.Amount *= Amount;
		}
		else
		{
			Item.Amount = Amount;
		}
		Item.bDropped = true;
		if (!Item.TryPickup(Receiver))
		{
			Item.Destroy();
			Ret = false;
		}
	}
	else
	{
		Ret = false;
	}

	if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = Ret;
	}
}

//==========================================================================
//
//	A_GiveInventory
//
//==========================================================================

final void A_GiveInventory(class<Inventory> ItemType, optional int Amount)
{
	DoGiveInventory(ItemType, Amount, self);
}

//==========================================================================
//
//	A_GiveToTarget
//
//==========================================================================

final void A_GiveToTarget(class<Inventory> ItemType, optional int Amount)
{
	DoGiveInventory(ItemType, Amount, Target);
}

//==========================================================================
//
//	DoTakeInventory
//
//==========================================================================

final void DoTakeInventory(class<Inventory> ItemType, int Amount,
	EntityEx Receiver)
{
	if (!Receiver)
	{
		return;
	}

	if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}

	Inventory Item = Receiver.FindInventory(ItemType);
	if (Item && !HexenArmor(Item))
	{
		if (Item.Amount > 0 && XLevel.StateCall)
		{
			XLevel.StateCall->Result = true;
		}
		if (!Amount || Item.Amount <= Amount)
		{
			if (Item.bKeepDepleted)
			{
				Item.Amount = 0;
			}
			else
			{
				Item.Destroy();
			}
		}
		else
		{
			Item.Amount -= Amount;
		}
	}
}

//==========================================================================
//
//	A_TakeInventory
//
//==========================================================================

final void A_TakeInventory(class<Inventory> ItemType, optional int Amount)
{
	DoTakeInventory(ItemType, Amount, self);
}

//==========================================================================
//
//	A_TakeFromTarget
//
//==========================================================================

final void A_TakeFromTarget(class<Inventory> ItemType, optional int Amount)
{
	DoTakeInventory(ItemType, Amount, Target);
}

//==========================================================================
//
//	A_DropInventory
//
//==========================================================================

final void A_DropInventory(class<Inventory> ItemType)
{
	Inventory Item = FindInventory(ItemType);
	if (Item)
	{
		DropInventory(Item);
	}
}

//==========================================================================
//
//	A_SelectWeapon
//
//==========================================================================

final void A_SelectWeapon(class<Weapon> WeaponType)
{
	if (!bIsPlayer)
	{
		return;
	}

	Weapon Wpn = Weapon(FindInventory(WeaponType));
	if (Wpn)
	{
		if (PlayerEx(Player).ReadyWeapon != Wpn)
		{
			PlayerEx(Player).PendingWeapon = Wpn;
		}
	}
	else if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}
}

//**************************************************************************
//	Weapon functions
//**************************************************************************

//**************************************************************************
//	Weapon attack functions
//**************************************************************************

//**************************************************************************
//	Original Doom/Strife monster attacks
//**************************************************************************

//==========================================================================
//
//  A_SpidRefire
//
//  Spider mastermind refire.
//
//==========================================================================

final void A_SpidRefire()
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 10)
		return;

	if (!Target || Target.Health <= 0 || !CanSee(Target))
	{
		SetState(SeeState);
	}
}

//**************************************************************************
//	Monster specific functions for Doom
//**************************************************************************

//==========================================================================
//
//  A_Metal
//
//  Cyberdemon move with metal sound.
//
//==========================================================================

final void A_Metal()
{
	PlaySound('spider/walk', CHAN_BODY);
	A_Chase();
}

//**************************************************************************
//**************************************************************************

//==========================================================================
//
//  A_XXScream
//
//  Strife version of A_XScream.
//
//==========================================================================

final void A_XXScream()
{
	if (!bNoBlood || !DeathSound)
	{
		A_XScream();
	}
	else
	{
		PlaySound(DeathSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_RemoveForceField
//
//==========================================================================

final void A_RemoveForceField()
{
	int i;
	line_t* line;

	bSpecial = false;
	for (i = 0; i < Sector->linecount; i++)
	{
		line = Sector->lines[i];
		if (line->backsector && line->special == LNSPEC_ForceField)
		{
			line->flags &= ~(ML_BLOCKING|ML_BLOCKEVERYTHING);
			line->special = 0;
			XLevel.Sides[line->sidenum[0]].midtexture = 0;
			XLevel.Sides[line->sidenum[1]].midtexture = 0;
		}
	}
}

//==========================================================================
//
//	A_BeShadowyFoe
//
//==========================================================================

final void A_BeShadowyFoe()
{
	RenderStyle = STYLE_Translucent;
	Alpha = 0.333;
	bFriendly = false;
}

//==========================================================================
//
//  A_FreeTargMobj
//
//==========================================================================

final void A_FreeTargMobj()
{
	Velocity = vector(0.0, 0.0, 0.0);
	Origin.z = CeilingZ + 4.0;
	Gravity = 1.0;
	bSolid = false;
	bShootable = false;
	bFloat = false;
	bCountKill = false;
	bMonster = false;
	bSkullFly = false;
	bNoGravity = true;
	bDropOff = true;
	bCorpse = true;
	bPassMobj = false;
	RenderStyle = STYLE_None;
	Alpha = 0.0;
	Player = none;
	bIsPlayer = false;
	Health = -1000;	// Don't resurrect
}

//==========================================================================
//
//  A_ExecActionSpecial
//
//==========================================================================

final void A_ExecActionSpecial(int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5, int Special)
{
	Level.ExecuteActionSpecial(Special, Arg1, Arg2, Arg3, Arg4, Arg5, NULL,
		0, self);

}

states
{
FreeTargMobj:
	TNT1 A 1050 A_FreeTargMobj
	Stop
}

defaultproperties
{
}
