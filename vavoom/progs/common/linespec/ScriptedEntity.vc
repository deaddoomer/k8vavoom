//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**	Class for Actor state action methods. This will eventually be
//**  renamed to Actor.
//**
//**************************************************************************

class ScriptedEntity : EntityEx
	abstract;

//==========================================================================
//
//	Destroyed
//
//==========================================================================

void Destroyed()
{
	// Remove from creature queue
	if (bMonster && bCorpse)
	{
		A_DeQueueCorpse();
	}

	::Destroyed();
}

//**************************************************************************
//	Monster AI
//**************************************************************************

//==========================================================================
//
//	A_Look
//
//	Stay in state until a player is sighted or has a goal.
//
//==========================================================================

final void A_Look()
{
	EntityEx	targ;
	Entity		Ent;

	//	Set goal now if appropriate.
	if (Special == LNSPEC_ThingSetGoal && Args[0] == 0)
	{
		int Searcher = -1;
		Goal = none;
		for (Ent = Level.FindMobjFromTID(Args[1], &Searcher); Ent;
			Ent = Level.FindMobjFromTID(Args[1], &Searcher))
		{
			if (!PatrolPoint(Ent))
			{
				continue;
			}
			Goal = PatrolPoint(Ent);
			break;
		}
		Special = 0;
		ReactionTime = itof(Args[2]) + XLevel.Time;
		bChaseGoal = !!Args[3];
	}

	Threshold = 0;	// any shot will wake up
	if (TIDToHate)
	{
		targ = Target;
	}
	else
	{
		targ = EntityEx(Sector->SoundTarget);
		//	If it's dead, don't chase it.
		if (targ && targ.Health <= 0)
		{
			targ = none;
		}
		if (targ && targ.bIsPlayer && PlayerEx(targ.Player).bNoTarget)
		{
			return;
		}
	}

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = -1;
	}

	if (targ && targ.bShootable)
	{
		Target = targ;

		if (bAmbush)
		{
			if (!CanSee(Target))
			{
				if (!LookForPlayers(false))
					return;
			}
		}
	}
	else
	{
		if (!LookForPlayers(bLookAllAround))
			return;
	}

	//	Go into chase state
	//	Don't start chasing after a goal if it isn't time yet.
	if (Target == Goal)
	{
		if (ReactionTime > XLevel.Time)
		{
			Target = none;
		}
	}
	else if (SightSound)
	{
		if (bBoss)
		{
			// Full volume
			PlaySound(SightSound, CHAN_VOICE, 1.0, ATTN_NONE);
		}
		else
		{
			PlaySound(SightSound, CHAN_VOICE);
		}
	}

	if (Target)
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//	A_Look2
//
//==========================================================================

final void A_Look2()
{
	EntityEx	targ;

	Threshold = 0;	// any shot will wake up
	targ = EntityEx(Sector->SoundTarget);

	if (!bNeutral && targ && targ.bShootable)
	{
		if (bFriendly != targ.bFriendly || Level.bNoAllies)
		{
			Target = targ;
			if (!bStandMustSeeTarget || CanSee(targ))
			{
				Threshold = 10;
				SetState(SeeState);
				return;
			}
		}
		else
		{
			if (LookForPlayers(bLookAllAround))
			{
				SetState(SeeState);
				bInCombat = true;
				return;
			}
		}
	}
	if (P_Random() < 30)
	{
		if (!(P_Random() & 1))
			SetState(FindState('LookRight'));
		else
			SetState(FindState('LookLeft'));
	}
	if (!bStanding && P_Random() < 40)
	{
		SetState(FindState('Walk'));
	}
}

//==========================================================================
//
//	A_TurretLook
//
//	Stay in state untill alarm is triggered.
//
//==========================================================================

final void A_TurretLook()
{
	EntityEx targ;
	int sound;

	Threshold = 0;
	targ = EntityEx(Sector->SoundTarget);
	if (targ && targ.bShootable)
	{
		Target = targ;
		// go into chase state
		if (SightSound)
		{
			PlaySound(SightSound, CHAN_VOICE);
		}
		Threshold = 10;
		SetState(SeeState);
	}
}

//==========================================================================
//
//	A_Wander
//
//==========================================================================

final void A_Wander()
{
	float	delta;

	bInCombat = false;
	if (bStanding)
		return;

	if (Threshold != 0)
	{
		Threshold--;
		return;
	}

	// turn towards movement direction if not there yet
	if (MoveDir < DI_NODIR)
	{
		Angles.yaw = itof(ftoi(Angles.yaw / 45.0)) * 45.0;
		delta = AngleMod180(Angles.yaw - itof(MoveDir) * 45.0);

		if (delta > 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw - 45.0);
		}
		else if (delta < 0.0)
		{
			Angles.yaw = AngleMod360(Angles.yaw + 45.0);
		}
	}

	if (--MoveCount < 0 || !StepMove())
	{
		RandomChaseDir();
		MoveCount += 5;
	}
}

//==========================================================================
//
//	DoChase
//
//	Actor has a melee attack, so it tries to close as fast as possible
//
//==========================================================================

void DoChase(bool FastChase, state AMeleeState, state AMissileState,
	bool NightmareFast, bool PlayActive, bool DontMove)
{
	float		delta;
	float		dist;
	float		ang;
	float		oldX;
	float		oldY;
	int			oldFloor;

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = -1;
	}

	if (ReactionCount)
	{
		ReactionCount--;
	}

	bInCombat = true;
	//	Modify target threshold.
	if (Threshold)
	{
		if (!Target || Target.Health <= 0)
		{
			Threshold = 0;
		}
		else
		{
			Threshold--;
		}
	}

	if (NightmareFast && Level.Game.fastparm)
	{
		//	Monsters move faster in nightmare mode.
		StateTime *= 0.5;
		if (StateTime < 0.1)
		{
			StateTime = 0.1;
		}
	}

	//	Turn towards movement direction if not there yet.
	// killough 9/7/98: keep facing towards target if strafing or backing out
	if (strafecount)
	{
		A_FaceTarget();
	}
	else
	{
		if (MoveDir < 8)
		{
			Angles.yaw = itof(ftoi(Angles.yaw / 45.0)) * 45.0;
			delta = AngleMod180(Angles.yaw - itof(MoveDir) * 45.0);

			if (delta > 0.0)
			{
				Angles.yaw = AngleMod360(Angles.yaw - 45.0);
			}
			else if (delta < 0.0)
			{
				Angles.yaw = AngleMod360(Angles.yaw + 45.0);
			}
		}
	}

	//	If the target is dead and not a goal, stop chasing it.
	if (Target && Target != Goal && Target.Health <= 0)
	{
		Target = none;
	}

	if (!Target || !Target.bShootable)
	{
		//	Look for a new target.
		if (LookForPlayers(true) && Target != Goal)
		{
			//	Got a new target.
			return;
		}
		if (!Target)
		{
			if (bFriendly)
			{
				A_Look();
				if (!Target)
				{
					if (!DontMove)
					{
						A_Wander();
					}
					return;
				}
			}
			else
			{
				SetState(IdleState);
				bInCombat = false;
				return;
			}
		}
	}

	//	Do not attack twice in a row.
	if (bJustAttacked)
	{
		bJustAttacked = false;
		if (!Level.Game.fastparm && !DontMove)
		{
			NewChaseDir();
		}
		return;
	}

	//	Don't attack if just moving toward goal
	if (Target == Goal || (bChaseGoal && Goal))
	{
		EntityEx SavedTarget = Target;
		Target = Goal;
		bool Result = CheckMeleeRange();
		Target = SavedTarget;

		if (Result)
		{
			// reached the goal

			// Execute the specials of any PatrolSpecials with the same TID
			// as the goal.
			Entity Ent;
			int Searcher = -1;
			for (Ent = Level.FindMobjFromTID(Goal.TID, &Searcher); Ent;
				Ent = Level.FindMobjFromTID(Goal.TID, &Searcher))
			{
				if (!PatrolSpecial(Ent))
				{
					continue;
				}
				Level.ExecuteActionSpecial(Ent.Special, Ent.Args[0],
					Ent.Args[1], Ent.Args[2], Ent.Args[3], Ent.Args[4],
					NULL, 0, self);
			}

			float LastGoalAng = Goal.Angles.yaw;
			int Delay;
			EntityEx NewGoal = none;
			Searcher = -1;
			for (Ent = Level.FindMobjFromTID(Goal.Args[0], &Searcher); Ent;
				Ent = Level.FindMobjFromTID(Goal.Args[0], &Searcher))
			{
				if (!PatrolPoint(Ent))
				{
					continue;
				}
				NewGoal = PatrolPoint(Ent);
				break;
			}
			if (NewGoal && Goal == Target)
			{
				Delay = NewGoal.Args[1];
				ReactionTime = itof(Delay) + XLevel.Time;
			}
			else
			{
				Delay = 0;
				ReactionTime = default.ReactionTime;
				Angles.yaw = LastGoalAng;		// Look in direction of last goal
			}
			if (Target == Goal)
			{
				Target = none;
			}
			bJustAttacked = true;
			if (NewGoal && Delay != 0)
			{
				bInCombat = true;
				SetState(IdleState);
			}
			Goal = NewGoal;
			return;
		}
	}

	if (Goal != Target)
	{
		if (FastChase && !DontMove)
		{
			//	Strafe
			if (FastChaseStrafeCount > 0)
			{
				FastChaseStrafeCount--;
			}
			else
			{
				FastChaseStrafeCount = 0;
				Velocity.x = 0.0;
				Velocity.y = 0.0;
				dist = DistTo(Target);
				if (dist < 640.0)
				{
					if (P_Random() < 100)
					{
						ang = atan2(Target.Origin.y - Origin.y,
							Target.Origin.x - Origin.x);
						if (P_Random() < 128)
							ang = AngleMod360(ang + 90.0);
						else
							ang = AngleMod360(ang - 90.0);
						Velocity.x = 13.0 * cos(ang) * 35.0;
						Velocity.y = 13.0 * sin(ang) * 35.0;
						FastChaseStrafeCount = 3;	// strafe time
					}
				}
			}
		}

		//	Check for melee attack.
		if (AMeleeState && CheckMeleeRange())
		{
			if (AttackSound)
			{
				PlaySound(AttackSound, CHAN_WEAPON);
			}
			SetState(AMeleeState);
			return;
		}

		//	Check for missile attack.
		if (AMissileState)
		{
			if (Level.Game.fastparm || !MoveCount)
			{
				if (CheckMissileRange())
				{
					SetState(AMissileState);
					bJustAttacked = true;
					return;
				}
			}
		}
	}

	//	Possibly choose another target.
	if ((Level.Game.netgame || TIDToHate) && !Threshold)
	{
		if (!CanSee(Target))
		{
			bool PrevNoSightCheck = bNoSightCheck;
			bNoSightCheck = false;
			bool GotNew = LookForPlayers(true);
			bNoSightCheck = PrevNoSightCheck;
			if (GotNew)
			{
				//	Got a new target.
				return;
			}
		}
	}

	if (strafecount)
	{
		strafecount--;
	}

	//	Chase towards player.
	if ((!FastChase || !FastChaseStrafeCount) && !DontMove)
	{
		oldX = Origin.x;
		oldY = Origin.y;
		oldFloor = Sector->floor.pic;
		if (--MoveCount < 0 || !StepMove())
		{
			NewChaseDir();
		}
		if (bCantLeaveFloorpic && Sector->floor.pic != oldFloor)
		{
			TryMove(vector(oldX, oldY, Origin.z));
			NewChaseDir();
		}
	}
	else if (DontMove && MoveCount > 0)
	{
		MoveCount = 0;
	}

	//	Make active sound.
	if (PlayActive && P_Random() < 3)
	{
		PlayActiveSound();
	}
}

//==========================================================================
//
//  CheckForResurrect
//
//  Check for ressurecting a body.
//
//==========================================================================

final bool CheckForResurrect(bool UseVileStates)
{
	float viletryx;
	float viletryy;
	Entity Other;

	if (MoveDir != DI_NODIR)
	{
		// check for corpses to raise
		viletryx = Origin.x + Speed / 35.0 * LineSpecialGameInfo(Level.Game).xspeed[MoveDir];
		viletryy = Origin.y + Speed / 35.0 * LineSpecialGameInfo(Level.Game).yspeed[MoveDir];

		//	For all things in radius check whether object is a corpse
		// that can be raised.
		foreach RadiusThings(Other, vector(viletryx, viletryy, 0.0), MAXRADIUS)
		{
			//  Detect a corpse that could be raised.
			float maxdist;
			bool check;

			if (!Other.bCorpse)
			{
				continue;	// not a monster
			}

			if (Other.StateTime != -1.0)
			{
				continue;	// not lying still yet
			}

			state RaiseState = Other.FindState('Raise');
			if (!RaiseState)
			{
				continue;	// monster doesn't have a raise state
			}

			maxdist = Other.Radius + Radius;

			if (fabs(Other.Origin.x - viletryx) > maxdist ||
				fabs(Other.Origin.y - viletryy) > maxdist)
			{
				continue;	// not actually touching
			}

			if (!CanSee(Other))
			{
				continue;	//  Con't see, possibly in other region
			}

			EntityEx CorpseHit = EntityEx(Other);
			CorpseHit.Velocity.x = 0.0;
			CorpseHit.Velocity.y = 0.0;
			float OldHeight = CorpseHit.Height;
			bool OldSolid = CorpseHit.bSolid;
			CorpseHit.bSolid = true;
			CorpseHit.Height = CorpseHit.default.Height;
			check = CorpseHit.CheckPosition(CorpseHit.Origin);
			CorpseHit.bSolid = OldSolid;
			CorpseHit.Height = OldHeight;

			if (!check)
			{
				continue;	// doesn't fit here
			}

			// got one!
			EntityEx temp = Target;
			Target = CorpseHit;
			A_FaceTarget();
			Target = temp;

			//	Enter heal state.
			state HealState = FindState('Heal');
			if (!HealState && UseVileStates)
			{
				//	For DeHackEd compatibility use Arch-vile heal states if
				// this one doesn't have it's own.
				HealState = FindClassState(Archvile, 'Heal');
			}
			if (HealState)
			{
				SetState(HealState);
			}
			CorpseHit.PlaySound('vile/raise', CHAN_BODY);

			CorpseHit.SetState(RaiseState);
			CorpseHit.Height = CorpseHit.default.Height;
			CorpseHit.bShootable = true;
			CorpseHit.bFloat = CorpseHit.default.bFloat;
			CorpseHit.bNoGravity = CorpseHit.default.bNoGravity;
			CorpseHit.bDropOff = false;
			CorpseHit.bSolid = true;
			CorpseHit.bCorpse = false;
			CorpseHit.Health = CorpseHit.default.Health;
			CorpseHit.Target = none;
			CorpseHit.LastEnemy = none;
			return true;
		}
	}
	return false;
}

//==========================================================================
//
//	A_Chase
//
//==========================================================================

final void A_Chase()
{
	DoChase(false, MeleeState, MissileState,
		LineSpecialGameInfo(Level.Game).bNightmareFastChase, true, false);
}

//==========================================================================
//
//	decorate_A_Chase
//
//==========================================================================

final void decorate_A_Chase(optional state AMeleeState,
	optional state AMissileState, optional int Flags)
{
	if (specified_AMeleeState)
	{
		if ((Flags & 8) && CheckForResurrect(false))
		{
			return;
		}
		DoChase(!!(Flags & 1), AMeleeState, AMissileState, !!(Flags & 4),
			!(Flags & 2), !!(Flags & 16));
	}
	else
	{
		DoChase(false, MeleeState, MissileState,
			LineSpecialGameInfo(Level.Game).bNightmareFastChase, true, false);
	}
}

//============================================================================
//
//  A_FastChase
//
//============================================================================

final void A_FastChase()
{
	DoChase(true, MeleeState, MissileState, true, true, false);
}

//==========================================================================
//
//  A_VileChase
//
//==========================================================================

final void A_VileChase()
{
	if (!CheckForResurrect(true))
	{
		// Return to normal attack.
		A_Chase();
	}
}

//==========================================================================
//
//	A_FaceTarget
//
//==========================================================================

final void A_FaceTarget()
{
	if (!Target)
		return;

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = 1;
	}

	bAmbush = false;

	Angles.yaw = atan2(Target.Origin.y - Origin.y,
		Target.Origin.x - Origin.x);

	if (Target.bShadow)
	{
		Angles.yaw = AngleMod360(Angles.yaw + (Random() - Random()) * 45.0);
	}
}

//==========================================================================
//
//	A_CentaurDefend
//
//==========================================================================

final void A_CentaurDefend()
{
	A_FaceTarget();
	if (CheckMeleeRange() && Random() < 0.125)
	{
		A_UnSetInvulnerable();
		SetState(MeleeState);
	}
}

//==========================================================================
//
//	A_AlertMonsters
//
//==========================================================================

final void A_AlertMonsters()
{
	if (Target && Target.bIsPlayer)
	{
		LineSpecialLevelInfo(Level).NoiseAlert(Target, self);
	}
}

//==========================================================================
//
//	A_ClearSoundTarget
//
//==========================================================================

final void A_ClearSoundTarget()
{
	Sector->SoundTarget = none;
}

//==========================================================================
//
//	A_SentinelBob
//
//==========================================================================

final void A_SentinelBob()
{
	float minz, maxz;

	if (bInFloat)
	{
		Velocity.z = 0.0;
		return;
	}

	if (Threshold)
		return;

	maxz = CeilingZ - Height - 16.0;
	minz = FloorZ + 96.0;
	if (minz > maxz)
	{
		minz = maxz;
	}

	if (minz < Origin.z)
	{
		Velocity.z -= 1.0 * 35.0;
	}
	else
	{
		Velocity.z += 1.0 * 35.0;
	}
	ReactionCount = (minz >= Origin.z) ? 4 : 0;
}

//**************************************************************************
//	Generic monster attacks
//**************************************************************************

//==========================================================================
//
//  DoExplode
//
//  Handles a bunch of exploding things.
//
//==========================================================================

final void DoExplode(int damage, float distance, bool damageSelf)
{
	int			i;

	RadiusAttack(Target, damage, distance, damageSelf);
	if (Origin.z <= FloorZ + distance)
	{
		HitFloorType();
	}

	if (bExplodeParticles)
	{
		//  Spawn explosion effects - dynamic light and particles
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (!Level.Game.Players[i])
				continue;
			if (!Level.Game.Players[i].bSpawned)
				continue;
			PlayerEx(Level.Game.Players[i]).ClientParticleExplosion(
				DLightColour, DLightRadius, Origin + vector(0.0, 0.0, Height * 0.5));
		}
	}
	else if (ExplodeEffect)
	{
		SendExplosion(ExplodeEffect, DLightRadius, Origin);
	}

	//  Clear old dynamic light and trail effects
	bDynamicLight = false;
	bLeaveTrail = false;
}

//==========================================================================
//
//  A_Explode
//
//  Handles a bunch of exploding things.
//
//==========================================================================

final void A_Explode()
{
	int			damage;
	float		distance;
	byte		damageSelf;

	damage = 128;
	distance = 128.0;
	damageSelf = true;

	PreExplode();
	GetExplodeParms(damage, distance, damageSelf);

	DoExplode(damage, distance, damageSelf);
}

//==========================================================================
//
//  A_ExplodeAndAlert
//
//==========================================================================

final void A_ExplodeAndAlert()
{
	A_Explode();
	if (Target && Target.bIsPlayer)
	{
		LineSpecialLevelInfo(Level).NoiseAlert(Target, self);
	}
}

//==========================================================================
//
//  A_ExplodeParms
//
//==========================================================================

final void A_ExplodeParms()
{
	int			damage;
	float		distance;
	byte		damageSelf;

	damage = ExplosionDamage;
	distance = itof(ExplosionRadius);
	damageSelf = !bExplosionDontHurtSelf;

	if (!damage)
	{
		damage = 128;
	}
	if (!distance)
	{
		distance = itof(damage);
	}

	DoExplode(damage, distance, damageSelf);
}

//==========================================================================
//
//  decorate_A_Explode
//
//==========================================================================

final void decorate_A_Explode(optional int damage, optional int distance,
	optional bool damageSelf)
{
	if (specified_damage)
	{
		if (!damage)
		{
			damage = 128;
		}
		if (!distance)
		{
			distance = 128;
		}
		if (!specified_damageSelf)
		{
			damageSelf = true;
		}
	}
	else
	{
		damage = ExplosionDamage;
		distance = ExplosionRadius;
		damageSelf = !bExplosionDontHurtSelf;
		if (!damage)
		{
			damage = 128;
		}
		if (!distance)
		{
			distance = damage;
		}
	}

	DoExplode(damage, itof(distance), damageSelf);
}

//**************************************************************************
//	Freeze death functions
//**************************************************************************

//**************************************************************************
//	Sound functions
//**************************************************************************

//==========================================================================
//
//  A_PlaySound
//
//==========================================================================

final void A_PlaySound(string Sound)
{
	PlaySound(StrToName(Sound), CHAN_BODY);
}

//==========================================================================
//
//  A_PlaySoundEx
//
//==========================================================================

final void A_PlaySoundEx(string Sound, string Channel, optional bool Loop,
	optional int Attenuation)
{
	//	Channel
	int Chan;
	if (!stricmp(Channel, "Auto"))
	{
		Chan = CHAN_AUTO;
	}
	else if (!stricmp(Channel, "Weapon"))
	{
		Chan = CHAN_WEAPON;
	}
	else if (!stricmp(Channel, "Voice"))
	{
		Chan = CHAN_VOICE;
	}
	else if (!stricmp(Channel, "Item"))
	{
		Chan = CHAN_ITEM;
	}
	else if (!stricmp(Channel, "Body"))
	{
		Chan = CHAN_BODY;
	}
	else if (!stricmp(Channel, "SoundSlot5"))
	{
		Chan = 5;
	}
	else if (!stricmp(Channel, "SoundSlot6"))
	{
		Chan = 6;
	}
	else if (!stricmp(Channel, "SoundSlot7"))
	{
		Chan = 7;
	}

	//	Attenuation
	float Atten = ATTN_NORMAL;
	switch (Attenuation)
	{
	case -1:
		Atten = ATTN_STATIC;
		break;
	case 1:
		Atten = ATTN_NONE;
		break;
	case 2:
		Atten = ATTN_SURROUND;
		break;
	}

	PlaySound(StrToName(Sound), Chan,, Atten, Loop);
}

//==========================================================================
//
//  A_PlayWeaponSound
//
//==========================================================================

final void A_PlayWeaponSound(string Sound)
{
	PlaySound(StrToName(Sound), CHAN_WEAPON);
}

//==========================================================================
//
//	A_ActiveSound
//
//==========================================================================

final void A_ActiveSound()
{
	if (ActiveSound)
	{
		PlaySound(ActiveSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_LoopActiveSound
//
//==========================================================================

final void A_LoopActiveSound()
{
	if (ActiveSound)
	{
		PlaySound(ActiveSound, CHAN_VOICE,,, true);
	}
}

//==========================================================================
//
//	A_FLoopActiveSound
//
//==========================================================================

final void A_FLoopActiveSound()
{
	if (ActiveSound && !GetSoundPlayingInfo(self, GetSoundID(ActiveSound)))
	{
		PlaySound(ActiveSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_StopSound
//
//==========================================================================

final void A_StopSound()
{
	StopSound(CHAN_VOICE);
}

//==========================================================================
//
//	A_StopSoundEx
//
//==========================================================================

final void A_StopSoundEx(string Channel)
{
	//	Channel
	int Chan;
	if (!stricmp(Channel, "Auto"))
	{
		Chan = CHAN_AUTO;
	}
	else if (!stricmp(Channel, "Weapon"))
	{
		Chan = CHAN_WEAPON;
	}
	else if (!stricmp(Channel, "Voice"))
	{
		Chan = CHAN_VOICE;
	}
	else if (!stricmp(Channel, "Item"))
	{
		Chan = CHAN_ITEM;
	}
	else if (!stricmp(Channel, "Body"))
	{
		Chan = CHAN_BODY;
	}
	else if (!stricmp(Channel, "SoundSlot5"))
	{
		Chan = 5;
	}
	else if (!stricmp(Channel, "SoundSlot6"))
	{
		Chan = 6;
	}
	else if (!stricmp(Channel, "SoundSlot7"))
	{
		Chan = 7;
	}

	StopSound(Chan);
}

//==========================================================================
//
//  A_Pain
//
//==========================================================================

final void A_Pain()
{
	if (bIsPlayer && !PlayerIsMorphed())
	{
		if (Health < 25)
		{
			PlaySound('*pain25', CHAN_VOICE);
		}
		else if (Health < 50)
		{
			PlaySound('*pain50', CHAN_VOICE);
		}
		else if (Health < 75)
		{
			PlaySound('*pain75', CHAN_VOICE);
		}
		else
		{
			PlaySound('*pain100', CHAN_VOICE);
		}
	}
	else if (PainSound)
	{
		PlaySound(PainSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_Scream
//
//  Death sound.
//
//==========================================================================

final void A_Scream()
{
	//  Remove muzzle flash & other light effects
	bDynamicLight = false;

	if (DeathSound)
	{
		// Make boss death sounds full volume
		PlaySound(DeathSound, CHAN_VOICE, 1.0, bBoss ? ATTN_NONE : ATTN_NORMAL);
	}
}

//==========================================================================
//
//	A_XScream
//
//  Explode death sound.
//
//==========================================================================

final void A_XScream()
{
	if (bIsPlayer)
	{
		PlaySound('*gibbed', CHAN_BODY);
	}
	else
	{
		PlaySound('misc/gibbed', CHAN_BODY);
	}
}

//==========================================================================
//
//  A_VileStart
//
//  Arch-vile attack start sound.
//
//==========================================================================

final void A_VileStart()
{
	PlaySound('vile/start', CHAN_WEAPON);
}

//==========================================================================
//
//  A_BrainPain
//
//  Brain pain sound.
//
//==========================================================================

final void A_BrainPain()
{
	PlaySound('brain/pain', CHAN_VOICE, 1.0, ATTN_NONE);
}

//==========================================================================
//
//  A_BrainAwake
//
//  Init boss spawner.
//
//==========================================================================

final void A_BrainAwake()
{
	//	Do just a sound, like in Boom.
	PlaySound('brain/sight', CHAN_VOICE, 1.0, ATTN_NONE);
}

//==========================================================================
//
//  A_PlayerScream
//
//==========================================================================

final void A_PlayerScream()
{
	if (!bIsPlayer || DeathSound)
	{
		PlaySound(DeathSound, CHAN_VOICE);
		return;
	}

	name Sound;
	int Chan = CHAN_VOICE;

	// Handle the different player death screams
	if ((Level.bFallingDamage || Level.bOldFallingDamage ||
		Level.bStrifeFallingDamage) && Velocity.z <= -39.0 * 35.0 &&
		IsSoundPresent('*splat'))
	{
		// Falling splat
		Sound = '*splat';
		Chan = CHAN_BODY;
	}
	if (!Sound && Special1 < 10 && IsSoundPresent('*wimpydeath'))
	{
		// Wimpy death sound
		Sound = '*wimpydeath';
	}
	if (!Sound && Health <= -50)
	{
		if (Health > -100 && IsSoundPresent('*crazydeath'))
		{
			// Crazy death sound
			Sound = '*crazydeath';
		}
		if (!Sound && IsSoundPresent('*xdeath'))
		{
			// Extreme death sound
			Sound = '*xdeath';
		}
		if (!Sound && IsSoundPresent('*gibbed'))
		{
			// Extreme death sound
			Sound = '*gibbed';
			Chan = CHAN_BODY;
		}
	}
	if (!Sound)
	{
		// Normal death sound
		Sound = '*death';
	}

	PlaySound(Sound, Chan);
}

//**************************************************************************
//	Special actions
//**************************************************************************

//==========================================================================
//
//  A_BossDeath
//
//  Possibly trigger special effects if on first boss level
//
//==========================================================================

final void A_BossDeath()
{
	name Cls = GetClassName(Class);
	if (!((Cls == 'BaronOfHell' && Level.bBaronSpecial) ||
		(Cls == 'Cyberdemon' && Level.bCyberDemonSpecial) ||
		(Cls == 'SpiderMastermind' && Level.bSpiderMastermindSpecial) ||
		(Cls == 'Arachnotron' && Level.bMap07Special) ||
		(Cls == 'Fatso' && Level.bMap07Special) ||
		(Cls == 'Ironlich' && Level.bIronLichSpecial) ||
		(Cls == 'Minotaur' && Level.bMinotaurSpecial) ||
		(Cls == 'Sorcerer2' && Level.bDSparilSpecial)))
	{
		return;
	}

	if (!CheckBossDeath())
	{
		return;
	}

	// victory!
	if (Level.bSpecialActionKillMonsters)
	{
		// Kill any remaining monsters
		LineSpecialLevelInfo(Level).P_Massacre();
	}

	if (Level.bMap07Special)
	{
		if (GetClassName(Class) == 'Fatso')
		{
			Level.ExecuteActionSpecial(LNSPEC_FloorLowerToLowest, 666, 8,
				0, 0, 0, NULL, 0, none);
			return;
		}
		if (GetClassName(Class) == 'Arachnotron')
		{
			Level.ExecuteActionSpecial(LNSPEC_FloorRaiseByTexture, 667, 8,
				0, 0, 0, NULL, 0, none);
			return;
		}
	}
	else if (Level.bSpecialActionOpenDoor)
	{
		Level.ExecuteActionSpecial(LNSPEC_DoorOpen, 666, 64, 150, 0, 0,
			NULL, 0, none);
		return;
	}
	else if (Level.bSpecialActionLowerFloor)
	{
		Level.ExecuteActionSpecial(LNSPEC_FloorLowerToLowest, 666, 8, 0, 0,
			0, NULL, 0, none);
		return;
	}
	Level.ExitLevel(0);
}

//==========================================================================
//
//  A_KeenDie
//
//  DOOM II special, map 32. Uses special tag 666.
//
//==========================================================================

final void A_KeenDie()
{
	EntityEx		Other;

	A_Fall();

	// scan the remaining thinkers to see if all Keens are dead
	foreach AllThinkers(class<Thinker>(Class), Other)
	{
		if (Other != self && Other.Health > 0)
		{
			// other mobj of the same Class not dead
			return;
		}
	}
	Level.ExecuteActionSpecial(LNSPEC_DoorOpen, 666, 16, 150, 0, 0, NULL, 0,
		none);
}

//==========================================================================
//
//  A_BrainDie
//
//  Killed brain, exit level.
//
//==========================================================================

final void A_BrainDie()
{
	Level.ExitLevel(0);
}

//==========================================================================
//
//	A_GetHurt
//
//==========================================================================

final void A_GetHurt()
{
	bInCombat = true;
	if ((P_Random() % 5) == 0)
	{
		PlaySound(PainSound, CHAN_VOICE);
		Health--;
	}
	if (Health <= 0)
	{
		Died(Target, none);
	}
}

//==========================================================================
//
//	A_KlaxonBlare
//
//==========================================================================

final void A_KlaxonBlare()
{
	ReactionCount--;
	if (ReactionCount <= 0)
	{
		Target = none;
		ReactionCount = 60;
		if (Target == none)
		{
			SetState(IdleState);
		}
	}
	if (ReactionCount == 2)
	{
		// Should make enemies go to Idle state again
		LineSpecialLevelInfo(Level).NoiseAlert(none, self);
	}
	else if (ReactionCount > 50)
	{
		PlaySound('misc/alarm', CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_CheckTerrain
//
//==========================================================================

final void A_CheckTerrain()
{
	int anglespeed;
	float speed;
	float finean;

	if (Origin.z == GetPlanePointZ(Floor, Origin))
	{
		if ((Sector->special & SECSPEC_BASE_MASK) == SECSPEC_DamageInstantDeath)
		{
			Damage(none, none, 999);
		}
		else if ((Sector->special & SECSPEC_BASE_MASK) == SECSPEC_ScrollCurrent)
		{
			anglespeed = Sector->tag - 100;
			speed = itof(anglespeed % 10) / 16.0 * 35.0;
			finean = itof(anglespeed / 10) * 45.0;
			Velocity.x += speed * cos(finean);
			Velocity.y += speed * sin(finean);
		}
	}
}

//============================================================================
//
//  A_CheckPlayerDone
//
//============================================================================

final void A_CheckPlayerDone()
{
	if (!bIsPlayer)
	{
		Destroy();
	}
}

//**************************************************************************
//	Spawn functions
//**************************************************************************

//**************************************************************************
//	State jumps
//**************************************************************************

//**************************************************************************
//	Flags and appearance
//**************************************************************************

//==========================================================================
//
//  A_SetFloorClip
//
//==========================================================================

final void A_SetFloorClip()
{
	bFloorClip = true;
	HandleFloorclip();
}

//==========================================================================
//
//  A_UnSetFloorClip
//
//==========================================================================

final void A_UnSetFloorClip()
{
	bFloorClip = false;
	FloorClip = 0.0;
}

//==========================================================================
//
//  A_HideThing
//
//==========================================================================

final void A_HideThing()
{
	bInvisible = true;
}

//==========================================================================
//
//  A_UnHideThing
//
//==========================================================================

final void A_UnHideThing()
{
	bInvisible = false;
}

//==========================================================================
//
//  A_SetInvulnerable
//
//==========================================================================

final void A_SetInvulnerable()
{
	bInvulnerable = true;
}

//==========================================================================
//
//  A_UnSetInvulnerable
//
//==========================================================================

final void A_UnSetInvulnerable()
{
	bInvulnerable = false;
}

//==========================================================================
//
//	A_SetReflective
//
//==========================================================================

final void A_SetReflective()
{
	bReflective = true;
}

//==========================================================================
//
//	A_UnSetReflective
//
//==========================================================================

final void A_UnSetReflective()
{
	bReflective = false;
}

//==========================================================================
//
//	A_SetReflectiveInvulnerable
//
//==========================================================================

final void A_SetReflectiveInvulnerable()
{
	bReflective = true;

	A_SetInvulnerable();
}

//==========================================================================
//
//	A_UnSetReflectiveInvulnerable
//
//==========================================================================

final void A_UnSetReflectiveInvulnerable()
{
	bReflective = false;

	A_UnSetInvulnerable();
}

//==========================================================================
//
//	A_SetShootable
//
//==========================================================================

final void A_SetShootable()
{
	bNonShootable = false;
	bShootable = true;
}

//==========================================================================
//
//	A_UnSetShootable
//
//==========================================================================

final void A_UnSetShootable()
{
	bNonShootable = true;
	bShootable = false;
}

//===========================================================================
//
//  A_NoGravity
//
//===========================================================================

final void A_NoGravity()
{
	bNoGravity = true;
}

//===========================================================================
//
//  A_Gravity
//
//===========================================================================

final void A_Gravity()
{
	bNoGravity = false;
	Gravity = 1.0;
}

//===========================================================================
//
//  A_LowGravity
//
//===========================================================================

final void A_LowGravity()
{
	bNoGravity = false;
	Gravity = 0.125;
}

//==========================================================================
//
//  A_NoBlocking
//
//  Unset blocking.
//
//==========================================================================

final void A_NoBlocking()
{
	int					SpeechNum;
	RogueConSpeech*		Speech;
	class<EntityEx>		DropItemType;
	int					i;

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		Alpha = 1.0;
		VisDir = 0;
	}

	// actor is on ground, it can be walked over
	bSolid = false;

	SpeechNum = GetSpeech();
	if (SpeechNum)
	{
		//	Drop stuff as determined by conversation.
		if (SpeechNum < 0)
		{
			Speech = &XLevel.GenericSpeeches[-SpeechNum - 1];
		}
		else
		{
			Speech = &XLevel.LevelSpeeches[SpeechNum - 1];
		}
		DropItemType = LineSpecialLevelInfo(Level).GetClassFromID(Speech->DropItem);
		if (DropItemType)
		{
			DropItem(DropItemType, 0, 1.0);
			return;
		}
	}

	// Check for monsters dropping things
	if (ShouldDropItems())
	{
		if (DropItemList.Num)
		{
			for (i = 0; i < DropItemList.Num; i++)
			{
				if (DropItemList[i].Type)
				{
					DropItem(class<EntityEx>(DropItemList[i].Type),
						DropItemList[i].Amount, DropItemList[i].Chance);
				}
			}
		}
		else
		{
			NoBlockingSet();
		}
	}
}

//==========================================================================
//
//	A_Fall
//
//	For compatibility
//
//==========================================================================

final void A_Fall()
{
	A_NoBlocking();
}

//==========================================================================
//
//	A_ScreamAndUnblock
//
//	For breakable DECORATE decorations that have only one death state.
//
//==========================================================================

final void A_ScreamAndUnblock()
{
	A_Scream();
	A_NoBlocking();
}

//==========================================================================
//
//	A_ActiveAndUnblock
//
//	For breakable DECORATE decorations that have only one death state.
//
//==========================================================================

final void A_ActiveAndUnblock()
{
	A_ActiveSound();
	A_NoBlocking();
}

//==========================================================================
//
//	A_SetShadow
//
//==========================================================================

final void A_SetShadow()
{
	bUnknown2 = true;
	bShadow = true;
	RenderStyle = STYLE_Translucent;
	Alpha = 0.333;
}

//==========================================================================
//
//	A_ClearShadow
//
//==========================================================================

final void A_ClearShadow()
{
	bUnknown2 = false;
	bShadow = false;
	RenderStyle = STYLE_Normal;
	Alpha = 1.0;
}

//==========================================================================
//
//  A_QueueCorpse
//
//  Throw another corpse on the queue.
//
//==========================================================================

final void A_QueueCorpse()
{
	EntityEx corpse;

	if (LineSpecialLevelInfo(Level).corpseQueueSlot >=
		LineSpecialLevelInfo(Level).CorpseQueSize)
	{
		// Too many corpses - remove an old one
		corpse = LineSpecialLevelInfo(Level).corpseQueue[
			LineSpecialLevelInfo(Level).corpseQueueSlot %
			LineSpecialLevelInfo(Level).CorpseQueSize];
		if (corpse)
		{
			corpse.Destroy();
		}
	}
	LineSpecialLevelInfo(Level).corpseQueue[
		LineSpecialLevelInfo(Level).corpseQueueSlot %
		LineSpecialLevelInfo(Level).CorpseQueSize] = self;
	LineSpecialLevelInfo(Level).corpseQueueSlot++;
}

//============================================================================
//
//  A_DeQueueCorpse
//
//  Remove a mobj from the queue (for resurrection)
//
//============================================================================

final void A_DeQueueCorpse()
{
	int slot;

	for (slot = 0; slot < LineSpecialLevelInfo(Level).CorpseQueSize; slot++)
	{
		if (LineSpecialLevelInfo(Level).corpseQueue[slot] == self)
		{
			LineSpecialLevelInfo(Level).corpseQueue[slot] = none;
			break;
		}
	}
}

//**************************************************************************
//	Missile movement
//**************************************************************************

//==========================================================================
//
//  A_Tracer
//
//  Ravenant missile tracer.
//
//==========================================================================

const float TRACEADJUST = 0.2865921825;

final void A_Tracer()
{
	EntityEx A;
	TVec wishdir;
	TVec currdir;
	TVec delta;
	float adjustlen;

	if (XLevel.TicTime & 3)
	{
		return;
	}

	// spawn a puff of smoke behind the rocket      
	SpawnPuff(Origin, MISSILERANGE, BulletPuff, false);

	A = Spawn(RevenantTracerSmoke, Origin - Velocity * Level.Game.frametime);

	A.Velocity.z = 1.0 * 35.0;
	A.StateTime -= Random() * 0.1;
	if (A.StateTime < 0.1)
	{
		A.StateTime = 0.1;
	}

	// adjust direction
	if (!Tracer || Tracer.Health <= 0)
	{
		return;
	}

	wishdir = Normalise(Tracer.GetCentre() - Origin);
	currdir = Normalise(Velocity);
	delta = wishdir - currdir;
	adjustlen = Length(delta);
	if (adjustlen > TRACEADJUST)
	{
		adjustlen = TRACEADJUST;
	}
	wishdir = currdir + delta * adjustlen;
	Velocity = wishdir * Speed;
	VectorAngles(&wishdir, &Angles);
}

//==========================================================================
//
//  A_Fire
//
//  Keep fire in front of player unless out of sight.
//
//==========================================================================

final void A_Fire()
{
	if (!Target || !Tracer)
	{
		return;
	}

	// don't move it if the vile lost sight
	if (!Target.CanSee(Tracer))
	{
		return;
	}

	UnlinkFromWorld();
	Origin.x = Tracer.Origin.x + 24.0 * cos(Tracer.Angles.yaw);
	Origin.y = Tracer.Origin.y + 24.0 * sin(Tracer.Angles.yaw);
	Origin.z = Tracer.Origin.z;
	LinkToWorld();
}

//==========================================================================
//
//	A_CountdownArg
//
//==========================================================================

final void A_CountdownArg(int Index)
{
	if (Index <= 0 || Index > 5)
	{
		return;
	}
	if (!Args[Index - 1]--)
	{
		if (bMissile)
		{
			ExplodeMissile();
		}
		else if (bShootable)
		{
			Damage(none, none, Health);
		}
		else
		{
			SetState(FindState('Death'));
		}
	}
}

//**************************************************************************
//	Inventory functions
//**************************************************************************

//==========================================================================
//
//	DoGiveInventory
//
//==========================================================================

final void DoGiveInventory(class<Inventory> ItemType, int Amount,
	EntityEx Receiver)
{
	if (!Receiver)
	{
		return;
	}

	if (!Amount)
	{
		Amount = 1;
	}
	bool Ret = true;
	if (ItemType)
	{
		Inventory Item = Spawn(ItemType,,,, false);
		if (Health(Item))
		{
			Item.Amount *= Amount;
		}
		else
		{
			Item.Amount = Amount;
		}
		Item.bDropped = true;
		if (!Item.TryPickup(Receiver))
		{
			Item.Destroy();
			Ret = false;
		}
	}
	else
	{
		Ret = false;
	}

	if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = Ret;
	}
}

//==========================================================================
//
//	A_GiveInventory
//
//==========================================================================

final void A_GiveInventory(class<Inventory> ItemType, optional int Amount)
{
	DoGiveInventory(ItemType, Amount, self);
}

//==========================================================================
//
//	A_GiveToTarget
//
//==========================================================================

final void A_GiveToTarget(class<Inventory> ItemType, optional int Amount)
{
	DoGiveInventory(ItemType, Amount, Target);
}

//==========================================================================
//
//	DoTakeInventory
//
//==========================================================================

final void DoTakeInventory(class<Inventory> ItemType, int Amount,
	EntityEx Receiver)
{
	if (!Receiver)
	{
		return;
	}

	if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}

	Inventory Item = Receiver.FindInventory(ItemType);
	if (Item && !HexenArmor(Item))
	{
		if (Item.Amount > 0 && XLevel.StateCall)
		{
			XLevel.StateCall->Result = true;
		}
		if (!Amount || Item.Amount <= Amount)
		{
			if (Item.bKeepDepleted)
			{
				Item.Amount = 0;
			}
			else
			{
				Item.Destroy();
			}
		}
		else
		{
			Item.Amount -= Amount;
		}
	}
}

//==========================================================================
//
//	A_TakeInventory
//
//==========================================================================

final void A_TakeInventory(class<Inventory> ItemType, optional int Amount)
{
	DoTakeInventory(ItemType, Amount, self);
}

//==========================================================================
//
//	A_TakeFromTarget
//
//==========================================================================

final void A_TakeFromTarget(class<Inventory> ItemType, optional int Amount)
{
	DoTakeInventory(ItemType, Amount, Target);
}

//==========================================================================
//
//	A_DropInventory
//
//==========================================================================

final void A_DropInventory(class<Inventory> ItemType)
{
	Inventory Item = FindInventory(ItemType);
	if (Item)
	{
		DropInventory(Item);
	}
}

//==========================================================================
//
//	A_SelectWeapon
//
//==========================================================================

final void A_SelectWeapon(class<Weapon> WeaponType)
{
	if (!bIsPlayer)
	{
		return;
	}

	Weapon Wpn = Weapon(FindInventory(WeaponType));
	if (Wpn)
	{
		if (PlayerEx(Player).ReadyWeapon != Wpn)
		{
			PlayerEx(Player).PendingWeapon = Wpn;
		}
	}
	else if (XLevel.StateCall)
	{
		XLevel.StateCall->Result = false;
	}
}

//**************************************************************************
//	Weapon functions
//**************************************************************************

//**************************************************************************
//	Weapon attack functions
//**************************************************************************

//===========================================================================
//
//  A_Punch
//
//===========================================================================

final void A_Punch()
{
	int			damage;
	TAVec		aimAngles;
	TVec		dir;
	EntityEx	AimTarget;

	if (bIsPlayer)
	{
		Weapon Wpn = PlayerEx(Player).ReadyWeapon;
		if (Wpn)
		{
			if (!Wpn.DepleteAmmo())
			{
				return;
			}
		}
	}

	damage = (P_Random() % 10 + 1) << 1;

	if (FindInventory(PowerStrength))
		damage *= 10;

	aimAngles = Angles;
	aimAngles.yaw = AngleMod360(aimAngles.yaw + (Random() -
		Random()) * 45.0 / 8.0);
	AimTarget = AimLineAttack(dir, aimAngles, MELEERANGE);
	LineAttack(dir, MELEERANGE, damage, BulletPuff);

	// turn to face target
	if (AimTarget)
	{
		PlaySound('*fist', CHAN_WEAPON);
		Angles.yaw = atan2(AimTarget.Origin.y - Origin.y,
			AimTarget.Origin.x - Origin.x);
		if (bIsPlayer)
		{
			Player.bFixAngle = true;
		}
	}
}

//**************************************************************************
//	Original Doom/Strife monster attacks
//**************************************************************************

//==========================================================================
//
//  A_PosAttack
//
//  Zombieman attack.
//
//==========================================================================

final void A_PosAttack()
{
	int damage;
	TVec dir;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();

	AimLineAttack(dir, Angles, MISSILERANGE);
	VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);

	PlaySound('grunt/attack', CHAN_WEAPON);

	damage = ((P_Random() % 5) + 1) * 3;

	LineAttack(dir, MISSILERANGE, damage, BulletPuff);
}

//==========================================================================
//
//  A_SPosAttack
//
//  For DeHackEd compatibility only.
//
//==========================================================================

final void A_SPosAttack()
{
	if (!Target)
	{
		return;
	}

	PlaySound('shotguy/attack', CHAN_WEAPON);
	DoSPosAttack();
}

//==========================================================================
//
//  A_SPosAttackUseAtkSound
//
//  Shotgun guy, Spider mastermind attack.
//
//==========================================================================

final void A_SPosAttackUseAtkSound()
{
	if (!Target)
	{
		return;
	}

	PlaySound(AttackSound, CHAN_WEAPON);
	DoSPosAttack();
}

//==========================================================================
//
//  DoSPosAttack
//
//==========================================================================

final void DoSPosAttack()
{
	int i;
	int damage;
	TVec aimDir;
	TVec dir;

	A_FaceTarget();
	AimLineAttack(aimDir, Angles, MISSILERANGE);
	for (i = 0; i < 3; i++)
	{
		dir = aimDir;
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
		damage = ((P_Random() % 5) + 1) * 3;
		LineAttack(dir, MISSILERANGE, damage, BulletPuff);
	}
}

//==========================================================================
//
//  A_CPosAttack
//
//  Heavy weapon dude attack.
//
//==========================================================================

final void A_CPosAttack()
{
	int damage;
	TVec dir;

	if (!Target)
	{
		return;
	}

	//	Andy Baker's stealth monsters
	if (bStealth)
	{
		VisDir = 1;
	}

	//FIXME
	PlaySound(AttackSound, CHAN_WEAPON);
	A_FaceTarget();
	AimLineAttack(dir, Angles, MISSILERANGE);
	VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
	damage = ((P_Random() % 5) + 1) * 3;
	LineAttack(dir, MISSILERANGE, damage, BulletPuff);
}

//==========================================================================
//
//  A_CPosRefire
//
//  Heavy weapon dude refire.
//
//==========================================================================

final void A_CPosRefire()
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 40)
	{
		return;
	}

	if (!Target || Target.Health <= 0 || !CanSee(Target))
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//  A_SpidRefire
//
//  Spider mastermind refire.
//
//==========================================================================

final void A_SpidRefire()
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 10)
		return;

	if (!Target || Target.Health <= 0 || !CanSee(Target))
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//  A_TroopAttack
//
//  Imp attack.
//
//==========================================================================

final void A_TroopAttack()
{
	int damage;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		PlaySound('imp/melee', CHAN_WEAPON);
		damage = (P_Random() % 8 + 1) * 3;
		Target.Damage(self, self, damage);
		return;
	}

	// launch a missile
	SpawnMissile(Target, DoomImpBall);
}

//==========================================================================
//
//  A_SargAttack
//
//  Demon, Spectre attack.
//
//==========================================================================

final void A_SargAttack()
{
	int damage;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		damage = ((P_Random() % 10) + 1) * 4;
		Target.Damage(self, self, damage);
	}
}

//==========================================================================
//
//  A_HeadAttack
//
//  Cacodemon attack.
//
//==========================================================================

final void A_HeadAttack()
{
	int damage;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		damage = (P_Random() % 6 + 1) * 10;
		Target.Damage(self, self, damage);
		return;
	}

	// launch a missile
	SpawnMissile(Target, CacodemonBall);
}

//==========================================================================
//
//  A_BruisAttack
//
//  Hell knight, Baron of hell attack.
//
//==========================================================================

final void A_BruisAttack()
{
	int damage;

	if (!Target)
	{
		return;
	}

	if (CheckMeleeRange())
	{
		PlaySound('baron/melee', CHAN_WEAPON);
		damage = (P_Random() % 8 + 1) * 10;
		Target.Damage(self, self, damage);
		return;
	}

	// launch a missile
	SpawnMissile(Target, BaronBall);
}

//==========================================================================
//
//  A_SkullAttack
//
//  Lost soul attack. Fly at the player like a missile.
//
//==========================================================================

const float SKULLSPEED = 700.0;

final void A_SkullAttack()
{
	if (!Target)
	{
		return;
	}

	bSkullFly = true;

	PlaySound(AttackSound, CHAN_VOICE);
	A_FaceTarget();
	Velocity = Normalise(Target.GetCentre() - Origin) * SKULLSPEED;
}

//==========================================================================
//
//  A_BspiAttack
//
//  Arachnotron attack.
//
//==========================================================================

final void A_BspiAttack()
{
	if (!Target)
	{
		return;
	}

	A_FaceTarget();

	// launch a missile
	SpawnMissile(Target, ArachnotronPlasma);
}

//==========================================================================
//
//  A_CyberAttack
//
//  Cyberdemon attack.
//
//==========================================================================

final void A_CyberAttack()
{
	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	SpawnMissile(Target, Rocket);
}

//==========================================================================
//
//  A_PainAttack
//
//  Pain elemental attack. Spawn a lost soul and launch it at the target.
// 
//==========================================================================

final void A_PainAttack()
{
	decorate_A_PainAttack(LostSoul);
}

//==========================================================================
//
//  decorate_A_PainAttack
//
//  Pain elemental attack. Spawn a lost soul and launch it at the target.
// 
//==========================================================================

final void decorate_A_PainAttack(optional class<ScriptedEntity> SpawnType)
{
	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	PainShootSkull(SpawnType, Angles.yaw);
}

//==========================================================================
//
//  A_PainDie
//
//  Pain elemental death.
//
//==========================================================================

final void A_PainDie()
{
	decorate_A_PainDie(LostSoul);
}

//==========================================================================
//
//  decorate_A_PainDie
//
//  Pain elemental death.
//
//==========================================================================

final void decorate_A_PainDie(optional class<ScriptedEntity> SpawnType)
{
	A_Fall();
	PainShootSkull(SpawnType, Angles.yaw + 90.0);
	PainShootSkull(SpawnType, Angles.yaw + 180.0);
	PainShootSkull(SpawnType, Angles.yaw + 270.0);
}

//==========================================================================
//
//  A_SkelFist
//
//  Ravenant close attack.
//
//==========================================================================

final void A_SkelFist()
{
	int damage;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();

	if (CheckMeleeRange())
	{
		damage = ((P_Random() % 10) + 1) * 6;
		PlaySound('skeleton/melee', CHAN_WEAPON);
		Target.Damage(self, self, damage);
	}
}

//==========================================================================
//
//  A_SkelMissile
//
//  Ravenant far attack.
//
//==========================================================================

final void A_SkelMissile()
{
	EntityEx A;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	Origin.z += 16.0;	// so missile spawns higher
	A = SpawnMissile(Target, RevenantTracer);
	Origin.z -= 16.0;	// back to normal

	if (A)
	{
		A.Origin = A.Origin + A.Velocity * 0.03;
		A.Tracer = Target;
		A.bSeekerMissile = true;
	}
}

//==========================================================================
//
//  A_FatAttack1
//
//  Mancubus attack, firing three missiles (bruisers) in three different
// directions? Doesn't look like it.
//
//==========================================================================

final void A_FatAttack1()
{
	decorate_A_FatAttack1(FatShot);
}

//==========================================================================
//
//  decorate_A_FatAttack1
//
//  Mancubus attack, firing three missiles (bruisers) in three different
// directions? Doesn't look like it.
//
//==========================================================================

const float FatsoSpreadAngle = 90.0 / 8.0;

final void decorate_A_FatAttack1(optional class<EntityEx> SpawnType)
{
	EntityEx A;

	if (!SpawnType)
	{
		SpawnType = FatShot;
	}

	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	// Change direction  to ...
	Angles.yaw = AngleMod360(Angles.yaw + FatsoSpreadAngle);
	SpawnMissile(Target, SpawnType);

	A = SpawnMissile(Target, SpawnType);
	if (A)
	{
		A.Angles.yaw = AngleMod360(A.Angles.yaw + FatsoSpreadAngle);
		VectorRotateAroundZ(&A.Velocity, FatsoSpreadAngle);
	}
}

//==========================================================================
//
//  A_FatAttack2
//
//  Mancubus attack, second direction.
//
//==========================================================================

final void A_FatAttack2()
{
	decorate_A_FatAttack2(FatShot);
}

//==========================================================================
//
//  decorate_A_FatAttack2
//
//  Mancubus attack, second direction.
//
//==========================================================================

final void decorate_A_FatAttack2(optional class<EntityEx> SpawnType)
{
	EntityEx A;

	if (!SpawnType)
	{
		SpawnType = FatShot;
	}

	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	// Now here choose opposite deviation.
	Angles.yaw = AngleMod360(Angles.yaw - FatsoSpreadAngle);
	SpawnMissile(Target, SpawnType);

	A = SpawnMissile(Target, SpawnType);
	if (A)
	{
		A.Angles.yaw = AngleMod360(A.Angles.yaw - FatsoSpreadAngle * 2.0);
		VectorRotateAroundZ(&A.Velocity, -FatsoSpreadAngle * 2.0);
	}
}

//==========================================================================
//
//  A_FatAttack3
//
//  Mancubus attack, third direction.
//
//==========================================================================

final void A_FatAttack3()
{
	decorate_A_FatAttack3(FatShot);
}

//==========================================================================
//
//  decorate_A_FatAttack3
//
//  Mancubus attack, third direction.
//
//==========================================================================

final void decorate_A_FatAttack3(optional class<EntityEx> SpawnType)
{
	EntityEx A;

	if (!SpawnType)
	{
		SpawnType = FatShot;
	}

	if (!Target)
	{
		return;
	}

	A_FaceTarget();

	A = SpawnMissile(Target, SpawnType);
	if (A)
	{
		A.Angles.yaw = AngleMod360(A.Angles.yaw - FatsoSpreadAngle / 2.0);
		VectorRotateAroundZ(&A.Velocity, -FatsoSpreadAngle / 2.0);
	}

	A = SpawnMissile(Target, SpawnType);
	if (A)
	{
		A.Angles.yaw = AngleMod360(A.Angles.yaw + FatsoSpreadAngle / 2.0);
		VectorRotateAroundZ(&A.Velocity, FatsoSpreadAngle / 2.0);
	}
}

//==========================================================================
//
//  A_VileTarget
//
//  Spawn the hellfire.
//
//==========================================================================

final void A_VileTarget()
{
	EntityEx fog;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();

	fog = Spawn(ArchvileFire, Target.Origin);

	Tracer = fog;
	fog.Target = self;
	fog.Tracer = Target;
	fog.SetState(fog.IdleState);
}

//==========================================================================
//
//  A_VileAttack
//
//  Arch-vile attack.
//
//==========================================================================

final void A_VileAttack()
{
	EntityEx fire;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();

	if (!CanSee(Target))
	{
		return;
	}

	PlaySound('vile/stop', CHAN_WEAPON);
	Target.Damage(self, self, 20);
	Target.Velocity.z = 1000.0 / Target.Mass * 35.0;

	fire = Tracer;

	if (!fire)
	{
		return;
	}

	// move the fire between the vile and the player
	fire.Origin.x = Target.Origin.x - 24.0 * cos(Angles.yaw);
	fire.Origin.y = Target.Origin.y - 24.0 * sin(Angles.yaw);
	fire.RadiusAttack(self, 70, 70.0, true);
}

//==========================================================================
//
//  A_BrainSpit
//
//  Spawn a cube.
//
//==========================================================================

final void A_BrainSpit()
{
	BrainState		BState;
	EntityEx		targ;
	EntityEx		A;
	float			Frac;

	//	Find brain state object, create it if not found.
	BState = none;
	foreach AllThinkers(BrainState, BState)
	{
		break;
	}
	if (!BState)
	{
		BState = Spawn(BrainState);
		BState.FindTargets();
	}

	if (!BState.Targets.Num)
	{
		//	No brain targets placed on a map.
		return;
	}

	BState.bEasy = !BState.bEasy;
	if (Level.Game.gameskill <= sk_easy && !BState.bEasy)
	{
		return;
	}

	// shoot a cube at current target
	targ = BState.Targets[BState.TargetOn];
	BState.TargetOn = (BState.TargetOn + 1) % BState.Targets.Num;

	// spawn brain missile
	A = SpawnMissile(targ, SpawnShot);
	if (A)
	{
		A.Target = targ;
		//	Prevent division by 0
		if (!A.Velocity.x && !A.Velocity.y)
		{
			Frac = 0.0;
		}
		else if (fabs(A.Velocity.x) > fabs(A.Velocity.y))
		{
			Frac = (targ.Origin.x - Origin.x) / A.Velocity.x;
		}
		else
		{
			Frac = (targ.Origin.y - Origin.y) / A.Velocity.y;
		}
		A.ReactionCount = ftoi(Frac / GetStateDuration(A.State));
	}

	PlaySound('brain/spit', CHAN_WEAPON, 1.0, ATTN_NONE);
}

//==========================================================================
//
//  A_SpawnFly
//
//  Cube flying, spawn monster, when finished.
//
//==========================================================================

final void A_SpawnFly()
{
	EntityEx newmobj;
	EntityEx fog;
	int r;
	class<EntityEx> type;

	if (--ReactionCount)
		return;	// still flying

	// First spawn teleport fog.
	fog = Spawn(SpawnFire, Target.Origin, vector(0.0, 0.0, 0.0));
	fog.PlaySound('brain/spawn', CHAN_VOICE);

	// Randomly select monster to spawn.
	r = P_Random();

	// Probability distribution (kind of :),
	// decreasing likelihood.
	if (r < 50)
		type = DoomImp;
	else if (r < 90)
		type = Demon;
	else if (r < 120)
		type = Spectre;
	else if (r < 130)
		type = PainElemental;
	else if (r < 160)
		type = Cacodemon;
	else if (r < 162)
		type = Archvile;
	else if (r < 172)
		type = Revenant;
	else if (r < 192)
		type = Arachnotron;
	else if (r < 222)
		type = Fatso;
	else if (r < 246)
		type = HellKnight;
	else
		type = BaronOfHell;

	newmobj = Spawn(type, Target.Origin, vector(0.0, 0.0, 0.0));
	if (newmobj.LookForPlayers(true))
		newmobj.SetState(newmobj.SeeState);

	// telefrag anything in this spot
	newmobj.bTelestomp = true;
	newmobj.TeleportMove(newmobj.Origin);

	// remove self (i.e., cube).
	Destroy();
}

//==========================================================================
//
//  A_SpawnSound
//
//  Travelling cube sound.
//
//==========================================================================

final void A_SpawnSound()
{
	PlaySound('brain/cube', CHAN_VOICE);
	A_SpawnFly();
}

//==========================================================================
//
//  A_BrainScream
//
//  Brain death sound, make explosions.
//
//==========================================================================

final void A_BrainScream()
{
	TVec org;
	EntityEx A;

	for (org.x = Origin.x - 196.0; org.x < Origin.x + 320.0; org.x += 8.0)
	{
		org.y = Origin.y - 320.0;
		org.z = 1.0 / 512.0 + Random() * 512.0;
		A = Spawn(Rocket, org);
		A.Velocity.z = Random() * 2.0 * 35.0;

		A.SetState(FindClassState(BossBrain, 'BrainExplode'));

		A.StateTime -= Random() * 0.2;
		if (A.StateTime < 0.1)
			A.StateTime = 0.1;
	}

	PlaySound('brain/death', CHAN_VOICE, 1.0, ATTN_NONE);
}

//==========================================================================
//
//  A_BrainExplode
//
//  Brain explosions.
//
//==========================================================================

final void A_BrainExplode()
{
	TVec org;
	EntityEx A;

	org.x = Origin.x + (Random() - Random()) * 8.0;
	org.y = Origin.y;
	org.z = 1.0 / 512.0 + Random() * 512.0;
	A = Spawn(Rocket, org,,, false);
	A.Velocity.z = Random() * 2.0 * 35.0;

	A.SetState(FindClassState(BossBrain, 'BrainExplode'));

	A.StateTime -= Random() * 0.2;
	if (A.StateTime < 0.1)
		A.StateTime = 0.1;
}

//===========================================================================
//
//  A_M_Saw
//
//===========================================================================

final void A_M_Saw()
{
	float		angle;
	int			damage;
	TAVec		aimAng;
	TVec		dir;
	EntityEx	AimTarget;

	if (!Target)
	{
		return;
	}

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		damage = 2 * (P_Random() % 10 + 1);
		aimAng = Angles;
		aimAng.yaw = AngleMod360(aimAng.yaw + (Random() -
			Random()) * 45.0 / 8.0);

		// use meleerange + 1 se the puff doesn't skip the flash
		AimTarget = AimLineAttack(dir, aimAng, MELEERANGE + 0.00001);
		LineAttack(dir, MELEERANGE + 0.00001, damage, BulletPuff);

		if (!AimTarget)
		{
			PlaySound('weapons/sawfull', CHAN_WEAPON);
			return;
		}
		PlaySound('weapons/sawhit', CHAN_WEAPON);

		// turn to face target
		angle = atan2(AimTarget.Origin.y - Origin.y,
			AimTarget.Origin.x - Origin.x);
		if (AngleMod360(angle - Angles.yaw) > 180.0)
		{
			if (AngleMod360(angle - Angles.yaw) < -90.0 / 20.0)
				Angles.yaw = angle + 90.0 / 21.0;
			else
				Angles.yaw = Angles.yaw - 90.0 / 20.0;
		}
		else
		{
			if (AngleMod360(angle - Angles.yaw) > 90.0 / 20.0)
				Angles.yaw = angle - 90.0 / 21.0;
			else
				Angles.yaw += 90.0 / 20.0;
		}
		Angles.yaw = AngleMod360(Angles.yaw);
	}
	else
	{
		PlaySound('weapons/sawfull', CHAN_WEAPON);
	}
}

//==========================================================================
//
//	A_SentinelRefire
//
//==========================================================================

final void A_SentinelRefire()
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 30)
	{
		return;
	}

	if (!Target || Target.Health <= 0 || !CanSee(Target) || P_Random() < 40)
	{
		SetState(SeeState);
	}
}

//**************************************************************************
//	Monster specific functions for Doom
//**************************************************************************

//==========================================================================
//
//  A_Hoof
//
//  Cyberdemon move with hoof sound.
//
//==========================================================================

final void A_Hoof()
{
	PlaySound('cyber/hoof', CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  A_Metal
//
//  Cyberdemon move with metal sound.
//
//==========================================================================

final void A_Metal()
{
	PlaySound('spider/walk', CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  A_BabyMetal
//
//  Arachnotron move with metal sound.
//
//==========================================================================

final void A_BabyMetal()
{
	PlaySound('baby/walk', CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  A_FatRaise
//
//  Mancubus attack sound.
//
//==========================================================================

final void A_FatRaise()
{
	A_FaceTarget();
	PlaySound('fatso/raiseguns', CHAN_WEAPON);
}

//==========================================================================
//
//  A_SkelWhosh
//
//  Ravenant attack sound.
//
//==========================================================================

final void A_SkelWhoosh()
{
	if (!Target)
	{
		return;
	}
	A_FaceTarget();
	PlaySound('skeleton/swing', CHAN_WEAPON);
}

//==========================================================================
//
//  A_StartFire
//
//  Make fire start sound.
//
//==========================================================================

final void A_StartFire()
{
	PlaySound('vile/firestrt', CHAN_VOICE);
	A_Fire();
}

//==========================================================================
//
//  A_FireCrackle
//
//  Fire sound.
//
//==========================================================================

final void A_FireCrackle()
{
	PlaySound('vile/firecrkl', CHAN_VOICE);
	A_Fire();
}

//===========================================================================
//
//  A_BFGSpray
//
//  Spawn a BFG explosion on every monster in view
//
//===========================================================================

final void A_BFGSpray()
{
	decorate_A_BFGSpray();
}

//===========================================================================
//
//  decorate_A_BFGSpray
//
//  Spawn a BFG explosion on every monster in view
//
//===========================================================================

final void decorate_A_BFGSpray(optional class<EntityEx> FlashType,
	optional int NumRays, optional int DamageAmount)
{
	int			i;
	int			j;
	int			damage;
	TAVec		aimAng;
	EntityEx	emo;
	TVec		Dir;
	EntityEx	AimTarget;

	if (!FlashType)
	{
		FlashType = BFGExtra;
	}
	if (NumRays <= 0)
	{
		NumRays = 40;
	}
	if (DamageAmount <= 0)
	{
		DamageAmount = 15;
	}

	// offset angles from its attack angle
	for (i = 0; i < NumRays; i++)
	{
		aimAng = Angles;
		aimAng.yaw = AngleMod360(aimAng.yaw - 45.0 + 90.0 / itof(NumRays) *
			itof(i));

		// target is the originator (player)
		//  of the missile
		AimTarget = Target.AimLineAttack(Dir, aimAng, 16.0 * 64.0);
		if (!AimTarget)
		{
			continue;
		}

		emo = Spawn(FlashType, AimTarget.Origin +
			vector(0.0, 0.0, AimTarget.Height / 4.0));

		damage = 0;
		for (j = 0; j < DamageAmount; j++)
		{
			damage += (P_Random() & 7) + 1;
		}

		AimTarget.Damage(Target, Target, damage);
	}
}

//**************************************************************************
//**************************************************************************

//==========================================================================
//
//  A_XXScream
//
//  Strife version of A_XScream.
//
//==========================================================================

final void A_XXScream()
{
	if (!bNoBlood || !DeathSound)
	{
		A_XScream();
	}
	else
	{
		PlaySound(DeathSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	A_RemoveForceField
//
//==========================================================================

final void A_RemoveForceField()
{
	int i;
	line_t* line;

	bSpecial = false;
	for (i = 0; i < Sector->linecount; i++)
	{
		line = Sector->lines[i];
		if (line->backsector && line->special == LNSPEC_ForceField)
		{
			line->flags &= ~(ML_BLOCKING|ML_BLOCKEVERYTHING);
			line->special = 0;
			XLevel.Sides[line->sidenum[0]].midtexture = 0;
			XLevel.Sides[line->sidenum[1]].midtexture = 0;
		}
	}
}

//==========================================================================
//
//	A_BeShadowyFoe
//
//==========================================================================

final void A_BeShadowyFoe()
{
	RenderStyle = STYLE_Translucent;
	Alpha = 0.333;
	bFriendly = false;
}

//==========================================================================
//
//  A_FreeTargMobj
//
//==========================================================================

final void A_FreeTargMobj()
{
	Velocity = vector(0.0, 0.0, 0.0);
	Origin.z = CeilingZ + 4.0;
	Gravity = 1.0;
	bSolid = false;
	bShootable = false;
	bFloat = false;
	bCountKill = false;
	bMonster = false;
	bSkullFly = false;
	bNoGravity = true;
	bDropOff = true;
	bCorpse = true;
	bPassMobj = false;
	RenderStyle = STYLE_None;
	Alpha = 0.0;
	Player = none;
	bIsPlayer = false;
	Health = -1000;	// Don't resurrect
}

//==========================================================================
//
//  A_ExecActionSpecial
//
//==========================================================================

final void A_ExecActionSpecial(int Arg1, int Arg2, int Arg3, int Arg4,
	int Arg5, int Special)
{
	Level.ExecuteActionSpecial(Special, Arg1, Arg2, Arg3, Arg4, Arg5, NULL,
		0, self);

}

//==========================================================================
//
//  A_Feathers
//
//==========================================================================

final void A_Feathers()
{
	int i;
	int count;
	EntityEx mo;

	if (Health > 0)
	{
		// Pain
		count = P_Random() < 32 ? 2 : 1;
	}
	else
	{
		// Death
		count = 5 + (P_Random() & 3);
	}
	for (i = 0; i < count; i++)
	{
		mo = Spawn(Feather, Origin + vector(0.0, 0.0, 20.0));
		mo.Target = self;
		mo.Velocity.x = (Random() - Random()) * 35.0;
		mo.Velocity.y = (Random() - Random()) * 35.0;
		mo.Velocity.z = (1.0 + Random() * 2.0) * 35.0;
		mo.SetState(GetStatePlus(mo.IdleState, P_Random() & 7));
	}
}

states
{
FreeTargMobj:
	TNT1 A 1050 A_FreeTargMobj
	Stop
Crunch:
	POL5 A -1
	Stop
}

defaultproperties
{
}
