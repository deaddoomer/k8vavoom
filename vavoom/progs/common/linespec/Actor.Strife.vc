//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

//==========================================================================
//
//	A_FlameDie
//
//==========================================================================

final void A_FlameDie()
{
	bNoGravity = true;
	Velocity.z = Random() * 4.0 * 35.0 / 10.0;
}

//==========================================================================
//
//	A_MaulerTorpedoWave
//
//==========================================================================

final void A_MaulerTorpedoWave()
{
	int i;
	float savedz;

	Angles.yaw = AngleMod360(Angles.yaw + 180.0);

	//	If the torpedo hit the ceiling, it should still spawn the wave.
	savedz = Origin.z;
	if (CeilingZ - Origin.z < 13.0)
	{
		Origin.z = CeilingZ - 13.0;
	}

	for (i = 0; i < 80; i++)
	{
		Angles.yaw = AngleMod360(Angles.yaw + 45.0 / 10.0);
		SpawnSubMissile(MaulerTorpedoWave, Target);
	}
	Origin.z = savedz;
}

//==========================================================================
//
//	A_SpectralLightning
//
//==========================================================================

final void A_SpectralLightning()
{
	Actor	lightning1;
	Actor	lightning2;
	float	x;
	float	y;

	if (Threshold)
	{
		Threshold--;
	}

	Velocity.x += (Random() - 0.5) * 6.0 * 35.0;
	Velocity.y += (Random() - 0.5) * 6.0 * 35.0;

	x = Origin.x + (Random() - 0.5) * 6.0 * 50.0;
	y = Origin.y + (Random() - 0.5) * 6.0 * 50.0;

	//	Spawn bolt in the centre.
	lightning1 = Spawn(Threshold > 25 ? class<Actor>(SpectralLightningV2) :
		class<Actor>(SpectralLightningV1), vector(x, y, ONCEILINGZ));
	if (Sector->bHasExtrafloors && Origin.z <= CeilingZ)
	{
		lightning1.Origin.z = CeilingZ - lightning1.Height;
	}
	lightning1.Target = Target;
	lightning1.Velocity.x = 0.001;
	lightning1.Velocity.y = 0.001;
	lightning1.Velocity.z = -18.0 * 35.0;
	lightning1.Health = Health;

	//	Spawn a random bolt.
	lightning2 = Spawn(SpectralLightningV2, vector(Origin.x, Origin.y,
		ONCEILINGZ));
	if (Sector->bHasExtrafloors && Origin.z <= CeilingZ)
	{
		lightning2.Origin.z = CeilingZ - lightning2.Height;
	}
	lightning2.Target = Target;
	lightning2.Velocity.x = 0.001;
	lightning2.Velocity.y = 0.001;
	lightning2.Velocity.z = -18.0 * 35.0;
	lightning2.Health = Health;
}

//==========================================================================
//
//	A_SpectralLightningTail
//
//==========================================================================

final void A_SpectralLightningTail()
{
	Actor A;

	A = Spawn(SpectralLightningHTail, Origin);
	A.Angles.yaw = Angles.yaw;
}

//==========================================================================
//
//	A_SpectralBigBallLightning
//
//==========================================================================

final void A_SpectralBigBallLightning()
{
	float angle;
	Actor A;
	float dir;

	A_Tracer2();

	dir = Angles.yaw;

	A = Spawn(SpectralLightningH3, Origin);
	A.Target = Target;
	A.Angles.yaw = AngleMod360(dir + 90.0);
	A.Tracer = Tracer;
	A.Velocity.x = A.Speed * cos(A.Angles.yaw);
	A.Velocity.y = A.Speed * sin(A.Angles.yaw);

	A = Spawn(SpectralLightningH3, Origin);
	A.Target = Target;
	A.Angles.yaw = AngleMod360(dir - 90.0);
	A.Tracer = Tracer;
	A.Velocity.x = A.Speed * cos(A.Angles.yaw);
	A.Velocity.y = A.Speed * sin(A.Angles.yaw);

	A = Spawn(SpectralLightningH3, Origin);
	A.Target = Target;
	A.Angles.yaw = dir;
	A.Tracer = Tracer;
	A.Velocity.x = A.Speed * cos(A.Angles.yaw);
	A.Velocity.y = A.Speed * sin(A.Angles.yaw);
}

//==========================================================================
//
//	A_Explose512
//
//==========================================================================

final void A_Explose512()
{
	int i;

	RadiusAttack(Target, 512, 512.0, true);
	if (Target && Target.bIsPlayer)
	{
		Target.Player.ExtraLight = 5;
	}
	
	RenderStyle = STYLE_Add;
}

//==========================================================================
//
//	A_LightGoesOut
//
//==========================================================================

final void A_LightGoesOut()
{
	int i;
	EntityEx foo;

	Sector->params.lightlevel = 0;
	Sector->floor.dist = Level.FindLowestFloorSurrounding(Sector, NULL);
	for (i = 0; i < 8; i++)
	{
		foo = Spawn(Rubble1, Origin);
		if (foo)
		{
			foo.Velocity.x = (Random() * 16.0 - Random() * 8.0) * 35.0;
			foo.Velocity.y = (Random() - Random()) * 8.0 * 35.0;
			foo.Velocity.z = (7.0 + Random() * 4.0) * 35.0;
		}
	}
}

//==========================================================================
//
//	A_ExtraLightOff
//
//==========================================================================

final void A_ExtraLightOff()
{
	if (Target && Target.bIsPlayer)
	{
		Target.Player.ExtraLight = 0;
	}
}

//==========================================================================
//
// A_HideDecepticon
//
// Hide the Acolyte-to-be							->
// Hide the guy transforming into an Acolyte		->
// Hide the transformer								->
// Transformers are Autobots and Decepticons, and
// Decepticons are the bad guys, so...				->
//
// Hide the Decepticon!
//
//==========================================================================

final void A_HideDecepticon()
{
	LineSpecialLevelInfo(Level).EV_DoDoor(999, 64, 0, 0, 0,
		VerticalDoor::DOOREV_Close, NULL, none);
	if (Target && Target.bIsPlayer)
	{
		LineSpecialLevelInfo(Level).NoiseAlert(Target, self);
	}
}

//==========================================================================
//
//	A_AcolyteBits
//
//==========================================================================

final void A_AcolyteBits()
{
	if (SpawnPoint.options & LineSpecialLevelInfo::MTF_SHADOW)
	{
		A_BeShadowyFoe();
	}
	else if (SpawnPoint.options & LineSpecialLevelInfo::MTF_SHADOW)
	{
		RenderStyle = STYLE_None;
	}
}

//==========================================================================
//
//	A_AcolyteDeath
//
//==========================================================================

final void A_AcolyteDeath()
{
	int i;
	Actor Other;

	//	Remove any shadowy effects on the Acolyte.
	RenderStyle = STYLE_Normal;
	Alpha = 1.0;

	//	Only the Blue Acolyte does extra stuff on death.
	if (Class != AcolyteBlue)
		return;

	//	Make sure there is a player alive for victory.
	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (Level.Game.Players[i] && Level.Game.Players[i].bSpawned && Level.Game.Players[i].Health > 0)
		{
			break;
		}
	}
	if (i == MAXPLAYERS)
		return;

	//	Make sure all the other blue acolytes are dead.
	foreach AllThinkers(EntityEx, Other)
	{
		if (Other != self && Other.Class == Class && Other.Health > 0)
		{
			//	Found a living one.
			return;
		}
	}

	EntityEx(Level.Game.Players[0].MO).GiveInventoryType(QuestItem7);
	PlayerEx(Level.Game.Players[0]).SetObjectives(14);
	PlayerEx(Level.Game.Players[0]).ClientVoice(14);
}
