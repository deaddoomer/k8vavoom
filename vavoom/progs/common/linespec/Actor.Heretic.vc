//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

//==========================================================================
//
//  A_MntrFloorFire
//
//==========================================================================

final void A_MntrFloorFire()
{
	Actor A;

	Origin.z = FloorZ;
	A = Spawn(MinotaurFX3, vector(
		Origin.x + (Random() - Random()) * 4.0,
		Origin.y + (Random() - Random()) * 4.0, ONFLOORZ));
	A.Target = Target;
	A.Velocity.x = 0.00001;	// Force block checking
	A.CheckMissileSpawn();
}

//==========================================================================
//
//  A_DripBlood
//
//==========================================================================

final void A_DripBlood()
{
	EntityEx mo;

	mo = Spawn(Blood, Origin + vector((Random() - Random()) * 8.0,
		(Random() - Random()) * 8.0, 0.0));
	mo.Velocity.x = (Random() - Random()) * 4.0 * 35.0;
	mo.Velocity.y = (Random() - Random()) * 4.0 * 35.0;
	mo.Gravity = 0.125;
}

//==========================================================================
//
//  A_LichIceImpact
//
//==========================================================================

final void A_LichIceImpact()
{
	int i;
	float angle;
	Actor shard;

	for (i = 0; i < 8; i++)
	{
		shard = Spawn(HeadFX2, Origin);
		angle = itof(i) * 45.0;
		shard.Target = Target;
		shard.Angles.yaw = angle;
		shard.Velocity.x = shard.Speed * cos(angle);
		shard.Velocity.y = shard.Speed * sin(angle);
		shard.Velocity.z = -0.6 * 35.0;
		shard.CheckMissileSpawn();
	}
}

//==========================================================================
//
//  A_LichFireGrow
//
//==========================================================================

final void A_LichFireGrow()
{
	Health--;
	Origin.z += 9.0;
	if (Health == 0)
	{
		SetState(FindState('NoGrow'));
	}
}

//==========================================================================
//
//  A_BlueSpark
//
//==========================================================================

final void A_BlueSpark()
{
	int i;
	Actor spark;

	for (i = 0; i < 2; i++)
	{
		spark = Spawn(Sorcerer2FXSpark, Origin);
		spark.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
		spark.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
		spark.Velocity.z = (1.0 + Random()) * 35.0;
	}
}

//===========================================================================
//
//  A_MacePL1Check
//
//===========================================================================

final void A_MacePL1Check()
{
	float angle;

	if (Special1 == 0)
	{
		return;
	}
	Special1 -= 4;
	if (Special1 > 0)
	{
		return;
	}
	Special1 = 0;
	bNoGravity = false;
	Gravity = 0.125;
	angle = Angles.yaw;
	Velocity.x = 7.0 * cos(angle) * 35.0;
	Velocity.y = 7.0 * sin(angle) * 35.0;
	Velocity.z -= Velocity.z / 2.0;
}

//===========================================================================
//
//  A_MaceBallImpact
//
//===========================================================================

final void A_MaceBallImpact()
{
	if (Origin.z <= FloorZ && HitFloorType())
	{
		// Landed in some sort of liquid
		Destroy();
		return;
	}
	if ((Health != 1234) && (Origin.z <= FloorZ) && Velocity.z)
	{
		// Bounce
		Health = 1234;
		Velocity.z = Velocity.z * 192.0 / 256.0;
		BounceType = BOUNCE_None;
		SetState(IdleState);
		PlaySound('weapons/macebounce', CHAN_VOICE);
	}
	else
	{
		// Explode
		bNoGravity = true;
		Gravity = 1.0;
		SendExplosion(RGB(255, 128, 0), 86.0, Origin);
		PlaySound('weapons/macehit', CHAN_VOICE);
	}
}

//===========================================================================
//
//  A_MaceBallImpact2
//
//===========================================================================

final void A_MaceBallImpact2()
{
	Actor tiny;
	float angle;

	if (Origin.z <= FloorZ && HitFloorType())
	{
		// Landed in some sort of liquid
		Destroy();
		return;
	}
	if ((Origin.z != FloorZ) || (Velocity.z < 2.0 * 35.0))
	{
		// Explode
		Velocity = vector(0.0, 0.0, 0.0);
		bNoGravity = true;
		BounceType = BOUNCE_None;
		Gravity = 1.0;
		SendExplosion(RGB(255, 128, 0), 86.0, Origin);
	}
	else
	{
		// Bounce
		Velocity.z = Velocity.z * 192.0 / 256.0;
		SetState(IdleState);

		tiny = Spawn(MaceFX3, Origin);
		angle = AngleMod360(Angles.yaw + 90.0);
		tiny.Target = Target;
		tiny.Angles.yaw = angle;
		tiny.Velocity.x =
			Velocity.x / 2.0 + (Velocity.z - 35.0) * cos(angle);
		tiny.Velocity.y =
			Velocity.y / 2.0 + (Velocity.z - 35.0) * sin(angle);
		tiny.Velocity.z = Velocity.z;
		tiny.CheckMissileSpawn();

		tiny = Spawn(MaceFX3, Origin);
		angle = AngleMod360(Angles.yaw - 90.0);
		tiny.Target = Target;
		tiny.Angles.yaw = angle;
		tiny.Velocity.x =
			Velocity.x / 2.0 + (Velocity.z - 35.0) * cos(angle);
		tiny.Velocity.y =
			Velocity.y / 2.0 + (Velocity.z - 35.0) * sin(angle);
		tiny.Velocity.z = Velocity.z;
		tiny.CheckMissileSpawn();
	}
}

//==========================================================================
//
//	A_Timebomb
//
//==========================================================================

final void A_Timebomb()
{
	// Time Bombs
	Origin.z += 32.0;
	RenderStyle = STYLE_Add;
	Alpha = 1.0;
	A_Explode();
}

//==========================================================================
//
//  A_PodPain
//
//==========================================================================

final void A_PodPain()
{
	int i;
	int count;
	int chance;
	Actor goo;

	chance = P_Random();
	if (chance < 128)
	{
		return;
	}
	count = chance > 240 ? 2 : 1;
	for (i = 0; i < count; i++)
	{
		goo = Spawn(PodGoo, Origin + vector(0.0, 0.0, 48.0));
		goo.Target = self;
		goo.Velocity.x = (Random() - Random()) * 2.0 * 35.0;
		goo.Velocity.y = (Random() - Random()) * 2.0 * 35.0;
		goo.Velocity.z = (0.5 + Random() * 2.0) * 35.0;
	}
}

//==========================================================================
//
//  A_RemovePod
//
//==========================================================================

final void A_RemovePod()
{
	if (Master && Master.Special1 > 0)
	{
		Master.Special1--;
	}
}

//==========================================================================
//
//  A_MakePod
//
//==========================================================================

final void A_MakePod()
{
	Actor A;
	float x;
	float y;
	float z;

	if (Special1 == 16)
	{
		// Too many generated pods
		return;
	}
	x = Origin.x;
	y = Origin.y;
	z = Origin.z;
	A = Spawn(Pod, vector(x, y, ONFLOORZ));
	if (!A.CheckPosition(A.Origin))
	{
		// Didn't fit
		A.Destroy();
		return;
	}
	A.SetState(A.FindState('Grow'));
	A.Thrust(Random() * 360.0, 4.5);
	A.PlaySound('world/podgrow', CHAN_VOICE);
	Special1++;	// Increment generated pod count
	A.Master = self;	// Link the generator to the pod
}

//==========================================================================
//
//  A_AccTeleGlitter
//
//==========================================================================

final void A_AccTeleGlitter()
{
	if (++Health > 35)
	{
		Velocity.z += Velocity.z / 2.0;
	}
}

//==========================================================================
//
//  A_VolcanoSet
//
//==========================================================================

final void A_VolcanoSet()
{
	StateTime = 3.0 + Random() * 3.5;
}

//==========================================================================
//
//  A_VolcanoBlast
//
//==========================================================================

final void A_VolcanoBlast()
{
	int i;
	int count;
	Actor blast;
	float angle;

	count = 1 + (P_Random() % 3);
	for (i = 0; i < count; i++)
	{
		blast = Spawn(VolcanoBlast, Origin + vector(0.0, 0.0, 44.0));
		blast.Target = self;
		angle = Random() * 360.0;
		blast.Angles.yaw = angle;
		blast.Velocity.x = cos(angle) * 35.0;
		blast.Velocity.y = sin(angle) * 35.0;
		blast.Velocity.z = (2.5 + Random() * 4.0) * 35.0;
		blast.PlaySound('world/volcano/shoot', CHAN_VOICE);
		blast.CheckMissileSpawn();
	}
}

//==========================================================================
//
//  A_VolcBallImpact
//
//==========================================================================

final void A_VolcBallImpact()
{
	int i;
	Actor tiny;
	float angle;

	if (Origin.z <= FloorZ)
	{
		bNoGravity = true;
		Gravity = 1.0;
		Origin.z += 28.0;
	}
	RadiusAttack(Target, 25, 25.0, true);
	for (i = 0; i < 4; i++)
	{
		tiny = Spawn(VolcanoTBlast, Origin);
		tiny.Target = self;
		angle = itof(i) * 90.0;
		tiny.Angles.yaw = angle;
		tiny.Velocity.x = 0.7 * cos(angle) * 35.0;
		tiny.Velocity.y = 0.7 * sin(angle) * 35.0;
		tiny.Velocity.z = (1.0 + Random() * 2.0) * 35.0;
		tiny.CheckMissileSpawn();
	}
}
