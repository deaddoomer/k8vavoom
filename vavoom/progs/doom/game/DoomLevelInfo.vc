//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class DoomLevelInfo : LineSpecialLevelInfo;

const int BODYQUESIZE				= 32;

EntityEx bodyque[BODYQUESIZE];
int bodyqueslot;

//==========================================================================
//
//  ExecuteActionSpecial
//
//==========================================================================

bool ExecuteActionSpecial(int Special, int Arg1, int Arg2, int Arg3,
	int Arg4, int Arg5, line_t* Line, int Side, Entity E)
{
	bool buttonSuccess;

	buttonSuccess = false;
	switch (Special)
	{
//LNSPEC_LightStop:
	case LNSPEC_QuakeTremor:
		buttonSuccess = A_LocalQuake(Arg1, Arg2, Arg3, Arg4, Arg5);
		break;
/*	case LNSPEC_UsePuzzleItem:
		buttonSuccess = EV_LineSearchForPuzzleItem(Arg1, Arg2, Arg3, Arg4,
			Arg5, A);
		break;*/
//LNSPEC_ThingActivate:

	// Inert Line specials
	default:
		buttonSuccess = ::ExecuteActionSpecial(Special, Arg1, Arg2, Arg3,
			Arg4, Arg5, Line, Side, E);
		break;
	}
	return buttonSuccess;
}

//==========================================================================
//
//  CheckActivation
//
//==========================================================================

bool CheckActivation(int activationType, line_t * line, EntityEx A)
{
	int lineActivation;
	bool noway;

	noway = true;
	lineActivation = GET_SPAC(line->flags);
	if (lineActivation == SPAC_PTOUCH &&
		(activationType == SPAC_PCROSS || activationType == SPAC_IMPACT))
	{
		lineActivation = activationType;
	}
	else if (lineActivation == SPAC_USETHROUGH)
	{
		lineActivation = SPAC_USE;
	}
	else if (line->special == LNSPEC_Teleport &&
		lineActivation == SPAC_CROSS && activationType == SPAC_PCROSS &&
		A && A.bMissile)
	{
		// Let missiles use regular player teleports
		lineActivation = SPAC_PCROSS;
	}
	if (lineActivation != activationType &&
		!(activationType == SPAC_MCROSS && lineActivation == SPAC_CROSS))
	{
		return false;
	}
	if (!A.bIsPlayer && !A.bMissile)
	{
		if ((activationType == SPAC_USE || activationType == SPAC_PUSH)
			&& (line->flags & ML_SECRET))
			return false;	// never open secret doors

		switch (lineActivation)
		{
		case SPAC_IMPACT:
		case SPAC_PCROSS:
			// shouldn't really be here if not a missile
		case SPAC_MCROSS:
			noway = false;
			break;

		case SPAC_CROSS:
			switch (line->special)
			{
			case LNSPEC_DoorRaise:
			case LNSPEC_PlatDownWaitUpStay:
			case LNSPEC_Teleport:
			case LNSPEC_TeleportNoFog:
			case LNSPEC_PlatDownWaitUpStayLip:
			case LNSPEC_TeleportLine:
				noway = false;
			}
			break;

		case SPAC_USE:
		case SPAC_PUSH:
			switch (line->special)
			{
			case LNSPEC_DoorRaise:
				if (line->arg1 == 0)
					noway = false;
				break;
			case LNSPEC_Teleport:
			case LNSPEC_TeleportNoFog:
				noway = false;
			}
			break;
		}
		if (noway)
			return false;
	}
	return true;
}

//==========================================================================
//
//  CheckLock
//
//==========================================================================

bool CheckLock(Entity user, int lock, bool door)
{
	int		Keys;

	if (!user.bIsPlayer)
	{
		return false;
	}
	if (!lock)
	{
		return true;
	}

	Keys = Player(user.Player).Keys;
	switch (lock)
	{
	case 2:	// Blue Lock
		if (!(Keys & (1 << it_bluecard)))
		{
			user.Player.centreprint(door ? "$pd_bluec" : "$pd_blueco");
			user.PlaySound('*grunt', CHAN_VOICE);
			return false;
		}
		break;

	case 1:	// Red Lock
		if (!(Keys & (1 << it_redcard)))
		{
			user.Player.centreprint(door ? "$pd_redc" : "$pd_redco");
			user.PlaySound('*grunt', CHAN_VOICE);
			return false;
		}
		break;

	case 3:	// Yellow Lock
		if (!(Keys & (1 << it_yellowcard)))
		{
			user.Player.centreprint(door ? "$pd_yellowc" : "$pd_yellowco");
			user.PlaySound('*grunt', CHAN_VOICE);
			return false;
		}
		break;

	case 5:	// Blue Lock
		if (!(Keys & (1 << it_blueskull)))
		{
			user.Player.centreprint(door ? "$pd_blues" : "$pd_blueso");
			user.PlaySound('*grunt', CHAN_VOICE);
			return false;
		}
		break;

	case 4:	// Red Lock
		if (!(Keys & (1 << it_redskull)))
		{
			user.Player.centreprint(door ? "$pd_reds" : "$pd_redso");
			user.PlaySound('*grunt', CHAN_VOICE);
			return false;
		}
		break;

	case 6:	// Yellow Lock
		if (!(Keys & (1 << it_yellowskull)))
		{
			user.Player.centreprint(door ? "$pd_yellows" : "$pd_yellowso");
			user.PlaySound('*grunt', CHAN_VOICE);
			return false;
		}
		break;

	case 100:	// Any key
	case 128 + 100:	// Any key
		if (!Keys)
		{
			user.Player.centreprint(door ? "$pd_any" : "$pd_anyobj");
			user.PlaySound('*grunt', CHAN_VOICE);
			return false;
		}
		break;

	case 101:	// All keys
		if (Keys != 0x3f)
		{
			user.Player.centreprint(door ? "$pd_all6" : "$pd_all6o");
			user.PlaySound('*grunt', CHAN_VOICE);
			return false;
		}
		break;

	case 128 + 2:	// Blue Lock
		if (!(Keys & ((1 << it_bluecard) | (1 << it_blueskull))))
		{
			user.Player.centreprint(door ? "$pd_bluek" : "$pd_blueo");
			user.PlaySound('*grunt', CHAN_VOICE);
			return false;
		}
		break;

	case 128 + 1:	// Red Lock
		if (!(Keys & ((1 << it_redcard) | (1 << it_redskull))))
		{
			user.Player.centreprint(door ? "$pd_redk" : "$pd_redo");
			user.PlaySound('*grunt', CHAN_VOICE);
			return false;
		}
		break;

	case 128 + 3:	// Yellow Lock
		if (!(Keys & ((1 << it_yellowcard) | (1 << it_yellowskull))))
		{
			user.Player.centreprint(door ? "$pd_yellowk" : "$pd_yellowo");
			user.PlaySound('*grunt', CHAN_VOICE);
			return false;
		}
		break;

	case 128 + 101:	// All keys
		if (!(Keys & ((1 << it_bluecard) | (1 << it_blueskull))) ||
			!(Keys & ((1 << it_redcard) | (1 << it_redskull))) ||
			!(Keys & ((1 << it_yellowcard) | (1 << it_yellowskull))))
		{
			user.Player.centreprint(door ? "$pd_all3" : "$pd_all3o");
			user.PlaySound('*grunt', CHAN_VOICE);
			return false;
		}
		break;
	}

	return true;
}

//===========================================================================
// Quake variables
//
//      Arg1     Intensity on richter scale (2..9)
//      Arg2     Duration in tics
//      Arg3     Radius for damage, in tile units (64 pixels)
//      Arg4     Radius for tremor in tile units (64 pixels)
//      Arg5     TID of map thing for focus of quake
//
//===========================================================================

//===========================================================================
//
//	A_LocalQuake
//
//===========================================================================

bool A_LocalQuake(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	QuakeFocus focus;
	EntityEx target;
	int lastfound = 0;
	int success = false;

	// Find all quake foci
	do
	{
		target = EntityEx(FindMobjFromTID(Arg5, &lastfound));
		if (target)
		{
			focus = QuakeFocus(Spawn(QuakeFocus, target.Origin));
			if (focus)
			{
				focus.Richters = Arg1;
				focus.QuakeDuration = Arg2 >> 1;	// decremented every 2 tics
				focus.DamageRadius = itof(Arg3) * 64.0;
				focus.TremorRadius = itof(Arg4) * 64.0;
				success = true;
			}
		}
	}
	while (target);

	return success;
}

//==========================================================================
//
//  P_Massacre
//
//  Kills all monsters.
//
//==========================================================================

int P_Massacre()
{
	int count;
	EntityEx mo;

	count = 0;
	foreach AllThinkers(EntityEx, mo)
	{
		if (mo.bMonster && (mo.Health > 0))
		{
			mo.Damage(none, none, 10000);
			count++;
		}
	}
	return count;
}

//==========================================================================
//
//  UpdateParticle
//
//==========================================================================

void UpdateParticle(particle_t * p, float DeltaTime)
{
	float time2, time3;
	float dvel;
	float grav;

	time3 = DeltaTime * 15.0;
	time2 = DeltaTime * 10.0;	// 15;
	dvel = 4.0 * DeltaTime;
	grav = 0.0;	//frametime * sv_gravity.value * 0.05;

	switch (p->type)
	{
	case pt_static:
		break;

	case pt_explode:
		p->ramp += time2;
		if (p->ramp >= 16.0)
			p->die = -1.0;
		else
			p->colour = DoomDefs.default.ramp1[ftoi(p->ramp)];
		p->vel.x += p->vel.x * dvel;
		p->vel.y += p->vel.y * dvel;
		p->vel.z += p->vel.z * dvel;
		p->vel.z -= grav;
		break;

	case pt_explode2:
		p->ramp += time3;
		if (p->ramp >= 16.0)
			p->die = -1.0;
		else
			p->colour = DoomDefs.default.ramp2[ftoi(p->ramp)];
		p->vel.x -= p->vel.x * DeltaTime;
		p->vel.y -= p->vel.y * DeltaTime;
		p->vel.z -= p->vel.z * DeltaTime;
		p->vel.z -= grav;
		break;
	}
}

//==========================================================================
//
//	GetDehackedItemType
//
//==========================================================================

class<Inventory> GetDehackedItemType(EntityEx Item)
{
	// Identify by sprite.
	// armor
	name SpriteName = GetStateSpriteName(Item.State);
	if (SpriteName == 'arm1')
	{
		return GreenArmor;
	}
	if (SpriteName == 'arm2')
	{
		return BlueArmor;
	}
		// bonus items
	if (SpriteName == 'bon1')
	{
		return HealthBonus;
	}
	if (SpriteName == 'bon2')
	{
		return ArmorBonus;
	}
	if (SpriteName == 'soul')
	{
		return Soulsphere;
	}
	if (SpriteName == 'mega')
	{
		return Megasphere;
	}

	// cards
	if (SpriteName == 'bkey')
	{
		return BlueCard;
	}
	if (SpriteName == 'ykey')
	{
		return YellowCard;
	}
	if (SpriteName == 'rkey')
	{
		return RedCard;
	}
	if (SpriteName == 'bsku')
	{
		return BlueSkull;
	}
	if (SpriteName == 'ysku')
	{
		return YellowSkull;
	}
	if (SpriteName == 'rsku')
	{
		return RedSkull;
	}

	// medikits, heals
	if (SpriteName == 'stim')
	{
		return Stimpack;
	}
	if (SpriteName == 'medi')
	{
		return Medikit;
	}

	// power ups
	if (SpriteName == 'pinv')
	{
		return InvulnerabilitySphere;
	}
	if (SpriteName == 'pstr')
	{
		return Berserk;
	}
	if (SpriteName == 'pins')
	{
		return BlurSphere;
	}
	if (SpriteName == 'suit')
	{
		return RadSuit;
	}
	if (SpriteName == 'pvis')
	{
		return Infrared;
	}

	//  Items
	if (SpriteName == 'pmap')
	{
		return Allmap;
	}

	// ammo
	if (SpriteName == 'clip')
	{
		return Clip;
	}
	if (SpriteName == 'ammo')
	{
		return ClipBox;
	}
	if (SpriteName == 'rock')
	{
		return RocketAmmo;
	}
	if (SpriteName == 'brok')
	{
		return RocketBox;
	}
	if (SpriteName == 'cell')
	{
		return Cell;
	}
	if (SpriteName == 'celp')
	{
		return CellPack;
	}
	if (SpriteName == 'shel')
	{
		return Shell;
	}
	if (SpriteName == 'sbox')
	{
		return ShellBox;
	}
	if (SpriteName == 'bpak')
	{
		return Backpack;
	}

	// weapons
	if (SpriteName == 'bfug')
	{
		return BFG9000;
	}
	if (SpriteName == 'mgun')
	{
		return Chaingun;
	}
	if (SpriteName == 'csaw')
	{
		return Chainsaw;
	}
	if (SpriteName == 'laun')
	{
		return RocketLauncher;
	}
	if (SpriteName == 'plas')
	{
		return PlasmaRifle;
	}
	if (SpriteName == 'shot')
	{
		return Shotgun;
	}
	if (SpriteName == 'sgn2')
	{
		return SuperShotgun;
	}
	return none;
}

defaultproperties
{
	DefaultDoorSound = 'DoorNormal';
	DefaultCeilingSound = 'CeilingNormal';
	DefaultSilentCeilingSound = 'CeilingSemiSilent';
	DefaultFloorSound = 'Floor';
	DefaultFloorAltSound = 'Floor';
	DefaultStairStepSound = 'Floor';
	DefaultPlatformSound = 'Platform';
}
