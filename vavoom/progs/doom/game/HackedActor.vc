//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class HackedActor : Actor
	abstract;

int SOULSPHERE_MAX;
int SOULSPHERE_HEALTH;
int MEGASPHERE_HEALTH;

int numbraintargets;
int braintargeton;
int brain_easy;
Actor braintargets[32];

string GOTARMOR;
string GOTMEGA;
string GOTHTHBONUS;
string GOTARMBONUS;
string GOTSTIM;
string GOTMEDINEED;
string GOTMEDIKIT;
string GOTSUPER;
string GOTBLUECARD;
string GOTYELWCARD;
string GOTREDCARD;
string GOTBLUESKUL;
string GOTYELWSKUL;
string GOTREDSKULL;
string GOTINVUL;
string GOTBERSERK;
string GOTINVIS;
string GOTSUIT;
string GOTMAP;
string GOTVISOR;
string GOTMSPHERE;
string GOTCLIP;
string GOTCLIPBOX;
string GOTROCKET;
string GOTROCKBOX;
string GOTCELL;
string GOTCELLBOX;
string GOTSHELLS;
string GOTSHELLBOX;
string GOTBACKPACK;
string GOTBFG9000;
string GOTCHAINGUN;
string GOTCHAINSAW;
string GOTLAUNCHER;
string GOTPLASMA;
string GOTSHOTGUN;
string GOTSHOTGUN2;

//==========================================================================
//
//	DropStuff
//
//==========================================================================

void DropStuff()
{
	classid item;
	Actor A;

	// Drop stuff.
	// This determines the kind of object spawned
	// during the death frame of a thing.
	if (Class == WolfSS ||
		Class == Zombieman)
	{
		item = ItemAmmoBulletClip;
	}
	else if (Class == ShotgunGuy)
	{
		item = ItemWeaponShotgun;
	}
	else if (Class == ChaingunGuy)
	{
		item = ItemWeaponChaingun;
	}
	else
	{
		return;
	}

	A = Spawn(item, vector(Origin.x, Origin.y, FloorZ));
	A.bDropped = true;	// special versions of items
}

//==========================================================================
//
//	HandlePickup
//
//==========================================================================

bool HandlePickup(Actor Toucher)
{
	int i;
	name sound = 'misc/i_pkup';

	// Identify by sprite.
	// armor
	name SpriteName = GetStateSpriteName(State);
	if (SpriteName == 'ARM1')
	{
		if (!Player(Toucher.Player).GiveArmor(1))
			return false;
		Toucher.Player.cprint(GOTARMOR);
	}
	else if (SpriteName == 'ARM2')
	{
		if (!Player(Toucher.Player).GiveArmor(2))
			return false;
		Toucher.Player.cprint(GOTMEGA);
	}
		// bonus items
	else if (SpriteName == 'BON1')
	{
		Toucher.Player.Health++;	// can go over 100%
		if (Toucher.Player.Health > 200)
			Toucher.Player.Health = 200;
		Toucher.Health = Toucher.Player.Health;
		Toucher.Player.cprint(GOTHTHBONUS);
	}
	else if (SpriteName == 'BON2')
	{
		Player(Toucher.Player).ArmorPoints++;	// can go over 100%
		if (Player(Toucher.Player).ArmorPoints > 200)
			Player(Toucher.Player).ArmorPoints = 200;
		if (!Player(Toucher.Player).ArmorType)
			Player(Toucher.Player).ArmorType = 1;
		Toucher.Player.cprint(GOTARMBONUS);
	}
	else if (SpriteName == 'SOUL')
	{
		Toucher.Player.Health += SOULSPHERE_HEALTH;
		if (Toucher.Player.Health > SOULSPHERE_MAX)
			Toucher.Player.Health = SOULSPHERE_MAX;
		Toucher.Player.MO.Health = Toucher.Player.Health;
		Toucher.Player.cprint(GOTSUPER);
		sound = 'misc/p_pkup';
	}
	else if (SpriteName == 'MEGA')
	{
		Toucher.Player.Health = MEGASPHERE_HEALTH;
		Toucher.Health = Toucher.Player.Health;
		Player(Toucher.Player).GiveArmor(2);
		Toucher.Player.cprint(GOTMSPHERE);
		sound = 'misc/p_pkup';
	}
		// cards
		// leave cards for everyone
	else if (SpriteName == 'BKEY')
	{
		if (Player(Toucher.Player).GiveCard(it_bluecard))
			Toucher.Player.cprint(GOTBLUECARD);
		if (Level.Game.netgame)
			return false;
	}
	else if (SpriteName == 'YKEY')
	{
		if (Player(Toucher.Player).GiveCard(it_yellowcard))
			Toucher.Player.cprint(GOTYELWCARD);
		if (Level.Game.netgame)
			return false;
	}
	else if (SpriteName == 'RKEY')
	{
		if (Player(Toucher.Player).GiveCard(it_redcard))
			Toucher.Player.cprint(GOTREDCARD);
		if (Level.Game.netgame)
			return false;
	}
	else if (SpriteName == 'BSKU')
	{
		if (Player(Toucher.Player).GiveCard(it_blueskull))
			Toucher.Player.cprint(GOTBLUESKUL);
		if (Level.Game.netgame)
			return false;
	}
	else if (SpriteName == 'YSKU')
	{
		if (Player(Toucher.Player).GiveCard(it_yellowskull))
			Toucher.Player.cprint(GOTYELWSKUL);
		if (Level.Game.netgame)
			return false;
	}
	else if (SpriteName == 'RSKU')
	{
		if (Player(Toucher.Player).GiveCard(it_redskull))
			Toucher.Player.cprint(GOTREDSKULL);
		if (Level.Game.netgame)
			return false;
	}
		// medikits, heals
	else if (SpriteName == 'STIM')
	{
		if (!Player(Toucher.Player).GiveBody(10, Player::MAXHEALTH))
			return false;
		Toucher.Player.cprint(GOTSTIM);
	}
	else if (SpriteName == 'MEDI')
	{
		if (!Player(Toucher.Player).GiveBody(25, Player::MAXHEALTH))
			return false;

		if (Toucher.Player.Health < 25)
			Toucher.Player.cprint(GOTMEDINEED);
		else
			Toucher.Player.cprint(GOTMEDIKIT);
	}
		// power ups
	else if (SpriteName == 'PINV')
	{
		if (!Player(Toucher.Player).GivePower(pw_invulnerability))
			return false;
		Toucher.Player.cprint(GOTINVUL);
		sound = 'misc/p_pkup';
	}
	else if (SpriteName == 'PSTR')
	{
		if (!Player(Toucher.Player).GivePower(pw_strength))
			return false;
		Toucher.Player.cprint(GOTBERSERK);
		sound = 'misc/p_pkup';
	}
	else if (SpriteName == 'PINS')
	{
		if (!Player(Toucher.Player).GivePower(pw_invisibility))
			return false;
		Toucher.Player.cprint(GOTINVIS);
		sound = 'misc/p_pkup';
	}
	else if (SpriteName == 'SUIT')
	{
		if (!Player(Toucher.Player).GivePower(pw_ironfeet))
			return false;
		Toucher.Player.cprint(GOTSUIT);
		sound = 'misc/p_pkup';
	}
	else if (SpriteName == 'PVIS')
	{
		if (!Player(Toucher.Player).GivePower(pw_infrared))
			return false;
		Toucher.Player.cprint(GOTVISOR);
		sound = 'misc/p_pkup';
	}
		//  Items
	else if (SpriteName == 'PMAP')
	{
		if (!Player(Toucher.Player).GiveItem(IT_ALL_MAP))
			return false;
		Toucher.Player.cprint(GOTMAP);
		sound = 'misc/p_pkup';
	}
		// ammo
	else if (SpriteName == 'CLIP')
	{
		if (bDropped)
		{
			if (!Player(Toucher.Player).GiveAmmo(DoomDefs::am_clip, MainGameInfo(Level.Game).clipammo[DoomDefs::am_clip] / 2))
				return false;
		}
		else
		{
			if (!Player(Toucher.Player).GiveAmmo(DoomDefs::am_clip, MainGameInfo(Level.Game).clipammo[DoomDefs::am_clip]))
				return false;
		}
		Toucher.Player.cprint(GOTCLIP);
	}
	else if (SpriteName == 'AMMO')
	{
		if (!Player(Toucher.Player).GiveAmmo(DoomDefs::am_clip, 5 * MainGameInfo(Level.Game).clipammo[DoomDefs::am_clip]))
			return false;
		Toucher.Player.cprint(GOTCLIPBOX);
	}
	else if (SpriteName == 'ROCK')
	{
		if (!Player(Toucher.Player).GiveAmmo(DoomDefs::am_misl, MainGameInfo(Level.Game).clipammo[DoomDefs::am_misl]))
			return false;
		Toucher.Player.cprint(GOTROCKET);
	}
	else if (SpriteName == 'BROK')
	{
		if (!Player(Toucher.Player).GiveAmmo(DoomDefs::am_misl, 5 * MainGameInfo(Level.Game).clipammo[DoomDefs::am_misl]))
			return false;
		Toucher.Player.cprint(GOTROCKBOX);
	}
	else if (SpriteName == 'CELL')
	{
		if (!Player(Toucher.Player).GiveAmmo(DoomDefs::am_cell, MainGameInfo(Level.Game).clipammo[DoomDefs::am_cell]))
			return false;
		Toucher.Player.cprint(GOTCELL);
	}
	else if (SpriteName == 'CELP')
	{
		if (!Player(Toucher.Player).GiveAmmo(DoomDefs::am_cell, 5 * MainGameInfo(Level.Game).clipammo[DoomDefs::am_cell]))
			return false;
		Toucher.Player.cprint(GOTCELLBOX);
	}
	else if (SpriteName == 'SHEL')
	{
		if (!Player(Toucher.Player).GiveAmmo(DoomDefs::am_shell, MainGameInfo(Level.Game).clipammo[DoomDefs::am_shell]))
			return false;
		Toucher.Player.cprint(GOTSHELLS);
	}
	else if (SpriteName == 'SBOX')
	{
		if (!Player(Toucher.Player).GiveAmmo(DoomDefs::am_shell, 5 * MainGameInfo(Level.Game).clipammo[DoomDefs::am_shell]))
			return false;
		Toucher.Player.cprint(GOTSHELLBOX);
	}
	else if (SpriteName == 'BPAK')
	{
		if (!Player(Toucher.Player).Backpack)
		{
			Player(Toucher.Player).Backpack = true;
			for (i = 0; i < DoomDefs::NUMAMMO; i++)
				Player(Toucher.Player).MaxAmmo[i] *= 2;
		}
		for (i = 0; i < DoomDefs::NUMAMMO; i++)
		{
			Player(Toucher.Player).GiveAmmo(i, MainGameInfo(Level.Game).clipammo[i]);
		}
		Toucher.Player.cprint(GOTBACKPACK);
	}
		// weapons
	else if (SpriteName == 'BFUG')
	{
		if (!Player(Toucher.Player).GiveWeapon(DoomDefs::wp_bfg, false))
			return false;
		Toucher.Player.cprint(GOTBFG9000);
		sound = 'misc/w_pkup';
	}
	else if (SpriteName == 'MGUN')
	{
		if (!Player(Toucher.Player).GiveWeapon(DoomDefs::wp_chaingun, bDropped))
			return false;
		Toucher.Player.cprint(GOTCHAINGUN);
		sound = 'misc/w_pkup';
	}
	else if (SpriteName == 'CSAW')
	{
		if (!Player(Toucher.Player).GiveWeapon(DoomDefs::wp_chainsaw, false))
			return false;
		Toucher.Player.cprint(GOTCHAINSAW);
		sound = 'misc/w_pkup';
	}
	else if (SpriteName == 'LAUN')
	{
		if (!Player(Toucher.Player).GiveWeapon(DoomDefs::wp_missile, false))
			return false;
		Toucher.Player.cprint(GOTLAUNCHER);
		sound = 'misc/w_pkup';
	}
	else if (SpriteName == 'PLAS')
	{
		if (!Player(Toucher.Player).GiveWeapon(DoomDefs::wp_plasma, false))
			return false;
		Toucher.Player.cprint(GOTPLASMA);
		sound = 'misc/w_pkup';
	}
	else if (SpriteName == 'SHOT')
	{
		if (!Player(Toucher.Player).GiveWeapon(DoomDefs::wp_shotgun, bDropped))
			return false;
		Toucher.Player.cprint(GOTSHOTGUN);
		sound = 'misc/w_pkup';
	}
	else if (SpriteName == 'SGN2')
	{
		if (!Player(Toucher.Player).GiveWeapon(DoomDefs::wp_supershotgun, bDropped))
			return false;
		Toucher.Player.cprint(GOTSHOTGUN2);
		sound = 'misc/w_pkup';
	}
	Toucher.PlaySound(sound, CHAN_ITEM);
	return true;
}

//===========================================================================
//
//  A_BFGSpray
//
//  Spawn a BFG explosion on every monster in view
//
//===========================================================================

void A_BFGSpray()
{
	int i;
	int j;
	int damage;
	TAVec aimAng;
	Actor emo;

	// offset angles from its attack angle
	for (i = 0; i < 40; i++)
	{
		aimAng = Angles;
		aimAng.yaw = AngleMod360(aimAng.yaw - 45.0 + 90.0 / 40.0 * itof(i));

		// target is the originator (player)
		//  of the missile
		Instigator.AimLineAttack(aimAng, 16.0 * 64.0);
		if (!Instigator.linetarget)
		{
			continue;
		}

		emo = Spawn(ExtraBFG, Instigator.linetarget.Origin +
			vector(0.0, 0.0, Instigator.linetarget.Height / 4.0));

		MSG_Select(MSG_SV_DATAGRAM);
		if (MSG_CheckSpace(8))
		{
			MSG_WriteByte(DoomDefs::svc_explosion2);
			MSG_WriteByte(DoomDefs::EF_DL_GBALL);
			MSG_WriteShort(ftoi(emo.Origin.x));
			MSG_WriteShort(ftoi(emo.Origin.y));
			MSG_WriteShort(ftoi(emo.Origin.z));
		}

		damage = 0;
		for (j = 0; j < 15; j++)
			damage += (P_Random() & 7) + 1;

		linetarget.Damage(Instigator, Instigator, damage);
	}
}

//==========================================================================
//
//  A_PosAttack
//
//  Zombieman attack.
//
//==========================================================================

void A_PosAttack()
{
	int damage;
	TVec dir;

	if (!Enemy)
		return;

	A_FaceTarget();

	dir = AimLineAttack(Angles, MISSILERANGE);
	VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);

	PlaySound('grunt/attack', CHAN_WEAPON);

	damage = ((P_Random() % 5) + 1) * 3;

	LineAttack(dir, MISSILERANGE, damage);

	Effects |= DoomDefs::EF_DL_MUZZLEFLASH;
}

//==========================================================================
//
//  A_SPosAttack
//
//  Shotgun guy, Spider mastermind attack.
//
//==========================================================================

void A_SPosAttack()
{
	int i;
	int damage;
	TVec aimDir;
	TVec dir;

	if (!Enemy)
		return;

	PlaySound('shotguy/attack', CHAN_WEAPON);
	A_FaceTarget();
	aimDir = AimLineAttack(Angles, MISSILERANGE);
	for (i = 0; i < 3; i++)
	{
		dir = aimDir;
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
		damage = ((P_Random() % 5) + 1) * 3;
		LineAttack(dir, MISSILERANGE, damage);
	}

	Effects |= DoomDefs::EF_DL_MUZZLEFLASH;
}

//==========================================================================
//
//  A_TroopAttack
//
//  Imp attack.
//
//==========================================================================

void A_TroopAttack()
{
	int damage;

	if (!Enemy)
		return;

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		PlaySound('imp/melee', CHAN_WEAPON);
		damage = (P_Random() % 8 + 1) * 3;
		Enemy.Damage(self, self, damage);
		return;
	}

	// launch a missile
	SpawnMissile(Enemy, ImpMissile);
}

//==========================================================================
//
//  A_SargAttack
//
//  Demon, Spectre attack.
//
//==========================================================================

void A_SargAttack()
{
	int damage;

	if (!Enemy)
		return;

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		damage = ((P_Random() % 10) + 1) * 4;
		Enemy.Damage(self, self, damage);
	}
}

//==========================================================================
//
//  A_HeadAttack
//
//  Cacodemon attack.
//
//==========================================================================

void A_HeadAttack()
{
	int damage;

	if (!Enemy)
		return;

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		damage = (P_Random() % 6 + 1) * 10;
		Enemy.Damage(self, self, damage);
		return;
	}

	// launch a missile
	SpawnMissile(Enemy, CacodemonMissile);
}

//==========================================================================
//
//  A_BruisAttack
//
//  Hell knight, Baron of hell attack.
//
//==========================================================================

void A_BruisAttack()
{
	int damage;

	if (!Enemy)
		return;

	if (CheckMeleeRange())
	{
		PlaySound('baron/melee', CHAN_WEAPON);
		damage = (P_Random() % 8 + 1) * 10;
		Enemy.Damage(self, self, damage);
		return;
	}

	// launch a missile
	SpawnMissile(Enemy, BruiserShot);
}

//==========================================================================
//
//  A_SkullAttack
//
//  Lost soul attack. Fly at the player like a missile.
//
//==========================================================================

void A_SkullAttack()
{
	if (!Enemy)
		return;

	bSkullFly = true;

	PlaySound(AttackSound, CHAN_VOICE);
	A_FaceTarget();
	Velocity = Normalise(MobjCenter(Enemy) - Origin) * 700.0;//SKULLSPEED;
}

//==========================================================================
//
//  A_Hoof
//
//  Cyberdemon move with hoof sound.
//
//==========================================================================

void A_Hoof()
{
	PlaySound('cyber/hoof', CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  A_Metal
//
//  Cyberdemon move with metal sound.
//
//==========================================================================

void A_Metal()
{
	PlaySound('cyber/walk', CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  A_CyberAttack
//
//  Cyberdemon attack.
//
//==========================================================================

void A_CyberAttack()
{
	if (!Enemy)
		return;

	A_FaceTarget();
	SpawnMissile(Enemy, Rocket);
}

//==========================================================================
//
//  A_SpidRefire
//
//  Spider mastermind refire.
//
//==========================================================================

void A_SpidRefire()
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 10)
		return;

	if (!Enemy || Enemy.Health <= 0 || !CanSee(Enemy))
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//  A_CPosAttack
//
//  Heavy weapon dude attack.
//
//==========================================================================

void A_CPosAttack()
{
	int damage;
	TVec dir;

	if (!Enemy)
		return;

	PlaySound('chainguy/attack', CHAN_WEAPON);
	A_FaceTarget();
	dir = AimLineAttack(Angles, MISSILERANGE);
	VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
	damage = ((P_Random() % 5) + 1) * 3;
	LineAttack(dir, MISSILERANGE, damage);

	Effects |= DoomDefs::EF_DL_MUZZLEFLASH;
}

//==========================================================================
//
//  A_CPosRefire
//
//  Heavy weapon dude refire.
//
//==========================================================================

void A_CPosRefire()
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 40)
		return;

	if (!Enemy || Enemy.Health <= 0 || !CanSee(Enemy))
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//  A_BabyMetal
//
//  Arachnotron move with metal sound.
//
//==========================================================================

void A_BabyMetal()
{
	PlaySound('baby/walk', CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  A_BspiAttack
//
//  Arachnotron attack.
//
//==========================================================================

void A_BspiAttack()
{
	if (!Enemy)
		return;

	A_FaceTarget();

	// launch a missile
	SpawnMissile(Enemy, ArachnotronPlasma);
}

//==========================================================================
//
//  A_PainShootSkull
//
//  Spawn a lost soul and launch it at the target
//
//==========================================================================

void A_PainShootSkull(float angle)
{
	Actor mo;
	HackedActor newmobj;
	float prestep;
	int count;

	// count total number of skull currently on the level
	count = 0;
	FOREACH(Actor, mo)
	{
		if (mo.Class == LostSoul)
			count++;
	}

	// if there are allready 20 skulls on the level,
	// don't spit another one
	if (count > 20)
		return;

	// okay, there's playe for another one
	prestep = 4.0 + 3.0 * (Radius + 16.0) / 2.0;//SKULL_RADIUS

	newmobj = HackedActor(Spawn(LostSoul, Origin + vector(
		prestep * cos(angle), prestep * sin(angle), 8.0)));

	// Check for movements.
	if (!newmobj.TryMove(newmobj.Origin))
	{
		// kill it immediately
		newmobj.Damage(self, self, 10000);
		return;
	}

	newmobj.Enemy = Enemy;
	newmobj.A_SkullAttack();
}

//==========================================================================
//
//  A_PainAttack
//
//  Pain elemental attack. Spawn a lost soul and launch it at the target.
// 
//==========================================================================

void A_PainAttack()
{
	if (!Enemy)
		return;

	A_FaceTarget();
	A_PainShootSkull(Angles.yaw);
}

//==========================================================================
//
//  A_PainDie
//
//  Pain elemental death.
//
//==========================================================================

void A_PainDie()
{
	A_Fall();
	A_PainShootSkull(Angles.yaw + 90.0);
	A_PainShootSkull(Angles.yaw + 180.0);
	A_PainShootSkull(Angles.yaw + 270.0);
}

//==========================================================================
//
//  A_SkelWhosh
//
//  Ravenant attack sound.
//
//==========================================================================

void A_SkelWhoosh()
{
	if (!Enemy)
		return;
	A_FaceTarget();
	PlaySound('skeleton/swing', CHAN_WEAPON);
}

//==========================================================================
//
//  A_SkelFist
//
//  Ravenant close attack.
//
//==========================================================================

void A_SkelFist()
{
	int damage;

	if (!Enemy)
		return;

	A_FaceTarget();

	if (CheckMeleeRange())
	{
		damage = ((P_Random() % 10) + 1) * 6;
		PlaySound('skeleton/melee', CHAN_WEAPON);
		Enemy.Damage(self, self, damage);
	}
}

//==========================================================================
//
//  A_SkelMissile
//
//  Ravenant far attack.
//
//==========================================================================

void A_SkelMissile()
{
	Actor A;

	if (!Enemy)
		return;

	A_FaceTarget();
	Origin.z += 16.0;	// so missile spawns higher
	A = SpawnMissile(Enemy, RevenantTracer);
	Origin.z -= 16.0;	// back to normal

	A.Origin = A.Origin + A.Velocity * 0.03;
	A.Enemy = Enemy;
}

//==========================================================================
//
//  A_Tracer
//
//  Ravenant missile tracer.
//
//==========================================================================

const float TRACEADJUST	= 0.2865921825;

void A_Tracer()
{
	Actor A;
	TVec wishdir;
	TVec currdir;
	TVec delta;
	float adjustlen;

	if (Level.Game.level->tictime & 3)
		return;

	// spawn a puff of smoke behind the rocket      
	SpawnPuff(Origin, MISSILERANGE);

	A = Spawn(RevenantTracerSmoke, Origin - Velocity * Level.Game.frametime);

	A.Velocity.z = 1.0 * 35.0;
	A.StateTime -= Random() * 0.1;
	if (A.StateTime < 0.1)
		A.StateTime = 0.1;

	// adjust direction
	if (!Enemy || Enemy.Health <= 0)
		return;

	wishdir = Normalise(MobjCenter(Enemy) - Origin);
	currdir = Normalise(Velocity);
	delta = wishdir - currdir;
	adjustlen = Length(delta);
	if (adjustlen > TRACEADJUST)
		adjustlen = TRACEADJUST;
	wishdir = currdir + delta * adjustlen;
	Velocity = wishdir * Speed;
	VectorAngles(&wishdir, &Angles);
}

//==========================================================================
//
//  A_FatRaise
//
//  Mancubus attack sound.
//
//==========================================================================

void A_FatRaise()
{
	A_FaceTarget();
	PlaySound('fatso/raiseguns', CHAN_WEAPON);
}

//==========================================================================
//
//  A_FatAttack1
//
//  Mancubus attack, firing three missiles (bruisers) in three different
// directions? Doesn't look like it.
//
//==========================================================================

void A_FatAttack1()
{
	Actor A;

	A_FaceTarget();
	// Change direction  to ...
	Angles.yaw = AngleMod360(Angles.yaw + (90.0 / 8.0));
	SpawnMissile(Enemy, MancubusMissile);

	A = SpawnMissile(Enemy, MancubusMissile);
	A.Angles.yaw = AngleMod360(A.Angles.yaw + (90.0 / 8.0));
	VectorRotateAroundZ(&A.Velocity, (90.0 / 8.0));
}

//==========================================================================
//
//  A_FatAttack2
//
//  Mancubus attack, second direction.
//
//==========================================================================

void A_FatAttack2()
{
	Actor A;

	A_FaceTarget();
	// Now here choose opposite deviation.
	Angles.yaw = AngleMod360(Angles.yaw - (90.0 / 8.0));
	SpawnMissile(Enemy, MancubusMissile);

	A = SpawnMissile(Enemy, MancubusMissile);
	A.Angles.yaw = AngleMod360(A.Angles.yaw - (90.0 / 8.0) * 2.0);
	VectorRotateAroundZ(&A.Velocity, -(90.0 / 8.0) * 2.0);
}

//==========================================================================
//
//  A_FatAttack3
//
//  Mancubus attack, third direction.
//
//==========================================================================

void A_FatAttack3()
{
	Actor A;

	A_FaceTarget();

	A = SpawnMissile(Enemy, MancubusMissile);
	A.Angles.yaw = AngleMod360(A.Angles.yaw - (90.0 / 8.0) / 2.0);
	VectorRotateAroundZ(&A.Velocity, -(90.0 / 8.0) / 2.0);

	A = SpawnMissile(Enemy, MancubusMissile);
	A.Angles.yaw = AngleMod360(A.Angles.yaw + (90.0 / 8.0) / 2.0);
	VectorRotateAroundZ(&A.Velocity, (90.0 / 8.0) / 2.0);
}

//==========================================================================
//
//  A_VileChase
//
//  Arch-vile check for ressurecting a body.
//
//==========================================================================

void A_VileChase()
{
	int xl;
	int xh;
	int yl;
	int yh;

	int bx;
	int by;

	Actor temp;

	if (MoveDir != DI_NODIR)
	{
		// check for corpses to raise
		viletryx = Origin.x + StepSpeed * MainGameInfo(Level.Game).xspeed[MoveDir];
		viletryy = Origin.y + StepSpeed * MainGameInfo(Level.Game).yspeed[MoveDir];

		xl = MapBlock(viletryx - XLevel.BlockMapOrgX - MAXRADIUS * 2.0);
		xh = MapBlock(viletryx - XLevel.BlockMapOrgX + MAXRADIUS * 2.0);
		yl = MapBlock(viletryy - XLevel.BlockMapOrgY - MAXRADIUS * 2.0);
		yh = MapBlock(viletryy - XLevel.BlockMapOrgY + MAXRADIUS * 2.0);

		for (bx = xl; bx <= xh; bx++)
		{
			for (by = yl; by <= yh; by++)
			{
				// Call PIT_VileCheck to check whether object is a corpse
				// that canbe raised.
				if (!XLevel.BlockThingsIterator(bx, by, self, 'PIT_VileCheck'))
				{
					// got one!
					temp = Enemy;
					Enemy = CorpseHit;
					A_FaceTarget();
					Enemy = temp;

					SetState(FindState('S_VILE_HEAL1'));
					CorpseHit.PlaySound('vile/raise', CHAN_BODY);

					CorpseHit.SetState(CorpseHit.RaiseState);
					CorpseHit.Height *= 4.0;
					CorpseHit.bShootable = true;
					CorpseHit.bFloat = CorpseHit.bDefaultFloat;
					CorpseHit.bNoGravity = CorpseHit.bDefaultNoGravity;
					CorpseHit.bDropOff = false;
					CorpseHit.bSolid = true;
					CorpseHit.bCorpse = false;
					CorpseHit.Health = CorpseHit.SpawnHealth;
					CorpseHit.Enemy = none;
				}
			}
		}
	}


	// Return to normal attack.
	A_Chase();
}

//==========================================================================
//
//  A_VileStart
//
//  Arch-vile attack start sound.
//
//==========================================================================

void A_VileStart()
{
	PlaySound('vile/start', CHAN_WEAPON);
}

//==========================================================================
//
//  A_VileTarget
//
//  Spawn the hellfire.
//
//==========================================================================

void A_VileTarget()
{
	Actor fog;

	if (!Enemy)
		return;

	A_FaceTarget();

	fog = Spawn(ArchvileFire, Enemy.Origin);

	Instigator = fog;//FIXME!!!!!!!
	fog.Instigator = self;
	fog.Enemy = Enemy;
	fog.SetState(fog.IdleState);
}

//==========================================================================
//
//  A_VileAttack
//
//  Arch-vile attack.
//
//==========================================================================

void A_VileAttack()
{
	Actor fire;

	if (!Enemy)
		return;

	A_FaceTarget();

	if (!CanSee(Enemy))
		return;

	PlaySound('vile/stop', CHAN_WEAPON);
	Enemy.Damage(self, self, 20);
	Enemy.Velocity.z = 1000.0 / Enemy.Mass * 35.0;

	fire = Instigator;//FIXME!!!!!!

	if (!fire)
		return;

	// move the fire between the vile and the player
	fire.Origin.x = Enemy.Origin.x - 24.0 * cos(Angles.yaw);
	fire.Origin.y = Enemy.Origin.y - 24.0 * sin(Angles.yaw);
	fire.RadiusAttack(70, 0, 0);
}

//==========================================================================
//
//  A_Fire
//
//  Keep fire in front of player unless out of sight.
//
//==========================================================================

void A_Fire()
{
	if (!Enemy || !Instigator)
		return;

	// don't move it if the vile lost sight
	if (!Instigator.CanSee(Enemy))
		return;

	UnlinkFromWorld();
	Origin.x = Enemy.Origin.x + 24.0 * cos(Enemy.Angles.yaw);
	Origin.y = Enemy.Origin.y + 24.0 * sin(Enemy.Angles.yaw);
	Origin.z = Enemy.Origin.z;
	LinkToWorld();
}

//==========================================================================
//
//  A_StartFire
//
//  Make fire start sound.
//
//==========================================================================

void A_StartFire()
{
	PlaySound('vile/firestrt', CHAN_VOICE);
	A_Fire();
}

//==========================================================================
//
//  A_FireCrackle
//
//  Fire sound.
//
//==========================================================================

void A_FireCrackle()
{
	PlaySound('vile/firecrkl', CHAN_VOICE);
	A_Fire();
}

//==========================================================================
//
//  A_BrainPain
//
//  Brain pain sound.
//
//==========================================================================

void A_BrainPain()
{
	PlayFullVolumeSound('brain/pain', CHAN_VOICE);
}

//==========================================================================
//
//  A_BrainScream
//
//  Brain death sound, make explosions.
//
//==========================================================================

void A_BrainScream()
{
	TVec org;
	Actor A;

	for (org.x = Origin.x - 196.0; org.x < Origin.x + 320.0; org.x += 8.0)
	{
		org.y = Origin.y - 320.0;
		org.z = 1.0 / 512.0 + Random() * 512.0;
		A = Spawn(Rocket, org);
		A.Velocity.z = Random() * 2.0 * 35.0;

		A.SetState(FindState('S_BRAINEXPLODE1'));

		A.StateTime -= Random() * 0.2;
		if (A.StateTime < 0.1)
			A.StateTime = 0.1;
	}

	PlayFullVolumeSound('brain/death', CHAN_VOICE);
}

//==========================================================================
//
//  A_BrainExplode
//
//  Brain explosions.
//
//==========================================================================

void A_BrainExplode()
{
	TVec org;
	Actor A;

	org.x = Origin.x + (Random() - Random()) * 8.0;
	org.y = Origin.y;
	org.z = 1.0 / 512.0 + Random() * 512.0;
	A = Spawn(Rocket, org);
	A.Velocity.z = Random() * 2.0 * 35.0;

	A.SetState(FindState('S_BRAINEXPLODE1'));

	A.StateTime -= Random() * 0.2;
	if (A.StateTime < 0.1)
		A.StateTime = 0.1;
}

//==========================================================================
//
//  A_BrainDie
//
//  Killed brain, exit level.
//
//==========================================================================

void A_BrainDie()
{
	G_ExitLevel(0);
}

//==========================================================================
//
//  A_BrainAwake
//
//  Init boss spawner.
//
//==========================================================================

void A_BrainAwake()
{
	Actor m;

	// find all the target spots
	numbraintargets = 0;
	FOREACH(Actor, m)
	{
		if (m.Class == BossTarget)
		{
			braintargets[numbraintargets] = m;
			numbraintargets++;
		}
	}
	braintargeton = 0;

	PlayFullVolumeSound('brain/sight', CHAN_VOICE);
}

//==========================================================================
//
//  A_BrainSpit
//
//  Spawn a cube.
//
//==========================================================================

void A_BrainSpit()
{
	Actor targ;
	Actor A;

	brain_easy ^= 1;
	if (Level.Game.gameskill <= sk_easy && (!brain_easy))
		return;

	// shoot a cube at current target
	targ = braintargets[braintargeton];
	braintargeton = (braintargeton + 1) % numbraintargets;

	// spawn brain missile
	A = SpawnMissile(targ, SpawnShot);
	A.Enemy = targ;
	A.ReactionCount = ftoi((targ.Origin.y - Origin.y) /
		A.Velocity.y / A.StateTime);

	PlayFullVolumeSound('brain/spit', CHAN_WEAPON);
}

//==========================================================================
//
//  A_SpawnFly
//
//  Cube flying, spawn monster, when finished.
//
//==========================================================================

void A_SpawnFly()
{
	Actor newmobj;
	Actor fog;
	int r;
	classid type;

	if (--ReactionCount)
		return;	// still flying

	// First spawn teleport fog.
	fog = Spawn(SpawnFire, Enemy.Origin);
	fog.PlaySound('brain/spawn', CHAN_VOICE);

	// Randomly select monster to spawn.
	r = P_Random();

	// Probability distribution (kind of :),
	// decreasing likelihood.
	if (r < 50)
		type = Imp;
	else if (r < 90)
		type = Demon;
	else if (r < 120)
		type = Shadows;
	else if (r < 130)
		type = PainElemental;
	else if (r < 160)
		type = Cacodemon;
	else if (r < 162)
		type = ArchVile;
	else if (r < 172)
		type = Revenant;
	else if (r < 192)
		type = Arachnotron;
	else if (r < 222)
		type = Mancubus;
	else if (r < 246)
		type = HellKnight;
	else
		type = BaronOfHell;

	newmobj = Spawn(type, Enemy.Origin);
	if (newmobj.LookForPlayers(true))
		newmobj.SetState(newmobj.SeeState);

	// telefrag anything in this spot
	newmobj.bTelestomp = true;
	newmobj.TeleportMove(newmobj.Origin);

	// remove self (i.e., cube).
	Remove();
}

//==========================================================================
//
//  A_SpawnSound
//
//  Travelling cube sound.
//
//==========================================================================

void A_SpawnSound()
{
	PlaySound('brain/cube', CHAN_VOICE);
	A_SpawnFly();
}

//==========================================================================
//
//  A_KeenDie
//
//  DOOM II special, map 32. Uses special tag 666.
//
//==========================================================================

void A_KeenDie()
{
	A_Fall();

	// scan the remaining thinkers to see if all Keens are dead
	if (FindOther())
	{
		return;
	}
	DoomLevelInfo(Level).EV_DoDoor(666, 16, 150, 0, 0, VerticalDoor::DOOREV_Open, NULL, none);
}

//==========================================================================
//
//  A_BossDeath
//
//  Possibly trigger special effects if on first boss level
//
//==========================================================================

void A_BossDeath()
{
	name mapname;
	int i;
	Actor Other;
	int args[5];

	mapname = Level.Game.level->MapName;

	if (mapname == 'e1m8')
	{
		if (Class != BaronOfHell)
			return;
	}
	else if (mapname == 'e2m8')
	{
		if (Class != Cyberdemon)
			return;
	}
	else if (mapname == 'e3m8')
	{
		if (Class != SpiderMastermind)
			return;
	}
	else if (mapname == 'e4m6')
	{
		if (Class != Cyberdemon)
			return;
	}
	else if (mapname == 'e4m8')
	{
		if (Class != SpiderMastermind)
			return;
	}
	else if (mapname == 'map07')
	{
		if ((Class != Mancubus) && (Class != Arachnotron))
			return;
	}
	else
	{
		//  Not a boss level
		return;
	}

	// make sure there is a player alive for victory
	for (i = 0; i < MAXPLAYERS; i++)
		if (Level.Game.Players[i] && Level.Game.Players[i].bSpawned && Level.Game.Players[i].Health > 0)
			break;

	if (i == MAXPLAYERS)
		return;	// no one left alive, so do not end game

	// scan the remaining thinkers to see if all bosses are dead
	FOREACH(Actor, Other)
	{
		if (Other != self && Other.Class == Class && Other.Health > 0)
		{
			// other boss not dead
			return;
		}
	}

	// victory!
	if (mapname == 'e1m8')
	{
		DoomLevelInfo(Level).EV_DoFloor(666, 8, 0, 0, 0, FloorMover::FLOOREV_LowerToLowest, NULL);
		return;
	}
	if (mapname == 'e4m6')
	{
		DoomLevelInfo(Level).EV_DoDoor(666, 64, 150, 0, 0, VerticalDoor::DOOREV_Open, NULL, none);
		return;
	}
	if (mapname == 'e4m8')
	{
		DoomLevelInfo(Level).EV_DoFloor(666, 8, 0, 0, 0, FloorMover::FLOOREV_LowerToLowest, NULL);
		return;
	}
	if (mapname == 'map07')
	{
		if (Class == Mancubus)
		{
			DoomLevelInfo(Level).EV_DoFloor(666, 8, 0, 0, 0, FloorMover::FLOOREV_LowerToLowest, NULL);
		}
		else	// mo->Class == MT_BABY
		{
			DoomLevelInfo(Level).EV_DoFloor(667, 8, 0, 0, 0, FloorMover::FLOOREV_RaiseByTexture, NULL);
		}
		return;
	}

	G_ExitLevel(0);
}

//==========================================================================
//
//	OnMapSpawn
//
//==========================================================================

void OnMapSpawn(mthing_t *mthing)
{
	::OnMapSpawn(mthing);
	if (Class == LostSoul)
	{
		bNoGravKill = true;
		bTriggerHappy = true;
	}
	if (Class == BaronOfHell || Class == HellKnight)
	{
		ImuneMissileType = BruiserShot;
	}
	if (Class == Cyberdemon)
	{
		MissileChance = 160.0;
		bTriggerHappy = true;
		bBoss = true;
	}
	if (Class == SpiderMastermind)
 	{
		bTriggerHappy = true;
		bBoss = true;
	}
	if (Class == Revenant)
	{
		bTriggerHappy = true;
		MissileMinRange = 196.0;
	}
	if (Class == ArchVile)
	{
		bNoGrudge = true;
		bNeverTarget = true;
		MissileMaxRange = 14.0 * 64.0;
	}

	if (Class == ItemInvulnerability || Class == ItemInvisibility)
	{
		bNoRespawn = true;
	}
}

//	Since many dehacked patches are mixing weapon and actor states we export
// them all and provide empty action functions.
void A_WeaponReady(){}
void A_Lower(){}
void A_Raise(){}
void A_ReFire(){}
void A_CheckReload(){}
void A_GunFlash(){}
void A_Light0(){}
void A_Light1(){}
void A_Light2(){}
void A_Punch(){}
void A_Saw(){}
void A_FirePistol(){}
void A_FireShotgun(){}
void A_FireShotgun2(){}
void A_OpenShotgun2(){}
void A_LoadShotgun2(){}
void A_CloseShotgun2(){}
void A_FireCGun(){}
void A_FireMissile(){}
void A_FirePlasma(){}
void A_BFGsound(){}
void A_FireBFG(){}

defaultproperties
{
	Health = 0;
	GibsHealth = 0;
	Mass = 0.0;
	SOULSPHERE_MAX = 200;
	SOULSPHERE_HEALTH = 100;
	MEGASPHERE_HEALTH = 200;
	GOTARMOR = "Picked up the armor.";
	GOTMEGA = "Picked up the MegaArmor!";
	GOTHTHBONUS = "Picked up a health bonus.";
	GOTARMBONUS = "Picked up an armor bonus.";
	GOTSTIM = "Picked up a stimpack.";
	GOTMEDINEED = "Picked up a medikit that you REALLY need!";
	GOTMEDIKIT = "Picked up a medikit.";
	GOTSUPER = "Supercharge!";
	GOTBLUECARD = "Picked up a blue keycard.";
	GOTYELWCARD = "Picked up a yellow keycard.";
	GOTREDCARD = "Picked up a red keycard.";
	GOTBLUESKUL = "Picked up a blue skull key.";
	GOTYELWSKUL = "Picked up a yellow skull key.";
	GOTREDSKULL = "Picked up a red skull key.";
	GOTINVUL = "Invulnerability!";
	GOTBERSERK = "Berserk!";
	GOTINVIS = "Partial Invisibility";
	GOTSUIT = "Radiation Shielding Suit";
	GOTMAP = "Computer Area Map";
	GOTVISOR = "Light Amplification Visor";
	GOTMSPHERE = "MegaSphere!";
	GOTCLIP = "Picked up a clip.";
	GOTCLIPBOX = "Picked up a box of bullets.";
	GOTROCKET = "Picked up a rocket.";
	GOTROCKBOX = "Picked up a box of rockets.";
	GOTCELL = "Picked up an energy cell.";
	GOTCELLBOX = "Picked up an energy cell pack.";
	GOTSHELLS = "Picked up 4 shotgun shells.";
	GOTSHELLBOX = "Picked up a box of shotgun shells.";
	GOTBACKPACK = "Picked up a backpack full of ammo!";
	GOTBFG9000 = "You got the BFG9000!  Oh, yes.";
	GOTCHAINGUN = "You got the chaingun!";
	GOTCHAINSAW = "A chainsaw!  Find some meat!";
	GOTLAUNCHER = "You got the rocket launcher!";
	GOTPLASMA = "You got the plasma gun!";
	GOTSHOTGUN = "You got the shotgun!";
	GOTSHOTGUN2 = "You got the super shotgun!";
}
