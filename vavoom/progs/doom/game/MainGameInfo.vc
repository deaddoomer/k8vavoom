//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

#ifndef NO_BOTS
class MainGameInfo : GameInfo;
#else
class MainGameInfoBase : GameInfo;
#endif

const int NUM_SPECIALS = 273;

const int MAX_TAGGED_LINES = 1024;

struct spec_trans_t
{
	int special;
	int arg1;
	int arg2;
	int arg3;
	int arg4;
	int arg5;
	int spac;
	int repeat;
};

struct tagged_line_t
{
	line_t *line;
	int lineTag;
};

enum
{
	PO_ANCHOR_TYPE = 9300,
	PO_SPAWN_TYPE,
	PO_SPAWNCRUSH_TYPE
};

spec_trans_t spec_trans_tab[NUM_SPECIALS];

classid WeaponClasses[DoomDefs::NUMWEAPONS];
int weapon_ammo_type[DoomDefs::NUMWEAPONS];
int WeaponOrder[DoomDefs::NUMWEAPONS];

int terrain_contents[6];
int contents_transluc[6];

#ifndef NO_BOTS
int botskill;
botinfo_t botinfo[30];
#endif

tagged_line_t	TaggedLines[MAX_TAGGED_LINES];
int				TaggedLineCount;

float windTab[3];
float pushTab[5];

int opposite[9];
int diags[4];
float xspeed[8];
float yspeed[8];

int maxammo[DoomDefs::NUMAMMO];
int clipammo[DoomDefs::NUMAMMO];

float air_control;

#ifndef DOOM2
bool shareware;
#endif

bool respawnmonsters;

int INITIAL_HEALTH;
int INITIAL_AMMO;
int GOD_HEALTH;
int BFGCELLS;

//==========================================================================
//
//	Init
//
//==========================================================================

void Init()
{
#ifndef DOOM2
	shareware = !WadLumpPresent('e2m1');
#endif
	InitTranslationTables();
#ifndef NO_BOTS
	InitBotTypes();
#endif
}

//==========================================================================
//
//  InitNewGame
//
//==========================================================================

void InitNewGame(int skill)
{
	respawnmonsters = skill == sk_nightmare || GetCvar('RespawnMonsters');
	nomonsters = GetCvar('NoMonsters');
	fastparm = skill == sk_nightmare || GetCvar('Fast');
}

//==========================================================================
//
//  CreateLevelInfo
//
//==========================================================================

LevelInfo CreateLevelInfo()
{
	return LevelInfo(NewSpecialThinker(DoomLevelInfo));
}

//==========================================================================
//
//  InitBotTypes
//
//==========================================================================

#ifndef NO_BOTS
void InitBotTypes()
{
	SetBotType(0,
		"bot1",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot1\\color\\0\\class\\0\\model\\doomguy\\skin\\green.pcx"
	);
	SetBotType(1,
		"bot2",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot2\\color\\0\\class\\0\\model\\doomguy\\skin\\greenf.pcx"
	);
	SetBotType(2,
		"bot3",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot3\\color\\0\\class\\0\\model\\doomguy\\skin\\camo.pcx"
	);
	SetBotType(3,
		"bot4",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot4\\color\\0\\class\\0\\model\\doomguy\\skin\\camof.pcx"
	);
	SetBotType(4,
		"bot5",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot5\\color\\1\\class\\0\\model\\doomguy\\skin\\black.pcx"
	);
	SetBotType(5,
		"bot6",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot6\\color\\1\\class\\0\\model\\doomguy\\skin\\blackf.pcx"
	);
	SetBotType(6,
		"bot7",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot7\\color\\1\\class\\0\\model\\doomguy\\skin\\white.pcx"
	);
	SetBotType(7,
		"bot8",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot8\\color\\1\\class\\0\\model\\doomguy\\skin\\whitef.pcx"
	);
	SetBotType(8,
		"bot9",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot9\\color\\2\\class\\0\\model\\doomguy\\skin\\brown.pcx"
	);
	SetBotType(9,
		"bot10",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot10\\color\\2\\class\\0\\model\\doomguy\\skin\\brownf.pcx"
	);
	SetBotType(10,
		"bot11",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot11\\color\\3\\class\\0\\model\\doomguy\\skin\\red.pcx"
	);
	SetBotType(11,
		"bot12",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot12\\color\\3\\class\\0\\model\\doomguy\\skin\\redf.pcx"
	);
	SetBotType(12,
		"bot13",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot13\\color\\4\\class\\0\\model\\doomguy\\skin\\pink.pcx"
	);
	SetBotType(13,
		"bot14",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot14\\color\\4\\class\\0\\model\\doomguy\\skin\\pinkf.pcx"
	);
	SetBotType(14,
		"bot15",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot15\\color\\5\\class\\0\\model\\doomguy\\skin\\blue.pcx"
	);
	SetBotType(15,
		"bot16",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot16\\color\\5\\class\\0\\model\\doomguy\\skin\\bluef.pcx"
	);
	SetBotType(16,
		"bot17",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot17\\color\\5\\class\\0\\model\\doomguy\\skin\\lgtblue.pcx"
	);
	SetBotType(17,
		"bot18",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot18\\color\\5\\class\\0\\model\\doomguy\\skin\\lgtbluef.pcx"
	);
	SetBotType(18,
		"bot19",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot19\\color\\5\\class\\0\\model\\doomguy\\skin\\navy.pcx"
	);
	SetBotType(19,
		"bot20",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot20\\color\\5\\class\\0\\model\\doomguy\\skin\\navyf.pcx"
	);
	SetBotType(20,
		"bot21",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot21\\color\\5\\class\\0\\model\\doomguy\\skin\\indigo.pcx"
	);
	SetBotType(21,
		"bot22",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot22\\color\\5\\class\\0\\model\\doomguy\\skin\\indigof.pcx"
	);
	SetBotType(22,
		"bot23",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot23\\color\\6\\class\\0\\model\\doomguy\\skin\\violet.pcx"
	);
	SetBotType(23,
		"bot24",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot24\\color\\6\\class\\0\\model\\doomguy\\skin\\violetf.pcx"
	);
	SetBotType(24,
		"bot25",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot25\\color\\6\\class\\0\\model\\doomguy\\skin\\purple.pcx"
	);
	SetBotType(25,
		"bot26",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot26\\color\\6\\class\\0\\model\\doomguy\\skin\\purplef.pcx"
	);
	SetBotType(26,
		"bot27",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot27\\color\\7\\class\\0\\model\\doomguy\\skin\\orange.pcx"
	);
	SetBotType(27,
		"bot28",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot28\\color\\7\\class\\0\\model\\doomguy\\skin\\orangef.pcx"
	);
	SetBotType(28,
		"bot29",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot29\\color\\7\\class\\0\\model\\doomguy\\skin\\yellow.pcx"
	);
	SetBotType(29,
		"bot30",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot30\\color\\7\\class\\0\\model\\doomguy\\skin\\yellowf.pcx"
	);
}

//==========================================================================
//
//  SetBotType
//
//==========================================================================

void SetBotType(int i, string Name, int accuracy, int intelect, int evade,
	int anticip, int reaction, string userinfo)
{
	botinfo[i].Name = Name;
	botinfo[i].accuracy = accuracy;
	botinfo[i].intelect = intelect;
	botinfo[i].evade = evade;
	botinfo[i].anticip = anticip;
	botinfo[i].reaction = reaction;
	botinfo[i].userinfo = userinfo;
}
#endif

//==========================================================================
//
//	InitTranslationTables
//
//==========================================================================

void InitTranslationTables()
{
	//  0
	SetLineTrans(1, LNSPEC_DoorRaise, 0, 16, 150, 0, 0, SPAC_USE, true);
	SetLineTrans(2, LNSPEC_DoorOpen, -1, 16, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(3, LNSPEC_DoorClose, -1, 16, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(4, LNSPEC_DoorRaise, -1, 16, 150, 0, 0, SPAC_CROSS, false);
	SetLineTrans(5, LNSPEC_FloorRaiseToLowestCeiling, -1, 8, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(6, LNSPEC_CeilingCrushAndRaiseA, -1, 16, 16, 10, 0, SPAC_CROSS, false);
	SetLineTrans(7, LNSPEC_StairsBuildUpDoom, -1, 2, 8, 0, 0, SPAC_USE, false);
	SetLineTrans(8, LNSPEC_StairsBuildUpDoom, -1, 2, 8, 0, 0, SPAC_CROSS, false);
	SetLineTrans(9, LNSPEC_FloorDonut, -1, 4, 4, 0, 0, SPAC_USE, false);

	SetLineTrans(10, LNSPEC_PlatDownWaitUpStayLip, -1, 32, 105, 0, 0, SPAC_CROSS, false);
	SetLineTrans(11, LNSPEC_ExitNormal, -1, 0, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(12, LNSPEC_LightMaxNeighbor, -1, 0, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(13, LNSPEC_LightChangeToValue, -1, 255, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(14, LNSPEC_FloorRaiseByValueChangeTex, -1, 4, 4, 0, 0, SPAC_USE, false);
	SetLineTrans(15, LNSPEC_FloorRaiseByValueChangeTex, -1, 4, 3, 0, 0, SPAC_USE, false);
	SetLineTrans(16, LNSPEC_DoorCloseWaitOpen, -1, 16, 240, 0, 0, SPAC_CROSS, false);
	SetLineTrans(17, LNSPEC_LightStrobeDoom, -1, 5, 35, 0, 0, SPAC_CROSS, false);
	SetLineTrans(18, LNSPEC_FloorRaiseToNearest, -1, 8, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(19, LNSPEC_FloorLowerToHighest, -1, 8, 128, 0, 0, SPAC_CROSS, false);

	SetLineTrans(20, LNSPEC_FloorRaiseToNearestChange, -1, 4, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(21, LNSPEC_PlatDownWaitUpStayLip, -1, 32, 105, 0, 0, SPAC_USE, false);
	SetLineTrans(22, LNSPEC_FloorRaiseToNearestChange, -1, 4, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(23, LNSPEC_FloorLowerToLowest, -1, 8, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(24, LNSPEC_FloorRaiseToLowestCeiling, -1, 8, 0, 0, 0, SPAC_IMPACT, false);
	SetLineTrans(25, LNSPEC_CeilingCrushAndRaiseA, -1, 8, 8, 10, 0, SPAC_CROSS, false);
	SetLineTrans(26, LNSPEC_DoorLockedRaise, 0, 16, 150, 2 | 128, 0, SPAC_USE, true);
	SetLineTrans(27, LNSPEC_DoorLockedRaise, 0, 16, 150, 3 | 128, 0, SPAC_USE, true);
	SetLineTrans(28, LNSPEC_DoorLockedRaise, 0, 16, 150, 1 | 128, 0, SPAC_USE, true);
	SetLineTrans(29, LNSPEC_DoorRaise, -1, 16, 150, 0, 0, SPAC_USE, false);

	SetLineTrans(30, LNSPEC_FloorRaiseByTexture, -1, 8, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(31, LNSPEC_DoorOpen, 0, 16, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(32, LNSPEC_DoorLockedRaise, 0, 16, 0, 2 | 128, 0, SPAC_USE, false);
	SetLineTrans(33, LNSPEC_DoorLockedRaise, 0, 16, 0, 1 | 128, 0, SPAC_USE, false);
	SetLineTrans(34, LNSPEC_DoorLockedRaise, 0, 16, 0, 3 | 128, 0, SPAC_USE, false);
	SetLineTrans(35, LNSPEC_LightChangeToValue, -1, 35, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(36, LNSPEC_FloorLowerToHighest, -1, 32, 136, 0, 0, SPAC_CROSS, false);
	SetLineTrans(37, LNSPEC_FloorLowerToLowestChange, -1, 8, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(38, LNSPEC_FloorLowerToLowest, -1, 8, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(39, LNSPEC_Teleport, 0, -1, 0, 0, 0, SPAC_CROSS, false);

	SetLineTrans(40, LNSPEC_FloorAndCeilingLowerRaise, -1, 8, 8, 0, 0, SPAC_CROSS, false);
	SetLineTrans(41, LNSPEC_CeilingLowerToFloor, -1, 8, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(42, LNSPEC_DoorClose, -1, 16, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(43, LNSPEC_CeilingLowerToFloor, -1, 8, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(44, LNSPEC_CeilingLowerAndCrush, -1, 8, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(45, LNSPEC_FloorLowerToHighest, -1, 8, 128, 0, 0, SPAC_USE, true);
	SetLineTrans(46, LNSPEC_DoorOpen, -1, 16, 0, 0, 0, SPAC_IMPACT, true);
	SetLineTrans(47, LNSPEC_FloorRaiseToNearestChange, -1, 4, 0, 0, 0, SPAC_IMPACT, false);
	SetLineTrans(48, LNSPEC_ScrollTextureLeft, 64, 0, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(49, LNSPEC_CeilingCrushAndRaiseA, -1, 8, 8, 10, 0, SPAC_USE, false);

	SetLineTrans(50, LNSPEC_DoorClose, -1, 16, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(51, LNSPEC_ExitSecret, -1, 0, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(52, LNSPEC_ExitNormal, -1, 0, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(53, LNSPEC_PlatPerpetualRaiseLip, -1, 8, 105, 0, 0, SPAC_CROSS, false);
	SetLineTrans(54, LNSPEC_PlatStop, -1, 0, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(55, LNSPEC_FloorRaiseAndCrush, -1, 8, 10, 0, 0, SPAC_USE, false);
	SetLineTrans(56, LNSPEC_FloorRaiseAndCrush, -1, 8, 10, 0, 0, SPAC_CROSS, false);
	SetLineTrans(57, LNSPEC_CeilingCrushStop, -1, 0, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(58, LNSPEC_FloorRaiseByValue, -1, 8, 24, 0, 0, SPAC_CROSS, false);
	SetLineTrans(59, LNSPEC_FloorRaiseByValueChange, -1, 8, 24, 0, 0, SPAC_CROSS, false);

	SetLineTrans(60, LNSPEC_FloorLowerToLowest, -1, 8, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(61, LNSPEC_DoorOpen, -1, 16, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(62, LNSPEC_PlatDownWaitUpStayLip, -1, 32, 105, 0, 0, SPAC_USE, true);
	SetLineTrans(63, LNSPEC_DoorRaise, -1, 16, 150, 0, 0, SPAC_USE, true);
	SetLineTrans(64, LNSPEC_FloorRaiseToLowestCeiling, -1, 8, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(65, LNSPEC_FloorRaiseAndCrush, -1, 8, 10, 0, 0, SPAC_USE, true);
	SetLineTrans(66, LNSPEC_FloorRaiseByValueChangeTex, -1, 4, 3, 0, 0, SPAC_USE, true);
	SetLineTrans(67, LNSPEC_FloorRaiseByValueChangeTex, -1, 4, 4, 0, 0, SPAC_USE, true);
	SetLineTrans(68, LNSPEC_FloorRaiseToNearestChange, -1, 4, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(69, LNSPEC_FloorRaiseToNearest, -1, 8, 0, 0, 0, SPAC_USE, true);

	SetLineTrans(70, LNSPEC_FloorLowerToHighest, -1, 32, 136, 0, 0, SPAC_USE, true);
	SetLineTrans(71, LNSPEC_FloorLowerToHighest, -1, 32, 136, 0, 0, SPAC_USE, false);
	SetLineTrans(72, LNSPEC_CeilingLowerAndCrush, -1, 8, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(73, LNSPEC_CeilingCrushAndRaiseA, -1, 8, 8, 10, 0, SPAC_CROSS, true);
	SetLineTrans(74, LNSPEC_CeilingCrushStop, -1, 0, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(75, LNSPEC_DoorClose, -1, 16, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(76, LNSPEC_DoorCloseWaitOpen, -1, 16, 240, 0, 0, SPAC_CROSS, true);
	SetLineTrans(77, LNSPEC_CeilingCrushAndRaiseA, -1, 16, 16, 10, 0, SPAC_CROSS, true);
	SetLineTrans(78, LNSPEC_FloorTransferNumeric, -1, 0, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(79, LNSPEC_LightChangeToValue, -1, 35, 0, 0, 0, SPAC_CROSS, true);

	SetLineTrans(80, LNSPEC_LightMaxNeighbor, -1, 0, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(81, LNSPEC_LightChangeToValue, -1, 255, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(82, LNSPEC_FloorLowerToLowest, -1, 8, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(83, LNSPEC_FloorLowerToHighest, -1, 8, 128, 0, 0, SPAC_CROSS, true);
	SetLineTrans(84, LNSPEC_FloorLowerToLowestChange, -1, 8, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(85, LNSPEC_ScrollTextureRight, 64, 0, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(86, LNSPEC_DoorOpen, -1, 16, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(87, LNSPEC_PlatPerpetualRaiseLip, -1, 8, 105, 0, 0, SPAC_CROSS, true);
	SetLineTrans(88, LNSPEC_PlatDownWaitUpStayLip, -1, 32, 105, 0, 0, SPAC_CROSS, true);
	SetLineTrans(89, LNSPEC_PlatStop, -1, 0, 0, 0, 0, SPAC_CROSS, true);

	SetLineTrans(90, LNSPEC_DoorRaise, -1, 16, 150, 0, 0, SPAC_CROSS, true);
	SetLineTrans(91, LNSPEC_FloorRaiseToLowestCeiling, -1, 8, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(92, LNSPEC_FloorRaiseByValue, -1, 8, 24, 0, 0, SPAC_CROSS, true);
	SetLineTrans(93, LNSPEC_FloorRaiseByValueChange, -1, 8, 24, 0, 0, SPAC_CROSS, true);
	SetLineTrans(94, LNSPEC_FloorRaiseAndCrush, -1, 8, 10, 0, 0, SPAC_CROSS, true);
	SetLineTrans(95, LNSPEC_FloorRaiseToNearestChange, -1, 4, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(96, LNSPEC_FloorRaiseByTexture, -1, 8, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(97, LNSPEC_Teleport, 0, -1, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(98, LNSPEC_FloorLowerToHighest, -1, 32, 136, 0, 0, SPAC_CROSS, true);
	SetLineTrans(99, LNSPEC_DoorLockedRaise, -1, 64, 0, 2 | 128, 0, SPAC_USE, true);

	SetLineTrans(100, LNSPEC_StairsBuildUpDoom, -1, 32, 16, 0, 0, SPAC_CROSS, false);
	SetLineTrans(101, LNSPEC_FloorRaiseToLowestCeiling, -1, 8, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(102, LNSPEC_FloorLowerToHighest, -1, 8, 128, 0, 0, SPAC_USE, false);
	SetLineTrans(103, LNSPEC_DoorOpen, -1, 16, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(104, LNSPEC_LightMinNeighbor, -1, 0, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(105, LNSPEC_DoorRaise, -1, 64, 150, 0, 0, SPAC_CROSS, true);
	SetLineTrans(106, LNSPEC_DoorOpen, -1, 64, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(107, LNSPEC_DoorClose, -1, 64, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(108, LNSPEC_DoorRaise, -1, 64, 150, 0, 0, SPAC_CROSS, false);
	SetLineTrans(109, LNSPEC_DoorOpen, -1, 64, 0, 0, 0, SPAC_CROSS, false);

	SetLineTrans(110, LNSPEC_DoorClose, -1, 64, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(111, LNSPEC_DoorRaise, -1, 64, 150, 0, 0, SPAC_USE, false);
	SetLineTrans(112, LNSPEC_DoorOpen, -1, 64, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(113, LNSPEC_DoorClose, -1, 64, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(114, LNSPEC_DoorRaise, -1, 64, 150, 0, 0, SPAC_USE, true);
	SetLineTrans(115, LNSPEC_DoorOpen, -1, 64, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(116, LNSPEC_DoorClose, -1, 64, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(117, LNSPEC_DoorRaise, 0, 64, 150, 0, 0, SPAC_USE, true);
	SetLineTrans(118, LNSPEC_DoorOpen, 0, 64, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(119, LNSPEC_FloorRaiseToNearest, -1, 8, 0, 0, 0, SPAC_CROSS, false);

	SetLineTrans(120, LNSPEC_PlatDownWaitUpStayLip, -1, 64, 105, 0, 0, SPAC_CROSS, true);
	SetLineTrans(121, LNSPEC_PlatDownWaitUpStayLip, -1, 64, 105, 0, 0, SPAC_CROSS, false);
	SetLineTrans(122, LNSPEC_PlatDownWaitUpStayLip, -1, 64, 105, 0, 0, SPAC_USE, false);
	SetLineTrans(123, LNSPEC_PlatDownWaitUpStayLip, -1, 64, 105, 0, 0, SPAC_USE, true);
	SetLineTrans(124, LNSPEC_ExitSecret, -1, 0, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(125, LNSPEC_Teleport, 0, -1, 0, 0, 0, SPAC_MCROSS, false);
	SetLineTrans(126, LNSPEC_Teleport, 0, -1, 0, 0, 0, SPAC_MCROSS, true);
	SetLineTrans(127, LNSPEC_StairsBuildUpDoom, -1, 32, 16, 0, 0, SPAC_USE, false);
	SetLineTrans(128, LNSPEC_FloorRaiseToNearest, -1, 8, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(129, LNSPEC_FloorRaiseToNearest, -1, 32, 0, 0, 0, SPAC_CROSS, true);

	SetLineTrans(130, LNSPEC_FloorRaiseToNearest, -1, 32, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(131, LNSPEC_FloorRaiseToNearest, -1, 32, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(132, LNSPEC_FloorRaiseToNearest, -1, 32, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(133, LNSPEC_DoorLockedRaise, -1, 64, 0, 2 | 128, 0, SPAC_USE, false);
	SetLineTrans(134, LNSPEC_DoorLockedRaise, -1, 64, 0, 1 | 128, 0, SPAC_USE, true);
	SetLineTrans(135, LNSPEC_DoorLockedRaise, -1, 64, 0, 1 | 128, 0, SPAC_USE, false);
	SetLineTrans(136, LNSPEC_DoorLockedRaise, -1, 64, 0, 3 | 128, 0, SPAC_USE, true);
	SetLineTrans(137, LNSPEC_DoorLockedRaise, -1, 64, 0, 3 | 128, 0, SPAC_USE, false);
	SetLineTrans(138, LNSPEC_LightChangeToValue, -1, 255, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(139, LNSPEC_LightChangeToValue, -1, 35, 0, 0, 0, SPAC_USE, true);

	SetLineTrans(140, LNSPEC_FloorRaiseByValueTimes8, -1, 8, 64, 0, 0, SPAC_USE, false);
	SetLineTrans(141, LNSPEC_CeilingCrushAndRaiseSilentA, -1, 8, 8, 10, 0, SPAC_CROSS, false);
	SetLineTrans(142, LNSPEC_FloorRaiseByValueTimes8, -1, 8, 64, 0, 0, SPAC_CROSS, false);
	SetLineTrans(143, LNSPEC_FloorRaiseByValueChangeTex, -1, 4, 3, 0, 0, SPAC_CROSS, false);
	SetLineTrans(144, LNSPEC_FloorRaiseByValueChangeTex, -1, 4, 4, 0, 0, SPAC_CROSS, false);
	SetLineTrans(145, LNSPEC_CeilingLowerToFloor, -1, 8, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(146, LNSPEC_FloorDonut, -1, 4, 4, 0, 0, SPAC_CROSS, false);
	SetLineTrans(147, LNSPEC_FloorRaiseByValueTimes8, -1, 8, 64, 0, 0, SPAC_CROSS, true);
	SetLineTrans(148, LNSPEC_FloorRaiseByValueChangeTex, -1, 4, 3, 0, 0, SPAC_CROSS, true);
	SetLineTrans(149, LNSPEC_FloorRaiseByValueChangeTex, -1, 4, 4, 0, 0, SPAC_CROSS, true);

	SetLineTrans(150, LNSPEC_CeilingCrushAndRaiseSilentA, -1, 8, 8, 10, 0, SPAC_CROSS, true);
	SetLineTrans(151, LNSPEC_FloorAndCeilingLowerRaise, -1, 8, 8, 0, 0, SPAC_CROSS, true);
	SetLineTrans(152, LNSPEC_CeilingLowerToFloor, -1, 8, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(153, LNSPEC_FloorTransferTrigger, -1, 0, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(154, LNSPEC_FloorTransferTrigger, -1, 0, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(155, LNSPEC_FloorDonut, -1, 4, 4, 0, 0, SPAC_CROSS, true);
	SetLineTrans(156, LNSPEC_LightStrobeDoom, -1, 5, 35, 0, 0, SPAC_CROSS, true);
	SetLineTrans(157, LNSPEC_LightMinNeighbor, -1, 0, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(158, LNSPEC_FloorRaiseByTexture, -1, 8, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(159, LNSPEC_FloorLowerToLowestChange, -1, 8, 0, 0, 0, SPAC_USE, false);

	SetLineTrans(160, LNSPEC_FloorRaiseByValueChange, -1, 8, 24, 0, 0, SPAC_USE, false);
	SetLineTrans(161, LNSPEC_FloorRaiseByValue, -1, 8, 24, 0, 0, SPAC_USE, false);
	SetLineTrans(162, LNSPEC_PlatPerpetualRaiseLip, -1, 8, 105, 0, 0, SPAC_USE, false);
	SetLineTrans(163, LNSPEC_PlatStop, -1, 0, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(164, LNSPEC_CeilingCrushAndRaiseA, -1, 16, 16, 10, 0, SPAC_USE, false);
	SetLineTrans(165, LNSPEC_CeilingCrushAndRaiseSilentA, -1, 8, 8, 10, 0, SPAC_USE, false);
	SetLineTrans(166, LNSPEC_FloorAndCeilingLowerRaise, -1, 8, 8, 0, 0, SPAC_USE, false);
	SetLineTrans(167, LNSPEC_CeilingLowerAndCrush, -1, 8, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(168, LNSPEC_CeilingCrushStop, -1, 0, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(169, LNSPEC_LightMaxNeighbor, -1, 0, 0, 0, 0, SPAC_USE, false);

	SetLineTrans(170, LNSPEC_LightChangeToValue, -1, 35, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(171, LNSPEC_LightChangeToValue, -1, 255, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(172, LNSPEC_LightStrobeDoom, -1, 5, 35, 0, 0, SPAC_USE, false);
	SetLineTrans(173, LNSPEC_LightMinNeighbor, -1, 0, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(174, LNSPEC_Teleport, 0, -1, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(175, LNSPEC_DoorCloseWaitOpen, -1, 8, 240, 0, 0, SPAC_USE, false);
	SetLineTrans(176, LNSPEC_FloorRaiseByTexture, -1, 8, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(177, LNSPEC_FloorLowerToLowestChange, -1, 8, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(178, LNSPEC_FloorRaiseByValueTimes8, -1, 8, 64, 0, 0, SPAC_USE, true);
	SetLineTrans(179, LNSPEC_FloorRaiseByValueChange, -1, 8, 24, 0, 0, SPAC_USE, true);

	SetLineTrans(180, LNSPEC_FloorRaiseByValue, -1, 8, 24, 0, 0, SPAC_USE, true);
	SetLineTrans(181, LNSPEC_PlatPerpetualRaiseLip, -1, 8, 105, 0, 0, SPAC_USE, true);
	SetLineTrans(182, LNSPEC_PlatStop, -1, 0, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(183, LNSPEC_CeilingCrushAndRaiseA, -1, 16, 16, 10, 0, SPAC_USE, true);
	SetLineTrans(184, LNSPEC_CeilingCrushAndRaiseA, -1, 8, 8, 10, 0, SPAC_USE, true);
	SetLineTrans(185, LNSPEC_CeilingCrushAndRaiseSilentA, -1, 8, 8, 10, 0, SPAC_USE, true);
	SetLineTrans(186, LNSPEC_FloorAndCeilingLowerRaise, -1, 8, 8, 0, 0, SPAC_USE, true);
	SetLineTrans(187, LNSPEC_CeilingLowerAndCrush, -1, 8, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(188, LNSPEC_CeilingCrushStop, -1, 0, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(189, LNSPEC_FloorTransferTrigger, -1, 0, 0, 0, 0, SPAC_USE, false);

	SetLineTrans(190, LNSPEC_FloorTransferTrigger, -1, 0, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(191, LNSPEC_FloorDonut, -1, 4, 4, 0, 0, SPAC_USE, true);
	SetLineTrans(192, LNSPEC_LightMaxNeighbor, -1, 0, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(193, LNSPEC_LightStrobeDoom, -1, 5, 35, 0, 0, SPAC_USE, true);
	SetLineTrans(194, LNSPEC_LightMinNeighbor, -1, 0, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(195, LNSPEC_Teleport, 0, -1, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(196, LNSPEC_DoorCloseWaitOpen, -1, 16, 240, 0, 0, SPAC_USE, true);
	SetLineTrans(197, LNSPEC_ExitNormal, 0, 0, 0, 0, 0, SPAC_IMPACT, false);
	SetLineTrans(198, LNSPEC_ExitSecret, 0, 0, 0, 0, 0, SPAC_IMPACT, false);
	SetLineTrans(199, LNSPEC_CeilingLowerToLowest, -1, 8, 0, 0, 0, SPAC_CROSS, false);

	SetLineTrans(200, LNSPEC_CeilingLowerToHighestFloor, -1, 8, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(201, LNSPEC_CeilingLowerToLowest, -1, 8, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(202, LNSPEC_CeilingLowerToHighestFloor, -1, 8, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(203, LNSPEC_CeilingLowerToLowest, -1, 8, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(204, LNSPEC_CeilingLowerToHighestFloor, -1, 8, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(205, LNSPEC_CeilingLowerToLowest, -1, 8, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(206, LNSPEC_CeilingLowerToHighestFloor, -1, 8, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(207, LNSPEC_TeleportNoFog, 0, 0, -1, 0, 0, SPAC_CROSS, false);
	SetLineTrans(208, LNSPEC_TeleportNoFog, 0, 0, -1, 0, 0, SPAC_CROSS, true);
	SetLineTrans(209, LNSPEC_TeleportNoFog, 0, 0, -1, 0, 0, SPAC_USE, false);

	SetLineTrans(210, LNSPEC_TeleportNoFog, 0, 0, -1, 0, 0, SPAC_USE, true);
	SetLineTrans(211, LNSPEC_PlatToggle, -1, 0, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(212, LNSPEC_PlatToggle, -1, 0, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(213, LNSPEC_TransferFloorLight, -1, 0, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(214, LNSPEC_ScrollCeiling, -1, 6, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(215, LNSPEC_ScrollFloor, -1, 6, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(216, LNSPEC_ScrollFloor, -1, 6, 1, 0, 0, SPAC_CROSS, false);
	SetLineTrans(217, LNSPEC_ScrollFloor, -1, 6, 2, 0, 0, SPAC_CROSS, false);
	SetLineTrans(218, LNSPEC_ScrollTextureModel, -1, 2, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(219, LNSPEC_FloorLowerToNearest, -1, 8, 0, 0, 0, SPAC_CROSS, false);

	SetLineTrans(220, LNSPEC_FloorLowerToNearest, -1, 8, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(221, LNSPEC_FloorLowerToNearest, -1, 8, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(222, LNSPEC_FloorLowerToNearest, -1, 8, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(223, LNSPEC_SectorSetFriction, -1, 0, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(224, LNSPEC_SectorSetWind, -1, 0, 0, 1, 0, SPAC_CROSS, false);
	SetLineTrans(225, LNSPEC_SectorSetCurrent, -1, 0, 0, 1, 0, SPAC_CROSS, false);
	SetLineTrans(226, LNSPEC_PointPushSetForce, -1, 0, 0, 1, 0, SPAC_CROSS, false);
	SetLineTrans(227, LNSPEC_ElevatorRaiseToNearest, -1, 32, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(228, LNSPEC_ElevatorRaiseToNearest, -1, 32, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(229, LNSPEC_ElevatorRaiseToNearest, -1, 32, 0, 0, 0, SPAC_USE, false);

	SetLineTrans(230, LNSPEC_ElevatorRaiseToNearest, -1, 32, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(231, LNSPEC_ElevatorLowerToNearest, -1, 32, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(232, LNSPEC_ElevatorLowerToNearest, -1, 32, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(233, LNSPEC_ElevatorLowerToNearest, -1, 32, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(234, LNSPEC_ElevatorLowerToNearest, -1, 32, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(235, LNSPEC_ElevatorMoveToFloor, -1, 32, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(236, LNSPEC_ElevatorMoveToFloor, -1, 32, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(237, LNSPEC_ElevatorMoveToFloor, -1, 32, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(238, LNSPEC_ElevatorMoveToFloor, -1, 32, 0, 0, 0, SPAC_USE, true);
	SetLineTrans(239, LNSPEC_FloorTransferNumeric, -1, 0, 0, 0, 0, SPAC_CROSS, false);

	SetLineTrans(240, LNSPEC_FloorTransferNumeric, -1, 0, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(241, LNSPEC_FloorTransferNumeric, -1, 0, 0, 0, 0, SPAC_USE, false);
	SetLineTrans(242, LNSPEC_TransferHeights, -1, 0, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(243, LNSPEC_TeleportLine, -1, -1, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(244, LNSPEC_TeleportLine, -1, -1, 0, 0, 0, SPAC_CROSS, true);
	SetLineTrans(245, LNSPEC_ScrollCeiling, -1, 5, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(246, LNSPEC_ScrollFloor, -1, 5, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(247, LNSPEC_ScrollFloor, -1, 5, 1, 0, 0, SPAC_CROSS, false);
	SetLineTrans(248, LNSPEC_ScrollFloor, -1, 5, 2, 0, 0, SPAC_CROSS, false);
	SetLineTrans(249, LNSPEC_ScrollTextureModel, -1, 1, 0, 0, 0, SPAC_CROSS, false);

	SetLineTrans(250, LNSPEC_ScrollCeiling, -1, 4, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(251, LNSPEC_ScrollFloor, -1, 4, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(252, LNSPEC_ScrollFloor, -1, 4, 1, 0, 0, SPAC_CROSS, false);
	SetLineTrans(253, LNSPEC_ScrollFloor, -1, 4, 2, 0, 0, SPAC_CROSS, false);
	SetLineTrans(254, LNSPEC_ScrollTextureModel, -1, 0, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(255, LNSPEC_ScrollTextureOffsets, 0, 0, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(256, LNSPEC_StairsBuildUpDoom, -1, 2, 8, 0, 0, SPAC_CROSS, true);
	SetLineTrans(257, LNSPEC_StairsBuildUpDoom, -1, 32, 16, 0, 0, SPAC_CROSS, true);
	SetLineTrans(258, LNSPEC_StairsBuildUpDoom, -1, 2, 8, 0, 0, SPAC_USE, true);
	SetLineTrans(259, LNSPEC_StairsBuildUpDoom, -1, 32, 16, 0, 0, SPAC_USE, true);

	SetLineTrans(260, LNSPEC_LineTranslucent, -1, 128, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(261, LNSPEC_TransferCeilingLight, -1, 0, 0, 0, 0, SPAC_CROSS, false);
	SetLineTrans(262, LNSPEC_TeleportLine, -1, -1, 1, 0, 0, SPAC_CROSS, false);
	SetLineTrans(263, LNSPEC_TeleportLine, -1, -1, 1, 0, 0, SPAC_CROSS, true);
	SetLineTrans(264, LNSPEC_TeleportLine, -1, -1, 1, 0, 0, SPAC_MCROSS, false);
	SetLineTrans(265, LNSPEC_TeleportLine, -1, -1, 1, 0, 0, SPAC_MCROSS, true);
	SetLineTrans(266, LNSPEC_TeleportLine, -1, -1, 0, 0, 0, SPAC_MCROSS, false);
	SetLineTrans(267, LNSPEC_TeleportLine, -1, -1, 0, 0, 0, SPAC_MCROSS, true);
	SetLineTrans(268, LNSPEC_TeleportNoFog, 0, 0, -1, 0, 0, SPAC_MCROSS, false);
	SetLineTrans(269, LNSPEC_TeleportNoFog, 0, 0, -1, 0, 0, SPAC_MCROSS, true);

	//	270
	SetLineTrans(271, 0, -1, 255, 0, 0, 0, SPAC_CROSS, false); // LNSPEC_StaticInit
	SetLineTrans(272, 0, -1, 255, 1, 0, 0, SPAC_CROSS, false); // LNSPEC_StaticInit
}

//==========================================================================
//
//	SetLineTrans
//
//==========================================================================

void SetLineTrans(int i, int special, int arg1, int arg2, int arg3,
	int arg4, int arg5, int spac, int repeat)
{
	spec_trans_tab[i].special = special;
	spec_trans_tab[i].arg1 = arg1;
	spec_trans_tab[i].arg2 = arg2;
	spec_trans_tab[i].arg3 = arg3;
	spec_trans_tab[i].arg4 = arg4;
	spec_trans_tab[i].arg5 = arg5;
	spec_trans_tab[i].spac = spac;
	spec_trans_tab[i].repeat = repeat;
}

//==========================================================================
//
//  TranslateLine
//
//==========================================================================

void TranslateLine(Level InLevel, line_t* line)
{
	int			OldSpec;
	int			OldTag;
	int			OldFlags;

	OldSpec = line->special;
	OldTag = line->arg1;
	OldFlags = line->flags;

	//	Clear unknown flags.
	line->flags &= 0x01ff;

	//	For BOOM compatibility all lines needs to have it's ID same as tag.
	if (OldTag)
	{
		line->LineTag = OldTag;
	}

	if (!line->special)
	{
		return;
	}

	//	Handle Boom's generalized types.
	if (OldSpec > 0x2F80)
	{
		//	Activation flags.
		switch (OldSpec & 0x0006)
		{
		case 0:
			line->flags |= SPAC_CROSS << ML_SPAC_SHIFT;
			break;

		case 2:
		case 6:
			if (OldFlags & 0x0200)
				line->flags |= SPAC_USETHROUGH << ML_SPAC_SHIFT;
			else
				line->flags |= SPAC_USE << ML_SPAC_SHIFT;
			break;

		case 4:
			line->flags |= SPAC_IMPACT << ML_SPAC_SHIFT;
			break;
		}
		if (OldSpec & 1)
		{
			line->flags |= ML_REPEAT_SPECIAL;
		}

		//	We treat push triggers like switch triggers with zero tags.
		if ((OldSpec & 0x0006) == 6)
		{
			line->arg1 = 0;
		}
		else
		{
			line->arg1 = OldTag;
		}

		if (OldSpec <= 0x3000)
		{
			//	Generalized crusher (tag, dnspeed, upspeed, silent, damage)
			line->special = LNSPEC_CeilingGenericCrush;
			if (OldSpec & 0x0020)
			{
				line->flags |= ML_MONSTERSCANACTIVATE;
			}
			switch (OldSpec & 0x0018)
			{
			case 0x0000:	line->arg2 = 8;		break;
			case 0x0008:	line->arg2 = 16;	break;
			case 0x0010:	line->arg2 = 32;	break;
			case 0x0018:	line->arg2 = 64;	break;
			}
			line->arg3 = line->arg2;
			line->arg4 = (OldSpec & 0x0040) >> 6;
			line->arg5 = 10;
		}
		else if (OldSpec <= 0x3400)
		{
			//	Generalized stairs (tag, speed, step, dir/igntxt, reset)
			line->special = LNSPEC_StairsGeneric;
			if (OldSpec & 0x0020)
			{
				line->flags |= ML_MONSTERSCANACTIVATE;
			}
			switch (OldSpec & 0x0018)
			{
			case 0x0000:	line->arg2 = 2;		break;
			case 0x0008:	line->arg2 = 4;		break;
			case 0x0010:	line->arg2 = 16;	break;
			case 0x0018:	line->arg2 = 32;	break;
			}
			switch (OldSpec & 0x00c0)
			{
			case 0x0000:	line->arg3 = 4;		break;
			case 0x0040:	line->arg3 = 8;		break;
			case 0x0080:	line->arg3 = 16;	break;
			case 0x00c0:	line->arg3 = 24;	break;
			}
			line->arg4 = (OldSpec & 0x0300) >> 8;
			line->arg5 = 0;
		}
		else if (OldSpec <= 0x3800)
		{
			//	Generalized lift (tag, speed, delay, target, height)
			line->special = LNSPEC_PlatGeneric;
			if (OldSpec & 0x0020)
			{
				line->flags |= ML_MONSTERSCANACTIVATE;
			}
			switch (OldSpec & 0x0018)
			{
			case 0x0000:	line->arg2 = 16;	break;
			case 0x0008:	line->arg2 = 32;	break;
			case 0x0010:	line->arg2 = 64;	break;
			case 0x0018:	line->arg2 = 128;	break;
			}
			switch (OldSpec & 0x00c0)
			{
			case 0x0000:	line->arg3 = 8;		break;
			case 0x0040:	line->arg3 = 24;	break;
			case 0x0080:	line->arg3 = 40;	break;
			case 0x00c0:	line->arg3 = 80;	break;
			}
			line->arg4 = ((OldSpec & 0x0300) >> 8) + 1;
			line->arg5 = 0;
		}
		else if (OldSpec <= 0x3c00)
		{
			//	Generalized locked door (tag, speed, kind, delay, lock)
			line->special = LNSPEC_DoorGeneric;
			if (OldSpec & 0x0080)
			{
				line->flags |= ML_MONSTERSCANACTIVATE;
			}
			switch (OldSpec & 0x0018)
			{
			case 0x0000:	line->arg2 = 16;	break;
			case 0x0008:	line->arg2 = 32;	break;
			case 0x0010:	line->arg2 = 64;	break;
			case 0x0018:	line->arg2 = 128;	break;
			}
			line->arg3 = (OldSpec & 0x0020) >> 5;
			line->arg4 = 0;
			line->arg5 = (OldSpec & 0x01c0) >> 6;
			if (line->arg5 == 0)
			{
				line->arg5 = 100;
			}
			else if (line->arg5 == 7)
			{
				line->arg5 = 101;
			}
			line->arg5 |= (OldSpec & 0x0200) >> 2;
		}
		else if (OldSpec <= 0x4000)
		{
			//	Generalized door (tag, speed, kind, delay, lock)
			line->special = LNSPEC_DoorGeneric;
			switch (OldSpec & 0x0018)
			{
			case 0x0000:	line->arg2 = 16;	break;
			case 0x0008:	line->arg2 = 32;	break;
			case 0x0010:	line->arg2 = 64;	break;
			case 0x0018:	line->arg2 = 128;	break;
			}
			line->arg3 = (OldSpec & 0x0060) >> 5;
			if ((OldSpec & 0x0006) == 6)
			{
				line->arg1 = OldTag;
				line->arg3 |= 128;
			}
			switch (OldSpec & 0x0300)
			{
			case 0x0000:	line->arg4 = 8;		break;
			case 0x0100:	line->arg4 = 32;	break;
			case 0x0200:	line->arg4 = 72;	break;
			case 0x0300:	line->arg4 = 240;	break;
			}
			line->arg5 = 0;
		}
		else
		{
			//	Generalized ceiling (tag, speed, height, target, change/model/direct/crush)
			//	Generalized floor (tag, speed, height, target, change/model/direct/crush)
			if (OldSpec <= 0x6000)
				line->special = LNSPEC_CeilingGeneric;
			else
				line->special = LNSPEC_FloorGeneric;

			switch (OldSpec & 0x0018)
			{
			case 0x0000:	line->arg2 = 8;		break;
			case 0x0008:	line->arg2 = 16;	break;
			case 0x0010:	line->arg2 = 32;	break;
			case 0x0018:	line->arg2 = 64;	break;
			}
			line->arg4 = ((OldSpec & 0x0380) >> 7) + 1;
			if (line->arg4 >= 7)
			{
				line->arg3 = 24 + (line->arg4 - 7) * 8;
				line->arg4 = 0;
			}
			else
			{
				line->arg3 = 0;
			}
			line->arg5 =  ((OldSpec & 0x0c00) >> 10) |
						  ((OldSpec & 0x0060) >> 3) |
						  ((OldSpec & 0x1000) >> 8);
		}
		return;
	}

	switch (OldSpec)
	{
	// Doom Legacy 3D floors
	case 281:
	case 289:
	case 300:
	//case 301:
	// EDGE 3D floors
	case 400:
	case 401:
	case 402:
	case 403:
	case 404:
	case 405:
	case 406:
	case 407:
	case 408:
	case 413:
	case 414:
	case 415:
	case 416:
	case 417:
		if (GetPlanePointZ(&line->frontsector->floor,
				*line->frontsector->lines[0]->v1) < 
			GetPlanePointZ(&line->frontsector->ceiling,
				*line->frontsector->lines[0]->v1))
		{
			InLevel.SwapPlanes(line->frontsector);
		}
		break;
	}
	switch (OldSpec)
 	{
 	case 281:
	case 289:
		line->special = 160;
		return;
	case 300:
		line->special = 160;
		line->frontsector->floor.translucency = 50;
		line->frontsector->ceiling.translucency = 50;
		return;
	// Doesn't work
	/*case 301:
		line->special = 160;
		line->frontsector->params.contents = CONTENTS_WATER;
		line->frontsector->floor.translucency = 50;
		line->frontsector->ceiling.translucency = 50;
		line->frontsector->ceiling.flags = 7;
		line->frontsector->floor.flags = 7;
		return;*/
	// EDGE 3D floors
	case 400:
		line->special = 160;
		return;
	case 401:
		line->special = 160;
		return;
	case 402:
		line->special = 160;
		return;
	case 403:
		line->special = 160;
		line->frontsector->params.contents = CONTENTS_WATER;
		line->frontsector->ceiling.flags = 7;
		line->frontsector->floor.flags = 7;
		return;
	case 404:
		line->special = 160;
		line->frontsector->params.contents = CONTENTS_WATER;
		line->frontsector->floor.translucency = 20;
		line->frontsector->ceiling.translucency = 20;
		line->frontsector->ceiling.flags = 7;
		line->frontsector->floor.flags = 7;
		return;
	case 405:
		line->special = 160;
		line->frontsector->params.contents = CONTENTS_WATER;
		line->frontsector->floor.translucency = 40;
		line->frontsector->ceiling.translucency = 40;
		line->frontsector->ceiling.flags = 7;
		line->frontsector->floor.flags = 7;
		return;
	case 406:
		line->special = 160;
		line->frontsector->params.contents = CONTENTS_WATER;
		line->frontsector->floor.translucency = 60;
		line->frontsector->ceiling.translucency = 60;
		line->frontsector->ceiling.flags = 7;
		line->frontsector->floor.flags = 7;
		return;
	case 407:
		line->special = 160;
		line->frontsector->params.contents = CONTENTS_WATER;
		line->frontsector->floor.translucency = 80;
		line->frontsector->ceiling.translucency = 80;
		line->frontsector->ceiling.flags = 7;
		line->frontsector->floor.flags = 7;
		return;
	case 408:
		line->special = 160;
		line->frontsector->params.contents = CONTENTS_WATER;
		line->frontsector->floor.translucency = 100;
		line->frontsector->ceiling.translucency = 100;
		line->frontsector->ceiling.flags = 7;
		line->frontsector->floor.flags = 7;
		return;
	case 413:
		line->special = 160;
		return;
	case 414:
		line->special = 160;
		line->frontsector->floor.translucency = 20;
		line->frontsector->ceiling.translucency = 20;
		line->frontsector->ceiling.flags = SPF_NOBLOCKSIGHT;
		line->frontsector->floor.flags = SPF_NOBLOCKSIGHT;
		return;
	case 415:
		line->special = 160;
		line->frontsector->floor.translucency = 40;
		line->frontsector->ceiling.translucency = 40;
		line->frontsector->ceiling.flags = SPF_NOBLOCKSIGHT;
		line->frontsector->floor.flags = SPF_NOBLOCKSIGHT;
		return;
	case 416:
		line->special = 160;
		line->frontsector->floor.translucency = 60;
		line->frontsector->ceiling.translucency = 60;
		line->frontsector->ceiling.flags = SPF_NOBLOCKSIGHT;
		line->frontsector->floor.flags = SPF_NOBLOCKSIGHT;
		return;
	case 417:
		line->special = 160;
		line->frontsector->floor.translucency = 80;
		line->frontsector->ceiling.translucency = 80;
		line->frontsector->ceiling.flags = SPF_NOBLOCKSIGHT;
		line->frontsector->floor.flags = SPF_NOBLOCKSIGHT;
		return;
	}

	if (line->special >= NUM_SPECIALS)
	{
		line->special = 0;
		line->arg1 = 0;
		return;
	}

	//	Special.
	line->special = spec_trans_tab[OldSpec].special;
	//	Arg 1.
	if (spec_trans_tab[OldSpec].arg1 == -1)
	{
		line->arg1 = OldTag;
	}
	else
	{
		line->arg1 = spec_trans_tab[OldSpec].arg1;
	}
	//	Arg 2.
	if (spec_trans_tab[OldSpec].arg2 == -1)
	{
		line->arg2 = OldTag;
	}
	else
	{
		line->arg2 = spec_trans_tab[OldSpec].arg2;
	}
	//	Arg 3.
	if (spec_trans_tab[OldSpec].arg3 == -1)
	{
		line->arg3 = OldTag;
	}
	else
	{
		line->arg3 = spec_trans_tab[OldSpec].arg3;
	}
	//	Arg 4.
	if (spec_trans_tab[OldSpec].arg4 == -1)
	{
		line->arg4 = OldTag;
	}
	else
	{
		line->arg4 = spec_trans_tab[OldSpec].arg4;
	}
	//	Arg 5.
	if (spec_trans_tab[OldSpec].arg5 == -1)
	{
		line->arg5 = OldTag;
	}
	else
	{
		line->arg5 = spec_trans_tab[OldSpec].arg5;
	}

	//	Activation flags.
	if (OldFlags & 0x0200 && spec_trans_tab[OldSpec].spac == SPAC_USE)
		line->flags |= SPAC_USETHROUGH << ML_SPAC_SHIFT;
	else
		line->flags |= spec_trans_tab[OldSpec].spac << ML_SPAC_SHIFT;
	if (spec_trans_tab[OldSpec].repeat)
	{
		line->flags |= ML_REPEAT_SPECIAL;
	}
}

//==========================================================================
//
//  TranslateSector
//
//==========================================================================

void TranslateSector(sector_t* sector)
{
	int special;
	int high;

	special = sector->special;
	if (!special)
	{
		return;
	}
	if (special == 9)
	{
		sector->special = SECSPEC_SECRET_MASK;
		return;
	}

	//	This supports phased lighting with specials 21-24 and wind specials
	// 40-51.
	high = (special & 0xfe0) << 3;
	special &= 0x01f;
	if (special < 21)
	{
		sector->special = high | (special + 64);
	}
	else if (special < 40)
	{
		sector->special = high | (special - 20);
	}
	else
	{
		sector->special = high | special;
	}
}

//==========================================================================
//
//  TranslateThing
//
//==========================================================================

void TranslateThing(mthing_t* mthing)
{
	int flags;

	// translate the spawn flags to Hexen format.
	flags = mthing->options;
	mthing->options = (flags & 0xf) | 0x7e0;
	if (flags & 0x10)
		mthing->options &= ~MTF_GSINGLE;
}

//==========================================================================
//
//  TranslateLevel
//
//==========================================================================

void TranslateLevel(Level InLevel)
{
	int i;

	for (i = 0; i < InLevel.NumLines; i++)
	{
		TranslateLine(InLevel, &InLevel.Lines[i]);
	}

	for (i = 0; i < InLevel.NumSectors; i++)
	{
		TranslateSector(&InLevel.Sectors[i]);
	}

	for (i = 0; i < InLevel.NumThings; i++)
	{
		TranslateThing(&InLevel.Things[i]);
	}
}

//==========================================================================
//
//  MakeFloorSlope
//
//==========================================================================

void MakeFloorSlope(Level InLevel, mthing_t * mthing)
{
	sector_t *sec;
	line_t *line;
	int i;

	sec = InLevel.PointInSector(vector(mthing->x, mthing->y, 0.0));
	for (i = 0; i < sec->linecount; i++)
	{
		line = sec->lines[i];
		if (mthing->tid == line->arg1)
		{
			TVec v1;
			TVec v2;
			TVec p1;
			TVec p2;
			TVec p3;

			p1 = vector(line->v1->x, line->v1->y, sec->floor.minz);
			p2 = vector(line->v2->x, line->v2->y, sec->floor.minz);
			p3 = vector(mthing->x, mthing->y, mthing->height);
			if (PointOnPlaneSide(p3, line) == 0)
			{
				v1 = p2 - p3;
				v2 = p1 - p3;
			}
			else
			{
				v1 = p1 - p3;
				v2 = p2 - p3;
			}
			sec->floor.normal = Normalise(CrossProduct(v1, v2));
			if (sec->floor.normal.z <= 0.0)
			{
				Error("Floor with normal.z <= 0.0");
			}
			sec->floor.dist = DotProduct(sec->floor.normal, p3);
			sec->base_floorheight = sec->floor.dist;
			InLevel.SendFloorSlope(sec);
			return;
		}
	}
}

//==========================================================================
//
//  MakeCeilingSlope
//
//==========================================================================

void MakeCeilingSlope(Level InLevel, mthing_t * mthing)
{
	sector_t *sec;
	line_t *line;
	int i;

	sec = InLevel.PointInSector(vector(mthing->x, mthing->y, 0.0));
	for (i = 0; i < sec->linecount; i++)
	{
		line = sec->lines[i];
		if (mthing->tid == line->arg1)
		{
			TVec p1;
			TVec p2;
			TVec p3;
			TVec v1;
			TVec v2;

			p1 = vector(line->v1->x, line->v1->y, sec->ceiling.maxz);
			p2 = vector(line->v2->x, line->v2->y, sec->ceiling.maxz);
			p3 = vector(mthing->x, mthing->y, mthing->height);
			if (PointOnPlaneSide(p3, line) == 0)
			{
				v1 = p1 - p3;
				v2 = p2 - p3;
			}
			else
			{
				v1 = p2 - p3;
				v2 = p1 - p3;
			}
			sec->ceiling.normal = Normalise(CrossProduct(v1, v2));
			if (sec->ceiling.normal.z >= 0.0)
			{
				Error("Ceiling with normal.z >= 0.0");
			}
			sec->ceiling.dist = DotProduct(sec->ceiling.normal, p3);
			sec->base_ceilingheight = sec->ceiling.dist;
			InLevel.SendCeilingSlope(sec);
			return;
		}
	}
}

//==========================================================================
//
//	SetVertexHeights
//
//==========================================================================

bool SetVertexHeights(Level InLevel, int ThingID)
{
	int i;
	int j;
	bool ret;
	mthing_t * mthing;
	
	ret = false;
	//	Clean all
	for (i = 0; i < InLevel.NumVertexes; i++)
	{
		InLevel.Vertexes[i].z = 0.1;
	}
	for (j = 0; j < InLevel.NumThings; j++)
	{
		mthing = &InLevel.Things[j];
		if (mthing->type == ThingID)
		{
			for (i = 0; i < InLevel.NumVertexes; i++)
			{
				if (InLevel.Vertexes[i].x == mthing->x &&
					InLevel.Vertexes[i].y == mthing->y)
				{
					InLevel.Vertexes[i].z = mthing->height;
					ret = true;
				}
			}
		}
	}
	return ret;
}

//==========================================================================
//
//	CleanVertexHeights
//
//==========================================================================

void CleanVertexHeights(Level InLevel)
{
	int i;
	
	for (i = 0; i < InLevel.NumVertexes; i++)
	{
		InLevel.Vertexes[i].z = 0.0;
	}
}

//==========================================================================
//
//	MakeVertexFloorHeights
//
//==========================================================================

void MakeVertexFloorHeights(Level InLevel)
{
	int i;
	sector_t *sec;
	TVec p1;
	TVec p2;
	TVec p3;
	TVec v1;
	TVec v2;
	
	if (!SetVertexHeights(InLevel, 1504))
	{
		return;
	}
	for (i = 0; i < InLevel.NumSectors; i++)
	{
		sec = &InLevel.Sectors[i];
		if (sec->linecount != 3)
			continue;
		p1 = *sec->lines[0]->v1;
		p2 = *sec->lines[0]->v2;
		if (sec->lines[1]->v1 == sec->lines[0]->v1 ||
			sec->lines[1]->v1 == sec->lines[0]->v2)
		{
			p3 = *sec->lines[1]->v2;
		}
		else
		{
			p3 = *sec->lines[1]->v1;
		}
		if (p1.z == 0.1 && p2.z == 0.1 && p3.z == 0.1)
		{
			continue;
		}
		if (p1.z == 0.1)
		{
			p1.z = sec->floorheight;
		}
		if (p2.z == 0.1)
		{
			p2.z = sec->floorheight;
		}
		if (p3.z == 0.1)
		{
			p3.z = sec->floorheight;
		}
		if (PointOnPlaneSide(p3, sec->lines[0]) == 0)
		{
			v1 = p2 - p3;
			v2 = p1 - p3;
		}
		else
		{
			v1 = p1 - p3;
			v2 = p2 - p3;
		}
		sec->floor.normal = Normalise(CrossProduct(v1, v2));
		if (sec->floor.normal.z <= 0.0)
		{
			Error("Floor with normal.z <= 0.0");
		}
		sec->floor.dist = DotProduct(sec->floor.normal, p3);
		sec->base_floorheight = sec->floor.dist;
		InLevel.SendFloorSlope(sec);
	}
}

//==========================================================================
//
//	MakeVertexCeilingHeights
//
//==========================================================================

void MakeVertexCeilingHeights(Level InLevel)
{
	int i;
	sector_t *sec;
	TVec p1;
	TVec p2;
	TVec p3;
	TVec v1;
	TVec v2;
	
	if (!SetVertexHeights(InLevel, 1505))
	{
		return;
	}
	for (i = 0; i < InLevel.NumSectors; i++)
	{
		sec = &InLevel.Sectors[i];
		if (sec->linecount != 3)
			continue;
		p1 = *sec->lines[0]->v1;
		p2 = *sec->lines[0]->v2;
		if (sec->lines[1]->v1 == sec->lines[0]->v1 ||
			sec->lines[1]->v1 == sec->lines[0]->v2)
		{
			p3 = *sec->lines[1]->v2;
		}
		else
		{
			p3 = *sec->lines[1]->v1;
		}
		if (p1.z == 0.1 && p2.z == 0.1 && p3.z == 0.1)
		{
			continue;
		}
		if (p1.z == 0.1)
		{
			p1.z = sec->ceilingheight;
		}
		if (p2.z == 0.1)
		{
			p2.z = sec->ceilingheight;
		}
		if (p3.z == 0.1)
		{
			p3.z = sec->ceilingheight;
		}
		if (PointOnPlaneSide(p3, sec->lines[0]) == 0)
		{
			v1 = p1 - p3;
			v2 = p2 - p3;
		}
		else
		{
			v1 = p2 - p3;
			v2 = p1 - p3;
		}
		sec->ceiling.normal = Normalise(CrossProduct(v1, v2));
		if (sec->ceiling.normal.z >= 0.0)
		{
			Error("Ceiling with normal.z >= 0.0");
		}
		sec->ceiling.dist = DotProduct(sec->ceiling.normal, p3);
		sec->base_ceilingheight = sec->ceiling.dist;
		InLevel.SendCeilingSlope(sec);
	}
}

//==========================================================================
//
//	AlignPlane
//
//	Set slopes for sectors, based on line specials
//
//	Aligns the floor or ceiling of a sector to the corresponding plane
// on the other side of the reference line. (By definition, line must be
// two-sided.)
//
//	If (which & 1), sets floor.
//	If (which & 2), sets ceiling.
//
//==========================================================================

void AlignPlane(Level InLevel, sector_t *sec, line_t *line, int which)
{
	sector_t *refsec;
	float bestdist;
	TVec *refvert = (*sec->lines)->v1;
	int i;
	line_t **probe;
	float dist;
	TVec *vert;
	TVec p, v1, v2, cross;
	sec_plane_t *refplane;
	sec_plane_t *srcplane;
	float srcheight, destheight;

	if (line->backsector == NULL)
		return;

	//	Find furthest vertex from the reference line. It, along with the two
	// ends of the line will define the plane.
	bestdist = 0.0;
	for (i = sec->linecount * 2, probe = sec->lines; i > 0; i--)
	{
		if (i & 1)
		{
			vert = (*probe)->v2;
			probe = &probe[1];
		}
		else
			vert = (*probe)->v1;
		dist = fabs(DotProduct(*vert, line->normal));

		if (dist > bestdist)
		{
			bestdist = dist;
			refvert = vert;
		}
	}

	refsec = line->frontsector == sec ? line->backsector : line->frontsector;

	p = *line->v1;
	v1 = *line->v2 - *line->v1;
	v2 = *refvert - *line->v1;

	refplane = (which == 0) ? &refsec->floor : &refsec->ceiling;
	srcplane = (which == 0) ? &sec->floor : &sec->ceiling;
	srcheight = (which == 0) ? sec->floorheight : sec->ceilingheight;
	destheight = (which == 0) ? refsec->floorheight : refsec->ceilingheight;

	p.z = destheight;
	v1.z = 0.0;
	v2.z = srcheight - destheight;

	cross = Normalise(CrossProduct(v1, v2));

	// Fix backward normals
	if ((cross.z < 0.0 && which == 0) || (cross.z > 0.0 && which == 1))
	{
		cross = -cross;
	}

	srcplane->normal = cross;
	srcplane->dist = DotProduct(cross, p);
	if (which == 0)
		InLevel.SendFloorSlope(sec);
	else
		InLevel.SendCeilingSlope(sec);
}

//==========================================================================
//
//	SetSlopes
//
//==========================================================================

void SetSlopes(Level InLevel)
{
	int i, s;

	for (i = 0; i < InLevel.NumLines; i++)
	{
		if (InLevel.Lines[i].special == LNSPEC_PlaneAlign)
		{
			InLevel.Lines[i].special = 0;
//			InLevel.Lines[i].id = InLevel.Lines[i].args[2];
			if (InLevel.Lines[i].backsector != NULL)
			{
				// args[0] is for floor, args[1] is for ceiling
				//
				// As a special case, if args[1] is 0,
				// then args[0], bits 2-3 are for ceiling.
				for (s = 0; s < 2; s++)
				{
					int bits = (s == 0 ? InLevel.Lines[i].arg1 :
 						InLevel.Lines[i].arg2) & 3;

					if (s == 1 && bits == 0)
						bits = (InLevel.Lines[i].arg1 >> 2) & 3;

					if (bits == 1)			// align front side to back
						AlignPlane(InLevel, InLevel.Lines[i].frontsector,
							&InLevel.Lines[i], s);
					else if (bits == 2)		// align back side to front
						AlignPlane(InLevel, InLevel.Lines[i].backsector,
							&InLevel.Lines[i], s);
				}
			}
		}
	}
}

//==========================================================================
//
//  SpawnExtraFloors
//
//==========================================================================

void SpawnExtraFloors(Level InLevel, line_t * line)
{
	int j;

	for (j = 0; j < InLevel.NumSectors; j++)
	{
		if (line->arg1 == InLevel.Sectors[j].tag)
		{
			InLevel.AddExtraFloor(line, &InLevel.Sectors[j]);
		}
	}
}

//==========================================================================
//
//  MakeContents
//
//==========================================================================

void MakeContents(line_t * line)
{
	int contents;

	if (!line->arg1 && !line->arg2 && !line->arg3)
	{
		contents =
			terrain_contents[TerrainType(line->frontsector->floor.pic)];
		line->frontsector->params.contents = contents;
		if (line->frontsector->floor.dist == -line->frontsector->ceiling.dist)
		{
			line->frontsector->floor.translucency =
				contents_transluc[contents];
			line->frontsector->ceiling.translucency =
				contents_transluc[contents];
			line->frontsector->ceiling.flags |=
				SPF_NOBLOCKING | SPF_NOBLOCKSIGHT | SPF_NOBLOCKSHOOT;
			line->frontsector->floor.flags |=
				SPF_NOBLOCKING | SPF_NOBLOCKSIGHT | SPF_NOBLOCKSHOOT;
		}
	}
	else
	{
		line->frontsector->params.contents = line->arg1;

		line->frontsector->floor.translucency = line->arg2;
		line->frontsector->ceiling.translucency = line->arg2;

		line->frontsector->ceiling.flags = line->arg3;
		line->frontsector->floor.flags = line->arg3;
	}
}

//==========================================================================
//
//  MakeHeightSec
//
//	killough 3/7/98:
//	support for drawn heights coming from different sector
//
//==========================================================================

void MakeHeightSec(Level InLevel, line_t* Line)
{
	sector_t*	Sec;
	int			s;

	Sec = Line->frontsector;
	if (Line->arg2 & 2)
	{
		Sec->bFakeFloorOnly = true;
	}
	if (Line->arg2 & 4)
	{
		Sec->bClipFakePlanes = true;
	}
	if (Line->arg2 & 8)
	{
		Sec->bUnderWater = true;
	}
	if (Line->arg2 & 16)
	{
		Sec->bIgnoreHeightSec = true;
	}
	if (Line->arg2 & 32)
	{
		Sec->bNoFakeLight = true;
	}
	for (s = InLevel.FindSectorFromTag(Line->arg1, -1); s  >= 0;
		s = InLevel.FindSectorFromTag(Line->arg1, s))
	{
		InLevel.Sectors[s].heightsec = Sec;
		InLevel.SetHeightSector(&InLevel.Sectors[s], Sec, Line->arg2);
	}
}

//==========================================================================
//
//  SetSectorFriction
//
//==========================================================================

void SetSectorFriction(Level InLevel, int tag, int amount, bool alterFlag)
{
	int			s;
	int			OldFriction;
	int			OldMoveFactor;
	float		Friction;
	float		MoveFactor;

	// An amount of 100 should result in a friction of
	// ORIG_FRICTION (0xE800)
	OldFriction = (0x1EB8 * amount) / 0x80 + 0xD001;

	// killough 8/28/98: prevent odd situations
	if (OldFriction > 0x10000)
		OldFriction = 0x10000;
	if (OldFriction < 0)
		OldFriction = 0;

	// The following check might seem odd. At the time of movement,
	// the move distance is multiplied by 'friction/0x10000', so a
	// higher friction value actually means 'less friction'.

	// [RH] Twiddled these values so that momentum on ice (with
	//		friction 0xf900) is the same as in Heretic/Hexen.
	if (OldFriction >= 0xe800)	// ice
//		movefactor = ((0x10092 - friction)*(0x70))/0x158;
		OldMoveFactor = ((0x10092 - OldFriction) * 1024) / 4352 + 568;
	else
		OldMoveFactor = ((OldFriction - 0xDB34) * (0xA)) / 0x80;

	// killough 8/28/98: prevent odd situations
	if (OldMoveFactor < 32)
		OldMoveFactor = 32;

	Friction = (1.0 - itof(OldFriction) / itof(0x10000)) * 35.0;
	MoveFactor = itof(OldMoveFactor) / itof(0x10000);

	for (s = InLevel.FindSectorFromTag(tag, -1); s >= 0;
		s = InLevel.FindSectorFromTag(tag, s))
	{
		// killough 8/28/98:
		//
		// Instead of spawning thinkers, which are slow and expensive,
		// modify the sector's own friction values. Friction should be
		// a property of sectors, not objects which reside inside them.
		// Original code scanned every object in every friction sector
		// on every tic, adjusting its friction, putting unnecessary
		// drag on CPU. New code adjusts friction of sector only once
		// at level startup, and then uses this friction value.

		InLevel.Sectors[s].Friction = Friction;
		InLevel.Sectors[s].MoveFactor = MoveFactor;
		if (alterFlag)
		{
			// When used inside a script, the sectors' friction flags
			// can be enabled and disabled at will.
			if (OldFriction == 0xe800)
			{
				InLevel.Sectors[s].special &= ~SECSPEC_FRICTION_MASK;
			}
			else
			{
				InLevel.Sectors[s].special |= SECSPEC_FRICTION_MASK;
			}
		}
	}
}

//==========================================================================
//
//  SpawnWorld
//
//==========================================================================

void SpawnWorld(Level InLevel)
{
	int			i;
	int			j;
	int			length;
	int			SecNum;
	mthing_t*	mthing;

	//  Spawn slopes first
	SetSlopes(InLevel);
	for (i = 0; i < InLevel.NumThings; i++)
	{
		mthing = &InLevel.Things[i];

		if (mthing->type == 1500)
		{
			MakeFloorSlope(InLevel, mthing);
			mthing->type = 0;
			continue;
		}

		if (mthing->type == 1501)
		{
			MakeCeilingSlope(InLevel, mthing);
			mthing->type = 0;
			continue;
		}

		if (mthing->type == PO_SPAWN_TYPE || mthing->type == PO_SPAWNCRUSH_TYPE)
		{
			// Polyobj StartSpot Pt.
			InLevel.SpawnPolyobj(mthing->x, mthing->y, mthing->angle,
				(mthing->type == PO_SPAWNCRUSH_TYPE));
			mthing->type = 0;
			continue;
		}
		if (mthing->type == PO_ANCHOR_TYPE)
		{
			// Polyobj Anchor Pt.
			InLevel.AddPolyAnchorPoint(mthing->x, mthing->y, mthing->angle);
			mthing->type = 0;
			continue;
		}
	}
	MakeVertexFloorHeights(InLevel);
	MakeVertexCeilingHeights(InLevel);
	CleanVertexHeights(InLevel);

	//	Initialise initial friction values.
	for (i = 0; i < InLevel.NumSectors; i++)
	{
		InLevel.Sectors[i].Friction = Actor::FRICTION;
	}

	//  Spawn 3D floors
	for (i = 0; i < InLevel.NumLines; i++)
	{
		switch (InLevel.Lines[i].special)
		{
		case LNSPEC_3DFloor:
			SpawnExtraFloors(InLevel, &InLevel.Lines[i]);
			InLevel.Lines[i].special = 0;
			break;

		case LNSPEC_Contents:
			MakeContents(&InLevel.Lines[i]);
			InLevel.Lines[i].special = 0;
			break;

		case LNSPEC_TransferFloorLight:
			for (SecNum = InLevel.FindSectorFromTag(InLevel.Lines[i].arg1, -1);
				SecNum >= 0;
				SecNum = InLevel.FindSectorFromTag(InLevel.Lines[i].arg1, SecNum))
			{
				InLevel.SetFloorLightSector(&InLevel.Sectors[SecNum],
					InLevel.Lines[i].frontsector);
			}
			InLevel.Lines[i].special = 0;
			break;

		case LNSPEC_TransferCeilingLight:
			for (SecNum = InLevel.FindSectorFromTag(InLevel.Lines[i].arg1, -1);
				SecNum >= 0;
				SecNum = InLevel.FindSectorFromTag(InLevel.Lines[i].arg1, SecNum))
			{
				InLevel.SetCeilingLightSector(&InLevel.Sectors[SecNum],
					InLevel.Lines[i].frontsector);
			}
			InLevel.Lines[i].special = 0;
			break;

		case LNSPEC_SectorSetFriction:
			if (InLevel.Lines[i].arg2)
			{
				//	Allow setting friction amount from parameter
				length = InLevel.Lines[i].arg2 <= 200 ?
					InLevel.Lines[i].arg2 : 200;
			}
			else
			{
				length = ftoi(Length(*InLevel.Lines[i].v2 -
					*InLevel.Lines[i].v1));
			}

			SetSectorFriction(InLevel, InLevel.Lines[i].arg1, length, false);
			InLevel.Lines[i].special = 0;
			break;

		case LNSPEC_TransferHeights:
			MakeHeightSec(InLevel, &InLevel.Lines[i]);
			break;
		}
	}

	TaggedLineCount = 0;
	for (i = 0; i < InLevel.NumLines; i++)
	{
		switch (InLevel.Lines[i].special)
		{
		case LNSPEC_LineSetIdentification:
		case LNSPEC_LineTranslucent:
		case LNSPEC_TeleportLine:
			if (InLevel.Lines[i].arg1)
			{
				if (TaggedLineCount == MAX_TAGGED_LINES)
				{
					Error("P_SpawnSpecials: MAX_TAGGED_LINES exceeded.");
				}
				TaggedLines[TaggedLineCount].line = &InLevel.Lines[i];
				TaggedLines[TaggedLineCount++].lineTag = InLevel.Lines[i].arg1;
			}
			if (InLevel.Lines[i].special == LNSPEC_LineSetIdentification)
			{
				InLevel.Lines[i].special = 0;
			}
			break;

		default:
			//	Add all other tagged lines for BOOM compatibility.
			if (InLevel.Lines[i].LineTag)
			{
				if (TaggedLineCount == MAX_TAGGED_LINES)
				{
					Error("P_SpawnSpecials: MAX_TAGGED_LINES exceeded.");
				}
				TaggedLines[TaggedLineCount].line = &InLevel.Lines[i];
				TaggedLines[TaggedLineCount++].lineTag = InLevel.Lines[i].LineTag;
			}
		}
	}

	//	Process translucent lines
	for (i = 0; i < InLevel.NumLines; i++)
	{
		if (InLevel.Lines[i].special != LNSPEC_LineTranslucent)
		{
			continue;
		}

		int trans = (255 - InLevel.Lines[i].arg2) * 100 / 255;
		if (InLevel.Lines[i].arg1)
		{
			for (j = 0; j < TaggedLineCount; j++)
			{
				if (TaggedLines[j].lineTag == InLevel.Lines[i].arg1)
				{
					InLevel.SetLineTransluc(TaggedLines[j].line, trans);
				}
			}
		}
		else
		{
			InLevel.SetLineTransluc(&InLevel.Lines[i], trans);
		}
		InLevel.Lines[i].special = 0;
	}
}

defaultproperties
{
	num_stats = 2 * DoomDefs::NUMAMMO + DoomDefs::NUMWEAPONS + 5;

	WeaponClasses[0] = WeaponFist;
	WeaponClasses[1] = WeaponPistol;
	WeaponClasses[2] = WeaponShotgun;
	WeaponClasses[3] = WeaponChaingun;
	WeaponClasses[4] = WeaponMissile;
	WeaponClasses[5] = WeaponPlasma;
	WeaponClasses[6] = WeaponBFG;
	WeaponClasses[7] = WeaponChainsaw;
#ifdef DOOM2
	WeaponClasses[8] = WeaponSuperShotgun;
#endif
#ifdef GRENADE_LAUNCHER
	WeaponClasses[9] = WeaponGrenade;
#endif

	weapon_ammo_type[0] = DoomDefs::am_noammo;
	weapon_ammo_type[1] = DoomDefs::am_clip;
	weapon_ammo_type[2] = DoomDefs::am_shell;
	weapon_ammo_type[3] = DoomDefs::am_clip;
	weapon_ammo_type[4] = DoomDefs::am_misl;
	weapon_ammo_type[5] = DoomDefs::am_cell;
	weapon_ammo_type[6] = DoomDefs::am_cell;
	weapon_ammo_type[7] = DoomDefs::am_noammo;
#ifdef DOOM2
	weapon_ammo_type[8] = DoomDefs::am_shell;
#endif
#ifdef GRENADE_LAUNCHER
	weapon_ammo_type[9] = DoomDefs::am_misl;
#endif

	WeaponOrder[0] = DoomDefs::wp_fist;
	WeaponOrder[1] = DoomDefs::wp_chainsaw;
	WeaponOrder[2] = DoomDefs::wp_pistol;
	WeaponOrder[3] = DoomDefs::wp_shotgun;
	WeaponOrder[4] = DoomDefs::wp_supershotgun;
	WeaponOrder[5] = DoomDefs::wp_chaingun;
	WeaponOrder[6] = DoomDefs::wp_missile;
#ifdef GRENADE_LAUNCHER
	WeaponOrder[7] = DoomDefs::wp_grenade;
	WeaponOrder[8] = DoomDefs::wp_plasma;
	WeaponOrder[9] = DoomDefs::wp_bfg;
#else
	WeaponOrder[7] = DoomDefs::wp_plasma;
	WeaponOrder[8] = DoomDefs::wp_bfg;
#endif

	terrain_contents[0] = CONTENTS_EMPTY;
	terrain_contents[1] = CONTENTS_WATER;
	terrain_contents[2] = CONTENTS_BLOOD;
	terrain_contents[3] = CONTENTS_NUKAGE;
	terrain_contents[4] = CONTENTS_SLIME;
	terrain_contents[5] = CONTENTS_LAVA;

	contents_transluc[0] = 0;
	contents_transluc[1] = 50;
	contents_transluc[2] = 15;
	contents_transluc[3] = 40;
	contents_transluc[4] = 45;
	contents_transluc[5] = 30;

	windTab[0] = 5.0 / 32.0;
	windTab[1] = 10.0 / 32.0;
	windTab[2] = 25.0 / 32.0;

	pushTab[0] = 5.0 * 35.0 * 35.0 / 32.0;
	pushTab[1] = 10.0 * 35.0 * 35.0 / 32.0;
	pushTab[2] = 25.0 * 35.0 * 35.0 / 32.0;
	pushTab[3] = 30.0 * 35.0 * 35.0 / 32.0;
	pushTab[4] = 35.0 * 35.0 * 35.0 / 32.0;

	opposite[0] = DI_WEST;
	opposite[1] = DI_SOUTHWEST;
	opposite[2] = DI_SOUTH;
	opposite[3] = DI_SOUTHEAST;
	opposite[4] = DI_EAST;
	opposite[5] = DI_NORTHEAST;
	opposite[6] = DI_NORTH;
	opposite[7] = DI_NORTHWEST;
	opposite[8] = DI_NODIR;

	diags[0] = DI_NORTHWEST;
	diags[1] = DI_NORTHEAST;
	diags[2] = DI_SOUTHWEST;
	diags[3] = DI_SOUTHEAST;

	xspeed[0] = 1.0;
	xspeed[1] = 0.7171630859;
	xspeed[2] = 0.0;
	xspeed[3] = -0.7171630859;
	xspeed[4] = -1.0;
	xspeed[5] = -0.7171630859;
	xspeed[6] = 0.0;
	xspeed[7] = 0.7171630859;

	yspeed[0] = 0.0;
	yspeed[1] = 0.7171630859;
	yspeed[2] = 1.0;
	yspeed[3] = 0.7171630859;
	yspeed[4] = 0.0;
	yspeed[5] = -0.7171630859;
	yspeed[6] = -1.0;
	yspeed[7] = -0.7171630859;

	maxammo[0] = 200;
	maxammo[1] = 50;
	maxammo[2] = 300;
	maxammo[3] = 50;

	clipammo[0] = 10;
	clipammo[1] = 4;
	clipammo[2] = 20;
	clipammo[3] = 1;

	air_control = 1.0 / 256.0;

#ifndef NO_BOTS
	botskill = 2;
#endif
	INITIAL_HEALTH = 100;
	INITIAL_AMMO = 50;
	GOD_HEALTH = 100;
	BFGCELLS = 40;
}
