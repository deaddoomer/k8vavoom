//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class IntermissionScreen : Window;

//	Intermission states
enum
{
	IMS_Stats,
	IMS_NextLoc,
	IMS_NoState,
	IMS_Text,
	IMS_Done
};

ClientGameBase ClGame;

// GLOBAL LOCATIONS
const int WI_SPACINGY	= 33;

const int WI_TITLEY		= 12;

// SINGPLE-PLAYER STUFF
const int SP_STATSX		= 210;
const int SP_STATSY		= 190;

const int SP_TIMEX		= 176;
const int SP_TIMEY		= 308;

const int SP_PARX		= 376;
const int SP_PARY		= 308;

// NET GAME STUFF
const int NG_STATSY		= 210;
const int NG_STATSX		= (172 + 32 / 2);

const int NG_SPACINGX    	= 64;

// DEATHMATCH STUFF
const int DM_MATRIXX		= 202;
const int DM_MATRIXY		= 208;

const int DM_TOTALSX		= 429;

const int DM_KILLERSX		= 170;
const int DM_KILLERSY		= 240;
const int DM_VICTIMSX    	= 165;
const int DM_VICTIMSY		= 190;

const int DM_SPACINGX		= 40;

// in seconds
const float SHOWNEXTLOCDELAY	= 4.0;

//  Different between registered DOOM (1994) and Ultimate DOOM - Final
// edition (retail, 1995?).
const int NUMEPISODES		= 3;
const int NUMMAPS			= 9;

const float TEXTSPEED	= 0.1;
const float TEXTWAIT	= 7.0;

#ifndef DOOM2

enum
{
	ANIM_ALWAYS,
	ANIM_RANDOM,
	ANIM_LEVEL
};

struct point_t
{
	int x;
	int y;
};

//
// Animation.
//
struct anim_t
{
	int type;

	// period in seconds between animations
	float period;

	// number of animation frames
	int nanims;

	// location of animation
	point_t loc;

	// LEVEL: level
	int level;

	// RANDOM: period deviation (<8),
	float data1;

	// RANDOM: random base period,
	float data2;

	// actual graphics for frames of animations
	int p[3];

	// following must be initialised to zero before use!

	// next value of btime (used in conjunction with period)
	float nexttime;

	// next frame number to animate
	int ctr;
};

#endif

// background (map of levels).
int patchINTERPIC;

int LeaveTitlePic;
int EnterTitlePic;

int interstate;

// used for timing of background animation
float btime;

int sp_state;
int ng_state;
int dm_state;

int				TotalKills;
int				TotalItems;
int				TotalSecret;

int cnt_kills[MAXPLAYERS];
int cnt_items[MAXPLAYERS];
int cnt_secret[MAXPLAYERS];
int cnt_time;
float cnt_pause;
int cnt_frags[MAXPLAYERS];

int dm_frags[MAXPLAYERS * MAXPLAYERS];
int dm_totals[MAXPLAYERS];

// "killers", "victims"
int killers;
int victims;

// Face background, your face, your dead face
int p[MAXPLAYERS];

int star;
int star_width;

int bstar;

// used for general timing
float cnt;

#ifndef DOOM2

int im_episode;
int im_map;
int im_nextepisode;
int im_nextmap;

anim_t *anims;
int numanims;

bool snl_pointeron;

//
// Data needed to add patches to full screen intermission pics.
// Patches are statistics messages, and animations.
// Loads of by-pixel layout and placement, offsets etc.
//

// You Are Here graphic
int yah[2];

// splat
int splat;

//
//  Animation locations. Using patches saves a lot of space, as they replace
// 320x200 full screen frames.
//
anim_t epsd0animinfo[10];
anim_t epsd1animinfo[9];
anim_t epsd2animinfo[6];

point_t lnodes[NUMEPISODES * NUMMAPS];

#endif

//==========================================================================
//
//  Start
//
//==========================================================================

void Start()
{
#ifndef DOOM2
	SetAnim(&epsd0animinfo[0], ANIM_ALWAYS, 1.0 / 3.0, 3, 224, 104);
	SetAnim(&epsd0animinfo[1], ANIM_ALWAYS, 1.0 / 3.0, 3, 184, 160);
	SetAnim(&epsd0animinfo[2], ANIM_ALWAYS, 1.0 / 3.0, 3, 112, 136);
	SetAnim(&epsd0animinfo[3], ANIM_ALWAYS, 1.0 / 3.0, 3, 72, 112);
	SetAnim(&epsd0animinfo[4], ANIM_ALWAYS, 1.0 / 3.0, 3, 88, 96);
	SetAnim(&epsd0animinfo[5], ANIM_ALWAYS, 1.0 / 3.0, 3, 64, 48);
	SetAnim(&epsd0animinfo[6], ANIM_ALWAYS, 1.0 / 3.0, 3, 192, 40);
	SetAnim(&epsd0animinfo[7], ANIM_ALWAYS, 1.0 / 3.0, 3, 136, 16);
	SetAnim(&epsd0animinfo[8], ANIM_ALWAYS, 1.0 / 3.0, 3, 80, 16);
	SetAnim(&epsd0animinfo[9], ANIM_ALWAYS, 1.0 / 3.0, 3, 64, 24);

	SetAnim2(&epsd1animinfo[0], ANIM_LEVEL, 1.0 / 3.0, 1, 128, 136, 1);
	SetAnim2(&epsd1animinfo[1], ANIM_LEVEL, 1.0 / 3.0, 1, 128, 136, 2);
	SetAnim2(&epsd1animinfo[2], ANIM_LEVEL, 1.0 / 3.0, 1, 128, 136, 3);
	SetAnim2(&epsd1animinfo[3], ANIM_LEVEL, 1.0 / 3.0, 1, 128, 136, 4);
	SetAnim2(&epsd1animinfo[4], ANIM_LEVEL, 1.0 / 3.0, 1, 128, 136, 5);
	SetAnim2(&epsd1animinfo[5], ANIM_LEVEL, 1.0 / 3.0, 1, 128, 136, 6);
	SetAnim2(&epsd1animinfo[6], ANIM_LEVEL, 1.0 / 3.0, 1, 128, 136, 7);
	SetAnim2(&epsd1animinfo[7], ANIM_LEVEL, 1.0 / 3.0, 3, 192, 144, 8);
	SetAnim2(&epsd1animinfo[8], ANIM_LEVEL, 1.0 / 3.0, 1, 128, 136, 8);

	SetAnim(&epsd2animinfo[0], ANIM_ALWAYS, 1.0 / 3.0, 3, 104, 168);
	SetAnim(&epsd2animinfo[1], ANIM_ALWAYS, 1.0 / 3.0, 3, 40, 136);
	SetAnim(&epsd2animinfo[2], ANIM_ALWAYS, 1.0 / 3.0, 3, 160, 96);
	SetAnim(&epsd2animinfo[3], ANIM_ALWAYS, 1.0 / 3.0, 3, 104, 80);
	SetAnim(&epsd2animinfo[4], ANIM_ALWAYS, 1.0 / 3.0, 3, 120, 32);
	SetAnim(&epsd2animinfo[5], ANIM_ALWAYS, 1.0 / 4.0, 3, 40, 0);

	// Episode 0 World Map
	SetLN(0, 0, 185, 164);	// location of level 0 (CJ)
	SetLN(0, 1, 148, 143);	// location of level 1 (CJ)
	SetLN(0, 2, 69, 122);	// location of level 2 (CJ)
	SetLN(0, 3, 209, 102);	// location of level 3 (CJ)
	SetLN(0, 4, 116, 89);	// location of level 4 (CJ)
	SetLN(0, 5, 166, 55);	// location of level 5 (CJ)
	SetLN(0, 6, 71, 56);	// location of level 6 (CJ)
	SetLN(0, 7, 135, 29);	// location of level 7 (CJ)
	SetLN(0, 8, 71, 24);	// location of level 8 (CJ)

	// Episode 1 World Map should go here
	SetLN(1, 0, 254, 25);	// location of level 0 (CJ)
	SetLN(1, 1, 97, 50);	// location of level 1 (CJ)
	SetLN(1, 2, 188, 64);	// location of level 2 (CJ)
	SetLN(1, 3, 128, 78);	// location of level 3 (CJ)
	SetLN(1, 4, 214, 92);	// location of level 4 (CJ)
	SetLN(1, 5, 133, 130);	// location of level 5 (CJ)
	SetLN(1, 6, 208, 136);	// location of level 6 (CJ)
	SetLN(1, 7, 148, 140);	// location of level 7 (CJ)
	SetLN(1, 8, 235, 158);	// location of level 8 (CJ)

	// Episode 2 World Map should go here
	SetLN(2, 0, 156, 168);	// location of level 0 (CJ)
	SetLN(2, 1, 48, 154);	// location of level 1 (CJ)
	SetLN(2, 2, 174, 95);	// location of level 2 (CJ)
	SetLN(2, 3, 265, 75);	// location of level 3 (CJ)
	SetLN(2, 4, 130, 48);	// location of level 4 (CJ)
	SetLN(2, 5, 279, 23);	// location of level 5 (CJ)
	SetLN(2, 6, 198, 48);	// location of level 6 (CJ)
	SetLN(2, 7, 140, 25);	// location of level 7 (CJ)
	SetLN(2, 8, 281, 136);	// location of level 8 (CJ)
#endif

	ClGame.skipintermission = false;
	cnt = 0.0;
	btime = 0.0;

#ifndef DOOM2
	FindEpisodeAndMap(ClGame.im->LeaveMap, &im_episode, &im_map);
	FindEpisodeAndMap(ClGame.im->EnterMap, &im_nextepisode, &im_nextmap);

	IM_InitAnimatedBack();
#endif

	TotalKills = ClGame.cl.Level.TotalKills;
	TotalItems = ClGame.cl.Level.TotalItems;
	TotalSecret = ClGame.cl.Level.TotalSecret;

	if (!TotalKills)
		TotalKills = 1;

	if (!TotalItems)
		TotalItems = 1;

	if (!TotalSecret)
		TotalSecret = 1;

	if (ClGame.deathmatch)
		IM_InitDeathmatchStats();
	else if (ClGame.maxclients > 1)
		IM_InitCooperativeStats();
	else
		IM_InitSingleStats();

	if (interstate == IMS_Stats)
	{
		IM_LoadData();

	// intermission music
#ifdef FIXME
#ifdef DOOM2
		S_StartSong("D_DM2INT", P_GetCDIntermissionTrack(), true);
#else
		S_StartSong("D_INTER", P_GetCDIntermissionTrack(), true);
#endif
#else
#ifdef DOOM2
		CmdBuf_AddText("music loop D_DM2INT\n");
#else
		CmdBuf_AddText("music loop D_INTER\n");
#endif
#endif
	}
	else
	{
		IM_InitText();
	}
}

#ifndef DOOM2
//==========================================================================
//
//  SetAnim
//
//==========================================================================

void SetAnim(anim_t* a, int Type, float Period, int NAnims, int x, int y)
{
	a->type = Type;
	a->period = Period;
	a->nanims = NAnims;
	a->loc.x = x;
	a->loc.y = y;
}

//==========================================================================
//
//  SetAnim2
//
//==========================================================================

void SetAnim2(anim_t* a, int Type, float Period, int NAnims, int x, int y, int level)
{
	a->type = Type;
	a->period = Period;
	a->nanims = NAnims;
	a->loc.x = x;
	a->loc.y = y;
	a->level = level;
}

//==========================================================================
//
//  SetLN
//
//==========================================================================

void SetLN(int epi, int map, int x, int y)
{
	lnodes[epi * NUMMAPS + map].x = x * 2;
	lnodes[epi * NUMMAPS + map].y = y * 480 / 200;
}

//==========================================================================
//
//  FindEpisodeAndMap
//
//==========================================================================

void FindEpisodeAndMap(name Name, int *epi, int *map)
{
	int e;
	int m;

	for (e = 1; e <= 3; e++)
	{
		for (m = 1; m <= 9; m++)
		{
			if (Name == StrToName(va("e%dm%d", e, m)))
			{
				*epi = e;
				*map = m;
				return;
			}
		}
	}
	*epi = 4;
	*map = 1;
}
#endif

//==========================================================================
//
//	Tick
//
//  Updates stuff each frame
//
//==========================================================================

void Tick(float DeltaTime)
{
	// counter for general background animation
	btime += DeltaTime;

#ifndef DOOM2
	IM_UpdateBackground();
#endif
	switch (interstate)
	{
	case IMS_Stats:
		if (ClGame.deathmatch)
			IM_UpdateDeathmatchStats(DeltaTime);
		else if (ClGame.maxclients > 1)
			IM_UpdateCooperativeStats(DeltaTime);
		else
			IM_UpdateSingleStats(DeltaTime);
		break;

#ifndef DOOM2
	case IMS_NextLoc:
		IM_UpdateNextLoc(DeltaTime);
		break;
#endif

	case IMS_NoState:
		IM_UpdateNoState(DeltaTime);
		break;

	case IMS_Text:
		IM_UpdateText(DeltaTime);
		break;

	case IMS_Done:
		break;
	}
}

//==========================================================================
//
//  DrawWindow
//
//==========================================================================

void DrawWindow(GC gc)
{
	T_SetFont(font_big);

	switch (interstate)
	{
	case IMS_Stats:
		IM_DrawBackground();

		if (ClGame.deathmatch)
		{
			IM_DrawDeathmatchStats();
		}
		else if (ClGame.maxclients > 1)
		{
			IM_DrawCooperativeStats();
		}
		else
		{
			IM_DrawSingleStats();
		}
		break;

#ifndef DOOM2
	case IMS_NextLoc:
		IM_DrawBackground();

		IM_DrawNextLoc();
		break;
#endif

	case IMS_NoState:
		IM_DrawBackground();

		IM_DrawNoState();
		break;

	case IMS_Text:
		IM_DrawText(gc);
		break;

	case IMS_Done:
		break;
	}
}

//**************************************************************************
//**
//**    Animated background
//**
//**************************************************************************

#ifndef DOOM2

//==========================================================================
//
//  IM_InitAnimatedBack
//
//==========================================================================

void IM_InitAnimatedBack()
{
	int i;
	anim_t *a;

	switch (im_episode)
	{
	case 1:
		anims = &epsd0animinfo[0];
		numanims = 10;
		break;

	case 2:
		anims = &epsd1animinfo[0];
		numanims = 9;
		break;

	case 3:
		anims = &epsd2animinfo[0];
		numanims = 6;
		break;

	default:
		return;
	}

	for (i = 0; i < numanims; i++)
	{
		a = &anims[i];

		// init variables
		a->ctr = -1;

		// specify the next time to draw it
		if (a->type == ANIM_ALWAYS)
			a->nexttime = btime + 0.1 + Random() * a->period;
		else if (a->type == ANIM_RANDOM)
			a->nexttime = btime + 0.1 + a->data2 + Random() * a->data1;
		else if (a->type == ANIM_LEVEL)
			a->nexttime = btime + 0.1;
	}
}

//==========================================================================
//
//  IM_DrawBackground
//
//==========================================================================

void IM_DrawBackground()
{
	SetVirtualScreen(320, 200);
	R_DrawPic(0, 0, patchINTERPIC);
	// draw animated background
	if (im_episode <= 3)
	{
		int i;
		anim_t *a;

		for (i = 0; i < numanims; i++)
		{
			a = &anims[i];
			if (a->ctr >= 0)
			{
				R_DrawPic(a->loc.x, a->loc.y, a->p[a->ctr]);
			}
		}
	}
	SetVirtualScreen(640, 480);
}

//==========================================================================
//
//  IM_UpdateBackground
//
//==========================================================================

void IM_UpdateBackground()
{
	int i;
	anim_t *a;

	if (im_episode > 3)
		return;

	for (i = 0; i < numanims; i++)
	{
		a = &anims[i];

		if (btime >= a->nexttime)
		{
			switch (a->type)
			{
			case ANIM_ALWAYS:
				if (++a->ctr >= a->nanims)
					a->ctr = 0;
				a->nexttime = btime + a->period;
				break;

			case ANIM_RANDOM:
				a->ctr++;
				if (a->ctr == a->nanims)
				{
					a->ctr = -1;
					a->nexttime = btime + a->data2 + Random() * a->data1;
				}
				else
				{
					a->nexttime = btime + a->period;
				}
				break;

			case ANIM_LEVEL:
				// gawd-awful hack for level anims
				if ((interstate || i != 7) && im_nextmap - 1 == a->level)
				{
					a->ctr++;
					if (a->ctr == a->nanims)
						a->ctr--;
					a->nexttime = btime + a->period;
				}
				break;
			}
		}
	}
}
#endif
#ifdef DOOM2

//==========================================================================
//
//  IM_DrawBackground
//
//==========================================================================

void IM_DrawBackground()
{
	SetVirtualScreen(320, 200);
	R_DrawPic(0, 0, patchINTERPIC);
	SetVirtualScreen(640, 480);
}
#endif

//==========================================================================
//
//  IM_LoadData
//
//==========================================================================

void IM_LoadData()
{
	picinfo_t info;
	int i;

	// background
#ifdef DOOM2
	patchINTERPIC = R_RegisterPic('interpic');
#else
	int j;
	anim_t *a;

	if (im_episode > 3)
	{
		patchINTERPIC = R_RegisterPic('interpic');
	}
	else
	{
		patchINTERPIC =
			R_RegisterPic(StrToName(va("wimap%d", im_episode - 1)));
	}

	// you are here
	yah[0] = R_RegisterPic('wiurh0');

	// you are here (alt.)
	yah[1] = R_RegisterPic('wiurh1');

	// splat
	splat = R_RegisterPic('wisplat');

	if (im_episode < 4)
	{
		for (j = 0; j < numanims; j++)
		{
			a = &anims[j];
			for (i = 0; i < a->nanims; i++)
			{
				// MONDO HACK!
				if (im_episode != 2 || j != 8)
				{
					// animations
					a->p[i] = R_RegisterPic(StrToName(va("wia%d0%d0%d",
						im_episode - 1, j, i)));
				}
				else
				{
					// HACK ALERT!
					a->p[i] = epsd1animinfo[4].p[i];
				}
			}
		}
	}
#endif

	if (ClGame.im->LeaveTitlePatch)
	{
		LeaveTitlePic = R_RegisterPic(ClGame.im->LeaveTitlePatch);
	}
	if (ClGame.im->EnterTitlePatch)
	{
		EnterTitlePic = R_RegisterPic(ClGame.im->EnterTitlePatch);
	}

	if (ClGame.maxclients > 1 || ClGame.deathmatch)
	{
		// "killers" (vertical)
		killers = R_RegisterPic('wikilrs');

		// "victims" (horiz)
		victims = R_RegisterPic('wivctms');

		// face backgrounds
//      for (i = 0; i < MAXPLAYERS; i++)
		for (i = 0; i < 4; i++)
		{
			p[i] = R_RegisterPic(StrToName(va("stpb%i", i)));
		}

		// your face
		star = R_RegisterPic('stfst01');
		R_GetPicInfo(star, &info);
		star_width = info.width;

		// dead face
		bstar = R_RegisterPic('stfdead0');
	}
}

//==========================================================================
//
//  IM_UnloadData
//
//==========================================================================

void IM_UnloadData()
{
}

//==========================================================================
//
//  IM_DrawLF
//
//  Draws "<Levelname> Finished!"
//
//==========================================================================

void IM_DrawLF()
{
	picinfo_t info;
	int y = WI_TITLEY;

	// draw <LevelName>
	if (ClGame.im->LeaveTitlePatch)
	{
		R_GetPicInfo(LeaveTitlePic, &info);
		R_DrawPic(320 - info.width / 2, y, LeaveTitlePic);
		y += info.height + T_TextHeight("DUMMY") / 4;
	}
	else
	{
		T_SetAlign(hcentre, vtop);
		T_DrawText(320, y, ClGame.im->LeaveName);
		y += (5 * T_TextHeight("DUMMY")) / 4;
	}

	// draw "Finished!"
	T_SetAlign(hcentre, vtop);
	T_DrawText(320, y, "finished");
}

//==========================================================================
//
//  IM_DrawEL
//
//  Draws "Entering <LevelName>"
//
//==========================================================================

void IM_DrawEL()
{
	picinfo_t info;
	int y = WI_TITLEY;

	// draw "Entering"
	T_SetAlign(hcentre, vtop);
	T_DrawText(320, y, "entering");

	// draw level
	y += (5 * T_TextHeight("DUMMY")) / 4;
	if (ClGame.im->EnterTitlePatch)
	{
		R_GetPicInfo(EnterTitlePic, &info);
		R_DrawPic(320 - info.width / 2, y, EnterTitlePic);
	}
	else
	{
		T_DrawText(320, y, ClGame.im->EnterName);
	}
}

//==========================================================================
//
//  IM_DrawPercent
//
//==========================================================================

void IM_DrawPercent(int x, int y, int p)
{
	if (p < 0)
		return;

	T_SetAlign(hright, vtop);
	T_DrawText(x, y, va("%d%%", p));
}

//==========================================================================
//
//  IM_DrawTime
//
//  Display level completion time and par, or "sucks" message if overflow.
//
//==========================================================================

void IM_DrawTime(int x, int y, int t, string BaseText, bool sucks)
{
	if (t < 0)
		return;

	T_SetAlign(hleft, vtop);

	string Text;
	if (!sucks || !ClGame.cl.Level.SuckTime || t < ClGame.cl.Level.SuckTime * 60 * 60)
	{
		Text = BaseText;
		if (t >= 60 * 60)
		{
			Text = strcat(Text, va("%d:", t / (60 * 60)));
			if ((t / 60) % 60 < 10)
				Text = strcat(Text, va("0%d", (t / 60) % 60));
			else
				Text = strcat(Text, va("%d", (t / 60) % 60));
		}
		else
			Text = strcat(Text, va("%d", t / 60));
		if (t % 60 < 10)
			Text = strcat(Text, va(":0%d", t % 60));
		else
			Text = strcat(Text, va(":%d", t % 60));
	}
	else
	{
		// "sucks"
		Text = strcat(BaseText, "sucks");
	}
	T_DrawText(x, y, Text);
}

//==========================================================================
//
//  IM_InitSingleStats
//
//==========================================================================

void IM_InitSingleStats()
{
	interstate = IMS_Stats;
	ClGame.skipintermission = 0;
	sp_state = 1;
	cnt_kills[0] = -1;
	cnt_items[0] = -1;
	cnt_secret[0] = -1;
	cnt_time = -1;
	cnt_pause = 1.0;
	if (ClGame.cl.Level.bNoIntermission)
	{
		interstate = IMS_NoState;
	}
}

//==========================================================================
//
//  IM_DrawSingleStats
//
//==========================================================================

void IM_DrawSingleStats()
{
	// line height
	int lh;

	lh = (3 * T_TextHeight("DUMMY")) / 2;

	IM_DrawLF();

	T_SetAlign(hleft, vtop);

	T_DrawText(SP_STATSX, SP_STATSY, "kills");
	T_DrawText(SP_STATSX, SP_STATSY + lh, "items");
	T_DrawText(SP_STATSX, SP_STATSY + 2 * lh, "scrt");

	IM_DrawPercent(640 - SP_STATSX, SP_STATSY, cnt_kills[0]);
	IM_DrawPercent(640 - SP_STATSX, SP_STATSY + lh, cnt_items[0]);
	IM_DrawPercent(640 - SP_STATSX, SP_STATSY + 2 * lh, cnt_secret[0]);
	IM_DrawTime(SP_TIMEX, SP_TIMEY, cnt_time, "time: ", true);
	if (cnt_time >= 0 && ClGame.cl.Level.ParTime)
		IM_DrawTime(SP_PARX, SP_PARY, ClGame.cl.Level.ParTime, "par: ", false);
}

//==========================================================================
//
//  IM_UpdateSingleStats
//
//==========================================================================

void IM_UpdateSingleStats(float DeltaTime)
{
	if (ClGame.skipintermission && sp_state != 10)
	{
		ClGame.skipintermission = 0;
		cnt_kills[0] = (ClGame.cl.KillCount * 100) / TotalKills;
		cnt_items[0] = (ClGame.cl.ItemCount * 100) / TotalItems;
		cnt_secret[0] = (ClGame.cl.SecretCount * 100) / TotalSecret;
		cnt_time = ftoi(ClGame.GLevel.LevelInfo.CompletitionTime);
		LocalSound('weapons/rocklx');
		sp_state = 10;
	}

	if (sp_state == 2)
	{
		cnt_kills[0] += 2;

		if (!(ftoi(btime * 35.0) & 3))
			LocalSound('weapons/pistol');

		if (cnt_kills[0] >= (ClGame.cl.KillCount * 100) / TotalKills)
		{
			cnt_kills[0] = (ClGame.cl.KillCount * 100) / TotalKills;
			LocalSound('weapons/rocklx');
			sp_state++;
		}
	}
	else if (sp_state == 4)
	{
		cnt_items[0] += 2;

		if (!(ftoi(btime * 35.0) & 3))
			LocalSound('weapons/pistol');

		if (cnt_items[0] >= (ClGame.cl.ItemCount * 100) / TotalItems)
		{
			cnt_items[0] = (ClGame.cl.ItemCount * 100) / TotalItems;
			LocalSound('weapons/rocklx');
			sp_state++;
		}
	}
	else if (sp_state == 6)
	{
		cnt_secret[0] += 2;

		if (!(ftoi(btime * 35.0) & 3))
			LocalSound('weapons/pistol');

		if (cnt_secret[0] >= (ClGame.cl.SecretCount * 100) / TotalSecret)
		{
			cnt_secret[0] = (ClGame.cl.SecretCount * 100) / TotalSecret;
			LocalSound('weapons/rocklx');
			sp_state++;
		}
	}

	else if (sp_state == 8)
	{
		if (!(ftoi(btime * 35.0) & 3))
			LocalSound('weapons/pistol');

		cnt_time += 3;

		if (cnt_time >= ftoi(ClGame.GLevel.LevelInfo.CompletitionTime))
		{
			cnt_time = ftoi(ClGame.GLevel.LevelInfo.CompletitionTime);
			LocalSound('weapons/rocklx');
			sp_state++;
		}
	}
	else if (sp_state == 10)
	{
		if (ClGame.skipintermission)
		{
			LocalSound('weapons/shotgr');

#ifdef DOOM2
			IM_InitNoState();
#else
			IM_InitNextLoc();
#endif
		}
	}
	else if (sp_state & 1)
	{
		cnt_pause -= DeltaTime;
		if (cnt_pause <= 0.0)
		{
			sp_state++;
			cnt_pause = 1.0;
		}
	}

}

//==========================================================================
//
//  IM_InitCooperativeStats
//
//==========================================================================

void IM_InitCooperativeStats()
{
	int i;

	interstate = IMS_Stats;
	ClGame.skipintermission = 0;
	ng_state = 1;

	cnt_pause = 1.0;

	for (i = 0; i < MAXPLAYERS; i++)
	{
		cnt_kills[i] = 0;
		cnt_items[i] = 0;
		cnt_secret[i] = 0;
		cnt_frags[i] = 0;
	}

	if (ClGame.cl.Level.bNoIntermission)
	{
		interstate = IMS_NoState;
	}
}

//==========================================================================
//
//  IM_DrawCooperativeStats
//
//==========================================================================

void IM_DrawCooperativeStats()
{
	int i;
	int x;
	int y;
	int pwidth;
	picinfo_t info;
	PlayerReplicationInfo RepInfo;

	pwidth = T_TextWidth("%");

	IM_DrawLF();

	T_SetAlign(hright, vtop);
	// draw stat titles (top line)
	T_DrawText(NG_STATSX + NG_SPACINGX, NG_STATSY, "kills");

	T_DrawText(NG_STATSX + 2 * NG_SPACINGX, NG_STATSY, "items");

	T_DrawText(NG_STATSX + 3 * NG_SPACINGX, NG_STATSY, "scrt");

	T_DrawText(NG_STATSX + 4 * NG_SPACINGX, NG_STATSY, "frgs");

	// draw stats
	y = NG_STATSY + T_TextHeight("kills");

	foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo)
	{
		i = RepInfo.PlayerNum;
		x = NG_STATSX;
		R_GetPicInfo(p[i], &info);
		R_DrawPic(x - info.width, y, p[i]);

		if (i == ClGame.cl.ClientNum)
			R_DrawPic(x - info.width, y, star);

		x += NG_SPACINGX;
		IM_DrawPercent(x - pwidth, y + 10, cnt_kills[i]);
		x += NG_SPACINGX;
		IM_DrawPercent(x - pwidth, y + 10, cnt_items[i]);
		x += NG_SPACINGX;
		IM_DrawPercent(x - pwidth, y + 10, cnt_secret[i]);
		x += NG_SPACINGX;

		T_SetAlign(hright, vtop);
		T_DrawText(x, y + 10, va("%d", cnt_frags[i]));

		y += WI_SPACINGY;
	}
}

//==========================================================================
//
//  IM_UpdateCooperativeStats
//
//==========================================================================

void IM_UpdateCooperativeStats(float DeltaTime)
{
	int fsum;
	PlayerReplicationInfo	RepInfo;

	bool stillticking;

	if (ClGame.skipintermission && ng_state != 10)
	{
		ClGame.skipintermission = 0;

		foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo)
		{
			cnt_kills[RepInfo.PlayerNum] = (RepInfo.KillCount * 100) / TotalKills;
			cnt_items[RepInfo.PlayerNum] = (RepInfo.ItemCount * 100) / TotalItems;
			cnt_secret[RepInfo.PlayerNum] = (RepInfo.SecretCount * 100) / TotalSecret;
			cnt_frags[RepInfo.PlayerNum] = RepInfo.Frags;
		}
		LocalSound('weapons/rocklx');
		ng_state = 10;
	}

	if (ng_state == 2)
	{
		if (!(ftoi(btime * 35.0) & 3))
			LocalSound('weapons/pistol');

		stillticking = false;

		foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo)
		{
			cnt_kills[RepInfo.PlayerNum] += 2;

			if (cnt_kills[RepInfo.PlayerNum] >= (RepInfo.KillCount * 100) / TotalKills)
				cnt_kills[RepInfo.PlayerNum] = (RepInfo.KillCount * 100) / TotalKills;
			else
				stillticking = true;
		}

		if (!stillticking)
		{
			LocalSound('weapons/rocklx');
			ng_state++;
		}
	}
	else if (ng_state == 4)
	{
		if (!(ftoi(btime * 35.0) & 3))
			LocalSound('weapons/pistol');

		stillticking = false;

		foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo)
		{
			cnt_items[RepInfo.PlayerNum] += 2;
			if (cnt_items[RepInfo.PlayerNum] >= (RepInfo.ItemCount * 100) / TotalItems)
				cnt_items[RepInfo.PlayerNum] = (RepInfo.ItemCount * 100) / TotalItems;
			else
				stillticking = true;
		}
		if (!stillticking)
		{
			LocalSound('weapons/rocklx');
			ng_state++;
		}
	}
	else if (ng_state == 6)
	{
		if (!(ftoi(btime * 35.0) & 3))
			LocalSound('weapons/pistol');

		stillticking = false;

		foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo)
		{
			cnt_secret[RepInfo.PlayerNum] += 2;

			if (cnt_secret[RepInfo.PlayerNum] >= RepInfo.SecretCount * 100 / TotalSecret)
				cnt_secret[RepInfo.PlayerNum] = RepInfo.SecretCount * 100 / TotalSecret;
			else
				stillticking = true;
		}

		if (!stillticking)
		{
			LocalSound('weapons/rocklx');
			ng_state += 1;
		}
	}
	else if (ng_state == 8)
	{
		if (!(ftoi(btime * 35.0) & 3))
			LocalSound('weapons/pistol');

		stillticking = false;

		foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo)
		{
			cnt_frags[RepInfo.PlayerNum] += 1;

			if (cnt_frags[RepInfo.PlayerNum] >= RepInfo.Frags)
				cnt_frags[RepInfo.PlayerNum] = RepInfo.Frags;
			else
				stillticking = true;
		}

		if (!stillticking)
		{
			LocalSound('*death');
			ng_state++;
		}
	}
	else if (ng_state == 10)
	{
		if (ClGame.skipintermission)
		{
			LocalSound('weapons/shotgr');
#ifdef DOOM2
			IM_InitNoState();
#else
			IM_InitNextLoc();
#endif
		}
	}
	else if (ng_state & 1)
	{
		cnt_pause -= DeltaTime;
		if (cnt_pause <= 0.0)
		{
			ng_state++;
			cnt_pause = 1.0;
		}
	}
}

//==========================================================================
//
//  IM_InitDeathmatchStats
//
//==========================================================================

void IM_InitDeathmatchStats()
{
	int						i;
	int						j;
	PlayerReplicationInfo	RepInfo;

	interstate = IMS_Stats;
	ClGame.skipintermission = 0;
	dm_state = 1;

	cnt_pause = 1.0;

	foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo)
	{
		i = RepInfo.PlayerNum;
		for (j = 0; j < MAXPLAYERS; j++)
			dm_frags[i * MAXPLAYERS + j] = 0;

		dm_totals[i] = 0;
	}
}

//==========================================================================
//
//  IM_DrawDeathmatchStats
//
//==========================================================================

void IM_DrawDeathmatchStats()
{
	int i;
	int j;
	int x;
	int y;
	int w;
	int lh;	// line height
	picinfo_t info;
	PlayerReplicationInfo RepInfo;
	PlayerReplicationInfo Other;

	lh = WI_SPACINGY;

	IM_DrawLF();

	T_SetAlign(hcentre, vtop);
	// draw stat titles (top line)
	T_DrawText(DM_TOTALSX, DM_MATRIXY - WI_SPACINGY + 10, "total");

	R_DrawPic(DM_KILLERSX, DM_KILLERSY, killers);
	R_DrawPic(DM_VICTIMSX, DM_VICTIMSY, victims);

	// draw P?
	x = DM_MATRIXX + DM_SPACINGX;
	y = DM_MATRIXY;

	foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo)
	{
		i = RepInfo.PlayerNum;
		R_GetPicInfo(p[i], &info);
		R_DrawPic(x - info.width / 2, DM_MATRIXY - WI_SPACINGY, p[i]);
		R_DrawPic(DM_MATRIXX - info.width / 2, y, p[i]);

		if (i == ClGame.cl.ClientNum)
		{
			R_DrawPic(x - info.width / 2, DM_MATRIXY - WI_SPACINGY,
				bstar);
			R_DrawPic(DM_MATRIXX - info.width / 2, y, star);
		}
		x += DM_SPACINGX;
		y += WI_SPACINGY;
	}

	// draw stats
	y = DM_MATRIXY + 10;
	w = T_TextWidth("0");

	T_SetAlign(hright, vtop);
	foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo)
	{
		i = RepInfo.PlayerNum;
		x = DM_MATRIXX + DM_SPACINGX;

		foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, Other)
		{
			j = Other.PlayerNum;
			T_DrawText(x + w, y, va("%d", dm_frags[i * MAXPLAYERS + j]));
			x += DM_SPACINGX;
		}
		T_DrawText(DM_TOTALSX + w, y, va("%d", dm_totals[i]));
		y += WI_SPACINGY;
	}
}

//==========================================================================
//
//  IM_UpdateDeathmatchStats
//
//==========================================================================

void IM_UpdateDeathmatchStats(float DeltaTime)
{
	int i;
	int j;

	bool stillticking;
	PlayerReplicationInfo	RepInfo;
	PlayerReplicationInfo	Other;

	if (ClGame.skipintermission && dm_state != 4)
	{
		ClGame.skipintermission = 0;

		foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo)
		{
			foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, Other)
			{
				dm_frags[RepInfo.PlayerNum * MAXPLAYERS + Other.PlayerNum] =
					RepInfo.FragsStats[Other.PlayerNum];
			}

			dm_totals[RepInfo.PlayerNum] = RepInfo.Frags;
		}

		LocalSound('weapons/rocklx');
		dm_state = 4;
	}

	if (dm_state == 2)
	{
		if (!(ftoi(btime * 35.0) & 3))
			LocalSound('weapons/pistol');

		stillticking = false;

		foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo)
		{
			i = RepInfo.PlayerNum;
			foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, Other)
			{
				j = Other.PlayerNum;
				if (dm_frags[i * MAXPLAYERS + j] != RepInfo.FragsStats[j])
				{
					if (RepInfo.FragsStats[j] < 0)
						dm_frags[i * MAXPLAYERS + j]--;
					else
						dm_frags[i * MAXPLAYERS + j]++;

					if (dm_frags[i * MAXPLAYERS + j] > 99)
						dm_frags[i * MAXPLAYERS + j] = 99;

					if (dm_frags[i * MAXPLAYERS + j] < -99)
						dm_frags[i * MAXPLAYERS + j] = -99;

					stillticking = true;
				}
			}
			dm_totals[i] = RepInfo.Frags;

			if (dm_totals[i] > 99)
				dm_totals[i] = 99;

			if (dm_totals[i] < -99)
				dm_totals[i] = -99;
		}
		if (!stillticking)
		{
			LocalSound('weapons/rocklx');
			dm_state++;
		}

	}
	else if (dm_state == 4)
	{
		if (ClGame.skipintermission)
		{
			LocalSound('misc/gibbed');

#ifdef DOOM2
			IM_InitNoState();
#else
			IM_InitNextLoc();
#endif
		}
	}
	else if (dm_state & 1)
	{
		cnt_pause -= DeltaTime;
		if (cnt_pause <= 0.0)
		{
			dm_state++;
			cnt_pause = 1.0;
		}
	}
}

#ifndef DOOM2

//==========================================================================
//
//  IM_InitNextLoc
//
//==========================================================================

void IM_InitNextLoc()
{
	interstate = IMS_NextLoc;
	ClGame.skipintermission = 0;
	cnt = SHOWNEXTLOCDELAY;

	IM_InitAnimatedBack();
}

//==========================================================================
//
//  IM_DrawOnLnode
//
//==========================================================================

void IM_DrawOnLnode(int n, int *c)
{
	int i;
	int left;
	int top;
	int right;
	int bottom;
	bool fits;
	picinfo_t info;

	fits = false;
	i = 0;
	do
	{
		R_GetPicInfo(c[i], &info);
		left = lnodes[(im_episode - 1) * NUMMAPS + n].x - info.xoffset;
		top = lnodes[(im_episode - 1) * NUMMAPS + n].y - info.yoffset;
		right = left + info.width;
		bottom = top + info.height;

		if (left >= 0 && right < 640 && top >= 0 && bottom < 480)
		{
			fits = true;
		}
		else
		{
			i++;
		}
	}
	while (!fits && i != 2);

	if (fits && i < 2)
	{
		R_DrawPic(lnodes[(im_episode - 1) * NUMMAPS + n].x, lnodes[(im_episode - 1) * NUMMAPS + n].y,
			c[i]);
	}
	else
	{
		// DEBUG
		dprint("Could not place patch on level %d", n + 1);
	}
}

//==========================================================================
//
//  IM_DrawNextLoc
//
//==========================================================================

void IM_DrawNextLoc()
{
	int i;
	int last;

	if (im_episode <= 3)
	{
		last = (im_map == 9) ? im_nextmap - 2 : im_map - 1;

		// draw a splat on taken cities.
		for (i = 0; i <= last; i++)
			IM_DrawOnLnode(i, &splat);

		// splat the secret level?
		if (ClGame.cl.bDidSecret)
			IM_DrawOnLnode(8, &splat);

		// draw flashing ptr
		if (snl_pointeron)
			IM_DrawOnLnode(im_nextmap - 1, &yah[0]);
	}

	// draws which level you are entering..
	IM_DrawEL();
}

//==========================================================================
//
//  IM_UpdateNextLoc
//
//==========================================================================

void IM_UpdateNextLoc(float DeltaTime)
{
	cnt -= DeltaTime;
	if (cnt <= 0.0 || ClGame.skipintermission)
		IM_InitNoState();
	else
		snl_pointeron = (ftoi(32.0 * cnt) & 31) < 20;
}

#endif

//==========================================================================
//
//  IM_InitNoState
//
//==========================================================================

void IM_InitNoState()
{
	interstate = IMS_NoState;
	ClGame.skipintermission = 0;
	cnt = 0.3;
}

//==========================================================================
//
//  IM_DrawNoState
//
//==========================================================================

void IM_DrawNoState()
{
#ifdef DOOM2
	// draws which level you are entering..
	if (ClGame.im->LeaveMap != 'map30')
	{
		IM_DrawEL();
	}
#else
	snl_pointeron = true;
	IM_DrawNextLoc();
#endif
}

//==========================================================================
//
//  IM_UpdateNoState
//
//==========================================================================

void IM_UpdateNoState(float DeltaTime)
{
	cnt -= DeltaTime;
	if (cnt <= 0.0)
	{
		IM_UnloadData();
		IM_InitText();
	}
}

//==========================================================================
//
//
//
//==========================================================================

// specifies current state
float intertime;

float HubCount;
string HubText;

name TextFlat;
int TextPic;

//==========================================================================
//
//  IM_InitText
//
//==========================================================================

void IM_InitText()
{
	if (ClGame.deathmatch || !ClGame.im->Text)
	{
		CmdBuf_AddText("TeleportNewMap\n");
		interstate = IMS_Done;
		return;
	}

	if (ClGame.im->bTextIsLump)
	{
		HubText = LoadTextLump(StrToName(ClGame.im->Text));
	}
	else
	{
		HubText = ClGame.im->Text;
	}
	HubCount = itof(strlen(HubText)) * TEXTSPEED + TEXTWAIT;

	TextFlat = '';
	TextPic = 0;
	if (ClGame.im->TextPic)
	{
		TextPic = R_RegisterPic(ClGame.im->TextPic);
	}
	else if (ClGame.im->TextFlat)
	{
		TextFlat = ClGame.im->TextFlat;
	}

	interstate = IMS_Text;
	intertime = 0.0;

	if (ClGame.im->TextMusic)
	{
		CmdBuf_AddText(va("music loop %n\n", ClGame.im->TextMusic));
	}
	else
	{
#ifdef DOOM2
#ifdef FIXME
		S_StartSong("d_read_m", P_GetCDEnd1Track(), true);
#else
		CmdBuf_AddText("music loop d_read_m\n");
#endif
#else
#ifdef FIXME
		S_StartSong("D_VICTOR", P_GetCDEnd1Track(), true);
#else
		CmdBuf_AddText("music loop D_VICTOR\n");
#endif
#endif
	}
}

//==========================================================================
//
//  IM_DrawText
//
//==========================================================================

void IM_DrawText(GC gc)
{
	int count;

	// erase the entire screen to a tiled background
	if (TextPic)
	{
		gc.DrawFullScreenPic(TextPic);
	}
	else if (TextFlat)
	{
		R_FillRectWithFlat(0, 0, 640, 480, TextFlat);
	}
	else
	{
		R_FillRect(0, 0, 640, 480, 0);
	}

	// draw some of the text onto the screen
	count = ftoi((intertime - 0.3) / TEXTSPEED);
	if (count < 0)
		count = 0;
	if (count > strlen(HubText))
		count = strlen(HubText);

	T_SetFont(font_small);
	T_SetAlign(hleft, vtop);
	T_DrawText(170, 150, substr(HubText, 0, count));
}

//==========================================================================
//
//  IM_UpdateText
//
//==========================================================================

void IM_UpdateText(float DeltaTime)
{
	intertime += DeltaTime;
	if (ClGame.skipintermission || intertime > HubCount)
	{
		ClGame.skipintermission = false;
		CmdBuf_AddText("TeleportNewMap\n");
		interstate = IMS_Done;
	}
}

//==========================================================================
//
//	VisibilityChanged
//
//==========================================================================

void VisibilityChanged(bool bNewVisibility)
{
	bTickEnabled = bNewVisibility;
}

defaultproperties
{
	bTickEnabled = true;
	Width = 640;
	Height = 480;
}
