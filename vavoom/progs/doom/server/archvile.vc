//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

#ifdef DOOM2

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  PIT_VileCheck
//
//  Detect a corpse that could be raised.
//
//==========================================================================

mobj_t *corpsehit;
mobj_t *vileobj;
float viletryx;
float viletryy;

boolean PIT_VileCheck(mobj_t * thing)
{
	float maxdist;
	boolean check;

	if (!(thing->flags & MF_CORPSE))
		return true;	// not a monster

	if (thing->time != -1.0)
		return true;	// not lying still yet

	if (thing->raisestate == S_NULL)
		return true;	// monster doesn't have a raise state

	maxdist = thing->radius + vileobj->radius;

	if (fabs(thing->origin.x - viletryx) > maxdist ||
		fabs(thing->origin.y - viletryy) > maxdist)
		return true;	// not actually touching

	if (!P_CheckSight(vileobj, thing))
		return true;	//  Con't see, possibly in other region

	corpsehit = thing;
	corpsehit->velocity.x = corpsehit->velocity.y = 0.0;
	corpsehit->height *= 4.0;
	check =
		P_CheckPosition(corpsehit, corpsehit->origin.x, corpsehit->origin.y);
	corpsehit->height /= 4.0;

	if (!check)
		return true;	// doesn't fit here

	return false;	// got one, so stop checking
}

//==========================================================================
//
//  A_VileChase
//
//  Arch-vile check for ressurecting a body.
//
//==========================================================================

void A_VileChase(mobj_t * actor)
{
	int xl;
	int xh;
	int yl;
	int yh;

	int bx;
	int by;

	mobjinfo_t *info;
	mobj_t *temp;

	if (actor->movedir != DI_NODIR)
	{
		// check for corpses to raise
		viletryx =
			actor->origin.x +
			actor->speed * frametime * xspeed[actor->movedir];
		viletryy =
			actor->origin.y +
			actor->speed * frametime * yspeed[actor->movedir];
		vileobj = actor;

		xl = MapBlock(viletryx - level->bmaporgx - MAXRADIUS * 2.0);
		xh = MapBlock(viletryx - level->bmaporgx + MAXRADIUS * 2.0);
		yl = MapBlock(viletryy - level->bmaporgy - MAXRADIUS * 2.0);
		yh = MapBlock(viletryy - level->bmaporgy + MAXRADIUS * 2.0);

		for (bx = xl; bx <= xh; bx++)
		{
			for (by = yl; by <= yh; by++)
			{
				// Call PIT_VileCheck to check whether object is a corpse
				// that canbe raised.
				if (!P_BlockThingsIterator(bx, by, PIT_VileCheck))
				{
					// got one!
					temp = actor->target;
					actor->target = corpsehit;
					A_FaceTarget(actor);
					actor->target = temp;

					SetMobjState(actor, S_VILE_HEAL1);
					StartSoundName(corpsehit, "Slop", CHAN_BODY);

					SetMobjState(corpsehit, corpsehit->raisestate);
					corpsehit->height *= 4.0;
#ifdef FIXME
					corpsehit->flags = info->flags;
#else
					corpsehit->flags |= MF_SOLID;
					corpsehit->flags &= ~(MF_CORPSE);
#endif
					corpsehit->health = corpsehit->spawnhealth;
					corpsehit->target = NULL;

					return;
				}
			}
		}
	}
	// Return to normal attack.
	A_Chase(actor);
}

//==========================================================================
//
//  A_VileStart
//
//  Arch-vile attack start sound.
//
//==========================================================================

void A_VileStart(mobj_t * actor)
{
	StartSoundName(actor, "ArchVileAttack", CHAN_WEAPON);
}

//==========================================================================
//
//  A_VileTarget
//
//  Spawn the hellfire.
//
//==========================================================================

void A_Fire(mobj_t * actor);

void A_VileTarget(mobj_t * actor)
{
	mobj_t *fog;

	if (!actor->target)
		return;

	A_FaceTarget(actor);

	fog = P_SpawnMobj(actor->target->origin.x, actor->target->origin.x,
		actor->target->origin.z, MT_FIRE);

	actor->tracer = fog;
	fog->target = actor;
	fog->tracer = actor->target;
	A_Fire(fog);
}

//==========================================================================
//
//  A_VileAttack
//
//  Arch-vile attack.
//
//==========================================================================

void A_VileAttack(mobj_t * actor)
{
	mobj_t *fire;

	if (!actor->target)
		return;

	A_FaceTarget(actor);

	if (!P_CheckSight(actor, actor->target))
		return;

	StartSoundName(actor, "BarrelExplode", CHAN_WEAPON);
	DamageMobj(actor->target, actor, actor, 20);
	actor->target->velocity.z = 1000.0 / actor->target->mass * 35.0;

	fire = actor->tracer;

	if (!fire)
		return;

	// move the fire between the vile and the player
	fire->origin.x = actor->target->origin.x - 24.0 * cos(actor->angles.yaw);
	fire->origin.y = actor->target->origin.y - 24.0 * sin(actor->angles.yaw);
	P_RadiusAttack(fire, actor, 70, 0, 0);
}

//==========================================================================
//
//  A_StartFire
//
//  Make fire start sound.
//
//==========================================================================

void A_StartFire(mobj_t * actor)
{
	StartSoundName(actor, "FlameStart", CHAN_VOICE);
	A_Fire(actor);
}

//==========================================================================
//
//  A_Fire
//
//  Keep fire in front of player unless out of sight.
//
//==========================================================================

void A_Fire(mobj_t * actor)
{
	mobj_t *dest;

	dest = actor->tracer;
	if (!dest)
		return;

	// don't move it if the vile lost sight
	if (!P_CheckSight(actor->target, dest))
		return;

	P_UnsetThingPosition(actor);
	actor->origin.x = dest->origin.x + 24.0 * cos(dest->angles.yaw);
	actor->origin.y = dest->origin.y + 24.0 * sin(dest->angles.yaw);
	actor->origin.z = dest->origin.z;
	P_SetThingPosition(actor);
}

//==========================================================================
//
//  A_FireCrackle
//
//  Fire sound.
//
//==========================================================================

void A_FireCrackle(mobj_t * actor)
{
	StartSoundName(actor, "Flame", CHAN_VOICE);
	A_Fire(actor);
}

#else

void A_VileChase(mobj_t * actor)
{
	NotDoom2();
}

void A_VileStart(mobj_t * actor)
{
	NotDoom2();
}

void A_VileTarget(mobj_t * actor)
{
	NotDoom2();
}

void A_VileAttack(mobj_t * actor)
{
	NotDoom2();
}

void A_StartFire(mobj_t * actor)
{
	NotDoom2();
}

void A_Fire(mobj_t * actor)
{
	NotDoom2();
}

void A_FireCrackle(mobj_t * actor)
{
	NotDoom2();
}

#endif

//**************************************************************************
//
//  $Log$
//  Revision 1.4  2001/09/24 17:24:09  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
