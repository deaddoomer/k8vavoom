//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

#ifdef DOOM2

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  PIT_VileCheck
//
//  Detect a corpse that could be raised.
//
//==========================================================================

mobj_t *corpsehit;
Entity vileobj;
float viletryx;
float viletryy;

boolean PIT_VileCheck(mobj_t * thing)
{
	float maxdist;
	boolean check;

	if (!(thing->flags & MF_CORPSE))
		return true;	// not a monster

	if (thing->time != -1.0)
		return true;	// not lying still yet

	if (thing->raisestate == S_NULL)
		return true;	// monster doesn't have a raise state

	maxdist = thing->radius + vileobj.radius;

	if (fabs(thing->origin.x - viletryx) > maxdist ||
		fabs(thing->origin.y - viletryy) > maxdist)
		return true;	// not actually touching

	if (!P_CheckSight(&vileobj, thing))
		return true;	//  Con't see, possibly in other region

	corpsehit = thing;
	corpsehit->velocity.x = corpsehit->velocity.y = 0.0;
	corpsehit->height *= 4.0;
	check =
		P_CheckPosition(corpsehit, corpsehit->origin.x, corpsehit->origin.y);
	corpsehit->height /= 4.0;

	if (!check)
		return true;	// doesn't fit here

	return false;	// got one, so stop checking
}

//==========================================================================
//
//  Actor::A_VileChase
//
//  Arch-vile check for ressurecting a body.
//
//==========================================================================

void Actor::A_VileChase(void)
{
	int xl;
	int xh;
	int yl;
	int yh;

	int bx;
	int by;

	mobj_t *temp;

	if (movedir != DI_NODIR)
	{
		// check for corpses to raise
		viletryx = origin.x + speed * frametime * xspeed[movedir];
		viletryy = origin.y + speed * frametime * yspeed[movedir];
		vileobj = self;

		xl = MapBlock(viletryx - level->bmaporgx - MAXRADIUS * 2.0);
		xh = MapBlock(viletryx - level->bmaporgx + MAXRADIUS * 2.0);
		yl = MapBlock(viletryy - level->bmaporgy - MAXRADIUS * 2.0);
		yh = MapBlock(viletryy - level->bmaporgy + MAXRADIUS * 2.0);

		for (bx = xl; bx <= xh; bx++)
		{
			for (by = yl; by <= yh; by++)
			{
				// Call PIT_VileCheck to check whether object is a corpse
				// that canbe raised.
				if (!P_BlockThingsIterator(bx, by, PIT_VileCheck))
				{
					// got one!
					temp = target;
					target = corpsehit;
					A_FaceTarget();
					target = temp;

					SetMobjState(this, S_VILE_HEAL1);
					StartSoundName(corpsehit, "Slop", CHAN_BODY);

					SetMobjState(corpsehit, corpsehit->raisestate);
					corpsehit->height *= 4.0;
#ifdef FIXME
					corpsehit->flags = info->flags;
#else
					corpsehit->flags |= MF_SOLID;
					corpsehit->flags &= ~(MF_CORPSE);
#endif
					corpsehit->health = corpsehit->spawnhealth;
					corpsehit->target = NULL;

					return;
				}
			}
		}
	}
	// Return to normal attack.
	A_Chase();
}

//==========================================================================
//
//  Actor::A_VileStart
//
//  Arch-vile attack start sound.
//
//==========================================================================

void Actor::A_VileStart(void)
{
	StartSoundName(this, "ArchVileAttack", CHAN_WEAPON);
}

//==========================================================================
//
//  Actor::A_VileTarget
//
//  Spawn the hellfire.
//
//==========================================================================

void Actor::A_VileTarget(void)
{
	mobj_t *fog;

	if (!target)
		return;

	A_FaceTarget();

	fog = P_SpawnMobj(target->origin.x, target->origin.x,
		target->origin.z, MT_FIRE);

	tracer = fog;
	fog->target = this;
	fog->tracer = target;
	((Actor *)fog)->A_Fire();
}

//==========================================================================
//
//  Actor::A_VileAttack
//
//  Arch-vile attack.
//
//==========================================================================

void Actor::A_VileAttack(void)
{
	mobj_t *fire;

	if (!target)
		return;

	A_FaceTarget();

	if (!P_CheckSight(this, target))
		return;

	StartSoundName(this, "BarrelExplode", CHAN_WEAPON);
	target->Damage(this, this, 20);
	target->velocity.z = 1000.0 / target->mass * 35.0;

	fire = tracer;

	if (!fire)
		return;

	// move the fire between the vile and the player
	fire->origin.x = target->origin.x - 24.0 * cos(angles.yaw);
	fire->origin.y = target->origin.y - 24.0 * sin(angles.yaw);
	P_RadiusAttack(fire, this, 70, 0, 0);
}

//==========================================================================
//
//  Actor::A_StartFire
//
//  Make fire start sound.
//
//==========================================================================

void Actor::A_StartFire(void)
{
	StartSoundName(this, "FlameStart", CHAN_VOICE);
	A_Fire();
}

//==========================================================================
//
//  Actor::A_Fire
//
//  Keep fire in front of player unless out of sight.
//
//==========================================================================

void Actor::A_Fire(void)
{
	mobj_t *dest;

	dest = tracer;
	if (!dest)
		return;

	// don't move it if the vile lost sight
	if (!P_CheckSight(target, dest))
		return;

	P_UnsetThingPosition(this);
	origin.x = dest->origin.x + 24.0 * cos(dest->angles.yaw);
	origin.y = dest->origin.y + 24.0 * sin(dest->angles.yaw);
	origin.z = dest->origin.z;
	P_SetThingPosition(this);
}

//==========================================================================
//
//  Actor::A_FireCrackle
//
//  Fire sound.
//
//==========================================================================

void Actor::A_FireCrackle(void)
{
	StartSoundName(this, "Flame", CHAN_VOICE);
	A_Fire();
}

#else

void Actor::A_VileChase(void)
{
	NotDoom2();
}

void Actor::A_VileStart(void)
{
	NotDoom2();
}

void Actor::A_VileTarget(void)
{
	NotDoom2();
}

void Actor::A_VileAttack(void)
{
	NotDoom2();
}

void Actor::A_StartFire(void)
{
	NotDoom2();
}

void Actor::A_Fire(void)
{
	NotDoom2();
}

void Actor::A_FireCrackle(void)
{
	NotDoom2();
}

#endif

//**************************************************************************
//
//  $Log$
//  Revision 1.6  2001/12/12 18:57:40  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.5  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.4  2001/09/24 17:24:09  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
