//**************************************************************************
//**
//**	##   ##    ##    ##   ##   ####     ####   ###     ###
//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**	   #    ##    ##    #      ####     ####   ##       ##
//**
//**	$Id$
//**
//**	Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**	This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**	This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**	$Log$
//**	Revision 1.2  2001/07/27 14:27:51  dj_jl
//**	Update with Id-s and Log-s, some fixes
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define GRAVITY			1225.0
#define MAXMOVE			1050.0
#define STOPSPEED		2.1875
#define FRICTION		3.28125
#define FRICTION_WATER	3.0

#define BOUNCE_VAL		1.5

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//	ClipVelocity
//
//	Slide off of the impacting object
//
//==========================================================================

TVec ClipVelocity(TVec in, TVec normal, float overbounce)
{
	return in - normal * (DotProduct(in, normal) * overbounce);
}

//**************************************************************************
//
//	SLIDE MOVE
//
//	Allows the player to slide along any angled walls.
//
//**************************************************************************

float			bestslidefrac;
line_t*			bestslideline;

mobj_t*			slidemo;
TVec			slideorg;
TVec			slidedir;

//==========================================================================
//
//	PTR_SlideTraverse
//
//==========================================================================

boolean PTR_SlideTraverse(intercept_t* in)
{
	line_t*		li;
	TVec		hit_point;
	
    if (!in->isaline)
		Error("PTR_SlideTraverse: not a line?");
		
    li = in->line;

    if (li->flags & ML_TWOSIDED)
    {
		opening_t	*open;

	    // set openrange, opentop, openbottom
		hit_point = slideorg + in->frac * slidedir;
    	open = LineOpenings(li, hit_point);
		open = FindOpening(open, slidemo->origin.z,	slidemo->origin.z + slidemo->height);
    
	    if (open &&
	    	(open->range >= slidemo->height) &&	//	fits
    		(open->top - slidemo->origin.z >= slidemo->height) && // mobj is not too high
	    	(open->bottom - slidemo->origin.z <= 24.0)) // not too big a step up
		{
    		// this line doesn't block movement
    		return true;
		}
	}
	else
    {
		if (PointOnPlaneSide(slidemo->origin, li))
		{
	    	// don't hit the back side
	    	return true;
		}
    }

    // the line does block movement,
    // see if it is closer than best so far
    if (in->frac < bestslidefrac)
    {
		bestslidefrac = in->frac;
		bestslideline = li;
    }
	
    return false;	// stop
}

//==========================================================================
//
//	SlidePathTraverse
//
//==========================================================================

void SlidePathTraverse(float x, float y)
{
	slideorg = vector(x, y, slidemo->origin.z);
	slidedir = slidemo->velocity * frametime;
	P_PathTraverse(x, y, x + slidedir.x, y + slidedir.y,
		PT_ADDLINES, PTR_SlideTraverse);
}

//==========================================================================
//
//	P_SlideMove
//
//	The momx / momy move is bad, so try to slide along a wall.
//	Find the first line hit, move flush to it, and slide along it.
//	This is a kludgy mess.
//
//==========================================================================

void P_SlideMove(mobj_t* mo)
{
	float		leadx;
	float		leady;
	float		trailx;
	float		traily;
	float		newx;
	float		newy;
    int			hitcount;
		
    slidemo = mo;
    hitcount = 0;

	do
    {
	    if (++hitcount == 3)
		{
			// don't loop forever
			if (!P_TryMove(mo, mo->origin.x, mo->origin.y + mo->velocity.y * frametime))
			    P_TryMove(mo, mo->origin.x + mo->velocity.x * frametime, mo->origin.y);
			return;
		}

	    // trace along the three leading corners
	    if (mo->velocity.x > 0.0)
    	{
			leadx = mo->origin.x + mo->radius;
			trailx = mo->origin.x - mo->radius;
    	}
	    else
    	{
			leadx = mo->origin.x - mo->radius;
			trailx = mo->origin.x + mo->radius;
	    }

	    if (mo->velocity.y > 0.0)
	    {
			leady = mo->origin.y + mo->radius;
			traily = mo->origin.y - mo->radius;
	    }
    	else
	    {
			leady = mo->origin.y - mo->radius;
			traily = mo->origin.y + mo->radius;
	    }
		
	    bestslidefrac = 1.00001;

	    SlidePathTraverse(leadx, leady);
	    SlidePathTraverse(trailx, leady);
	    SlidePathTraverse(leadx, traily);
    
	    // move up to the wall
    	if (bestslidefrac == 1.00001)
	    {
			// the move most have hit the middle, so stairstep
			if (!P_TryMove(mo, mo->origin.x, mo->origin.y + mo->velocity.y * frametime))
			    P_TryMove(mo, mo->origin.x + mo->velocity.x * frametime, mo->origin.y);
			return;
    	}

	    // fudge a bit to make sure it doesn't hit
    	bestslidefrac -= 0.03125;
	    if (bestslidefrac > 0.0)
    	{
			newx = mo->velocity.x * frametime * bestslidefrac;
			newy = mo->velocity.y * frametime * bestslidefrac;
	
			if (!P_TryMove(mo, mo->origin.x + newx, mo->origin.y + newy))
            {
				if (!P_TryMove(mo, mo->origin.x, mo->origin.y + mo->velocity.y * frametime))
				    P_TryMove(mo, mo->origin.x + mo->velocity.x * frametime, mo->origin.y);
				return;
			}
	    }
    
	    // Now continue along the wall.
    	// First calculate remainder.
	    bestslidefrac = 1.0 - (bestslidefrac + 0.03125);
    
	    if (bestslidefrac > 1.0)
			bestslidefrac = 1.0;
    
	    if (bestslidefrac <= 0.0)
			return;
    
	    // clip the moves
		mo->velocity = ClipVelocity(mo->velocity * bestslidefrac, bestslideline->normal, 1.0);

    } while (!P_TryMove(mo, mo->origin.x + mo->velocity.x * frametime,
    	mo->origin.y + mo->velocity.y * frametime));
}

//**************************************************************************
//
//	BOUNCING
//
//	Bounce missile against walls
//
//**************************************************************************

//============================================================================
//
//	PTR_BounceTraverse
//
//============================================================================

boolean PTR_BounceTraverse(intercept_t *in)
{
	line_t  	*li;
	TVec		hit_point;
	opening_t	*open;

	if (!in->isaline)
		Error("PTR_BounceTraverse: not a line?");

	li = in->line;
	if (li->flags & ML_TWOSIDED)
    {
		hit_point = slideorg + in->frac * slidedir;
		open = LineOpenings(li, hit_point);	// set openrange, opentop, openbottom
		open = FindOpening(open, slidemo->origin.z,	slidemo->origin.z +	slidemo->height);
		if (open &&
			open->range >= slidemo->height &&			// fits
			open->top - slidemo->origin.z >= slidemo->height)// mobj is not too high
		{
			return true;            // this line doesn't block movement
		}
	}
	else
	{
		if (PointOnPlaneSide(slidemo->origin, li))
        {
			return true;            // don't hit the back side
		}
	}

	bestslideline = li;
	return false;   // stop
}

//============================================================================
//
//	P_BounceWall
//
//============================================================================

void P_BounceWall(mobj_t *mo, float overbounce)
{
	slidemo = mo;
	if (mo->velocity.x > 0.0)
	{
		slideorg.x = mo->origin.x + mo->radius;
	}
	else
	{
		slideorg.x = mo->origin.x - mo->radius;
	}
	if (mo->velocity.y > 0.0)
	{
		slideorg.y = mo->origin.y + mo->radius;
	}
	else
	{
		slideorg.y = mo->origin.y - mo->radius;
	}
	slideorg.z = slidemo->origin.z;
	slidedir = mo->velocity * frametime;
	P_PathTraverse(slideorg.x, slideorg.y,
		slideorg.x + slidedir.x, slideorg.y + slidedir.y,
		PT_ADDLINES, PTR_BounceTraverse);
	mo->velocity = ClipVelocity(mo->velocity, bestslideline->normal, overbounce);
}

//**************************************************************************
//
//	OBJECT MOVEMENT
//
//**************************************************************************

//==========================================================================
//
//	CheckWater
//
//==========================================================================

boolean CheckWater(mobj_t *mobj)
{
	TVec	point;
	int		cont;

	point = mobj->origin;
	point.z += 1.0;
	
	mobj->waterlevel = 0;
	mobj->watertype = CONTENTS_EMPTY;
	cont = PointContents(mobj->subsector->sector, point);
	if (cont >= CONTENTS_WATER)
	{
		mobj->watertype = cont;
		mobj->waterlevel = 1;
		point.z = mobj->origin.z + mobj->height * 0.5;
		cont = PointContents(mobj->subsector->sector, point);
		if (cont >= CONTENTS_WATER)
		{
			mobj->waterlevel = 2;
			if (mobj->player)
			{
				point = mobj->player->vieworg;
				cont = PointContents(mobj->subsector->sector, point);
				if (cont >= CONTENTS_WATER)
					mobj->waterlevel = 3;
			}
		}
	}
	return mobj->waterlevel > 1;
}

//==========================================================================
//
//	P_XYMovement
//
//==========================================================================

void P_XYMovement(mobj_t* mo)
{ 	
    float		ptryx;
    float		ptryy;
    float		xmove;
    float		ymove;
			
    if (!mo->velocity.x && !mo->velocity.y)
    {
		if (mo->flags & MF_SKULLFLY)
		{
	    	// the skull slammed into something
		    mo->flags &= ~MF_SKULLFLY;
		    mo->velocity.x = mo->velocity.y = mo->velocity.z = 0.0;

		    SetMobjState(mo, mo->spawnstate);
		}
		return;
    }
	
    if (mo->velocity.x > MAXMOVE)
		mo->velocity.x = MAXMOVE;
    else if (mo->velocity.x < -MAXMOVE)
		mo->velocity.x = -MAXMOVE;

    if (mo->velocity.y > MAXMOVE)
		mo->velocity.y = MAXMOVE;
    else if (mo->velocity.y < -MAXMOVE)
		mo->velocity.y = -MAXMOVE;
		
    xmove = mo->velocity.x * frametime;
    ymove = mo->velocity.y * frametime;

    do
    {
		if (xmove > MAXMOVE / (35.0 * 2.0) || ymove > MAXMOVE / (35.0 * 2.0))
		{
		    ptryx = mo->origin.x + xmove / 2.0;
		    ptryy = mo->origin.y + ymove / 2.0;
		    xmove /= 2.0;
		    ymove /= 2.0;
		}
		else
		{
		    ptryx = mo->origin.x + xmove;
	    	ptryy = mo->origin.y + ymove;
		    xmove = ymove = 0.0;
		}
		
		if (!P_TryMove(mo, ptryx, ptryy))
		{
	    	// blocked move
		    if (mo->player)
		    {
		    	// try to slide along it
				P_SlideMove(mo);
		    }
		    else if (mo->flags & MF_MISSILE)
		    {
				if (mo->flags & MF_BOUNCE)
				{
					//	Bounce against walls and non-killable ofjects
					if (BlockingMobj)
					{
						if ((!BlockingMobj->player) &&
							(!(BlockingMobj->flags & MF_COUNTKILL)))
						{
							float	speed;
							angle_t	angle;
	
							angle = atan2(mo->origin.y - BlockingMobj->origin.y,
								mo->origin.x - BlockingMobj->origin.x)
								+ ANG90 / 90 * ((P_Random() % 16) - 8);
							speed = Length(mo->velocity);
							speed = speed * 0.75;
							mo->angles.yaw = angle;
							mo->velocity.x = speed * cos(angle);
							mo->velocity.y = speed * sin(angle);
							if (mo->sound_pain)
							{
								StartSound(mo, mo->sound_pain);
							}
						}
						else
						{
							// Struck a player/creature
 							P_ExplodeMissile(mo);
						}
					}
					else
					{
						// Struck a wall
						P_BounceWall(mo, BOUNCE_VAL);
						if (mo->sound_pain)
						{
							StartSound(mo, mo->sound_pain);
						}
					}	
					return;
				}

				// explode a missile
				if (ceilingline &&
			    	ceilingline->backsector &&
				    ceilingline->backsector->ceiling.pic == skyflatnum)
				{
				    // Hack to prevent missiles exploding
			    	// against the sky.
				    // Does not handle sky floors.
				    P_RemoveMobj(mo);
				    return;
				}
				P_ExplodeMissile(mo);
		    }
		    else
			{
				mo->velocity.x = mo->velocity.y = 0.0;
			}
		}
    } while (xmove || ymove);
}

//==========================================================================
//
// P_ZMovement
//
//==========================================================================

void P_ZMovement(mobj_t* mo)
{
	float	dist;
    float	delta;

    // check for smooth step up
    if (mo->player && mo->origin.z < mo->floorz)
    {
		mo->player->viewheight -= mo->floorz - mo->origin.z;

		mo->player->deltaviewheight
		    = (VIEWHEIGHT - mo->player->viewheight) / 8.0;
    }
    
    // adjust height
    mo->origin.z += mo->velocity.z * frametime;
	
    if (mo->flags & MF_FLOAT && mo->target)
    {
		// float down towards target if too close
		if (!(mo->flags & MF_SKULLFLY) && !(mo->flags & MF_INFLOAT))
		{
		    dist = MobjDist2(mo, mo->target);
	    
		    delta = mo->target->origin.z + mo->height / 2.0 - mo->origin.z;

		    if (delta < 0.0 && dist < -(delta * 3.0))
				mo->origin.z -= FLOATSPEED * frametime;
		    else if (delta > 0.0 && dist < (delta * 3.0))
				mo->origin.z += FLOATSPEED * frametime;
		}
    }
    
    // clip movement
    if (mo->origin.z <= mo->floorz)
    {
		// hit the floor

		// Note (id):
		//  somebody left this after the setting momz to 0,
		//  kinda useless there.
		if (mo->flags & MF_SKULLFLY)
		{
		    // the skull slammed into something
		    mo->velocity.z = -mo->velocity.z;
		}
	
		if (mo->velocity.z < 0.0)
		{
		    if (mo->player && (mo->velocity.z < -GRAVITY * 0.25))
		    {
				// Squat down.
				// Decrease viewheight for a moment
				// after hitting the ground (hard),
				// and utter appropriate sound.
				mo->player->deltaviewheight = mo->velocity.z / 8.0 * frametime;
				StartSoundName(mo, "PlayerLand");
		    }
		}
		mo->origin.z = mo->floorz;

		if (mo->flags & MF_MISSILE)
		{
			if (!(mo->flags & (MF_NOCLIP|MF_BOUNCE)))
			{
			    P_ExplodeMissile(mo);
		    	return;
			}
			if (mo->flags & MF_BOUNCE && mo->sound_pain && Length(mo->velocity) > 256.0)
			{
				StartSound(mo, mo->sound_pain);
			}
		}
    }

    if (mo->origin.z + mo->height > mo->ceilingz)
    {
		// hit the ceiling
		if (mo->velocity.z > 0.0)
	    	mo->velocity.z = 0.0;

	    mo->origin.z = mo->ceilingz - mo->height;

		if (mo->flags & MF_SKULLFLY)
		{
			// the skull slammed into something
		    mo->velocity.z = -mo->velocity.z;
		}

		if (mo->flags & MF_MISSILE)
		{
			if (!(mo->flags & (MF_NOCLIP|MF_BOUNCE)))
			{
			    P_ExplodeMissile(mo);
	    		return;
			}
			if (mo->flags & MF_BOUNCE && mo->sound_pain && Length(mo->velocity) > 256.0)
			{
				StartSound(mo, mo->sound_pain);
			}
		}
    }
}

//==========================================================================
//
//	UpdateVelocity
//
//==========================================================================

void UpdateVelocity(mobj_t *mo)
{
	float		dot;
    player_t*	player;

    player = mo->player;

	if (mo->waterlevel < 2)
	{
	    if (!(mo->flags & MF_NOGRAVITY) &&
    		(mo->origin.z > mo->floorz || mo->subsector->sector->floor.normal.z < 0.7))
	    {
			//	Add gravity
	    	mo->velocity.z -= GRAVITY * frametime;
	    }
	}
	else if (!mo->player)
	{
	    if (!(mo->flags & MF_NOGRAVITY) &&
    		(mo->origin.z > mo->floorz || mo->subsector->sector->floor.normal.z < 0.7))
	    {
			//	Add gravity
	    	mo->velocity.z = -60.0;
	    }
	}
	
    // slow down

    if (mo->flags & (MF_MISSILE | MF_SKULLFLY) && !(mo->flags & MF_BOUNCE))
		return; 	// no friction for missiles ever
		
    if (mo->origin.z > mo->floorz && !(mo->flags2 & MF2_ONMOBJ) &&
    	mo->waterlevel < 2)
		return;		// no friction when airborne

	//	Clip velocity
    if (mo->origin.z <= mo->floorz)
	{
		dot = DotProduct(mo->velocity, mo->floor->normal);
		if (dot < 0.0)
		{
			if (mo->flags & MF_BOUNCE)
			{
				dot *= BOUNCE_VAL;
			}
			mo->velocity -= dot * mo->floor->normal;
		}
	}

    if (mo->flags & MF_CORPSE)
    {
		// do not stop sliding if halfway off a step with some momentum
		if (mo->velocity.x > 0.25 * 35.0 || mo->velocity.x < -0.25 * 35.0 ||
			mo->velocity.y > 0.25 * 35.0 || mo->velocity.y < -0.25 * 35.0)
		{
		    if (mo->floorz != mo->subsector->sector->floorheight)
				return;
		}
    }

    if (mo->velocity.x > -STOPSPEED && mo->velocity.x < STOPSPEED &&
		mo->velocity.y > -STOPSPEED && mo->velocity.y < STOPSPEED &&
		mo->velocity.z > -STOPSPEED && mo->velocity.z < STOPSPEED &&
    	(!player || (!player->forwardmove && !player->sidemove)))
    {
		if (player)
		{
        	int		sn;

			// if in a walking frame, stop moving
            sn = player->mo->statenum;
			if (sn >= S_PLAY_RUN1 && sn <= S_PLAY_RUN4)
		    	SetMobjState(player->mo, S_PLAY);
		}
		mo->velocity = vector(0.0, 0.0, 0.0);
    }
    else
    {
		if (mo->waterlevel > 1)
		{
			mo->velocity -= mo->velocity * (FRICTION_WATER * frametime);
		}
		else
		{
			mo->velocity -= mo->velocity * (FRICTION * frametime);
		}
    }
}

//==========================================================================
//
//	TEST ON MOBJ
//
//==========================================================================

mobj_t*		tzmthing;
float		tzmx;
float		tzmy;
float		tzmz;

mobj_t 		*onmobj; //generic global onmobj...used for landing on pods/players

//==========================================================================
//
//	PIT_CheckOnmobjZ
//
//==========================================================================

boolean PIT_CheckOnmobjZ(mobj_t *thing)
{
	float	blockdist;

	if (!(thing->flags & (MF_SOLID | MF_SPECIAL | MF_SHOOTABLE)))
	{
		// Can't hit thing
		return true;
	}
	blockdist = thing->radius + tzmthing->radius;
	if (fabs(thing->origin.x - tzmx) >= blockdist || fabs(thing->origin.y - tzmy) >= blockdist)
	{
		// Didn't hit thing
		return true;
	}
	if (thing == tzmthing)
	{
		// Don't clip against self
		return true;
	}
	if (tzmz > thing->origin.z + thing->height)
	{	
		return true;
	}
	else if (tzmz + tzmthing->height < thing->origin.z)
	{
		// under thing
		return true;
	}
	if (thing->flags & MF_SOLID)
	{
		onmobj = thing;
	}
	return (!(thing->flags & MF_SOLID));
}

//=============================================================================
//
//	P_FakeZMovement
//
//	Fake the zmovement so that we can check if a move is legal
//
//=============================================================================

void P_FakeZMovement(mobj_t *mo)
{
	float		dist;
	float		delta;

	//
	//	adjust height
	//
	tzmz += mo->velocity.z * frametime;
	if (mo->flags & MF_FLOAT && mo->target)
	{
		// float down towards target if too close
		if (!(mo->flags & MF_SKULLFLY) && !(mo->flags & MF_INFLOAT))
		{
			dist = MobjDist2(mo, mo->target);
			delta = mo->target->origin.z + mo->height / 2.0 - tzmz;
			if (delta < 0.0 && dist < -(delta * 3.0))
				tzmz -= FLOATSPEED * frametime;
			else if (delta > 0.0 && dist < (delta * 3.0))
				tzmz += FLOATSPEED * frametime;
		}
	}

	//
	//	clip movement
	//
	if (tzmz <= mo->floorz)
	{
		// Hit the floor
		tzmz = mo->floorz;
	}
	if (tzmz + mo->height > mo->ceilingz)
	{
		// hit the ceiling
		tzmz = mo->ceilingz - mo->height;
	}
}

//=============================================================================
//
//	P_CheckOnmobj
//
//	Checks if the new Z position is legal
//
//=============================================================================

mobj_t *P_CheckOnmobj(mobj_t *thing)
{
	int			xl,xh,yl,yh,bx,by;
	
	tzmthing = thing;
	tzmx = thing->origin.x;
	tzmy = thing->origin.y;
	tzmz = thing->origin.z;
	P_FakeZMovement(tzmthing);
		
	if (thing->flags & MF_NOCLIP)
		return NULL;

	//
	// check things first, possibly picking things up
	// the bounding box is extended by MAXRADIUS because mobj_ts are grouped
	// into mapblocks based on their origin point, and can overlap into adjacent
	// blocks by up to MAXRADIUS units
	//
	xl = MapBlock(thing->origin.x - thing->radius - level->bmaporgx - MAXRADIUS);
	xh = MapBlock(thing->origin.x + thing->radius - level->bmaporgx + MAXRADIUS);
	yl = MapBlock(thing->origin.y - thing->radius - level->bmaporgy - MAXRADIUS);
	yh = MapBlock(thing->origin.y + thing->radius - level->bmaporgy + MAXRADIUS);

	for (bx=xl ; bx<=xh ; bx++)
		for (by=yl ; by<=yh ; by++)
			if (!P_BlockThingsIterator(bx,by,PIT_CheckOnmobjZ))
			{
				return onmobj;
			}
	return NULL;
}

//===========================================================================
//
//	PlayerLandedOnThing
//
//===========================================================================

void PlayerLandedOnThing(mobj_t *mo, mobj_t *onmobj)
{
	mo->player->deltaviewheight = mo->velocity.z * frametime / 8.0;
	if (mo->velocity.z < -GRAVITY * 0.375)
	{
		StartSoundName(mo, "PlayerLand");
	}
}

//==========================================================================
//
//	P_MobjThinker
//
//==========================================================================

void P_MobjThinker(mobj_t* mobj)
{
	mobj_t		*onmo;

 	//  In my deathmatch mode remove dropped weapons after 30 seconds
    // because otherwise they are spawned fastar than player(s) can pick 
    // them up and the game is going slower and slower and slower ...
	if ((mobj->flags & MF_DROPPED) && (deathmatch == 3))
	{
       	mobj->movecount++;
        if (mobj->movecount >= 30 * 35)
		{
           	P_RemoveMobj(mobj);
            return;
		}
	}

	CheckWater(mobj);
	UpdateVelocity(mobj);

    // momentum movement
    if (mobj->velocity.x || mobj->velocity.y || (mobj->flags & MF_SKULLFLY))
    {
		P_XYMovement(mobj);

		if (!mobj->real_function)
        {
	    	return;		// mobj was removed
		}
    }
    if ((mobj->origin.z != mobj->floorz) || mobj->velocity.z || BlockingMobj)
    {
		// Handle Z momentum and gravity
		if (!(onmo = P_CheckOnmobj(mobj)))
		{
			P_ZMovement(mobj);
			if (mobj->player && mobj->flags & MF2_ONMOBJ)
			{
				mobj->flags2 &= ~MF2_ONMOBJ;
			}
		}
		else
		{
			if (mobj->player)
			{
				if (mobj->velocity.z < -GRAVITY * 0.25)
				{
					PlayerLandedOnThing(mobj, onmo);
				}
				if (onmo->origin.z + onmo->height - mobj->origin.z <= 24.0)
				{
					mobj->player->viewheight -= onmo->origin.z + onmo->height
							- mobj->origin.z;
					mobj->player->deltaviewheight =
						(VIEWHEIGHT - mobj->player->viewheight) / 8.0;
					mobj->origin.z = onmo->origin.z + onmo->height;
					mobj->flags2 |= MF2_ONMOBJ;
					mobj->velocity.z = 0.0;
				}
				else
				{
					// hit the bottom of the blocking mobj
					mobj->velocity.z = 0.0;
				}
			}
		}
		if (!mobj->real_function)
        {
	    	return;		// mobj was removed
		}
    }

    // cycle through states,
    // calling action functions at transitions
    if (mobj->time != -1.0)
    {
		mobj->time -= frametime;
		
		// you can cycle through multiple states in a tic
		if (mobj->time <= 0.0)
		{
			mobj->time = 0.0;
	    	if (!SetMobjState(mobj, mobj->nextstate))
				return;		// freed itself
		}
    }
    else
    {
		// check for nightmare respawn
		if (!(mobj->flags & MF_COUNTKILL))
	    	return;

        //  In my deathmatch mode monstars respawns very fast
        if (deathmatch == 3)
		{
			if (level->tictime & 31)
	    		return;

			if (P_Random() > 32)
	    		return;

			P_NightmareRespawn(mobj);
		}
        else
		{
			if (!respawnmonsters)
	    		return;

        	mobj->movecount++;

			if (mobj->movecount < 12 * 35)
	    		return;

			if (level->tictime & 31)
	    		return;

			if (P_Random() > 4)
	    		return;

			P_NightmareRespawn(mobj);
		}
    }
}

