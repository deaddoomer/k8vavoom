//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

int opposite[] = {
	DI_WEST, DI_SOUTHWEST, DI_SOUTH, DI_SOUTHEAST,
	DI_EAST, DI_NORTHEAST, DI_NORTH, DI_NORTHWEST, DI_NODIR
};
int diags[] = {
	DI_NORTHWEST, DI_NORTHEAST, DI_SOUTHWEST, DI_SOUTHEAST
};

float xspeed[8] =
	{ 1.0, 0.7171630859, 0.0, -0.7171630859, -1.0, -0.7171630859, 0.0,
		0.7171630859 };
float yspeed[8] =
	{ 0.0, 0.7171630859, 1.0, 0.7171630859, 0.0, -0.7171630859, -1.0,
		-0.7171630859 };

//==========================================================================
//
//  Actor::CheckMeleeRange
//
//==========================================================================

boolean Actor::CheckMeleeRange(void)
{
	float dist;

	if (!target)
	{
		return false;
	}

	dist = MobjDist(*target, self);

	if (dist >= MELEERANGE - 20.0 + target->Radius)
	{
		return false;
	}

	if (!P_CheckSight(self, *target))
	{
		return false;
	}

	return true;
}

//==========================================================================
//
//  Actor::CheckMissileRange
//
//==========================================================================

boolean Actor::CheckMissileRange(void)
{
	float dist;

	if (!P_CheckSight(self, *target))
	{
		return false;
	}

	if (bJustHit)
	{
		// the target just hit the enemy,
		// so fight back!
		bJustHit = false;
		return true;
	}

	if (ReactionCount)
	{
		return false;	// do not attack yet
	}

	// OPTIMIZE: get this from a global checksight
	dist = MobjDist(self, *target) - 64.0;

	if (!MeleeState)
		dist -= 128.0;	// no melee attack, so fire more

	if (Class == ArchVile)
	{
		if (dist > 14.0 * 64.0)
			return false;	// too far away
	}

	if (Class == Revenant)
	{
		if (dist < 196.0)
			return false;	// close for fist attack
		dist /= 2.0;
	}

	if (Class == Cyberdemon || Class == SpiderMastermind || Class == LostSoul)
	{
		dist /= 2.0;
	}

	if (dist > 200.0)
		dist = 200.0;

	if (Class == Cyberdemon && dist > 160.0)
		dist = 160.0;

	if (Random() * 256.0 < dist)
		return false;

	return true;
}

//==========================================================================
//
//  Actor::FindOther
//
//==========================================================================

boolean Actor::FindOther(void)
{
	Actor Other;

	FOREACH(Actor, Other)
	{
		if (Other != self && Other.Class == Class && Other.Health > 0)
		{
			// other mobj of the same Class not dead
			return true;
		}
	}
	return false;
}

//==========================================================================
//
//  Actor::LookForMonsters
//
//==========================================================================

boolean Actor::LookForMonsters(boolean allaround)
{
	Actor mo;
	float an;
	float dist;

	FOREACH(Actor, mo)
	{
		if (mo.Health <= 0)
			continue;	// dead

		if (mo == self)
			continue;

		if (mo.Class != LostSoul && mo.Class != PlayerEntity &&
			!mo.bCountKill)
			continue;

		if (!P_CheckSight(self, mo))
			continue;	// out of sight

		if (P_Random() > 128)
			continue;

		if (!allaround)
		{
			an = AngleMod360(atan2(mo.origin.y - origin.y,
				mo.origin.x - origin.x) - angles.yaw);

			if (an > 90.0 && an < 270.0)
			{
				dist = MobjDist(mo, self);
				// if real close, react anyway
				if (dist > MELEERANGE)
					continue;	// behind back
			}
		}

		target = &mo;
		return true;
	}
	return false;
}

//==========================================================================
//
//  Actor::LookForMonsters2
//
//==========================================================================

boolean Actor::LookForMonsters2(boolean allaround)
{
	Actor mo;
	float an;
	float dist;

	if (!P_CheckSight(self, *players[0].mo))
	{
		return false;	//  Not seen by player
	}

	FOREACH(Actor, mo)
	{
		if (mo.Health <= 0)
			continue;	// dead

		if (mo == self)
			continue;	// self

		if ((mo.Class != LostSoul) && !mo.bCountKill)
			continue;	// not a monster

		if (!P_CheckSight(self, mo))
			continue;	// out of sight

		if (P_Random() > 128)
			continue;	// sometimes skip

		if (!allaround)
		{
			an = AngleMod360(atan2(mo.origin.y - origin.y,
				mo.origin.x - origin.x) - angles.yaw);

			if (an > 90.0 && an < 270.0)
			{
				dist = MobjDist(mo, self);
				// if real close, react anyway
				if (dist > MELEERANGE)
					continue;	// behind back
			}
		}

		target = &mo;
		return true;
	}
	return false;
}

//==========================================================================
//
//  Actor::LookForPlayers
//
//  If allaround is false, only look 180 degrees in front.
//  Returns true if a player is targeted.
//
//==========================================================================

boolean Actor::LookForPlayers(boolean allaround)
{
	int c;
	int stop;
	player_t *P;
	float an;
	float dist;

	if (deathmatch == 3)
	{
		return LookForMonsters(allaround);
	}

	if (!netgame && players[0].spawned && players[0].health <= 0)
	{
		return LookForMonsters2(allaround);
	}

	c = 0;
	stop = (lastlook - 1) & 3;

	for (;; lastlook = (lastlook + 1) & (MAXPLAYERS - 1))
	{
		if (lastlook == stop)
		{
			// done looking
			return false;
		}

		P = &players[lastlook];

		if (!P->active)
			continue;

		if (c++ == 2)
		{
			// done looking
			return false;
		}

		if (!P->spawned || !P->mo)
			continue;	//  not spawned yet

		if (P->health <= 0)
			continue;	// dead

		if (!P_CheckSight(self, *P->mo))
			continue;	//  out of sight

		if (!allaround)
		{
			an = AngleMod360(atan2(P->mo->origin.y - origin.y,
				P->mo->origin.x - origin.x) - angles.yaw);

			if (an > 90.0 && an < 270.0)
			{
				dist = MobjDist(*P->mo, self);
				// if real close, react anyway
				if (dist > MELEERANGE)
					continue;	// behind back
			}
		}

		target = P->mo;
		return true;
	}

	return false;
}

//==========================================================================
//
//  Actor::StepMove
//
//  Move in the current direction, returns false if the move is blocked.
//
//==========================================================================

boolean Actor::StepMove(void)
{
	float tryx;
	float tryy;

	line_t *ld;
	boolean good;

	if (movedir == DI_NODIR)
		return false;

#ifdef RANGECHECK
	if (movedir >= 8 || movedir < 0)
		Error("Weird movedir!");
#endif

	tryx = origin.x + Speed * frametime * xspeed[movedir];
	tryy = origin.y + Speed * frametime * yspeed[movedir];

	if (!P_TryMove(this, tryx, tryy))
	{
		// open any specials
		if (bFloat && floatok)
		{
			// must adjust height
			if (origin.z < saved_tmfloorz)
				origin.z += FLOATSPEED * frametime;
			else
				origin.z -= FLOATSPEED * frametime;

			bInFloat = true;
			return true;
		}

		if (!numspechit)
			return false;

		movedir = DI_NODIR;
		good = false;
		while (numspechit--)
		{
			ld = spechit[numspechit];
			// if the special is not a door
			// that can be opened,
			// return false
			if (P_ActivateLine(ld, this, 0, SPAC_USE))
			{
				good = true;
			}
		}
		return good;
	}
	else
	{
		bInFloat = false;
	}

	if (!bFloat)
	{
		origin.z = floorz;
	}
	return true;
}

//==========================================================================
//
//  Actor::TryWalk
//
//  Attempts to move actor on in its current (ob->moveangle) direction.
// If blocked by either a wall or an actor returns FALSE
// If move is either clear or blocked only by a door, returns TRUE and sets...
// If a door is in the way, an OpenDoor call is made to start it opening.
//
//==========================================================================

boolean Actor::TryWalk(void)
{
	if (!StepMove())
	{
		return false;
	}

	movecount = P_Random() & 15;
	return true;
}

//==========================================================================
//
//  Actor::NewChaseDir
//
//==========================================================================

void Actor::NewChaseDir(void)
{
	float deltax;
	float deltay;

	int d[3];

	int tdir;
	int olddir;

	int turnaround;

	if (!target)
	{
		Error("P_NewChaseDir: called with no target");
	}

	olddir = movedir;
	turnaround = opposite[olddir];

	deltax = target->origin.x - origin.x;
	deltay = target->origin.y - origin.y;

	if (deltax > 10.0)
		d[1] = DI_EAST;
	else if (deltax < -10.0)
		d[1] = DI_WEST;
	else
		d[1] = DI_NODIR;

	if (deltay < -10.0)
		d[2] = DI_SOUTH;
	else if (deltay > 10.0)
		d[2] = DI_NORTH;
	else
		d[2] = DI_NODIR;

	// try direct route
	if (d[1] != DI_NODIR && d[2] != DI_NODIR)
	{
		movedir = diags[((deltay < 0.0) << 1) + (deltax > 0.0)];
		if (movedir != turnaround && TryWalk())
			return;
	}

	// try other directions
	if (P_Random() > 200 || fabs(deltay) > fabs(deltax))
	{
		tdir = d[1];
		d[1] = d[2];
		d[2] = tdir;
	}

	if (d[1] == turnaround)
		d[1] = DI_NODIR;
	if (d[2] == turnaround)
		d[2] = DI_NODIR;

	if (d[1] != DI_NODIR)
	{
		movedir = d[1];
		if (TryWalk())
		{
			// either moved forward or attacked
			return;
		}
	}

	if (d[2] != DI_NODIR)
	{
		movedir = d[2];

		if (TryWalk())
			return;
	}

	// there is no direct path to the player,
	// so pick another direction.
	if (olddir != DI_NODIR)
	{
		movedir = olddir;

		if (TryWalk())
			return;
	}

	// randomly determine direction of search
	if (P_Random() & 1)
	{
		for (tdir = DI_EAST; tdir <= DI_SOUTHEAST; tdir++)
		{
			if (tdir != turnaround)
			{
				movedir = tdir;

				if (TryWalk())
					return;
			}
		}
	}
	else
	{
		for (tdir = DI_SOUTHEAST; tdir != (DI_EAST - 1); tdir--)
		{
			if (tdir != turnaround)
			{
				movedir = tdir;

				if (TryWalk())
					return;
			}
		}
	}

	if (turnaround != DI_NODIR)
	{
		movedir = turnaround;
		if (TryWalk())
			return;
	}

	movedir = DI_NODIR;	// can not move
}

//**************************************************************************
//
//  $Log$
//  Revision 1.12  2002/02/06 17:28:51  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.11  2002/02/02 19:17:25  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.10  2002/01/28 18:50:17  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.9  2002/01/25 18:04:33  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.8  2002/01/17 18:15:52  dj_jl
//  Renamed all map object classes
//
//  Revision 1.7  2002/01/15 18:26:59  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.6  2002/01/07 12:21:10  dj_jl
//  Changed copyright year
//
//  Revision 1.5  2001/12/27 17:52:22  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.4  2001/10/22 17:23:11  dj_jl
//  Floatification of angles
//
//  Revision 1.3  2001/09/24 17:24:09  dj_jl
//  Beautification
//
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
