//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

#define	SKULLSPEED		700.0
#define SKULL_RADIUS	16.0
#define	FATSPREAD		(90.0 / 8.0)

class HackedActor:Actor
	abstract
{

int numbraintargets;
int braintargeton;
int brain_easy;
Actor braintargets[32];

//===========================================================================
//
//  A_BFGSpray
//
//  Spawn a BFG explosion on every monster in view
//
//===========================================================================

void A_BFGSpray(void)
{
	int i;
	int j;
	int damage;
	TAVec aimAng;
	Actor emo;

	// offset angles from its attack angle
	for (i = 0; i < 40; i++)
	{
		aimAng = Angles;
		aimAng.yaw = AngleMod360(aimAng.yaw - 45.0 + 90.0 / 40.0 * itof(i));

		// target is the originator (player)
		//  of the missile
		AimLineAttack(Instigator, aimAng, 16.0 * 64.0);
		if (!linetarget)
		{
			continue;
		}

		emo = Spawn(ExtraBFG, linetarget.Origin +
			vector(0.0, 0.0, linetarget.Height / 4.0));

		MSG_Select(MSG_SV_DATAGRAM);
		MSG_WriteByte(svc_explosion2);
		MSG_WriteByte(EF_DL_GBALL);
		MSG_WriteShort(ftoi(emo.Origin.x));
		MSG_WriteShort(ftoi(emo.Origin.y));
		MSG_WriteShort(ftoi(emo.Origin.z));

		damage = 0;
		for (j = 0; j < 15; j++)
			damage += (P_Random() & 7) + 1;

		linetarget.Damage(Instigator, Instigator, damage);
	}
}

//==========================================================================
//
//  A_PosAttack
//
//  Zombieman attack.
//
//==========================================================================

void A_PosAttack(void)
{
	int damage;
	TVec dir;

	if (!Enemy)
		return;

	A_FaceTarget();

	dir = AimLineAttack(self, Angles, MISSILERANGE);
	VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);

	PlaySound('PistolFire', CHAN_WEAPON);

	damage = ((P_Random() % 5) + 1) * 3;

	LineAttack(self, dir, MISSILERANGE, damage);

	Effects |= EF_DL_MUZZLEFLASH;
}

//==========================================================================
//
//  A_SPosAttack
//
//  Shotgun guy, Spider mastermind attack.
//
//==========================================================================

void A_SPosAttack(void)
{
	int i;
	int damage;
	TVec aimDir;
	TVec dir;

	if (!Enemy)
		return;

	PlaySound('ShotgunFire', CHAN_WEAPON);
	A_FaceTarget();
	aimDir = AimLineAttack(self, Angles, MISSILERANGE);
	for (i = 0; i < 3; i++)
	{
		dir = aimDir;
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
		damage = ((P_Random() % 5) + 1) * 3;
		LineAttack(self, dir, MISSILERANGE, damage);
	}

	Effects |= EF_DL_MUZZLEFLASH;
}

//==========================================================================
//
//  A_TroopAttack
//
//  Imp attack.
//
//==========================================================================

void A_TroopAttack(void)
{
	int damage;

	if (!Enemy)
		return;

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		PlaySound('ImpAttack', CHAN_WEAPON);
		damage = (P_Random() % 8 + 1) * 3;
		Enemy.Damage(self, self, damage);
		return;
	}

	// launch a missile
	SpawnMissile(Enemy, ImpMissile);
}

//==========================================================================
//
//  A_SargAttack
//
//  Demon, Spectre attack.
//
//==========================================================================

void A_SargAttack(void)
{
	int damage;

	if (!Enemy)
		return;

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		damage = ((P_Random() % 10) + 1) * 4;
		Enemy.Damage(self, self, damage);
	}
}

//==========================================================================
//
//  A_HeadAttack
//
//  Cacodemon attack.
//
//==========================================================================

void A_HeadAttack(void)
{
	int damage;

	if (!Enemy)
		return;

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		damage = (P_Random() % 6 + 1) * 10;
		Enemy.Damage(self, self, damage);
		return;
	}

	// launch a missile
	SpawnMissile(Enemy, CacodemonMissile);
}

//==========================================================================
//
//  A_BruisAttack
//
//  Hell knight, Baron of hell attack.
//
//==========================================================================

void A_BruisAttack(void)
{
	int damage;

	if (!Enemy)
		return;

	if (CheckMeleeRange())
	{
		PlaySound('ImpAttack', CHAN_WEAPON);
		damage = (P_Random() % 8 + 1) * 10;
		Enemy.Damage(self, self, damage);
		return;
	}

	// launch a missile
	SpawnMissile(Enemy, BruiserShot);
}

//==========================================================================
//
//  A_SkullAttack
//
//  Lost soul attack. Fly at the player like a missile.
//
//==========================================================================

void A_SkullAttack(void)
{
	if (!Enemy)
		return;

	bSkullFly = true;

	PlaySound(AttackSound, CHAN_VOICE);
	A_FaceTarget();
	Velocity = Normalize(MobjCenter(Enemy) - Origin) * 700.0;//SKULLSPEED;
}

//==========================================================================
//
//  A_Hoof
//
//  Cyberdemon move with hoof sound.
//
//==========================================================================

void A_Hoof(void)
{
	PlaySound('CyberWalk1', CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  A_Metal
//
//  Cyberdemon move with metal sound.
//
//==========================================================================

void A_Metal(void)
{
	PlaySound('CyberWalk2', CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  A_CyberAttack
//
//  Cyberdemon attack.
//
//==========================================================================

void A_CyberAttack(void)
{
	if (!Enemy)
		return;

	A_FaceTarget();
	SpawnMissile(Enemy, Rocket);
}

//==========================================================================
//
//  A_SpidRefire
//
//  Spider mastermind refire.
//
//==========================================================================

void A_SpidRefire(void)
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 10)
		return;

	if (!Enemy || Enemy.Health <= 0 || !P_CheckSight(self, Enemy))
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//  A_CPosAttack
//
//  Heavy weapon dude attack.
//
//==========================================================================

void A_CPosAttack(void)
{
	int damage;
	TVec dir;

	if (!Enemy)
		return;

	PlaySound('ShotgunFire', CHAN_WEAPON);
	A_FaceTarget();
	dir = AimLineAttack(self, Angles, MISSILERANGE);
	VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
	damage = ((P_Random() % 5) + 1) * 3;
	LineAttack(self, dir, MISSILERANGE, damage);

	Effects |= EF_DL_MUZZLEFLASH;
}

//==========================================================================
//
//  A_CPosRefire
//
//  Heavy weapon dude refire.
//
//==========================================================================

void A_CPosRefire(void)
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 40)
		return;

	if (!Enemy || Enemy.Health <= 0 || !P_CheckSight(self, Enemy))
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//  A_PainShootSkull
//
//  Spawn a lost soul and launch it at the target
//
//==========================================================================

void A_PainShootSkull(float angle)
{
	Actor mo;
	HackedActor newmobj;
	float prestep;
	int count;

	// count total number of skull currently on the level
	count = 0;
	FOREACH(Actor, mo)
	{
		if (mo.Class == LostSoul)
			count++;
	}

	// if there are allready 20 skulls on the level,
	// don't spit another one
	if (count > 20)
		return;

	// okay, there's playe for another one
	prestep = 4.0 + 3.0 * (Radius + SKULL_RADIUS) / 2.0;

	newmobj = HackedActor(Spawn(LostSoul, Origin + vector(
		prestep * cos(angle), prestep * sin(angle), 8.0)));

	// Check for movements.
	if (!newmobj.TryMove(newmobj.Origin))
	{
		// kill it immediately
		newmobj.Damage(self, self, 10000);
		return;
	}

	newmobj.Enemy = Enemy;
	newmobj.A_SkullAttack();
}

//==========================================================================
//
//  A_PainAttack
//
//  Pain elemental attack. Spawn a lost soul and launch it at the target.
// 
//==========================================================================

void A_PainAttack(void)
{
	if (!Enemy)
		return;

	A_FaceTarget();
	A_PainShootSkull(Angles.yaw);
}

//==========================================================================
//
//  A_PainDie
//
//  Pain elemental death.
//
//==========================================================================

void A_PainDie(void)
{
	A_Fall();
	A_PainShootSkull(Angles.yaw + 90.0);
	A_PainShootSkull(Angles.yaw + 180.0);
	A_PainShootSkull(Angles.yaw + 270.0);
}

//==========================================================================
//
//  A_SkelWhosh
//
//  Ravenant attack sound.
//
//==========================================================================

void A_SkelWhoosh(void)
{
	if (!Enemy)
		return;
	A_FaceTarget();
	PlaySound('RavenantSwing', CHAN_WEAPON);
}

//==========================================================================
//
//  A_SkelFist
//
//  Ravenant close attack.
//
//==========================================================================

void A_SkelFist(void)
{
	int damage;

	if (!Enemy)
		return;

	A_FaceTarget();

	if (CheckMeleeRange())
	{
		damage = ((P_Random() % 10) + 1) * 6;
		PlaySound('RavenantPunch', CHAN_WEAPON);
		Enemy.Damage(self, self, damage);
	}
}

//==========================================================================
//
//  A_SkelMissile
//
//  Ravenant far attack.
//
//==========================================================================

void A_SkelMissile(void)
{
	Actor A;

	if (!Enemy)
		return;

	A_FaceTarget();
	Origin.z += 16.0;	// so missile spawns higher
	A = SpawnMissile(Enemy, RevenantTracer);
	Origin.z -= 16.0;	// back to normal

	A.Origin = A.Origin + A.Velocity * 0.03;
	A.Enemy = Enemy;
}

//==========================================================================
//
//  A_Tracer
//
//  Ravenant missile tracer.
//
//==========================================================================

#define TRACEADJUST	0.2865921825

void A_Tracer(void)
{
	Actor A;
	TVec wishdir;
	TVec currdir;
	TVec delta;
	float adjustlen;

	if (level->tictime & 3)
		return;

	// spawn a puff of smoke behind the rocket      
	SpawnPuff(Origin.x, Origin.y, Origin.z);

	A = Spawn(RevenantTracerSmoke, Origin - Velocity * frametime);

	A.Velocity.z = 1.0 * 35.0;
	A.StateTime -= Random() * 0.1;
	if (A.StateTime < 0.1)
		A.StateTime = 0.1;

	// adjust direction
	if (!Enemy || Enemy.Health <= 0)
		return;

	wishdir = Normalize(MobjCenter(Enemy) - Origin);
	currdir = Normalize(Velocity);
	delta = wishdir - currdir;
	adjustlen = Length(delta);
	if (adjustlen > TRACEADJUST)
		adjustlen = TRACEADJUST;
	wishdir = currdir + delta * adjustlen;
	Velocity = wishdir * Speed;
	VectorAngles(&wishdir, &Angles);
}

//==========================================================================
//
//  A_FatRaise
//
//  Mancubus attack sound.
//
//==========================================================================

void A_FatRaise(void)
{
	A_FaceTarget();
	PlaySound('MancubusAttack', CHAN_WEAPON);
}

//==========================================================================
//
//  A_FatAttack1
//
//  Mancubus attack, firing three missiles (bruisers) in three different
// directions? Doesn't look like it.
//
//==========================================================================

void A_FatAttack1(void)
{
	Actor A;

	A_FaceTarget();
	// Change direction  to ...
	Angles.yaw = AngleMod360(Angles.yaw + FATSPREAD);
	SpawnMissile(Enemy, MancubusMissile);

	A = SpawnMissile(Enemy, MancubusMissile);
	A.Angles.yaw = AngleMod360(A.Angles.yaw + FATSPREAD);
	VectorRotateAroundZ(&A.Velocity, FATSPREAD);
}

//==========================================================================
//
//  A_FatAttack2
//
//  Mancubus attack, second direction.
//
//==========================================================================

void A_FatAttack2(void)
{
	Actor A;

	A_FaceTarget();
	// Now here choose opposite deviation.
	Angles.yaw = AngleMod360(Angles.yaw - FATSPREAD);
	SpawnMissile(Enemy, MancubusMissile);

	A = SpawnMissile(Enemy, MancubusMissile);
	A.Angles.yaw = AngleMod360(A.Angles.yaw - FATSPREAD * 2.0);
	VectorRotateAroundZ(&A.Velocity, -FATSPREAD * 2.0);
}

//==========================================================================
//
//  A_FatAttack3
//
//  Mancubus attack, third direction.
//
//==========================================================================

void A_FatAttack3(void)
{
	Actor A;

	A_FaceTarget();

	A = SpawnMissile(Enemy, MancubusMissile);
	A.Angles.yaw = AngleMod360(A.Angles.yaw - FATSPREAD / 2.0);
	VectorRotateAroundZ(&A.Velocity, -FATSPREAD / 2.0);

	A = SpawnMissile(Enemy, MancubusMissile);
	A.Angles.yaw = AngleMod360(A.Angles.yaw + FATSPREAD / 2.0);
	VectorRotateAroundZ(&A.Velocity, FATSPREAD / 2.0);
}

//==========================================================================
//
//  A_VileChase
//
//  Arch-vile check for ressurecting a body.
//
//==========================================================================

void A_VileChase(void)
{
	int xl;
	int xh;
	int yl;
	int yh;

	int bx;
	int by;

	Actor temp;

	if (MoveDir != DI_NODIR)
	{
		// check for corpses to raise
		viletryx = Origin.x + StepSpeed * xspeed[MoveDir];
		viletryy = Origin.y + StepSpeed * yspeed[MoveDir];
		vileobj = self;

		xl = MapBlock(viletryx - level->bmaporgx - MAXRADIUS * 2.0);
		xh = MapBlock(viletryx - level->bmaporgx + MAXRADIUS * 2.0);
		yl = MapBlock(viletryy - level->bmaporgy - MAXRADIUS * 2.0);
		yh = MapBlock(viletryy - level->bmaporgy + MAXRADIUS * 2.0);

		for (bx = xl; bx <= xh; bx++)
		{
			for (by = yl; by <= yh; by++)
			{
				// Call PIT_VileCheck to check whether object is a corpse
				// that canbe raised.
				if (!P_BlockThingsIterator(bx, by, 'PIT_VileCheck'))
				{
					// got one!
					temp = Enemy;
					Enemy = CorpseHit;
					A_FaceTarget();
					Enemy = temp;

					SetState(S_VILE_HEAL1);
					CorpseHit.PlaySound('Slop', CHAN_BODY);

					CorpseHit.SetState(CorpseHit.RaiseState);
					CorpseHit.Height *= 4.0;
					CorpseHit.bShootable = true;
					if (CorpseHit.Class == Cacodemon ||
						CorpseHit.Class == PainElemental)
					{
						CorpseHit.bFloat = true;
						CorpseHit.bNoGravity = true;
					}
					CorpseHit.bDropOff = false;
					CorpseHit.bSolid = true;
					CorpseHit.bCorpse = false;
					CorpseHit.Health = CorpseHit.SpawnHealth;
					CorpseHit.Enemy = none;
				}
			}
		}
	}


	// Return to normal attack.
	A_Chase();
}

//==========================================================================
//
//  A_VileStart
//
//  Arch-vile attack start sound.
//
//==========================================================================

void A_VileStart(void)
{
	PlaySound('ArchVileAttack', CHAN_WEAPON);
}

//==========================================================================
//
//  A_VileTarget
//
//  Spawn the hellfire.
//
//==========================================================================

void A_VileTarget(void)
{
	Actor fog;

	if (!Enemy)
		return;

	A_FaceTarget();

	fog = Spawn(ArchvileFire, Enemy.Origin);

	Instigator = fog;//FIXME!!!!!!!
	fog.Instigator = self;
	fog.Enemy = Enemy;
	fog.SetState(fog.SpawnState);
}

//==========================================================================
//
//  A_VileAttack
//
//  Arch-vile attack.
//
//==========================================================================

void A_VileAttack(void)
{
	Actor fire;

	if (!Enemy)
		return;

	A_FaceTarget();

	if (!P_CheckSight(self, Enemy))
		return;

	PlaySound('BarrelExplode', CHAN_WEAPON);
	Enemy.Damage(self, self, 20);
	Enemy.Velocity.z = 1000.0 / Enemy.Mass * 35.0;

	fire = Instigator;//FIXME!!!!!!

	if (!fire)
		return;

	// move the fire between the vile and the player
	fire.Origin.x = Enemy.Origin.x - 24.0 * cos(Angles.yaw);
	fire.Origin.y = Enemy.Origin.y - 24.0 * sin(Angles.yaw);
	fire.RadiusAttack(70, 0, 0);
}

//==========================================================================
//
//  A_Fire
//
//  Keep fire in front of player unless out of sight.
//
//==========================================================================

void A_Fire(void)
{
	if (!Enemy)
		return;

	// don't move it if the vile lost sight
	if (!P_CheckSight(Instigator, Enemy))
		return;

	P_UnsetThingPosition(self);
	Origin.x = Enemy.Origin.x + 24.0 * cos(Enemy.Angles.yaw);
	Origin.y = Enemy.Origin.y + 24.0 * sin(Enemy.Angles.yaw);
	Origin.z = Enemy.Origin.z;
	P_SetThingPosition(self);
}

//==========================================================================
//
//  A_StartFire
//
//  Make fire start sound.
//
//==========================================================================

void A_StartFire(void)
{
	PlaySound('FlameStart', CHAN_VOICE);
	A_Fire();
}

//==========================================================================
//
//  A_FireCrackle
//
//  Fire sound.
//
//==========================================================================

void A_FireCrackle(void)
{
	PlaySound('Flame', CHAN_VOICE);
	A_Fire();
}

//==========================================================================
//
//  A_BrainPain
//
//  Brain pain sound.
//
//==========================================================================

void A_BrainPain(void)
{
	PlayFullVolumeSound('BossPain', CHAN_VOICE);
}

//==========================================================================
//
//  A_BrainScream
//
//  Brain death sound, make explosions.
//
//==========================================================================

void A_BrainScream(void)
{
	TVec org;
	Actor A;

	for (org.x = Origin.x - 196.0; org.x < Origin.x + 320.0; org.x += 8.0)
	{
		org.y = Origin.y - 320.0;
		org.z = 1.0 / 512.0 + Random() * 512.0;
		A = Spawn(Rocket, org);
		A.Velocity.z = Random() * 2.0 * 35.0;

		A.SetState(S_BRAINEXPLODE1);

		A.StateTime -= Random() * 0.2;
		if (A.StateTime < 0.1)
			A.StateTime = 0.1;
	}

	PlayFullVolumeSound('BossDeath', CHAN_VOICE);
}

//==========================================================================
//
//  A_BrainExplode
//
//  Brain explosions.
//
//==========================================================================

void A_BrainExplode(void)
{
	TVec org;
	Actor A;

	org.x = Origin.x + (Random() - Random()) * 8.0;
	org.y = Origin.y;
	org.z = 1.0 / 512.0 + Random() * 512.0;
	A = Spawn(Rocket, org);
	A.Velocity.z = Random() * 2.0 * 35.0;

	A.SetState(S_BRAINEXPLODE1);

	A.StateTime -= Random() * 0.2;
	if (A.StateTime < 0.1)
		A.StateTime = 0.1;
}

//==========================================================================
//
//  A_BrainDie
//
//  Killed brain, exit level.
//
//==========================================================================

void A_BrainDie(void)
{
	G_ExitLevel();
}

//==========================================================================
//
//  A_BrainAwake
//
//  Init boss spawner.
//
//==========================================================================

void A_BrainAwake(void)
{
	Actor m;

	// find all the target spots
	numbraintargets = 0;
	FOREACH(Actor, m)
	{
		if (m.Class == BossTarget)
		{
			braintargets[numbraintargets] = m;
			numbraintargets++;
		}
	}
	braintargeton = 0;

	PlayFullVolumeSound('BossSight', CHAN_VOICE);
}

//==========================================================================
//
//  A_BrainSpit
//
//  Spawn a cube.
//
//==========================================================================

void A_BrainSpit(void)
{
	Actor targ;
	Actor A;

	brain_easy ^= 1;
	if (gameskill <= sk_easy && (!brain_easy))
		return;

	// shoot a cube at current target
	targ = braintargets[braintargeton];
	braintargeton = (braintargeton + 1) % numbraintargets;

	// spawn brain missile
	A = SpawnMissile(targ, SpawnShot);
	A.Enemy = targ;
	A.ReactionCount = ftoi((targ.Origin.y - Origin.y) /
		A.Velocity.y / A.StateTime);

	PlayFullVolumeSound('BossFire', CHAN_WEAPON);
}

//==========================================================================
//
//  A_SpawnFly
//
//  Cube flying, spawn monster, when finished.
//
//==========================================================================

void A_SpawnFly(void)
{
	Actor newmobj;
	Actor fog;
	int r;
	classid type;

	if (--ReactionCount)
		return;	// still flying

	// First spawn teleport fog.
	fog = Spawn(SpawnFire, Enemy.Origin);
	fog.PlaySound('Teleport', CHAN_VOICE);

	// Randomly select monster to spawn.
	r = P_Random();

	// Probability distribution (kind of :),
	// decreasing likelihood.
	if (r < 50)
		type = Imp;
	else if (r < 90)
		type = Demon;
	else if (r < 120)
		type = Shadows;
	else if (r < 130)
		type = PainElemental;
	else if (r < 160)
		type = Cacodemon;
	else if (r < 162)
		type = ArchVile;
	else if (r < 172)
		type = Revenant;
	else if (r < 192)
		type = Arachnotron;
	else if (r < 222)
		type = Mancubus;
	else if (r < 246)
		type = HellKnight;
	else
		type = BaronOfHell;

	newmobj = Spawn(type, Enemy.Origin);
	if (newmobj.LookForPlayers(true))
		newmobj.SetState(newmobj.SeeState);

	// telefrag anything in this spot
	newmobj.bTelestomp = true;
	newmobj.TeleportMove(newmobj.Origin);

	// remove self (i.e., cube).
	Remove();
}

//==========================================================================
//
//  A_SpawnSound
//
//  Travelling cube sound.
//
//==========================================================================

void A_SpawnSound(void)
{
	PlaySound('CubeFly', CHAN_VOICE);
	A_SpawnFly();
}

//==========================================================================
//
//  A_KeenDie
//
//  DOOM II special, map 32. Uses special tag 666.
//
//==========================================================================

void A_KeenDie(void)
{
	int args[5];

	A_Fall();

	// scan the remaining thinkers to see if all Keens are dead
	if (FindOther())
	{
		return;
	}
	args[0] = 666;
	args[1] = 16;
	args[2] = 150;
	args[3] = 0;
	EV_DoDoor(NULL, &args[0], doorOpen);
}

defaultproperties
{
}

}

//**************************************************************************
//
//  $Log$
//  Revision 1.1  2002/05/03 17:11:53  dj_jl
//  Object classes split up into their files.
//
//**************************************************************************
