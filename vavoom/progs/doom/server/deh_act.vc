//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class Zombieman;
class ShotgunGuy;
class Imp;
class Demon;
class Shadows;
class Cacodemon;
class LostSoul;
class ChaingunGuy;
class WolfSS;
class PainElemental;
class ArchVile;
class Revenant;
class Arachnotron;
class Mancubus;
class HellKnight;
class BaronOfHell;
class Cyberdemon;
class SpiderMastermind;

class ItemAmmoBulletClip;
class ItemWeaponShotgun;
class ItemWeaponChaingun;
class ItemInvulnerability;
class ItemInvisibility;

class ExtraBFG;
class ImpMissile;
class CacodemonMissile;
class BruiserShot;
class RevenantTracer;
class RevenantTracerSmoke;
class MancubusMissile;
class ArchvileFire;
class BossTarget;
class SpawnShot;
class SpawnFire;
class ArachnotronPlasma;

#define	SKULLSPEED		700.0
#define SKULL_RADIUS	16.0
#define	FATSPREAD		(90.0 / 8.0)

class HackedActor:Actor
	abstract
{

int numbraintargets;
int braintargeton;
int brain_easy;
Actor braintargets[32];

//==========================================================================
//
//	DropStuff
//
//==========================================================================

void DropStuff(void)
{
	classid item;
	Actor A;

	// Drop stuff.
	// This determines the kind of object spawned
	// during the death frame of a thing.
	switch (Class)
	{
	case WolfSS:
	case Zombieman:
		item = ItemAmmoBulletClip;
		break;

	case ShotgunGuy:
		item = ItemWeaponShotgun;
		break;

	case ChaingunGuy:
		item = ItemWeaponChaingun;
		break;

	default:
		return;
	}

	A = Spawn(item, vector(Origin.x, Origin.y, FloorZ));
	A.bDropped = true;	// special versions of items
}

//==========================================================================
//
//	HandlePickup
//
//==========================================================================

boolean HandlePickup(Actor Toucher)
{
	int i;
	name sound;

	sound = 'PickupItem';

	// Identify by sprite.
	switch (SpriteName)
	{
		// armor
	case 'ARM1':
		if (!Toucher.GiveArmor(1))
			return false;
		cprint(Toucher.Player, GOTARMOR);
		break;

	case 'ARM2':
		if (!Toucher.GiveArmor(2))
			return false;
		cprint(Toucher.Player, GOTMEGA);
		break;

		// bonus items
	case 'BON1':
		Toucher.Player->Health++;	// can go over 100%
		if (Toucher.Player->Health > 200)
			Toucher.Player->Health = 200;
		Toucher.Health = Toucher.Player->Health;
		cprint(Toucher.Player, GOTHTHBONUS);
		break;

	case 'BON2':
		Toucher.Player->ArmorPoints++;	// can go over 100%
		if (Toucher.Player->ArmorPoints > 200)
			Toucher.Player->ArmorPoints = 200;
		if (!Toucher.Player->ArmorType)
			Toucher.Player->ArmorType = 1;
		cprint(Toucher.Player, GOTARMBONUS);
		break;

	case 'SOUL':
		Toucher.Player->Health += SOULSPHERE_HEALTH;
		if (Toucher.Player->Health > SOULSPHERE_MAX)
			Toucher.Player->Health = SOULSPHERE_MAX;
		Toucher.Player->MO.Health = Toucher.Player->Health;
		cprint(Toucher.Player, GOTSUPER);
		sound = 'PickupPower';
		break;

	case 'MEGA':
		Toucher.Player->Health = MEGASPHERE_HEALTH;
		Toucher.Health = Toucher.Player->Health;
		Toucher.GiveArmor(2);
		cprint(Toucher.Player, GOTMSPHERE);
		sound = 'PickupPower';
		break;

		// cards
		// leave cards for everyone
	case 'BKEY':
		if (Toucher.GiveCard(it_bluecard))
			cprint(Toucher.Player, GOTBLUECARD);
		if (!netgame)
			break;
		return false;

	case 'YKEY':
		if (Toucher.GiveCard(it_yellowcard))
			cprint(Toucher.Player, GOTYELWCARD);
		if (!netgame)
			break;
		return false;

	case 'RKEY':
		if (Toucher.GiveCard(it_redcard))
			cprint(Toucher.Player, GOTREDCARD);
		if (!netgame)
			break;
		return false;

	case 'BSKU':
		if (Toucher.GiveCard(it_blueskull))
			cprint(Toucher.Player, GOTBLUESKUL);
		if (!netgame)
			break;
		return false;

	case 'YSKU':
		if (Toucher.GiveCard(it_yellowskull))
			cprint(Toucher.Player, GOTYELWSKUL);
		if (!netgame)
			break;
		return false;

	case 'RSKU':
		if (Toucher.GiveCard(it_redskull))
			cprint(Toucher.Player, GOTREDSKULL);
		if (!netgame)
			break;
		return false;

		// medikits, heals
	case 'STIM':
		if (!Toucher.GiveBody(10, MAXHEALTH))
			return false;
		cprint(Toucher.Player, GOTSTIM);
		break;

	case 'MEDI':
		if (!Toucher.GiveBody(25, MAXHEALTH))
			return false;

		if (Toucher.Player->Health < 25)
			cprint(Toucher.Player, GOTMEDINEED);
		else
			cprint(Toucher.Player, GOTMEDIKIT);
		break;

		// power ups
	case 'PINV':
		if (!Toucher.GivePower(pw_invulnerability))
			return false;
		cprint(Toucher.Player, GOTINVUL);
		sound = 'PickupPower';
		break;

	case 'PSTR':
		if (!Toucher.GivePower(pw_strength))
			return false;
		cprint(Toucher.Player, GOTBERSERK);
		sound = 'PickupPower';
		break;

	case 'PINS':
		if (!Toucher.GivePower(pw_invisibility))
			return false;
		cprint(Toucher.Player, GOTINVIS);
		sound = 'PickupPower';
		break;

	case 'SUIT':
		if (!Toucher.GivePower(pw_ironfeet))
			return false;
		cprint(Toucher.Player, GOTSUIT);
		sound = 'PickupPower';
		break;

	case 'PVIS':
		if (!Toucher.GivePower(pw_infrared))
			return false;
		cprint(Toucher.Player, GOTVISOR);
		sound = 'PickupPower';
		break;

		//  Items
	case 'PMAP':
		if (!Toucher.GiveItem(IT_ALL_MAP))
			return false;
		cprint(Toucher.Player, GOTMAP);
		sound = 'PickupPower';
		break;

		// ammo
	case 'CLIP':
		if (bDropped)
		{
			if (!Toucher.GiveAmmo(am_clip, clipammo[am_clip] / 2))
				return false;
		}
		else
		{
			if (!Toucher.GiveAmmo(am_clip, clipammo[am_clip]))
				return false;
		}
		cprint(Toucher.Player, GOTCLIP);
		break;

	case 'AMMO':
		if (!Toucher.GiveAmmo(am_clip, 5 * clipammo[am_clip]))
			return false;
		cprint(Toucher.Player, GOTCLIPBOX);
		break;

	case 'ROCK':
		if (!Toucher.GiveAmmo(am_misl, clipammo[am_misl]))
			return false;
		cprint(Toucher.Player, GOTROCKET);
		break;

	case 'BROK':
		if (!Toucher.GiveAmmo(am_misl, 5 * clipammo[am_misl]))
			return false;
		cprint(Toucher.Player, GOTROCKBOX);
		break;

	case 'CELL':
		if (!Toucher.GiveAmmo(am_cell, clipammo[am_cell]))
			return false;
		cprint(Toucher.Player, GOTCELL);
		break;

	case 'CELP':
		if (!Toucher.GiveAmmo(am_cell, 5 * clipammo[am_cell]))
			return false;
		cprint(Toucher.Player, GOTCELLBOX);
		break;

	case 'SHEL':
		if (!Toucher.GiveAmmo(am_shell, clipammo[am_shell]))
			return false;
		cprint(Toucher.Player, GOTSHELLS);
		break;

	case 'SBOX':
		if (!Toucher.GiveAmmo(am_shell, 5 * clipammo[am_shell]))
			return false;
		cprint(Toucher.Player, GOTSHELLBOX);
		break;

	case 'BPAK':
		if (!Toucher.Player->Backpack)
		{
			Toucher.Player->Backpack = true;
			for (i = 0; i < NUMAMMO; i++)
				Toucher.Player->MaxAmmo[i] *= 2;
		}
		for (i = 0; i < NUMAMMO; i++)
		{
			Toucher.GiveAmmo(i, clipammo[i]);
		}
		cprint(Toucher.Player, GOTBACKPACK);
		break;

		// weapons
	case 'BFUG':
		if (!Toucher.GiveWeapon(wp_bfg, false))
			return false;
		cprint(Toucher.Player, GOTBFG9000);
		sound = 'PickupWeapon';
		break;

	case 'MGUN':
		if (!Toucher.GiveWeapon(wp_chaingun, bDropped))
			return false;
		cprint(Toucher.Player, GOTCHAINGUN);
		sound = 'PickupWeapon';
		break;

	case 'CSAW':
		if (!Toucher.GiveWeapon(wp_chainsaw, false))
			return false;
		cprint(Toucher.Player, GOTCHAINSAW);
		sound = 'PickupWeapon';
		break;

	case 'LAUN':
		if (!Toucher.GiveWeapon(wp_missile, false))
			return false;
		cprint(Toucher.Player, GOTLAUNCHER);
		sound = 'PickupWeapon';
		break;

	case 'PLAS':
		if (!Toucher.GiveWeapon(wp_plasma, false))
			return false;
		cprint(Toucher.Player, GOTPLASMA);
		sound = 'PickupWeapon';
		break;

	case 'SHOT':
		if (!Toucher.GiveWeapon(wp_shotgun, bDropped))
			return false;
		cprint(Toucher.Player, GOTSHOTGUN);
		sound = 'PickupWeapon';
		break;

	case 'SGN2':
		if (!Toucher.GiveWeapon(wp_supershotgun, bDropped))
			return false;
		cprint(Toucher.Player, GOTSHOTGUN2);
		sound = 'PickupWeapon';
		break;
	}
	Toucher.PlaySound(sound, CHAN_ITEM);
	return true;
}

//===========================================================================
//
//  A_BFGSpray
//
//  Spawn a BFG explosion on every monster in view
//
//===========================================================================

void A_BFGSpray(void)
{
	int i;
	int j;
	int damage;
	TAVec aimAng;
	Actor emo;

	// offset angles from its attack angle
	for (i = 0; i < 40; i++)
	{
		aimAng = Angles;
		aimAng.yaw = AngleMod360(aimAng.yaw - 45.0 + 90.0 / 40.0 * itof(i));

		// target is the originator (player)
		//  of the missile
		AimLineAttack(Instigator, aimAng, 16.0 * 64.0);
		if (!linetarget)
		{
			continue;
		}

		emo = Spawn(ExtraBFG, linetarget.Origin +
			vector(0.0, 0.0, linetarget.Height / 4.0));

		MSG_Select(MSG_SV_DATAGRAM);
		MSG_WriteByte(svc_explosion2);
		MSG_WriteByte(EF_DL_GBALL);
		MSG_WriteShort(ftoi(emo.Origin.x));
		MSG_WriteShort(ftoi(emo.Origin.y));
		MSG_WriteShort(ftoi(emo.Origin.z));

		damage = 0;
		for (j = 0; j < 15; j++)
			damage += (P_Random() & 7) + 1;

		linetarget.Damage(Instigator, Instigator, damage);
	}
}

//==========================================================================
//
//  A_PosAttack
//
//  Zombieman attack.
//
//==========================================================================

void A_PosAttack(void)
{
	int damage;
	TVec dir;

	if (!Enemy)
		return;

	A_FaceTarget();

	dir = AimLineAttack(self, Angles, MISSILERANGE);
	VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);

	PlaySound('PistolFire', CHAN_WEAPON);

	damage = ((P_Random() % 5) + 1) * 3;

	LineAttack(self, dir, MISSILERANGE, damage);

	Effects |= EF_DL_MUZZLEFLASH;
}

//==========================================================================
//
//  A_SPosAttack
//
//  Shotgun guy, Spider mastermind attack.
//
//==========================================================================

void A_SPosAttack(void)
{
	int i;
	int damage;
	TVec aimDir;
	TVec dir;

	if (!Enemy)
		return;

	PlaySound('ShotgunFire', CHAN_WEAPON);
	A_FaceTarget();
	aimDir = AimLineAttack(self, Angles, MISSILERANGE);
	for (i = 0; i < 3; i++)
	{
		dir = aimDir;
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
		damage = ((P_Random() % 5) + 1) * 3;
		LineAttack(self, dir, MISSILERANGE, damage);
	}

	Effects |= EF_DL_MUZZLEFLASH;
}

//==========================================================================
//
//  A_TroopAttack
//
//  Imp attack.
//
//==========================================================================

void A_TroopAttack(void)
{
	int damage;

	if (!Enemy)
		return;

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		PlaySound('ImpAttack', CHAN_WEAPON);
		damage = (P_Random() % 8 + 1) * 3;
		Enemy.Damage(self, self, damage);
		return;
	}

	// launch a missile
	SpawnMissile(Enemy, ImpMissile);
}

//==========================================================================
//
//  A_SargAttack
//
//  Demon, Spectre attack.
//
//==========================================================================

void A_SargAttack(void)
{
	int damage;

	if (!Enemy)
		return;

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		damage = ((P_Random() % 10) + 1) * 4;
		Enemy.Damage(self, self, damage);
	}
}

//==========================================================================
//
//  A_HeadAttack
//
//  Cacodemon attack.
//
//==========================================================================

void A_HeadAttack(void)
{
	int damage;

	if (!Enemy)
		return;

	A_FaceTarget();
	if (CheckMeleeRange())
	{
		damage = (P_Random() % 6 + 1) * 10;
		Enemy.Damage(self, self, damage);
		return;
	}

	// launch a missile
	SpawnMissile(Enemy, CacodemonMissile);
}

//==========================================================================
//
//  A_BruisAttack
//
//  Hell knight, Baron of hell attack.
//
//==========================================================================

void A_BruisAttack(void)
{
	int damage;

	if (!Enemy)
		return;

	if (CheckMeleeRange())
	{
		PlaySound('ImpAttack', CHAN_WEAPON);
		damage = (P_Random() % 8 + 1) * 10;
		Enemy.Damage(self, self, damage);
		return;
	}

	// launch a missile
	SpawnMissile(Enemy, BruiserShot);
}

//==========================================================================
//
//  A_SkullAttack
//
//  Lost soul attack. Fly at the player like a missile.
//
//==========================================================================

void A_SkullAttack(void)
{
	if (!Enemy)
		return;

	bSkullFly = true;

	PlaySound(AttackSound, CHAN_VOICE);
	A_FaceTarget();
	Velocity = Normalize(MobjCenter(Enemy) - Origin) * 700.0;//SKULLSPEED;
}

//==========================================================================
//
//  A_Hoof
//
//  Cyberdemon move with hoof sound.
//
//==========================================================================

void A_Hoof(void)
{
	PlaySound('CyberWalk1', CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  A_Metal
//
//  Cyberdemon move with metal sound.
//
//==========================================================================

void A_Metal(void)
{
	PlaySound('CyberWalk2', CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  A_CyberAttack
//
//  Cyberdemon attack.
//
//==========================================================================

void A_CyberAttack(void)
{
	if (!Enemy)
		return;

	A_FaceTarget();
	SpawnMissile(Enemy, Rocket);
}

//==========================================================================
//
//  A_SpidRefire
//
//  Spider mastermind refire.
//
//==========================================================================

void A_SpidRefire(void)
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 10)
		return;

	if (!Enemy || Enemy.Health <= 0 || !CanSee(Enemy))
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//  A_CPosAttack
//
//  Heavy weapon dude attack.
//
//==========================================================================

void A_CPosAttack(void)
{
	int damage;
	TVec dir;

	if (!Enemy)
		return;

	PlaySound('ShotgunFire', CHAN_WEAPON);
	A_FaceTarget();
	dir = AimLineAttack(self, Angles, MISSILERANGE);
	VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
	damage = ((P_Random() % 5) + 1) * 3;
	LineAttack(self, dir, MISSILERANGE, damage);

	Effects |= EF_DL_MUZZLEFLASH;
}

//==========================================================================
//
//  A_CPosRefire
//
//  Heavy weapon dude refire.
//
//==========================================================================

void A_CPosRefire(void)
{
	// keep firing unless target got out of sight
	A_FaceTarget();

	if (P_Random() < 40)
		return;

	if (!Enemy || Enemy.Health <= 0 || !CanSee(Enemy))
	{
		SetState(SeeState);
	}
}

//==========================================================================
//
//  A_BabyMetal
//
//  Arachnotron move with metal sound.
//
//==========================================================================

void A_BabyMetal(void)
{
	PlaySound('BabyWalk', CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  A_BspiAttack
//
//  Arachnotron attack.
//
//==========================================================================

void A_BspiAttack(void)
{
	if (!Enemy)
		return;

	A_FaceTarget();

	// launch a missile
	SpawnMissile(Enemy, ArachnotronPlasma);
}

//==========================================================================
//
//  A_PainShootSkull
//
//  Spawn a lost soul and launch it at the target
//
//==========================================================================

void A_PainShootSkull(float angle)
{
	Actor mo;
	HackedActor newmobj;
	float prestep;
	int count;

	// count total number of skull currently on the level
	count = 0;
	FOREACH(Actor, mo)
	{
		if (mo.Class == LostSoul)
			count++;
	}

	// if there are allready 20 skulls on the level,
	// don't spit another one
	if (count > 20)
		return;

	// okay, there's playe for another one
	prestep = 4.0 + 3.0 * (Radius + SKULL_RADIUS) / 2.0;

	newmobj = HackedActor(Spawn(LostSoul, Origin + vector(
		prestep * cos(angle), prestep * sin(angle), 8.0)));

	// Check for movements.
	if (!newmobj.TryMove(newmobj.Origin))
	{
		// kill it immediately
		newmobj.Damage(self, self, 10000);
		return;
	}

	newmobj.Enemy = Enemy;
	newmobj.A_SkullAttack();
}

//==========================================================================
//
//  A_PainAttack
//
//  Pain elemental attack. Spawn a lost soul and launch it at the target.
// 
//==========================================================================

void A_PainAttack(void)
{
	if (!Enemy)
		return;

	A_FaceTarget();
	A_PainShootSkull(Angles.yaw);
}

//==========================================================================
//
//  A_PainDie
//
//  Pain elemental death.
//
//==========================================================================

void A_PainDie(void)
{
	A_Fall();
	A_PainShootSkull(Angles.yaw + 90.0);
	A_PainShootSkull(Angles.yaw + 180.0);
	A_PainShootSkull(Angles.yaw + 270.0);
}

//==========================================================================
//
//  A_SkelWhosh
//
//  Ravenant attack sound.
//
//==========================================================================

void A_SkelWhoosh(void)
{
	if (!Enemy)
		return;
	A_FaceTarget();
	PlaySound('RavenantSwing', CHAN_WEAPON);
}

//==========================================================================
//
//  A_SkelFist
//
//  Ravenant close attack.
//
//==========================================================================

void A_SkelFist(void)
{
	int damage;

	if (!Enemy)
		return;

	A_FaceTarget();

	if (CheckMeleeRange())
	{
		damage = ((P_Random() % 10) + 1) * 6;
		PlaySound('RavenantPunch', CHAN_WEAPON);
		Enemy.Damage(self, self, damage);
	}
}

//==========================================================================
//
//  A_SkelMissile
//
//  Ravenant far attack.
//
//==========================================================================

void A_SkelMissile(void)
{
	Actor A;

	if (!Enemy)
		return;

	A_FaceTarget();
	Origin.z += 16.0;	// so missile spawns higher
	A = SpawnMissile(Enemy, RevenantTracer);
	Origin.z -= 16.0;	// back to normal

	A.Origin = A.Origin + A.Velocity * 0.03;
	A.Enemy = Enemy;
}

//==========================================================================
//
//  A_Tracer
//
//  Ravenant missile tracer.
//
//==========================================================================

#define TRACEADJUST	0.2865921825

void A_Tracer(void)
{
	Actor A;
	TVec wishdir;
	TVec currdir;
	TVec delta;
	float adjustlen;

	if (level->tictime & 3)
		return;

	// spawn a puff of smoke behind the rocket      
	SpawnPuff(Origin.x, Origin.y, Origin.z);

	A = Spawn(RevenantTracerSmoke, Origin - Velocity * frametime);

	A.Velocity.z = 1.0 * 35.0;
	A.StateTime -= Random() * 0.1;
	if (A.StateTime < 0.1)
		A.StateTime = 0.1;

	// adjust direction
	if (!Enemy || Enemy.Health <= 0)
		return;

	wishdir = Normalize(MobjCenter(Enemy) - Origin);
	currdir = Normalize(Velocity);
	delta = wishdir - currdir;
	adjustlen = Length(delta);
	if (adjustlen > TRACEADJUST)
		adjustlen = TRACEADJUST;
	wishdir = currdir + delta * adjustlen;
	Velocity = wishdir * Speed;
	VectorAngles(&wishdir, &Angles);
}

//==========================================================================
//
//  A_FatRaise
//
//  Mancubus attack sound.
//
//==========================================================================

void A_FatRaise(void)
{
	A_FaceTarget();
	PlaySound('MancubusAttack', CHAN_WEAPON);
}

//==========================================================================
//
//  A_FatAttack1
//
//  Mancubus attack, firing three missiles (bruisers) in three different
// directions? Doesn't look like it.
//
//==========================================================================

void A_FatAttack1(void)
{
	Actor A;

	A_FaceTarget();
	// Change direction  to ...
	Angles.yaw = AngleMod360(Angles.yaw + FATSPREAD);
	SpawnMissile(Enemy, MancubusMissile);

	A = SpawnMissile(Enemy, MancubusMissile);
	A.Angles.yaw = AngleMod360(A.Angles.yaw + FATSPREAD);
	VectorRotateAroundZ(&A.Velocity, FATSPREAD);
}

//==========================================================================
//
//  A_FatAttack2
//
//  Mancubus attack, second direction.
//
//==========================================================================

void A_FatAttack2(void)
{
	Actor A;

	A_FaceTarget();
	// Now here choose opposite deviation.
	Angles.yaw = AngleMod360(Angles.yaw - FATSPREAD);
	SpawnMissile(Enemy, MancubusMissile);

	A = SpawnMissile(Enemy, MancubusMissile);
	A.Angles.yaw = AngleMod360(A.Angles.yaw - FATSPREAD * 2.0);
	VectorRotateAroundZ(&A.Velocity, -FATSPREAD * 2.0);
}

//==========================================================================
//
//  A_FatAttack3
//
//  Mancubus attack, third direction.
//
//==========================================================================

void A_FatAttack3(void)
{
	Actor A;

	A_FaceTarget();

	A = SpawnMissile(Enemy, MancubusMissile);
	A.Angles.yaw = AngleMod360(A.Angles.yaw - FATSPREAD / 2.0);
	VectorRotateAroundZ(&A.Velocity, -FATSPREAD / 2.0);

	A = SpawnMissile(Enemy, MancubusMissile);
	A.Angles.yaw = AngleMod360(A.Angles.yaw + FATSPREAD / 2.0);
	VectorRotateAroundZ(&A.Velocity, FATSPREAD / 2.0);
}

//==========================================================================
//
//  A_VileChase
//
//  Arch-vile check for ressurecting a body.
//
//==========================================================================

void A_VileChase(void)
{
	int xl;
	int xh;
	int yl;
	int yh;

	int bx;
	int by;

	Actor temp;

	if (MoveDir != DI_NODIR)
	{
		// check for corpses to raise
		viletryx = Origin.x + StepSpeed * xspeed[MoveDir];
		viletryy = Origin.y + StepSpeed * yspeed[MoveDir];
		vileobj = self;

		xl = MapBlock(viletryx - level->bmaporgx - MAXRADIUS * 2.0);
		xh = MapBlock(viletryx - level->bmaporgx + MAXRADIUS * 2.0);
		yl = MapBlock(viletryy - level->bmaporgy - MAXRADIUS * 2.0);
		yh = MapBlock(viletryy - level->bmaporgy + MAXRADIUS * 2.0);

		for (bx = xl; bx <= xh; bx++)
		{
			for (by = yl; by <= yh; by++)
			{
				// Call PIT_VileCheck to check whether object is a corpse
				// that canbe raised.
				if (!P_BlockThingsIterator(bx, by, 'PIT_VileCheck'))
				{
					// got one!
					temp = Enemy;
					Enemy = CorpseHit;
					A_FaceTarget();
					Enemy = temp;

					SetState(FindState('S_VILE_HEAL1'));
					CorpseHit.PlaySound('Slop', CHAN_BODY);

					CorpseHit.SetState(CorpseHit.RaiseState);
					CorpseHit.Height *= 4.0;
					CorpseHit.bShootable = true;
					CorpseHit.bFloat = CorpseHit.bDefaultFloat;
					CorpseHit.bNoGravity = CorpseHit.bDefaultNoGravity;
					CorpseHit.bDropOff = false;
					CorpseHit.bSolid = true;
					CorpseHit.bCorpse = false;
					CorpseHit.Health = CorpseHit.SpawnHealth;
					CorpseHit.Enemy = none;
				}
			}
		}
	}


	// Return to normal attack.
	A_Chase();
}

//==========================================================================
//
//  A_VileStart
//
//  Arch-vile attack start sound.
//
//==========================================================================

void A_VileStart(void)
{
	PlaySound('ArchVileAttack', CHAN_WEAPON);
}

//==========================================================================
//
//  A_VileTarget
//
//  Spawn the hellfire.
//
//==========================================================================

void A_VileTarget(void)
{
	Actor fog;

	if (!Enemy)
		return;

	A_FaceTarget();

	fog = Spawn(ArchvileFire, Enemy.Origin);

	Instigator = fog;//FIXME!!!!!!!
	fog.Instigator = self;
	fog.Enemy = Enemy;
	fog.SetState(fog.IdleState);
}

//==========================================================================
//
//  A_VileAttack
//
//  Arch-vile attack.
//
//==========================================================================

void A_VileAttack(void)
{
	Actor fire;

	if (!Enemy)
		return;

	A_FaceTarget();

	if (!CanSee(Enemy))
		return;

	PlaySound('BarrelExplode', CHAN_WEAPON);
	Enemy.Damage(self, self, 20);
	Enemy.Velocity.z = 1000.0 / Enemy.Mass * 35.0;

	fire = Instigator;//FIXME!!!!!!

	if (!fire)
		return;

	// move the fire between the vile and the player
	fire.Origin.x = Enemy.Origin.x - 24.0 * cos(Angles.yaw);
	fire.Origin.y = Enemy.Origin.y - 24.0 * sin(Angles.yaw);
	fire.RadiusAttack(70, 0, 0);
}

//==========================================================================
//
//  A_Fire
//
//  Keep fire in front of player unless out of sight.
//
//==========================================================================

void A_Fire(void)
{
	if (!Enemy)
		return;

	// don't move it if the vile lost sight
	if (!Instigator.CanSee(Enemy))
		return;

	UnlinkFromWorld();
	Origin.x = Enemy.Origin.x + 24.0 * cos(Enemy.Angles.yaw);
	Origin.y = Enemy.Origin.y + 24.0 * sin(Enemy.Angles.yaw);
	Origin.z = Enemy.Origin.z;
	LinkToWorld();
}

//==========================================================================
//
//  A_StartFire
//
//  Make fire start sound.
//
//==========================================================================

void A_StartFire(void)
{
	PlaySound('FlameStart', CHAN_VOICE);
	A_Fire();
}

//==========================================================================
//
//  A_FireCrackle
//
//  Fire sound.
//
//==========================================================================

void A_FireCrackle(void)
{
	PlaySound('Flame', CHAN_VOICE);
	A_Fire();
}

//==========================================================================
//
//  A_BrainPain
//
//  Brain pain sound.
//
//==========================================================================

void A_BrainPain(void)
{
	PlayFullVolumeSound('BossPain', CHAN_VOICE);
}

//==========================================================================
//
//  A_BrainScream
//
//  Brain death sound, make explosions.
//
//==========================================================================

void A_BrainScream(void)
{
	TVec org;
	Actor A;

	for (org.x = Origin.x - 196.0; org.x < Origin.x + 320.0; org.x += 8.0)
	{
		org.y = Origin.y - 320.0;
		org.z = 1.0 / 512.0 + Random() * 512.0;
		A = Spawn(Rocket, org);
		A.Velocity.z = Random() * 2.0 * 35.0;

		A.SetState(FindState('S_BRAINEXPLODE1'));

		A.StateTime -= Random() * 0.2;
		if (A.StateTime < 0.1)
			A.StateTime = 0.1;
	}

	PlayFullVolumeSound('BossDeath', CHAN_VOICE);
}

//==========================================================================
//
//  A_BrainExplode
//
//  Brain explosions.
//
//==========================================================================

void A_BrainExplode(void)
{
	TVec org;
	Actor A;

	org.x = Origin.x + (Random() - Random()) * 8.0;
	org.y = Origin.y;
	org.z = 1.0 / 512.0 + Random() * 512.0;
	A = Spawn(Rocket, org);
	A.Velocity.z = Random() * 2.0 * 35.0;

	A.SetState(FindState('S_BRAINEXPLODE1'));

	A.StateTime -= Random() * 0.2;
	if (A.StateTime < 0.1)
		A.StateTime = 0.1;
}

//==========================================================================
//
//  A_BrainDie
//
//  Killed brain, exit level.
//
//==========================================================================

void A_BrainDie(void)
{
	G_ExitLevel();
}

//==========================================================================
//
//  A_BrainAwake
//
//  Init boss spawner.
//
//==========================================================================

void A_BrainAwake(void)
{
	Actor m;

	// find all the target spots
	numbraintargets = 0;
	FOREACH(Actor, m)
	{
		if (m.Class == BossTarget)
		{
			braintargets[numbraintargets] = m;
			numbraintargets++;
		}
	}
	braintargeton = 0;

	PlayFullVolumeSound('BossSight', CHAN_VOICE);
}

//==========================================================================
//
//  A_BrainSpit
//
//  Spawn a cube.
//
//==========================================================================

void A_BrainSpit(void)
{
	Actor targ;
	Actor A;

	brain_easy ^= 1;
	if (gameskill <= sk_easy && (!brain_easy))
		return;

	// shoot a cube at current target
	targ = braintargets[braintargeton];
	braintargeton = (braintargeton + 1) % numbraintargets;

	// spawn brain missile
	A = SpawnMissile(targ, SpawnShot);
	A.Enemy = targ;
	A.ReactionCount = ftoi((targ.Origin.y - Origin.y) /
		A.Velocity.y / A.StateTime);

	PlayFullVolumeSound('BossFire', CHAN_WEAPON);
}

//==========================================================================
//
//  A_SpawnFly
//
//  Cube flying, spawn monster, when finished.
//
//==========================================================================

void A_SpawnFly(void)
{
	Actor newmobj;
	Actor fog;
	int r;
	classid type;

	if (--ReactionCount)
		return;	// still flying

	// First spawn teleport fog.
	fog = Spawn(SpawnFire, Enemy.Origin);
	fog.PlaySound('Teleport', CHAN_VOICE);

	// Randomly select monster to spawn.
	r = P_Random();

	// Probability distribution (kind of :),
	// decreasing likelihood.
	if (r < 50)
		type = Imp;
	else if (r < 90)
		type = Demon;
	else if (r < 120)
		type = Shadows;
	else if (r < 130)
		type = PainElemental;
	else if (r < 160)
		type = Cacodemon;
	else if (r < 162)
		type = ArchVile;
	else if (r < 172)
		type = Revenant;
	else if (r < 192)
		type = Arachnotron;
	else if (r < 222)
		type = Mancubus;
	else if (r < 246)
		type = HellKnight;
	else
		type = BaronOfHell;

	newmobj = Spawn(type, Enemy.Origin);
	if (newmobj.LookForPlayers(true))
		newmobj.SetState(newmobj.SeeState);

	// telefrag anything in this spot
	newmobj.bTelestomp = true;
	newmobj.TeleportMove(newmobj.Origin);

	// remove self (i.e., cube).
	Remove();
}

//==========================================================================
//
//  A_SpawnSound
//
//  Travelling cube sound.
//
//==========================================================================

void A_SpawnSound(void)
{
	PlaySound('CubeFly', CHAN_VOICE);
	A_SpawnFly();
}

//==========================================================================
//
//  A_KeenDie
//
//  DOOM II special, map 32. Uses special tag 666.
//
//==========================================================================

void A_KeenDie(void)
{
	int args[5];

	A_Fall();

	// scan the remaining thinkers to see if all Keens are dead
	if (FindOther())
	{
		return;
	}
	args[0] = 666;
	args[1] = 16;
	args[2] = 150;
	args[3] = 0;
	EV_DoDoor(NULL, &args[0], doorOpen);
}

//==========================================================================
//
//  A_BossDeath
//
//  Possibly trigger special effects if on first boss level
//
//==========================================================================

void A_BossDeath(void)
{
	string mapname;
	int i;
	Actor Other;
	int args[5];

	mapname = ARR2STR(level->mapname);

	if (!strcmp(mapname, "E1M8"))
	{
		if (Class != BaronOfHell)
			return;
	}
	else if (!strcmp(mapname, "E2M8"))
	{
		if (Class != Cyberdemon)
			return;
	}
	else if (!strcmp(mapname, "E3M8"))
	{
		if (Class != SpiderMastermind)
			return;
	}
	else if (!strcmp(mapname, "E4M6"))
	{
		if (Class != Cyberdemon)
			return;
	}
	else if (!strcmp(mapname, "E4M8"))
	{
		if (Class != SpiderMastermind)
			return;
	}
	else if (!strcmp(mapname, "MAP07"))
	{
		if ((Class != Mancubus) && (Class != Arachnotron))
			return;
	}
	else
	{
		//  Not a boss level
		return;
	}

	// make sure there is a player alive for victory
	for (i = 0; i < MAXPLAYERS; i++)
		if (players[i].bSpawned && players[i].Health > 0)
			break;

	if (i == MAXPLAYERS)
		return;	// no one left alive, so do not end game

	// scan the remaining thinkers to see if all bosses are dead
	FOREACH(Actor, Other)
	{
		if (Other != self && Other.Class == Class && Other.Health > 0)
		{
			// other boss not dead
			return;
		}
	}

	// victory!
	if (!strcmp(mapname, "E1M8"))
	{
		args[0] = 666;
		args[1] = 8;
		EV_DoFloor(NULL, &args[0], FLEV_LOWERFLOORTOLOWEST);
		return;
	}
	if (!strcmp(mapname, "E4M6"))
	{
		args[0] = 666;
		args[1] = 64;
		args[2] = 150;
		args[3] = 0;
		EV_DoDoor(NULL, &args[0], doorOpen);
		return;
	}
	if (!strcmp(mapname, "E4M8"))
	{
		args[0] = 666;
		args[1] = 8;
		EV_DoFloor(NULL, &args[0], FLEV_LOWERFLOORTOLOWEST);
		return;
	}
	if (!strcmp(mapname, "MAP07"))
	{
		if (Class == Mancubus)
		{
			args[0] = 666;
			args[1] = 8;
			EV_DoFloor(NULL, &args[0], FLEV_LOWERFLOORTOLOWEST);
		}
		else	// mo->Class == MT_BABY
		{
			args[0] = 667;
			args[1] = 8;
			EV_DoFloor(NULL, &args[0], FLEV_RAISETOTEXTURE);
		}
		return;
	}

	G_ExitLevel();
}

//==========================================================================
//
//	OnMapSpawn
//
//==========================================================================

void OnMapSpawn(mthing_t *mthing)
{
	::OnMapSpawn(mthing);
	if (Class == LostSoul)
	{
		bNoGravKill = true;
		bTriggerHappy = true;
	}
	if (Class == BaronOfHell || Class == HellKnight)
	{
		ImuneMissileType = BruiserShot;
	}
	if (Class == Cyberdemon)
	{
		MissileChance = 160.0;
		bTriggerHappy = true;
		bBoss = true;
	}
	if (Class == SpiderMastermind)
 	{
		bTriggerHappy = true;
		bBoss = true;
	}
	if (Class == Revenant)
	{
		bTriggerHappy = true;
		MissileMinRange = 196.0;
	}
	if (Class == ArchVile)
	{
		bNoGrudge = true;
		bNeverTarget = true;
		MissileMaxRange = 14.0 * 64.0;
	}

	if (Class == ItemInvulnerability || Class == ItemInvisibility)
	{
		bNoRespawn = true;
	}
}

defaultproperties
{
	Health = 0;
	GibsHealth = 0;
	Mass = 0.0;
}

}

//**************************************************************************
//
//  $Log$
//  Revision 1.6  2002/08/08 18:04:40  dj_jl
//  Fixes for renamed functions.
//
//  Revision 1.5  2002/07/13 08:01:48  dj_jl
//  Moved some functions to the Entity class.
//
//  Revision 1.4  2002/06/22 07:22:16  dj_jl
//  Added default values to Actor.
//
//  Revision 1.3  2002/06/14 15:53:12  dj_jl
//  Fixed DeHackEd support.
//
//  Revision 1.2  2002/05/18 16:59:58  dj_jl
//  Renamed SpawnState to IdleState, other changes.
//
//  Revision 1.1  2002/05/03 17:11:53  dj_jl
//  Object classes split up into their files.
//
//**************************************************************************
