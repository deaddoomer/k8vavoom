//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// ===== Polyobj Event Code =====

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

enum
{
	PODOOR_NONE,
	PODOOR_SLIDE,
	PODOOR_SWING
};

// TYPES -------------------------------------------------------------------

class PolyobjThinker:Thinker
{
	int polyobj;
	float thrust_force;
};

addfields polyobj_t
{
	PolyobjThinker SpecialData;	// pointer a thinker, if the poly is moving
};

// FUNCTION PROTOTYPES -----------------------------------------------------

boolean P_CheckPosition(mobj_t * thing, float x, float y);

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

class PolyobjRotator:PolyobjThinker
{
	float dist;
	float speed;

//==========================================================================
//
//	Think
//
//==========================================================================

void Think(void)
{
	float move;
	float absMove;
	polyobj_t *poly;

	move = speed * frametime;
	absMove = fabs(move);
	if (dist >= 0.0 && dist < absMove)
	{
		move = dist * (speed < 0.0 ? -1.0 : 1.0);
	}
	if (PO_RotatePolyobj(polyobj, move))
	{
		if (dist < 0.0)
		{
			// perpetual polyobj
			return;
		}
		dist -= absMove;
		if (dist <= 0.0)
		{
			poly = GetPolyobj(polyobj);
			if (poly->SpecialData == self)
			{
				poly->SpecialData = none;
			}
			PolyobjStopSequence(poly);
			PolyobjFinished(poly->tag);
			RemoveSpecialThinker(self);
			return;
		}
	}
}

}

//==========================================================================
//
//  EV_RotatePoly
//
//==========================================================================

boolean EV_RotatePoly(line_t * line, int *args, int direction, boolean
	overRide)
{
	int mirror;
	int polyNum;
	PolyobjRotator pe;
	polyobj_t *poly;

	polyNum = args[0];
	if ((poly = GetPolyobj(polyNum)))
	{
		if (poly->SpecialData && !overRide)
		{	// poly is already moving
			return false;
		}
	}
	else
	{
		Error("EV_RotatePoly:  Invalid polyobj num");	//: %d\n", polyNum);
	}
	pe = NewSpecialThinker(PolyobjRotator);
	pe.polyobj = polyNum;
	if (args[2])
	{
		if (args[2] == 255)
		{
			pe.dist = -1.0;
		}
		else
		{
			pe.dist = itof(args[2]) * (90.0 / 64.0);	// Angle
		}
	}
	else
	{
		pe.dist = 360.0;
	}
	pe.speed = AngleMod180(32.0 * itof(args[1]) * itof(direction) * 90.0 / 64.0 / 8.0);

	//THRUST
	pe.thrust_force = pe.speed / 32.0 * itof(0x800) / 90.0;

	poly->SpecialData = pe;
	PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));

	while ((mirror = GetPolyobjMirror(polyNum)))
	{
		poly = GetPolyobj(mirror);
		if (poly && poly->SpecialData && !overRide)
		{	// mirroring poly is already in motion
			break;
		}
		pe = NewSpecialThinker(PolyobjRotator);
		poly->SpecialData = pe;
		pe.polyobj = mirror;
		if (args[2])
		{
			if (args[2] == 255)
			{
				pe.dist = -1.0;
			}
			else
			{
				pe.dist = itof(args[2]) * (90.0 / 64.0);	// Angle
			}
		}
		else
		{
			pe.dist = 360.0;
		}
		if ((poly = GetPolyobj(polyNum)))
		{
			poly->SpecialData = pe;
		}
		else
		{
			Error("EV_RotatePoly:  Invalid polyobj num");	//: %d\n", polyNum);
		}
		direction = -direction;
		pe.speed = AngleMod180(32.0 * itof(args[1]) * itof(direction) * 90.0 / 64.0 / 8.0);

		//THRUST
		pe.thrust_force = pe.speed / 32.0 * itof(0x800) / 90.0;

		polyNum = mirror;
		PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));
	}
	return true;
}

class PolyobjMover:PolyobjThinker
{
	float speed;
	float dist;
	float angle;

//==========================================================================
//
//	Think
//
//==========================================================================

void Think(void)
{
	float move;
	float absMove;
	float xMove;
	float yMove;
	polyobj_t *poly;

	move = speed * frametime;
	absMove = fabs(move);
	if (dist < absMove)
	{
		move = dist * (move < 0.0 ? -1.0 : 1.0);
	}
	xMove = move * cos(angle);
	yMove = move * sin(angle);
	if (PO_MovePolyobj(polyobj, xMove, yMove))
	{
		dist -= absMove;
		if (dist <= 0.0)
		{
			poly = GetPolyobj(polyobj);
			if (poly->SpecialData == self)
			{
				poly->SpecialData = none;
			}
			PolyobjStopSequence(poly);
			PolyobjFinished(poly->tag);
			RemoveSpecialThinker(self);
			return;
		}
	}
}

}

//==========================================================================
//
// EV_MovePoly
//
//==========================================================================

boolean EV_MovePoly(line_t * line, int *args, boolean timesEight, boolean
	overRide)
{
	int mirror;
	int polyNum;
	PolyobjMover pe;
	polyobj_t *poly;
	float an;

	polyNum = args[0];
	if ((poly = GetPolyobj(polyNum)))
	{
		if (poly->SpecialData && !overRide)
		{	// poly is already moving
			return false;
		}
	}
	else
	{
		Error("EV_MovePoly:  Invalid polyobj num");	//: %d\n", polyNum);
	}
	pe = NewSpecialThinker(PolyobjMover);
	pe.polyobj = polyNum;
	if (timesEight)
	{
		pe.dist = itof(args[3]) * 8.0;
	}
	else
	{
		pe.dist = itof(args[3]);	// Distance
	}
	pe.speed = itof(args[1]) * 4.0;

	//THRUST
	pe.thrust_force = pe.speed / 8.0;

	poly->SpecialData = pe;

	an = itof(args[2]) * (90.0 / 64.0);

	pe.angle = an;
	PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));

	while ((mirror = GetPolyobjMirror(polyNum)))
	{
		poly = GetPolyobj(mirror);
		if (poly && poly->SpecialData && !overRide)
		{	// mirroring poly is already in motion
			break;
		}
		pe = NewSpecialThinker(PolyobjMover);
		pe.polyobj = mirror;
		poly->SpecialData = pe;
		if (timesEight)
		{
			pe.dist = itof(args[3]) * 8.0;
		}
		else
		{
			pe.dist = itof(args[3]);	// Distance
		}
		pe.speed = itof(args[1]) * 4.0;

		//THRUST
		pe.thrust_force = pe.speed / 8.0;

		an = AngleMod360(an + 180.0);	// reverse the angle
		pe.angle = an;
		polyNum = mirror;
		PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));
	}
	return true;
}

class PolyobjDoor:PolyobjThinker
{
	int type;
	float speed;
	float dist;
	float xSpeed;	// for sliding walls
	float ySpeed;
	float totalDist;
	float time;
	float waitTime;
	boolean close;

//==========================================================================
//
//  Think
//
//==========================================================================

void Think(void)
{
	polyobj_t *poly;
	float move;

	if (time)
	{
		time -= frametime;
		if (time <= 0.0)
		{
			time = 0.0;
			poly = GetPolyobj(polyobj);
			PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));
		}
		return;
	}
	switch (type)
	{
	case PODOOR_SLIDE:
		move = speed * frametime;
		if (PO_MovePolyobj(polyobj, move * xSpeed, move * ySpeed))
		{
			dist -= fabs(move);
			if (dist <= 0.0)
			{
				poly = GetPolyobj(polyobj);
				PolyobjStopSequence(poly);
				if (!close)
				{
					dist = totalDist;
					close = true;
					time = waitTime;
					xSpeed = -xSpeed;
					ySpeed = -ySpeed;
				}
				else
				{
					if (poly->SpecialData == self)
					{
						poly->SpecialData = none;
					}
					PolyobjFinished(poly->tag);
					RemoveSpecialThinker(self);
				}
			}
		}
		else
		{
			poly = GetPolyobj(polyobj);
			if (poly->crush || !close)
			{
				// continue moving if the poly is a crusher, or is opening
				return;
			}
			else
			{
				// open back up
				dist = totalDist - dist;
				xSpeed = -xSpeed;
				ySpeed = -ySpeed;
				close = false;
				PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));
			}
		}
		break;

	case PODOOR_SWING:
		move = speed * frametime;
		if (PO_RotatePolyobj(polyobj, move))
		{
			dist -= fabs(move);
			if (dist <= 0.0)
			{
				poly = GetPolyobj(polyobj);
				PolyobjStopSequence(poly);
				if (!close)
				{
					dist = totalDist;
					close = true;
					time = waitTime;
					speed = -speed;
				}
				else
				{
					if (poly->SpecialData == self)
					{
						poly->SpecialData = none;
					}
					PolyobjFinished(poly->tag);
					RemoveSpecialThinker(self);
				}
			}
		}
		else
		{
			poly = GetPolyobj(polyobj);
			if (poly->crush || !close)
			{
				// continue moving if the poly is a crusher, or is opening
				return;
			}
			else
			{
				// open back up and rewait
				dist = totalDist - dist;
				speed = -speed;
				close = false;
				PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));
			}
		}
		break;

	default:
		break;
	}
}

}

//==========================================================================
//
// EV_OpenPolyDoor
//
//==========================================================================

boolean EV_OpenPolyDoor(line_t * line, int *args, int type)
{
	int mirror;
	int polyNum;
	PolyobjDoor pd;
	polyobj_t *poly;
	float an = 0.0;

	polyNum = args[0];
	if ((poly = GetPolyobj(polyNum)))
	{
		if (poly->SpecialData)
		{	// poly is already moving
			return false;
		}
	}
	else
	{
		Error("EV_OpenPolyDoor:  Invalid polyobj num");	//: %d\n", polyNum);
	}
	pd = NewSpecialThinker(PolyobjDoor);
	pd.type = type;
	pd.polyobj = polyNum;
	if (type == PODOOR_SLIDE)
	{
		pd.waitTime = itof(args[4]) / 35.0;
		pd.speed = itof(args[1]) * 4.0;
		pd.totalDist = itof(args[3]);	// Distance
		pd.dist = pd.totalDist;
		an = itof(args[2]) * (90.0 / 64.0);
		pd.xSpeed = cos(an);
		pd.ySpeed = sin(an);

		//THRUST
		pd.thrust_force = pd.speed / 8.0;

		PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));
	}
	else if (type == PODOOR_SWING)
	{
		pd.waitTime = itof(args[3]) / 35.0;
		pd.speed = AngleMod180(4.0 * itof(args[1]) * (90.0 / 64.0));
		pd.totalDist = itof(args[2]) * (90.0 / 64.0);
		pd.dist = pd.totalDist;

		//THRUST
		pd.thrust_force = pd.speed * itof(0x1000) / 180.0;

		PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));
	}

	poly->SpecialData = pd;

	while ((mirror = GetPolyobjMirror(polyNum)))
	{
		poly = GetPolyobj(mirror);
		if (poly && poly->SpecialData)
		{	// mirroring poly is already in motion
			break;
		}
		pd = NewSpecialThinker(PolyobjDoor);
		pd.polyobj = mirror;
		pd.type = type;
		poly->SpecialData = pd;
		if (type == PODOOR_SLIDE)
		{
			pd.waitTime = itof(args[4]) / 35.0;
			pd.speed = itof(args[1]) * 4.0;
			pd.totalDist = itof(args[3]);	// Distance
			pd.dist = pd.totalDist;
			an = AngleMod360(an + 180.0);	// reverse the angle
			pd.xSpeed = cos(an);
			pd.ySpeed = sin(an);

			//THRUST
			pd.thrust_force = pd.speed / 8.0;

			PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));
		}
		else if (type == PODOOR_SWING)
		{
			pd.waitTime = itof(args[3]) / 35.0;
			pd.speed = AngleMod180(4.0 * itof(-args[1]) * (90.0 / 64.0));
			pd.totalDist = itof(args[2]) * (90.0 / 64.0);
			pd.dist = pd.totalDist;

			//THRUST
			pd.thrust_force = pd.speed * itof(0x1000) / 180.0;

			PolyobjStartSequence(poly, POLY_SEQ_NAME(poly->seqType));
		}
		polyNum = mirror;
	}
	return true;
}

//==========================================================================
//
//  PolyThrustMobj
//
//==========================================================================

void PolyThrustMobj(mobj_t * mobj, TVec thrustDir, polyobj_t * po)
{
	float force;
	PolyobjThinker pe;

	if (!(mobj->flags & MF_SHOOTABLE) && !mobj->player)
	{
		return;
	}

	pe = po->SpecialData;
	if (pe)
	{
		force = pe.thrust_force;
		if (force < 1.0)
		{
			force = 1.0;
		}
		else if (force > 128.0)
		{
			force = 128.0;
		}
	}
	else
	{
		force = 1.0;
	}

	mobj->velocity += force * thrustDir;
	if (po->crush)
	{
		TVec testPos;

		testPos = mobj->origin + force * thrustDir * frametime;
		if (!P_CheckPosition(mobj, testPos.x, testPos.y))
		{
			mobj->Damage(NULL, NULL, 3);
		}
	}
}

//==========================================================================
//
//  PolyBusy
//
//==========================================================================

boolean PolyBusy(int polyobj)
{
	polyobj_t *poly;

	poly = GetPolyobj(polyobj);
	if (!poly->SpecialData)
	{
		return false;
	}
	else
	{
		return true;
	}
}

//**************************************************************************
//
//  $Log$
//  Revision 1.3  2002/01/15 08:12:25  dj_jl
//  Replaced some pointers with references
//
//  Revision 1.2  2002/01/07 12:21:11  dj_jl
//  Changed copyright year
//
//  Revision 1.1  2001/12/18 18:29:15  dj_jl
//  Added Hexen action specials
//
//  Revision 1.8  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.7  2001/10/22 17:23:13  dj_jl
//  Floatification of angles
//
//  Revision 1.6  2001/10/18 17:39:34  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.5  2001/10/02 17:42:38  dj_jl
//  Possibility to declare function's code inside class declaration
//
//  Revision 1.4  2001/09/24 17:18:15  dj_jl
//  Created thinker classes
//
//  Revision 1.3  2001/09/20 16:20:00  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.2  2001/07/27 14:27:52  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
