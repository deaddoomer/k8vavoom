//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

enum
{
	FLOOREV_LowerToHighest,
	FLOOREV_RaiseToHighest,
	FLOOREV_LowerToLowest,
	FLOOREV_LowerToNearest,
	FLOOREV_RaiseToNearest,
	FLOOREV_RaiseToLowestCeiling,
	FLOOREV_LowerByValue,
	FLOOREV_RaiseByValue,
	FLOOREV_LowerByValueTimes8,
	FLOOREV_RaiseByValueTimes8,
	FLOOREV_LowerTimes8Instant,
	FLOOREV_RaiseTimes8Instant,
	FLOOREV_MoveToValueTimes8,
	FLOOREV_RaiseByTexture,
	FLOOREV_LowerToLowestChange,
	FLOOREV_RaiseToNearestChange,
	FLOOREV_RaiseByValueChange,
	FLOOREV_RaiseByValueChange2,
	FLOOREV_RaiseAndCrush,
	FLOOREV_Generic,
	FLOOREV_GenericChange0,
	FLOOREV_GenericChangeT,
	FLOOREV_GenericChange,
	FLOOREV_Donut
};

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  EV_DoFloor
//
//  HANDLE FLOOR TYPES
//
//==========================================================================

int EV_DoFloor(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type,
	line_t* Line)
{
	int			SecNum;
	int			Rtn;
	sector_t*	Sec;
	FloorMover	Floor;

	Rtn = false;
	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &GLevel.Sectors[SecNum];

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (Sec->FloorData)
			continue;

		// new floor thinker
		Rtn = true;
		Floor = NewSpecialThinker(FloorMover);
		Floor.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type, Line);
	}
	return Rtn;
}

//==========================================================================
//
//  EV_DoFloorAndCeiling
//
//==========================================================================

int EV_DoFloorAndCeiling(line_t * line, int *args, bool raise)
{
	bool floor;
	bool ceiling;

	if (raise)
	{
		floor = EV_DoFloor(args[0], args[1], args[2], args[3], args[4],
			FLOOREV_RaiseByValue, line);
		ceiling = EV_DoCeiling(args[0], args[1], args[2], args[3], args[4],
			CEILEV_RaiseByValue, line);
	}
	else
	{
		floor = EV_DoFloor(args[0], args[1], args[2], args[3], args[4],
			FLOOREV_LowerByValue, line);
		ceiling = EV_DoCeiling(args[0], args[1], args[2], args[3], args[4],
			CEILEV_LowerByValue, line);
	}
	return floor || ceiling;
}

//==========================================================================
//
// EV_FloorCrushStop
//
//==========================================================================

int EV_FloorCrushStop(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	FloorMover	Floor;
	bool		Rtn;

	Rtn = false;
	FOREACH(FloorMover, Floor)
	{
		if (Floor.CrushStop(Arg1))
		{
			Rtn = true;
		}
	}
	return Rtn;
}

//==========================================================================
//
//  EV_BuildStairsOld
//
//  BUILD A STAIRCASE!
//
//==========================================================================

int EV_BuildStairsOld(line_t * line, int *args)
{
	int secnum;
	float height;
	int i;
	int texture;
	int ok;
	int rtn;
	int j;

	sector_t *sec;
	sector_t *tsec;

	FloorMover Floor;

	float stairsize;

	stairsize = itof(args[2]);

	secnum = -1;
	rtn = 0;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &GLevel.Sectors[secnum];

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (sec->FloorData)
			continue;

		// new floor thinker
		rtn = 1;
		height = sec->floorheight + stairsize;
		Floor = NewSpecialThinker(FloorMover);
		Floor.InitStair(sec, args[1], 1, height);

		texture = sec->floor.pic;

		// Find next sector to raise
		// 1.   Find 2-sided line with same sector side[0]
		// 2.   Other side is the next sector to raise
		//   3. Unless already moving, or different texture, then stop building
		do
		{
			ok = 0;
			for (i = 0; i < sec->linecount; i++)
			{
				if (!(sec->lines[i]->flags & ML_TWOSIDED))
					continue;

				tsec = sec->lines[i]->frontsector;

				if (&GLevel.Sectors[secnum] != tsec)
					continue;

				tsec = sec->lines[i]->backsector;

				if (tsec->floor.pic != texture)
					continue;

				height += stairsize;

				if (tsec->FloorData)
					continue;

				sec = tsec;
//              secnum = tsec - GLevel.Sectors;
				for (j = 0; j < GLevel.NumSectors; j++)
					if (tsec == &GLevel.Sectors[j])
					{
						secnum = j;
						break;
					}

				Floor = NewSpecialThinker(FloorMover);
				Floor.InitStair(sec, args[1], 1, height);

				ok = 1;
				break;
			}
		}
		while (ok);
	}
	return rtn;
}

//==========================================================================
//
//  EV_DoDonut()
//
//  Handle donut function: lower pillar, raise surrounding pool, both to
// height, texture and type of the sector surrounding the pool.
//  Passed the linedef that triggered the donut
//  Returns whether a thinker was created
//
//==========================================================================

int EV_DoDonut(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
	sector_t*	s1;
	sector_t*	s2;
	sector_t*	s3;
	int			secnum;
	int			rtn;
	int			i;
	FloorMover	Floor;

	secnum = -1;
	rtn = 0;
	// do function on all sectors with same tag as linedef
	while ((secnum = FindSectorFromTag(Arg1, secnum)) >= 0)
	{
		s1 = &GLevel.Sectors[secnum];	// s1 is pillar's sector

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (s1->FloorData)
			continue;

		s2 = getNextSector(s1->lines[0], s1);	// s2 is pool's sector
		rtn = 1;

		// find a two sided line around the pool whose other side isn't the pillar
		for (i = 0; i < s2->linecount; i++)
		{
			if ((!s2->lines[i]->flags & ML_TWOSIDED) ||
				(s2->lines[i]->backsector == s1))
				continue;
			s3 = s2->lines[i]->backsector;

			//  Spawn rising slime
			Floor = NewSpecialThinker(FloorMover);
			Floor.InitDonut(s2, s3, Arg2);

			//  Spawn lowering donut-hole
			Floor = NewSpecialThinker(FloorMover);
			Floor.InitDonut2(s1, s3, Arg3);
			break;
		}
	}
	return rtn;
}

//**************************************************************************
//
//  STAIRS
//
//**************************************************************************

enum
{
	STAIRSEV_DownNormal,
	STAIRSEV_UpNormal,
	STAIRSEV_DownSync,
	STAIRSEV_UpSync
};

//==========================================================================
//
//	EV_BuildStairs
//
//	BUILD A STAIRCASE!
//
//	StairDirection is either positive or negative, denoting build stairs
// up or down.
//
//==========================================================================

int EV_BuildStairs(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
	int StairsType)
{
	int				SecNum;
	sector_t*		Sec;
	StairStepMover	StairStep;
	StairStepMover	StairQueueHead;

	StairQueueHead = none;
	for (SecNum = FindSectorFromTag(Arg1, -1); SecNum >= 0;
		SecNum = FindSectorFromTag(Arg1, SecNum))
	{
		Sec = &GLevel.Sectors[SecNum];

		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (Sec->FloorData)
			continue;

		StairStep = NewSpecialThinker(StairStepMover);
		StairStep.Init(Sec, Arg1, Arg2, Arg3, Arg4, Arg5,
			StairsType);
		if (StairQueueHead)
		{
			StairQueueHead.AppendToQueue(StairStep);
		}
		else
		{
			StairQueueHead = StairStep;
		}
		Sec->special &= ~SECSPEC_BASE_MASK;
	}
	for (StairStep = StairQueueHead; StairStep;
		StairStep = StairStep.QueueNext)
	{
		StairStep.ProcessStairSector();
	}
	return 1;
}

//**************************************************************************
//
//  PILLAR
//
//**************************************************************************

//==========================================================================
//
//  EV_BuildPillar
//
//==========================================================================

int EV_BuildPillar(line_t * line, int *args, bool crush)
{
	int secnum;
	sector_t *sec;
	Pillar pillar;
	float newHeight;
	int rtn;

	rtn = 0;
	secnum = -1;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &GLevel.Sectors[secnum];
		if (sec->FloorData || sec->CeilingData)
			continue;	// already moving
		if (sec->floorheight == sec->ceilingheight)
		{
			// pillar is already closed
			continue;
		}
		rtn = 1;
		if (!args[2])
		{
			newHeight = sec->floorheight +
				((sec->ceilingheight - sec->floorheight) / 2.0);
		}
		else
		{
			newHeight = sec->floorheight + itof(args[2]);
		}

		pillar = NewSpecialThinker(Pillar);
		sec->FloorData = pillar;
		sec->CeilingData = pillar;
		pillar.Sector = sec;
		if (!args[2])
		{
			pillar.floorSpeed = itof(args[1]) * 4.0;
			pillar.ceilingSpeed = pillar.floorSpeed;
		}
		else if (newHeight - sec->floorheight >
			sec->ceilingheight - newHeight)
		{
			pillar.floorSpeed = itof(args[1]) * 4.0;
			pillar.ceilingSpeed = (sec->ceilingheight - newHeight) *
				pillar.floorSpeed / (newHeight - sec->floorheight);
		}
		else
		{
			pillar.ceilingSpeed = itof(args[1]) * 4.0;
			pillar.floorSpeed = (newHeight - sec->floorheight) *
				pillar.ceilingSpeed / (sec->ceilingheight - newHeight);
		}
		pillar.floordest = newHeight;
		pillar.ceilingdest = newHeight;
		pillar.direction = 1;
		pillar.crush = crush * args[3];
//FIXME		SectorStartSequence(pillar.Sector,
//			seq_name[SEQ_PLATFORM + pillar.Sector->seqType]);
	}
	return rtn;
}

//==========================================================================
//
// EV_OpenPillar
//
//==========================================================================

int EV_OpenPillar(line_t * line, int *args)
{
	int secnum;
	sector_t *sec;
	Pillar pillar;
	int rtn;

	rtn = 0;
	secnum = -1;
	while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
	{
		sec = &GLevel.Sectors[secnum];
		if (sec->FloorData || sec->CeilingData)
			continue;	// already moving
		if (sec->floorheight != sec->ceilingheight)
		{	// pillar isn't closed
			continue;
		}
		rtn = 1;
		pillar = NewSpecialThinker(Pillar);
		sec->FloorData = pillar;
		sec->CeilingData = pillar;
		pillar.Sector = sec;
		if (!args[2])
		{
			pillar.floordest = FindLowestFloorSurrounding(sec, NULL);
		}
		else
		{
			pillar.floordest = sec->floorheight - itof(args[2]);
		}
		if (!args[3])
		{
			pillar.ceilingdest = FindHighestCeilingSurrounding(sec, NULL);
		}
		else
		{
			pillar.ceilingdest = sec->ceilingheight + itof(args[3]);
		}
		if (sec->floorheight - pillar.floordest >= pillar.ceilingdest -
			sec->ceilingheight)
		{
			pillar.floorSpeed = itof(args[1]) * 4.0;
			pillar.ceilingSpeed = (sec->ceilingheight -
				pillar.ceilingdest) * pillar.floorSpeed /
				(pillar.floordest - sec->floorheight);
		}
		else
		{
			pillar.ceilingSpeed = itof(args[1]) * 4.0;
			pillar.floorSpeed = (pillar.floordest -
				sec->floorheight) * pillar.ceilingSpeed /
				(sec->ceilingheight - pillar.ceilingdest);
		}
		pillar.direction = -1;	// open the pillar
//FIXME		SectorStartSequence(pillar.Sector,
//			seq_name[SEQ_PLATFORM + pillar.Sector->seqType]);
	}
	return rtn;
}

//**************************************************************************
//
//  FLOOR WAGGLE
//
//**************************************************************************

enum
{
	WGLSTATE_EXPAND,
	WGLSTATE_STABLE,
	WGLSTATE_REDUCE
};

//==========================================================================
//
//  EV_StartFloorWaggle
//
//==========================================================================

bool EV_StartFloorWaggle(int tag, int height, int speed, int offset,
	int timer)
{
	int sectorIndex;
	sector_t *sector;
	FloorWaggle Waggle;
	bool retCode;

	retCode = false;
	sectorIndex = -1;
	while ((sectorIndex = FindSectorFromTag(tag, sectorIndex)) >= 0)
	{
		sector = &GLevel.Sectors[sectorIndex];
		if (sector->FloorData)
		{
			// Already busy with another thinker
			continue;
		}
		retCode = true;
		Waggle = NewSpecialThinker(FloorWaggle);
		sector->FloorData = Waggle;
		Waggle.Sector = sector;
		Waggle.originalHeight = sector->floor.dist;
		Waggle.accumulator = itof(offset);
		Waggle.accSpeed = itof(speed) / 2.0;
		Waggle.scale = 0.0;
		Waggle.targetScale = itof(height) / 64.0;
		Waggle.scaleSpeed = Waggle.targetScale
			/ (1.0 + 3.0 * itof(height) / 255.0);
		Waggle.timer = timer ? itof(timer) : -1.0;
		Waggle.state = WGLSTATE_EXPAND;
	}
	return retCode;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.18  2005/03/01 14:39:31  dj_jl
//  Big update of line specials.
//
//  Revision 1.17  2005/01/25 17:45:12  dj_jl
//  Constants for common line specials
//  Updated special utilites.
//
//  Revision 1.16  2004/11/22 07:36:24  dj_jl
//  Implemented all sector specials in all games.
//
//  Revision 1.15  2002/10/26 16:32:20  dj_jl
//  New style of defining classes.
//
//  Revision 1.14  2002/09/07 16:28:24  dj_jl
//  Added Level class.
//
//  Revision 1.13  2002/04/11 16:48:09  dj_jl
//  New base classes for sector thinkers, Tick function.
//
//  Revision 1.12  2002/02/26 17:49:47  dj_jl
//  no message
//
//  Revision 1.11  2002/01/15 08:12:25  dj_jl
//  Replaced some pointers with references
//
//  Revision 1.10  2002/01/12 18:02:47  dj_jl
//  Replaced some C style casts with dynamic casts
//
//  Revision 1.9  2002/01/11 18:19:40  dj_jl
//  Started to use names in progs
//
//  Revision 1.8  2002/01/07 12:21:10  dj_jl
//  Changed copyright year
//
//  Revision 1.7  2001/12/18 18:29:15  dj_jl
//  Added Hexen action specials
//
//  Revision 1.6  2001/09/24 17:13:25  dj_jl
//  Created thinker classes
//
//  Revision 1.5  2001/09/20 16:19:59  dj_jl
//  Start using object-oriented stuff, beautification
//  
//  Revision 1.4  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.3  2001/08/01 17:44:54  dj_jl
//  Beautification
//  
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
