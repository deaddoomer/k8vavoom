//**************************************************************************
//**
//**	##   ##    ##    ##   ##   ####     ####   ###     ###
//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**	   #    ##    ##    #      ####     ####   ##       ##
//**
//**	$Id$
//**
//**	Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**	This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**	This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// TYPES -------------------------------------------------------------------

enum
{
	// lower floor to highest surrounding floor
	FLEV_LOWERFLOOR,
    
	// lower floor to lowest surrounding floor
	FLEV_LOWERFLOORTOLOWEST,
    
	// lower floor to highest surrounding floor VERY FAST
	FLEV_LOWERTOHIGHEST,
    
	// raise floor to lowest surrounding CEILING
	FLEV_RAISEFLOOR,
    
	// raise floor to next highest surrounding floor
	FLEV_RAISEFLOORTONEAREST,

	// raise floor to shortest height texture around it
	FLEV_RAISETOTEXTURE,
    
	// lower floor to lowest surrounding floor
	//  and change floorpic
	FLEV_LOWERTOLOWESTCHANGE,
  
	FLEV_RAISEFLOORBYVALUE,
	FLEV_RAISEFLOORBYVALUECHANGE,
	FLEV_RAISEFLOORCRUSH,

	FLEV_DONUT,
	FLEV_RAISEBYVALUETIMES8,

	FLEV_RAISEFLOORBYVALUECHANGE2,
	FLEV_RAISEFLOORTONEARESTCHANGE
};

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  T_MoveFloor
//
//	MOVE A FLOOR TO IT'S DESTINATION (UP OR DOWN)
//
//==========================================================================

void T_MoveFloor(special_t* floor)
{
    int			res;
	
    res = T_MovePlane(floor->sector,
		      floor->tic_speed,
		      floor->floordestheight,
		      floor->crush, 0, floor->direction);
    
    if (!(level->tictime & 7))
		StartSoundName(&floor->sector->soundorg, "StoneMoving", CHAN_VOICE);
    
    if (res == RES_PASTDEST)
    {
		floor->sector->specialdata = NULL;

		if (floor->direction == 1)
		{
		    switch (floor->type)
		    {
		      case FLEV_DONUT:
				floor->sector->special = floor->newspecial;
				SetFloorPic(floor->sector, floor->texture);
                break;
		      default:
				break;
		    }
		}
		else if (floor->direction == -1)
		{
		    switch (floor->type)
		    {
		      case FLEV_LOWERTOLOWESTCHANGE:
				floor->sector->special = floor->newspecial;
				SetFloorPic(floor->sector, floor->texture);
                break;
		      default:
				break;
		    }
		}
		RemoveSpecialThinker(floor);
		StartSoundName(&floor->sector->soundorg, "PlatformStop", CHAN_VOICE);
    }
}

//==========================================================================
//
//  EV_DoFloor
//
//	HANDLE FLOOR TYPES
//
//==========================================================================

int EV_DoFloor(line_t* line, int *args, int floortype)
{
    int				secnum;
    int				rtn;
    int				i;
    sector_t		*sec;
    special_t		*floor;
	float			minsize = 99999.0;
	line_t			*secline;
	side_t			*side;

    secnum = -1;
    rtn = 0;
    while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
    {
		sec = &level->sectors[secnum];
		
		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (sec->specialdata)
	    	continue;
	
		// new floor thinker
		rtn = 1;
		floor = NewSpecialThinker(T_MoveFloor);
		sec->specialdata = floor;
	    floor->sector = sec;
		floor->type = floortype;
		floor->crush = false;
	    floor->tic_speed = itof(args[1]) / 8.0;
/*		if (floortype == FLEV_LOWERTIMES8INSTANT ||
			floortype == FLEV_RAISETIMES8INSTANT)
		{
			floor->speed = 2000.0;
		}*/

		switch (floortype)
		{
		 case FLEV_LOWERFLOOR:
		    floor->direction = -1;
		    floor->floordestheight = FindHighestFloorSurrounding(sec);
		    break;

		 case FLEV_LOWERFLOORTOLOWEST:
		    floor->direction = -1;
		    floor->floordestheight = FindLowestFloorSurrounding(sec);
		    break;

		 case FLEV_LOWERTOHIGHEST:
		    floor->direction = -1;
		    floor->floordestheight = FindHighestFloorSurrounding(sec);
		    if (floor->floordestheight != sec->floorheight)
				floor->floordestheight += itof(args[2]) - 128.0;
		    break;

		 case FLEV_RAISEFLOOR:
		    floor->direction = 1;
		    floor->floordestheight = FindLowestCeilingSurrounding(sec);
		    if (floor->floordestheight > sec->ceilingheight)
				floor->floordestheight = sec->ceilingheight;
		    break;

		 case FLEV_RAISEFLOORCRUSH:
		    floor->crush = args[2];
		    floor->direction = 1;
		    floor->floordestheight = FindLowestCeilingSurrounding(sec);
		    if (floor->floordestheight > sec->ceilingheight)
				floor->floordestheight = sec->ceilingheight;
		    floor->floordestheight -= 8.0;
		    break;

		 case FLEV_RAISEFLOORTONEAREST:
		    floor->direction = 1;
		    floor->floordestheight = FindNextHighestFloor(sec, sec->floorheight);
		    break;

		 case FLEV_RAISEFLOORBYVALUE:
		    floor->direction = 1;
		    floor->floordestheight = floor->sector->floorheight +
		    	itof(args[2]);
		    break;

/*		 case FLEV_RAISETIMES8INSTANT:*/
		 case FLEV_RAISEBYVALUETIMES8:
		    floor->direction = 1;
		    floor->floordestheight = floor->sector->floorheight +
		    	itof(args[2]) * 8.0;
		    break;

		 case FLEV_RAISEFLOORBYVALUECHANGE:
		    floor->direction = 1;
		    floor->floordestheight = floor->sector->floorheight +
		    	itof(args[2]);
		    SetFloorPic(sec, line->frontsector->floor.pic);
		    sec->special = line->frontsector->special;
		    break;

		  case FLEV_RAISEFLOORBYVALUECHANGE2:
			floor->direction = 1;
		    floor->floordestheight = sec->floorheight + itof(args[2]) * 8.0;
		    SetFloorPic(sec, line->frontsector->floor.pic);
		    StartSoundName(&sec->soundorg, "StoneMoving", CHAN_VOICE);
		    break;

		 case FLEV_RAISETOTEXTURE:
			floor->direction = 1;
			for (i = 0; i < sec->linecount; i++)
			{
				secline = sec->lines[i];
				if (!(secline->flags & ML_TWOSIDED))
					continue;

				side = &level->sides[secline->sidenum[0]];
				if (side->bottomtexture >= 0)
					if (TextureHeight(side->bottomtexture) < minsize)
						minsize = TextureHeight(side->bottomtexture);

		      	side = &level->sides[secline->sidenum[1]];
				if (side->bottomtexture >= 0)
					if (TextureHeight(side->bottomtexture) < minsize)
						minsize = TextureHeight(side->bottomtexture);
			}
			floor->floordestheight = floor->sector->floorheight + minsize;
			break;
	  
		 case FLEV_LOWERTOLOWESTCHANGE:
		    floor->direction = -1;
	    	floor->floordestheight = FindLowestFloorSurrounding(sec);
		    floor->texture = sec->floor.pic;
	    	for (i = 0; i < sec->linecount; i++)
		    {
				secline = sec->lines[i];
				if (secline->flags & ML_TWOSIDED)
				{
				    if (level->sides[secline->sidenum[0]].sector == sec)
				    {
						sec = level->sides[secline->sidenum[1]].sector;

						if (sec->floorheight == floor->floordestheight)
						{
						    floor->texture = sec->floor.pic;
						    floor->newspecial = sec->special;
						    break;
						}
				    }
				    else
				    {
						sec = level->sides[secline->sidenum[0]].sector;

						if (sec->floorheight == floor->floordestheight)
						{
						    floor->texture = sec->floor.pic;
						    floor->newspecial = sec->special;
						    break;
						}
				    }
				}
		    }
			break;

		  case FLEV_RAISEFLOORTONEARESTCHANGE:
			floor->direction = 1;
		    floor->floordestheight = FindNextHighestFloor(sec, sec->floorheight);
		    SetFloorPic(sec, line->frontsector->floor.pic);
		    // NO MORE DAMAGE, IF APPLICABLE
		    sec->special = 0;
		    StartSoundName(&sec->soundorg, "StoneMoving", CHAN_VOICE);
		    break;
	    
/*
			case FLEV_LOWERFLOORBYVALUE:
				floor->direction = -1;
				floor->floordestheight = floor->sector->floorheight -
					itof(args[2]);
				break;
			case FLEV_LOWERTIMES8INSTANT:
			case FLEV_LOWERBYVALUETIMES8:
				floor->direction = -1;
				floor->floordestheight = floor->sector->floorheight -
					itof(args[2]) * 8.0;
				break;

			case FLEV_MOVETOVALUETIMES8:
				floor->floordestheight = itof(args[2]) * 8.0;
				if (args[3])
				{
					floor->floordestheight = -floor->floordestheight;
				}
				if (floor->floordestheight > floor->sector->floorheight)
				{
					floor->direction = 1;
				}
				else if (floor->floordestheight < floor->sector->floorheight)
				{
					floor->direction = -1;
				}
				else
				{ // already at lowest position
					rtn = 0;
				}
				break;
*/
		 default:
		    break;
		}
    }
    return rtn;
}

//==========================================================================
//
//	EV_BuildStairs
//
//	BUILD A STAIRCASE!
//
//==========================================================================

int EV_BuildStairs(line_t* line, int *args)
{
    int				secnum;
    float			height;
    int				i;
    int				texture;
    int				ok;
    int				rtn;
	int				j;

    sector_t*		sec;
    sector_t*		tsec;

    special_t*		floor;
    
    float			stairsize;
    float			speed;

	speed = itof(args[1]) / 8.0;
	stairsize = itof(args[2]);

    secnum = -1;
    rtn = 0;
    while ((secnum = FindSectorFromTag(args[0], secnum)) >= 0)
    {
		sec = &level->sectors[secnum];
		
	// ALREADY MOVING?  IF SO, KEEP GOING...
		if (sec->specialdata)
		    continue;
	
		// new floor thinker
		rtn = 1;
		floor = NewSpecialThinker(T_MoveFloor);
		sec->specialdata = floor;
		floor->direction = 1;
		floor->sector = sec;
		floor->tic_speed = speed;
		height = sec->floorheight + stairsize;
		floor->floordestheight = height;
		
		texture = sec->floor.pic;
	
		// Find next sector to raise
		// 1.	Find 2-sided line with same sector side[0]
		// 2.	Other side is the next sector to raise
	    //   3. Unless already moving, or different texture, then stop building
		do
		{
		    ok = 0;
		    for (i = 0;i < sec->linecount;i++)
		    {
				if (!(sec->lines[i]->flags & ML_TWOSIDED))
				    continue;
					
				tsec = sec->lines[i]->frontsector;
		
				if (&level->sectors[secnum] != tsec)
				    continue;

				tsec = sec->lines[i]->backsector;

				if (tsec->floor.pic != texture)
				    continue;

				height += stairsize;

				if (tsec->specialdata)
			    	continue;

				sec = tsec;
//				secnum = tsec - level->sectors;
				for (j=0; j<level->numsectors; j++)
                	if (tsec == &level->sectors[j])
                    {
                    	secnum = j;
                        break;
					}

				floor = NewSpecialThinker(T_MoveFloor);

				sec->specialdata = floor;
				floor->direction = 1;
				floor->sector = sec;
				floor->tic_speed = speed;
				floor->floordestheight = height;
				ok = 1;
				break;
			}
		} while (ok);
    }
    return rtn;
}

//==========================================================================
//
//	EV_DoDonut()
//
//	Handle donut function: lower pillar, raise surrounding pool, both to
// height, texture and type of the sector surrounding the pool.
//	Passed the linedef that triggered the donut
//	Returns whether a thinker was created
//
//==========================================================================

int EV_DoDonut(line_t *line, int *args)
{
	sector_t* 		s1;
	sector_t* 		s2;
	sector_t* 		s3;
	int       		secnum;
	int       		rtn;
	int       		i;
	special_t*		floor;

	secnum = -1;
	rtn = 0;
	// do function on all sectors with same tag as linedef
	while ((secnum = FindSectorFromTag(args[0],secnum)) >= 0)
	{
    	s1 = &level->sectors[secnum];                // s1 is pillar's sector
              
		// ALREADY MOVING?  IF SO, KEEP GOING...
		if (s1->specialdata)
		    continue;
                      
		s2 = getNextSector(s1->lines[0], s1);  // s2 is pool's sector
		rtn = 1;

		// find a two sided line around the pool whose other side isn't the pillar
		for (i = 0;i < s2->linecount; i++)
    	{
		    if ((!s2->lines[i]->flags & ML_TWOSIDED) ||
				(s2->lines[i]->backsector == s1))
					continue;
		    s3 = s2->lines[i]->backsector;
	    
		    //	Spawn rising slime
		    floor = NewSpecialThinker(T_MoveFloor);
		    s2->specialdata = floor;
		    floor->type = FLEV_DONUT;
		    floor->crush = false;
		    floor->direction = 1;
		    floor->sector = s2;
		    floor->tic_speed = itof(args[1]) / 8.0;
		    floor->texture = s3->floor.pic;
		    floor->newspecial = 0;
		    floor->floordestheight = s3->floorheight;
	    
		    //	Spawn lowering donut-hole
		    floor = NewSpecialThinker(T_MoveFloor);
		    s1->specialdata = floor;
		    floor->type = FLEV_LOWERFLOOR;
		    floor->crush = false;
		    floor->direction = -1;
		    floor->sector = s1;
		    floor->tic_speed = itof(args[2]) / 8.0;
		    floor->floordestheight = s3->floorheight;
		    break;
		}
    }
    return rtn;
}

//**************************************************************************
//
//	$Log$
//	Revision 1.4  2001/08/29 17:42:13  dj_jl
//	Added sound channel
//
//	Revision 1.3  2001/08/01 17:44:54  dj_jl
//	Beautification
//	
//	Revision 1.2  2001/07/27 14:27:51  dj_jl
//	Update with Id-s and Log-s, some fixes
//
//**************************************************************************
