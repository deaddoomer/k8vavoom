//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// Boss brain classes.
class BrainDeathMissile;
class Imp;
class Demon;
class Shadows;
class PainElemental;
class Cacodemon;
class ArchVile;
class Revenant;
class Arachnotron;
class Mancubus;
class HellKnight;
class BaronOfHell;

#define DAMAGE_COMPUTE(var, dam)  \
	{  \
		(var) = dam;  \
		if (dam##Error > 0)  \
			(var) += dam##Error * (P_Random() - P_Random()) / 255;  \
		else if (dam##Max > 0)  \
			(var) += (dam##Max - dam) * P_Random() / 255;  \
		if ((var) < 0) (var) = 0;  \
	}

//==========================================================================
//
//	Actor::ObjectSpawning
//
//	An Object spawns another object and is spawned in the state specificed
// by attack->objinitstate. The procedure is based on the A_PainShootSkull
// which is the routine for shooting skulls from a pain elemental. In
// this the object being created is decided in the attack. This
// procedure also used the new blocking line check to see if
// the object is spawned across a blocking line, if so the procedure
// terminates.
//
//==========================================================================

void Actor::ObjectSpawning(AttackType *attack, float angle)
{
	float spawnx;
	float spawny;
	float spawnz;
	//float slope;
	float prestep;
	Actor newobject;

	// -AJA- 1999/09/10: apply the angle offset of the attack.
	angle -= attack->AngleOffset;
	angle = AngleMod360(angle);
	//slope = object->vertangle + attack->slope_offset;
  
	newobject = Spawn(attack->SpawnedObj, Origin);

	if (attack->bPrestepSpawn)
	{
		prestep = 4.0 + 1.5 * Radius + newobject.Radius;
		spawnx = Origin.x + prestep * cos(angle);
		spawny = Origin.y + prestep * sin(angle);
	}
	else
	{
		spawnx = Origin.x;
		spawny = Origin.y;
	}
	spawnz = Origin.z + attack->Height;
	newobject.SetOrigin2(vector(spawnx, spawny, spawnz));

	if (attack->Sound)
		PlaySound(attack->Sound, CHAN_VOICE);

	// If the object cannot move from its position, remove it or kill it.
	if (!newobject.TryMove(newobject.Origin))
	{
		if (attack->bKillFailedSpawn)
			newobject.Died(self);
		else
			newobject.Remove();
		return;
	}

	newobject.Enemy = Enemy;

	// -AJA- 1999/09/25: Set the initial direction & momentum when
	//       the ANGLED_SPAWN attack special is used.
	if (attack->bAngledSpawn)
	{
		newobject.bSkullFly = true;
		newobject.A_FaceTarget();
		newobject.Velocity = Normalize(MobjCenter(newobject.Enemy) -
			newobject.Origin) * attack->AssaultSpeed;
	}

	newobject.SetState(attack->ObjInitState);
}

//==========================================================================
//
//	Actor::DoAttack
//
//	When an object goes on the attack, it current attack is handled here;
// the attack type is discerned and the assault is launched.
//
//==========================================================================

void Actor::DoAttack(AttackType *attack)
{
	int i;
	int damage;
	Actor proj;
	TVec aimDir;
	TVec dir;
	TAVec aimAng;

	switch (attack->AttackStyle)
	{
	case ATK_CloseCombat:
		if (CheckMeleeRange())
		{
			if (attack->Sound)
				PlaySound(attack->Sound, CHAN_WEAPON);
			DAMAGE_COMPUTE(damage, attack->Damage);
			Enemy.Damage(self, self, damage);
		}
		break;

	case ATK_Projectile:
		DAMAGE_COMPUTE(damage, attack->Damage);
		proj = SpawnMissile(Enemy, attack->AtkMobj);
		if (proj)
		{
			proj.MissileDamage = damage;
		}
		break;

	case ATK_SmartProjectile:	// EXTRA
		DAMAGE_COMPUTE(damage, attack->Damage);
		proj = SpawnMissile(Enemy, attack->AtkMobj);
		if (proj)
		{
			proj.MissileDamage = damage;
		}
		break;

	case ATK_RandomSpread:		// EXTRA
		//P_ActLaunchRandomSpread(object);
		break;

	case ATK_ShootToSpot:
		if (NumBrainTargets == 0)
		{
			LookForShootSpots();
		}
		BrainTargetOn += P_Random();
		BrainTargetOn %= NumBrainTargets;
		SpawnMissile(BrainTargets[BrainTargetOn], attack->AtkMobj);
		break;

	case ATK_Shot:
		aimDir = AimLineAttack(self, Angles, MISSILERANGE);
		if (attack->Sound)
			PlaySound(attack->Sound, CHAN_WEAPON);
		for (i = 0; i < attack->Count; i++)
		{
			dir = aimDir;
			VectorRotateAroundZ(&dir, (Random() - Random()) * attack->AccuracyAngle);
			DAMAGE_COMPUTE(damage, attack->Damage);
			LineAttack(self, dir, MISSILERANGE, damage);
		}
		break;

	case ATK_SkullFly:
		if (!Enemy)
		{
			return;
		}
		bSkullFly = true;
		if (attack->InitSound)
			PlaySound(attack->InitSound, CHAN_VOICE);
		Velocity = Normalize(MobjCenter(Enemy) - Origin) * attack->AssaultSpeed;
		break;

	case ATK_Spawner:
		ObjectSpawning(attack, Angles.yaw);
		break;

	case ATK_Spreader:
		DAMAGE_COMPUTE(damage, attack->Damage);
		if (SpreadCount < 0 || SpreadCount > 12)
			SpreadCount = 0;

		if (SpreadCount == 0)
		{
			Angles.yaw = AngleMod360(Angles.yaw + 90.0 / 8.0);
			proj = SpawnMissile(Enemy, attack->AtkMobj);
			if (proj)
			{
				proj.MissileDamage = damage;
			}
		}
		else if (SpreadCount == 4)
		{
			Angles.yaw = AngleMod360(Angles.yaw - 90.0 / 8.0);
			proj = SpawnMissile(Enemy, attack->AtkMobj);
			if (proj)
			{
				proj.MissileDamage = damage;
			}
		}
		else
		{
			proj = SpawnMissile(Enemy, attack->AtkMobj);
			if (proj)
			{
				proj.MissileDamage = damage;
				switch (SpreadCount)
				{
				case 2:
					proj.Angles.yaw = AngleMod360(proj.Angles.yaw + 90.0 / 8.0);
					VectorRotateAroundZ(&proj.Velocity, 90.0 / 8.0);
					break;
				case 6:
					proj.Angles.yaw = AngleMod360(proj.Angles.yaw - 90.0 / 4.0);
					VectorRotateAroundZ(&proj.Velocity, -90.0 / 4.0);
					break;
				case 8:
					proj.Angles.yaw = AngleMod360(proj.Angles.yaw - 90.0 / 16.0);
					VectorRotateAroundZ(&proj.Velocity, -90.0 / 16.0);
					break;
				case 10:
					proj.Angles.yaw = AngleMod360(proj.Angles.yaw + 90.0 / 16.0);
					VectorRotateAroundZ(&proj.Velocity, 90.0 / 16.0);
					break;
				}
			}
		}
		SpreadCount += 2;
		break;

	case ATK_Tracker:
		if (!Enemy)
			return;

		proj = Spawn(attack->AtkMobj, Enemy.Origin);

		Instigator = proj;//FIXME!!!!!!!
		proj.Instigator = self;
		proj.Enemy = Enemy;
		proj.P_ActTrackerFollow();
		break;

	case ATK_TripleSpawner:
		ObjectSpawning(attack, Angles.yaw + 90.0);
		ObjectSpawning(attack, Angles.yaw + 180.0);
		ObjectSpawning(attack, Angles.yaw + 270.0);
		break;

	case ATK_Spray:
		// offset angles from its attack angle
		for (i = 0; i < 40; i++)
		{
			aimAng = Angles;
			aimAng.yaw = AngleMod360(aimAng.yaw - 45.0 + 90.0 / 40.0 * itof(i));

			// target is the originator (player) of the missile
			AimLineAttack(Instigator, aimAng, attack->Range);
			if (!linetarget)
			{
				continue;
			}

			proj = Spawn(attack->AtkMobj, linetarget.Origin +
				vector(0.0, 0.0, linetarget.Height / 4.0));

		    DAMAGE_COMPUTE(damage, attack->Damage);
			linetarget.Damage(Instigator, Instigator, damage);
		}
		break;
	}
}

//==========================================================================
//
//	Actor::P_ActComboAttack
//
//	This is called at end of a set of states that can result in
// either a closecombat or ranged attack. The procedure checks
// to see if the target is within melee range and picks the
// approiate attack.
//
//==========================================================================

void Actor::P_ActComboAttack(void)
{
	AttackType *attack;

	if (!Enemy)
		return;

	if (CheckMeleeRange())
		attack = &CloseCombat;
	else
		attack = &RangeAttack;

	if (attack->bFaceTarget)
		A_FaceTarget();

	if (attack->bNeedSight)
	{
		if (!P_CheckSight(self, Enemy))
			return;
	}
	CurrentAttack = attack;
    DoAttack(attack);
}

//==========================================================================
//
//	Actor::P_ActMeleeAttack
//
//	Setup a close combat assault
//
//==========================================================================

void Actor::P_ActMeleeAttack(AttackType *custom_attack)
{
	AttackType *attack;

	attack = &CloseCombat;

	// -AJA- 1999/08/10: Multiple attack support.
	if (custom_attack)
		attack = custom_attack;

	if (attack->bFaceTarget)
		A_FaceTarget();

	if (attack->bNeedSight)
	{
		if (!Enemy || !P_CheckSight(self, Enemy))
			return;
	}
	CurrentAttack = attack;
	DoAttack(attack);
}

//==========================================================================
//
//	Actor::P_ActRangeAttack
//
//	Setup an attack at range
//
//==========================================================================

void Actor::P_ActRangeAttack(AttackType *custom_attack)
{
	AttackType *attack;

	attack = &RangeAttack;

	// -AJA- 1999/08/10: Multiple attack support.
	if (custom_attack)
		attack = custom_attack;

	if (attack->bFaceTarget)
		A_FaceTarget();

	if (attack->bNeedSight)
	{
		if (!Enemy || !P_CheckSight(self, Enemy))
			return;
	}
	CurrentAttack = attack;
	DoAttack(attack);
}

//==========================================================================
//
//	Actor::P_ActSpareAttack
//
//	Setup an attack that is not defined as close or range. can be
// used to act as a follow attack for close or range, if you want one to
// add to the others.
//
//==========================================================================

void Actor::P_ActSpareAttack(AttackType *custom_attack)
{
	AttackType *attack;

	attack = &SpareAttack;

	// -AJA- 1999/08/10: Multiple attack support.
	if (custom_attack)
		attack = custom_attack;

	if (attack->bFaceTarget && Enemy)
		A_FaceTarget();

	if (attack->bNeedSight && Enemy)
	{
		if (!P_CheckSight(self, Enemy))
			return;
	}

	CurrentAttack = attack;
	DoAttack(attack);
}

//==========================================================================
//
//	Actor::P_ActRefireCheck
//
//	This procedure will be called inbetween firing on an object
// that will fire repeatly (Chaingunner/Arachontron etc...), the
// purpose of this is to see if the object should refire and
// performs checks to that effect, first there is a check to see
// if the object will keep firing regardless and the others
// check if the the target exists, is alive and within view. The
// only other code here is a stealth check: a object with stealth
// capabilitys will lose the ability while firing.
//
//==========================================================================

void Actor::P_ActRefireCheck(void)
{
	AttackType *attack;

	attack = CurrentAttack;

	if (!attack)
		return;

	if (attack->bFaceTarget)
		A_FaceTarget();

	// Random chance that object will keep firing regardless
	if (Random() < attack->KeepFireChance)
		return;

	if (!Enemy || (Enemy.Health <= 0) || !P_CheckSight(self, Enemy))
	{
		if (SeeState)
			SetState(SeeState);
	}
//  else if (object->flags & MF_STEALTH)
//  {
//    object->vis_target = VISIBLE;
//  }
}

//==========================================================================
//
//	Actor::P_ActPlaySound
//
//	Generate an arbitrary sound.
//
//==========================================================================

void Actor::P_ActPlaySound(name sound)
{
	PlaySound(sound, CHAN_VOICE);
}

//==========================================================================
//
//	Actor::P_ActKillSound
//
//	Kill any current sounds from this thing.
//
//==========================================================================

void Actor::P_ActKillSound(void)
{
	StopSound(self, CHAN_AUTO);
}

//==========================================================================
//
//	Actor::P_ActMakeAmbientSound
//
//	Just a sound generating procedure that cause the sound ref
// in seesound to be generated.
//
//==========================================================================

void Actor::P_ActMakeAmbientSound(void)
{
	if (SightSound)
		PlaySound(SightSound, CHAN_VOICE);
}

//==========================================================================
//
//	Actor::P_ActMakeAmbientSoundRandom
//
//	Give a small "random" chance that this object will make its
// ambient sound. Currently this is a set value of 50, however
// the code that drives this, should allow for the user to set
// the value, note for further DDF Development.
//
//==========================================================================

void Actor::P_ActMakeAmbientSoundRandom(void)
{
	if (SightSound)
	{
		if (P_Random() < 50)
			PlaySound(SightSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	Actor::P_ActMakeActiveSound
//
//	Just a sound generating procedure that cause the sound ref
// in seesound to be generated.
//
//==========================================================================

void Actor::P_ActMakeActiveSound(void)
{
	if (ActiveSound)
		PlaySound(ActiveSound, CHAN_VOICE);
}

//==========================================================================
//
//	Actor::P_ActMakeDyingSound
//
//	This procedure is like everyother sound generating
// procedure with the exception that if the object is
// a boss (EF_BOSSMAN extended flag) then the sound is
// generated at full volume (source = NULL).
//
//==========================================================================

void Actor::P_ActMakeDyingSound(void)
{
	if (DeathSound)
	{
		if (bBoss)
			PlayFullVolumeSound(DeathSound, CHAN_VOICE);
		else
			PlaySound(DeathSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	Actor::P_ActMakePainSound (Ow!! it hurts!)
//
//==========================================================================

void Actor::P_ActMakePainSound(void)
{
	if (PainSound)
	{
		if (bBoss)
			PlayFullVolumeSound(PainSound, CHAN_VOICE);
		else
			PlaySound(PainSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	Actor::P_ActMakeOverKillSound
//
//==========================================================================

void Actor::P_ActMakeOverKillSound(void)
{
	if (OverkillSound)
	{
		if (bBoss)
			PlayFullVolumeSound(OverkillSound, CHAN_VOICE);
		else
			PlaySound(OverkillSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	Actor::P_ActMakeCloseAttemptSound
//
//	Attempting close combat sound
//
//==========================================================================

void Actor::P_ActMakeCloseAttemptSound(void)
{
	if (CloseCombat.InitSound)
	{
		PlaySound(CloseCombat.InitSound, CHAN_VOICE);
	}
}

//==========================================================================
//
//	Actor::P_ActMakeRangeAttemptSound
//
//	Attempting attack at range sound
//
//==========================================================================

void Actor::P_ActMakeRangeAttemptSound(void)
{
	if (RangeAttack.InitSound)
		PlaySound(RangeAttack.InitSound, CHAN_VOICE);
}

//==========================================================================
//
//	Actor::P_ActDamageExplosion
//
//	Radius Attack damage set by info->damage. Used for the original Barrels
//
//==========================================================================

void Actor::P_ActDamageExplosion(void)
{
	int damage;
  
	DAMAGE_COMPUTE(damage, ExplodeDamage);

	RadiusAttack(damage, damage, false);
}

//==========================================================================
//
//	Actor::P_ActWalkSoundChase
//
//==========================================================================

void Actor::P_ActWalkSoundChase(void)
{
	PlaySound(WalkSound, CHAN_BODY);
	A_Chase();
}

//==========================================================================
//
//  Actor::P_ActResurrectChase
//
//  Arch-vile check for ressurecting a body.
//
//==========================================================================

void Actor::P_ActResurrectChase(void)
{
	int xl;
	int xh;
	int yl;
	int yh;

	int bx;
	int by;

	Actor temp;

	if (MoveDir != DI_NODIR)
	{
		// check for corpses to raise
		viletryx = Origin.x + StepSpeed * xspeed[MoveDir];
		viletryy = Origin.y + StepSpeed * yspeed[MoveDir];
		vileobj = self;

		xl = MapBlock(viletryx - level->bmaporgx - MAXRADIUS * 2.0);
		xh = MapBlock(viletryx - level->bmaporgx + MAXRADIUS * 2.0);
		yl = MapBlock(viletryy - level->bmaporgy - MAXRADIUS * 2.0);
		yh = MapBlock(viletryy - level->bmaporgy + MAXRADIUS * 2.0);

		for (bx = xl; bx <= xh; bx++)
		{
			for (by = yl; by <= yh; by++)
			{
				// Call PIT_VileCheck to check whether object is a corpse
				// that canbe raised.
				if (!P_BlockThingsIterator(bx, by, 'PIT_VileCheck'))
				{
					// got one!
					temp = Enemy;
					Enemy = CorpseHit;
					A_FaceTarget();
					Enemy = temp;

					SetState(ResState);
					if (CorpseHit.OverkillSound)
						CorpseHit.PlaySound(CorpseHit.OverkillSound, CHAN_BODY);

					CorpseHit.SetState(CorpseHit.RaiseState);
					CorpseHit.Height *= 4.0;
					CorpseHit.bShootable = true;
					CorpseHit.bFloat = CorpseHit.bDefaultFloat;
					CorpseHit.bNoGravity = CorpseHit.bDefaultNoGravity;
					CorpseHit.bDropOff = false;
					CorpseHit.bSolid = true;
					CorpseHit.bCorpse = false;
					CorpseHit.Health = CorpseHit.SpawnHealth;
					CorpseHit.Enemy = none;
					return;
				}
			}
		}
	}


	// Return to normal attack.
	A_Chase();
}

//
//   BOSS-BRAIN HANDLING
//

//==========================================================================
//
//	Actor::LookForShootSpots
//
//==========================================================================

void Actor::LookForShootSpots(void)
{
	Actor m;

	// find all the target spots
	NumBrainTargets = 0;
	FOREACH(Actor, m)
	{
		if (m.Class == SpitSpot)
		{
			BrainTargets[NumBrainTargets] = m;
			NumBrainTargets++;
		}
	}
}

//==========================================================================
//
//  Actor::A_BrainScream
//
//  Brain death sound, make explosions.
//
//==========================================================================

void Actor::A_BrainScream(void)
{
	TVec org;
	Actor A;

	for (org.x = Origin.x - 196.0; org.x < Origin.x + 320.0; org.x += 8.0)
	{
		org.y = Origin.y - 320.0;
		org.z = 1.0 / 512.0 + Random() * 512.0;
		A = Spawn(BrainDeathMissile, org);
		if (A.SightSound)
			PlaySound(SightSound, CHAN_VOICE);
		A.Velocity.z = Random() * 2.0 * 35.0;

		A.StateTime -= Random() * 0.2;
		if (A.StateTime < 0.1)
			A.StateTime = 0.1;
	}

	if (DeathSound)
		PlayFullVolumeSound(DeathSound, CHAN_VOICE);
}

//==========================================================================
//
//  Actor::A_BrainDie
//
//  Killed brain, exit level.
//
//==========================================================================

void Actor::A_BrainDie(void)
{
	G_ExitLevel();
}

//==========================================================================
//
//  Actor::A_BrainSpit
//
//  Spawn a cube.
//
//==========================================================================

void Actor::A_BrainSpit(void)
{
	Actor targ;
	Actor A;

	BrainEasy ^= 1;
	if (gameskill <= sk_easy && (!BrainEasy))
		return;

	// shoot out a cube
	P_ActRangeAttack(NULL);
}

//==========================================================================
//
//	Actor::A_CubeSpawn
//
//  Cube flying, spawn monster, when finished.
//
//==========================================================================

void Actor::A_CubeSpawn(void)
{
	Actor newmobj;
	int r;
	classid type;

	// Randomly select monster to spawn.
	r = P_Random();

	// Probability distribution (kind of :),
	// decreasing likelihood.
	if (r < 50)
		type = Imp;
	else if (r < 90)
		type = Demon;
	else if (r < 120)
		type = Shadows;
	else if (r < 130)
		type = PainElemental;
	else if (r < 160)
		type = Cacodemon;
	else if (r < 162)
		type = ArchVile;
	else if (r < 172)
		type = Revenant;
	else if (r < 192)
		type = Arachnotron;
	else if (r < 222)
		type = Mancubus;
	else if (r < 246)
		type = HellKnight;
	else
		type = BaronOfHell;

	newmobj = Spawn(type, Enemy.Origin);
	if (newmobj.LookForPlayers(true))
	{
		if (newmobj.SeeState)
			newmobj.SetState(newmobj.SeeState);
		else
			newmobj.SetState(newmobj.SpawnState);
	}

	// telefrag anything in this spot
	newmobj.bTelestomp = true;
	newmobj.TeleportMove(newmobj.Origin);
}

//==========================================================================
//
//	Actor::A_BrainMissileExplode
//
//  Brain explosions.
//
//==========================================================================

void Actor::A_BrainMissileExplode(void)
{
	TVec org;
	Actor A;

	org.x = Origin.x + (Random() - Random()) * 8.0;
	org.y = Origin.y;
	org.z = 1.0 / 512.0 + Random() * 512.0;
	A = Spawn(BrainDeathMissile, org);
	if (SightSound)
		PlaySound(SightSound, CHAN_VOICE);
	A.Velocity.z = Random() * 2.0 * 35.0;

	A.StateTime -= Random() * 0.2;
	if (A.StateTime < 0.1)
		A.StateTime = 0.1;
}

//==========================================================================
//
//	Actor::P_ActJump
//
//	Jumps to the given label, possibly randomly.  Note: nothing to do
// with monsters physically jumping.
//
//==========================================================================

void Actor::P_ActJump(float chance, name jumpState)
{
	if (Random() < chance)
	{
		NextState = FindState(jumpState);
	}
}

//==========================================================================
//
//	Actor::P_ActFixedHomingProjectile
//
//==========================================================================

void Actor::P_ActFixedHomingProjectile(void)
{
	//Actor A;
	TVec wishdir;
	TVec currdir;
	TVec delta;
	float adjustlen;

	if (level->tictime & 3)
		return;

	// spawn a puff of smoke behind the rocket      
	SpawnPuff(Origin.x, Origin.y, Origin.z);

/*
	A = Spawn(RevenantTracerSmoke, Origin - Velocity * frametime);

	A.Velocity.z = 1.0 * 35.0;
	A.StateTime -= Random() * 0.1;
	if (A.StateTime < 0.1)
		A.StateTime = 0.1;
*/

	// adjust direction
	if (!Enemy || Enemy.Health <= 0)
		return;

	wishdir = Normalize(MobjCenter(Enemy) - Origin);
	currdir = Normalize(Velocity);
	delta = wishdir - currdir;
	adjustlen = Length(delta);
	if (adjustlen > 0.2865921825)
		adjustlen = 0.2865921825;
	wishdir = currdir + delta * adjustlen;
	Velocity = wishdir * Speed;
	VectorAngles(&wishdir, &Angles);
}

//==========================================================================
//
//	Actor::P_ActRandomHomingProjectile
//
//==========================================================================

void Actor::P_ActRandomHomingProjectile(void)
{
	//Actor A;
	TVec wishdir;
	TVec currdir;
	TVec delta;
	float adjustlen;

	if (level->tictime & 3)
		return;

	// spawn a puff of smoke behind the rocket      
	SpawnPuff(Origin.x, Origin.y, Origin.z);

/*
	A = Spawn(RevenantTracerSmoke, Origin - Velocity * frametime);

	A.Velocity.z = 1.0 * 35.0;
	A.StateTime -= Random() * 0.1;
	if (A.StateTime < 0.1)
		A.StateTime = 0.1;
*/

	// adjust direction
	if (!Enemy || Enemy.Health <= 0)
		return;

	wishdir = Normalize(MobjCenter(Enemy) - Origin);
	currdir = Normalize(Velocity);
	delta = wishdir - currdir;
	adjustlen = Length(delta);
	if (adjustlen > 0.2865921825)
		adjustlen = 0.2865921825;
	wishdir = currdir + delta * adjustlen;
	Velocity = wishdir * Speed;
	VectorAngles(&wishdir, &Angles);
}

//==========================================================================
//
//	Actor::P_ActHomeToSpot
//
//	This projectile will alter its course to intercept its
// target, or explode if it has reached it.  Used by the bossbrain
// cube.
//
//==========================================================================

void Actor::P_ActHomeToSpot(void)
{
	float dist;
	float ck_radius;

	if (!Enemy)
	{
		ExplodeMissile();
		return;
	}

	dist = Length(Enemy.Origin - Origin);

	ck_radius = Enemy.Radius + Radius + 2.0;
  
	// reached target ?
	if (dist <= ck_radius)
	{
		ExplodeMissile();
		return;
	}
	Velocity = Normalize(Enemy.Origin - Origin) * Speed;
}

//==========================================================================
//
//	Actor::P_ActEffectTracker
//
//  Arch-vile attack.
//
//==========================================================================

void Actor::P_ActEffectTracker(void)
{
	Actor tracker;
	int damage;

	if (!Enemy || !CurrentAttack)
		return;

	if (CurrentAttack->bFaceTarget)
		A_FaceTarget();

	if (CurrentAttack->bNeedSight)
	{
		if (!P_CheckSight(self, Enemy))
			return;
	}

	if (CurrentAttack->Sound)
		PlaySound(CurrentAttack->Sound, CHAN_WEAPON);
	DAMAGE_COMPUTE(damage, CurrentAttack->Damage);
	Enemy.Damage(self, self, damage);
	if (Enemy.Mass)
		Enemy.Velocity.z = 1000.0 / Enemy.Mass * 35.0;
	else
		Enemy.Velocity.z = 2000.0;

	tracker = Instigator;//FIXME!!!!!!

	if (!tracker)
		return;

	// move the fire between the vile and the player
	tracker.Origin.x = Enemy.Origin.x - 24.0 * cos(Angles.yaw);
	tracker.Origin.y = Enemy.Origin.y - 24.0 * sin(Angles.yaw);
	DAMAGE_COMPUTE(damage, tracker.ExplodeDamage);
	tracker.RadiusAttack(damage, 0, 0);
}

//==========================================================================
//
//	Actor::P_ActTrackerFollow
//
//	Called by the tracker to follow its target.
//
//==========================================================================

void Actor::P_ActTrackerFollow(void)
{
	if (!Enemy)
		return;

	// don't move it if the vile lost sight
	if (!P_CheckSight(Instigator, Enemy))
		return;

	P_UnsetThingPosition(self);
	Origin.x = Enemy.Origin.x + 24.0 * cos(Enemy.Angles.yaw);
	Origin.y = Enemy.Origin.y + 24.0 * sin(Enemy.Angles.yaw);
	Origin.z = Enemy.Origin.z;
	P_SetThingPosition(self);
}

//==========================================================================
//
//	Actor::P_ActTrackerActive
//
//	Called by the tracker to make its active sound: also tracks
//
//==========================================================================

void Actor::P_ActTrackerActive(void)
{
	if (ActiveSound)
		PlaySound(ActiveSound, CHAN_VOICE);

	P_ActTrackerFollow();
}

//==========================================================================
//
//	Actor::P_ActTrackerStart
//
//	Called by the tracker to make its launch (see) sound: also tracks
//
//==========================================================================

void Actor::P_ActTrackerStart(void)
{
	if (SightSound)
		PlaySound(SightSound, CHAN_VOICE);

	P_ActTrackerFollow();
}

//==========================================================================
//
//	Actor::P_ActTransSet
//
//==========================================================================

void Actor::P_ActTransSet(int value)
{
	Translucency = value;
}

//==========================================================================
//
//	PlayerPawn::ActPlayerAttack
//
//==========================================================================

void PlayerPawn::ActPlayerAttack(AttackType *attack)
{
	int i;
	float range;
	int damage;
	TAVec aimAngles;
	TVec dir;
	TVec aimDir;
	Actor proj;

	range = (attack->Range > 0.0) ? attack->Range : MISSILERANGE;

	switch (attack->AttackStyle)
	{
	case ATK_CloseCombat:
		if (attack->Sound)
			PlaySound(attack->Sound, CHAN_WEAPON);

		DAMAGE_COMPUTE(damage, attack->Damage);

		if (Player->Powers[pw_strength])
			damage *= 10;

		aimAngles = Player->MO.Angles;
		aimAngles.yaw = AngleMod360(aimAngles.yaw + (Random() -
			Random()) * 45.0 / 8.0);
		dir = AimLineAttack(Player->MO, aimAngles, attack->Range);
		LineAttack(Player->MO, dir, attack->Range, damage);

		// turn to face target
		if (linetarget && attack->bFaceTarget)
		{
			Player->MO.Angles.yaw = atan2(
				linetarget.Origin.y - Player->MO.Origin.y,
				linetarget.Origin.x - Player->MO.Origin.x);
			Player->bFixAngle = true;
		}
		break;

	case ATK_Projectile:
		DAMAGE_COMPUTE(damage, attack->Damage);
		proj = SpawnPlayerMissile(attack->AtkMobj);
		proj.MissileDamage = damage;
		break;

	case ATK_Shot:
		if (attack->Sound)
			PlaySound(attack->Sound, CHAN_WEAPON);

		aimDir = Aim(Player->MO, 16.0 * 64.0);
		// -AJA- 1999/09/10: apply the attack's angle offsets.
		//objangle -= attack->angle_offset;
		//objslope += attack->slope_offset;
		for (i = 0; i < attack->Count; i++)
		{
			//  Make a copy of angles because inacurate shoot will modify them
			dir = aimDir;
			if (!Player->Refire)
			{
				TAVec angles;

				VectorAngles(&dir, &angles);
				if (attack->AccuracyAngle > 0.0)
					angles.yaw += attack->AccuracyAngle * (Random() - Random());
				//if (attack->accuracy_slope > 0)
				//	slope += attack->accuracy_slope * (P_RandomNegPos() / 255.0);
				AngleVector(&angles, &dir);
			}
			DAMAGE_COMPUTE(damage, attack->Damage);
			LineAttack(self, dir, MISSILERANGE, damage);
		}
		break;

	case ATK_SmartProjectile:	// EXTRA
		print("Smart proj\n");
		//LaunchSmartProjectile(object, target, attack->atk_mobj);
		break;

	case ATK_RandomSpread:		// EXTRA
		print("Random spread\n");
		//P_ActLaunchRandomSpread(object);
		break;

	case ATK_ShootToSpot:		// EXTRA
		print("Shoot to spot\n");
		//ShootToSpot(object);
		break;

	case ATK_SkullFly:			// EXTRA
		Error("Player can't skullfly");
		break;

	case ATK_Spawner:			// EXTRA
		print("spawner\n");
		//ObjectSpawning(object, object->angle);
		break;

	case ATK_Spreader:			// EXTRA
		print("Spreader\n");
		//P_ActLaunchOrderedSpread(object);
		break;

	case ATK_Tracker:			// EXTRA
		print("Tracker\n");
		//LaunchTracker(object);
		break;

	case ATK_TripleSpawner:		// EXTRA
		print("Tripple spawner\n");
		//ObjectTripleSpawn(object);
		break;

	case ATK_Spray:				// EXTRA
		Error("Player spray");
		break;

	default:
		print("Bad attack type %d\n", attack->AttackStyle);
	}
}

//**************************************************************************
//
//	AttackHolder
//
//**************************************************************************

class AttackHolder:Object
{

AttackType Attack;

defaultproperties
{
	Attack.DamageMax = -1;
	Attack.DamageError = -1;
}

}

//**************************************************************************
//
//  $Log$
//  Revision 1.3  2002/06/14 15:51:20  dj_jl
//  A lots of changes, new functions etc for DDF.
//
//  Revision 1.2  2002/05/29 16:48:38  dj_jl
//  Some updates.
//
//  Revision 1.1  2002/05/18 17:03:28  dj_jl
//  Working on DDF to VavoomC converter.
//
//**************************************************************************
