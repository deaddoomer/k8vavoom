//**************************************************************************
//**
//**	##   ##    ##    ##   ##   ####     ####   ###     ###
//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**	   #    ##    ##    #      ####     ####   ##       ##
//**
//**	$Id$
//**
//**	Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**	This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**	This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**	Moving object handling.
//**	Mobj spawn, damage, kill, set state functions
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define ITEMQUESIZE		128

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

void SetupPsprites(player_t* player);
void DropWeapon(player_t* player);
void P_SpawnPlayer(mthing_t* mthing);
void P_NightmareRespawn(mobj_t* mobj);
void P_ExplodeMissile(mobj_t* mo);
boolean P_CheckPosition(mobj_t* thing, float x, float y);
boolean P_TryMove(mobj_t* thing, float x, float y);

// DATA DECLARATIONS -------------------------------------------------------

mthing_t	itemrespawnque[ITEMQUESIZE];
int			itemrespawntime[ITEMQUESIZE];
int			iquehead;
int			iquetail;

// CODE --------------------------------------------------------------------

//==========================================================================
//==========================================================================
//
//	GAME SPAWN FUNCTIONS
//
//==========================================================================
//==========================================================================

//==========================================================================
//
//	SetOrigin
//
//==========================================================================

void SetOrigin(mobj_t *mobj, TVec origin)
{
    mobj->origin = origin;

    // set subsector and/or block links
    P_SetThingPosition(mobj);
	
    if (origin.z == ONFLOORZ)
    {
		mobj->origin.z = mobj->floorz;
	}
    else if (origin.z == ONCEILINGZ)
	{
    	mobj->origin.z = mobj->ceilingz - mobj->height;
	}
}

//==========================================================================
//
//	CopyMThing
//
//==========================================================================

void CopyMThing(mthing_t *from, mthing_t *to)
{
	to->tid = from->tid;
	to->x = from->x;
	to->y = from->y;
	to->height = from->height;
	to->angle = from->angle;
	to->type = from->type;
	to->options = from->options;
	to->special = from->special;
	to->arg1 = from->arg1;
	to->arg2 = from->arg2;
	to->arg3 = from->arg3;
	to->arg4 = from->arg4;
	to->arg5 = from->arg5;
}

//==========================================================================
//
//	generic_mobj_start
//
//==========================================================================

void generic_mobj_start(mobj_t *self, mthing_t *mthing)
{
    state_t*	st;

    self->lastlook = P_Random() % MAXPLAYERS;
    // do not set the state with P_SetMobjState,
    // because action routines can not be called yet
    st = &states[self->spawnstate];

    self->time = st->time;
    self->sprite = st->sprite;
    self->frame = st->frame;
	self->model_index = st->model_index;
	self->alias_frame = st->model_frame;
    self->statenum = st->statenum;
    self->nextstate = st->nextstate;

	if (mthing)
	{
	    float		x;
    	float		y;
	    float		z;

		CopyMThing(mthing, &self->spawnpoint);

    	x = mthing->x;
	    y = mthing->y;
	    if (self->flags & MF_SPAWNCEILING)
			z = ONCEILINGZ;
	    else
			z = ONFLOORZ;
		SetOrigin(self, vector(x, y, z));
		if (z == ONFLOORZ)
		{
			self->origin.z += mthing->height;
		}
		else if (z == ONCEILINGZ)
		{
			self->origin.z -= mthing->height;
		}
		P_SetThingPosition(self);

		self->tid = mthing->tid;
		self->special = mthing->special;
		self->args[0] = mthing->arg1;
		self->args[1] = mthing->arg2;
		self->args[2] = mthing->arg3;
		self->args[3] = mthing->arg4;
		self->args[4] = mthing->arg5;
	    if (self->time > 0.0)
			self->time = 0.1 + Random() * self->time;
	    if (self->flags & MF_COUNTKILL)
			level->totalkills++;
	    if (self->flags & MF_COUNTITEM)
			level->totalitems++;
		
	    self->angles.yaw = ANG45 * (mthing->angle / 45);
    	if (mthing->options & MTF_AMBUSH)
			self->flags |= MF_AMBUSH;
	}
	else
	{
		SetOrigin(self, self->origin);
	}
}

//==========================================================================
//
//	P_SpawnMobj
//
//==========================================================================

mobj_t *P_SpawnMobj(float x, float y, float z, int type)
{
    mobj_t*		mobj;

	mobj = NewMobjThinker();
    mobj->type = type;
	mobj->origin = vector(x, y, z);
	mobjinfo[type].spawnfunc(mobj, NULL);
    return mobj;
}

//==========================================================================
//
//	P_SpawnMapThing
//
//	The fields of the mapthing should already be in host byte order.
//
//==========================================================================

void P_SpawnMapThing(mthing_t* mthing, boolean spawn_thinkers)
{
    int			i;
    int			bit;
    mobj_t*		mobj;
	int			spawnMask;

#ifndef DOOM2
	switch(mthing->type)
	{
	 case 68:        // Arachnotron
	 case 64:        // Archvile
	 case 88:        // Boss Brain
	 case 89:        // Boss Shooter
	 case 69:        // Hell Knight
	 case 67:        // Mancubus
	 case 71:        // Pain Elemental
	 case 65:        // Former Human Commando
	 case 66:        // Revenant
	 case 84:        // Wolf SS
		NotDoom2();
	}
#endif

	if (mthing->type <= 0)
		return;

    // count deathmatch start positions
    if (mthing->type == 11)
    {
		if (level->numdeathmatchstarts < MAXDEATHMATCHSTARTS)
		{
			CopyMThing(mthing, &level->deathmatchstarts[level->numdeathmatchstarts]);
	    	level->numdeathmatchstarts++;
		}
		return;
    }
	
    // check for players specially
    if (mthing->type <= 4)
    {
		// save spots for respawning in network games
        CopyMThing(mthing, &level->playerstarts[mthing->arg1 * MAXPLAYERS + mthing->type - 1]);
		return;
    }

	//	Don't spawn, if we are loading a savegame
    if (!spawn_thinkers)
    {
    	return;
    }

	// Check current game type with spawn flags
	if (netgame == false)
	{
		spawnMask = MTF_GSINGLE;
	}
	else if(deathmatch)
	{
		spawnMask = MTF_GDEATHMATCH;
	}
	else
	{
		spawnMask = MTF_GCOOP;
	}
	if (!(mthing->options & spawnMask))
	{
		return;
	}

    // check for apropriate skill level
    if (gameskill == sk_baby)
		bit = 1;
    else if (gameskill == sk_nightmare)
		bit = 4;
    else
		bit = 1 << (gameskill - 1);

    if (!(mthing->options & bit))
		return;
	
    // find which type to spawn
	for (i = 0; i < num_mobj_types; i++)
	{
		if (mthing->type == mobjinfo[i].doomednum)
		{
		    // spawn it
			mobj = NewMobjThinker();
		    mobj->type = i;
			mobjinfo[i].spawnfunc(mobj, mthing);
			return;
		}
	}
	dprint("P_SpawnMapThing: Unknown type %d at (%f, %f)\n",
		mthing->type, mthing->x, mthing->y);
}

//==========================================================================
//
//  SpawnPuff
//
//==========================================================================

void SpawnPuff(float x, float y, float z)
{
#if 1
	MSG_Select(MSG_SV_DATAGRAM, NULL);
	MSG_WriteByte(svc_gun_shot);
	MSG_WriteShort(ftoi(x));
	MSG_WriteShort(ftoi(y));
	MSG_WriteShort(ftoi(z));
#else
    mobj_t*	th;

    z += (Random() - Random()) * 4.0;

    th = P_SpawnMobj(x, y, z, MT_PUFF);
    th->velocity.z = 1.0 * 35.0;
    th->time -= Random() * 0.1;

    if (th->time < 0.1)
		th->time = 0.1;

#ifdef FIXME
    // don't make punches spark on the wall
    if (attackrange == MELEERANGE)
		SetMobjState(th, S_PUFF3);
#endif
#endif
}

//==========================================================================
//
//	P_SpawnBlood
// 
//==========================================================================

void P_SpawnBlood(float x, float y, float z, int damage)
{
#if 0
    mobj_t	*th;
#endif

	MSG_Select(MSG_SV_DATAGRAM, NULL);
	MSG_WriteByte(svc_blood);
	MSG_WriteShort(ftoi(x));
	MSG_WriteShort(ftoi(y));
	MSG_WriteShort(ftoi(z));
	MSG_WriteByte(damage > 255 ? 255 : damage);
#if 0
    z += (Random() - Random()) * 4.0;
    th = P_SpawnMobj(x, y, z, MT_BLOOD);
    th->velocity.z = 2.0 * 35.0;
    th->time -= Random() * 0.1;

    if (th->time < 0.1)
		th->time = 0.1;
		
    if (damage <= 12 && damage >= 9)
		SetMobjState(th, S_BLOOD2);
    else if (damage < 9)
		SetMobjState(th, S_BLOOD3);
#endif
}


//==========================================================================
//
//	P_ExplodeMissile
//
//==========================================================================

void P_ExplodeMissile(mobj_t* mo)
{
    mo->velocity.x = mo->velocity.y = mo->velocity.z = 0.0;

    SetMobjState(mo, mo->deathstate);

    mo->time -= Random() * 0.1;

    if (mo->time < 0.1)
		mo->time = 0.1;

    mo->flags &= ~(MF_MISSILE|MF_BOUNCE);

    if (mo->sound_death)
		StartSound(mo, mo->sound_death, CHAN_VOICE);

	if (mo->deathstate != S_EXPLODE1 && (mo->effects & EF_DLIGHT_MASK))
	{
		MSG_Select(MSG_SV_DATAGRAM, NULL);
		MSG_WriteByte(svc_explosion2);
		MSG_WriteByte(mo->effects & EF_DLIGHT_MASK);
		MSG_WriteShort(ftoi(mo->origin.x));
		MSG_WriteShort(ftoi(mo->origin.y));
		MSG_WriteShort(ftoi(mo->origin.z));
		mo->effects &= ~EF_DLIGHT_MASK;
	}
	mo->effects &= ~EF_ROCKET;
}

//==========================================================================
//
//  CheckMissileSpawn
//
//	Moves the missile forward a bit and possibly explodes it right there.
//
//==========================================================================

void CheckMissileSpawn(mobj_t* th)
{
    th->time -= Random() * 0.1;
    if (th->time < 0.1)
		th->time = 0.1;
    
    // move a little forward so an angle can
    // be computed if it immediately explodes
	vma(th->origin, th->velocity, frametime / 2.0, th->origin);

    if (!P_TryMove(th, th->origin.x, th->origin.y))
		P_ExplodeMissile(th);
}

//==========================================================================
//
//  SpawnMissile
//
//==========================================================================

mobj_t* SpawnMissile(mobj_t* source, mobj_t* dest, int type)
{
    mobj_t*		th;
	TVec		dir;

    th = P_SpawnMobj(source->origin.x, source->origin.y, source->origin.z + 32.0, type);
    
    if (th->sound_sight)
		StartSound(th, th->sound_sight, CHAN_VOICE);

    th->target = source;	// where it came from

	vsub(dest->origin, source->origin, dir);
    // fuzzy player
    if (dest->translucency)
	{
		VectorRotateAroundZ(&dir, (P_Random() - P_Random()) << 20);
	}
	vnorm(dir);
    vscale(dir, th->speed, th->velocity);

    VectorAngles(&dir, &th->angles);

    CheckMissileSpawn(th);
	
    return th;
}

//==========================================================================
//
//	KillMobj
//
//==========================================================================

void KillMobj(mobj_t* source,mobj_t* target)
{
    int		item;
    mobj_t*	mo;
	
    target->flags &= ~(MF_SHOOTABLE|MF_FLOAT|MF_SKULLFLY);

    if (target->type != MT_SKULL)
		target->flags &= ~MF_NOGRAVITY;

    target->flags |= MF_CORPSE|MF_DROPOFF;
    target->height /= 4.0;

    if (source && source->player)
    {
		// count for intermission
		if (target->flags & MF_COUNTKILL)
		    source->player->killcount++;

		if (target->player)
	    	source->player->frags[P_GetPlayerNum(target->player)]++;
    }
    else if (!netgame && (target->flags & MF_COUNTKILL))
    {
		// count all monster deaths,
		// even those caused by other monsters
		players[0].killcount++;
    }
    
    if (target->player)
    {
		// count environment kills against you
		if (!source)
	    	target->player->frags[P_GetPlayerNum(target->player)]++;
			
		target->flags &= ~MF_SOLID;
		target->player->playerstate = PST_DEAD;
		DropWeapon(target->player);
#ifdef FIXME
		if (target->player == &players[consoleplayer] && automapactive)
		{
		    // don't die in auto map,
	    	// switch view prior to dying
		    AM_Stop();
		}
#endif
    }

    if (target->health < target->gibshealth && target->xdeathstate)
    {
		SetMobjState(target, target->xdeathstate);
    }
    else
	{
		SetMobjState(target, target->deathstate);
	}
    target->time -= Random() * 0.1;

    if (target->time < 0.1)
		target->time = 0.1;
		

    // Drop stuff.
    // This determines the kind of object spawned
    // during the death frame of a thing.
    switch (target->type)
    {
      case MT_WOLFSS:
      case MT_POSSESSED:
		item = MT_CLIP;
		break;
	
      case MT_SHOTGUY:
		item = MT_SHOTGUN;
		break;
	
      case MT_CHAINGUY:
		item = MT_CHAINGUN;
		break;
	
      default:
		return;
    }

    mo = P_SpawnMobj(target->origin.x, target->origin.y, target->floorz, item);
    mo->flags |= MF_DROPPED;	// special versions of items
}

//==========================================================================
//
//  DamageMobj
//
//	Damages both enemies and players.
//	"inflictor" is the thing that caused the damage, creature or missile,
// can be NULL (slime, etc).
//	"source" is the thing to target after taking damage, creature or NULL.
//	Source and inflictor are the same for melee attacks. Source can be NULL
// for slime, barrel explosions and other environmental stuff.
//
//==========================================================================

void DamageMobj(mobj_t* target, mobj_t* inflictor, mobj_t* source, int damage)
{
    int			saved;
    player_t*	player;
	
    if (!(target->flags & MF_SHOOTABLE))
		return;	// shouldn't happen...
		
    if (target->health <= 0)
		return;

    if (target->flags & MF_SKULLFLY)
    {
		target->velocity = vector(0.0, 0.0, 0.0);
    }
	
    player = target->player;
    if (player && gameskill == sk_baby)
		damage >>= 1; 	// take half damage in trainer mode
		
    // Some close combat weapons should not
    // inflict thrust and push the victim out of reach,
    // thus kick away unless using the chainsaw.
    if (inflictor && !(target->flags & MF_NOCLIP) &&
    	(!source || !source->player ||
	    	source->player->readyweapon != wp_chainsaw))
    {
		target->velocity += (500.0 * itof(damage) / target->mass) *
			Normalize(MobjCenter(target) - MobjCenter(inflictor));
    }
    
    // player specific
    if (player)
    {
		// end of game hell hack
		if (target->subsector->sector->special == 11
		    && damage >= target->health)
		{
		    damage = target->health - 1;
		}
	

		// Below certain threshold,
		// ignore damage in GOD mode, or with INVUL power.
		if (damage < 1000
		     && ((player->cheats & CF_GODMODE)
			  || player->powers[pw_invulnerability]))
		{
		    return;
		}
	
		if (player->armortype)
		{
		    if (player->armortype == 1)
				saved = damage/3;
		    else
				saved = damage/2;
	    
		    if (player->armorpoints <= saved)
		    {
				// armor is used up
				saved = player->armorpoints;
				player->armortype = 0;
		    }
		    player->armorpoints -= saved;
		    damage -= saved;
		}
		player->health -= damage; 	// mirror mobj health here for Dave
		if (player->health < 0)
		    player->health = 0;
	
		player->attacker = source;
		player->damagecount += damage;	// add damage after armor / invuln

		if (player->damagecount > 100)
		    player->damagecount = 100;	// teleport stomp does 10k points...
    }
    
    // do the damage	
    target->health -= damage;	
    if (target->health <= 0)
    {
		KillMobj(source, target);
		return;
    }

    if ((P_Random() < target->painchance)
		 && !(target->flags & MF_SKULLFLY) )
    {
		target->flags |= MF_JUSTHIT;	// fight back!
		SetMobjState(target, target->painstate);
    }
			
    target->reactiontime = 0;		// we're awake now...	

    if ((!target->threshold || target->type == MT_VILE)
		&& source && source != target
		&& source->type != MT_VILE)
    {
		// if not intent on another player,
		// chase after this one
		target->target = source;
		target->threshold = BASETHRESHOLD;
		if (target->statenum == target->spawnstate
		    && target->seestate != S_NULL)
		{
		    SetMobjState(target, target->seestate);
		}
    }
			
}

//==========================================================================
//
//	P_RemoveMobj
//
//==========================================================================

void P_RemoveMobj(mobj_t* mobj)
{
    if ((mobj->flags & MF_SPECIAL) && !(mobj->flags & MF_DROPPED)
		&& (mobj->type != MT_INV) && (mobj->type != MT_INS))
    {
		CopyMThing(&mobj->spawnpoint, &itemrespawnque[iquehead]);
		itemrespawntime[iquehead] = level->tictime;
		iquehead = (iquehead + 1) & (ITEMQUESIZE - 1);

		// lose one off the end?
		if (iquehead == iquetail)
	    	iquetail = (iquetail + 1) & (ITEMQUESIZE - 1);
    }

    // free block
    RemoveMobjThinker(mobj);
}

//==========================================================================
//
//	P_RespawnSpecials
//
//==========================================================================

void P_RespawnSpecials(void)
{
    float			x;
    float			y;
    float			z;
    
    mobj_t*			mo;
    mthing_t*		mthing;
    
    int				i;

    // only respawn items in deathmatch
    if ((deathmatch != 2) && (deathmatch != 3))
		return;	//

    // nothing left to respawn?
    if (iquehead == iquetail)
		return;

    // wait at least 30 seconds
    if (level->tictime - itemrespawntime[iquetail] < 30*35)
		return;

    mthing = &itemrespawnque[iquetail];
	
    x = mthing->x;
    y = mthing->y;
	  
    // spawn a teleport fog at the new spot
    mo = P_SpawnMobj(x, y, ONFLOORZ, MT_IFOG);
	StartSoundName(mo, "ItemRespawn", CHAN_ITEM);

    // find which type to spawn
    for (i = 0; i < num_mobj_types; i++)
    {
		if (mthing->type == mobjinfo[i].doomednum)
	    	break;
    }
    
    // spawn it
#ifdef FIXME
    if (mobjinfo[i].flags & MF_SPAWNCEILING)
		z = ONCEILINGZ;
    else
#endif
		z = ONFLOORZ;

    mo = P_SpawnMobj(x, y, z, i);
    CopyMThing(mthing, &mo->spawnpoint);
    mo->angles.yaw = ANG45 * (mthing->angle / 45);

    // pull it from the que
    iquetail = (iquetail + 1) & (ITEMQUESIZE - 1);
}

//==========================================================================
//
//	P_NightmareRespawn
//
//==========================================================================

void P_NightmareRespawn(mobj_t* mobj)
{
    float			x;
    float			y;
    float			z;
    mobj_t*			mo;
    mthing_t*		mthing;
		
    x = mobj->spawnpoint.x;
    y = mobj->spawnpoint.y;

    // somthing is occupying it's position?
    if (!P_CheckPosition(mobj, x, y))
		return;	// no respwan

    // spawn a teleport fog at old spot
    // because of removal of the body?
    mo = P_SpawnMobj(mobj->origin.x, mobj->origin.y, ONFLOORZ, MT_TFOG);

    // initiate teleport sound
    StartSoundName(mo, "Teleport", CHAN_BODY);

    // spawn a teleport fog at the new spot
    mo = P_SpawnMobj(x, y, ONFLOORZ, MT_TFOG);

    StartSoundName(mo, "Teleport", CHAN_BODY);

    // spawn the new monster
    mthing = &mobj->spawnpoint;
	
    // spawn it
#ifdef FIXME
    if (mobj->info->flags & MF_SPAWNCEILING)
		z = ONCEILINGZ;
    else
#endif
		z = ONFLOORZ;

    // inherit attributes from deceased one
    mo = P_SpawnMobj(x, y, z, mobj->type);
    CopyMThing(&mobj->spawnpoint, &mo->spawnpoint);
    mo->angles.yaw = ANG45 * (mthing->angle / 45);

    if (mthing->options & MTF_AMBUSH)
		mo->flags |= MF_AMBUSH;

    mo->reactiontime = 18;
	
    // remove the old monster,
    P_RemoveMobj(mobj);
}

//==========================================================================
//
//	CanActivateCross
//
//==========================================================================

int CanActivateCross(mobj_t* thing)
{
	switch (thing->type)
	{
	 case MT_ROCKET:
	 case MT_PLASMA:
	 case MT_BFG:
	 case MT_TROOPSHOT:
	 case MT_HEADSHOT:
	 case MT_BRUISERSHOT:
	    return false;
	}
	return true;
}

//**************************************************************************
//
//		NOISE ALERT
//
//**************************************************************************

mobj_t*		soundtarget;

//==========================================================================
//
//  P_RecursiveSound
//
//	Called by P_NoiseAlert. Recursively traverse adjacent sectors, sound
// blocking lines cut off traversal.
//
//==========================================================================

void P_RecursiveSound(sector_t* sec, int soundblocks)
{
    int			i;
    line_t*		check;
    sector_t*	other;
	
    // wake up all monsters in this sector
    if (sec->validcount == *validcount &&
    	sec->soundtraversed <= soundblocks + 1)
    {
		return;		// already flooded
    }
    
    sec->validcount = *validcount;
    sec->soundtraversed = soundblocks + 1;
    sec->soundtarget = soundtarget;
	
    for (i=0; i<sec->linecount; i++)
    {
		check = sec->lines[i];
		if (!(check->flags & ML_TWOSIDED))
		    continue;
	
		if (!LineOpenings(check, *check->v1))
		{
			if (!LineOpenings(check, *check->v2))
			    continue;	// closed door
		}
	
		if (level->sides[check->sidenum[0]].sector == sec)
		    other = level->sides[check->sidenum[1]].sector;
		else
		    other = level->sides[check->sidenum[0]].sector;
	
		if (check->flags & ML_SOUNDBLOCK)
		{
		    if (!soundblocks)
				P_RecursiveSound(other, 1);
		}
		else
		    P_RecursiveSound(other, soundblocks);
    }
}

//==========================================================================
//
//	P_NoiseAlert
//
//	If a monster yells at a player, it will alert other monsters to the
// player.
//
//==========================================================================

void P_NoiseAlert(mobj_t* target, mobj_t* emmiter)
{
    soundtarget = target;
    (*validcount)++;
    P_RecursiveSound(emmiter->subsector->sector, 0);
}

//**************************************************************************
//
//	$Log$
//	Revision 1.4  2001/08/29 17:42:13  dj_jl
//	Added sound channel
//
//	Revision 1.3  2001/07/31 16:59:30  dj_jl
//	Set model when spawning object
//
//	Revision 1.2  2001/07/27 14:27:51  dj_jl
//	Update with Id-s and Log-s, some fixes
//
//**************************************************************************
