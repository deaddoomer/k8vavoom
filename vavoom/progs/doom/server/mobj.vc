//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**    Moving object handling.
//**    Mobj spawn, damage, kill, set state functions
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

#define ITEMQUESIZE		128

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

void SetupPsprites(player_t * player);
void DropWeapon(player_t * player);
void P_SpawnPlayer(mthing_t * mthing);
void P_NightmareRespawn(mobj_t * mobj);
void P_ExplodeMissile(mobj_t * mo);
boolean P_TryMove(mobj_t * thing, float x, float y);

// DATA DECLARATIONS -------------------------------------------------------

mthing_t itemrespawnque[ITEMQUESIZE];
int itemrespawntime[ITEMQUESIZE];
int iquehead;
int iquetail;

// CODE --------------------------------------------------------------------

//==========================================================================
//==========================================================================
//
//  GAME SPAWN FUNCTIONS
//
//==========================================================================
//==========================================================================

//==========================================================================
//
//  SetOrigin
//
//==========================================================================

void SetOrigin(mobj_t * mobj, TVec origin)
{
	mobj->Origin = origin;

	// set subsector and/or block links
	P_SetThingPosition(*mobj);

	if (origin.z == ONFLOORZ)
	{
		mobj->Origin.z = mobj->FloorZ;
	}
	else if (origin.z == ONCEILINGZ)
	{
		mobj->Origin.z = mobj->CeilingZ - mobj->Height;
	}
}

//==========================================================================
//
//  CopyMThing
//
//==========================================================================

void CopyMThing(mthing_t * from, mthing_t * to)
{
	to->tid = from->tid;
	to->x = from->x;
	to->y = from->y;
	to->height = from->height;
	to->angle = from->angle;
	to->type = from->type;
	to->options = from->options;
	to->special = from->special;
	to->arg1 = from->arg1;
	to->arg2 = from->arg2;
	to->arg3 = from->arg3;
	to->arg4 = from->arg4;
	to->arg5 = from->arg5;
}

//==========================================================================
//
//	Actor::OnMapSpawn
//
//==========================================================================

void Actor::OnMapSpawn(mthing_t * mthing)
{
	state_t *st;

	SpawnHealth = Health;
	bCheckLineBlocking = false;
	bCheckLineBlockMonsters = false;
	if (!bMissile)
	{
		bCheckLineBlocking = true;
		if (Class != PlayerPawn)
		{
			bCheckLineBlockMonsters = true;
		}
	}
	//	DeHackEd crap
	if (bNoClip)
	{
		bColideWithWorld = false;
		bColideWithThings = false;
	}

	if (gameskill == sk_nightmare)
	{
		ReactionCount = 0;
	}

	LastLook = P_Random() % MAXPLAYERS;
	// do not set the state with SetState,
	// because action routines can not be called yet
	st = &states[SpawnState];
	StateTime = st->time;
	SpriteIndex = st->sprite;
	SpriteName = sprite_names[st->sprite];
	SpriteFrame = st->frame;
	ModelIndex = st->model_index;
	ModelFrame = st->model_frame;
	StateNum = st->statenum;
	NextState = st->nextstate;

	if (mthing)
	{
		float x;
		float y;
		float z;

		CopyMThing(mthing, &SpawnPoint);

		x = mthing->x;
		y = mthing->y;
		if (bSpawnCeiling)
			z = ONCEILINGZ;
		else
			z = ONFLOORZ;
		SetOrigin(this, vector(x, y, z));
		if (z == ONFLOORZ)
		{
			Origin.z += mthing->height;
		}
		else if (z == ONCEILINGZ)
		{
			Origin.z -= mthing->height;
		}
		P_SetThingPosition(self);

		TID = mthing->tid;
		Special = mthing->special;
		Args[0] = mthing->arg1;
		Args[1] = mthing->arg2;
		Args[2] = mthing->arg3;
		Args[3] = mthing->arg4;
		Args[4] = mthing->arg5;
		if (StateTime > 0.0)
			StateTime = 0.1 + Random() * StateTime;
		if (bCountKill)
			level->totalkills++;
		if (bCountItem)
			level->totalitems++;

		Angles.yaw = itof(45 * (mthing->angle / 45));
		if (mthing->options & MTF_AMBUSH)
		{
			bAmbush = true;
		}
		if (mthing->options & MTF_DORMANT)
		{
			bDormant = true;
			StateTime = -1.0;
		}
	}
	else
	{
		SetOrigin(this, Origin);
	}
}

//==========================================================================
//
//  P_SpawnMobj
//
//==========================================================================

mobj_t *P_SpawnMobj(float x, float y, float z, classid type)
{
	mobj_t *mobj;

	mobj = &Actor(NewMobjThinker(type));
	mobj->Origin = vector(x, y, z);
	mobj->OnMapSpawn(NULL);
	return mobj;
}

//==========================================================================
//
//  P_SpawnMapThing
//
//  The fields of the mapthing should already be in host byte order.
//
//==========================================================================

void P_SpawnMapThing(mthing_t * mthing, boolean spawn_thinkers)
{
	int i;
	int bit;
	mobj_t *mobj;
	int spawnMask;

#ifndef DOOM2
	switch (mthing->type)
	{
	case 68:	// Arachnotron
	case 64:	// Archvile
	case 88:	// Boss Brain
	case 89:	// Boss Shooter
	case 69:	// Hell Knight
	case 67:	// Mancubus
	case 71:	// Pain Elemental
	case 65:	// Former Human Commando
	case 66:	// Revenant
	case 84:	// Wolf SS
		NotDoom2();
	}
#endif

	if (mthing->type <= 0)
		return;

	// count deathmatch start positions
	if (mthing->type == 11)
	{
		if (level->numdeathmatchstarts < MAXDEATHMATCHSTARTS)
		{
			CopyMThing(mthing,
				&level->deathmatchstarts[level->numdeathmatchstarts]);
			level->numdeathmatchstarts++;
		}
		return;
	}

	if (mthing->type == PO_SPAWN_TYPE || mthing->type == PO_SPAWNCRUSH_TYPE)
	{
		// Polyobj StartSpot Pt.
		SpawnPolyobj(mthing->x, mthing->y, mthing->angle,
			(mthing->type == PO_SPAWNCRUSH_TYPE));
		return;
	}
	if (mthing->type == PO_ANCHOR_TYPE)
	{
		// Polyobj Anchor Pt.
		AddAnchorPoint(mthing->x, mthing->y, mthing->angle);
		return;
	}

	// check for players specially
	if (mthing->type <= 4)
	{
		// save spots for respawning in network games
		CopyMThing(mthing, &level->playerstarts[mthing->arg1 * MAXPLAYERS +
			mthing->type - 1]);
		return;
	}

	//  Don't spawn, if we are loading a savegame
	if (!spawn_thinkers)
	{
		return;
	}

	// Check current game type with spawn flags
	if (netgame == false)
	{
		spawnMask = MTF_GSINGLE;
	}
	else if (deathmatch)
	{
		spawnMask = MTF_GDEATHMATCH;
	}
	else
	{
		spawnMask = MTF_GCOOP;
	}
	if (!(mthing->options & spawnMask))
	{
		return;
	}

	// check for apropriate skill level
	if (gameskill == sk_baby)
		bit = 1;
	else if (gameskill == sk_nightmare)
		bit = 4;
	else
		bit = 1 << (gameskill - 1);

	if (!(mthing->options & bit))
		return;

	// find which type to spawn
	for (i = 0; i < num_mobj_types; i++)
	{
		if (mthing->type == mobjinfo[i].doomednum)
		{
			// spawn it
			mobj = &Actor(NewMobjThinker(mobjinfo[i].class_id));
			mobj->OnMapSpawn(mthing);
			return;
		}
	}
	dprint("P_SpawnMapThing: Unknown type %d at (%f, %f)\n",
		mthing->type, mthing->x, mthing->y);
}

//==========================================================================
//
//  SpawnPuff
//
//==========================================================================

void SpawnPuff(float x, float y, float z)
{
#if 1
	MSG_Select(MSG_SV_DATAGRAM);
	MSG_WriteByte(svc_gun_shot);
	MSG_WriteShort(ftoi(x));
	MSG_WriteShort(ftoi(y));
	MSG_WriteShort(ftoi(z));
#else
	mobj_t *th;

	z += (Random() - Random()) * 4.0;

	th = P_SpawnMobj(x, y, z, MT_PUFF);
	th->Velocity.z = 1.0 * 35.0;
	th->time -= Random() * 0.1;

	if (th->time < 0.1)
		th->time = 0.1;

#ifdef FIXME
	// don't make punches spark on the wall
	if (attackrange == MELEERANGE)
		th->SetState(S_PUFF3);
#endif
#endif
}

//==========================================================================
//
//  P_SpawnBlood
// 
//==========================================================================

void P_SpawnBlood(float x, float y, float z, int damage)
{
#if 0
	mobj_t *th;
#endif

	MSG_Select(MSG_SV_DATAGRAM);
	MSG_WriteByte(svc_blood);
	MSG_WriteShort(ftoi(x));
	MSG_WriteShort(ftoi(y));
	MSG_WriteShort(ftoi(z));
	MSG_WriteByte(damage > 255 ? 255 : damage);
#if 0
	z += (Random() - Random()) * 4.0;
	th = P_SpawnMobj(x, y, z, MT_BLOOD);
	th->Velocity.z = 2.0 * 35.0;
	th->time -= Random() * 0.1;

	if (th->time < 0.1)
		th->time = 0.1;

	if (damage <= 12 && damage >= 9)
		th->SetState(S_BLOOD2);
	else if (damage < 9)
		th->SetState(S_BLOOD3);
#endif
}

//==========================================================================
//
//  P_ExplodeMissile
//
//==========================================================================

void P_ExplodeMissile(mobj_t * mo)
{
	mo->Velocity = vector(0.0, 0.0, 0.0);

	mo->SetState(mo->DeathState);

	mo->StateTime -= Random() * 0.1;

	if (mo->StateTime < 0.1)
		mo->StateTime = 0.1;

	mo->bMissile = false;

	if (mo->DeathSound)
		mo->PlaySound(mo->DeathSound, CHAN_VOICE);

	if (mo->DeathState != S_EXPLODE1 && (mo->Effects & EF_DLIGHT_MASK))
	{
		MSG_Select(MSG_SV_DATAGRAM);
		MSG_WriteByte(svc_explosion2);
		MSG_WriteByte(mo->Effects & EF_DLIGHT_MASK);
		MSG_WriteShort(ftoi(mo->Origin.x));
		MSG_WriteShort(ftoi(mo->Origin.y));
		MSG_WriteShort(ftoi(mo->Origin.z));
		mo->Effects &= ~EF_DLIGHT_MASK;
	}
	mo->Effects &= ~EF_ROCKET;
}

//==========================================================================
//
//  CheckMissileSpawn
//
//  Moves the missile forward a bit and possibly explodes it right there.
//
//==========================================================================

void CheckMissileSpawn(mobj_t * th)
{
	th->StateTime -= Random() * 0.1;
	if (th->StateTime < 0.1)
		th->StateTime = 0.1;

	// move a little forward so an angle can
	// be computed if it immediately explodes
	th->Origin = th->Origin + th->Velocity * 0.0142857143;

	if (!P_TryMove(th, th->Origin.x, th->Origin.y))
		P_ExplodeMissile(th);
}

//==========================================================================
//
//  SpawnMissile
//
//==========================================================================

mobj_t *SpawnMissile(mobj_t * source, mobj_t * dest, classid type)
{
	mobj_t *th;
	TVec dir;

	th =
		P_SpawnMobj(source->Origin.x, source->Origin.y,
		source->Origin.z + 32.0, type);

	if (th->SightSound)
		th->PlaySound(th->SightSound, CHAN_VOICE);

	th->Owner = *source;	// where it came from

	dir = dest->Origin - source->Origin;
	// fuzzy player
	if (dest->Translucency)
	{
		VectorRotateAroundZ(&dir, (Random() - Random()) * 45.0 / 2.0);
	}
	dir = Normalize(dir);
	th->Velocity = dir * th->Speed;

	VectorAngles(&dir, &th->Angles);

	CheckMissileSpawn(th);

	return th;
}

//==========================================================================
//
//  KillMobj
//
//==========================================================================

void KillMobj(mobj_t * source, mobj_t * target)
{
	classid item;
	mobj_t *mo;

	target->bShootable = false;
	target->bFloat = false;
	target->bSkullFly = false;

	if (target->Class != LostSoul)
		target->bNoGravity = false;

	target->bDropOff = true;
	target->bCorpse = true;
	target->Height /= 4.0;

	if (source && source->bIsPlayer)
	{
		// count for intermission
		if (target->bCountKill)
			source->Player->KillCount++;

		if (target->bIsPlayer)
		{
			if (source->Player->bIsBot)
			{
				source->Player->Bot.Killed(*target);
			}

			if (target->Player->bIsBot)
			{
				target->Player->Bot.Died(*source);
			}

			source->Player->Frags[P_GetPlayerNum(target->Player)]++;
		}
	}
	else if (!netgame && target->bCountKill)
	{
		// count all monster deaths,
		// even those caused by other monsters
		players[0].KillCount++;
	}

	if (target->bIsPlayer)
	{
		// count environment kills against you
		if (!source)
			target->Player->Frags[P_GetPlayerNum(target->Player)]++;

		target->bSolid = false;
		target->Player->PlayerState = PST_DEAD;
		DropWeapon(target->Player);
#ifdef FIXME
		if (target->Player == &players[consoleplayer] && automapactive)
		{
			// don't die in auto map,
			// switch view prior to dying
			AM_Stop();
		}
#endif
	}

	if (target->Health < target->GibsHealth && target->GibsDeathState)
	{
		if (target->bFixedModel)
		{
			target->bFixedModel = false;
			target->ModelSkinNum = 0;
		}
		target->SetState(target->GibsDeathState);
	}
	else
	{
		target->SetState(target->DeathState);
	}
	target->StateTime -= Random() * 0.1;

	if (target->StateTime < 0.1)
		target->StateTime = 0.1;

	// Drop stuff.
	// This determines the kind of object spawned
	// during the death frame of a thing.
	switch (target->Class)
	{
	case WolfSS:
	case Zombieman:
		item = ItemAmmoBulletClip;
		break;

	case ShotgunGuy:
		item = ItemWeaponShotgun;
		break;

	case ChaingunGuy:
		item = ItemWeaponChaingun;
		break;

	default:
		return;
	}

	mo = P_SpawnMobj(target->Origin.x, target->Origin.y, target->FloorZ,
		item);
	mo->bDropped = true;	// special versions of items
}

//==========================================================================
//
//	Actor::Damage
//
//  Damages both enemies and players.
//  "inflictor" is the thing that caused the damage, creature or missile,
// can be NULL (slime, etc).
//  "source" is the thing to target after taking damage, creature or NULL.
//  Source and inflictor are the same for melee attacks. Source can be NULL
// for slime, barrel explosions and other environmental stuff.
//
//==========================================================================

void Actor::Damage(Actor inflictor, Actor source, int damage)
{
	int saved;

	if (!bShootable)
		return;	// shouldn't happen...

	if (Health <= 0)
		return;

	if (bSkullFly)
	{
		Velocity = vector(0.0, 0.0, 0.0);
	}
	if (bDormant)
	{
		// Invulnerable, and won't wake up
		return;
	}

	if (bIsPlayer && gameskill == sk_baby)
		damage >>= 1;	// take half damage in trainer mode

	// Some close combat weapons should not
	// inflict thrust and push the victim out of reach,
	// thus kick away unless using the chainsaw.
	if (inflictor && bColideWithThings &&
		(!source || !source.bIsPlayer ||
			source.Player->ReadyWeapon != wp_chainsaw))
	{
		Velocity += (500.0 * itof(damage) / Mass) *
			Normalize(MobjCenter(self) - MobjCenter(inflictor));
	}

	// player specific
	if (bIsPlayer)
	{
		// end of game hell hack
		if ((Sector->special & 255) == 75 && damage >= Health)
		{
			damage = Health - 1;
		}

		// Below certain threshold,
		// ignore damage in GOD mode, or with INVUL power.
		if (damage < 1000 && ((Player->Cheats & CF_GODMODE) ||
			Player->Powers[pw_invulnerability]))
		{
			return;
		}

		if (Player->ArmorType)
		{
			if (Player->ArmorType == 1)
				saved = damage / 3;
			else
				saved = damage / 2;

			if (Player->ArmorPoints <= saved)
			{
				// armor is used up
				saved = Player->ArmorPoints;
				Player->ArmorType = 0;
			}
			Player->ArmorPoints -= saved;
			damage -= saved;
		}
		Player->Health -= damage;	// mirror mobj health here for Dave
		if (Player->Health < 0)
			Player->Health = 0;

		Player->Attacker = &source;
		Player->DamageCount += damage;	// add damage after armor / invuln

		if (Player->DamageCount > 100)
			Player->DamageCount = 100;	// teleport stomp does 10k points...
	}

	// do the damage    
	Health -= damage;
	if (Health <= 0)
	{
		KillMobj(&source, this);
		return;
	}

	if ((P_Random() < PainChance) && !bSkullFly)
	{
		bJustHit = true;	// fight back!
		SetState(PainState);
	}

	ReactionCount = 0;	// we're awake now...

	if ((!Threshold || Class == ArchVile)
		&& source && source != self && source.Class != ArchVile)
	{
		// if not intent on another player,
		// chase after this one
		Target = source;
		Threshold = BASETHRESHOLD;
		if (StateNum == SpawnState && SeeState != S_NULL)
		{
			SetState(SeeState);
		}
	}

}

//==========================================================================
//
//  P_RemoveMobj
//
//==========================================================================

void P_RemoveMobj(mobj_t * mobj)
{
	if (mobj->bSpecial && !mobj->bDropped &&
		(mobj->Class != ItemInvulnerability) &&
		(mobj->Class != ItemInvisibility))
	{
		CopyMThing(&mobj->SpawnPoint, &itemrespawnque[iquehead]);
		itemrespawntime[iquehead] = level->tictime;
		iquehead = (iquehead + 1) & (ITEMQUESIZE - 1);

		// lose one off the end?
		if (iquehead == iquetail)
			iquetail = (iquetail + 1) & (ITEMQUESIZE - 1);
	}

	// free block
	RemoveMobjThinker(*mobj);
}

//==========================================================================
//
//  P_RespawnSpecials
//
//==========================================================================

void P_RespawnSpecials(void)
{
	float x;
	float y;
	float z;

	mobj_t *mo;
	mthing_t *mthing;

	int i;

	// only respawn items in deathmatch
	if ((deathmatch != 2) && (deathmatch != 3))
		return;	//

	// nothing left to respawn?
	if (iquehead == iquetail)
		return;

	// wait at least 30 seconds
	if (level->tictime - itemrespawntime[iquetail] < 30 * 35)
		return;

	mthing = &itemrespawnque[iquetail];

	x = mthing->x;
	y = mthing->y;

	// spawn a teleport fog at the new spot
	mo = P_SpawnMobj(x, y, ONFLOORZ, ItemRespawnFog);
	mo->PlaySound('ItemRespawn', CHAN_ITEM);

	// find which type to spawn
	for (i = 0; i < num_mobj_types; i++)
	{
		if (mthing->type == mobjinfo[i].doomednum)
			break;
	}

	// spawn it
#ifdef FIXME
	if (mobjinfo[i].Flags & MF_SPAWNCEILING)
		z = ONCEILINGZ;
	else
#endif
		z = ONFLOORZ;

	mo = P_SpawnMobj(x, y, z, mobjinfo[i].class_id);
	CopyMThing(mthing, &mo->SpawnPoint);
	mo->Angles.yaw = itof(45 * (mthing->angle / 45));

	// pull it from the que
	iquetail = (iquetail + 1) & (ITEMQUESIZE - 1);
}

//==========================================================================
//
//  P_NightmareRespawn
//
//==========================================================================

void P_NightmareRespawn(mobj_t * mobj)
{
	float x;
	float y;
	float z;
	mobj_t *mo;
	mthing_t *mthing;

	x = mobj->SpawnPoint.x;
	y = mobj->SpawnPoint.y;

	// somthing is occupying it's position?
	if (!mobj->CheckPosition(vector(x, y, ONFLOORZ)))
		return;	// no respwan

	// spawn a teleport fog at old spot
	// because of removal of the body?
	mo = P_SpawnMobj(mobj->Origin.x, mobj->Origin.y, ONFLOORZ, TeleportFog);

	// initiate teleport sound
	mo->PlaySound('Teleport', CHAN_BODY);

	// spawn a teleport fog at the new spot
	mo = P_SpawnMobj(x, y, ONFLOORZ, TeleportFog);

	mo->PlaySound('Teleport', CHAN_BODY);

	// spawn the new monster
	mthing = &mobj->SpawnPoint;

	// spawn it
#ifdef FIXME
	if (mobj->info->Flags & MF_SPAWNCEILING)
		z = ONCEILINGZ;
	else
#endif
		z = ONFLOORZ;

	// inherit attributes from deceased one
	mo = P_SpawnMobj(x, y, z, mobj->Class);
	CopyMThing(&mobj->SpawnPoint, &mo->SpawnPoint);
	mo->Angles.yaw = itof(45 * (mthing->angle / 45));

	if (mthing->options & MTF_AMBUSH)
		mo->bAmbush = true;

	mo->ReactionCount = 18;

	// remove the old monster,
	P_RemoveMobj(mobj);
}

//==========================================================================
//
//  CanActivateCross
//
//==========================================================================

int CanActivateCross(mobj_t * thing)
{
	switch (thing->Class)
	{
	case Rocket:
	case PlasmaShot:
	case BFGShot:
	case ImpMissile:
	case CacodemonMissile:
	case BruiserShot:
		return false;
	}
	return true;
}

//**************************************************************************
//
//      NOISE ALERT
//
//**************************************************************************

mobj_t *soundtarget;

//==========================================================================
//
//  P_RecursiveSound
//
//  Called by P_NoiseAlert. Recursively traverse adjacent sectors, sound
// blocking lines cut off traversal.
//
//==========================================================================

void P_RecursiveSound(sector_t * sec, int soundblocks)
{
	int i;
	line_t *check;
	sector_t *other;

	// wake up all monsters in this sector
	if (sec->validcount == *validcount &&
		sec->soundtraversed <= soundblocks + 1)
	{
		return;	// already flooded
	}

	sec->validcount = *validcount;
	sec->soundtraversed = soundblocks + 1;
	sec->SoundTarget = *soundtarget;

	for (i = 0; i < sec->linecount; i++)
	{
		check = sec->lines[i];
		if (!(check->flags & ML_TWOSIDED))
			continue;

		if (!LineOpenings(check, *check->v1))
		{
			if (!LineOpenings(check, *check->v2))
				continue;	// closed door
		}

		if (level->sides[check->sidenum[0]].sector == sec)
			other = level->sides[check->sidenum[1]].sector;
		else
			other = level->sides[check->sidenum[0]].sector;

		if (check->flags & ML_SOUNDBLOCK)
		{
			if (!soundblocks)
				P_RecursiveSound(other, 1);
		}
		else
			P_RecursiveSound(other, soundblocks);
	}
}

//==========================================================================
//
//  P_NoiseAlert
//
//  If a monster yells at a player, it will alert other monsters to the
// player.
//
//==========================================================================

void P_NoiseAlert(mobj_t * target, mobj_t * emmiter)
{
	soundtarget = target;
	(*validcount)++;
	P_RecursiveSound(emmiter->Sector, 0);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.36  2002/03/04 18:31:35  dj_jl
//  Replaced bNoClip with two seperate flags, beautification.
//
//  Revision 1.35  2002/03/02 17:41:12  dj_jl
//  Renamed Enemy to Target. Beautification.
//
//  Revision 1.34  2002/02/26 17:49:47  dj_jl
//  no message
//
//  Revision 1.33  2002/02/22 18:00:09  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.32  2002/02/16 16:26:55  dj_jl
//  Removed precalculated sound IDs
//
//  Revision 1.31  2002/02/14 19:20:57  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.30  2002/02/09 18:13:46  dj_jl
//  Added flags that determines what line blocking flags to check
//
//  Revision 1.29  2002/02/07 18:50:08  dj_jl
//  Made CheckPosition shared.
//
//  Revision 1.28  2002/02/06 17:28:51  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.27  2002/02/02 19:17:25  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.26  2002/01/29 18:11:23  dj_jl
//  Added dormant things
//
//  Revision 1.25  2002/01/28 18:50:18  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.24  2002/01/25 18:04:33  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.23  2002/01/24 18:19:25  dj_jl
//  Split common class Entity, made SetMobjState an Entity function
//
//  Revision 1.22  2002/01/17 18:15:53  dj_jl
//  Renamed all map object classes
//
//  Revision 1.21  2002/01/15 18:26:59  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.20  2002/01/12 18:00:47  dj_jl
//  Sound names initialized as names
//
//  Revision 1.19  2002/01/11 18:19:40  dj_jl
//  Started to use names in progs
//
//  Revision 1.18  2002/01/07 12:21:10  dj_jl
//  Changed copyright year
//
//  Revision 1.17  2001/12/27 17:52:22  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.16  2001/12/18 18:35:26  dj_jl
//  Added polyobjs
//
//  Revision 1.15  2001/12/12 18:57:40  dj_jl
//  State functions now are methods of Actor and Weapon classes
//
//  Revision 1.14  2001/12/04 18:36:42  dj_jl
//  Bots, directly from SkullTag!
//
//  Revision 1.13  2001/12/01 18:14:08  dj_jl
//  Changed MSG_Select, beautification
//
//  Revision 1.12  2001/11/02 18:42:08  dj_jl
//  Damage method
//
//  Revision 1.11  2001/10/22 17:23:11  dj_jl
//  Floatification of angles
//
//  Revision 1.10  2001/10/18 17:39:33  dj_jl
//  A lots of changes for Alpha 2
//
//  Revision 1.9  2001/10/09 17:41:16  dj_jl
//  Beautification
//
//  Revision 1.8  2001/10/02 17:42:37  dj_jl
//  Possibility to declare function's code inside class declaration
//
//  Revision 1.7  2001/09/27 17:08:19  dj_jl
//  Removed spawn functions, added mobj classes
//
//  Revision 1.6  2001/09/24 17:24:09  dj_jl
//  Beautification
//
//  Revision 1.5  2001/08/31 17:17:23  dj_jl
//  Removed vector macros
//  
//  Revision 1.4  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.3  2001/07/31 16:59:30  dj_jl
//  Set model when spawning object
//
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
