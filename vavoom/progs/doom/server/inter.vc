//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**    GET STUFF
//**
//**************************************************************************

#define BONUSADD	6

Actor Spawn(classid type, TVec AOrigin);

//==========================================================================
//
//	Actor::GiveAmmo
//
//	Returns false if the ammo can't be picked up at all
//
//==========================================================================

boolean Actor::GiveAmmo(int ammo, int num)
{
	int oldammo;
	int max;

	if (ammo == am_noammo)
		return false;

	if (ammo < 0 || ammo > NUMAMMO)
		Error("P_GiveAmmo: bad type %i", ammo);

	max = Player->MaxAmmo[ammo];
	if (Player->Ammo[ammo] == max)
		return false;

	if (gameskill == sk_baby || gameskill == sk_nightmare)
	{
		// give double ammo in trainer mode,
		// you'll need in nightmare
		num <<= 1;
	}

	oldammo = Player->Ammo[ammo];
	Player->Ammo[ammo] += num;

	if (Player->Ammo[ammo] > max)
		Player->Ammo[ammo] = max;

	// If non zero ammo, 
	// don't change up weapons,
	// player was lower on purpose.
	if (oldammo)
		return true;

	// We were down to zero,
	// so select a new weapon.
	// Preferences are not user selectable.
	switch (ammo)
	{
	case am_clip:
		if (Player->ReadyWeapon == wp_fist)
		{
			if (Player->WeaponOwned[wp_chaingun])
				Player->PendingWeapon = wp_chaingun;
			else
				Player->PendingWeapon = wp_pistol;
		}
		break;

	case am_shell:
		if (Player->ReadyWeapon == wp_fist
			|| Player->ReadyWeapon == wp_pistol)
		{
			if (Player->WeaponOwned[wp_shotgun])
				Player->PendingWeapon = wp_shotgun;
		}
		break;

	case am_cell:
		if (Player->ReadyWeapon == wp_fist
			|| Player->ReadyWeapon == wp_pistol)
		{
			if (Player->WeaponOwned[wp_plasma])
				Player->PendingWeapon = wp_plasma;
		}
		break;

	case am_misl:
		if (Player->ReadyWeapon == wp_fist)
		{
			if (Player->WeaponOwned[wp_missile])
				Player->PendingWeapon = wp_missile;
		}
	default:
		break;
	}

	return true;
}

//==========================================================================
//
//  Actor::GiveWeapon
//
//  The weapon name may have a MF_DROPPED flag ored in.
//
//==========================================================================

boolean Actor::GiveWeapon(int weapon, boolean dropped)
{
#ifdef DDF
	if (Player->WeaponOwned[weapon])
	{
		return false;
	}
	Player->WeaponOwned[weapon] = true;
	Player->PendingWeapon = weapon;
	return true;
#else
	boolean gaveammo;
	boolean gaveweapon;
	int ammoCount;

	ammoCount = clipammo[weapon_ammo_type[weapon]];
	if (netgame && (deathmatch < 2) && !dropped)
	{
		// leave placed weapons forever on net games
		if (Player->WeaponOwned[weapon])
			return false;

		Player->BonusCount += BONUSADD;
		Player->WeaponOwned[weapon] = true;

		if (deathmatch)
			GiveAmmo(weapon_ammo_type[weapon], 5 * ammoCount);
		else
			GiveAmmo(weapon_ammo_type[weapon], 2 * ammoCount);
		Player->PendingWeapon = weapon;

		PlaySound('PickupWeapon', CHAN_ITEM);
		return false;
	}

	gaveammo = false;
	if (weapon_ammo_type[weapon] != am_noammo)
	{
		// give one clip with a dropped weapon,
		// two clips with a found weapon
		if (dropped)
			gaveammo = GiveAmmo(weapon_ammo_type[weapon], 1 * ammoCount);
		else
			gaveammo = GiveAmmo(weapon_ammo_type[weapon], 2 * ammoCount);
	}

	gaveweapon = false;
	if (!Player->WeaponOwned[weapon])
	{
		gaveweapon = true;
		Player->WeaponOwned[weapon] = true;
		Player->PendingWeapon = weapon;
	}

	return (gaveweapon || gaveammo);
#endif
}

//==========================================================================
//
//	Actor::GiveBody
//
//	Returns false if the body isn't needed at all
//
//==========================================================================

boolean Actor::GiveBody(int num, int max)
{
	if (Health >= max)
	{
		return false;
	}

	Health += num;
	if (Health > max)
	{
		Health = max;
	}
	Player->Health = Health;

	return true;
}

//==========================================================================
//
//	Actor::GiveArmor
//
//	Returns false if the armor is worse than the current armor.
//
//==========================================================================

boolean Actor::GiveArmor(int armortype)
{
	int hits;

	hits = armortype * 100;
	if (Player->ArmorPoints >= hits)
		return false;	// don't pick up

	Player->ArmorType = armortype;
	Player->ArmorPoints = hits;

	return true;
}

//==========================================================================
//
//	Actor::GiveArmor2
//
//	Returns false if the armor is worse than the current armor.
//
//==========================================================================

boolean Actor::GiveArmor2(int armortype, int num, int max)
{
	if (Player->ArmorPoints >= max)
	{
		return false;	// don't pick up
	}
	Player->ArmorPoints += num;
	if (Player->ArmorPoints > max)
	{
		Player->ArmorPoints = max;
	}
	if (Player->ArmorType < armortype)
	{
		Player->ArmorType = armortype;
	}
	return true;
}

//==========================================================================
//
//	Actor::GiveCard
//
//==========================================================================

boolean Actor::GiveCard(int card)
{
	if (Player->Keys & (1 << card))
		return false;

	Player->BonusCount = BONUSADD;
	Player->Keys |= 1 << card;
	return true;
}

//==========================================================================
//
//  Actor::GiveItem
//
//==========================================================================

boolean Actor::GiveItem(int item)
{
	if (Player->Items & item)
	{
		return false;	// already got it
	}

	Player->Items |= item;
	return true;
}

//==========================================================================
//
//	Actor::GivePower
//
//==========================================================================

boolean Actor::GivePower(int power)
{
	if (power == pw_invulnerability)
	{
		Player->Powers[power] = ftoi(INVULNTIME * 35.0);
		return true;
	}

	if (power == pw_invisibility)
	{
		Player->Powers[power] = ftoi(INVISTIME * 35.0);
		Translucency = 90;
		return true;
	}

	if (power == pw_infrared)
	{
		Player->Powers[power] = ftoi(INFRATIME * 35.0);
		return true;
	}

	if (power == pw_ironfeet)
	{
		Player->Powers[power] = ftoi(IRONTIME * 35.0);
		return true;
	}

	if (power == pw_strength)
	{
		GiveBody(100, MAXHEALTH);
		Player->Powers[power] = 1;
		if (Player->ReadyWeapon != wp_fist)
			Player->PendingWeapon = wp_fist;
		return true;
	}

	if (Player->Powers[power])
		return false;	// already got it

	Player->Powers[power] = 1;
	return true;
}

//==========================================================================
//
//	Actor::GivePower2
//
//==========================================================================

boolean Actor::GivePower2(int power, float duration, float max)
{
	if (Player->Powers[power] >= ftoi(max * 35.0))
		return false;	// already got it

	Player->Powers[power] += ftoi(duration * 35.0);
	if (Player->Powers[power] >= ftoi(max * 35.0))
	{
		Player->Powers[power] = ftoi(max * 35.0);
	}

	if (power == pw_invisibility)
	{
		Translucency = 90;
	}
	if (power == pw_strength)
	{
		if (Player->ReadyWeapon != wp_fist)
			Player->PendingWeapon = wp_fist;
	}

	return true;
}

//==========================================================================
//
//	Actor::HideSpecial
//
//==========================================================================

__states__(Actor)
{
	S_DORMANT_PICKUP1('', 0, 30.0, S_DORMANT_PICKUP2)
	{
		bHidden = true;
		bSpecial = false;
	}
	S_DORMANT_PICKUP2('', 0, -1.0, S_NULL)
	{
		Actor A;

		bHidden = false;
		bSpecial = true;
		SetState(IdleState);

		// spawn a teleport fog at the new spot
		A = Spawn(ItemRespawnFog, Origin);
		A.PlaySound('ItemRespawn', CHAN_ITEM);
	}
}

void Actor::HideSpecial(void)
{
	// only respawn items in deathmatch
	if ((deathmatch == 2 || deathmatch == 3) && !bDropped && !bNoRespawn)
	{
		SetState(S_DORMANT_PICKUP1);
	}
	else
	{
		Remove();
	}
}

//==========================================================================
//
//	Actor::HandlePickup
//
//==========================================================================

boolean Actor::HandlePickup(Actor Toucher)
{
	return false;
}

//==========================================================================
//
//	Actor::TouchSpecial
//
//==========================================================================

void Actor::TouchSpecial(Actor Toucher)
{
	if (!Toucher.bPickUp)
	{
		// can't remove thing
		return;
	}
	// Dead thing touching.
	// Can happen with a sliding player corpse.
	if (Toucher.Health <= 0)
		return;

	if (!HandlePickup(Toucher))
	{
		return;
	}
#ifdef DDF
	cprint(Toucher.Player, PickupMessage);
	Toucher.PlaySound(ActiveSound, CHAN_ITEM);
#endif
	if (bCountItem)
		Toucher.Player->ItemCount++;
	HideSpecial();
	Toucher.Player->BonusCount += BONUSADD;
}

//**************************************************************************
//
//  $Log$
//  Revision 1.19  2002/06/14 15:51:20  dj_jl
//  A lots of changes, new functions etc for DDF.
//
//  Revision 1.18  2002/05/18 16:59:58  dj_jl
//  Renamed SpawnState to IdleState, other changes.
//
//  Revision 1.17  2002/03/28 18:11:24  dj_jl
//  Changed hiding of specials like in Raven games.
//
//  Revision 1.16  2002/03/20 19:07:43  dj_jl
//  Got rid of a lots of legacy, beautification.
//
//  Revision 1.15  2002/03/12 19:21:24  dj_jl
//  No need for linefeed in client-printing
//
//  Revision 1.14  2002/02/22 18:00:08  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.13  2002/02/14 19:20:57  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.12  2002/02/09 18:12:25  dj_jl
//  Replaced identifying sprite name indexes with sprite names
//
//  Revision 1.11  2002/02/06 17:28:51  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.10  2002/01/28 18:50:18  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.9  2002/01/25 18:04:33  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.8  2002/01/17 18:15:52  dj_jl
//  Renamed all map object classes
//
//  Revision 1.7  2002/01/15 18:26:59  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.6  2002/01/11 18:19:40  dj_jl
//  Started to use names in progs
//
//  Revision 1.5  2002/01/07 12:21:10  dj_jl
//  Changed copyright year
//
//  Revision 1.4  2001/09/24 17:24:09  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
