//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**    GET STUFF
//**
//**************************************************************************

#define BONUSADD	6

Actor Spawn(classid type, TVec AOrigin);

//==========================================================================
//
//	Actor::GiveAmmo
//
//	Num is the number of clip loads, not the individual count (0= 1/2 clip).
// Returns false if the ammo can't be picked up at all
//
//==========================================================================

boolean Actor::GiveAmmo(int ammo, int num)
{
	int oldammo;
	int max;

	if (ammo == am_noammo)
		return false;

	if (ammo < 0 || ammo > NUMAMMO)
		Error("P_GiveAmmo: bad type %i", ammo);

	max = Player->Backpack ? maxammo[ammo] * 2 : maxammo[ammo];
	if (Player->Ammo[ammo] == max)
		return false;

	if (num)
		num *= clipammo[ammo];
	else
		num = clipammo[ammo] / 2;

	if (gameskill == sk_baby || gameskill == sk_nightmare)
	{
		// give double ammo in trainer mode,
		// you'll need in nightmare
		num <<= 1;
	}

	oldammo = Player->Ammo[ammo];
	Player->Ammo[ammo] += num;

	if (Player->Ammo[ammo] > max)
		Player->Ammo[ammo] = max;

	// If non zero ammo, 
	// don't change up weapons,
	// player was lower on purpose.
	if (oldammo)
		return true;

	// We were down to zero,
	// so select a new weapon.
	// Preferences are not user selectable.
	switch (ammo)
	{
	case am_clip:
		if (Player->ReadyWeapon == wp_fist)
		{
			if (Player->WeaponOwned[wp_chaingun])
				Player->PendingWeapon = wp_chaingun;
			else
				Player->PendingWeapon = wp_pistol;
		}
		break;

	case am_shell:
		if (Player->ReadyWeapon == wp_fist
			|| Player->ReadyWeapon == wp_pistol)
		{
			if (Player->WeaponOwned[wp_shotgun])
				Player->PendingWeapon = wp_shotgun;
		}
		break;

	case am_cell:
		if (Player->ReadyWeapon == wp_fist
			|| Player->ReadyWeapon == wp_pistol)
		{
			if (Player->WeaponOwned[wp_plasma])
				Player->PendingWeapon = wp_plasma;
		}
		break;

	case am_misl:
		if (Player->ReadyWeapon == wp_fist)
		{
			if (Player->WeaponOwned[wp_missile])
				Player->PendingWeapon = wp_missile;
		}
	default:
		break;
	}

	return true;
}

//==========================================================================
//
//  Actor::GiveWeapon
//
//  The weapon name may have a MF_DROPPED flag ored in.
//
//==========================================================================

boolean Actor::GiveWeapon(int weapon, boolean dropped)
{
	boolean gaveammo;
	boolean gaveweapon;

	if (netgame && (deathmatch < 2) && !dropped)
	{
		// leave placed weapons forever on net games
		if (Player->WeaponOwned[weapon])
			return false;

		Player->BonusCount += BONUSADD;
		Player->WeaponOwned[weapon] = true;

		if (deathmatch)
			GiveAmmo(weapon_ammo_type[weapon], 5);
		else
			GiveAmmo(weapon_ammo_type[weapon], 2);
		Player->PendingWeapon = weapon;

		PlaySound('PickupWeapon', CHAN_ITEM);
		return false;
	}

	if (weapon_ammo_type[weapon] != am_noammo)
	{
		// give one clip with a dropped weapon,
		// two clips with a found weapon
		if (dropped)
			gaveammo = GiveAmmo(weapon_ammo_type[weapon], 1);
		else
			gaveammo = GiveAmmo(weapon_ammo_type[weapon], 2);
	}
	else
		gaveammo = false;

	if (Player->WeaponOwned[weapon])
		gaveweapon = false;
	else
	{
		gaveweapon = true;
		Player->WeaponOwned[weapon] = true;
		Player->PendingWeapon = weapon;
	}

	return (gaveweapon || gaveammo);
}

//==========================================================================
//
//	Actor::GiveBody
//
//	Returns false if the body isn't needed at all
//
//==========================================================================

boolean Actor::GiveBody(int num)
{
	if (Health >= MAXHEALTH)
	{
		return false;
	}

	Health += num;
	if (Health > MAXHEALTH)
	{
		Health = MAXHEALTH;
	}
	Player->Health = Health;

	return true;
}

//==========================================================================
//
//	Actor::GiveArmor
//
//	Returns false if the armor is worse than the current armor.
//
//==========================================================================

boolean Actor::GiveArmor(int armortype)
{
	int hits;

	hits = armortype * 100;
	if (Player->ArmorPoints >= hits)
		return false;	// don't pick up

	Player->ArmorType = armortype;
	Player->ArmorPoints = hits;

	return true;
}

//==========================================================================
//
//	Actor::GiveCard
//
//==========================================================================

boolean Actor::GiveCard(int card)
{
	if (Player->Keys & (1 << card))
		return false;

	Player->BonusCount = BONUSADD;
	Player->Keys |= 1 << card;
	return true;
}

//==========================================================================
//
//  Actor::GiveItem
//
//==========================================================================

boolean Actor::GiveItem(int item)
{
	if (Player->Items & item)
	{
		return false;	// already got it
	}

	Player->Items |= item;
	return true;
}

//==========================================================================
//
//	Actor::GivePower
//
//==========================================================================

boolean Actor::GivePower(int power)
{
	if (power == pw_invulnerability)
	{
		Player->Powers[power] = ftoi(INVULNTIME * 35.0);
		return true;
	}

	if (power == pw_invisibility)
	{
		Player->Powers[power] = ftoi(INVISTIME * 35.0);
		Translucency = 90;
		return true;
	}

	if (power == pw_infrared)
	{
		Player->Powers[power] = ftoi(INFRATIME * 35.0);
		return true;
	}

	if (power == pw_ironfeet)
	{
		Player->Powers[power] = ftoi(IRONTIME * 35.0);
		return true;
	}

	if (power == pw_strength)
	{
		GiveBody(100);
		Player->Powers[power] = 1;
		return true;
	}

	if (Player->Powers[power])
		return false;	// already got it

	Player->Powers[power] = 1;
	return true;
}

//==========================================================================
//
//	Actor::HideSpecial
//
//==========================================================================

__states__(Actor)
{
	S_DORMANT_PICKUP1('', 0, 30.0, S_DORMANT_PICKUP2)
	{
		bHidden = true;
		bSpecial = false;
	}
	S_DORMANT_PICKUP2('', 0, -1.0, S_NULL)
	{
		Actor A;

		bHidden = false;
		bSpecial = true;
		SetState(IdleState);

		// spawn a teleport fog at the new spot
		A = Spawn(ItemRespawnFog, Origin);
		A.PlaySound('ItemRespawn', CHAN_ITEM);
	}
}

void Actor::HideSpecial(void)
{
	// only respawn items in deathmatch
	if ((deathmatch == 2 || deathmatch == 3) && !bDropped && !bNoRespawn)
	{
		SetState(S_DORMANT_PICKUP1);
	}
	else
	{
		Remove();
	}
}

//==========================================================================
//
//	Actor::TouchSpecial
//
//==========================================================================

void Actor::TouchSpecial(Actor Toucher)
{
	int i;
	name sound;

	if (!Toucher.bPickUp)
	{
		// can't remove thing
		return;
	}

	// Dead thing touching.
	// Can happen with a sliding player corpse.
	if (Toucher.Health <= 0)
		return;

	sound = 'PickupItem';

	// Identify by sprite.
	switch (SpriteName)
	{
		// armor
	case 'ARM1':
		if (!Toucher.GiveArmor(1))
			return;
		cprint(Toucher.Player, GOTARMOR);
		break;

	case 'ARM2':
		if (!Toucher.GiveArmor(2))
			return;
		cprint(Toucher.Player, GOTMEGA);
		break;

		// bonus items
	case 'BON1':
		Toucher.Player->Health++;	// can go over 100%
		if (Toucher.Player->Health > 200)
			Toucher.Player->Health = 200;
		Toucher.Health = Toucher.Player->Health;
		cprint(Toucher.Player, GOTHTHBONUS);
		break;

	case 'BON2':
		Toucher.Player->ArmorPoints++;	// can go over 100%
		if (Toucher.Player->ArmorPoints > 200)
			Toucher.Player->ArmorPoints = 200;
		if (!Toucher.Player->ArmorType)
			Toucher.Player->ArmorType = 1;
		cprint(Toucher.Player, GOTARMBONUS);
		break;

	case 'SOUL':
		Toucher.Player->Health += SOULSPHERE_HEALTH;
		if (Toucher.Player->Health > SOULSPHERE_MAX)
			Toucher.Player->Health = SOULSPHERE_MAX;
		Toucher.Player->MO.Health = Toucher.Player->Health;
		cprint(Toucher.Player, GOTSUPER);
		sound = 'PickupPower';
		break;

#ifdef DOOM2
	case 'MEGA':
		Toucher.Player->Health = MEGASPHERE_HEALTH;
		Toucher.Health = Toucher.Player->Health;
		Toucher.GiveArmor(2);
		cprint(Toucher.Player, GOTMSPHERE);
		sound = 'PickupPower';
		break;
#endif

		// cards
		// leave cards for everyone
	case 'BKEY':
		if (Toucher.GiveCard(it_bluecard))
			cprint(Toucher.Player, GOTBLUECARD);
		if (!netgame)
			break;
		return;

	case 'YKEY':
		if (Toucher.GiveCard(it_yellowcard))
			cprint(Toucher.Player, GOTYELWCARD);
		if (!netgame)
			break;
		return;

	case 'RKEY':
		if (Toucher.GiveCard(it_redcard))
			cprint(Toucher.Player, GOTREDCARD);
		if (!netgame)
			break;
		return;

	case 'BSKU':
		if (Toucher.GiveCard(it_blueskull))
			cprint(Toucher.Player, GOTBLUESKUL);
		if (!netgame)
			break;
		return;

	case 'YSKU':
		if (Toucher.GiveCard(it_yellowskull))
			cprint(Toucher.Player, GOTYELWSKUL);
		if (!netgame)
			break;
		return;

	case 'RSKU':
		if (Toucher.GiveCard(it_redskull))
			cprint(Toucher.Player, GOTREDSKULL);
		if (!netgame)
			break;
		return;

		// medikits, heals
	case 'STIM':
		if (!Toucher.GiveBody(10))
			return;
		cprint(Toucher.Player, GOTSTIM);
		break;

	case 'MEDI':
		if (!Toucher.GiveBody(25))
			return;

		if (Toucher.Player->Health < 25)
			cprint(Toucher.Player, GOTMEDINEED);
		else
			cprint(Toucher.Player, GOTMEDIKIT);
		break;

		// power ups
	case 'PINV':
		if (!Toucher.GivePower(pw_invulnerability))
			return;
		cprint(Toucher.Player, GOTINVUL);
		sound = 'PickupPower';
		break;

	case 'PSTR':
		if (!Toucher.GivePower(pw_strength))
			return;
		cprint(Toucher.Player, GOTBERSERK);
		if (Toucher.Player->ReadyWeapon != wp_fist)
			Toucher.Player->PendingWeapon = wp_fist;
		sound = 'PickupPower';
		break;

	case 'PINS':
		if (!Toucher.GivePower(pw_invisibility))
			return;
		cprint(Toucher.Player, GOTINVIS);
		sound = 'PickupPower';
		break;

	case 'SUIT':
		if (!Toucher.GivePower(pw_ironfeet))
			return;
		cprint(Toucher.Player, GOTSUIT);
		sound = 'PickupPower';
		break;

	case 'PVIS':
		if (!Toucher.GivePower(pw_infrared))
			return;
		cprint(Toucher.Player, GOTVISOR);
		sound = 'PickupPower';
		break;

		//  Items
	case 'PMAP':
		if (!Toucher.GiveItem(IT_ALL_MAP))
			return;
		cprint(Toucher.Player, GOTMAP);
		sound = 'PickupPower';
		break;

		// ammo
	case 'CLIP':
		if (bDropped)
		{
			if (!Toucher.GiveAmmo(am_clip, 0))
				return;
		}
		else
		{
			if (!Toucher.GiveAmmo(am_clip, 1))
				return;
		}
		cprint(Toucher.Player, GOTCLIP);
		break;

	case 'AMMO':
		if (!Toucher.GiveAmmo(am_clip, 5))
			return;
		cprint(Toucher.Player, GOTCLIPBOX);
		break;

	case 'ROCK':
		if (!Toucher.GiveAmmo(am_misl, 1))
			return;
		cprint(Toucher.Player, GOTROCKET);
		break;

	case 'BROK':
		if (!Toucher.GiveAmmo(am_misl, 5))
			return;
		cprint(Toucher.Player, GOTROCKBOX);
		break;

	case 'CELL':
		if (!Toucher.GiveAmmo(am_cell, 1))
			return;
		cprint(Toucher.Player, GOTCELL);
		break;

	case 'CELP':
		if (!Toucher.GiveAmmo(am_cell, 5))
			return;
		cprint(Toucher.Player, GOTCELLBOX);
		break;

	case 'SHEL':
		if (!Toucher.GiveAmmo(am_shell, 1))
			return;
		cprint(Toucher.Player, GOTSHELLS);
		break;

	case 'SBOX':
		if (!Toucher.GiveAmmo(am_shell, 5))
			return;
		cprint(Toucher.Player, GOTSHELLBOX);
		break;

	case 'BPAK':
		Toucher.Player->Backpack = true;
		for (i = 0; i < NUMAMMO; i++)
		{
			Toucher.GiveAmmo(i, 1);
		}
		cprint(Toucher.Player, GOTBACKPACK);
		break;

		// weapons
	case 'BFUG':
		if (!Toucher.GiveWeapon(wp_bfg, false))
			return;
		cprint(Toucher.Player, GOTBFG9000);
		sound = 'PickupWeapon';
		break;

	case 'MGUN':
		if (!Toucher.GiveWeapon(wp_chaingun, bDropped))
			return;
		cprint(Toucher.Player, GOTCHAINGUN);
		sound = 'PickupWeapon';
		break;

	case 'CSAW':
		if (!Toucher.GiveWeapon(wp_chainsaw, false))
			return;
		cprint(Toucher.Player, GOTCHAINSAW);
		sound = 'PickupWeapon';
		break;

	case 'LAUN':
		if (!Toucher.GiveWeapon(wp_missile, false))
			return;
		cprint(Toucher.Player, GOTLAUNCHER);
		sound = 'PickupWeapon';
		break;

	case 'PLAS':
		if (!Toucher.GiveWeapon(wp_plasma, false))
			return;
		cprint(Toucher.Player, GOTPLASMA);
		sound = 'PickupWeapon';
		break;

	case 'SHOT':
		if (!Toucher.GiveWeapon(wp_shotgun, bDropped))
			return;
		cprint(Toucher.Player, GOTSHOTGUN);
		sound = 'PickupWeapon';
		break;

#ifdef DOOM2
	case 'SGN2':
		if (!Toucher.GiveWeapon(wp_supershotgun, bDropped))
			return;
		cprint(Toucher.Player, GOTSHOTGUN2);
		sound = 'PickupWeapon';
		break;
#endif

#ifdef GRENADE_LAUNCHER
	case 'GLAU':
		if (!Toucher.GiveWeapon(wp_grenade, false))
			return;
		cprint(Toucher.Player, "Piched up a grenade launcher");
		sound = 'PickupWeapon';
		break;
#endif
	}

	if (bCountItem)
		Toucher.Player->ItemCount++;
	HideSpecial();
	Toucher.Player->BonusCount += BONUSADD;
	Toucher.PlaySound(sound, CHAN_ITEM);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.18  2002/05/18 16:59:58  dj_jl
//  Renamed SpawnState to IdleState, other changes.
//
//  Revision 1.17  2002/03/28 18:11:24  dj_jl
//  Changed hiding of specials like in Raven games.
//
//  Revision 1.16  2002/03/20 19:07:43  dj_jl
//  Got rid of a lots of legacy, beautification.
//
//  Revision 1.15  2002/03/12 19:21:24  dj_jl
//  No need for linefeed in client-printing
//
//  Revision 1.14  2002/02/22 18:00:08  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.13  2002/02/14 19:20:57  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.12  2002/02/09 18:12:25  dj_jl
//  Replaced identifying sprite name indexes with sprite names
//
//  Revision 1.11  2002/02/06 17:28:51  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.10  2002/01/28 18:50:18  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.9  2002/01/25 18:04:33  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.8  2002/01/17 18:15:52  dj_jl
//  Renamed all map object classes
//
//  Revision 1.7  2002/01/15 18:26:59  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.6  2002/01/11 18:19:40  dj_jl
//  Started to use names in progs
//
//  Revision 1.5  2002/01/07 12:21:10  dj_jl
//  Changed copyright year
//
//  Revision 1.4  2001/09/24 17:24:09  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
