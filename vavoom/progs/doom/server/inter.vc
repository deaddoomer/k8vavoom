//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**    GET STUFF
//**
//**************************************************************************

#define BONUSADD	6

void P_RemoveMobj(mobj_t * mobj);

//==========================================================================
//
//	Actor::GiveAmmo
//
//	Num is the number of clip loads, not the individual count (0= 1/2 clip).
// Returns false if the ammo can't be picked up at all
//
//==========================================================================

boolean Actor::GiveAmmo(int ammo, int num)
{
	int oldammo;
	int max;

	if (ammo == am_noammo)
		return false;

	if (ammo < 0 || ammo > NUMAMMO)
		Error("P_GiveAmmo: bad type %i", ammo);

	max = Player->backpack ? maxammo[ammo] * 2 : maxammo[ammo];
	if (Player->ammo[ammo] == max)
		return false;

	if (num)
		num *= clipammo[ammo];
	else
		num = clipammo[ammo] / 2;

	if (gameskill == sk_baby || gameskill == sk_nightmare)
	{
		// give double ammo in trainer mode,
		// you'll need in nightmare
		num <<= 1;
	}

	oldammo = Player->ammo[ammo];
	Player->ammo[ammo] += num;

	if (Player->ammo[ammo] > max)
		Player->ammo[ammo] = max;

	// If non zero ammo, 
	// don't change up weapons,
	// player was lower on purpose.
	if (oldammo)
		return true;

	// We were down to zero,
	// so select a new weapon.
	// Preferences are not user selectable.
	switch (ammo)
	{
	case am_clip:
		if (Player->readyweapon == wp_fist)
		{
			if (Player->weaponowned[wp_chaingun])
				Player->pendingweapon = wp_chaingun;
			else
				Player->pendingweapon = wp_pistol;
		}
		break;

	case am_shell:
		if (Player->readyweapon == wp_fist
			|| Player->readyweapon == wp_pistol)
		{
			if (Player->weaponowned[wp_shotgun])
				Player->pendingweapon = wp_shotgun;
		}
		break;

	case am_cell:
		if (Player->readyweapon == wp_fist
			|| Player->readyweapon == wp_pistol)
		{
			if (Player->weaponowned[wp_plasma])
				Player->pendingweapon = wp_plasma;
		}
		break;

	case am_misl:
		if (Player->readyweapon == wp_fist)
		{
			if (Player->weaponowned[wp_missile])
				Player->pendingweapon = wp_missile;
		}
	default:
		break;
	}

	return true;
}

//==========================================================================
//
//  Actor::GiveWeapon
//
//  The weapon name may have a MF_DROPPED flag ored in.
//
//==========================================================================

boolean Actor::GiveWeapon(int weapon, boolean dropped)
{
	boolean gaveammo;
	boolean gaveweapon;

	if (netgame && (deathmatch < 2) && !dropped)
	{
		// leave placed weapons forever on net games
		if (Player->weaponowned[weapon])
			return false;

		Player->bonuscount += BONUSADD;
		Player->weaponowned[weapon] = true;

		if (deathmatch)
			GiveAmmo(weapon_ammo_type[weapon], 5);
		else
			GiveAmmo(weapon_ammo_type[weapon], 2);
		Player->pendingweapon = weapon;

		StartSoundName(self, 'PickupWeapon', CHAN_ITEM);
		return false;
	}

	if (weapon_ammo_type[weapon] != am_noammo)
	{
		// give one clip with a dropped weapon,
		// two clips with a found weapon
		if (dropped)
			gaveammo = GiveAmmo(weapon_ammo_type[weapon], 1);
		else
			gaveammo = GiveAmmo(weapon_ammo_type[weapon], 2);
	}
	else
		gaveammo = false;

	if (Player->weaponowned[weapon])
		gaveweapon = false;
	else
	{
		gaveweapon = true;
		Player->weaponowned[weapon] = true;
		Player->pendingweapon = weapon;
	}

	return (gaveweapon || gaveammo);
}

//==========================================================================
//
//	Actor::GiveBody
//
//	Returns false if the body isn't needed at all
//
//==========================================================================

boolean Actor::GiveBody(int num)
{
	if (Player->health >= MAXHEALTH)
		return false;

	Player->health += num;
	if (Player->health > MAXHEALTH)
		Player->health = MAXHEALTH;
	Health = Player->health;

	return true;
}

//==========================================================================
//
//	Actor::GiveArmor
//
//	Returns false if the armor is worse than the current armor.
//
//==========================================================================

boolean Actor::GiveArmor(int armortype)
{
	int hits;

	hits = armortype * 100;
	if (Player->armorpoints >= hits)
		return false;	// don't pick up

	Player->armortype = armortype;
	Player->armorpoints = hits;

	return true;
}

//==========================================================================
//
//	Actor::GiveCard
//
//==========================================================================

boolean Actor::GiveCard(int card)
{
	if (Player->keys & (1 << card))
		return false;

	Player->bonuscount = BONUSADD;
	Player->keys |= 1 << card;
	return true;
}

//==========================================================================
//
//  Actor::GiveItem
//
//==========================================================================

boolean Actor::GiveItem(int item)
{
	if (Player->items & item)
	{
		return false;	// already got it
	}

	Player->items |= item;
	return true;
}

//==========================================================================
//
//	Actor::GivePower
//
//==========================================================================

boolean Actor::GivePower(int power)
{
	if (power == pw_invulnerability)
	{
		Player->powers[power] = ftoi(INVULNTIME * 35.0);
		return true;
	}

	if (power == pw_invisibility)
	{
		Player->powers[power] = ftoi(INVISTIME * 35.0);
		Translucency = 90;
		return true;
	}

	if (power == pw_infrared)
	{
		Player->powers[power] = ftoi(INFRATIME * 35.0);
		return true;
	}

	if (power == pw_ironfeet)
	{
		Player->powers[power] = ftoi(IRONTIME * 35.0);
		return true;
	}

	if (power == pw_strength)
	{
		GiveBody(100);
		Player->powers[power] = 1;
		return true;
	}

	if (Player->powers[power])
		return false;	// already got it

	Player->powers[power] = 1;
	return true;
}

//==========================================================================
//
//	Actor::TouchSpecial
//
//==========================================================================

void Actor::TouchSpecial(Actor Toucher)
{
	int i;
	name sound;

	if (!Toucher.bPickUp)
	{
		// can't remove thing
		return;
	}

	// Dead thing touching.
	// Can happen with a sliding player corpse.
	if (Toucher.Health <= 0)
		return;

	sound = 'PickupItem';

	// Identify by sprite.
	switch (SpriteName)
	{
		// armor
	case 'ARM1':
		if (!Toucher.GiveArmor(1))
			return;
		cprint(Toucher.Player, "%s\n", GOTARMOR);
		break;

	case 'ARM2':
		if (!Toucher.GiveArmor(2))
			return;
		cprint(Toucher.Player, "%s\n", GOTMEGA);
		break;

		// bonus items
	case 'BON1':
		Toucher.Player->health++;	// can go over 100%
		if (Toucher.Player->health > 200)
			Toucher.Player->health = 200;
		Toucher.Health = Toucher.Player->health;
		cprint(Toucher.Player, "%s\n", GOTHTHBONUS);
		break;

	case 'BON2':
		Toucher.Player->armorpoints++;	// can go over 100%
		if (Toucher.Player->armorpoints > 200)
			Toucher.Player->armorpoints = 200;
		if (!Toucher.Player->armortype)
			Toucher.Player->armortype = 1;
		cprint(Toucher.Player, "%s\n", GOTARMBONUS);
		break;

	case 'SOUL':
		Toucher.Player->health += SOULSPHERE_HEALTH;
		if (Toucher.Player->health > SOULSPHERE_MAX)
			Toucher.Player->health = SOULSPHERE_MAX;
		Toucher.Player->mo->Health = Toucher.Player->health;
		cprint(Toucher.Player, "%s\n", GOTSUPER);
		sound = 'PickupPower';
		break;

#ifdef DOOM2
	case 'MEGA':
		Toucher.Player->health = MEGASPHERE_HEALTH;
		Toucher.Health = Toucher.Player->health;
		Toucher.GiveArmor(2);
		cprint(Toucher.Player, "%s\n", GOTMSPHERE);
		sound = 'PickupPower';
		break;
#endif

		// cards
		// leave cards for everyone
	case 'BKEY':
		if (Toucher.GiveCard(it_bluecard))
			cprint(Toucher.Player, "%s\n", GOTBLUECARD);
		if (!netgame)
			break;
		return;

	case 'YKEY':
		if (Toucher.GiveCard(it_yellowcard))
			cprint(Toucher.Player, "%s\n", GOTYELWCARD);
		if (!netgame)
			break;
		return;

	case 'RKEY':
		if (Toucher.GiveCard(it_redcard))
			cprint(Toucher.Player, "%s\n", GOTREDCARD);
		if (!netgame)
			break;
		return;

	case 'BSKU':
		if (Toucher.GiveCard(it_blueskull))
			cprint(Toucher.Player, "%s\n", GOTBLUESKUL);
		if (!netgame)
			break;
		return;

	case 'YSKU':
		if (Toucher.GiveCard(it_yellowskull))
			cprint(Toucher.Player, "%s\n", GOTYELWSKUL);
		if (!netgame)
			break;
		return;

	case 'RSKU':
		if (Toucher.GiveCard(it_redskull))
			cprint(Toucher.Player, "%s\n", GOTREDSKULL);
		if (!netgame)
			break;
		return;

		// medikits, heals
	case 'STIM':
		if (!Toucher.GiveBody(10))
			return;
		cprint(Toucher.Player, "%s\n", GOTSTIM);
		break;

	case 'MEDI':
		if (!Toucher.GiveBody(25))
			return;

		if (Toucher.Player->health < 25)
			cprint(Toucher.Player, "%s\n", GOTMEDINEED);
		else
			cprint(Toucher.Player, "%s\n", GOTMEDIKIT);
		break;

		// power ups
	case 'PINV':
		if (!Toucher.GivePower(pw_invulnerability))
			return;
		cprint(Toucher.Player, "%s\n", GOTINVUL);
		sound = 'PickupPower';
		break;

	case 'PSTR':
		if (!Toucher.GivePower(pw_strength))
			return;
		cprint(Toucher.Player, "%s\n", GOTBERSERK);
		if (Toucher.Player->readyweapon != wp_fist)
			Toucher.Player->pendingweapon = wp_fist;
		sound = 'PickupPower';
		break;

	case 'PINS':
		if (!Toucher.GivePower(pw_invisibility))
			return;
		cprint(Toucher.Player, "%s\n", GOTINVIS);
		sound = 'PickupPower';
		break;

	case 'SUIT':
		if (!Toucher.GivePower(pw_ironfeet))
			return;
		cprint(Toucher.Player, "%s\n", GOTSUIT);
		sound = 'PickupPower';
		break;

	case 'PVIS':
		if (!Toucher.GivePower(pw_infrared))
			return;
		cprint(Toucher.Player, "%s\n", GOTVISOR);
		sound = 'PickupPower';
		break;

		//  Items
	case 'PMAP':
		if (!Toucher.GiveItem(IT_ALL_MAP))
			return;
		cprint(Toucher.Player, "%s\n", GOTMAP);
		sound = 'PickupPower';
		break;

		// ammo
	case 'CLIP':
		if (bDropped)
		{
			if (!Toucher.GiveAmmo(am_clip, 0))
				return;
		}
		else
		{
			if (!Toucher.GiveAmmo(am_clip, 1))
				return;
		}
		cprint(Toucher.Player, "%s\n", GOTCLIP);
		break;

	case 'AMMO':
		if (!Toucher.GiveAmmo(am_clip, 5))
			return;
		cprint(Toucher.Player, "%s\n", GOTCLIPBOX);
		break;

	case 'ROCK':
		if (!Toucher.GiveAmmo(am_misl, 1))
			return;
		cprint(Toucher.Player, "%s\n", GOTROCKET);
		break;

	case 'BROK':
		if (!Toucher.GiveAmmo(am_misl, 5))
			return;
		cprint(Toucher.Player, "%s\n", GOTROCKBOX);
		break;

	case 'CELL':
		if (!Toucher.GiveAmmo(am_cell, 1))
			return;
		cprint(Toucher.Player, "%s\n", GOTCELL);
		break;

	case 'CELP':
		if (!Toucher.GiveAmmo(am_cell, 5))
			return;
		cprint(Toucher.Player, "%s\n", GOTCELLBOX);
		break;

	case 'SHEL':
		if (!Toucher.GiveAmmo(am_shell, 1))
			return;
		cprint(Toucher.Player, "%s\n", GOTSHELLS);
		break;

	case 'SBOX':
		if (!Toucher.GiveAmmo(am_shell, 5))
			return;
		cprint(Toucher.Player, "%s\n", GOTSHELLBOX);
		break;

	case 'BPAK':
		Toucher.Player->backpack = true;
		for (i = 0; i < NUMAMMO; i++)
		{
			Toucher.GiveAmmo(i, 1);
		}
		cprint(Toucher.Player, "%s\n", GOTBACKPACK);
		break;

		// weapons
	case 'BFUG':
		if (!Toucher.GiveWeapon(wp_bfg, false))
			return;
		cprint(Toucher.Player, "%s\n", GOTBFG9000);
		sound = 'PickupWeapon';
		break;

	case 'MGUN':
		if (!Toucher.GiveWeapon(wp_chaingun, bDropped))
			return;
		cprint(Toucher.Player, "%s\n", GOTCHAINGUN);
		sound = 'PickupWeapon';
		break;

	case 'CSAW':
		if (!Toucher.GiveWeapon(wp_chainsaw, false))
			return;
		cprint(Toucher.Player, "%s\n", GOTCHAINSAW);
		sound = 'PickupWeapon';
		break;

	case 'LAUN':
		if (!Toucher.GiveWeapon(wp_missile, false))
			return;
		cprint(Toucher.Player, "%s\n", GOTLAUNCHER);
		sound = 'PickupWeapon';
		break;

	case 'PLAS':
		if (!Toucher.GiveWeapon(wp_plasma, false))
			return;
		cprint(Toucher.Player, "%s\n", GOTPLASMA);
		sound = 'PickupWeapon';
		break;

	case 'SHOT':
		if (!Toucher.GiveWeapon(wp_shotgun, bDropped))
			return;
		cprint(Toucher.Player, "%s\n", GOTSHOTGUN);
		sound = 'PickupWeapon';
		break;

#ifdef DOOM2
	case 'SGN2':
		if (!Toucher.GiveWeapon(wp_supershotgun, bDropped))
			return;
		cprint(Toucher.Player, "%s\n", GOTSHOTGUN2);
		sound = 'PickupWeapon';
		break;
#endif

#ifdef GRENADE_LAUNCHER
	case 'GLAU':
		if (!Toucher.GiveWeapon(wp_grenade, false))
			return;
		cprint(Toucher.Player, "Piched up a grenade launcher\n");
		sound = 'PickupWeapon';
		break;
#endif
	}

	if (bCountItem)
		Toucher.Player->itemcount++;
	P_RemoveMobj(this);
	Toucher.Player->bonuscount += BONUSADD;
	StartSoundName(Toucher, sound, CHAN_ITEM);
}

//**************************************************************************
//
//  $Log$
//  Revision 1.13  2002/02/14 19:20:57  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.12  2002/02/09 18:12:25  dj_jl
//  Replaced identifying sprite name indexes with sprite names
//
//  Revision 1.11  2002/02/06 17:28:51  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.10  2002/01/28 18:50:18  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.9  2002/01/25 18:04:33  dj_jl
//  Many global functions made Actor functions
//
//  Revision 1.8  2002/01/17 18:15:52  dj_jl
//  Renamed all map object classes
//
//  Revision 1.7  2002/01/15 18:26:59  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.6  2002/01/11 18:19:40  dj_jl
//  Started to use names in progs
//
//  Revision 1.5  2002/01/07 12:21:10  dj_jl
//  Changed copyright year
//
//  Revision 1.4  2001/09/24 17:24:09  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/29 17:42:13  dj_jl
//  Added sound channel
//  
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
