//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2002 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

int botskill = 2;

// CODE --------------------------------------------------------------------

/*

  This section contains the main bot AI. The
  main bot AI loop, B_Think, is called every tic.
  Also included are various bot decision-making
  procedures, such as B_CheckStuff and B_SetEnemy.

*/

#if 0
//
// B_ChooseWeapon
//
// Decide which weapon would be best to use in out situation
weapontype_t B_ChooseWeapon (skullb_s *bot)
{
	player_t *player = bot->player;
	AActor *mo = bot->player->mo;
	AActor *enemy = bot->enemy;
	fixed_t dist;

	if (!enemy)
		return player->readyweapon;

	dist = P_AproxDistance (mo->x - enemy->x, mo->y - enemy->y);

	if (dist <= MELEERANGE)
	{
		if (player->WeaponOwned[wp_supershotgun] && player->Ammo[am_shell] >= 2)
			return wp_supershotgun;

		if (player->WeaponOwned[wp_plasma] && player->Ammo[am_cell] >= 20)
			return wp_plasma;

		if (player->WeaponOwned[wp_railgun] && player->Ammo[am_cell] >= 10)
			return wp_railgun;

		if (player->WeaponOwned[wp_chaingun] && player->Ammo[am_clip] >= 20)
			return wp_chaingun;

		if (player->powers[pw_strength])
			return wp_fist;

		if (player->WeaponOwned[wp_chainsaw])
			return wp_chainsaw;

		if (player->WeaponOwned[wp_shotgun] && player->Ammo[am_shell])
			return wp_shotgun;

		// Didn't find anything good
		return player->readyweapon;
	}

	else if (dist <= 512*FRACUNIT)
	{
		if (player->WeaponOwned[wp_plasma] && player->Ammo[am_cell] >= 20)
			return wp_plasma;

		if (player->WeaponOwned[wp_supershotgun] && player->Ammo[am_shell] >= 2)
			return wp_supershotgun;

		if (player->WeaponOwned[wp_grenlauncher] && player->Ammo[am_misl] >= 2)
			return wp_grenlauncher;

		if (player->WeaponOwned[wp_missile] && player->Ammo[am_misl] >= 2)
			return wp_missile;

		if (player->WeaponOwned[wp_railgun] && player->Ammo[am_cell] >= 10)
			return wp_railgun;

		if (player->WeaponOwned[wp_chaingun] && player->Ammo[am_clip])
			return wp_chaingun;

		if (player->WeaponOwned[wp_shotgun] && player->Ammo[am_shell])
			return wp_shotgun;

		return player->readyweapon;
	}

	else
	{
		if (player->WeaponOwned[wp_railgun] && player->Ammo[am_cell] >= 10)
			return wp_railgun;

		if (player->WeaponOwned[wp_chaingun] && player->Ammo[am_clip])
			return wp_chaingun;

		if (player->WeaponOwned[wp_shotgun] && player->Ammo[am_shell])
			return wp_shotgun;

		if (player->WeaponOwned[wp_plasma] && player->Ammo[am_cell] >= 20)
			return wp_plasma;

		if (player->WeaponOwned[wp_missile] && player->Ammo[am_misl] >= 2)
			return wp_missile;

		if (player->WeaponOwned[wp_grenlauncher] && player->Ammo[am_misl] >= 2)
			return wp_grenlauncher;

		return player->readyweapon;
	}

	return player->readyweapon;
}

//
// B_Chat
//

// Tic down bot's typing time, and say our message if we're done
bool B_Chat (skullb_s *bot)
{
	// Chat ticker
	if (bot->t_chat)
	{
		if (!bot->chatline || !bot->chatline->string || !botchat.value)
		{
			bot->t_chat = 0;
			bot->player->icon = NULL;
			return false;
		}
		else
			bot->t_chat--;

		// Chat time has expired, time to say our line
		if (!bot->t_chat)
		{
			int plyrnum = bot->player - players;
			Net_Command (DEM_SAY, 0, bot->chatline->string, plyrnum);

			// Handle responses
			for (int i=0; i<MAXPLAYERS; i++)
			{
				if (!players[i].skullb || !playeringame[i])
					continue;
				if ((bot->info.chatinfo != CT_NONE) && (bot->chatline->bot == players[i].skullb->info.chatinfo))
				{
					players[i].skullb->chatline = bot->chatline->line;
					players[i].skullb->t_chat = players[i].skullb->info.chattime;
				}
			}
			bot->chatline = NULL;
		}
		
		// Don't do anything while "typing"
		return true;

	}

	return false;
}

/*

  This section of code contains the console commands
  related to the bots, such as "addbot" and "removebot".
  It also contains a console command that displays all
  of the bot path nodes on the level, which can be particularly
  helpful for developers, and for people who need to pay
  close attention to their movement.

*/

// Returns true if a given bot name is valid
BOOL B_CheckName (char *Name)
{
	if (!Name)
		return true;
	else
	{
		for (int i=0; i<NUMTOTALBOTS; i++)
			if (!stricmp (botinfo[i].Name, Name))
				return true;
		return false;
	}
}
#endif

//==========================================================================
//
//	IsDangerous
//
//	Checks if a sector is dangerous.
//
//==========================================================================

bool IsDangerous(sector_t *sec)
{
	int special = sec->special & ~SECRET_MASK;

	switch (special)
	{
		case 64 + 5:
		case 64 + 7:
		case 64 + 16:
		case 64 + 4:
		case 64 + 11:
			return true;
		default:
			// [RH] Ignore unknown specials
			break;
	}
	switch (special & DAMAGE_MASK)
	{
		case 0x100: // 2/5 damage per 31 ticks
		case 0x200: // 5/10 damage per 31 ticks
		case 0x300: // 10/20 damage per 31 ticks
			return true;
		default:
			break;
	}

//	if (sec->damage)
//		return true;

	return false;
}

//==========================================================================
//
//	PTR_BotPathTraverse
//
//	[BC] For the bots
//
//==========================================================================

float bottracerange;
TVec bottracedir;

bool PTR_BotPathTraverse(intercept_t *in)
{
	Actor th;
	line_t *ld;
	BotPlayer bot;
	Actor botmo;
	TVec hit_point;

	bot = usething.Player->Bot;
	botmo = usething;

	if (in->bIsALine)
	{
		sector_t *back;
		sector_t *front;
		opening_t *open;
		float diffheight;

		ld = in->line;					// This linedef
		hit_point = botmo.Origin + (bottracerange * in->frac) * bottracedir;

		// Line is impassible
		if (!(ld->flags & ML_TWOSIDED) || (ld->flags & ML_BLOCKING))
			return false;

		// Line isn't two sided
		if (!ld->backsector)
			return false;

		if (!PointOnPlaneSide(botmo.Origin, ld))
		{
			back = ld->backsector;
			front = ld->frontsector;
		}
		else
		{
			back = ld->frontsector;
			front = ld->backsector;
		}

		// Sector is dangerous
		if (IsDangerous(back))
			return false;

		// crosses a two sided line
		open = LineOpenings(ld, hit_point);
		open = FindOpening(open, hit_point.z, hit_point.z + botmo.Height);
		// No valid openings
		if (!open)
		{
			return false;
		}

		// No cliff jumping unless we're going after something
		if ((front->floorheight - back->floorheight) > 32.0 && !bot.enemy)
		{
			return false;
		}

		diffheight = back->floorheight - front->floorheight;
		
		if (diffheight > 0.0)
		{
			if (diffheight > 48.0)
			{
/*				if (front->SSpecial == ThrustThingZ || front->springpadzone)
				{
					if (bot->player - players == displayplayer && netstate != NS_SERVER)
						Printf (PRINT_HIGH, "B_CheckPath: Bouncy sector, should be okay\n");
					return true;
				}
				else*/
					return false;
			}
			else if (diffheight <= 48.0 && diffheight >= 24.0)
			{
				botmo.Player->Buttons |= BT_JUMP;
			}
		}

		return true;
	}

	th = Actor(in->Thing);

	if (th == botmo)
		return true;

	if (th.bSolid)
		return false;

/*	fixed_t diffheight = (th->z + th->Height) - shootthing->z;

	if (diffheight > 0)
	{
		if (diffheight <= 48*FRACUNIT && diffheight >= 24*FRACUNIT)
		{
			bot->player->cmd.ucmd.buttons |= BT_JUMP;
			return true;
		}
		else if (diffheight <= 24*FRACUNIT)
			return true;
		else
			return false;
				
	}
*/
	return true;
}

#if 0
//
// B_SetAction
//
// Decide what to do in teamgame (defend, whatever)
//
void B_SetAction (skullb_s *bot)
{
	AActor *mo = bot->player->mo;
	int defenders = 0;
	int attackers = 0;

	if (bot->player->team == TM_NONE)
		return;

	if (bot->state == BST_NOTHING)
	{
		return;

		// Let's see what the other bots on our
		// team are doing, and decide our action based
		// off of that
		for (int i=0; i<MAXPLAYERS; i++)
		{
			if (playeringame[i] && players[i].mo->IsTeammate (mo) && players[i].skullb)
			{
				if (players[i].skullb->state == BST_OFFENSE)
					attackers++;
				if (players[i].skullb->state == BST_DEFENSE)
					defenders++;
			}
		}

		// Defense wins championships...
		if (defenders <= attackers)
			bot->state = BST_DEFENSE;
		else
			bot->state = BST_OFFENSE;
	}
}

void B_SetGoal (skullb_s *bot)
{
	return;

	AActor *mo = bot->player->mo;
	AActor *actor;

	if (bot->player->team == TM_NONE)
		return;

	TThinkerIterator<AActor> iterator;

	while ((actor = iterator.Next ()) && !bot->goal)
	{
		if (bot->state == BST_OFFENSE)
		{
			if (actor->Class == teams[bot->player->team].theirs)
				bot->goal = actor;
		}
		else if (bot->state == BST_RETURN)
		{
			if (actor->Class == teams[bot->player->team].ours)
				bot->goal = actor;
		}
	}
}

//This function is called every
//tick (for each bot) to set
//the mate (teammate coop mate).
AActor *B_SetAlly (skullb_s *bot)
{
	return NULL;
	
	fixed_t closest_dist, test;
	AActor *target;
	bool p_leader[MAXPLAYERS];

	//is mate alive?
	if (bot->ally)
	{
		if (!bot->ally->Health)
			bot->ally = NULL;
		else
		{
			bot->last_mate = bot->ally;
			return bot->ally;
		}
	}

	//Check old_mates status.
	if (bot->last_mate)
		if (!bot->last_mate->Health)
			bot->last_mate = NULL;

	for (int i=0; i<MAXPLAYERS; i++)
	{
		if (!playeringame[i] || !players[i].team || i == consoleplayer)
			continue;
		if (players[i].team == bot->player->team)
		{
			bot->ally = players[i].mo;
			break;
		}

		p_leader[i] = false;
		for (int j=0; j<MAXPLAYERS; j++)
		{
			if (players[j].skullb->ally == players[i].mo)
			{
				p_leader[i] = true;
				break;
			}
		}
	}

	target = NULL;
	closest_dist = MAXINT;

	//Check for player friends
	for (i=0; i<MAXPLAYERS; i++)
	{
		if (playeringame[i]
			&& players[i].mo
			&& bot->player->mo != players[i].mo
			&& (bot->player->mo->IsTeammate (players[i].mo) || !deathmatch.value)
			&& players[i].mo->Health
			&& ((bot->player->health/2) <= players[i].mo->Health || !deathmatch.value)
			&& !p_leader[i]) //taken?
		{

			if (P_CheckSight (bot->player->mo, players[i].mo, true))
			{
				test = P_AproxDistance (players[i].mo->x - bot->player->mo->x,
										players[i].mo->y - bot->player->mo->y);

				if (test < closest_dist)
				{
					closest_dist = test;
					target = players[i].mo;
				}
			}
		}
	}

	return target;
}

// [RH] We absolutely do not want to pick things up here. The bot code is
// executed apart from all the other simulation code, so we don't want it
// creating side-effects during gameplay.
bool SafeCheckPosition (AActor *actor, fixed_t x, fixed_t y)
{
	int savedFlags = actor->Flags;
	actor->Flags &= ~MF_PICKUP;
	bool res = P_CheckPosition (actor, x, y) ? true : false;
	actor->Flags = savedFlags;
	return res;
}
#endif

botinfo_t botinfo[30] =
{
	{
		"bot1",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot1\\color\\0\\class\\0\\model\\doomguy\\skin\\green.pcx"
	},
	{
		"bot2",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot2\\color\\0\\class\\0\\model\\doomguy\\skin\\greenf.pcx"
	},
	{
		"bot3",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot3\\color\\0\\class\\0\\model\\doomguy\\skin\\camo.pcx"
	},
	{
		"bot4",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot4\\color\\0\\class\\0\\model\\doomguy\\skin\\camof.pcx"
	},
	{
		"bot5",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot5\\color\\1\\class\\0\\model\\doomguy\\skin\\black.pcx"
	},
	{
		"bot6",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot6\\color\\1\\class\\0\\model\\doomguy\\skin\\blackf.pcx"
	},
	{
		"bot7",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot7\\color\\1\\class\\0\\model\\doomguy\\skin\\white.pcx"
	},
	{
		"bot8",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot8\\color\\1\\class\\0\\model\\doomguy\\skin\\whitef.pcx"
	},
	{
		"bot9",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot9\\color\\2\\class\\0\\model\\doomguy\\skin\\brown.pcx"
	},
	{
		"bot10",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot10\\color\\2\\class\\0\\model\\doomguy\\skin\\brownf.pcx"
	},
	{
		"bot11",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot11\\color\\3\\class\\0\\model\\doomguy\\skin\\red.pcx"
	},
	{
		"bot12",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot12\\color\\3\\class\\0\\model\\doomguy\\skin\\redf.pcx"
	},
	{
		"bot13",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot13\\color\\4\\class\\0\\model\\doomguy\\skin\\pink.pcx"
	},
	{
		"bot14",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot14\\color\\4\\class\\0\\model\\doomguy\\skin\\pinkf.pcx"
	},
	{
		"bot15",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot15\\color\\5\\class\\0\\model\\doomguy\\skin\\blue.pcx"
	},
	{
		"bot16",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot16\\color\\5\\class\\0\\model\\doomguy\\skin\\bluef.pcx"
	},
	{
		"bot17",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot17\\color\\5\\class\\0\\model\\doomguy\\skin\\lgtblue.pcx"
	},
	{
		"bot18",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot18\\color\\5\\class\\0\\model\\doomguy\\skin\\lgtbluef.pcx"
	},
	{
		"bot19",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot19\\color\\5\\class\\0\\model\\doomguy\\skin\\navy.pcx"
	},
	{
		"bot20",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot20\\color\\5\\class\\0\\model\\doomguy\\skin\\navyf.pcx"
	},
	{
		"bot21",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot21\\color\\5\\class\\0\\model\\doomguy\\skin\\indigo.pcx"
	},
	{
		"bot22",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot22\\color\\5\\class\\0\\model\\doomguy\\skin\\indigof.pcx"
	},
	{
		"bot23",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot23\\color\\6\\class\\0\\model\\doomguy\\skin\\violet.pcx"
	},
	{
		"bot24",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot24\\color\\6\\class\\0\\model\\doomguy\\skin\\violetf.pcx"
	},
	{
		"bot25",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot25\\color\\6\\class\\0\\model\\doomguy\\skin\\purple.pcx"
	},
	{
		"bot26",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot26\\color\\6\\class\\0\\model\\doomguy\\skin\\purplef.pcx"
	},
	{
		"bot27",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot27\\color\\7\\class\\0\\model\\doomguy\\skin\\orange.pcx"
	},
	{
		"bot28",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot28\\color\\7\\class\\0\\model\\doomguy\\skin\\orangef.pcx"
	},
	{
		"bot29",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot29\\color\\7\\class\\0\\model\\doomguy\\skin\\yellow.pcx"
	},
	{
		"bot30",
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		bsk_medium,
		"\\Name\\bot30\\color\\7\\class\\0\\model\\doomguy\\skin\\yellowf.pcx"
	}
};

//**************************************************************************
//
//  $Log$
//  Revision 1.22  2002/10/26 16:32:20  dj_jl
//  New style of defining classes.
//
//  Revision 1.21  2002/09/07 16:28:24  dj_jl
//  Added Level class.
//
//  Revision 1.20  2002/07/13 08:01:48  dj_jl
//  Moved some functions to the Entity class.
//
//  Revision 1.19  2002/06/14 15:51:20  dj_jl
//  A lots of changes, new functions etc for DDF.
//
//  Revision 1.18  2002/04/11 16:49:49  dj_jl
//  Tick function.
//
//  Revision 1.17  2002/03/28 18:15:34  dj_jl
//  Renamed mo in player_t to MO.
//
//  Revision 1.16  2002/03/20 19:07:43  dj_jl
//  Got rid of a lots of legacy, beautification.
//
//  Revision 1.15  2002/03/09 17:57:01  dj_jl
//  Got rid of function pointers, made most of the physics functions native.
//
//  Revision 1.14  2002/02/22 18:00:06  dj_jl
//  A lots of the renaming, beautification.
//
//  Revision 1.13  2002/02/14 19:20:57  dj_jl
//  Renamed Entity properties to new naming style
//
//  Revision 1.12  2002/02/06 17:28:51  dj_jl
//  Replaced Actor flags with boolean variables.
//
//  Revision 1.11  2002/02/02 19:17:25  dj_jl
//  Replacing pointers with references, beautification.
//
//  Revision 1.10  2002/01/28 18:50:18  dj_jl
//  Made some functions Actor members.
//  Replaced some pointers with references.
//
//  Revision 1.9  2002/01/17 18:15:52  dj_jl
//  Renamed all map object classes
//
//  Revision 1.8  2002/01/15 18:26:59  dj_jl
//  Some property names with logical words starting with capital letter.
//  Moved everything from Entity class into Actor class.
//
//  Revision 1.7  2002/01/11 08:03:10  dj_jl
//  Renamed 'name' to "Name'
//
//  Revision 1.6  2002/01/07 12:21:10  dj_jl
//  Changed copyright year
//
//  Revision 1.5  2002/01/04 18:22:58  dj_jl
//  All posible skins and models
//
//  Revision 1.4  2002/01/03 18:33:04  dj_jl
//  Beautification
//
//  Revision 1.3  2001/12/27 17:52:22  dj_jl
//  Removed Entity property type, replaced with Object property Class
//
//  Revision 1.2  2001/12/12 19:15:27  dj_jl
//  Some little changes for state methods
//
//  Revision 1.1  2001/12/04 18:36:42  dj_jl
//  Bots, directly from SkullTag!
//
//**************************************************************************
