//**************************************************************************
//**
//**	##   ##    ##    ##   ##   ####     ####   ###     ###
//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**	   #    ##    ##    #      ####     ####   ##       ##
//**
//**	$Id$
//**
//**	Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**	This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**	This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**	$Log$
//**	Revision 1.2  2001/07/27 14:27:51  dj_jl
//**	Update with Id-s and Log-s, some fixes
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

// GLOBAL LOCATIONS
#define WI_SPACINGY    	33

#define WI_TITLEY		2

// SINGPLE-PLAYER STUFF
#define SP_STATSX		50
#define SP_STATSY		50

#define SP_TIMEX		16
#define SP_TIMEY		168

// NET GAME STUFF
#define NG_STATSY		50
#define NG_STATSX		(32 + star_width / 2)

#define NG_SPACINGX    	64

// DEATHMATCH STUFF
#define DM_MATRIXX		42
#define DM_MATRIXY		68

#define DM_TOTALSX		269

#define DM_KILLERSX		10
#define DM_KILLERSY		100
#define DM_VICTIMSX    	5
#define DM_VICTIMSY		50

#define DM_SPACINGX		40

// in seconds
#define SHOWNEXTLOCDELAY	4.0

//	Different between registered DOOM (1994) and Ultimate DOOM - Final
// edition (retail, 1995?).
#define NUMEPISODES		3
#define NUMMAPS			9

// CONSTANTS ---------------------------------------------------------------

#ifndef DOOM2

enum
{
    ANIM_ALWAYS,
    ANIM_RANDOM,
    ANIM_LEVEL
};

#endif

// TYPES -------------------------------------------------------------------

#ifndef DOOM2

struct point_t
{
    int		x;
    int		y;
};

//
// Animation.
//
struct anim_t
{
	int		type;

	// period in seconds between animations
	float	period;

	// number of animation frames
	int		nanims;

    // location of animation
	point_t	loc;

	// LEVEL: level
	int		level;

	// RANDOM: period deviation (<8),
	float	data1;

	// RANDOM: random base period,
	float	data2;

	// actual graphics for frames of animations
	int		p[3];

    // following must be initialized to zero before use!

	// next value of btime (used in conjunction with period)
	float	nexttime;

	// next frame number to animate
	int		ctr;
};

#endif

// FUNCTION PROTOTYPES -----------------------------------------------------

#ifndef DOOM2
void IM_InitNextLoc(void);
#endif
void IM_InitNoState(void);
#ifdef DOOM2
void IM_InitText(void);
void F_StartFinale(void);
#endif

// DATA DECLARATIONS -------------------------------------------------------

// background (map of levels).
int				patchINTERPIC;

int				interstate;

// used for timing of background animation
float			btime;

int				sp_state;
int				ng_state;
int				dm_state;

int				cnt_kills[MAXPLAYERS];
int				cnt_items[MAXPLAYERS];
int				cnt_secret[MAXPLAYERS];
int				cnt_time;
float			cnt_pause;
int				cnt_frags[MAXPLAYERS];

int				dm_frags[MAXPLAYERS][MAXPLAYERS];
int				dm_totals[MAXPLAYERS];

// "killers", "victims"
int				killers;
int				victims;

// Face background, your face, your dead face
int				p[MAXPLAYERS];

int				star;
int				star_width;

int				bstar;

// used for general timing
float			cnt;

#ifndef DOOM2
int				im_episode;
int				im_map;
int				im_nextepisode;
int				im_nextmap;

//
//	Animation locations. Using patches saves a lot of space, as they replace
// 320x200 full screen frames.
//
anim_t epsd0animinfo[] =
{
    { ANIM_ALWAYS, 1.0/3.0, 3, { 224, 104 } },
    { ANIM_ALWAYS, 1.0/3.0, 3, { 184, 160 } },
    { ANIM_ALWAYS, 1.0/3.0, 3, { 112, 136 } },
    { ANIM_ALWAYS, 1.0/3.0, 3, { 72, 112 } },
    { ANIM_ALWAYS, 1.0/3.0, 3, { 88, 96 } },
    { ANIM_ALWAYS, 1.0/3.0, 3, { 64, 48 } },
    { ANIM_ALWAYS, 1.0/3.0, 3, { 192, 40 } },
    { ANIM_ALWAYS, 1.0/3.0, 3, { 136, 16 } },
    { ANIM_ALWAYS, 1.0/3.0, 3, { 80, 16 } },
    { ANIM_ALWAYS, 1.0/3.0, 3, { 64, 24 } }
};

anim_t epsd1animinfo[] =
{
    { ANIM_LEVEL, 1.0/3.0, 1, { 128, 136 }, 1 },
    { ANIM_LEVEL, 1.0/3.0, 1, { 128, 136 }, 2 },
    { ANIM_LEVEL, 1.0/3.0, 1, { 128, 136 }, 3 },
    { ANIM_LEVEL, 1.0/3.0, 1, { 128, 136 }, 4 },
    { ANIM_LEVEL, 1.0/3.0, 1, { 128, 136 }, 5 },
    { ANIM_LEVEL, 1.0/3.0, 1, { 128, 136 }, 6 },
    { ANIM_LEVEL, 1.0/3.0, 1, { 128, 136 }, 7 },
    { ANIM_LEVEL, 1.0/3.0, 3, { 192, 144 }, 8 },
    { ANIM_LEVEL, 1.0/3.0, 1, { 128, 136 }, 8 }
};

anim_t epsd2animinfo[] =
{
    { ANIM_ALWAYS, 1.0/3.0, 3, { 104, 168 } },
    { ANIM_ALWAYS, 1.0/3.0, 3, { 40, 136 } },
    { ANIM_ALWAYS, 1.0/3.0, 3, { 160, 96 } },
    { ANIM_ALWAYS, 1.0/3.0, 3, { 104, 80 } },
    { ANIM_ALWAYS, 1.0/3.0, 3, { 120, 32 } },
    { ANIM_ALWAYS, 1.0/4.0, 3, { 40, 0 } }
};

anim_t			*anims;
int				numanims;

boolean			snl_pointeron = false;

//
// Data needed to add patches to full screen intermission pics.
// Patches are statistics messages, and animations.
// Loads of by-pixel layout and placement, offsets etc.
//

// You Are Here graphic
int				yah[2];

// splat
int				splat;

point_t lnodes[NUMEPISODES][NUMMAPS] =
{
    // Episode 0 World Map
    {
	{ 185, 164 },	// location of level 0 (CJ)
	{ 148, 143 },	// location of level 1 (CJ)
	{ 69, 122 },	// location of level 2 (CJ)
	{ 209, 102 },	// location of level 3 (CJ)
	{ 116, 89 },	// location of level 4 (CJ)
	{ 166, 55 },	// location of level 5 (CJ)
	{ 71, 56 },		// location of level 6 (CJ)
	{ 135, 29 },	// location of level 7 (CJ)
	{ 71, 24 }		// location of level 8 (CJ)
    },

    // Episode 1 World Map should go here
    {
	{ 254, 25 },	// location of level 0 (CJ)
	{ 97, 50 },		// location of level 1 (CJ)
	{ 188, 64 },	// location of level 2 (CJ)
	{ 128, 78 },	// location of level 3 (CJ)
	{ 214, 92 },	// location of level 4 (CJ)
	{ 133, 130 },	// location of level 5 (CJ)
	{ 208, 136 },	// location of level 6 (CJ)
	{ 148, 140 },	// location of level 7 (CJ)
	{ 235, 158 }	// location of level 8 (CJ)
    },

    // Episode 2 World Map should go here
    {
	{ 156, 168 },	// location of level 0 (CJ)
	{ 48, 154 },	// location of level 1 (CJ)
	{ 174, 95 },	// location of level 2 (CJ)
	{ 265, 75 },	// location of level 3 (CJ)
	{ 130, 48 },	// location of level 4 (CJ)
	{ 279, 23 },	// location of level 5 (CJ)
	{ 198, 48 },	// location of level 6 (CJ)
	{ 140, 25 },	// location of level 7 (CJ)
	{ 281, 136 }	// location of level 8 (CJ)
    }

};

#endif

// CODE --------------------------------------------------------------------

//**************************************************************************
//**
//**	Animated background
//**
//**************************************************************************

#ifndef DOOM2

//==========================================================================
//
//  IM_InitAnimatedBack
//
//==========================================================================

void IM_InitAnimatedBack(void)
{
    int		i;
    anim_t	*a;

    switch (im_episode)
	{
	 case 1:
		anims = &epsd0animinfo[0];
		numanims = 10;
		break;

	 case 2:
		anims = &epsd1animinfo[0];
		numanims = 9;
		break;

	 case 3:
		anims = &epsd2animinfo[0];
		numanims = 6;
		break;

	 default:
		return;
	}

    for (i = 0; i < numanims; i++)
    {
		a = &anims[i];

		// init variables
		a->ctr = -1;

		// specify the next time to draw it
		if (a->type == ANIM_ALWAYS)
	    	a->nexttime = btime + 0.1 + Random() * a->period;
		else if (a->type == ANIM_RANDOM)
	    	a->nexttime = btime + 0.1 + a->data2 + Random() * a->data1;
		else if (a->type == ANIM_LEVEL)
	    	a->nexttime = btime + 0.1;
    }
}

//==========================================================================
//
//	IM_DrawBackground
//
//==========================================================================

void IM_DrawBackground(void)
{
    R_DrawPic(0, 0, patchINTERPIC);
   	// draw animated background
    if (im_episode <= 3)
	{
    	int			i;
	    anim_t*		a;

	    for (i = 0; i < numanims; i++)
	    {
			a = &anims[i];
			if (a->ctr >= 0)
			{
				R_DrawPic(a->loc.x, a->loc.y, a->p[a->ctr]);
			}
	    }
	}	
}

//==========================================================================
//
//  IM_UpdateBackground
//
//==========================================================================

void IM_UpdateBackground(void)
{
    int		i;
    anim_t*	a;

    if (im_episode > 3)
		return;

    for (i = 0; i < numanims; i++)
    {
		a = &anims[i];

		if (btime >= a->nexttime)
		{
	    	switch (a->type)
	    	{
		     case ANIM_ALWAYS:
				if (++a->ctr >= a->nanims) a->ctr = 0;
				a->nexttime = btime + a->period;
				break;

		     case ANIM_RANDOM:
				a->ctr++;
				if (a->ctr == a->nanims)
				{
				    a->ctr = -1;
				    a->nexttime = btime + a->data2 + Random() * a->data1;
				}
				else
				{
					a->nexttime = btime + a->period;
				}
				break;
		
		     case ANIM_LEVEL:
				// gawd-awful hack for level anims
				if ((interstate || i != 7) && im_nextmap - 1 == a->level)
				{
				    a->ctr++;
				    if (a->ctr == a->nanims) a->ctr--;
				    a->nexttime = btime + a->period;
				}
				break;
		    }
		}
    }
}
#endif
#ifdef DOOM2

//==========================================================================
//
//	IM_DrawBackground
//
//==========================================================================

void IM_DrawBackground(void)
{
    R_DrawPic(0, 0, patchINTERPIC);
}
#endif

//==========================================================================
//
//	IM_LoadData
//
//==========================================================================

void IM_LoadData(void)
{
	picinfo_t	info;
	int			i;

    // background
#ifdef DOOM2
    patchINTERPIC = R_RegisterPic("INTERPIC", PIC_PATCH);
#else
	int			j;
	anim_t		*a;

	if (im_episode > 3)
	{
	    patchINTERPIC = R_RegisterPic("INTERPIC", PIC_PATCH);
	}
	else
	{
	    patchINTERPIC = R_RegisterPic(va("WIMAP%d", im_episode - 1), PIC_PATCH);
	}

	// you are here
	yah[0] = R_RegisterPic("WIURH0", PIC_PATCH);

	// you are here (alt.)
	yah[1] = R_RegisterPic("WIURH1", PIC_PATCH);

	// splat
	splat = R_RegisterPic("WISPLAT", PIC_PATCH);

	if (im_episode < 4)
	{
    	for (j = 0; j < numanims; j++)
    	{
			a = &anims[j];
			for (i = 0; i < a->nanims; i++)
			{
	    		// MONDO HACK!
	    		if (im_episode != 2 || j != 8)
	    		{
					// animations
					a->p[i] = R_RegisterPic(va("WIA%d0%d0%d", im_episode - 1, j, i), PIC_PATCH);
	    		}
	    		else
	    		{
					// HACK ALERT!
					a->p[i] = epsd1animinfo[4].p[i];
	    		}
			}
    	}
	}
#endif

	if (cl->maxclients > 1 || cl->deathmatch)
    {
	    // "killers" (vertical)
    	killers = R_RegisterPic("WIKILRS", PIC_PATCH);

	    // "victims" (horiz)
    	victims = R_RegisterPic("WIVCTMS", PIC_PATCH);

	    // face backgrounds
//	    for (i = 0; i < MAXPLAYERS; i++)
	    for (i = 0; i < 4; i++)
		{
			p[i] = R_RegisterPic(va("STPB%i", i), PIC_PATCH);
		}

	    // your face
    	star = R_RegisterPic("STFST01", PIC_PATCH);
		R_GetPicInfo(star, &info);
		star_width = info.width;

	    // dead face
    	bstar = R_RegisterPic("STFDEAD0", PIC_PATCH);
	}
}

//==========================================================================
//
//  IM_UnloadData
//
//==========================================================================

void IM_UnloadData(void)
{
}

//==========================================================================
//
//  IM_DrawLF
//
//	Draws "<Levelname> Finished!"
//
//==========================================================================

void IM_DrawLF(void)
{
    int y = WI_TITLEY;

    // draw <LevelName>
    T_SetAlign(hcenter, vtop);
	T_DrawText(160, y, ARR2STR(im->leave_name));

    // draw "Finished!"
    y += (5 * T_TextHeight("DUMMY")) / 4;
    
	T_DrawText(160, y, "finished");
}

//==========================================================================
//
//  IM_DrawEL
//
//	Draws "Entering <LevelName>"
//
//==========================================================================

void IM_DrawEL(void)
{
    int y = WI_TITLEY;

    // draw "Entering"
    T_SetAlign(hcenter, vtop);
	T_DrawText(160, y, "entering");

    // draw level
    y += (5 * T_TextHeight("DUMMY")) / 4;
	T_DrawText(160, y, ARR2STR(im->enter_name));
}

//==========================================================================
//
//  IM_DrawPercent
//
//==========================================================================

void IM_DrawPercent(int x, int y, int p)
{
    if (p < 0)
		return;

    T_SetAlign(hright, vtop);
	T_DrawText(x, y, va("%d%%", p));
}

//==========================================================================
//
//  IM_DrawTime
//
//	Display level completion time and par, or "sucks" message if overflow.
//
//==========================================================================

void IM_DrawTime(int x, int y, int t)
{
    if (t < 0)
		return;

	T_SetAlign(hleft, vtop);

    if (t <= 61 * 59)
    {
		if (t % 60 < 10)
			T_DrawText(x, y, va("time: %d:0%d", t / 60, t % 60));
		else
			T_DrawText(x, y, va("time: %d:%d", t / 60, t % 60));
    }
    else
    {
		// "sucks"
		T_DrawText(x, y, "time: sucks");
    }
}

//==========================================================================
//
//  IM_InitSingleStats
//
//==========================================================================

void IM_InitSingleStats(void)
{
    interstate = 0;
    skipintermission = 0;
    sp_state = 1;
    cnt_kills[0] = cnt_items[0] = cnt_secret[0] = -1;
    cnt_time = -1;
    cnt_pause = 1.0;
}

//==========================================================================
//
//  IM_DrawSingleStats
//
//==========================================================================

void IM_DrawSingleStats(void)
{
    // line height
    int lh;	

    lh = (3 * T_TextHeight("DUMMY")) / 2;

    IM_DrawLF();

    T_SetAlign(hleft, vtop);

    T_DrawText(SP_STATSX, SP_STATSY, "kills");
    T_DrawText(SP_STATSX, SP_STATSY + lh, "items");
	T_DrawText(SP_STATSX, SP_STATSY + 2 * lh, "scrt");

    IM_DrawPercent(320 - SP_STATSX, SP_STATSY, cnt_kills[0]);
    IM_DrawPercent(320 - SP_STATSX, SP_STATSY + lh, cnt_items[0]);
    IM_DrawPercent(320 - SP_STATSX, SP_STATSY + 2 * lh, cnt_secret[0]);
    IM_DrawTime(SP_TIMEX, SP_TIMEY, cnt_time);
}

//==========================================================================
//
//  IM_UpdateSingleStats
//
//==========================================================================

void IM_UpdateSingleStats(void)
{
    if (skipintermission && sp_state != 10)
    {
		skipintermission = 0;
		cnt_kills[0] = (scores[0].killcount * 100) / im->totalkills;
		cnt_items[0] = (scores[0].itemcount * 100) / im->totalitems;
		cnt_secret[0] = (scores[0].secretcount * 100) / im->totalsecret;
		cnt_time = ftoi(im->time);
		LocalSound("BarrelExplode");
		sp_state = 10;
    }

    if (sp_state == 2)
    {
		cnt_kills[0] += 2;

		if (!(ftoi(btime * 35.0) & 3))
		    LocalSound("PistolFire");

		if (cnt_kills[0] >= (scores[0].killcount * 100) / im->totalkills)
		{
		    cnt_kills[0] = (scores[0].killcount * 100) / im->totalkills;
		    LocalSound("BarrelExplode");
		    sp_state++;
		}
    }
    else if (sp_state == 4)
    {
		cnt_items[0] += 2;

		if (!(ftoi(btime * 35.0)&3))
		    LocalSound("PistolFire");

		if (cnt_items[0] >= (scores[0].itemcount * 100) / im->totalitems)
		{
		    cnt_items[0] = (scores[0].itemcount * 100) / im->totalitems;
		    LocalSound("BarrelExplode");
		    sp_state++;
		}
    }
    else if (sp_state == 6)
    {
		cnt_secret[0] += 2;

		if (!(ftoi(btime * 35.0)&3))
		    LocalSound("PistolFire");

		if (cnt_secret[0] >= (scores[0].secretcount * 100) / im->totalsecret)
		{
		    cnt_secret[0] = (scores[0].secretcount * 100) / im->totalsecret;
		    LocalSound("BarrelExplode");
		    sp_state++;
		}
    }

    else if (sp_state == 8)
    {
		if (!(ftoi(btime * 35.0)&3))
		    LocalSound("PistolFire");

		cnt_time += 3;

	    if (cnt_time >= ftoi(im->time))
	    {
		    cnt_time = ftoi(im->time);
			LocalSound("BarrelExplode");
			sp_state++;
	    }
    }
    else if (sp_state == 10)
    {
		if (skipintermission)
		{
		    LocalSound("ShotgunCocking");

#ifdef DOOM2
			IM_InitNoState();
#else
			IM_InitNextLoc();
#endif
		}
    }
    else if (sp_state & 1)
    {
		cnt_pause -= frametime;
		if (cnt_pause <= 0.0)
		{
		    sp_state++;
		    cnt_pause = 1.0;
		}
    }

}

//==========================================================================
//
//  IM_InitCooperativeStats
//
//==========================================================================

void IM_InitCooperativeStats(void)
{
    int i;

    interstate = 0;
    skipintermission = 0;
    ng_state = 1;

    cnt_pause = 1.0;

    for (i = 0; i < MAXPLAYERS; i++)
    {
		if (!scores[i].active)
		    continue;

		cnt_kills[i] = cnt_items[i] = cnt_secret[i] = cnt_frags[i] = 0;
    }
}

//==========================================================================
//
//  IM_DrawCooperativeStats
//
//==========================================================================

void IM_DrawCooperativeStats(void)
{
    int			i;
    int			x;
    int			y;
    int			pwidth;
	picinfo_t	info;

    pwidth = T_TextWidth("%");

    IM_DrawLF();

    T_SetAlign(hright, vtop);
    // draw stat titles (top line)
	T_DrawText(NG_STATSX + NG_SPACINGX, NG_STATSY, "kills");

	T_DrawText(NG_STATSX + 2 * NG_SPACINGX, NG_STATSY, "items");

	T_DrawText(NG_STATSX + 3 * NG_SPACINGX, NG_STATSY, "scrt");

	T_DrawText(NG_STATSX + NG_SPACINGX, NG_STATSY, "frgs");

    // draw stats
    y = NG_STATSY + T_TextHeight("kills");

//	for (i = 0; i < MAXPLAYERS; i++)
	for (i = 0; i < 4; i++)
    {
		if (!scores[i].active)
	    	continue;

		x = NG_STATSX;
		R_GetPicInfo(p[i], &info);
		R_DrawPic(x - info.width, y, p[i]);

		if (i == cl->clientnum)
	    	R_DrawPic(x - info.width, y, star);

		x += NG_SPACINGX;
		IM_DrawPercent(x - pwidth, y + 10, cnt_kills[i]);	x += NG_SPACINGX;
		IM_DrawPercent(x - pwidth, y + 10, cnt_items[i]);	x += NG_SPACINGX;
		IM_DrawPercent(x - pwidth, y + 10, cnt_secret[i]);	x += NG_SPACINGX;

    	T_SetAlign(hright, vtop);
		T_DrawText(x, y + 10, va("%d", cnt_frags[i]));

		y += WI_SPACINGY;
    }
}

//==========================================================================
//
//  FragSum
//
//==========================================================================

int FragSum(int playernum)
{
    int		i;
    int		frags = 0;
    
    for (i = 0; i < MAXPLAYERS; i++)
    {
		if (scores[i].active && i != playernum)
		{
	    	frags += scores[playernum].frags[i];
		}
    }

    // JDC hack - negative frags.
    frags -= scores[playernum].frags[playernum];

    return frags;
}

//==========================================================================
//
//  IM_UpdateCooperativeStats
//
//==========================================================================

void IM_UpdateCooperativeStats(void)
{

    int		i;
    int		fsum;
    
    boolean	stillticking;

    if (skipintermission && ng_state != 10)
    {
		skipintermission = 0;

		for (i = 0; i < MAXPLAYERS; i++)
		{
		    if (!scores[i].active)
				continue;

		    cnt_kills[i] = (scores[i].killcount * 100) / im->totalkills;
		    cnt_items[i] = (scores[i].itemcount * 100) / im->totalitems;
		    cnt_secret[i] = (scores[i].secretcount * 100) / im->totalsecret;
			cnt_frags[i] = FragSum(i);
		}
		LocalSound("BarrelExplode");
		ng_state = 10;
    }

    if (ng_state == 2)
    {
		if (!(ftoi(btime * 35.0)&3))
		    LocalSound("PistolFire");

		stillticking = false;

		for (i = 0; i < MAXPLAYERS; i++)
		{
		    if (!scores[i].active)
				continue;

		    cnt_kills[i] += 2;

		    if (cnt_kills[i] >= (scores[i].killcount * 100) / im->totalkills)
				cnt_kills[i] = (scores[i].killcount * 100) / im->totalkills;
		    else
				stillticking = true;
		}
	
		if (!stillticking)
		{
		    LocalSound("BarrelExplode");
		    ng_state++;
		}
    }
    else if (ng_state == 4)
    {
		if (!(ftoi(btime * 35.0)&3))
		    LocalSound("PistolFire");

		stillticking = false;

		for (i = 0; i < MAXPLAYERS; i++)
		{
		    if (!scores[i].active)
				continue;

		    cnt_items[i] += 2;
		    if (cnt_items[i] >= (scores[i].itemcount * 100) / im->totalitems)
				cnt_items[i] = (scores[i].itemcount * 100) / im->totalitems;
		    else
				stillticking = true;
		}
		if (!stillticking)
		{
		    LocalSound("BarrelExplode");
		    ng_state++;
		}
    }
    else if (ng_state == 6)
    {
		if (!(ftoi(btime * 35.0)&3))
		    LocalSound("PistolFire");

		stillticking = false;

		for (i = 0; i < MAXPLAYERS; i++)
		{
		    if (!scores[i].active)
				continue;

		    cnt_secret[i] += 2;

		    if (cnt_secret[i] >= (scores[i].secretcount * 100) / im->totalsecret)
				cnt_secret[i] = (scores[i].secretcount * 100) / im->totalsecret;
		    else
				stillticking = true;
		}
	
		if (!stillticking)
		{
		    LocalSound("BarrelExplode");
		    ng_state += 1;
		}
    }
    else if (ng_state == 8)
    {
		if (!(ftoi(btime * 35.0)&3))
		    LocalSound("PistolFire");

		stillticking = false;

		for (i = 0; i< MAXPLAYERS; i++)
		{
		    if (!scores[i].active)
				continue;

		    cnt_frags[i] += 1;

		    if (cnt_frags[i] >= (fsum = FragSum(i)))
				cnt_frags[i] = fsum;
		    else
				stillticking = true;
		}
	
		if (!stillticking)
		{
		    LocalSound("PlayerDeath");
		    ng_state++;
		}
    }
    else if (ng_state == 10)
    {
		if (skipintermission)
		{
		    LocalSound("ShotgunCocking");
#ifdef DOOM2
			IM_InitNoState();
#else
			IM_InitNextLoc();
#endif
		}
    }
    else if (ng_state & 1)
    {
		cnt_pause -= frametime;
		if (cnt_pause <= 0.0)
		{
		    ng_state++;
		    cnt_pause = 1.0;
		}
    }
}

//==========================================================================
//
//  IM_InitDeathmatchStats
//
//==========================================================================

void IM_InitDeathmatchStats(void)
{
    int		i;
    int		j;

    interstate = 0;
    skipintermission = 0;
    dm_state = 1;

    cnt_pause = 1.0;

    for (i = 0; i < MAXPLAYERS; i++)
    {
		if (scores[i].active)
		{
		    for (j = 0; j < MAXPLAYERS; j++)
			if (scores[j].active)
			    dm_frags[i][j] = 0;

		    dm_totals[i] = 0;
		}
    }
}

//==========================================================================
//
//  IM_DrawDeathmatchStats
//
//==========================================================================

void IM_DrawDeathmatchStats(void)
{
    int		i;
    int		j;
    int		x;
    int		y;
    int		w;
    int		lh;	// line height
	picinfo_t	info;

    lh = WI_SPACINGY;

    IM_DrawLF();

    T_SetAlign(hcenter, vtop);
    // draw stat titles (top line)
	T_DrawText(DM_TOTALSX, DM_MATRIXY - WI_SPACINGY + 10, "total");
    
    R_DrawPic(DM_KILLERSX, DM_KILLERSY, killers);
    R_DrawPic(DM_VICTIMSX, DM_VICTIMSY, victims);

    // draw P?
    x = DM_MATRIXX + DM_SPACINGX;
    y = DM_MATRIXY;

//	for (i = 0; i < MAXPLAYERS; i++)
	for (i = 0; i < 4; i++)
    {
		if (scores[i].active)
		{
			R_GetPicInfo(p[i], &info);
			R_DrawPic(x - info.width / 2, DM_MATRIXY - WI_SPACINGY, p[i]);
			R_DrawPic(DM_MATRIXX - info.width / 2, y, p[i]);
	    
		    if (i == cl->clientnum)
		    {
				R_DrawPic(x - info.width / 2, DM_MATRIXY - WI_SPACINGY, bstar);
				R_DrawPic(DM_MATRIXX - info.width / 2, y, star);
		    }
		}
		x += DM_SPACINGX;
		y += WI_SPACINGY;
    }

    // draw stats
    y = DM_MATRIXY + 10;
    w = T_TextWidth("0");

    T_SetAlign(hright, vtop);
//	for (i = 0; i < MAXPLAYERS; i++)
	for (i = 0; i < 4; i++)
    {
		x = DM_MATRIXX + DM_SPACINGX;

		if (scores[i].active)
		{
//		    for (j = 0; j < MAXPLAYERS; j++)
		    for (j = 0; j < 4; j++)
		    {
				if (scores[j].active)
                {
					T_DrawText(x + w, y, va("%d", dm_frags[i][j]));
				}
				x += DM_SPACINGX;
		    }
			T_DrawText(DM_TOTALSX + w, y, va("%d", dm_totals[i]));
		}
		y += WI_SPACINGY;
    }
}

//==========================================================================
//
//  IM_UpdateDeathmatchStats
//
//==========================================================================

void IM_UpdateDeathmatchStats(void)
{
    int		i;
    int		j;
    
    boolean	stillticking;

    if (skipintermission && dm_state != 4)
    {
		skipintermission = 0;

		for (i = 0; i < MAXPLAYERS; i++)
		{
		    if (scores[i].active)
		    {
				for (j = 0; j < MAXPLAYERS; j++)
				    if (scores[j].active)
						dm_frags[i][j] = scores[i].frags[j];

					dm_totals[i] = FragSum(i);
		    }
		}
	
		LocalSound("BarrelExplode");
		dm_state = 4;
    }

    
    if (dm_state == 2)
    {
		if (!(ftoi(btime * 35.0)&3))
		    LocalSound("PistolFire");
	
		stillticking = false;

		for (i = 0; i < MAXPLAYERS; i++)
		{
		    if (scores[i].active)
		    {
				for (j = 0; j < MAXPLAYERS; j++)
				{
				    if (scores[j].active
						&& dm_frags[i][j] != scores[i].frags[j])
				    {
						if (scores[i].frags[j] < 0)
						    dm_frags[i][j]--;
						else
						    dm_frags[i][j]++;

						if (dm_frags[i][j] > 99)
						    dm_frags[i][j] = 99;

						if (dm_frags[i][j] < -99)
						    dm_frags[i][j] = -99;
			
						stillticking = true;
				    }
				}
				dm_totals[i] = FragSum(i);

				if (dm_totals[i] > 99)
				    dm_totals[i] = 99;
		
				if (dm_totals[i] < -99)
				    dm_totals[i] = -99;
		    }
	    
		}
		if (!stillticking)
		{
		    LocalSound("BarrelExplode");
		    dm_state++;
		}

    }
    else if (dm_state == 4)
    {
		if (skipintermission)
		{
		    LocalSound("Slop");

#ifdef DOOM2
			IM_InitNoState();
#else
			IM_InitNextLoc();
#endif
		}
    }
    else if (dm_state & 1)
    {
		cnt_pause -= frametime;
		if (cnt_pause <= 0.0)
		{
		    dm_state++;
		    cnt_pause = 1.0;
		}
    }
}

#ifndef DOOM2

//==========================================================================
//
//  IM_InitNextLoc
//
//==========================================================================

void IM_InitNextLoc(void)
{
    interstate = 1;
    skipintermission = 0;
    cnt = SHOWNEXTLOCDELAY;

	IM_InitAnimatedBack();
}

//==========================================================================
//
//  IM_DrawOnLnode
//
//==========================================================================

void IM_DrawOnLnode(int n, int* c)
{
    int		i;
    int		left;
    int		top;
    int		right;
    int		bottom;
    boolean	fits = false;
	picinfo_t	info;

    i = 0;
    do
    {
		R_GetPicInfo(c[i], &info);
		left = lnodes[im_episode - 1][n].x - info.xoffset;
		top = lnodes[im_episode - 1][n].y - info.yoffset;
		right = left + info.width;
		bottom = top + info.height;

		if (left >= 0 && right < 320 && top >= 0 && bottom < 200)
		{
	    	fits = true;
		}
		else
		{
	    	i++;
		}
    } while (!fits && i != 2);

    if (fits && i < 2)
    {
		R_DrawPic(lnodes[im_episode - 1][n].x, lnodes[im_episode - 1][n].y, c[i]);
    }
    else
    {
		// DEBUG
		dprint("Could not place patch on level %d\n", n + 1);
    }
}

//==========================================================================
//
//  IM_DrawNextLoc
//
//==========================================================================

void IM_DrawNextLoc(void)
{
    int		i;
    int		last;

    if (im_episode <= 3)
    {
		last = (im_map == 9) ? im_nextmap - 2 : im_map - 1;

		// draw a splat on taken cities.
		for (i = 0; i <= last; i++)
		    IM_DrawOnLnode(i, &splat);

		// splat the secret level?
		if (cl->didsecret)
		    IM_DrawOnLnode(8, &splat);

		// draw flashing ptr
		if (snl_pointeron)
		    IM_DrawOnLnode(im_nextmap - 1, &yah[0]);
    }

    // draws which level you are entering..
	IM_DrawEL();
}

//==========================================================================
//
//  IM_UpdateNextLoc
//
//==========================================================================

void IM_UpdateNextLoc(void)
{
	cnt -= frametime;
    if (cnt <= 0.0 || skipintermission)
		IM_InitNoState();
    else
		snl_pointeron = (ftoi(32.0 * cnt) & 31) < 20;
}

#endif

//==========================================================================
//
//  IM_InitNoState
//
//==========================================================================

void IM_InitNoState(void)
{
    interstate = -1;
    skipintermission = 0;
    cnt = 0.3;
}

//==========================================================================
//
//  IM_DrawNoState
//
//==========================================================================

void IM_DrawNoState(void)
{
#ifdef DOOM2
    // draws which level you are entering..
    if (strcmp(ARR2STR(im->leavemap), "MAP30"))
	{
		IM_DrawEL();
	}
#else
    snl_pointeron = true;
	IM_DrawNextLoc();
#endif
}

//==========================================================================
//
//  IM_UpdateNoState
//
//==========================================================================

void IM_UpdateNoState(void)
{
	cnt -= frametime;
    if (cnt <= 0.0)
    {
	    IM_UnloadData();
#ifdef DOOM2
		IM_InitText();
#else
	    CmdBuf_AddText("TeleportNewMap\n");
	    interstate = -2;
#endif
    }
}

#ifdef DOOM2

//==========================================================================
//
//
//
//==========================================================================

#define	TEXTSPEED	0.1
#define	TEXTWAIT	4.0
#define MAX_INTRMSN_MESSAGE_SIZE	1024

// specifies current state
float		intertime;

int			ClusterMessage[MAX_INTRMSN_MESSAGE_SIZE / 4];

float		HubCount;
string		HubText;

string		TextFlat;

//==========================================================================
//
//	IM_InitText
//
//==========================================================================

void IM_InitText(void)
{
	string		textLump;

    if (cl->deathmatch)
	{
	    CmdBuf_AddText("TeleportNewMap\n");
	    interstate = -2;
		return;
	}

	if (!strcmp(ARR2STR(im->leavemap), "MAP06"))
	{
	    TextFlat = "SLIME16";
		textLump = "FIN1TEXT";
	}
	else if (!strcmp(ARR2STR(im->leavemap), "MAP11"))
	{
	    TextFlat = "RROCK14";
		textLump = "FIN2TEXT";
	}
	else if (!strcmp(ARR2STR(im->leavemap), "MAP20"))
	{
	    TextFlat = "RROCK07";
		textLump = "FIN3TEXT";
	}
	else if (!strcmp(ARR2STR(im->leavemap), "MAP30"))
	{
	    TextFlat = "RROCK17";
		textLump = "FIN4TEXT";
	}
	else if (!strcmp(ARR2STR(im->leavemap), "MAP15") &&
		!strcmp(ARR2STR(im->entermap), "MAP31"))
	{
	    TextFlat = "RROCK13";
		textLump = "SEC1TEXT";
	}
	else if (!strcmp(ARR2STR(im->leavemap), "MAP31") &&
		!strcmp(ARR2STR(im->entermap), "MAP32"))
	{
	    TextFlat = "RROCK19";
		textLump = "SEC2TEXT";
	}
	else
	{
	    CmdBuf_AddText("TeleportNewMap\n");
	    interstate = -2;
	    return;
	}

	LoadTextLump(textLump, &ClusterMessage[0], MAX_INTRMSN_MESSAGE_SIZE);

	HubText = ARR2STR(ClusterMessage);
	HubCount = itof(strlen(HubText)) * TEXTSPEED + TEXTWAIT;

    interstate = 2;
	intertime = 0.0;
#ifdef FIXME
	S_StartSong("D_READ_M", P_GetCDEnd1Track(), true);
#else
	CmdBuf_AddText("music loop D_READ_M\n");
#endif
}

//==========================================================================
//
//	IM_DrawText
//
//==========================================================================

void IM_DrawText(void)
{
    int		count;

    // erase the entire screen to a tiled background
	R_FillRectWithFlat(0, 0, 320, 200, TextFlat);

    // draw some of the text onto the screen
	count = ftoi((intertime - 0.3) / TEXTSPEED);
	if (count < 0)
	{
		count = 0;
	}

	T_SetFont(font_small);
	T_SetAlign(hleft, vtop);
	T_DrawNText(10, 10, HubText, count);
}

//==========================================================================
//
//	IM_UpdateText
//
//==========================================================================

void IM_UpdateText(void)
{
	intertime += frametime;
	if (skipintermission)
	{
		skipintermission = false;
		if (!strcmp(ARR2STR(im->leavemap), "MAP30"))
		{
	  		F_StartFinale();
		}
		else
		{
	  		CmdBuf_AddText("TeleportNewMap\n");
		    interstate = -2;
		}
	}
}

#endif

//==========================================================================
//
//  IM_Drawer
//
//==========================================================================

void IM_Drawer(void)
{
	T_SetFont(font_big);

	IM_DrawBackground();
    
    switch (interstate)
    {
	 case 0:
		if (cl->deathmatch)
		{
			IM_DrawDeathmatchStats();
		}
		else if (cl->maxclients > 1)
		{
			IM_DrawCooperativeStats();
		}
		else
		{
			IM_DrawSingleStats();
		}
		break;

#ifndef DOOM2
	 case 1:
		IM_DrawNextLoc();
		break;
#else
	 case 2:
		IM_DrawText();
		break;
#endif

	 case -1:
	 case -2:
		IM_DrawNoState();
		break;
    }
}

//==========================================================================
//
//	IM_UpdateStats
//
//	Updates stuff each frame
//
//==========================================================================

void IM_UpdateStats(void)
{
    // counter for general background animation
	btime += frametime;

#ifndef DOOM2
	IM_UpdateBackground();
#endif
    switch (interstate)
    {
	 case 0:
		if (cl->deathmatch) IM_UpdateDeathmatchStats();
		else if (cl->maxclients > 1) IM_UpdateCooperativeStats();
		else IM_UpdateSingleStats();
		break;

#ifndef DOOM2
	 case 1:
		IM_UpdateNextLoc();
		break;
#else
	 case 2:
		IM_UpdateText();
		break;
#endif

	 case -1:
		IM_UpdateNoState();
		break;

	 case -2:
		break;
	}
}

//==========================================================================
//
//	FindEpisodeAndMap
//
//==========================================================================

#ifndef DOOM2
void FindEpisodeAndMap(string name, int *epi, int *map)
{
	int		e;
	int		m;

	for (e = 1; e <= 3; e++)
	{
		for (m = 1; m <= 9; m++)
		{
			if (!strcmp(name, va("E%dM%d", e, m)))
			{
				*epi = e;
				*map = m;
				return;
			}
		}
	}
	*epi = 4;
	*map = 1;
}
#endif

//==========================================================================
//
//	IM_Start
//
//==========================================================================

void IM_Start(void)
{
    skipintermission = false;
    cnt = 0.0;
    btime = 0.0;

#ifndef DOOM2
	FindEpisodeAndMap(ARR2STR(im->leavemap), &im_episode, &im_map);
	FindEpisodeAndMap(ARR2STR(im->entermap), &im_nextepisode, &im_nextmap);

	IM_InitAnimatedBack();
#endif

    if (!im->totalkills)
		im->totalkills = 1;

    if (!im->totalitems)
		im->totalitems = 1;

    if (!im->totalsecret)
		im->totalsecret = 1;

    if (cl->deathmatch)
		IM_InitDeathmatchStats();
    else if (cl->maxclients > 1)
		IM_InitCooperativeStats();
    else
		IM_InitSingleStats();

	IM_LoadData();

	// intermission music
#ifdef FIXME
#ifdef DOOM2
	S_StartSong("D_DM2INT", P_GetCDIntermissionTrack(), true);
#else
	S_StartSong("D_INTER", P_GetCDIntermissionTrack(), true);
#endif
#else
#ifdef DOOM2
	CmdBuf_AddText("music loop D_DM2INT\n");
#else
	CmdBuf_AddText("music loop D_INTER\n");
#endif
#endif
}


