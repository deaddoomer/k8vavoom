//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2001 JÆnis Legzdi·ý
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

// MACROS ------------------------------------------------------------------

//
//  Location of statistics, justified according to widget type.
//

#define ST_BGX				0
#define ST_BGY				168

// AMMO number pos.
#define ST_AMMOX			44
#define ST_AMMOY			171

// HEALTH number pos.
#define ST_HEALTHX			90
#define ST_HEALTHY			171

// Frags pos.
#define ST_FRAGSX			138
#define ST_FRAGSY			171

// Weapon pos.
#define ST_ARMSBGX			104
#define ST_ARMSBGY			168
#define ST_ARMSX			111
#define ST_ARMSY			172
#define ST_ARMSXSPACE		12
#define ST_ARMSYSPACE		10

// Location of marine face
#define ST_FACESX			143
#define ST_FACESY			168

// ARMOR number pos.
#define ST_ARMORX			221
#define ST_ARMORY			171

// Key icon positions.
#define ST_KEY0X			239
#define ST_KEY0Y			171
#define ST_KEY1X			239
#define ST_KEY1Y			181
#define ST_KEY2X			239
#define ST_KEY2Y			191

// Ammunition counter.
#define ST_AMMO0X			288
#define ST_AMMO0Y			173
#define ST_AMMO1X			288
#define ST_AMMO1Y			179
#define ST_AMMO2X			288
#define ST_AMMO2Y			191
#define ST_AMMO3X			288
#define ST_AMMO3Y			185

// Indicate maximum ammunition.
// Only needed because backpack exists.
#define ST_MAXAMMO0X		314
#define ST_MAXAMMO0Y		173
#define ST_MAXAMMO1X		314
#define ST_MAXAMMO1Y		179
#define ST_MAXAMMO2X		314
#define ST_MAXAMMO2Y		191
#define ST_MAXAMMO3X		314
#define ST_MAXAMMO3Y		185

//  Fullscreen widgets
#define ST_TDHEALTHX	50
#define ST_TDHEALTHY	180

#define ST_TDARMORX		100
#define ST_TDARMORY		180

#define ST_TDAMMOX		315
#define ST_TDAMMOY		180

//
//  FACE WIDGET MACROS
//

// Number of status faces.
#define ST_NUMPAINFACES		5
#define ST_NUMSTRAIGHTFACES	3
#define ST_NUMTURNFACES		2
#define ST_NUMSPECIALFACES	3

#define ST_FACESTRIDE \
          (ST_NUMSTRAIGHTFACES + ST_NUMTURNFACES + ST_NUMSPECIALFACES)

#define ST_NUMEXTRAFACES	2

#define ST_NUMFACES \
          (ST_FACESTRIDE*ST_NUMPAINFACES+ST_NUMEXTRAFACES)

#define ST_TURNOFFSET		(ST_NUMSTRAIGHTFACES)
#define ST_OUCHOFFSET		(ST_TURNOFFSET + ST_NUMTURNFACES)
#define ST_EVILGRINOFFSET	(ST_OUCHOFFSET + 1)
#define ST_RAMPAGEOFFSET	(ST_EVILGRINOFFSET + 1)
#define ST_GODFACE			(ST_NUMPAINFACES * ST_FACESTRIDE)
#define ST_DEADFACE			(ST_GODFACE + 1)

#define ST_STRAIGHTFACECOUNT	(TICRATE / 2)
#define ST_TURNCOUNT			(1 * TICRATE)
#define ST_EVILGRINCOUNT		(2 * TICRATE)
#define ST_RAMPAGEDELAY			(2 * TICRATE)

#define ST_MUCHPAIN			20

// CONSTANTS ---------------------------------------------------------------

// TYPES -------------------------------------------------------------------

// FUNCTION PROTOTYPES -----------------------------------------------------

// DATA DECLARATIONS -------------------------------------------------------

int sb_height = 32;

//
//  WIDGET DATA
//

// number of frags so far in deathmatch
int st_fragscount;

// current face index, used by w_faces
int st_faceindex = 0;

int st_maxammo[4];

//
//  FACE WIDGET DATA
//

// count until face changes
int st_facecount = 0;

// used for evil grin
boolean oldweaponsowned[NUMWEAPONS];

// used to use appopriately pained face
int st_oldhealth = -1;

int sb_face_lastattackdown = -1;
int sb_face_priority = 0;

int sb_cpo_lastcalc;
int sb_cpo_oldhealth = -1;

//
//  PICS
//

int pic_bar;
int pic_arms;
int pic_tallnum[10];
int pic_yellownum[10];
int pic_graynum[10];
int pic_minus;
int pic_percent;
int pic_faceback;
int pic_faces[ST_NUMFACES];
int pic_keys[6];
int pic_pause;

// CODE --------------------------------------------------------------------

//==========================================================================
//
//  SB_StartMap
//
//==========================================================================

void SB_StartMap(void)
{
	int namebuf[3];
	string name = ARR2STR(namebuf);
	int i;

	pic_bar = R_RegisterPic("STBAR", PIC_PATCH);
	pic_arms = R_RegisterPic("STARMS", PIC_PATCH);

	for (i = 0; i < 10; i++)
	{
		sprint(name, "STTNUM%d", i);
		pic_tallnum[i] = R_RegisterPic(name, PIC_PATCH);
		sprint(name, "STYSNUM%d", i);
		pic_yellownum[i] = R_RegisterPic(name, PIC_PATCH);
		sprint(name, "STGNUM%d", i);
		pic_graynum[i] = R_RegisterPic(name, PIC_PATCH);
	}
	pic_minus = R_RegisterPic("STTMINUS", PIC_PATCH);
	pic_percent = R_RegisterPic("STTPRCNT", PIC_PATCH);

	sprint(name, "STFB%d", cl->clientnum);
	pic_faceback = R_RegisterPic(name, PIC_PATCH);

	for (i = 0; i < 6; i++)
	{
		sprint(name, "STKEYS%d", i);
		pic_keys[i] = R_RegisterPic(name, PIC_PATCH);
	}

	for (i = 0; i < ST_NUMPAINFACES; i++)
	{
		sprint(name, "STFST%d0", i);
		pic_faces[i * ST_FACESTRIDE] = R_RegisterPic(name, PIC_PATCH);
		sprint(name, "STFST%d1", i);
		pic_faces[i * ST_FACESTRIDE + 1] = R_RegisterPic(name, PIC_PATCH);
		sprint(name, "STFST%d2", i);
		pic_faces[i * ST_FACESTRIDE + 2] = R_RegisterPic(name, PIC_PATCH);
		sprint(name, "STFTR%d0", i);
		pic_faces[i * ST_FACESTRIDE + 3] = R_RegisterPic(name, PIC_PATCH);
		sprint(name, "STFTL%d0", i);
		pic_faces[i * ST_FACESTRIDE + 4] = R_RegisterPic(name, PIC_PATCH);
		sprint(name, "STFOUCH%d", i);
		pic_faces[i * ST_FACESTRIDE + 5] = R_RegisterPic(name, PIC_PATCH);
		sprint(name, "STFEVL%d", i);
		pic_faces[i * ST_FACESTRIDE + 6] = R_RegisterPic(name, PIC_PATCH);
		sprint(name, "STFKILL%d", i);
		pic_faces[i * ST_FACESTRIDE + 7] = R_RegisterPic(name, PIC_PATCH);
	}
	pic_faces[ST_GODFACE] = R_RegisterPic("STFGOD0", PIC_PATCH);
	pic_faces[ST_DEADFACE] = R_RegisterPic("STFDEAD0", PIC_PATCH);

	pic_pause = R_RegisterPic("M_PAUSE", PIC_PATCH);

	st_faceindex = 0;
	st_oldhealth = -1;
	for (i = 0; i < NUMWEAPONS; i++)
		oldweaponsowned[i] = cl->weaponowned[i];
}

//==========================================================================
//
//	SB_DrawTallNum
//
//==========================================================================

void SB_DrawTallNum(int x, int y, int num, int trans, boolean perc)
{
	int w;
	int neg;
	picinfo_t info;

	// if non-number, do not draw it
	if (num == 1994)
	{
		return;
	}

	if (perc)
	{
		R_DrawPic2(ST_HEALTHX, ST_HEALTHY, pic_percent, trans);
	}

	R_GetPicInfo(pic_tallnum[0], &info);
	w = info.width;

	neg = num < 0;
	if (neg)
	{
		num = -num;
	}

	// in the special case of 0, you draw 0
	if (!num)
	{
		R_DrawPic2(x - w, y, pic_tallnum[0], trans);
	}

	// draw the new number
	while (num)
	{
		x -= w;
		R_DrawPic2(x, y, pic_tallnum[num % 10], trans);
		num /= 10;
	}

	// draw a minus sign if necessary
	if (neg)
	{
		R_DrawPic2(x - 8, y, pic_minus, trans);
	}
}

//==========================================================================
//
//	SB_DrawSmallNum
//
//==========================================================================

void SB_DrawSmallNum(int x, int y, int num)
{
	int w;
	picinfo_t info;

	if (num < 0)
	{
		num = -num;
	}

	R_GetPicInfo(pic_yellownum[0], &info);
	w = info.width;

	// in the special case of 0, you draw 0
	if (!num)
	{
		R_DrawPic(x - w, y, pic_yellownum[0]);
	}

	// draw the new number
	while (num)
	{
		x -= w;
		R_DrawPic(x, y, pic_yellownum[num % 10]);
		num /= 10;
	}
}

//==========================================================================
//
//	SB_DrawMainBar
//
//==========================================================================

void SB_DrawMainBar(void)
{
	int i;

	//  background
	R_DrawPic(ST_BGX, ST_BGY, pic_bar);

	// ready weapon ammo
	SB_DrawTallNum(ST_AMMOX, ST_AMMOY, cl->ready_ammo, 0, false);

	// health percentage
	SB_DrawTallNum(ST_HEALTHX, ST_HEALTHY, cl->health, 0, true);

	if (deathmatch)
	{
		// frags sum
		SB_DrawTallNum(ST_FRAGSX, ST_FRAGSY, st_fragscount, 0, false);
	}
	else
	{
		// weapons owned
		R_DrawPic(ST_ARMSBGX, ST_ARMSBGY, pic_arms);
		for (i = 0; i < 6; i++)
		{
			if (cl->weaponowned[i + 1])
			{
				R_DrawPic(ST_ARMSX + (i % 3) * ST_ARMSXSPACE,
					ST_ARMSY + (i / 3) * ST_ARMSYSPACE, pic_yellownum[i + 2]);
			}
			else
			{
				R_DrawPic(ST_ARMSX + (i % 3) * ST_ARMSXSPACE,
					ST_ARMSY + (i / 3) * ST_ARMSYSPACE, pic_graynum[i + 2]);
			}
		}
	}

	// faces
	if (netgame)
	{
		R_DrawPic(ST_FACESX, ST_FACESY, pic_faceback);
	}
	R_DrawPic(ST_FACESX, ST_FACESY, pic_faces[st_faceindex]);

	// armor percentage
	SB_DrawTallNum(ST_ARMORX, ST_ARMORY, cl->armorpoints, 0, true);

	// keyboxes 0-2
	if (cl->stats.flags & SBF_BLUE_SKULL)
	{
		R_DrawPic(ST_KEY0X, ST_KEY0Y, pic_keys[3]);
	}
	else if (cl->stats.flags & SBF_BLUE_CARD)
	{
		R_DrawPic(ST_KEY0X, ST_KEY0Y, pic_keys[0]);
	}

	if (cl->stats.flags & SBF_YELLOW_SKULL)
	{
		R_DrawPic(ST_KEY1X, ST_KEY1Y, pic_keys[4]);
	}
	else if (cl->stats.flags & SBF_YELLOW_CARD)
	{
		R_DrawPic(ST_KEY1X, ST_KEY1Y, pic_keys[1]);
	}

	if (cl->stats.flags & SBF_RED_SKULL)
	{
		R_DrawPic(ST_KEY2X, ST_KEY2Y, pic_keys[5]);
	}
	else if (cl->stats.flags & SBF_RED_CARD)
	{
		R_DrawPic(ST_KEY2X, ST_KEY2Y, pic_keys[2]);
	}

	// ammo count (all four kinds)
	SB_DrawSmallNum(ST_AMMO0X, ST_AMMO0Y, cl->ammo[0]);
	SB_DrawSmallNum(ST_AMMO1X, ST_AMMO1Y, cl->ammo[1]);
	SB_DrawSmallNum(ST_AMMO2X, ST_AMMO2Y, cl->ammo[2]);
	SB_DrawSmallNum(ST_AMMO3X, ST_AMMO3Y, cl->ammo[3]);

	// max ammo count (all four kinds)
	SB_DrawSmallNum(ST_MAXAMMO0X, ST_MAXAMMO0Y, st_maxammo[0]);
	SB_DrawSmallNum(ST_MAXAMMO1X, ST_MAXAMMO1Y, st_maxammo[1]);
	SB_DrawSmallNum(ST_MAXAMMO2X, ST_MAXAMMO2Y, st_maxammo[2]);
	SB_DrawSmallNum(ST_MAXAMMO3X, ST_MAXAMMO3Y, st_maxammo[3]);
}

//==========================================================================
//
//	SB_DrawFullscreenStats
//
//==========================================================================

void SB_DrawFullscreenStats(void)
{
	// health
	SB_DrawTallNum(ST_TDHEALTHX, ST_TDHEALTHY, cl->health, 40, false);

	// armor
	SB_DrawTallNum(ST_TDARMORX, ST_TDARMORY, cl->armorpoints, 40, false);

	// ready weapon ammo
	SB_DrawTallNum(ST_TDAMMOX, ST_TDAMMOY, cl->ready_ammo, 40, false);

	if (deathmatch)
	{
		// frags sum
		SB_DrawTallNum(315, 5, st_fragscount, 40, false);
	}
}

//==========================================================================
//
//	SB_DrawPause
//
//==========================================================================

void SB_DrawPause(void)
{
	if (cl->paused && GetCvar("draw_pause"))
	{
		R_DrawPic(126, 4, pic_pause);
	}
}

//==========================================================================
//
//  SB_Drawer
//
//==========================================================================

void SB_Drawer(int sb_view)
{
	if (sb_view == SB_VIEW_FULLSCREEN)
	{
		SB_DrawFullscreenStats();
	}
	else
	{
		SB_DrawMainBar();
	}
	SB_DrawPause();
}

//==========================================================================
//
//  CalcPainOffset
//
//==========================================================================

int CalcPainOffset(void)
{
	int health;

	health = cl->health > 100 ? 100 : cl->health;

	if (health != sb_cpo_oldhealth)
	{
		sb_cpo_lastcalc =
			ST_FACESTRIDE * (((100 - health) * ST_NUMPAINFACES) / 101);
		sb_cpo_oldhealth = health;
	}
	return sb_cpo_lastcalc;
}

//==========================================================================
//
//  UpdateFaceWidget
//
//  This is a not-very-pretty routine which handles the face states and
// their timing.
//  the precedence of expressions is:
//  dead > evil grin > turned head > straight ahead
//
//==========================================================================

void UpdateFaceWidget(void)
{
	int i;
	angle_t badguyangle;
	angle_t diffang;
	boolean doevilgrin;

	// a random number per tick
	int st_randomnumber;

	st_randomnumber = P_Random();

	if (sb_face_priority < 10)
	{
		// dead
		if (!cl->health)
		{
			sb_face_priority = 9;
			st_faceindex = ST_DEADFACE;
			st_facecount = 1;
		}
	}

	if (sb_face_priority < 9)
	{
		if (cl->bonuscount)
		{
			// picking up bonus
			doevilgrin = false;

			for (i = 0; i < NUMWEAPONS; i++)
			{
				if (oldweaponsowned[i] != cl->weaponowned[i])
				{
					doevilgrin = true;
					oldweaponsowned[i] = cl->weaponowned[i];
				}
			}
			if (doevilgrin)
			{
				// evil grin if just picked up weapon
				sb_face_priority = 8;
				st_facecount = ST_EVILGRINCOUNT;
				st_faceindex = CalcPainOffset() + ST_EVILGRINOFFSET;
			}
		}
	}

#ifdef FIXME
	if (sb_face_priority < 8)
	{
		if (cl->damagecount && cl->attacker && cl->attacker != cl->mo)
		{
			// being attacked
			sb_face_priority = 7;

			if (cl->health - st_oldhealth > ST_MUCHPAIN)
			{
				st_facecount = ST_TURNCOUNT;
				st_faceindex = CalcPainOffset() + ST_OUCHOFFSET;
			}
			else
			{
				badguyangle = PointToAngle(cl->mo->x,
					cl->mo->y, cl->attacker->x, cl->attacker->y);

				if (badguyangle > cl->mo->angle)
				{
					// whether right or left
					diffang = badguyangle - cl->mo->angle;
					i = diffang > ANG180;
				}
				else
				{
					// whether left or right
					diffang = cl->mo->angle - badguyangle;
					i = diffang <= ANG180;
				}	// confusing, aint it?

				st_facecount = ST_TURNCOUNT;
				st_faceindex = CalcPainOffset();

				if (diffang < ANG45)
				{
					// head-on
					st_faceindex += ST_RAMPAGEOFFSET;
				}
				else if (i)
				{
					// turn face right
					st_faceindex += ST_TURNOFFSET;
				}
				else
				{
					// turn face left
					st_faceindex += ST_TURNOFFSET + 1;
				}
			}
		}
	}
#endif

	if (sb_face_priority < 7)
	{
		// getting hurt because of your own damn stupidity
		if (cl->damagecount)
		{
			if (cl->health - st_oldhealth > ST_MUCHPAIN)
			{
				sb_face_priority = 7;
				st_facecount = ST_TURNCOUNT;
				st_faceindex = CalcPainOffset() + ST_OUCHOFFSET;
			}
			else
			{
				sb_face_priority = 6;
				st_facecount = ST_TURNCOUNT;
				st_faceindex = CalcPainOffset() + ST_RAMPAGEOFFSET;
			}
		}
	}

#ifdef FIXME
	if (sb_face_priority < 6)
	{
		// rapid firing
		if (cl->attackdown)
		{
			if (sb_face_lastattackdown == -1)
				sb_face_lastattackdown = ST_RAMPAGEDELAY;
			else if (!--sb_face_lastattackdown)
			{
				sb_face_priority = 5;
				st_faceindex = CalcPainOffset() + ST_RAMPAGEOFFSET;
				st_facecount = 1;
				sb_face_lastattackdown = 1;
			}
		}
		else
			sb_face_lastattackdown = -1;
	}
#endif

	if (sb_face_priority < 5)
	{
		// invulnerability
		if (cl->stats.flags & SBF_GOD_MODE)
		{
			sb_face_priority = 4;

			st_faceindex = ST_GODFACE;
			st_facecount = 1;
		}
	}

	// look left or look right if the facecount has timed out
	if (!st_facecount)
	{
		st_faceindex = CalcPainOffset() + (st_randomnumber % 3);
		st_facecount = ST_STRAIGHTFACECOUNT;
		sb_face_priority = 0;
	}

	st_facecount--;
	st_oldhealth = cl->health;
}

//==========================================================================
//
//  SB_UpdateWidgets
//
//==========================================================================

void SB_UpdateWidgets(void)
{
	int i;

	//  Update widget data
	st_fragscount = 0;
	for (i = 0; i < MAXPLAYERS; i++)
	{
		if (i != cl->clientnum)
			st_fragscount += cl->frags[i];
		else
			st_fragscount -= cl->frags[i];
	}
	for (i = 0; i < 4; i++)
	{
		st_maxammo[i] = maxammo[i] * (cl->backpack ? 2 : 1);
	}
	UpdateFaceWidget();
}

//**************************************************************************
//
//  $Log$
//  Revision 1.6  2001/10/09 17:36:57  dj_jl
//  Added flags for status bar
//
//  Revision 1.5  2001/10/02 17:37:19  dj_jl
//  Removed status bar widgets
//
//  Revision 1.4  2001/09/24 17:24:09  dj_jl
//  Beautification
//
//  Revision 1.3  2001/08/29 17:46:25  dj_jl
//  Moved view border and message box to progs
//  
//  Revision 1.2  2001/07/27 14:27:51  dj_jl
//  Update with Id-s and Log-s, some fixes
//
//**************************************************************************
