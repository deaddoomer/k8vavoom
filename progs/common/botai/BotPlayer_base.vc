//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//
//  This section contains the main bot AI. The
//  main bot AI loop, B_Think, is called every tic.
//  Also included are various bot decision-making
//  procedures, such as B_CheckStuff and B_SetEnemy.
//
//**************************************************************************
//class RocketLauncher : Weapon decorate;

// Main bot class
class BotPlayerBase : GameObject;

// random bot names
array!string BotNames;


#define BOT_ALLOW_JUMPS

const float FORWARDWALK = 200.0;
const float FORWARDRUN  = 400.0;
const float SIDEWALK    = 192.0;
const float SIDERUN     = 320.0;

/*const float MAX_TRAVERSE_DIST     (1024*FRACUNIT) //10 meters, used within b_func.c*/
const float MAX_TRAVERSE_DIST = 307.2; // 3 meters, used within b_func.c -> 1 meter = 102.4 units
const float AVOID_DIST        = 512.0; // try to avoid incoming missiles once they reached this close
const float SAFE_SELF_MISDIST = 128.0; // distance from self to target where it's safe to pull a rocket
/*const float FRIEND_DIST         (128*FRACUNIT)  //To friend.
const float DARK_DIST         (256*FRACUNIT)  //Distance that bot can see enemies in the dark from.
const float WHATS_DARK          64        //light value thats classed as dark.
const float MAX_MONSTER_TARGET_DIST   (1024*FRACUNIT) //Too high can slow down the performance, see P_mobj.c*/
const float ENEMY_SCAN_FOV = 120.0;
const float MAXSTEPHEIGHT = 32.0;
const float MAXJUMPHEIGHT = 56.0;
const float MAXMOVEHEIGHT = MAXJUMPHEIGHT;
const float MAXDROPHEIGHT = 384.0;
/*const float MAXMOVEHEIGHT       (32*FRACUNIT) //MAXSTEPMOVE but with jumping counted in.
const float GETINCOMBAT         (512*FRACUNIT)  //Max distance to item. if it's due to be icked up in a combat situation.*/
const float SHOOTFOV = 60.0;
/*const float MAXROAM           (5*TICRATE)   //When this time is elapsed the bot will roam after something else.*/
const float MONSTER_SCAN_RADIUS = 2048.0;

const float ITEM_GIVEUP_TIME = 1.5; // if bot cannot get item for this time, ignore it
const float ITEM_IGNORE_TIME = 10.0; // time bot should ignore item
const float ITEM_IGNORE_TIME_DEVIATION = 3.0; // random deviation for ignore time

bool lastPathCheckJump = false;
bool lastPathCheckUse = false;


/*
  Class definitions for botinfo, chatinfo, and
  other various bot information thingamabobers.
*/

enum {
  bsk_verypoor,
  bsk_poor,
  bsk_low,
  bsk_medium,
  bsk_high,
  bsk_excellent,
  bsk_supreme
};

struct botinfo_t {
  string Name;    // bot's name
  int accuracy;   // accuracy with "instant" weapons (this includes "leading")
  int intelect;   // accuracy with "missile" weapons (rocket launcher, etc.)
  int evade;      // ability to dodge incoming missiles
  int anticip;    // ability to anticipate "instant" shots
  int reaction;   // overall reaction time (lower is "better")
/*
  int pisschance;   // chance the bot will get pissed when his threshold is reached
  int threshold;    // how much it takes to frustrate/piss off the bot
  int dangerlevel;  // when health is below this, we need some health
  int wpfav;      // favorite weapon
  int chatinfo;   // bot's chat strings
  int chattime;   // how long it takes us to type a line
  int chatty;     // how talkative the bot is
  char *colour;   // colour (in form of a string)
  char *gender;   // male/female/it :)
  char *skin;     // skin
  int railcolour;   // railgun trail colour
  bool revealed;    // hidden bots must be revealed
*/
  string userinfo;
};

/*
struct chatline_t {
  char *string;
  chattype_t bot;
  chatline_t *line;
};

struct chatinfo_t {
  chatline_t intro[5];
  chatline_t inter[5];
  chatline_t rare[5];
  chatline_t frag[15];
  chatline_t died[10];
  chatline_t roam[10];
  chatline_t pissed[5];
  chatline_t frustrated[5];
  chatline_t special[20];
} chatinfo_t;
*/

// The things the bot knows about their enemy
/*
struct enemyinfo_t {
  int health;
  weapontype_t weap;
};
*/

//
// Bot states
//
enum {
  BST_NOTHING, // deciding what to do
  BST_OFFENSE, // bot is "fetching" something (skull, whatever)
  BST_DEFENSE, // bot is defending something
  BST_RETURN, // bot is heading to scoring place
};


Player player; // points to reference player
Actor botmo;
Actor ITarget;  // immediate target (where to go) (k8: currently unused)

// destinations
Actor item; // item (roam towards weapon, etc)
float itemFirstSeenTime; // so bot can give up if it cannot reach item for some time
bool bItemIsWeapon;
bool bItemIsPowerup;
Actor goal; // teamgame goal spot
Actor node; // node we're heading towards
Actor prev; // previous node we were at
TVec posdest; // position of our destination (doesn't have to be an actor)
bool posdest_valid;
Actor enemy; // the dead meat
TVec lastpos; // last place we saw our enemy
bool lastpos_valid;
Actor missile; // a threathing missile that got to be avoided

Actor ally; // ally to tag along with
float t_strafe;
float t_react;
float t_fire; // seconds left until our gun will actually fire again
float t_shootcooldown;

float forwardmove; // for building ucmd
float sidemove;

// misc booleans
bool bAllRound;
bool bNewItemIsWeapon;
bool bNewItemIsPowerup;

botinfo_t info; // aiming, name, perfection, yadda yadda

int angerlevel;

float angle; // the wanted angle that the bot tries to get every tic

// bot options
bool boptCheckWimpyWeapon = true;
array!Weapon weaponList;

// bot will ignore item if it cannot obtain it for some time
dictionary!(Actor, float) itemIgnoreTimeout;



//==========================================================================
//
//  PutItemToIgnoreList
//
//  put item into ignore list
//
//==========================================================================
final void PutItemToIgnoreList (Actor item, optional float timeoutMult) {
  if (!item || !item.IsDestroyed()) return;
  if (!specified_timeoutMult) timeoutMult = 1;
  float currTime = botmo.XLevel.Time;
  float timeout = ITEM_IGNORE_TIME+(FRandomFull()-0.5)*(ITEM_IGNORE_TIME_DEVIATION*2);
  timeout *= timeoutMult;
  timeout += currTime;
  if (GetCvarB('bot_developer_messages_items')) print("bot '%s' gives up on %C for %s", player.PlayerName, item.Class, timeout-currTime);
  itemIgnoreTimeout.put(item, timeout);
}


//==========================================================================
//
//  BotTick
//
//  Main bot function
//
//==========================================================================
void BotTick (float deltaTime) {
  botmo = Actor(player.MO);

  //print("BOTMO is %C", botmo);

  player.ForwardMove = 0.0;
  player.SideMove = 0.0;
  player.FlyMove = 0.0;
  player.Buttons = 0;

  // we're dead, so hit space to respawn
  if (!player.Health) {
    player.Buttons |= BT_USE;
    return;
  }

  // weed out any bad destinations/enemies
  CheckStuff();

  // destination setting
  SetEnemy();
  Scan();

  // turning towards destination
  BotAim();
  Turn();

  // moving towards destination
  Attack();
  Move(deltaTime);

  //Pitch();

  // only walk if we're on skill 0
  if (!MainGameInfo(player.Level.Game).botskill || GetCvarB('bot_no_run')) {
    if (forwardmove == FORWARDRUN) forwardmove = FORWARDWALK;
    if (forwardmove == -FORWARDRUN) forwardmove = -FORWARDWALK;
    if (sidemove == SIDERUN) sidemove = SIDEWALK;
    if (sidemove == -SIDERUN) sidemove = -SIDEWALK;
  }

  player.SideMove = sidemove;
  player.ForwardMove = forwardmove;

  t_react = fmax(0, t_react-deltaTime);
  t_shootcooldown = fmax(0, t_shootcooldown-deltaTime);
  t_fire = fmax(0, t_fire-deltaTime);
}


//==========================================================================
//
//  AngleTo
//
//==========================================================================
final float AngleTo (TVec dest) {
  TAVec ang;
  TVec dir = dest-botmo.Origin;
  VectorAngles(dir, out ang);
  return ang.yaw;
}


//==========================================================================
//
//  PitchTo
//
//==========================================================================
final float PitchTo (TVec dest, optional bool useRealHeight) {
  TVec org = botmo.Origin;
  if (useRealHeight) org.z += botmo.Height*0.5-botmo.FloorClip+player.GetAttackZOfs;

  TAVec ang;
  TVec dir = dest-org;

  VectorAngles(dir, out ang);
  return ang.pitch;
}


//==========================================================================
//
//  PitchToEntity
//
//==========================================================================
final float PitchToEntity (EntityEx ent, optional bool useRealHeight) {
  if (!ent) return 0;
  TVec eorig = ent.Origin;
  if (useRealHeight) eorig.z += ent.Height*0.95-ent.FloorClip;

  TVec org = botmo.Origin;
  if (useRealHeight) org.z += botmo.Height*0.5-botmo.FloorClip+player.GetAttackZOfs;

  TAVec ang;
  TVec dir = eorig-org;

  VectorAngles(dir, out ang);
  return ang.pitch;
}


//==========================================================================
//
//  CheckWeaponItem
//
//  return `true` to exit from `CheckItem` with `res` result
//  otherwise `res` has no meaning
//
//==========================================================================
bool CheckWeaponItem (Weapon Wpn, out bool res) {
  if (!Wpn) return false;

  // if we don't have the weapon, pick it up
  Weapon exwpn = Weapon(botmo.FindInventory(class!Inventory(Wpn.Class)));
  if (!exwpn) { res = true; return true; }

  if (!Wpn.CanPickupForAmmo(exwpn)) { res = false; return true; }

  // if we have no more room for the ammo it gives
  auto ammo1 = (Wpn.AmmoType1 ? botmo.FindInventory(Wpn.AmmoType1) : none);
  if (ammo1 && ammo1.Amount == ammo1.MaxAmount) { res = false; return true; }

  // can't pick it up because we have it and it's not a dropped weapon
  if (!Wpn.bDropped) { res = false; return true; }

  res = true;
  return true;
}


//==========================================================================
//
//  CheckSpecialItem
//
//  return `true` to exit from `CheckItem` with `res` result
//  otherwise `res` has no meaning
//
//==========================================================================
bool CheckSpecialItem (Actor item, out bool res) {
  return false;
}


//==========================================================================
//
//  CheckAmmoItem
//
//  return `true` to exit from `CheckItem` with `res` result
//  otherwise `res` has no meaning
//
//==========================================================================
bool CheckAmmoItem (Ammo ammo, out bool res) {
  // if we have no more room for the ammo it gives
  Inventory AmmoItem = botmo.FindInventory(ammo.GetParentAmmo());
  if (AmmoItem && AmmoItem.Amount >= AmmoItem.MaxAmount) { res = false; return true; }

  res = true;
  return true;
}


//==========================================================================
//
//  CheckOtherItem
//
//  return `true` to exit from `CheckItem` with `res` result
//  otherwise `res` has no meaning
//
//==========================================================================
bool CheckOtherItem (Actor item, out bool res) {
  if (Health(item) && botmo.Health >= Player::MAXHEALTH) { res = false; return true; }
  //if ((item.Class == Soulsphere || item.Class == Megasphere) && botmo.Health >= 2*Player::MAXHEALTH) return false;

  BasicArmor Armor = BasicArmor(botmo.FindInventory(BasicArmor));
  if (!Armor) return false;

  if (BasicArmorPickup(item) && (Armor.Amount >= BasicArmorPickup(item).SaveAmount)) { res = false; return true; }
  //if (item.Class == Megasphere && Armor.Amount >= 200) return false;

  return false;
}


//==========================================================================
//
//  CheckItem
//
//  Determines if we should bother picking up an item or not
//
//==========================================================================
bool CheckItem (Actor item) {
  bool res;

  bNewItemIsWeapon = false;
  bNewItemIsPowerup = false;

  if (!item) return false;
  if (!item.bSpecial) return false;

  Weapon Wpn = Weapon(item);
  if (Wpn) {
    bNewItemIsWeapon = true;
    if (CheckWeaponItem(Wpn, out res)) return res;
  }

  if (CheckSpecialItem(item, out res)) return res;

  Ammo ammo = Ammo(item);
  if (ammo && CheckAmmoItem(ammo, out res)) return res;

  if (CheckOtherItem(item, out res)) return res;

  // guess we're okay
  return true;
}


//==========================================================================
//
//  SetEnemy
//
//==========================================================================
void SetEnemy () {
  if (enemy && enemy.Health > 0 && player.MO && player.MO.CanSee(enemy)) {
    return;
  }

  bAllRound = !!enemy;
  enemy = FindEnemy();

  if (!enemy) return;

  // double check the validity of the enemy
  if (!enemy.bShootable) enemy = none;
}


//==========================================================================
//
//  CheckTo
//
//  Checks if an location is reachable
//
//==========================================================================
bool CheckTo (TVec pos) {
  float dist = Length2D(botmo.Origin-pos);
  float an = GetAngle();
  if (!CheckPath(an, dist, onlyCheck:true)) return false;
  return true;
}


//==========================================================================
//
//  CheckStuff
//
//  Make sure that our destinations/enemies and everything are valid.
//
//==========================================================================
void CheckStuff () {
  if (item) {
    if (!item.bSpecial || item.IsDestroyed() || // somebody picked
        !CheckTo(item.Origin)) // can't reach
    {
      PutItemToIgnoreList(item, 0.8);
      item = none;
      itemFirstSeenTime = 0;
    }
  }

  if (missile) {
    if (!missile.bMissile || missile.IsDestroyed()) missile = none;
  }

  if (node) {
    if (!CheckTo(node.Origin) || botmo.DistTo2(node) < botmo.Radius) {
      prev = node;
      node = none;
    }
  }

  if (posdest_valid) {
    TVec dir = posdest-botmo.Origin;
    dir.z = 0.0;
    if (Length2D(dir) < botmo.Radius || !CheckTo(posdest)) {
      posdest_valid = false;
    }
  }

  if (lastpos_valid) {
    TVec dir = lastpos-botmo.Origin;
    dir.z = 0.0;
    if (Length2D(dir) < botmo.Radius || !CheckTo(lastpos)) {
      lastpos_valid = false;
    }
  }

  if (enemy) {
    if (enemy.IsDestroyed() || enemy.Health <= 0 || !enemy.bShootable) enemy = none;
  }
}


//==========================================================================
//
//  Scan
//
//  Scan all mobj's visible to the bot for incoming missiles, enemies, and
//  various items to pick up.
//
//==========================================================================
void Scan () {
  float currTime = botmo.XLevel.Time;

  // check if bot tried to get current item for too long
  if (item) {
    if (currTime-itemFirstSeenTime > ITEM_GIVEUP_TIME) {
      PutItemToIgnoreList(item);
      item = none;
      itemFirstSeenTime = 0;
    }
  }

  Entity ee;
  foreach botmo.RadiusThings(out ee, botmo.Origin, MONSTER_SCAN_RADIUS) {
    Actor actor = Actor(ee);
    if (!actor) continue;
    if (!actor.bSpecial && !actor.bMissile) {
      // not interested in this one
      continue;
    }
    if (Check_LOS(actor, 90.0)) {
      // look for special items
      if (!item && actor.bSpecial) {
        // check if we should ignore this item
        auto dip = itemIgnoreTimeout.find(actor);
        if (dip) {
          if (*dip >= currTime) continue; // ignore it
          if (GetCvarB('bot_developer_messages_items')) print("bot '%s' wants %C again (%s)", player.PlayerName, actor.Class, currTime-(*dip));
          // it is ok to obtain, remove from list
          itemIgnoreTimeout.del(actor);
        }
        if (CheckItem(actor)) {
          if (GetCvarB('bot_developer_messages_items')) print("bot '%s' wants %s", player.PlayerName, actor.Class);
          item = actor;
          bItemIsWeapon = bNewItemIsWeapon;
          bItemIsPowerup = bNewItemIsPowerup;
        } else {
          if (GetCvarB('bot_developer_messages_items')) print("bot '%s' ignores %s", player.PlayerName, actor.Class);
        }
      } else if (!missile && actor.bMissile && botmo.DistTo(actor) < AVOID_DIST) {
        missile = actor;
      }
    }
  }
}


//==========================================================================
//
//  SkillLower
//
//==========================================================================
int SkillLower (int skill, int num) {
  if (num <= 0) return skill;
  skill = max(0, skill-num);
  return skill;
}


//==========================================================================
//
//  SetAngle
//
//==========================================================================
final void SetAngle (float an) {
  angle = AngleMod360(an);
}


//==========================================================================
//
//  GetAngle
//
//==========================================================================
final float GetAngle () {
  return angle;
}


//==========================================================================
//
//  IsDangerous
//
//  Checks if a sector is dangerous.
//
//==========================================================================
bool IsDangerous (sector_t *sec) {
  return false;
}


//==========================================================================
//
//  DistToPlane
//
//==========================================================================
final float DistToPlane (const ref TPlane plane, const ref TVec point) {
  return fabs(DotProduct(point, plane.normal));
}


//==========================================================================
//
//  PerformLastCheckActions
//
//==========================================================================
void PerformLastCheckActions () {
#ifdef BOT_ALLOW_JUMPS
  if (lastPathCheckJump && !GetCvarB('bot_no_jump')) player.Buttons |= BT_JUMP;
#endif
  if (lastPathCheckUse) EntityEx(player.MO).UseLines(Player::USERANGE, Player::USETHINGRANGE, '*usefail');
  lastPathCheckJump = false;
  lastPathCheckUse = false;
}


//==========================================================================
//
//  CheckPath
//
//  Checks for obstructions at a certain angle and distance. Returns true if
//  the path is clear, and false is the path is blocked.
//
//==========================================================================
bool CheckPath (float ang, float dist, optional bool onlyCheck, optional out float maxdist) {
  intercept_t *in;
  TVec bottracedir;

  maxdist = 0;

  float bottracerange = dist;
  sincos(ang, out bottracedir.y, bottracedir.x);
  bottracedir.z = 0.0;
  float x1 = botmo.Origin.x;
  float y1 = botmo.Origin.y;
  float x2 = x1+dist*bottracedir.x;
  float y2 = y1+dist*bottracedir.y;

  //EntityEx(player.MO).UseLines(Player::USERANGE, Player::USETHINGRANGE, '*usefail');

  //bool lastPathCheckJump = false;
  //bool lastPathCheckUse = false;

  float distance_passed = 0;

  foreach botmo.PathTraverse(in, x1, y1, x2, y2, PT_ADDLINES|PT_ADDTHINGS/*|PT_EARLYOUT*/) {
    distance_passed = dist*in->frac;
    if (in->bIsALine) {
      sector_t *back;
      sector_t *front;
      opening_t *open;
      //float diffheight;

      line_t *ld = in->line; // this linedef
      TVec hit_point = botmo.Origin+(bottracerange*in->frac)*bottracedir;

      // [CW]
      if (distance_passed <= Player::USERANGE && (in->line->SpacFlags&(SPAC_UseThrough|SPAC_Use))) {
        // [FB] Use lines
        //EntityEx(player.MO).UseLines(Player::USERANGE, Player::USETHINGRANGE, '*usefail');
        lastPathCheckUse = true;
      }

      // line is impassible
      if (!(ld->flags&ML_TWOSIDED) || (ld->flags&(ML_BLOCKING|ML_BLOCKPLAYERS|ML_BLOCKEVERYTHING))) return false;

      // line isn't two sided
      if (!ld->backsector) return false;

      if (!PointOnPlaneSide(botmo.Origin, *ld)) {
        back = ld->backsector;
        front = ld->frontsector;
      } else {
        back = ld->frontsector;
        front = ld->backsector;
      }

      // sector is dangerous
      if (IsDangerous(back)) return false;

      // crosses a two sided line
      //open = LineOpenings(ld, hit_point);
      //open = FindOpening(open, hit_point.z, hit_point.z+botmo.Height);
      open = FindLineOpening(ld, hit_point, botmo.Height, do3dmidtex:true);
      // no valid openings
      if (!open) return false;

      /+
      float diffheight = GetPlanePointZ(ref back->floor, hit_point)-GetPlanePointZ(ref front->floor, hit_point);

      // no cliff jumping unless we're going after something
      if (-diffheight > 32.0 && !enemy) return false;

      if (diffheight > 0.0) {
        if (diffheight > 48.0) {
          /*
          if (front->SSpecial == ThrustThingZ || front->springpadzone) {
            if (P_GetPlayerNum(bot->player) == displayplayer && netstate != NS_SERVER) {
              Printf (PRINT_HIGH, "B_CheckPath: Bouncy sector, should be okay\n");
            }
            return true;
          }
          else
          */
          return false;
        } else if (diffheight <= 48.0 && diffheight >= 24.0) {
          //botmo.Player.Buttons |= BT_JUMP;
          lastPathCheckJump = true;
        }
      }
      +/

      // [FB] No cliff jumping unless we're going after something
      if ((open->lowfloor-open->bottom) >= MAXMOVEHEIGHT &&
          (open->lowfloor-open->bottom) <= MAXDROPHEIGHT &&
          !(enemy && enemy == ITarget))
      {
        return false;
      }

      // [FB] Determine if it's wise to jump up to a floor
      float diffheight = open->bottom-open->lowfloor;

      if (diffheight > 0.0) {
        if (diffheight >= MAXSTEPHEIGHT && diffheight <= MAXJUMPHEIGHT) {
          if (distance_passed <= 48.0) {
            //player.Buttons |= BT_JUMP;
            lastPathCheckJump = true;
          }
          continue;
        } else if (diffheight >= MAXJUMPHEIGHT) {
          // CHECKME!!
          /*if (front->SSpecial == ThrustThingZ || front->springpadzone) return true; else*/
          return false;
        }
      }
    } else {
      Actor th = Actor(in->Thing);
      if (!th) continue;
      if (th == botmo) continue;
      //if (th.bSolid) return false;

      if (th.bSolid && th != enemy) {
        // [FB] Jump to avoid something
        float dheight = th.Origin.z+th.Height-botmo.Origin.z;
        if (dheight >= MAXSTEPHEIGHT && dheight <= MAXJUMPHEIGHT) {
          //player.Buttons |= BT_JUMP;
          lastPathCheckJump = true;
          continue;
        }
        return false;
      }

      // [FB] Jump to reach something
      float dheight = th.Origin.z+th.Height-botmo.Origin.z;
      if (dheight >= MAXSTEPHEIGHT && dheight <= MAXJUMPHEIGHT) {
        //player.Buttons |= BT_JUMP;
        lastPathCheckJump = true;
        continue;
      }

      /*
      fixed_t diffheight = (th->z + th->Height) - shootthing->z;
      if (diffheight > 0) {
        if (diffheight <= 48*FRACUNIT && diffheight >= 24*FRACUNIT) {
          bot->player->cmd.ucmd.buttons |= BT_JUMP;
          return true;
        }
        else if (diffheight <= 24*FRACUNIT)
          return true;
        else
          return false;
      }
      */
    }

    // [CW] Since this method is for short distances only, we should
    //      break the procedure after certain distance is reached
    //if (distance_passed >= MAX_TRAVERSE_DIST) break;
  }

  if (distance_passed < 1) return false;

  if (!lastPathCheckJump) {
    auto oldCWT = botmo.bColideWithThings;
    scope(exit) botmo.bColideWithThings = oldCWT;
    if (!botmo.CheckPosition(botmo.Origin+bottracedir*distance_passed)) {
      if (GetCvarB('bot_developer_messages_checkpos')) print("bot '%s' CheckPosition falied at %s (distance=%s)", player.PlayerName, botmo.Origin+bottracedir*distance_passed, distance_passed);
      return false;
    }
  }

#ifdef BOT_ALLOW_JUMPS
  if (!onlyCheck && lastPathCheckJump && !GetCvarB('bot_no_jump')) { player.Buttons |= BT_JUMP; lastPathCheckJump = false; }
#endif
  if (!onlyCheck && lastPathCheckUse) { EntityEx(player.MO).UseLines(Player::USERANGE, Player::USETHINGRANGE, '*usefail'); lastPathCheckUse = false; }

  maxdist = distance_passed;
  return true;
}


//==========================================================================
//
//  Check_LOS
//
//  Doesnt check LOS, checks visibility with a set view angle.
//  B_Checksight checks LOS (straight line)
//
//  Check if mo1 has free line to mo2 and if mo2 is within mo1 viewangle
// (vangle) given with normal degrees. If these conditions are true, the
// function returns true. GOOD TO KNOW is that the players view angle in
// doom is 90 degrees infront.
//
//==========================================================================
final bool Check_LOS (Actor to, float vangle, optional bool skipCanSee) {
  if (!to) return false;
  if (vangle <= 0) return false; // looker seems to be blind
  if (vangle < 360.0) {
    // check FOV
    if (fabs(AngleMod180(AngleTo(to.Origin)-botmo.Angles.yaw)) > vangle/2.0) return false;
  }
  if (!skipCanSee && !botmo.CanSee(to)) return false; // out of sight
  return true;
}


//==========================================================================
//
//  GoodAngle
//
//==========================================================================
final bool GoodAngle (Actor to, float vangle) {
  if (!to) return true;
  if (vangle <= 0) return false; // looker seems to be blind
  if (vangle >= 360.0) return true;
  // check FOV
  return (fabs(AngleMod180(AngleTo(to.Origin)-botmo.Angles.yaw)) <= vangle/2.0);
}


//==========================================================================
//
//  BotAimProjectile
//
//==========================================================================
void BotAimProjectile (float dist, bool right, float an) {
  if (!enemy) return; // just in case

  // splash weapons
  //bot->SetAngle(R_PointToAngle2(MO->x, MO->y, enemy->x, enemy->y));

  // [BC] cajun prediction
  // here goes the prediction.
  float m = dist/875.0; //FIXME: determine current weapon's missile speed
  float px = enemy.Origin.x+(enemy.Velocity.x*m*2.0);
  float py = enemy.Origin.y+(enemy.Velocity.y*m*2.0);

  // projectile weapons
  switch (info.intelect) {
    case bsk_verypoor:
    case bsk_poor:
      if (MainGameInfo(player.Level.Game).botskill > 3 && Random() < 0.01) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      } else {
        // aim right at the enemy
        SetAngle(an);
      }
      break;
    case bsk_low:
      if (MainGameInfo(player.Level.Game).botskill > 2 && Random() < 0.03) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      } else {
        // aim right at the enemy
        SetAngle(an);
      }
      break;
    case bsk_medium:
      if (MainGameInfo(player.Level.Game).botskill > 2 && Random() < 0.09) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      } else {
        if (right) SetAngle(an+Random()*20.0); else SetAngle(an-Random()*20.0);
      }
      break;
    case bsk_high:
      if (MainGameInfo(player.Level.Game).botskill > 1 && Random() < 0.9) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      }
      else {
        if (right) SetAngle(an+Random()*20.0); else SetAngle(an-Random()*20.0);
      }
      break;
    case bsk_excellent:
      if (MainGameInfo(player.Level.Game).botskill > 1 && Random() < 0.3) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      } else {
        if (right) SetAngle(an+Random()*20.0); else SetAngle(an-Random()*20.0);
      }
      break;
    case bsk_supreme:
      if (MainGameInfo(player.Level.Game).botskill > 0 && Random() < 0.1) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      } else {
        if (right) SetAngle(an+Random()*20.0); else SetAngle(an-Random()*20.0);
      }
      break;
    default:
      Error("Unknown bot skill level: %d", info.intelect);
      return;
  }
}


//==========================================================================
//
//  BotAimInstant
//
//  instant weapons
//
//==========================================================================
void BotAimInstant (float dist, bool right, float an) {
  // [CW]
  if (info.accuracy > bsk_verypoor && info.accuracy <= bsk_high && dist <= EntityEx::MELEERANGE*2.0) {
    SetAngle(an);
    return;
  }

  //FIXME: Implement botskill, accuracy, and intelligence
  switch (info.accuracy) {
    case bsk_verypoor:
      if (right) SetAngle(an+Random()*60.0); else SetAngle(an-Random()*60.0);
      break;
    case bsk_poor:
      if (right) SetAngle(an+Random()*45.0); else SetAngle(an-Random()*45.0);
      break;
    case bsk_low:
      if (right) SetAngle(an+Random()*30.0); else SetAngle(an-Random()*30.0);
      break;
    case bsk_medium:
      if (right) SetAngle(an+Random()*15.0); else SetAngle(an-Random()*15.0);
      break;
    case bsk_high:
      SetAngle(an);
      break;
    case bsk_excellent:
      SetAngle(AngleTo(enemy.Origin+enemy.Velocity*0.1));
      break;
    case bsk_supreme://FIXME
      SetAngle(AngleTo(enemy.Origin+enemy.Velocity*0.1));
      break;
    default:
      Error("BotPlayer::AimInstant::Unknown bot accuracy skill level: %d", info.accuracy);
      return;
  }
}


//==========================================================================
//
//  BotAimSpecial
//
//==========================================================================
bool BotAimSpecial (float dist, bool right, float an) {
  /*
  if (player.ReadyWeapon.bBotBfg) {
    // BFG9000
    SetAngle(AngleTo(enemy.Origin));
    return true;
  }
  */
  return false;
}


//==========================================================================
//
//  BotAim
//
//==========================================================================
void BotAim () {
  float dist;
  bool right;
  float an;

  if (!enemy) return;

  if (t_react) return;

  // distance to enemy
  dist = botmo.DistTo2(enemy);

  right = !!(P_Random()&1);
  an = AngleTo(enemy.Origin);

  //Pitch(); // do it in attack code instead

  if (BotAimSpecial(dist, right, an)) return;

  if (player.ReadyWeapon.bBotProjectile) {
    BotAimProjectile(dist, right, an);
  } else {
    BotAimInstant(dist, right, an);
  }
}


//==========================================================================
//
//  FindMonsterEnemy
//
//==========================================================================
Actor FindMonsterEnemy () {
  auto oldEnemy = enemy;
  scope(exit) enemy = oldEnemy;
  // if we have no enemy, but an attacker, switch to attacker
  Actor narrowTarget = none;
  float bestNarrowDist = float.max;
  Actor roughTarget = none;
  float bestRoughDist = float.max;

  Entity ee;
  foreach botmo.RadiusThings(ee, botmo.Origin, MONSTER_SCAN_RADIUS) {
    if (ee == botmo) continue; // don't target self
    Actor act = Actor(ee);
    if (!act) continue;
    if (!act.bShootable || !act.bMonster || act.bMissile) continue; // not interesting
    if (act.Health <= 0) continue; // it is dead
    float temp = act.DistTo(botmo);
    if (temp < 512 && temp < bestNarrowDist && GoodAngle(act, 120)) {
      enemy = act; // for `Check_LOS()`
      if (Check_LOS(act, 360) || CheckTo(act.Origin)) {
        bestNarrowDist = temp;
        narrowTarget = act;
      }
    }
    if (!roughTarget && temp < bestRoughDist && GoodAngle(act, 180)) {
      enemy = act; // for `Check_LOS()`
      if (Check_LOS(act, 360) || CheckTo(act.Origin)) {
        bestRoughDist = temp;
        roughTarget = act;
      }
    }
  }

  if (narrowTarget) return narrowTarget;
  if (roughTarget) return roughTarget;

  // if no targets, and we are in coop, attack the monster than hurts the player
  // roughTarget is for fellow bot, narrowTarget is for human player
  if (!player.Level.Game.deathmatch) {
    //print("looking for other player's offenders...");
    bestNarrowDist = float.max;
    bestRoughDist = float.max;
    foreach (auto i; 0..MAXPLAYERS) {
      auto plr = player.Level.Game.Players[i];
      if (!plr) continue;
      if (!plr.bSpawned /*|| plr.MO.Health <= 0*/ || botmo == plr.MO) continue;
      auto act = Actor(PlayerEx(plr).Attacker);
      if (!act || !act.bMonster || act.bMissile || act.Health <= 0) continue;
      if (!Check_LOS(act, 120)) continue;
      if (GetCvarB('bot_developer_messages_attack')) print("  bot '%s': player %d offender is %C", player.PlayerName, i, act);
      float dist = botmo.DistTo2(act);
      if (plr.bIsBot) {
        if (!roughTarget || dist < bestRoughDist) { roughTarget = act; bestRoughDist = dist; }
      } else {
        if (!narrowTarget || dist < bestNarrowDist) { narrowTarget = act; bestNarrowDist = dist; }
      }
    }

    //print(" narrow: %C; rough: %C", narrowTarget, roughTarget);
    return (narrowTarget ? narrowTarget : roughTarget);
  }

  return none;
}


//==========================================================================
//
//  FindEnemy
//
//==========================================================================
Actor FindEnemy () {
  // note: it's hard to ambush a bot who is not alone
  float vangle = (bAllRound || ally ? 360.0 : ENEMY_SCAN_FOV);
  bAllRound = false;

  Actor target = none;
  float closest_dist = 99999.0;

  // if we have no enemy, but an attacker, switch to attacker
  if (!enemy && player.Attacker) {
    Actor act = Actor(player.Attacker);
    if (act && act.Health > 0 && act.bShootable && (act.bMonster || act.bIsPlayer)) {
      if (act.bIsPlayer || Check_LOS(act, 120)) {
        if (GetCvarB('bot_developer_messages_attack')) print("bot '%s' is retaliating to %C", player.PlayerName, act);
        return act;
      }
    }
  }

  bool ignoreHumans = GetCvarB('bot_ignore_humans');

  if (player.Level.Game.deathmatch) {
    // search for player enemies in deathmatch
    foreach (auto i; 0..MAXPLAYERS) {
      auto plr = player.Level.Game.Players[i];
      if (!plr) continue;
      if (plr.bSpawned && plr.MO.Health > 0 && botmo != plr.MO) {
        if (ignoreHumans && !plr.bIsBot) continue;
        float temp = plr.MO.DistTo(botmo);
        if (temp < closest_dist) {
          if (Check_LOS(Actor(plr.MO), vangle)) {
            closest_dist = temp;
            target = Actor(plr.MO);
          }
        }
      }
    }
  }

  // if no target, try to find some monster
  if (!target) target = FindMonsterEnemy();

  return target;
}


//==========================================================================
//
//  RoamRandom
//
//  support function for roaming
//  returns `true` if no further roam actions should be taken
//
//==========================================================================
bool RoamRandom (out TVec dest) {
  int r = P_Random();
  float an = GetAngle();
  float maxdistf, maxdistl, maxdistr;

  if (GetCvarB('bot_developer_messages_roam')) print("bot '%s' has nothing to do; r=%s; an=%s", player.PlayerName, r, an);

  for (float dist = 1024.0; dist >= 64.0; dist -= 64.0) {
    if (CheckPath(an, dist, out maxdist:maxdistf)) {
      posdest_valid = true;
      posdest.x = botmo.Origin.x+dist*cos(an);
      posdest.y = botmo.Origin.y+dist*sin(an);
      posdest.z = botmo.Origin.z;
      SetAngle(an);
      break;
    }

    if (CheckPath(an+45.0, dist, out maxdist:maxdistl)) {
      posdest_valid = true;
      posdest.x = botmo.Origin.x+dist*cos(an+45.0);
      posdest.y = botmo.Origin.y+dist*sin(an+45.0);
      posdest.z = botmo.Origin.z;
      SetAngle(an+45.0);
      break;
    }

    // left is no good, try right
    if (CheckPath(an-45.0, dist, out maxdist:maxdistr)) {
      posdest_valid = true;
      posdest.x = botmo.Origin.x+dist*cos(an-45.0);
      posdest.y = botmo.Origin.y+dist*sin(an-45.0);
      posdest.z = botmo.Origin.z;
      SetAngle(an-45.0);
      break;
    }

    // can move at least half the distance?
    float maxd = fmax(fmax(maxdistl, maxdistr), maxdistf);
    if (maxd >= dist*0.5) {
      // forward?
      if (maxdistf > maxdistl && maxdistf > maxdistr) {
        dist = maxdistf;
      } else if (maxdistl > maxdistr) {
        // left
        dist = maxdistl;
        an -= 45;
      } else {
        // right
        dist = maxdistr;
        an += 45;
      }
      posdest_valid = true;
      posdest.x = botmo.Origin.x+dist*cos(an);
      posdest.y = botmo.Origin.y+dist*sin(an);
      posdest.z = botmo.Origin.z;
      SetAngle(an);
      break;
    }
  }

  if (posdest_valid) {
    dest = posdest;
    if (GetCvarB('bot_developer_messages_roam')) print("bot '%s' roams to %s from %s", player.PlayerName, dest, botmo.Origin);
  } else {
    if (GetCvarB('bot_developer_messages_roam')) print("bot '%s' cannot roam where it wants", player.PlayerName);
    float wlksign = FORWARDWALK*(P_Random() > 128 ? 1 : -1);
    an = botmo.Angles.yaw;
    if (!CheckPath(an, wlksign)) {
      if (CheckPath(an, -wlksign)) {
        wlksign = -wlksign;
      } else {
        SetAngle(GetAngle()+45.0*FRandomFull());
        //SetAngle(GetAngle()+45.0/3.0);
        //player.ViewAngles.yaw = GetAngle();
        //wlksign = 0;
      }
    }
    forwardmove = wlksign;
    // unconditionally, just for fun
    PerformLastCheckActions();
    return true;
  }

  return false;
}


//==========================================================================
//
//  Roam
//
//  Handle non-attack/dodging movement
//
//==========================================================================
void Roam () {
  TVec dest;

  float currTime = botmo.XLevel.Time;

  if (lastpos_valid) {
    TVec dir = lastpos-botmo.Origin;
    dir.z = 0.0;
    if (Length2D(dir) <= 32.0) lastpos_valid = false;
  }

  if (item && !CheckTo(item.Origin)) {
    // forget for some time
    PutItemToIgnoreList(item, 1.0/4.0);
    item = none;
    itemFirstSeenTime = 0;
  }

  if (item && currTime-itemFirstSeenTime > ITEM_GIVEUP_TIME) {
    PutItemToIgnoreList(item, 0.9);
    item = none;
    itemFirstSeenTime = 0;
  }

  // order of item response precedence
  if (goal) {
    dest = goal.Origin;
    if (GetCvarB('bot_developer_messages_roam')) print("bot '%s' is going to goal at %s from %s", player.PlayerName, dest, botmo.Origin);
  } else if (lastpos_valid) {
    dest = lastpos;
    if (GetCvarB('bot_developer_messages_roam')) print("bot '%s' is going to lastpost at %s from %s", player.PlayerName, dest, botmo.Origin);
  } else if (item) {
    dest = item.Origin;
    if (GetCvarB('bot_developer_messages_roam') || GetCvarB('bot_developer_messages_item')) print("bot '%s' is going to item at %s from %s", player.PlayerName, dest, botmo.Origin);
  } else if (node) {
    dest = node.Origin;
    if (GetCvarB('bot_developer_messages_roam')) print("bot '%s' is going to node at %s from %s", player.PlayerName, dest, botmo.Origin);
  } else if (posdest_valid) {
    dest = posdest;
    if (GetCvarB('bot_developer_messages_roam')) print("bot '%s' is going to posdest at %s from %s (dist=%s)", player.PlayerName, dest, botmo.Origin, (dest-botmo.Origin).length2D);
    if ((dest-botmo.Origin).length2D <= botmo.Radius/3) {
      if (GetCvarB('bot_developer_messages_roam')) print("bot '%s' is RADIUS-CLOSE go to posdest at %s from %s", player.PlayerName, dest, botmo.Origin);
      posdest_valid = false;
      if (RoamRandom(dest)) return;
    } else if (!CheckTo(dest)) {
      if (GetCvarB('bot_developer_messages_roam')) print("bot '%s' CANNOT go to posdest at %s from %s", player.PlayerName, dest, botmo.Origin);
      posdest_valid = false;
      if (RoamRandom(dest)) return;
    }
  } else {
    // no target, so just run around until we find something
    if (RoamRandom(dest)) return;
  }

  CheckTo(dest); // to setup flags
  // unconditionally, just for fun
  PerformLastCheckActions();

  forwardmove = FORWARDRUN;
  SetAngle(AngleTo(dest));
}


//==========================================================================
//
//  CheckWantCurrentItem
//
//==========================================================================
bool CheckWantCurrentItem () {
  if (!item) return false;
  if (bItemIsPowerup) return true; // always collect powerups
  if (!bItemIsWeapon) return false; // don't bother with non-weapons
  if (!player.ReadyWeapon || !CanAttackWithCurrentWeapon()) return true; // want any weapon
  Weapon wpn = Weapon(item);
  if (!wpn) return false;
  if (boptCheckWimpyWeapon && player.ReadyWeapon.bWimpyWeapon) return false;
  if (player.ReadyWeapon && player.ReadyWeapon.bBotMelee) return true;
  return true;
}


//==========================================================================
//
//  Move
//
//  main bot movement function.
//  dodging/attacking movement is also handled here
//
//==========================================================================
void Move (float deltaTime) {
  // worry about missiles above all else
  if (missile) {
    if (t_strafe) {
      t_strafe = fmax(0, t_strafe-deltaTime);
      if (!t_strafe) {
        // don't change direction while dodging missiles (that could be bad)
        //bot->sidemove = -bot->sidemove;
        t_strafe = 2.0;
      }
    }

    // look at the missle and sidestep it
    SetAngle(AngleTo(missile.Origin));
    forwardmove = -FORWARDRUN;
    return;
  }

  // anticipate a shot: time to dodge!
  if (enemy && t_shootcooldown <= 0.25) {
    if (!sidemove) sidemove = SIDERUN;

    switch (info.anticip) {
      case bsk_verypoor:
        // deer caught in the headlights
        sidemove = 0.0;
        return;

      case bsk_poor:
        // always walk right
        sidemove = SIDEWALK;
        break;

      case bsk_low:
        // always run right
        sidemove = SIDERUN;
        break;

      case bsk_medium:
        // just switch directions every couple seconds
        if (t_strafe) {
          t_strafe = fmax(0, t_strafe-deltaTime);
          if (!t_strafe) {
            sidemove = -sidemove;
            t_strafe = 2.0;
          }
        }
        break;

      case bsk_high:
        // switch directions when we think our opponent will fire
        if (!t_shootcooldown) sidemove = -sidemove;
        break;

      case bsk_excellent:
        // move in a somewhat random direction when we think our opponent will fire
        if (!t_shootcooldown) {
          sidemove = (Random() < 0.5 ? SIDERUN : -SIDERUN);
          if (Random() < 0.5) forwardmove = -FORWARDWALK;
        }
        break;

      case bsk_supreme:
        // what a squirmy little fucker!
        if (!t_shootcooldown) {
          switch (P_Random()&3) {
            case 0: sidemove = SIDERUN; break;
            case 1: sidemove = SIDEWALK; break;
            case 2: sidemove = -SIDERUN; break;
            case 3: sidemove = -SIDEWALK; break;
          }
          switch (P_Random()&3) {
            case 0: forwardmove = FORWARDRUN; break;
            case 1: forwardmove = FORWARDWALK; break;
            case 2: forwardmove = -FORWARDRUN; break;
            case 3: forwardmove = -FORWARDWALK; break;
          }
        }
        break;

      default:
        Error("Unknown bot skill level: %d", info.anticip);
        return;
    }
  }

  // now handle attack movement
  if (enemy) {
    bool noforward = false;
    bool noside = false;
    if (!sidemove) sidemove = SIDERUN;

    if (t_strafe) {
      t_strafe = fmax(0, t_strafe-deltaTime);
      if (!t_strafe) {
        sidemove = -sidemove;
        t_strafe = 2.0;
      }
    }

    float dist = botmo.DistTo(enemy);

    // remember where we saw him last in case he gets away
    lastpos = enemy.Origin;
    lastpos_valid = true;

    // check if we'd rather pick up something than fight
    if (item) {
      if (CheckWantCurrentItem()) {
        Roam();
        return;
      }
    }

    float an = botmo.Angles.yaw;
    if (sidemove < 0.0) an -= 90.0; else an += 90.0;

    if (!CheckPath(an, 48.0)) {
      // we're blocked, so go the other way!
      sidemove = -sidemove;
    }

    if (CheckTo(enemy.Origin) && dist > player.ReadyWeapon.BotCombatDist) {
      forwardmove = FORWARDRUN;
    } else {
      forwardmove = -FORWARDRUN;
    }

    // unconditionally, just for fun
    PerformLastCheckActions();
    return;
  }

  if (t_strafe) {
    t_strafe = fmax(0, t_strafe-deltaTime);
    if (!t_strafe) {
      sidemove = -sidemove;
      t_strafe = 2.0;
    }
  }

  // run to human player to give some support
  if (!player.Level.Game.deathmatch) {
    // search for player enemies in deathmatch
    //print("looking for player...");
    Actor target = none;
    float closest_dist = 99999.0;
    foreach (auto i; 0..MAXPLAYERS) {
      auto plr = player.Level.Game.Players[i];
      if (!plr) continue;
      if (!plr.bIsBot && plr.bSpawned && plr.MO.Health > 0 && botmo != plr.MO) {
        float temp = plr.MO.DistTo(botmo);
        if (temp > SAFE_SELF_MISDIST && temp < closest_dist) {
          if (Check_LOS(Actor(plr.MO), 360) || CheckTo(plr.MO.Origin)) {
            closest_dist = temp;
            target = Actor(plr.MO);
          }
        }
      }
    }
    if (target) {
      //print("  found player; dist=%f", target.DistTo(botmo));
      SetAngle(AngleTo(target.Origin));
      player.ViewAngles.yaw = GetAngle();
      lastpos = target.Origin;
      lastpos_valid = true;
      posdest_valid = false;
      item = none;
    }
  }

  // roam after an item
  Roam();
}


//==========================================================================
//
//  AttackSpecial
//
//==========================================================================
bool AttackSpecial () {
  /*
  if (player.ReadyWeapon.Class == Chaingun)
  {
    // Double tap the chaingun for extreme accuracy
    if (info.accuracy == bsk_supreme)
      if (t_fire)
        return true;
  }
  */
  return false;
}


//==========================================================================
//
//  CanAttackWithCurrentWeapon
//
//==========================================================================
bool CanAttackWithCurrentWeapon (optional bool ignorePending) {
  if (ignorePending) {
    if (player.PendingWeapon) return false; // we're going to switch weapons, cannot attack
  } else {
    if (player.PendingWeapon) {
      if (player.PendingWeapon.CheckAmmo(Weapon::FIRE_Primary, AutoSwitch:false)) return true;
    }
  }

  if (player.ReadyWeapon) {
    if (player.ReadyWeapon.CheckAmmo(Weapon::FIRE_Primary, AutoSwitch:false)) return true;
  }

  return false;
}


//==========================================================================
//
//  BuildWeaponList
//
//==========================================================================
void BuildWeaponList () {
  weaponList.reset(); // don't reallocate
  if (!botmo) return;

  auto pawn = PlayerPawn(botmo);
  if (!pawn) return;

  int currSlot = 0;
  int currIndex = -1;

  foreach (auto i; 0..PlayerPawn::MAX_WEAPONS_PER_SLOT*(PlayerPawn::NUM_WEAPON_SLOTS+1)) {
    if (++currIndex == PlayerPawn::MAX_WEAPONS_PER_SLOT) {
      currIndex = 0;
      currSlot = (currSlot+1)%(PlayerPawn::NUM_WEAPON_SLOTS+1);
    }
    class!Weapon swc = pawn.GetWeaponInSlot(currSlot, currIndex);
    if (!swc) continue;
    Weapon Wpn = Weapon(botmo.FindInventory(swc));
    if (Wpn) {
      if (Wpn.SisterWeapon && Wpn.SisterWeapon.bPoweredUp) {
        bool Powered = !!botmo.FindInventory(PowerWeaponLevel2);
        if (Powered) Wpn = Wpn.SisterWeapon;
      }
      weaponList[$] = Wpn;
    }
  }
}


//==========================================================================
//
//  BotSwitchWeapon
//
//==========================================================================
void BotSwitchWeapon () {
  BuildWeaponList();
  Weapon bestwpn = player.ReadyWeapon;
  if (bestwpn && !bestwpn.CheckAmmo(Weapon::FIRE_Primary, AutoSwitch:false)) bestwpn = none;
  foreach (Weapon wpn; weaponList) {
    if (!wpn.CheckAmmo(Weapon::FIRE_Primary, AutoSwitch:false)) continue;
    if (!bestwpn) { bestwpn = wpn; continue; }
    if (wpn.bBotProjectile) {
      if (!enemy) continue;
      if (enemy.DistTo(botmo) <= SAFE_SELF_MISDIST) continue;
      if (!bestwpn || !bestwpn.bBotBfg) bestwpn = wpn;
      continue;
    }
    if (wpn.bBotBfg) {
      bestwpn = wpn;
      continue;
    }
    if (bestwpn && bestwpn.bBotMelee && !wpn.bBotMelee) {
      bestwpn = wpn;
    }
  }
  //print("  found weapon %C", bestwpn);
  if (bestwpn && bestwpn != player.ReadyWeapon) {
    //print("   setting weapon %C (ready is %C, pending is %C)", bestwpn, player.ReadyWeapon, player.PendingWeapon);
    player.PendingWeapon = bestwpn;
  }
}


//==========================================================================
//
//  Attack
//
//==========================================================================
void Attack () {
  // still reacting to something
  if (t_react) return;
  if (player.PendingWeapon) return;

  // check if we can fire current weapon, and
  // try to switch weapons if we can't
  if (!player.PendingWeapon) BotSwitchWeapon();

  // don't have an enemy to fight
  if (!enemy || enemy.Health <= 0) return;

  // never attack other players in coop
  if (enemy.bIsPlayer && !player.Level.Game.deathmatch) {
    // reset enemy
    if (GetCvarB('bot_developer_messages_attack')) print("bot '%s': oops, coop enemy is another player!", player.PlayerName);
    enemy = none;
    return;
  }

  if (!CanAttackWithCurrentWeapon(ignorePending:true)) return;

  //if (player.ReadyWeapon) print("CANATTACK with %C: %B", player.ReadyWeapon, player.ReadyWeapon.CheckAmmo(Weapon::FIRE_Primary, AutoSwitch:false));

  // no point in firing if we won't hit them
  if (!Check_LOS(enemy, SHOOTFOV)) return;

  // set dodge time
  t_shootcooldown = 0.3+0.5*FRandomFull();

  // set pitch here, so headshot checks will work as expected
  //FIXME: allies-in-water situation should be moved to separate function
  Pitch();

  if (AttackSpecial()) return;

  if (!t_fire) {
    if (GetCvarB('bot_developer_messages_attack')) print("bot '%s': attacking %s", player.PlayerName, enemy.Class);
    player.Buttons |= BT_ATTACK;
    //HACK: for plasmagun, do not release attack button
    if (player.ReadyWeapon) {
      class!Weapon wpn = class!Weapon(player.ReadyWeapon.Class);
      while (wpn) {
        if (nameicmp(GetClassName(wpn), 'PlasmaRifle') == 0) {
          //print("PLASMA!");
          t_fire = 0;
          return;
        }
        wpn = class!Weapon(GetClassParent(wpn));
      }
    }
    t_fire = 1.0/35.0*2.5;
  }
}


//==========================================================================
//
//  Turn
//
//  [BC] Ahh, the new and improved turning...
//
//==========================================================================
void Turn () {
  float distance = GetAngle()-botmo.Angles.yaw;

       if (distance > 180.0) distance -= 360.0;
  else if (distance < -180.0) distance += 360.0;

  /*
  if (!enemy) {
    player.ViewAngles.yaw = GetAngle();
    return;
  }
  */

  // [BC] Don't act crazy while trying to aim
  switch (info.accuracy) {
    case bsk_verypoor:
    case bsk_poor:
    case bsk_low:
      distance = fclamp(distance, -7.5, 7.5);
      break;
    case bsk_medium:
      distance = fclamp(distance, -15, 15);
      break;
    case bsk_high:
      distance = fclamp(distance, -22.5, 22.5);
      break;
    case bsk_excellent:
      distance = fclamp(distance, -30, 30);
      break;
    case bsk_supreme:
      distance = fclamp(distance, -37.5, 37.5);
      break;
  }

  player.ViewAngles.yaw = AngleMod360(botmo.Angles.yaw+distance);
}


//==========================================================================
//
//  Pitch
//
//==========================================================================
void Pitch () {
  bool doHeadshots = GetCvarB('bot_always_headshots');
  float hsdist = 512; // average

  if (!doHeadshots) {
    switch (info.intelect) {
      case bsk_verypoor:
        if (FRandomFull() < 0.2) { doHeadshots = true; hsdist = 256; }
        break;
      case bsk_poor:
        if (FRandomFull() < 0.3) { doHeadshots = true; hsdist = 256; }
        break;
      case bsk_low:
        if (FRandomFull() < 0.4) { doHeadshots = true; hsdist = (P_Random()&1 ? 384 : 256); }
        break;
      case bsk_medium:
        if (FRandomFull() < 0.5) { doHeadshots = true; hsdist = (P_Random()&1 ? 384 : 256); }
        break;
      case bsk_high:
        if (FRandomFull() < 0.6) { doHeadshots = true; hsdist = (P_Random()&1 ? 512 : 384); }
        break;
      case bsk_excellent:
        if (FRandomFull() < 0.8) { doHeadshots = true; hsdist = (P_Random()&1 ? 512 : 384); }
        break;
      case bsk_supreme:
        if (FRandomFull() < 0.9) { doHeadshots = true; hsdist = (P_Random()&1 ? 512 : 384); }
        break;
    }
  }


  if (enemy) {
    if (doHeadshots && botmo.DistTo2(enemy) <= hsdist) {
      if (GetCvarB('bot_developer_messages_attack')) print("bot '%s': HEADSHOTTING %C", player.PlayerName, enemy);
    } else {
      if (GetCvarB('bot_developer_messages_attack')) print("bot '%s': shooting at %C", player.PlayerName, enemy);
      doHeadshots = false;
    }
  } else {
    doHeadshots = false;
  }

  botmo.Angles.pitch = 0.0;

  // new code
  // [FB] Set pitch for underwater areas
  if (player.MO.WaterLevel > 2) {
    if (enemy) {
      botmo.Angles.pitch = PitchToEntity(enemy, doHeadshots);
    } else {
      // [FB] Follow our buddy if we're tagging along
      if (ally || (ally && !enemy)) {
        botmo.Angles.pitch = PitchToEntity(ally);
      }
    }
  } else {
    if (enemy) {
      botmo.Angles.pitch = PitchToEntity(enemy, doHeadshots);
      //print("bot: enemy at %s, bot at %s, pitch is %s (%s) (%s)", eorig, org, botmo.Angles.pitch, player.ViewAngles.pitch, enemy.Class);
      //print("     real: enemy at %s, bot at %s (eheight=%s, bheight=%s, efclip=%s, bfclip=%s, zofs=%s)", enemy.Origin, botmo.Origin, enemy.Height, botmo.Height, enemy.FloorClip, botmo.FloorClip, player.GetAttackZOfs);
    }
  }

  //k8: if we won't do this, it won't work right
  player.ViewAngles.pitch = botmo.Angles.pitch;
}


//==========================================================================
//
//  Killed
//
//==========================================================================
void Killed (EntityEx victim) {
  // [BC] Let some anger out
  angerlevel -= 5;
  enemy = none;

  // [BC] Don't need to worry about following him anymore
  lastpos_valid = false;
}


//==========================================================================
//
//  Died
//
//==========================================================================
void Died (EntityEx killer) {
}


//==========================================================================
//
//  OnBeginPlay
//
//==========================================================================
void OnBeginPlay () {
  int botskill = 4;
  int bottype = 0;
  botinfo_t *binfo;

  bool randomBot = true;

  if (player.PlayerName) {
    foreach (auto i; 0..MainGameInfo::NUMTOTALBOTS) {
      if (stricmp(MainGameInfo(player.Level.Game).botinfo[i].Name, player.PlayerName) == 0) {
        bottype = i;
        randomBot = false;
        break;
      }
    }
  }

  if (randomBot) {
    // if the user doesn't input a name, don't
    // spawn one of the "special" bots, only one of the
    // normal ones.
    bottype = P_Random()%MainGameInfo::NUMBOTTYPES;
  }

  //print("bottype=%s; name='%s'", bottype, player.PlayerName);

  binfo = &MainGameInfo(player.Level.Game).botinfo[bottype];

  t_strafe = 1.0;

  if (botskill > 4) botskill = 4;
  if (botskill < 0) botskill = 0;

  // implement skill settings
  info.accuracy = SkillLower(binfo->accuracy, 4-botskill);
  info.intelect = SkillLower(binfo->intelect, 4-botskill);
  info.evade = SkillLower(binfo->evade, 4-botskill);
  info.anticip = SkillLower(binfo->anticip, 4-botskill);
  info.reaction = SkillLower(binfo->reaction, 4-botskill);
  player.UserInfo = binfo->userinfo;

  if (randomBot && default.BotNames.length) {
    //print("OLD USERINFO: '%s'", player.UserInfo);
    // use random bot name
    string botName = default.BotNames[round(FRandomFull()*default.BotNames.length)%default.BotNames.length];
    if (player.UserInfo.strStartsWith("\\Name")) {
      auto idx = player.UserInfo.strIndexOf("\\", 1);
      idx = player.UserInfo.strIndexOf("\\", idx+1);
      if (idx > 0) {
        player.UserInfo = "\\Name\\"~botName~player.UserInfo[idx..$];
      } else {
        player.UserInfo ~= "\\Name\\"~botName;
      }
    } else {
      player.UserInfo ~= "\\Name\\"~botName;
    }
    //print("NEW USERINFO: '%s'", player.UserInfo);
  }

  if (!player.Level.Game.deathmatch) {
    info.accuracy = bsk_high;
    info.intelect = bsk_high;
    info.evade = bsk_high;
    info.anticip = bsk_high;
    info.reaction = bsk_high;
  }
}


//==========================================================================
//
//  OnSpawn
//
//==========================================================================
void OnSpawn () {
  ITarget = none;
  Actor item = none;
  itemFirstSeenTime = 0;
  bItemIsWeapon = false;
  bItemIsPowerup = false;
  goal = none;
  node = none;
  prev = none;
  posdest_valid = false;
  enemy = none;
  lastpos_valid = false;
  missile = none;

  ally = none;
  itemIgnoreTimeout.reset();

  // forgot who killed us (sometimes)
  if (FRandomFull() < 0.7) player.Attacker = none;
}


defaultproperties {
#include "botnames.vc"
}
