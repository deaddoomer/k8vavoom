//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2022 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//
//  This section contains the main bot AI.
//
//**************************************************************************
//#include "BotPlayer_pather_old.vc"
#include "BotPlayer_pather.vc"


// ////////////////////////////////////////////////////////////////////////// //
// Main bot class
class BotPlayerBase : GameObject;

// random bot names
array!string BotNames;


#define BOT_ALLOW_JUMPS

const float FORWARDWALK = 200.0;
const float FORWARDRUN  = 400.0;
const float SIDEWALK    = 192.0;
const float SIDERUN     = 320.0;

/*const float MAX_TRAVERSE_DIST     (1024*FRACUNIT) //10 meters, used within b_func.c*/
const float MAX_TRAVERSE_DIST = 307.2; // 3 meters, used within b_func.c -> 1 meter = 102.4 units
const float AVOID_DIST        = 512.0; // try to avoid incoming missiles once they reached this close
const float SAFE_SELF_MISDIST = 128.0; // distance from self to target where it's safe to pull a rocket
/*const float FRIEND_DIST         (128*FRACUNIT)  //To friend.
const float DARK_DIST         (256*FRACUNIT)  //Distance that bot can see enemies in the dark from.
const float WHATS_DARK          64        //light value thats classed as dark.
const float MAX_MONSTER_TARGET_DIST   (1024*FRACUNIT) //Too high can slow down the performance, see P_mobj.c*/
const float ENEMY_SCAN_FOV = 120.0;
/*const float DEFAULT_MAXMOVEHEIGHT       (32*FRACUNIT) //MAXSTEPMOVE but with jumping counted in.
const float GETINCOMBAT         (512*FRACUNIT)  //Max distance to item. if it's due to be icked up in a combat situation.*/
const float SHOOTFOV = 60.0;
/*const float MAXROAM           (5*TICRATE)   //When this time is elapsed the bot will roam after something else.*/
const float MONSTER_SCAN_RADIUS = 1024.0;
const float ITEM_SCAN_RADIUS = 1024.0;

const float ITEM_GIVEUP_TIME = 1.5; // if bot cannot get item for this time, ignore it
const float ITEM_IGNORE_TIME = 10.0; // time bot should ignore item
const float ITEM_IGNORE_TIME_DEVIATION = 3.0; // random deviation for ignore time


// required for hexen
bool boptCheckWimpyWeapon = true;


/*
  Class definitions for botinfo, chatinfo, and
  other various bot information thingamabobers.
*/

/+
enum {
  bsk_verypoor,
  bsk_poor,
  bsk_low,
  bsk_medium,
  bsk_high,
  bsk_excellent,
  bsk_supreme
};

struct botinfo_t {
  string Name;    // bot's name
  int accuracy;   // accuracy with "instant" weapons (this includes "leading")
  int intelect;   // accuracy with "missile" weapons (rocket launcher, etc.)
  int evade;      // ability to dodge incoming missiles
  int anticip;    // ability to anticipate "instant" shots
  int reaction;   // overall reaction time (lower is "better")
/*
  int pisschance;   // chance the bot will get pissed when his threshold is reached
  int threshold;    // how much it takes to frustrate/piss off the bot
  int dangerlevel;  // when health is below this, we need some health
  int wpfav;      // favorite weapon
  int chatinfo;   // bot's chat strings
  int chattime;   // how long it takes us to type a line
  int chatty;     // how talkative the bot is
  char *color;   // color (in form of a string)
  char *gender;   // male/female/it :)
  char *skin;     // skin
  int railcolor;   // railgun trail color
  bool revealed;    // hidden bots must be revealed
*/
  string userinfo;
};
+/


/*
struct chatline_t {
  char *string;
  chattype_t bot;
  chatline_t *line;
};

struct chatinfo_t {
  chatline_t intro[5];
  chatline_t inter[5];
  chatline_t rare[5];
  chatline_t frag[15];
  chatline_t died[10];
  chatline_t roam[10];
  chatline_t pissed[5];
  chatline_t frustrated[5];
  chatline_t special[20];
} chatinfo_t;
*/

// The things the bot knows about their enemy
/*
struct enemyinfo_t {
  int health;
  weapontype_t weap;
};
*/

//
// Bot states
//
enum {
  BST_NOTHING, // deciding what to do
  BST_OFFENSE, // bot is "fetching" something (skull, whatever)
  BST_DEFENSE, // bot is defending something
  BST_RETURN, // bot is heading to scoring place
};


PlayerEx player; // points to reference player
Actor botmo;
Actor ITarget;  // immediate target (where to go) (k8: currently unused)

// destinations
Actor item; // item (roam towards weapon, etc)
float itemFirstSeenTime; // so bot can give up if it cannot reach item for some time
bool bItemIsWeapon;
bool bItemIsPowerup;
Actor goal; // teamgame goal spot
Actor node; // node we're heading towards
Actor prev; // previous node we were at
TVec posdest; // position of our destination (doesn't have to be an actor)
bool posdest_valid;
TVec posdestLast; // used to invalidate `posdest_set_time`
float posdest_set_time;
Actor enemy; // the dead meat
TVec lastpos; // last place we saw our enemy
bool lastpos_valid;
Actor missile; // a threathing missile that got to be avoided

Actor ally; // ally to tag along with
float t_strafe;
float t_react;
float t_fire; // seconds left until our gun will actually fire again
float t_shootcooldown;

float forwardmove; // for building ucmd
float sidemove;

// misc booleans
bool bAllRound;
bool bNewItemIsWeapon;
bool bNewItemIsPowerup;

LineSpecialGameInfo::botinfo_t info; // aiming, name, perfection, yadda yadda

int angerlevel;

float angle; // the wanted angle that the bot tries to get every tic

int lastThinkTic; // do not replan on every simulation tic, replan on every game tic (1/35)

array!Weapon weaponList;

// bot will ignore item if it cannot obtain it for some time
dictionary!(Actor, float) itemIgnoreTimeout;

#ifdef BOT_PATHER_OLD
// nodes for subsectors
array!BotPathNode ssnodes;
int lastNodeUpdate = 1; // update when some node info changed, so planners can reset caches; never zero
#endif

// current path, subsector numbers
array!int currPath;
int currDestNodeIdx;
float currPathCost;
// set when bot leaves current path node
// reset when bot arrives to current path node
// if it takes too long to travel, replan path
float currAlienNodeTime;
// to avoid blocks, reset node link if we cannot move for some time
// last subsector bot was in
int lastSubsector = -1;
// last time we changed subsector
// if we are in the same subsector for too long, drop current path, and get a new goal
// `0` means "not set"
float lastSSChangeTime;
// if bot cannot move for some time, drop current path, and get a new goal
//TVec lastCurrFollowPos;
// `0` means "not set"
//float lastCurrFollowTime;

// do not give up moving to ally while this timeout not reached
float currPathAllyForceTimeout;

// we should not use doors and such continuously, so wait a little if we did used something
dictionary!(int, float) lastUsedLines; // by line index
dictionary!(EntityEx, float) lastUsedThings;

// a-star planner
BotPathGraph pather;

// hash of current map, to detect map changes
string lastMapHash;


// cached cvars
transient bool bot_disable_ai;
transient bool bot_ignore_humans;
transient bool bot_developer_messages_roam;
transient bool bot_developer_messages_checkpos;
transient bool bot_developer_messages_items;
transient bool bot_developer_messages_attack;
transient bool bot_developer_messages_path;
transient bool bot_developer_messages_crumbs;
transient bool bot_developer_messages_planpath;
transient bool bot_run_to_subsector_center;
transient bool bot_no_run;
transient bool bot_no_jump;
transient bool bot_always_headshots;


//==========================================================================
//
//  UpdateCvarCache
//
//==========================================================================
final void UpdateCvarCache () {
  bot_disable_ai = GetCvarB('bot_disable_ai');
  bot_ignore_humans = GetCvarB('bot_ignore_humans');
  bot_developer_messages_roam = GetCvarB('bot_developer_messages_roam');
  bot_developer_messages_checkpos = GetCvarB('bot_developer_messages_checkpos');
  bot_developer_messages_items = GetCvarB('bot_developer_messages_items');
  bot_developer_messages_attack = GetCvarB('bot_developer_messages_attack');
  bot_developer_messages_path = GetCvarB('bot_developer_messages_path');
  bot_developer_messages_crumbs = GetCvarB('bot_developer_messages_crumbs');
  bot_developer_messages_planpath = GetCvarB('bot_developer_messages_planpath');
  bot_run_to_subsector_center = GetCvarB('bot_run_to_subsector_center');
  bot_no_run = GetCvarB('bot_no_run');
  bot_no_jump = GetCvarB('bot_no_jump');
  bot_always_headshots = GetCvarB('bot_always_headshots');
}


//==========================================================================
//
//  Destroy
//
//==========================================================================
override void Destroy () {
#ifdef BOT_PATHER_OLD
  foreach (ref BotPathNode node; ssnodes) delete node;
  ssnodes.length = 0;
#endif
  delete pather;
  ::Destroy();
}


//==========================================================================
//
//  DumpNodes
//
//==========================================================================
final void DumpNodes () {
#ifdef BOT_PATHER_OLD
  EntityEx mo = EntityEx(player.MO);
  if (!mo) return;
  printmsg(PMSG.BotDev, "=== NODES FOR '%s' ===", player.PlayerName);
  foreach (int nidx, BotPathNode node; ssnodes) {
    if (!node) continue;
    printmsg(PMSG.BotDev, " node #%s (%s) has #%d transitions", nidx, node.index, node.ssreachable.length);
    foreach (int tridx, const ref auto tr; node.ssreachable) {
      printmsg(PMSG.BotDev, "  transition #%d: dest=%s; dist=%s; cost=%s; jump=%B; use=%B", tridx, tr.subnum, tr.dist, tr.moveCost, tr.needJump, tr.needUse);
    }
  }
#else
  EntityEx mo = EntityEx(player.MO);
  if (!mo || !pather) return;
  printmsg(PMSG.BotDev, "=== NODES FOR '%s' ===", player.PlayerName);
  foreach (int nidx, BotPathNode ptnode; pather.nodes) {
    if (!ptnode) continue;
    printmsg(PMSG.BotDev, " node #%s (%s) has #%d transitions (passable=%B; door=%B)", nidx, ptnode.index, ptnode.exits.length, ptnode.passable, ptnode.door);
    foreach (int tridx, const ref auto tr; ptnode.exits) {
      printmsg(PMSG.BotDev, "  transition #%d: dest=%s; dist=%s; cost=%s; jump=%B; use=%B", tridx, tr.subnum, tr.dist, tr.moveCost, tr.needJump, tr.needUse);
    }
  }
#endif
}


//==========================================================================
//
//  ResetCurrPath
//
//==========================================================================
final void ResetCurrPath () {
  currPath.reset();
  currPathCost = float.max;
  currDestNodeIdx = 0;
  //lastCurrFollowTime = 0;
}


//==========================================================================
//
//  UseCurrentPath
//
//  use path stored in `pather` as current one
//
//==========================================================================
final void UseCurrentPath () {
  ResetCurrPath();
  if (!pather) return;
  foreach (auto pidx; 0..pather.PathArrayLength) {
    auto ptnode = BotPathNode(pather.PathArrayNode(pidx));
    currPath[$] = ptnode.index;
  }
  if (currPath.length) {
    if (bot_developer_messages_planpath) {
      printmsg(PMSG.BotDevPlanPath, "=== new path from %d to %d (%d nodes) ===", currPath[0], currPath[$-1], currPath.length);
      foreach (auto pidx; 0..currPath.length) printmsg(PMSG.BotDevPlanPath, "  #%d: %d", pidx, currPath[pidx]);
    }
    currPathCost = pather.pathCost;
  }
  currDestNodeIdx = 0;
  currAlienNodeTime = 0;
}


//==========================================================================
//
//  HavePathToSS
//
//  doesn't invalidate current path
//
//==========================================================================
final bool HavePathToSS (subsector_t *ssdest) {
  if (!pather) return false;
  if (!ssdest) return false;
  if (!botmo.SubSector) return false;
#ifdef BOT_PATHER_OLD
  return pather.BuildPath(botmo.SubSector-&botmo.XLevel.Subsectors[0], ssdest-&botmo.XLevel.Subsectors[0]);
#else
  TVec dest = botmo.XLevel.GetSubsectorCenter(ssdest);
  dest.z = EntityEx::ONFLOORZ;
  return pather.BuildPath(botmo.Origin, botmo.SubSector, dest, ssdest);
#endif
}


//==========================================================================
//
//  HavePathToPoint
//
//  doesn't invalidate current path
//
//==========================================================================
final bool HavePathToPoint (TVec dest, optional subsector_t *destsub) {
#ifdef BOT_PATHER_OLD
  if (!destsub) destsub = botmo.XLevel.PointInSubsectorRender(dest);
  return HavePathToSS(destsub);
#else
  return pather.BuildPath(botmo.Origin, botmo.SubSector, dest, destsub);
#endif
}


//==========================================================================
//
//  TestFindPathTo
//
//==========================================================================
final void TestFindPathTo (TVec dest) {
  EntityEx mo = EntityEx(player.MO);
  if (!mo) return;
  botmo = Actor(mo);
  if (!botmo) return;
  subsector_t *ss = botmo.XLevel.PointInSubsectorRender(dest);
  if (!ss) return;
  pather.debugDump = true;
  scope(exit) pather.debugDump = false;
  if (!HavePathToPoint(dest, ss)) {
    printmsg(PMSG.BotDev, "bot '%s' cannot find path from #%s to #%s", player.PlayerName, botmo.SubSector-&botmo.XLevel.Subsectors[0], ss-&botmo.XLevel.Subsectors[0]);
  } else {
    printmsg(PMSG.BotDev, "bot '%s' found path from #%s to #%s", player.PlayerName, botmo.SubSector-&botmo.XLevel.Subsectors[0], ss-&botmo.XLevel.Subsectors[0]);
    UseCurrentPath();
    // do not give up for 20 seconds
    currPathAllyForceTimeout = botmo.XLevel.Time+6;
    //foreach (int sidx; currPath) printmsg(PMSG.BotDev, "  ss: #%d", sidx);
  }
}


//==========================================================================
//
//  PutItemToIgnoreList
//
//  put item into ignore list
//
//==========================================================================
final void PutItemToIgnoreList (Actor aitem, optional float timeoutMult) {
  if (!aitem || !aitem.IsDestroyed) return;
  if (!specified_timeoutMult) timeoutMult = 1;
  float currTime = botmo.XLevel.Time;
  float timeout = ITEM_IGNORE_TIME+(FRandomFull()-0.5)*(ITEM_IGNORE_TIME_DEVIATION*2);
  if (!player.Level.Game.deathmatch) {
    // coop
    timeout += 30;
  }
  timeout *= timeoutMult;
  timeout += currTime;
  if (bot_developer_messages_items) printmsg(PMSG.BotDevAI, "bot '%s' gives up on %C for %s", player.PlayerName, aitem.Class, timeout-currTime);
  itemIgnoreTimeout.put(aitem, timeout);
}


//==========================================================================
//
//  IsGoodMapPosition
//
//==========================================================================
final bool IsGoodMapPosition (ref TVec pos) {
  Entity::tmtrace_t tmtrace;
  if (botmo.CheckRelPosition(out tmtrace, pos, noPickups:true, ignoreMonsters:true, ignorePlayers:true)) {
    pos = tmtrace.End;
    return true;
  } else {
    return false;
  }
}


//==========================================================================
//
//  CheckAndDropNodeFromTo
//
//==========================================================================
final void CheckAndDropNodeAt (subsector_t *ss, optional bool atBotOrigin) {
#ifdef BOT_PATHER_OLD
  if (!ss) return;
  botmo = Actor(player.MO);
  if (!botmo) return;
  if (botmo.Health <= 0 || botmo.Height < 8) return;

  bool oldNode = false;
  if (ss == botmo.SubSector) atBotOrigin = true; // why not?

  int ssnum = ss-&botmo.XLevel.Subsectors[0];
  if (ssnodes[ssnum]) {
    if (!ssnodes[ssnum].needRecalc) return;
    oldNode = true;
    if (bot_developer_messages_crumbs) printmsg(PMSG.BotDevCrumbs, "want to update a node in subsector #%d (%B)", ssnum, atBotOrigin);
  } else {
    if (bot_developer_messages_crumbs) printmsg(PMSG.BotDevCrumbs, "want to drop a new node in subsector #%d (%B)", ssnum, atBotOrigin);
  }

  // get subsector center
  TVec cpos = botmo.XLevel.GetSubsectorCenter(ss);
  cpos.z = EntityEx::ONFLOORZ;

  if (!IsGoodMapPosition(ref cpos)) {
    if (bot_developer_messages_crumbs) printmsg(PMSG.BotDevCrumbs, "oops; cannot spawn node at subsector #%d center...", ssnum);
    if (!atBotOrigin) return;
    cpos = botmo.Origin;
  }

  BotPathNode node = (oldNode ? ssnodes[ssnum] : BotPathNode.CreateNew(botmo.XLevel));
  if (!node) FatalError("something is very wrong in bot breadcrumbs");
  node.index = ssnum;
  node.Origin = cpos;
  node.needRecalc = false;

  // if our new node has no connections to other nodes, no need to invalidate path cache
  bool needCacheUpdate = false;

  // check reachable subsectors
  foreach (auto lidx; ss.firstline..ss.firstline+ss.numlines) {
    seg_t *seg = &botmo.XLevel.Segs[lidx];
    line_t *ld = seg.linedef;
    if (ld) {
      // not a miniseg
      if (!(ld.flags&ML_TWOSIDED)) continue; // not interesting
      if (ld.flags&(ML_BLOCKING|ML_BLOCKPLAYERS|ML_BLOCKEVERYTHING)) continue; // not interesting
    }
    if (!seg.partner || seg.partner.frontsub == seg.frontsub) continue; // not interesting

    // ok, this looks like something interesting
    int psnum = seg.partner.frontsub-&botmo.XLevel.Subsectors[0];
    if (bot_developer_messages_crumbs) printmsg(PMSG.BotDevCrumbs, "  crumb: src=%d; dest=%d", ssnum, psnum);

    BotPathNode otherNode = ssnodes[psnum];
    if (!otherNode) {
      // put a dummy node there
      cpos = botmo.XLevel.GetSubsectorCenter(seg.partner.frontsub);
      cpos.z = EntityEx::ONFLOORZ;
      if (IsGoodMapPosition(cpos)) {
        otherNode = BotPathNode.CreateNew(botmo.XLevel);
        otherNode.index = ssnum;
        otherNode.Origin = cpos;
        otherNode.needRecalc = false;
        ssnodes[psnum] = otherNode;
        if (bot_developer_messages_crumbs) printmsg(PMSG.BotDevCrumbs, "  crumb: created dummy node at #%s", psnum);
      }
    }

    if (otherNode) {
      bool canReachOther = otherNode.CanReachSSByIndex(ssnum);

      EntityEx::PathInfo pi;
      TAVec ang;
      TVec dir = otherNode.Origin-node.Origin;
      dir.z = 0;
      float dist = dir.length2D;

      // from ssnum to psnum
      if (!node.CanReachSSByIndex(psnum)) {
        needCacheUpdate = true;
        if (oldNode && !canReachOther) otherNode.needRecalc = true; // so it will be rechecked; just in case
        VectorAngles(dir, out ang);
        bool reached = botmo.TracePath(ang.yaw, dist, out pi, allowJump:true, allowDrop:true, ignoreMonsters:true, srcOrigin:node.Origin);
        // if not reached, but destination is in required subsector, consider this node reachable
        if (!reached) {
          dir.z = 0;
          TVec res = node.Origin+dir.normalise2D*pi.maxdist;
          subsector_t *dss = botmo.XLevel.PointInSubsectorRender(res);
          if (dss == seg.partner.frontsub) reached = true;
        }
        if (reached) {
          if (bot_developer_messages_crumbs) printmsg(PMSG.BotDevCrumbs, "  subsector #%d is reachable from #%d", psnum, ssnum);
          auto tr = node.ssreachable.alloc();
          tr.subnum = psnum;
          tr.dist = pi.maxdist;
          tr.needJump = pi.needJump;
          tr.needUse = pi.needUse;
          tr.moveCost = pi.maxdist*pi.maxdist+(pi.needUse ? 20 : 0);
          if (IsDangerous(seg.partner.frontsub.sector)) tr.moveCost *= 9;
        } else {
          if (bot_developer_messages_crumbs) printmsg(PMSG.BotDevCrumbs, "  crumb: ignored %s->%s (dest=%s)", ssnum, psnum, pi.maxdist);
        }
      }

      // from psnum to ssnum
      if (!oldNode || !canReachOther) {
        needCacheUpdate = true;
        otherNode.needRecalc = true; // so it will be rechecked; just in case
        dir = node.Origin-otherNode.Origin;
        VectorAngles(dir, out ang);
        bool reached = botmo.TracePath(ang.yaw, dist, allowJump:true, allowDrop:true, ignoreMonsters:true, srcOrigin:otherNode.Origin);
        // if not reached, but destination is in required subsector, consider this node reachable
        if (!reached) {
          dir.z = 0;
          TVec res = otherNode.Origin+dir.normalise2D*pi.maxdist;
          subsector_t *dss = botmo.XLevel.PointInSubsectorRender(res);
          if (dss == ss) reached = true;
        }
        if (reached) {
          if (bot_developer_messages_crumbs) printmsg(PMSG.BotDevCrumbs, "  subsector #%d is reachable from #%d", ssnum, psnum);
          auto tr = ssnodes[psnum].ssreachable.alloc();
          tr.subnum = ssnum;
          tr.dist = pi.maxdist;
          tr.needJump = pi.needJump;
          tr.needUse = pi.needUse;
          tr.moveCost = pi.maxdist*pi.maxdist+(pi.needUse ? 20 : 0);
          if (IsDangerous(seg.frontsub.sector)) tr.moveCost *= 9;
        } else {
          if (bot_developer_messages_crumbs) printmsg(PMSG.BotDevCrumbs, "  crumb: ignored %s->%s (dest=%s)", psnum, ssnum, pi.maxdist);
        }
      }
    }
  }
  ssnodes[ssnum] = node;

  if (needCacheUpdate && pather) {
    if (!(++lastNodeUpdate)) {
      lastNodeUpdate = 1;
      pather.lastNodeUpdate = 0; // so the cache will be invalidated on next path building
    }
  }
#endif
}


//==========================================================================
//
//  CheckAndDropNode
//
//==========================================================================
final void CheckAndDropNode () {
#ifdef BOT_PATHER_OLD
  if (!botmo.SubSector) return;
  CheckAndDropNodeAt(botmo.SubSector, atBotOrigin:true);
#endif
}


//==========================================================================
//
//  AngleDiff
//
//==========================================================================
/+
static final float AngleDiff (float afrom, float ato) {
  return AngleMod360(ato-afrom+180)-180;
  /*
  float a = ato-afrom;
  a += 180;
  a = a-ffloor(a/360.0)*360.0;
  return a-180;
  */
  //return (a+180)%360-180;
}
+/


//==========================================================================
//
//  AngleTo
//
//==========================================================================
final float AngleTo (TVec dest) {
  TAVec ang;
  TVec dir = dest-botmo.Origin;
  VectorAngles(dir, out ang);
  return ang.yaw;
}


//==========================================================================
//
//  PitchTo
//
//==========================================================================
final float PitchTo (TVec dest, optional bool useRealHeight) {
  TVec org = botmo.Origin;
  //FIXME: use `CalculateLineAttackZOfs()` here
  if (useRealHeight) org.z += botmo.Height*0.5-botmo.FloorClip+player.GetAttackZOfs;

  TAVec ang;
  TVec dir = dest-org;

  VectorAngles(dir, out ang);
  return ang.pitch;
}


//==========================================================================
//
//  PitchToEntity
//
//==========================================================================
final float PitchToEntity (EntityEx ent, optional bool useRealHeight) {
  if (!ent) return 0;

  //FIXME: use `CalculateLineAttackZOfs()` here
  TVec eorig = ent.Origin;
  if (useRealHeight) eorig.z += ent.Height*0.95-ent.FloorClip;

  //FIXME: use `CalculateLineAttackZOfs()` here
  TVec org = botmo.Origin;
  if (useRealHeight) org.z += botmo.Height*0.5-botmo.FloorClip+player.GetAttackZOfs;

  TAVec ang;
  TVec dir = eorig-org;

  VectorAngles(dir, out ang);
  return ang.pitch;
}


//==========================================================================
//
//  SkillLower
//
//==========================================================================
int SkillLower (int skill, int num) {
  if (num <= 0) return skill;
  skill = max(0, skill-num);
  return skill;
}


//==========================================================================
//
//  SetAngle
//
//==========================================================================
final void SetAngle (float an) {
  angle = AngleMod360(an);
}


//==========================================================================
//
//  GetAngle
//
//==========================================================================
final float GetAngle () {
  return angle;
}


//==========================================================================
//
//  GetRealAngle
//
//==========================================================================
final float GetRealAngle () {
  //return player.ViewAngles.yaw;
  return botmo.Angles.yaw;
}


//==========================================================================
//
//  ForceAngle
//
//==========================================================================
final void ForceAngle (float ang) {
  ang = AngleMod360(ang);
  angle = ang;
  player.ViewAngles.yaw = ang;
  botmo.Angles.yaw = ang;
}


//==========================================================================
//
//  IsDangerous
//
//  Checks if a sector is dangerous.
//
//==========================================================================
bool IsDangerous (sector_t *sec) {
  return false;
}


//==========================================================================
//
//  DistToPlane
//
//==========================================================================
final float DistToPlane (const ref TPlane plane, const ref TVec point) {
  return fabs(DotProduct(point, plane.normal));
}


//==========================================================================
//
//  CheckWeaponItem
//
//  return `true` to exit from `CheckItem` with `res` result
//  otherwise `res` has no meaning
//
//==========================================================================
bool CheckWeaponItem (Weapon Wpn, out bool res) {
  if (!Wpn) return false;

  // we cannot use melee weapons anyway
  if (Wpn.bBotMelee) { res = false; return true; }

  // if we don't have the weapon, pick it up
  Weapon exwpn = Weapon(botmo.FindInventory(class!Inventory(Wpn.Class)));
  if (!exwpn) { res = true; return true; }

  if (!Wpn.CanPickupForAmmo(exwpn)) { res = false; return true; }

  // if we have no more room for the ammo it gives
  auto ammo1 = Ammo(Wpn.AmmoType1 ? botmo.FindInventory(Wpn.AmmoType1) : none);
  if (ammo1 && ammo1.Amount == ammo1./*MaxAmount*/k8GetAmmoKingMax()) { res = false; return true; }

  // can't pick it up because we have it and it's not a dropped weapon
  if (!Wpn.bDropped) { res = false; return true; }

  res = true;
  return true;
}


//==========================================================================
//
//  CheckSpecialItem
//
//  return `true` to exit from `CheckItem` with `res` result
//  otherwise `res` has no meaning
//
//==========================================================================
bool CheckSpecialItem (Actor aitem, out bool res) {
  return false;
}


//==========================================================================
//
//  CheckAmmoItem
//
//  return `true` to exit from `CheckItem` with `res` result
//  otherwise `res` has no meaning
//
//==========================================================================
bool CheckAmmoItem (Ammo ammo, out bool res) {
  // if we have no more room for the ammo it gives
  Ammo AmmoItem = Ammo(botmo.FindInventory(ammo.GetParentAmmo()));
  if (AmmoItem && AmmoItem.Amount >= AmmoItem./*MaxAmount*/k8GetAmmoKingMax()) { res = false; return true; }

  res = true;
  return true;
}


//==========================================================================
//
//  CheckOtherItem
//
//  return `true` to exit from `CheckItem` with `res` result
//  otherwise `res` has no meaning
//
//==========================================================================
bool CheckOtherItem (Actor aitem, out bool res) {
  if (Health(aitem) && botmo.Health >= PlayerEx::MAXHEALTH) { res = false; return true; }
  //if ((aitem.Class == Soulsphere || aitem.Class == Megasphere) && botmo.Health >= 2*PlayerEx::MAXHEALTH) return false;

  BasicArmor Armor = BasicArmor(botmo.FindInventory(BasicArmor, disableReplacement:true));
  if (!Armor) return false;

  if (BasicArmorPickup(aitem) && (Armor.Amount >= BasicArmorPickup(aitem).SaveAmount)) { res = false; return true; }
  //if (aitem.Class == Megasphere && Armor.Amount >= 200) return false;

  return false;
}


//==========================================================================
//
//  CheckItem
//
//  Determines if we should bother picking up an item or not
//
//==========================================================================
bool CheckItem (Actor aitem) {
  bool res;

  bNewItemIsWeapon = false;
  bNewItemIsPowerup = false;

  if (!aitem) return false;
  if (!aitem.bSpecial || aitem.bInvisible) return false;

  Weapon Wpn = Weapon(aitem);
  if (Wpn) {
    bNewItemIsWeapon = true;
    if (CheckWeaponItem(Wpn, out res)) return res;
  }

  if (CheckSpecialItem(aitem, out res)) return res;

  Ammo ammo = Ammo(aitem);
  if (ammo && CheckAmmoItem(ammo, out res)) return res;

  if (CheckOtherItem(aitem, out res)) return res;

  // guess we're okay
  return true;
}


//==========================================================================
//
//  FindAllyToSupport
//
//==========================================================================
Actor FindAllyToSupport (bool allowESP) {
  if (player.Level.Game.deathmatch) return none;
  // search for player enemies in deathmatch
  //printmsg(PMSG.BotDevAI, "looking for player...");
  Actor target = none;
  float closest_dist = 99999.0;
  foreach (auto i; 0..MAXPLAYERS) {
    auto plr = player.Level.Game.Players[i];
    if (!plr) continue;
    if (!plr.bIsBot && plr.bSpawned && plr.MO.Health > 0 && botmo != plr.MO) {
      float temp = plr.MO.DistTo(botmo);
      if (temp > SAFE_SELF_MISDIST && temp < closest_dist) {
        if (Check_LOS(Actor(plr.MO), 360) || CheckTo(plr.MO.Origin)) {
          closest_dist = temp;
          target = Actor(plr.MO);
        }
      }
    }
  }
  if (target) {
    ResetCurrPath();
    return target;
  }

  if (allowESP) {
    // use ESP to get to player, lol
    foreach (auto i; 0..MAXPLAYERS) {
      auto plr = player.Level.Game.Players[i];
      if (!plr) continue;
      if (!plr.bIsBot && plr.bSpawned && plr.MO.Health > 0 && botmo != plr.MO) {
        if (HavePathToPoint(plr.MO.Origin, plr.MO.SubSector)) {
          if (bot_developer_messages_roam) printmsg(PMSG.BotDevRoam, "*** ESP activated! src=%d, dst=%d", botmo.SubSector-&botmo.XLevel.Subsectors[0], plr.MO.SubSector-&botmo.XLevel.Subsectors[0]);
          UseCurrentPath();
          break;
        } else {
          if (bot_developer_messages_roam) printmsg(PMSG.BotDevRoam, "*** CANNOT activate ESP! src=%d, dst=%d", botmo.SubSector-&botmo.XLevel.Subsectors[0], plr.MO.SubSector-&botmo.XLevel.Subsectors[0]);
        }
      }
    }
  }

  return none;
}


//==========================================================================
//
//  SetEnemy
//
//==========================================================================
void SetEnemy () {
  // never attack other players in coop
  if (enemy && enemy.bIsPlayer && !player.Level.Game.deathmatch) {
    // reset enemy
    if (bot_developer_messages_attack) printmsg(PMSG.BotDevAttack, "bot '%s': oops, coop enemy is another player!", player.PlayerName);
    enemy = none;
  }

  if (enemy && enemy.Health > 0 && player.MO && player.MO.CanSee(enemy)) {
    return;
  }

  bAllRound = !!enemy;
  enemy = FindEnemy();

  if (!enemy) return;

  // double check the validity of the enemy
  if (!enemy.bShootable) enemy = none;

  // run to human player to give some support
  if (!enemy) {
    Actor target = FindAllyToSupport(allowESP:true);
    if (target && botmo.DistTo2(target) > 96) {
      ForceAngle(AngleTo(target.Origin));
      lastpos = target.Origin;
      lastpos_valid = true;
      posdest_valid = false;
      posdest_set_time = 0;
      item = none;
      if (bot_developer_messages_roam) printmsg(PMSG.BotDevRoam, "bot '%s': going to support %C", player.PlayerName, target);
    }
  }
}


//==========================================================================
//
//  CheckStuff
//
//  Make sure that our destinations/enemies and everything are valid.
//
//==========================================================================
void CheckStuff () {
  if (item) {
    if (!item.bSpecial || item.bInvisible || item.IsDestroyed /*|| // somebody picked
        !CheckTo(item.Origin)*/) // can't reach
    {
      PutItemToIgnoreList(item, 0.8);
      item = none;
      itemFirstSeenTime = 0;
    }
  }

  if (missile) {
    if (!missile.bMissile || missile.IsDestroyed) missile = none;
  }

  if (node) {
    if (!CheckTo(node.Origin) || botmo.DistTo2(node) < botmo.Radius) {
      prev = node;
      node = none;
    }
  }

  /*
  if (posdest_valid) {
    TVec dir = posdest-botmo.Origin;
    dir.z = 0.0;
    if (Length2D(dir) < botmo.Radius || !CheckTo(posdest)) {
      posdest_valid = false;
    }
  }

  if (lastpos_valid) {
    TVec dir = lastpos-botmo.Origin;
    dir.z = 0.0;
    if (Length2D(dir) < botmo.Radius || !CheckTo(lastpos)) {
      lastpos_valid = false;
    }
  }
  */

  if (enemy) {
    if (enemy.IsDestroyed || enemy.Health <= 0 || !enemy.bShootable) enemy = none;
  }
}


transient array!Actor otherItems;


//==========================================================================
//
//  Scan
//
//  Scan all mobj's visible to the bot for incoming missiles, enemies, and
//  various items to pick up.
//
//==========================================================================
void Scan () {
  if (currPath.length) return;

  if (currPathAllyForceTimeout > botmo.XLevel.Time) {
    if (FindAllyToSupport(allowESP:true)) {
      currPathAllyForceTimeout = 0;
      printmsg(PMSG.BotDevAI, "bot '%s' found ally!", player.PlayerName);
    } else {
      if (currPath.length) return;
      currPathAllyForceTimeout = 0;
      printmsg(PMSG.BotDevAI, "bot '%s' can't find an ally!", player.PlayerName);
    }
  }

  if (!enemy && !item) {
    if (!FindAllyToSupport(allowESP:false)) {
      FindAllyToSupport(allowESP:true);
      if (currPath.length) {
        item = none;
        return;
      }
    }
  }

  float currTime = botmo.XLevel.Time;

  // check if bot tried to get current item for too long
  if (item) {
    if (currTime-itemFirstSeenTime > ITEM_GIVEUP_TIME) {
      PutItemToIgnoreList(item);
      item = none;
      itemFirstSeenTime = 0;
    }
  }

  Entity ee;
  otherItems.reset();
  foreach botmo.RadiusThings(out ee, botmo.Origin, ITEM_SCAN_RADIUS) {
    Actor actor = Actor(ee);
    if (!actor) continue;
    if (actor.bInvisible) continue;
    if (!actor.bSpecial && !actor.bMissile) {
      // not interested in this one
      continue;
    }
    if (Check_LOS(actor, 90.0)) {
      // look for special items
      if (!item && actor.bSpecial) {
        // check if we should ignore this item
        auto dip = itemIgnoreTimeout.find(actor);
        if (dip) {
          if (*dip > currTime) continue; // ignore it
          if (bot_developer_messages_items) printmsg(PMSG.BotDevItems, "bot '%s' wants %C again (%s)", player.PlayerName, actor.Class, currTime-(*dip));
          // it is ok to obtain, remove from list
          itemIgnoreTimeout.del(actor);
        }
        if (CheckItem(actor) && HavePathToPoint(actor.Origin, actor.SubSector)) {
          if (bot_developer_messages_items) printmsg(PMSG.BotDevItems, "bot '%s' wants %s", player.PlayerName, actor.Class);
          UseCurrentPath();
          item = actor;
          bItemIsWeapon = bNewItemIsWeapon;
          bItemIsPowerup = bNewItemIsPowerup;
        } else {
          if (bot_developer_messages_items) printmsg(PMSG.BotDevItems, "bot '%s' ignores %s", player.PlayerName, actor.Class);
        }
      } else if (!missile && actor.bMissile && botmo.DistTo(actor) < AVOID_DIST) {
        missile = actor;
      }
    } else if (actor.bSpecial) {
      auto dip = itemIgnoreTimeout.find(actor);
      if (dip) {
        if (*dip > currTime) continue; // ignore it
        if (bot_developer_messages_items) printmsg(PMSG.BotDevItems, "bot '%s' wants %C again (%s)", player.PlayerName, actor.Class, currTime-(*dip));
        // it is ok to obtain, remove from list
        itemIgnoreTimeout.del(actor);
      }
      if (player.Level.Game.deathmatch) {
        // not a coop
        Weapon wpn = Weapon(actor);
        if (wpn) otherItems[$] = actor;
      }
    }
  }

  if (!item && otherItems.length) {
    if (!player.Level.Game.deathmatch) {
      // coop, don't chase items
      otherItems.reset();
      item = none;
    } else {
      while (otherItems.length) {
        int idx = roundi(FRandomFull()*otherItems.length)%otherItems.length;
        Actor act = otherItems[idx];
        otherItems.remove(idx);
        if (CheckItem(act) && HavePathToPoint(act.Origin, act.SubSector)) {
          if (bot_developer_messages_items) printmsg(PMSG.BotDevItems, "going to unseen item %C", act);
          UseCurrentPath();
          item = act;
          break;
        }
      }
    }
  }
}


// ////////////////////////////////////////////////////////////////////////// //
const float UseCooldown = 3; // three seconds

// use delegates
final bool checkThingUse (EntityEx th) {
  auto tlt = lastUsedThings.find(th);
  if (tlt && *tlt > botmo.XLevel.Time) return false; // cooldown is not complete
  return true;
}

final void onThingUsed (EntityEx th) {
  printmsg(PMSG.BotDevAI, "bot '%s' used thing '%C'", player.PlayerName, th);
  lastUsedThings.put(th, botmo.XLevel.Time+UseCooldown);
}

final bool checkLineUse (line_t *ld) {
  int lidx = ld-&botmo.XLevel.Lines[0];
  auto tlt = lastUsedLines.find(lidx);
  if (tlt && *tlt > botmo.XLevel.Time) return false; // cooldown is not complete
  return true;
}

final void onLineUsed (line_t *ld) {
  int lidx = ld-&botmo.XLevel.Lines[0];
  printmsg(PMSG.BotDevAI, "bot '%s' used line #%s", player.PlayerName, lidx);
  lastUsedLines.put(lidx, botmo.XLevel.Time+UseCooldown);
}


//==========================================================================
//
//  PerformLastCheckActions
//
//==========================================================================
void PerformLastCheckActions (const ref EntityEx::PathInfo pi) {
#ifdef BOT_ALLOW_JUMPS
  if (pi.needJump && !bot_no_jump && player.IsJumpEnabled()) player.Buttons |= BT_JUMP;
#endif
  if (pi.needUse) {
    //EntityEx(player.MO).UseLines(PlayerEx::DEFAULT_USERANGE, PlayerEx::DEFAULT_USETHINGRANGE, '*usefail');
    float ur, utr;
    player.GetUseRanges(out ur, out utr);
    EntityEx(player.MO).UseLines(/*PlayerEx::DEFAULT_USERANGE*/ur, /*PlayerEx::DEFAULT_USETHINGRANGE*/utr, '', // don't produce any sound on fail
      &checkLineUse, &onLineUsed, &checkThingUse, &onThingUsed);
  }
}


//==========================================================================
//
//  CheckTo
//
//  Checks if an location is reachable
//
//==========================================================================
bool CheckTo (TVec pos, optional out EntityEx::PathInfo pi) {
  TVec v2 = botmo.Origin-pos;
  v2.z = 0;
  if (!v2) return true;
  float dist = Length2D(v2);
  float an = GetAngle();
  return botmo.TracePath(an, dist, pi!optional, allowJump:true, ignoreMonsters:true, allowDrop:true);
}


//==========================================================================
//
//  CheckToEnt
//
//  Checks if an location is reachable
//
//==========================================================================
bool CheckToEnt (Entity ent, optional out EntityEx::PathInfo pi) {
  TVec v2 = botmo.Origin-ent.Origin;
  v2.z = 0;
  if (!v2) return true;
  float dist = Length2D(v2);
  float an = GetAngle();
  return botmo.TracePath(an, dist, pi!optional, distEnt:ent, allowJump:true, ignoreMonsters:true, allowDrop:true);
}


//==========================================================================
//
//  CanGetCloserTo
//
//  Checks if we can move a little closer
//
//==========================================================================
bool CanGetCloserTo (TVec pos) {
  TVec v2 = botmo.Origin-pos;
  v2.z = 0;
  if (!v2) return true;
  float dist = Length2D(v2);
  float an = GetAngle();
  EntityEx::PathInfo pi;
  if (botmo.TracePath(an, dist, out pi, allowJump:true, ignoreMonsters:true, allowDrop:true)) return true;
  return (pi.maxdist >= 32); // at least half of a tile
}


//==========================================================================
//
//  CanGetCloserToEnt
//
//  Checks if we can move a little closer
//
//==========================================================================
bool CanGetCloserToEnt (Entity ent) {
  TVec v2 = botmo.Origin-ent.Origin;
  v2.z = 0;
  if (!v2) return true;
  float dist = Length2D(v2);
  float an = GetAngle();
  EntityEx::PathInfo pi;
  if (botmo.TracePath(an, dist, out pi, distEnt:ent, allowJump:true, ignoreMonsters:true, allowDrop:true)) return true;
  return (pi.maxdist >= 32); // at least half of a tile
}


//==========================================================================
//
//  Check_LOS
//
//  Doesnt check LOS, checks visibility with a set view angle.
//  B_Checksight checks LOS (straight line)
//
//  Check if mo1 has free line to mo2 and if mo2 is within mo1 viewangle
// (vangle) given with normal degrees. If these conditions are true, the
// function returns true. GOOD TO KNOW is that the players view angle in
// doom is 90 degrees infront.
//
//==========================================================================
final bool Check_LOS (Actor to, float vangle, optional bool skipCanSee) {
  if (!to) return false;
  if (vangle <= 0) return false; // looker seems to be blind
  if (vangle < 360.0) {
    // check FOV
    if (fabs(AngleMod180(AngleTo(to.Origin)-GetRealAngle())) > vangle/2.0) return false;
  }
  if (!skipCanSee && !botmo.CanSee(to, disableBetterSight:true)) return false; // out of sight
  return true;
}


//==========================================================================
//
//  GoodAngle
//
//==========================================================================
final bool GoodAngle (Actor to, float vangle) {
  if (!to) return true;
  if (vangle <= 0) return false; // looker seems to be blind
  if (vangle >= 360.0) return true;
  // check FOV
  return (fabs(AngleMod180(AngleTo(to.Origin)-GetRealAngle())) <= vangle/2.0);
}


//==========================================================================
//
//  BotAimProjectile
//
//==========================================================================
void BotAimProjectile (float dist, bool right, float an) {
  if (!enemy) return; // just in case

  // splash weapons
  //bot->SetAngle(R_PointToAngle2(MO->x, MO->y, enemy->x, enemy->y));

  // [BC] cajun prediction
  // here goes the prediction.
  float m = dist/875.0; //FIXME: determine current weapon's missile speed
  float px = enemy.Origin.x+(enemy.Velocity.x*m*2.0);
  float py = enemy.Origin.y+(enemy.Velocity.y*m*2.0);

  // projectile weapons
  switch (info.intelect) {
    case LineSpecialGameInfo::bsk_verypoor:
    case LineSpecialGameInfo::bsk_poor:
      if (MainGameInfo(player.Level.Game).botskill > 3 && Random() < 0.01) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      } else {
        // aim right at the enemy
        SetAngle(an);
      }
      break;
    case LineSpecialGameInfo::bsk_low:
      if (MainGameInfo(player.Level.Game).botskill > 2 && Random() < 0.03) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      } else {
        // aim right at the enemy
        SetAngle(an);
      }
      break;
    case LineSpecialGameInfo::bsk_medium:
      if (MainGameInfo(player.Level.Game).botskill > 2 && Random() < 0.09) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      } else {
        if (right) SetAngle(an+Random()*20.0); else SetAngle(an-Random()*20.0);
      }
      break;
    case LineSpecialGameInfo::bsk_high:
      if (MainGameInfo(player.Level.Game).botskill > 1 && Random() < 0.9) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      }
      else {
        if (right) SetAngle(an+Random()*20.0); else SetAngle(an-Random()*20.0);
      }
      break;
    case LineSpecialGameInfo::bsk_excellent:
      if (MainGameInfo(player.Level.Game).botskill > 1 && Random() < 0.3) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      } else {
        if (right) SetAngle(an+Random()*20.0); else SetAngle(an-Random()*20.0);
      }
      break;
    case LineSpecialGameInfo::bsk_supreme:
      if (MainGameInfo(player.Level.Game).botskill > 0 && Random() < 0.1) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      } else {
        if (right) SetAngle(an+Random()*20.0); else SetAngle(an-Random()*20.0);
      }
      break;
    default:
      Error("Unknown bot skill level: %d", info.intelect);
      return;
  }
}


//==========================================================================
//
//  BotAimInstant
//
//  instant weapons
//
//==========================================================================
void BotAimInstant (float dist, bool right, float an) {
  // [CW]
  if (info.accuracy > LineSpecialGameInfo::bsk_verypoor &&
      info.accuracy <= LineSpecialGameInfo::bsk_high &&
      dist <= EntityEx::DEFAULT_MELEERANGE*2.0)
  {
    SetAngle(an);
    return;
  }

  //FIXME: Implement botskill, accuracy, and intelligence
  switch (info.accuracy) {
    case LineSpecialGameInfo::bsk_verypoor:
      if (right) SetAngle(an+Random()*60.0); else SetAngle(an-Random()*60.0);
      break;
    case LineSpecialGameInfo::bsk_poor:
      if (right) SetAngle(an+Random()*45.0); else SetAngle(an-Random()*45.0);
      break;
    case LineSpecialGameInfo::bsk_low:
      if (right) SetAngle(an+Random()*30.0); else SetAngle(an-Random()*30.0);
      break;
    case LineSpecialGameInfo::bsk_medium:
      if (right) SetAngle(an+Random()*15.0); else SetAngle(an-Random()*15.0);
      break;
    case LineSpecialGameInfo::bsk_high:
      SetAngle(an);
      break;
    case LineSpecialGameInfo::bsk_excellent:
      SetAngle(AngleTo(enemy.Origin+enemy.Velocity*0.1));
      break;
    case LineSpecialGameInfo::bsk_supreme://FIXME
      SetAngle(AngleTo(enemy.Origin+enemy.Velocity*0.1));
      break;
    default:
      Error("BotPlayer::AimInstant::Unknown bot accuracy skill level: %d", info.accuracy);
      return;
  }
}


//==========================================================================
//
//  BotAimSpecial
//
//==========================================================================
bool BotAimSpecial (float dist, bool right, float an) {
  /*
  if (player.ReadyWeapon.bBotBfg) {
    // BFG9000
    SetAngle(AngleTo(enemy.Origin));
    return true;
  }
  */
  return false;
}


//==========================================================================
//
//  BotAim
//
//==========================================================================
void BotAim () {
  float dist;
  bool right;
  float an;

  if (!enemy) return;

  if (t_react) return;

  // distance to enemy
  dist = botmo.DistTo2(enemy);

  right = !!(P_Random()&1);
  an = AngleTo(enemy.Origin);

  //Pitch(); // do it in attack code instead

  if (BotAimSpecial(dist, right, an)) return;

  if (player.ReadyWeapon.bBotProjectile) {
    BotAimProjectile(dist, right, an);
  } else {
    BotAimInstant(dist, right, an);
  }
}


//==========================================================================
//
//  FindMonsterOffender
//
//==========================================================================
Actor FindMonsterOffender () {
  if (player.Level.Game.deathmatch) return none;

  //printmsg(PMSG.BotDevAI, "looking for other player's offenders...");
  // roughTarget is for fellow bot, narrowTarget is for human player
  float bestNarrowDist = float.max;
  float bestRoughDist = float.max;
  Actor narrowTarget = none;
  Actor roughTarget = none;

  foreach (auto i; 0..MAXPLAYERS) {
    auto plr = player.Level.Game.Players[i];
    if (!plr) continue;
    if (!plr.bSpawned /*|| plr.MO.Health <= 0*/ || botmo == plr.MO) continue;
    auto act = Actor(PlayerEx(plr).Attacker);
    if (!act || !act.bMonster || act.bMissile || act.Health <= 0) continue;
    if (!Check_LOS(act, 360)) continue;
    if (bot_developer_messages_attack) printmsg(PMSG.BotDevAttack, "  bot '%s': player %d offender is %C", player.PlayerName, i, act);
    float dist = botmo.DistTo2(act);
    if (plr.bIsBot) {
      if (!roughTarget || dist < bestRoughDist) { roughTarget = act; bestRoughDist = dist; }
    } else {
      if (!narrowTarget || dist < bestNarrowDist) { narrowTarget = act; bestNarrowDist = dist; }
    }
  }

  //printmsg(PMSG.BotDevAI, " narrow: %C; rough: %C", narrowTarget, roughTarget);
  return (narrowTarget ? narrowTarget : roughTarget);
}


//==========================================================================
//
//  FindMonsterEnemy
//
//==========================================================================
Actor FindMonsterEnemy () {
  auto oldEnemy = enemy;
  scope(exit) enemy = oldEnemy;
  // if we have no enemy, but an attacker, switch to attacker
  Actor narrowTarget = none;
  float bestNarrowDist = float.max;
  Actor roughTarget = none;
  float bestRoughDist = float.max;

  Entity ee;
  foreach botmo.RadiusThings(ee, botmo.Origin, MONSTER_SCAN_RADIUS) {
    if (ee == botmo) continue; // don't target self
    Actor act = Actor(ee);
    if (!act) continue;
    if (!act.bShootable || !act.bMonster || act.bMissile) continue; // not interesting
    if (act.Health <= 0) continue; // it is dead
    float temp = act.DistTo(botmo);
    if (temp < 512 && temp < bestNarrowDist && GoodAngle(act, 120)) {
      enemy = act; // for `Check_LOS()`
      if (Check_LOS(act, 360) /*|| CheckTo(act.Origin)*/) {
        bestNarrowDist = temp;
        narrowTarget = act;
      }
    }
    if (!roughTarget && temp < bestRoughDist && GoodAngle(act, 180)) {
      enemy = act; // for `Check_LOS()`
      if (Check_LOS(act, 360) /*|| CheckTo(act.Origin)*/) {
        bestRoughDist = temp;
        roughTarget = act;
      }
    }
  }

  if (narrowTarget) return narrowTarget;
  if (roughTarget) return roughTarget;

  // if no targets, and we are in coop, attack the monster than hurts the player
  return FindMonsterOffender();
}


//==========================================================================
//
//  FindEnemy
//
//==========================================================================
Actor FindEnemy () {
  // note: it's hard to ambush a bot who is not alone
  float vangle = (bAllRound || ally ? 360.0 : ENEMY_SCAN_FOV);
  bAllRound = false;

  Actor target = none;
  float closest_dist = 99999.0;

  // if we have no enemy, but an attacker, switch to attacker
  if (!enemy && player.Attacker) {
    Actor act = Actor(player.Attacker);
    if (act && act != botmo && act.Health > 0 && act.bShootable && (act.bMonster || act.bIsPlayer)) {
      if (!player.Level.Game.deathmatch && act.bIsPlayer) act = none;
      if (act && Check_LOS(act, 360)) {
        if (bot_developer_messages_attack) printmsg(PMSG.BotDevAttack, "bot '%s' is retaliating to %C", player.PlayerName, act);
        return act;
      }
    }
  }

  if (player.Level.Game.deathmatch) {
    // search for player enemies in deathmatch
    bool ignoreHumans = bot_ignore_humans;
    foreach (auto i; 0..MAXPLAYERS) {
      auto plr = player.Level.Game.Players[i];
      if (!plr) continue;
      if (!plr.bSpawned || plr.MO == botmo || plr.MO.Health <= 0) continue;
      if (ignoreHumans && !plr.bIsBot) continue;
      float temp = plr.MO.DistTo(botmo);
      if (temp < closest_dist) {
        if (Check_LOS(Actor(plr.MO), vangle)) {
          closest_dist = temp;
          target = Actor(plr.MO);
        }
      }
    }
  }

  // if no target, try to find some monster
  if (!target) target = FindMonsterEnemy();

  return target;
}


//==========================================================================
//
//  RoamRandom
//
//  support function for roaming
//  returns `true` if no further roam actions should be taken
//
//==========================================================================
void RoamRandom (out TVec dest) {
  float an = GetRealAngle();

  if (bot_developer_messages_roam) printmsg(PMSG.BotDevRoam, "bot '%s' has nothing to do; an=%s", player.PlayerName, an);

  posdest_valid = false;

  EntityEx::PathInfo piFwd, piLeft, piRight;
  float dist = 1024.0;

  Actor allyToSupport = FindAllyToSupport(allowESP:true);
  if (allyToSupport) {
    CheckTo(allyToSupport.Origin, out piFwd);
    if (bot_developer_messages_roam) printmsg(PMSG.BotDevRoam, "bot '%s', ally to support is '%C', angle=%s; maxdist=%s", player.PlayerName, allyToSupport, piFwd.maxdist, piFwd.angle);
    if (piFwd.maxdist > 96) {
      SetAngle(piFwd.angle);
      PerformLastCheckActions(piFwd);
      forwardmove = FORWARDRUN;
      lastpos = allyToSupport.Origin;
      lastpos_valid = true;
      posdest_valid = false;
      posdest_set_time = 0;
      item = none;
      return;
    }
  }

  if (FollowPath()) return;

  if (botmo.TracePath(an, dist, out piFwd, allowJump:true)) {
    posdest_valid = true;
    posdest = botmo.Origin+dist*piFwd.dirxy;
    SetAngle(piFwd.angle);
    PerformLastCheckActions(piFwd);
    forwardmove = FORWARDWALK;
    return;
  }

  // check left and right
  botmo.TracePath(an+45, dist, out piLeft, allowJump:true);
  botmo.TracePath(an-45, dist, out piRight, allowJump:true);

  // random choice
  EntityEx::PathInfo *pip[3];
  pip[0] = &piFwd;
  pip[1] = &piLeft;
  pip[2] = &piRight;

  int swap0 = 0, swap1 = 0;
  if (P_Random() > 127) {
    swap0 = 1;
    swap1 = 2;
  } else if (P_Random() > 127) {
    swap0 = 0;
    swap1 = 1;
  } else if (P_Random() > 127) {
    swap0 = 0;
    swap1 = 2;
  }
  {
    auto tmp = pip[swap0]; pip[swap0] = pip[swap1]; pip[swap1] = tmp;
  }

  //int idx = P_Random()%pip.length;
  foreach (auto n; 0..pip.length) {
    EntityEx::PathInfo *pi = pip[n];
    n = (n+1)%pip.length;
    if (pi.success || pi.maxdist > 64) {
      posdest_valid = true;
      posdest = botmo.Origin+dist*pi.dirxy;
      SetAngle(pi.angle);
      PerformLastCheckActions(*pi);
      forwardmove = FORWARDWALK;
      return;
    }
  }

  // cannot move, turn around
  SetAngle(GetAngle()+10.0+35.0*FRandomFull());
  // walk anyway
  forwardmove = FORWARDWALK;
  // do random jump in case we can free ourself with it
#ifdef BOT_ALLOW_JUMPS
  if (P_Random() > 127 && !bot_no_jump && player.IsJumpEnabled()) player.Buttons |= BT_JUMP;
#endif

  return;
}


//==========================================================================
//
//  FollowPath
//
//==========================================================================
final bool FollowPath () {
  float currTime = botmo.XLevel.Time;
  int ssnum = botmo.SubSector-&botmo.XLevel.Subsectors[0];
  EntityEx::PathInfo pi;

  // check if we are staying in the same node for too long
  if (lastSubsector == ssnum && lastSSChangeTime) {
    if (currTime-lastSSChangeTime > 4) {
      if (currDestNodeIdx < currPath.length) {
        if (bot_developer_messages_planpath) {
          printmsg(PMSG.BotDevPlanPath, "DAMMIT! bot '%s' cannot move from subsector #%d to subsector #%d in %s seconds, dropping the path", player.PlayerName, ssnum, currPath[$-1], currTime-lastSSChangeTime);
        }
      }
      ResetCurrPath();
      lastSSChangeTime = currTime;
      SetAngle(FRandomBetween(0, 360));
      return false; // no path
    }
  } else {
    lastSubsector = ssnum;
    lastSSChangeTime = currTime;
  }

  float pangle = GetRealAngle();

  // running by path
  // [0] should be current bot node
  // [1] is the next node
  while (currDestNodeIdx < currPath.length) {
    if (ssnum == currPath[currDestNodeIdx]) {
      // bot is a current node, check if we can go to the next one
      currAlienNodeTime = 0; // reset current node switch timer

      if (currDestNodeIdx+1 >= currPath.length) {
        // no next node, arrived
        ResetCurrPath();
        break;
      }

      if (bot_run_to_subsector_center) {
#ifdef BOT_PATHER_OLD
        BotPathNode ptnode = ssnodes[currPath[currDestNodeIdx+1]];
#else
        BotPathNode ptnode = pather.nodes[currPath[currDestNodeIdx+1]];
#endif

        float dist = (botmo.Origin-ptnode.Origin).length2D;
        bool canReach = botmo.TracePath(pangle, dist, out pi, allowJump:true, allowDrop:true, ignoreMonsters:true);
        if (!canReach && pi.maxdist >= dist*0.5) canReach = true;

        if (!canReach) {
          // cannot reach, try to get to current subsector center
#ifdef BOT_PATHER_OLD
          ptnode = ssnodes[currPath[currDestNodeIdx]];
#else
          ptnode = pather.nodes[currPath[currDestNodeIdx]];
#endif
          dist = (botmo.Origin-ptnode.Origin).length2D;
          if (dist > botmo.Radius*6) {
            if (bot_developer_messages_path) printmsg(PMSG.BotDevPath, "bot '%s' is going to center of subsector #%d for #%s (%s left)", player.PlayerName, ssnum, currTime-lastSSChangeTime, dist-botmo.Radius*6);
            float ptangle = AngleTo(ptnode.Origin);
            if (fabs(AngleDiff(GetAngle(), ptangle)) > 25) SetAngle(ptangle);
                 if (dist <= 64+32) forwardmove = 32;
            else if (dist <= 128) forwardmove = FORWARDWALK;
            else forwardmove = FORWARDRUN;
            botmo.TracePath(pangle, dist, out pi, allowJump:true, allowDrop:true);
            PerformLastCheckActions(pi);
            return true;
          }
        }
      }

      // bot in a current node, go to the next one
      ++currDestNodeIdx;
    } else {
#ifdef BOT_PATHER_OLD
      BotPathNode ptnode = ssnodes[currPath[currDestNodeIdx]];
#else
      BotPathNode ptnode = pather.nodes[currPath[currDestNodeIdx]];
#endif
      // bot is not in a current node, setup timer
      if (currAlienNodeTime) {
        // more than 3 seconds away from our destination node?
        if (currTime-currAlienNodeTime > 3) {
          // yes, replan path
          if (bot_developer_messages_path) printmsg(PMSG.BotDevPath, "bot '%s' is staying away from its destination ss #%s (at #%s) for #%s, replanning", player.PlayerName, ptnode.index, ssnum, currTime-currAlienNodeTime);
          if (!HavePathToSS(&botmo.XLevel.Subsectors[currPath[$-1]])) {
            // alas, no path
            if (bot_developer_messages_path) printmsg(PMSG.BotDevPath, "bot '%s' cannot replan its path to #%d from #%s", player.PlayerName, currPath[$-1], ssnum);
            ResetCurrPath();
            return false;
          }
          if (bot_developer_messages_path) printmsg(PMSG.BotDevPath, "bot '%s' replanned its path to #%d from #%s", player.PlayerName, currPath[$-1], ssnum);
          // ok, path is replanned, follow it
          UseCurrentPath();
          continue;
        }
      } else {
        currAlienNodeTime = currTime;
      }

      if (bot_developer_messages_path) printmsg(PMSG.BotDevPath, "bot '%s' is going to subsector #%d (from #%d)", player.PlayerName, ptnode.index, ssnum);
      float ptangle = AngleTo(ptnode.Origin);
      if (fabs(AngleDiff(GetAngle(), ptangle)) > 25) SetAngle(ptangle);
      float dist = (botmo.Origin-ptnode.Origin).length2D;
           if (dist <= 64+32) forwardmove = FORWARDWALK;
      else forwardmove = FORWARDRUN;
      botmo.TracePath(pangle, dist, out pi, allowJump:true, allowDrop:true);
      PerformLastCheckActions(pi);
      return true;
    }
  }

  if (bot_developer_messages_path) printmsg(PMSG.BotDevPath, "bot '%s' arrived to destination subsector #%d", player.PlayerName, ssnum);
  ResetCurrPath();
  return false;
}


//==========================================================================
//
//  Roam
//
//  Handle non-attack/dodging movement
//
//==========================================================================
void Roam () {
  if (FollowPath()) return;

  if (FindAllyToSupport(allowESP:false)) {
    ResetCurrPath();
  }

  if (FollowPath()) return;

  TVec dest;
  float currTime = botmo.XLevel.Time;

  /*
  if (lastpos_valid) {
    TVec dir = lastpos-botmo.Origin;
    dir.z = 0.0;
    if (Length2D(dir) <= 32.0) lastpos_valid = false;
  }
  */

  if (item && !CheckTo(item.Origin)) {
    if (!HavePathToPoint(item.Origin, item.SubSector)) {
      // forget for some time
      PutItemToIgnoreList(item, 1.0/4.0);
      item = none;
      itemFirstSeenTime = 0;
    } else {
      UseCurrentPath();
      if (FollowPath()) return;
    }
  }

  if (item && currTime-itemFirstSeenTime > ITEM_GIVEUP_TIME) {
    PutItemToIgnoreList(item, 0.9);
    item = none;
    itemFirstSeenTime = 0;
  }

  EntityEx::PathInfo pi;
  bool destValid = false;

  // order of item response precedence
  if (goal) {
    dest = goal.Origin;
    if (HavePathToPoint(dest) || CanGetCloserTo(dest)) {
      destValid = true;
      if (bot_developer_messages_roam) printmsg(PMSG.BotDevRoam, "bot '%s' is going to goal at %s from %s", player.PlayerName, dest, botmo.Origin);
    }
  }

  if (!destValid && lastpos_valid) {
    dest = lastpos;
    if (HavePathToPoint(dest) || CanGetCloserTo(dest)) {
      destValid = true;
      if (bot_developer_messages_roam) printmsg(PMSG.BotDevRoam, "bot '%s' is going to lastpost at %s from %s", player.PlayerName, dest, botmo.Origin);
    }
  }

  if (item) {
    dest = item.Origin;
    if (HavePathToPoint(dest, item.SubSector) || CanGetCloserTo(dest)) {
      destValid = true;
      if (bot_developer_messages_roam || bot_developer_messages_items) printmsg(PMSG.BotDevRoam, "bot '%s' is going to item at %s from %s", player.PlayerName, dest, botmo.Origin);
      //if (botmo.DistTo2(item) <= botmo.Radius*2) noRun = true;
    }
  }

  if (node) {
    dest = node.Origin;
    if (HavePathToPoint(dest, node.SubSector) || CanGetCloserTo(dest)) {
      destValid = true;
      if (bot_developer_messages_roam) printmsg(PMSG.BotDevRoam, "bot '%s' is going to node at %s from %s", player.PlayerName, dest, botmo.Origin);
    }
  }

  if (posdest_valid) {
    dest = posdest;
    if (HavePathToPoint(dest) || CanGetCloserTo(dest)) {
      destValid = true;
      if (bot_developer_messages_roam) printmsg(PMSG.BotDevRoam, "bot '%s' is going to posdest at %s from %s (dist=%s)", player.PlayerName, dest, botmo.Origin, (dest-botmo.Origin).length2D);
    }
  }

  if (destValid && HavePathToPoint(dest)) {
    UseCurrentPath();
    SetAngle(AngleTo(dest));
  }

  if (FollowPath()) return;

  if (!destValid) {
    // no target, so just run around until we find something
    RoamRandom(dest);
    return;
  }

  CheckTo(dest, out pi); // to setup flags
  // unconditionally, just for fun
  PerformLastCheckActions(pi);

  // bots are very bad at navigation, and even worser when running, so help 'em a little
  float distDest = (dest-botmo.Origin).length2DSquared;
  if (distDest <= 64*64) {
    forwardmove = FORWARDWALK/2.0;
  } else if (distDest <= 128*128) {
    forwardmove = FORWARDWALK;
  } else {
    forwardmove = FORWARDRUN;
  }

  // forget after some time
  if (posdestLast == dest && posdest_set_time > 0) {
    if (currTime-posdest_set_time > 5) {
      if (bot_developer_messages_roam) printmsg(PMSG.BotDevRoam, "bot '%s': cannot reach destination, timeout is %s", player.PlayerName, currTime-posdest_set_time);
      lastpos_valid = false;
      posdest_valid = false;
      posdest_set_time = 0;
    } else {
      //posdest_set_time = currTime;
    }
  } else {
    posdestLast = dest;
    posdest_set_time = currTime;
  }

  //forwardmove = (noRun ? FORWARDWALK : FORWARDRUN);
  SetAngle(AngleTo(dest));
}


//==========================================================================
//
//  CheckWantCurrentItem
//
//==========================================================================
bool CheckWantCurrentItem () {
  if (!item) return false;
  if (!item.bSpecial || item.bInvisible || item.IsDestroyed) { item = none; return false; } // picked up by someone
  if (bItemIsPowerup) return true; // always collect powerups
  if (!bItemIsWeapon) return false; // don't bother with non-weapons
  Weapon wpn = Weapon(item);
  if (!wpn) return false;
  if (!player.ReadyWeapon || !CanAttackWithCurrentWeapon()) return true; // want any weapon
  if (boptCheckWimpyWeapon) {
    if (wpn.bWimpyWeapon || wpn.bBotMelee) return false;
  }
  Weapon currWpn = Weapon(player.ReadyWeapon);
  if (!currWpn) return true; // just in case
  if (boptCheckWimpyWeapon) {
    if (currWpn.bWimpyWeapon) return true; // replace wimpy weapon
    if (currWpn.bBotMelee) return true; // replace melee weapon
  }
  // assume that higher slot means "better weapon" (this is not always true, but...)
  if (wpn.SelectionOrder && currWpn.SelectionOrder) return (wpn.SelectionOrder < currWpn.SelectionOrder);
  if (wpn.SlotNumber > 0 && currWpn.SlotNumber > 0 && wpn.SlotNumber > currWpn.SlotNumber) return true;
  return true; //(wpn.SelectionOrder < currWpn.SelectionOrder);
}


//==========================================================================
//
//  Move
//
//  main bot movement function.
//  dodging/attacking movement is also handled here
//
//==========================================================================
void Move (float deltaTime) {
  // worry about missiles above all else
  if (missile) {
    if (t_strafe) {
      t_strafe = fmax(0, t_strafe-deltaTime);
      if (!t_strafe) {
        // don't change direction while dodging missiles (that could be bad)
        //bot->sidemove = -bot->sidemove;
        t_strafe = 2.0;
      }
    }

    // look at the missle and sidestep it
    SetAngle(AngleTo(missile.Origin));
    forwardmove = -FORWARDRUN;
    return;
  }

  // anticipate a shot: time to dodge!
  if (enemy && t_shootcooldown <= 0.25) {
    if (!sidemove) sidemove = SIDERUN;

    switch (info.anticip) {
      case LineSpecialGameInfo::bsk_verypoor:
        // deer caught in the headlights
        sidemove = 0.0;
        return;

      case LineSpecialGameInfo::bsk_poor:
        // always walk right
        sidemove = SIDEWALK;
        break;

      case LineSpecialGameInfo::bsk_low:
        // always run right
        sidemove = SIDERUN;
        break;

      case LineSpecialGameInfo::bsk_medium:
        // just switch directions every couple seconds
        if (t_strafe) {
          t_strafe = fmax(0, t_strafe-deltaTime);
          if (!t_strafe) {
            sidemove = -sidemove;
            t_strafe = 2.0;
          }
        }
        break;

      case LineSpecialGameInfo::bsk_high:
        // switch directions when we think our opponent will fire
        if (!t_shootcooldown) sidemove = -sidemove;
        break;

      case LineSpecialGameInfo::bsk_excellent:
        // move in a somewhat random direction when we think our opponent will fire
        if (!t_shootcooldown) {
          sidemove = (Random() < 0.5 ? SIDERUN : -SIDERUN);
          if (Random() < 0.5) forwardmove = -FORWARDWALK;
        }
        break;

      case LineSpecialGameInfo::bsk_supreme:
        // what a squirmy little fucker!
        if (!t_shootcooldown) {
          switch (P_Random()&3) {
            case 0: sidemove = SIDERUN; break;
            case 1: sidemove = SIDEWALK; break;
            case 2: sidemove = -SIDERUN; break;
            case 3: sidemove = -SIDEWALK; break;
          }
          switch (P_Random()&3) {
            case 0: forwardmove = FORWARDRUN; break;
            case 1: forwardmove = FORWARDWALK; break;
            case 2: forwardmove = -FORWARDRUN; break;
            case 3: forwardmove = -FORWARDWALK; break;
          }
        }
        break;

      default:
        Error("Unknown bot skill level: %d", info.anticip);
        return;
    }
  }

  // just in case
  if (enemy && (enemy.Health <= 0 || !enemy.bShootable || (!enemy.bMonster && !enemy.bIsPlayer))) enemy = none;

  // now handle attack movement
  if (enemy) {
    EntityEx::PathInfo pi;

    if (!sidemove) sidemove = SIDERUN;

    if (t_strafe) {
      t_strafe = fmax(0, t_strafe-deltaTime);
      if (!t_strafe) {
        sidemove = -sidemove;
        t_strafe = 2.0;
      }
    }

    float dist = botmo.DistTo(enemy);

    // remember where we saw him last in case he gets away
    lastpos = enemy.Origin;
    lastpos_valid = true;

    // check if we'd rather pick up something than fight
    if (item) {
      if (CheckWantCurrentItem()) {
        sidemove = 0;
        Roam();
        return;
      }
    }

    if (bot_developer_messages_roam) printmsg(PMSG.BotDevRoam, "bot '%s': going to enemy lastpos %C", player.PlayerName, enemy);

    float an = GetRealAngle();
    if (sidemove < 0.0) an -= 90.0; else an += 90.0;

    if (!botmo.TracePath(an, 48.0, out pi, allowJump:true)) {
      // we're blocked, so go the other way!
      sidemove = -sidemove;
    }

    if (CheckTo(enemy.Origin, out pi) && dist > player.ReadyWeapon.BotCombatDist) {
      forwardmove = FORWARDRUN;
      if (!botmo.TracePath(an, 64, out pi, allowJump:true)) {
        forwardmove = -FORWARDRUN;
      }
    } else {
      if (botmo.TracePath(an+180, 64, out pi, allowJump:true)) {
        forwardmove = -FORWARDRUN;
      } else {
        forwardmove = FORWARDRUN;
      }
    }

    SetAngle(AngleTo(lastpos));

    // unconditionally, just for fun
    PerformLastCheckActions(pi);
    return;
  }

  if (t_strafe) {
    t_strafe = fmax(0, t_strafe-deltaTime);
    if (!t_strafe) {
      sidemove = -sidemove;
      t_strafe = 2.0;
    }
  }

  // roam after an item
  Roam();
}


//==========================================================================
//
//  AttackSpecial
//
//==========================================================================
bool AttackSpecial () {
  /*
  if (player.ReadyWeapon.Class == Chaingun)
  {
    // Double tap the chaingun for extreme accuracy
    if (info.accuracy == LineSpecialGameInfo::bsk_supreme)
      if (t_fire)
        return true;
  }
  */
  return false;
}


//==========================================================================
//
//  CanAttackWithCurrentWeapon
//
//==========================================================================
bool CanAttackWithCurrentWeapon (optional bool ignorePending) {
  if (ignorePending) {
    if (player.PendingWeapon) return false; // we're going to switch weapons, cannot attack
  } else {
    if (player.PendingWeapon) {
      if (player.PendingWeapon.CheckAmmo(Weapon::FIRE_Primary, AutoSwitch:false)) return true;
    }
  }

  if (player.ReadyWeapon) {
    if (player.ReadyWeapon.CheckAmmo(Weapon::FIRE_Primary, AutoSwitch:false)) return true;
  }

  return false;
}


//==========================================================================
//
//  BuildWeaponList
//
//==========================================================================
void BuildWeaponList () {
  weaponList.reset(); // don't reallocate
  if (!botmo) return;

  auto pawn = PlayerPawn(botmo);
  if (!pawn) return;

  foreach (auto currSlot; 0..pawn.GetNumberOfSlots()) {
    foreach (auto currIndex; 0..pawn.GetSlotSize(currSlot)) {
      class!Weapon swc = pawn.GetWeaponInSlot(currSlot, currIndex);
      if (!swc) continue;
      Weapon Wpn = Weapon(botmo.FindInventory(swc));
      if (Wpn) {
        if (Wpn.SisterWeapon && Wpn.SisterWeapon.bPoweredUp) {
          bool Powered = !!botmo.FindInventory(PowerWeaponLevel2);
          if (Powered) Wpn = Wpn.SisterWeapon;
        }
        weaponList[$] = Wpn;
      }
    }
  }
}


//==========================================================================
//
//  BotSwitchWeapon
//
//==========================================================================
void BotSwitchWeapon () {
  BuildWeaponList();
  Weapon bestwpn = player.ReadyWeapon;
  if (bestwpn && !bestwpn.CheckAmmo(Weapon::FIRE_Primary, AutoSwitch:false)) bestwpn = none;
  foreach (Weapon wpn; weaponList) {
    if (!wpn.CheckAmmo(Weapon::FIRE_Primary, AutoSwitch:false)) continue;
    //if (!bestwpn) { bestwpn = wpn; continue; }
    if (wpn.bBotProjectile) {
      if (!enemy) continue;
      if (enemy.DistTo(botmo) <= SAFE_SELF_MISDIST) continue;
      if (!bestwpn || !bestwpn.bBotBfg) bestwpn = wpn;
      continue;
    }
    if (wpn.bBotBfg) {
      bestwpn = wpn;
      continue;
    }
    if (bestwpn && bestwpn.bBotMelee && !wpn.bBotMelee) {
      bestwpn = wpn;
      continue;
    }
    if (!bestwpn && (enemy || !wpn.bBotProjectile)) {
      bestwpn = wpn;
      continue;
    }
    if (bestwpn && !bestwpn.bBotBfg && wpn.SelectionOrder < bestwpn.SelectionOrder) {
      bestwpn = wpn;
    }
  }
  //printmsg(PMSG.BotDevItems, "  found weapon %C", bestwpn);
  if (bestwpn && bestwpn != player.ReadyWeapon) {
    //printmsg(PMSG.BotDevItems, "   setting weapon %C (ready is %C, pending is %C)", bestwpn, player.ReadyWeapon, player.PendingWeapon);
    player.PendingWeapon = bestwpn;
  }
}


//==========================================================================
//
//  Attack
//
//==========================================================================
transient EntityEx tempPlrMO;


void Attack (bool newTick) {
  // still reacting to something
  if (t_react) return;
  if (player.PendingWeapon) return;

  // check if we can fire current weapon, and
  // try to switch weapons if we can't
  if (!player.PendingWeapon) {
    BotSwitchWeapon();
    if (player.PendingWeapon) return;
  }

  bool resetEnemy = false;

  // don't have an enemy to fight
  if (newTick && (!enemy || enemy.Health <= 0)) {
    // check if we have some enemy in sight for one-time shot
    enemy = Actor(PlayerEx(player).Attacker);
    if (enemy && enemy.bIsPlayer && !player.Level.Game.deathmatch) enemy = none; // don't retaliate to allies
    if (!enemy || enemy.Health <= 0 || !enemy.bShootable || !enemy.bMonster) {
      enemy = FindEnemy();
      if (!enemy) return;
      if (bot_developer_messages_attack) printmsg(PMSG.BotDevAttack, "bot '%s' want to place one-time shot to '%C'", player.PlayerName, enemy);
      resetEnemy = true;
    } else {
      if (bot_developer_messages_attack) printmsg(PMSG.BotDevAttack, "bot '%s' want to retaliate to '%C'", player.PlayerName, enemy);
    }
    return;
  }
  if (!enemy) return;

  // never attack other players in coop
  if (enemy.bIsPlayer && !player.Level.Game.deathmatch) {
    // reset enemy
    if (bot_developer_messages_attack) printmsg(PMSG.BotDevAttack, "bot '%s': oops, coop enemy is another player!", player.PlayerName);
    enemy = none;
    return;
  }

  scope(exit) if (resetEnemy) enemy = none;

  if (!CanAttackWithCurrentWeapon(ignorePending:true)) return;

  // it we better pickup an item, don't attack
  if (!resetEnemy && CheckWantCurrentItem()) return;

  //if (player.ReadyWeapon) printmsg(PMSG.BotDevAttack, "CANATTACK with %C: %B", player.ReadyWeapon, player.ReadyWeapon.CheckAmmo(Weapon::FIRE_Primary, AutoSwitch:false));

  // no point in firing if we won't hit them
  bool doFire = Check_LOS(enemy, SHOOTFOV);

  // check if we'll shoot any ally
  if (doFire && !player.Level.Game.deathmatch) {
    // check all other players
    TVec dir;
    AngleVector(botmo.Angles, out dir);
    foreach (auto i; 0..MAXPLAYERS) {
      auto plr = player.Level.Game.Players[i];
      if (!plr) continue;
      if (plr.bSpawned && plr.MO.Health > 0 && botmo != plr.MO) {
        tempPlrMO = EntityEx(plr.MO);
        if (botmo.CheckLineAttackWithCB(dir, 1024, delegate bool (EntityEx th) { return (th == tempPlrMO); })) {
          if (bot_developer_messages_attack) printmsg(PMSG.BotDevAttack, "bot '%s' ceased fire due to '%s'", player.PlayerName, plr.PlayerName);
          doFire = false;
          break;
        }
      }
    }
  }

  {
    //FIXME: use `CalculateLineAttackZOfs()` here
    TVec eorig = enemy.Origin;
    eorig.z += enemy.Height*0.95-enemy.FloorClip;

    //FIXME: use `CalculateLineAttackZOfs()` here
    TVec org = botmo.Origin;
    org.z += botmo.Height*0.5-botmo.FloorClip+player.GetAttackZOfs;

    TVec hp, norm;
    // `BSPTraceLine()` returns `false` on hit
    if (!doFire || !botmo.XLevel.BSPTraceLine(org, eorig, out hp, out norm, noBlockFlags:SPF_NOBLOCKING|SPF_PLAYER|SPF_HITINFO)) {
      // try sidemove
      EntityEx::PathInfo piLeft;
      if (botmo.TracePath(GetAngle()-90, SIDEWALK, out piLeft, allowJump:true)) {
        sidemove = -SIDEWALK;
        t_react = 0.3;
        return;
      }
      EntityEx::PathInfo piRight;
      if (botmo.TracePath(GetAngle()+90, SIDEWALK, out piRight, allowJump:true)) {
        sidemove = SIDEWALK;
        t_react = 0.3;
        return;
      }
      sidemove = (piLeft.maxdist > piRight.maxdist ? -SIDERUN : SIDERUN);
      forwardmove = -FORWARDWALK;
      t_react = 0.3;
      return;
    }
  }

  if (!doFire) return;

  // set dodge time
  t_shootcooldown = 0.3+0.5*FRandomFull();

  // set pitch here, so headshot checks will work as expected
  //FIXME: allies-in-water situation should be moved to separate function
  Pitch();

  if (AttackSpecial()) return;

  if (!t_fire) {
    if (bot_developer_messages_attack) printmsg(PMSG.BotDevAttack, "bot '%s': attacking %s", player.PlayerName, enemy.Class);
    player.Buttons |= BT_ATTACK;
    //HACK: for plasmagun, do not release attack button
    if (player.ReadyWeapon && player.ReadyWeapon.bBotFastShoot) {
      t_fire = 0;
    } else {
      t_fire = 1.0/35.0*2.5;
    }
  }
}


//==========================================================================
//
//  Turn
//
//  [BC] Ahh, the new and improved turning...
//
//==========================================================================
void Turn () {
  /*
  float distance = GetAngle()-botmo.Angles.yaw;
       if (distance > 180.0) distance -= 360.0;
  else if (distance < -180.0) distance += 360.0;
  */
  float distance = AngleDiff(GetRealAngle(), GetAngle());

  // [BC] Don't act crazy while trying to aim
  switch (info.accuracy) {
    case LineSpecialGameInfo::bsk_verypoor:
    case LineSpecialGameInfo::bsk_poor:
    case LineSpecialGameInfo::bsk_low:
      distance = fclamp(distance, -7.5, 7.5);
      break;
    case LineSpecialGameInfo::bsk_medium:
      distance = fclamp(distance, -15, 15);
      break;
    case LineSpecialGameInfo::bsk_high:
      distance = fclamp(distance, -22.5, 22.5);
      break;
    case LineSpecialGameInfo::bsk_excellent:
      distance = fclamp(distance, -30, 30);
      break;
    case LineSpecialGameInfo::bsk_supreme:
      distance = fclamp(distance, -37.5, 37.5);
      break;
  }

  ForceAngle(GetRealAngle()+distance);
}


//==========================================================================
//
//  Pitch
//
//==========================================================================
void Pitch () {
  bool doHeadshots = bot_always_headshots;
  float hsdist = 512; // average

  if (!player.ReadyWeapon || player.ReadyWeapon.bBotProjectile || !GetCvarB('k8HSEnabled')) {
    doHeadshots = false;
  } else {
    if (!doHeadshots) {
      switch (info.intelect) {
        case LineSpecialGameInfo::bsk_verypoor:
          if (FRandomFull() < 0.2) { doHeadshots = true; hsdist = 256; }
          break;
        case LineSpecialGameInfo::bsk_poor:
          if (FRandomFull() < 0.3) { doHeadshots = true; hsdist = 256; }
          break;
        case LineSpecialGameInfo::bsk_low:
          if (FRandomFull() < 0.4) { doHeadshots = true; hsdist = (P_Random()&1 ? 384 : 256); }
          break;
        case LineSpecialGameInfo::bsk_medium:
          if (FRandomFull() < 0.5) { doHeadshots = true; hsdist = (P_Random()&1 ? 384 : 256); }
          break;
        case LineSpecialGameInfo::bsk_high:
          if (FRandomFull() < 0.6) { doHeadshots = true; hsdist = (P_Random()&1 ? 512 : 384); }
          break;
        case LineSpecialGameInfo::bsk_excellent:
          if (FRandomFull() < 0.8) { doHeadshots = true; hsdist = (P_Random()&1 ? 512 : 384); }
          break;
        case LineSpecialGameInfo::bsk_supreme:
          if (FRandomFull() < 0.9) { doHeadshots = true; hsdist = (P_Random()&1 ? 512 : 384); }
          break;
      }
    }
  }

  if (enemy) {
    if (doHeadshots && botmo.DistTo2(enemy) <= hsdist) {
      if (bot_developer_messages_attack) printmsg(PMSG.BotDevAttack, "bot '%s': HEADSHOTTING %C", player.PlayerName, enemy);
    } else {
      if (bot_developer_messages_attack) printmsg(PMSG.BotDevAttack, "bot '%s': shooting at %C", player.PlayerName, enemy);
      doHeadshots = false;
    }
  } else {
    doHeadshots = false;
  }

  botmo.Angles.pitch = 0.0;

  // new code
  // [FB] Set pitch for underwater areas
  if (player.MO.WaterLevel > 2) {
    if (enemy) {
      botmo.Angles.pitch = PitchToEntity(enemy, doHeadshots);
    } else {
      // [FB] Follow our buddy if we're tagging along
      if (ally || (ally && !enemy)) {
        botmo.Angles.pitch = PitchToEntity(ally);
      }
    }
  } else {
    if (enemy) {
      botmo.Angles.pitch = PitchToEntity(enemy, doHeadshots);
      //print("bot: enemy at %s, bot at %s, pitch is %s (%s) (%s)", eorig, org, botmo.Angles.pitch, player.ViewAngles.pitch, enemy.Class);
      //print("     real: enemy at %s, bot at %s (eheight=%s, bheight=%s, efclip=%s, bfclip=%s, zofs=%s)", enemy.Origin, botmo.Origin, enemy.Height, botmo.Height, enemy.FloorClip, botmo.FloorClip, player.GetAttackZOfs);
    }
  }

  //k8: if we won't do this, it won't work right
  player.ViewAngles.pitch = botmo.Angles.pitch;
}


//==========================================================================
//
//  Killed
//
//==========================================================================
void Killed (EntityEx victim) {
  // [BC] Let some anger out
  angerlevel -= 5;
  enemy = none;

  // [BC] Don't need to worry about following him anymore
  lastpos_valid = false;
}


//==========================================================================
//
//  Died
//
//==========================================================================
void Died (EntityEx killer) {
  lastThinkTic = 0;
}


//==========================================================================
//
//  BotTick
//
//  Main bot function
//
//==========================================================================
void BotTick (float deltaTime) {
  UpdateCvarCache();

  botmo = Actor(player.MO);
  int currTic = botmo.XLevel.TicTime;

  if (botmo.Health <= 0) player.Health = 0; // wtf? sometimes this is it
  //print("%s health is %s (%s)", player.PlayerName, player.Health, botmo.Health);

  bool doReplan = (lastThinkTic != currTic);

  if (player.Health <= 0 || doReplan) {
    player.ForwardMove = 0.0;
    player.SideMove = 0.0;
    player.FlyMove = 0.0;

  }
  player.Buttons = 0;

  sidemove = 0;
  forwardmove = 0;

  // we're dead, so hit space to respawn
  if (player.Health <= 0) {
    lastThinkTic = 0;
    player.Buttons |= BT_USE;
    return;
  }

  if (bot_disable_ai) return;

  lastThinkTic = currTic;

  int ssnum = botmo.SubSector-&botmo.XLevel.Subsectors[0];
  if (ssnum != lastSubsector) {
    lastSubsector = ssnum;
    lastSSChangeTime = botmo.XLevel.Time;
    CheckAndDropNode();
  }

#ifdef BOT_PATHER_OLD
  pather.Reset(); // oops
#else
  if (doReplan) pather.IncQueryCounter();
#endif

  if (doReplan) {
    // weed out any bad destinations/enemies
    CheckStuff();
    // destination setting
    SetEnemy();
    Scan();
  }

  // turning towards destination
  BotAim();

  Turn();

  // moving towards destination
  Attack(doReplan);

  if (doReplan) {
    Move(deltaTime);
  } else {
    if (FollowPath()) doReplan = true; // force movement
  }

  if (doReplan) {
    // only walk if we're on skill 0
    /*
    if (!MainGameInfo(player.Level.Game).botskill || bot_no_run) {
      if (forwardmove == FORWARDRUN) forwardmove = FORWARDWALK;
      if (forwardmove == -FORWARDRUN) forwardmove = -FORWARDWALK;
      if (sidemove == SIDERUN) sidemove = SIDEWALK;
      if (sidemove == -SIDERUN) sidemove = -SIDEWALK;
    }
    */

    player.SideMove = sidemove;
    player.ForwardMove = forwardmove;
  } else {
    if (sidemove) player.SideMove = sidemove;
    if (forwardmove) player.ForwardMove = forwardmove;
  }

  t_react = fmax(0, t_react-deltaTime);
  t_shootcooldown = fmax(0, t_shootcooldown-deltaTime);
  t_fire = fmax(0, t_fire-deltaTime);
}


//==========================================================================
//
//  OnBeginPlay
//
//==========================================================================
void OnBeginPlay () {
  UpdateCvarCache();

  // create pather
  if (!pather) {
    pather = SpawnObject(BotPathGraph);
    pather.UpdateCvarCache();
#ifdef BOT_PATHER_OLD
    pather.Setup(self);
#endif
  }

  if (pather) pather.UpdateCvarCache();

  int botskill = 4;
  int bottype = 0;
  LineSpecialGameInfo::botinfo_t *binfo;

  bool randomBot = true;

  if (player.PlayerName) {
    foreach (auto i; 0../*MainGameInfo::NUMTOTALBOTS*/MainGameInfo(player.Level.Game).botinfo.length) {
      if (stricmp(MainGameInfo(player.Level.Game).botinfo[i].Name, player.PlayerName) == 0) {
        bottype = i;
        randomBot = false;
        break;
      }
    }
  }

  if (randomBot) {
    // if the user doesn't input a name, don't
    // spawn one of the "special" bots, only one of the
    // normal ones.
    bottype = P_Random()%/*MainGameInfo::*/MainGameInfo(player.Level.Game).NUMBOTTYPES;
  }

  //print("bottype=%s; name='%s'", bottype, player.PlayerName);

  binfo = &MainGameInfo(player.Level.Game).botinfo[bottype];

  t_strafe = 1.0;

  if (botskill > 4) botskill = 4;
  if (botskill < 0) botskill = 0;

  // implement skill settings
  info.accuracy = SkillLower(binfo->accuracy, 4-botskill);
  info.intelect = SkillLower(binfo->intelect, 4-botskill);
  info.evade = SkillLower(binfo->evade, 4-botskill);
  info.anticip = SkillLower(binfo->anticip, 4-botskill);
  info.reaction = SkillLower(binfo->reaction, 4-botskill);
  player.UserInfo = binfo->userinfo;

  if (randomBot && default.BotNames.length) {
    //print("OLD USERINFO: '%s'", player.UserInfo);
    // use random bot name
    string botName;
    foreach (; 0..100) {
      botName = default.BotNames[roundi(FRandomFull()*default.BotNames.length)%default.BotNames.length];
      bool found = false;
      foreach (auto pidx; 0..MAXPLAYERS) {
        auto plr = player.Level.Game.Players[pidx];
        if (!plr) continue;
        if (stricmp(plr.PlayerName, botName) == 0) { found = true; break; }
      }
      if (!found) break;
    }
    if (player.UserInfo.strStartsWith("\\Name")) {
      auto idx = player.UserInfo.strIndexOf("\\", 1);
      idx = player.UserInfo.strIndexOf("\\", idx+1);
      if (idx > 0) {
        player.UserInfo = "\\Name\\"~botName~player.UserInfo[idx..$];
      } else {
        player.UserInfo ~= "\\Name\\"~botName;
      }
    } else {
      player.UserInfo ~= "\\Name\\"~botName;
    }
    //print("NEW USERINFO: '%s'", player.UserInfo);
  }

  /*
  if (!player.Level.Game.deathmatch) {
    info.accuracy = LineSpecialGameInfo::bsk_high;
    info.intelect = LineSpecialGameInfo::bsk_high;
    info.evade = LineSpecialGameInfo::bsk_high;
    info.anticip = LineSpecialGameInfo::bsk_high;
    info.reaction = LineSpecialGameInfo::bsk_high;
  }
  */
}


//==========================================================================
//
//  OnMapChanged
//
//==========================================================================
void OnMapChanged () {
  lastMapHash = player.MO.XLevel.MapHash;
  lastSubsector = -1;
  lastUsedLines.reset();
  lastUsedThings.reset();
#ifdef BOT_PATHER_OLD
  foreach (ref BotPathNode node; ssnodes) delete node;
  ssnodes.length = player.MO.XLevel.Subsectors.length; // clear it
  foreach (ref BotPathNode node; ssnodes) node = none;
#else
  pather.Setup(self);
  printmsg(PMSG.BotDev, "bot '%s' created %s path nodes", player.PlayerName, pather.nodes.length);
#endif
}


//==========================================================================
//
//  OnSpawn
//
//==========================================================================
void OnSpawn () {
  UpdateCvarCache();

#ifdef BOT_PATHER_OLD
  if (ssnodes.length != player.MO.XLevel.Subsectors.length || lastMapHash != player.MO.XLevel.MapHash) {
    OnMapChanged();
  }
#else
  if (pather.nodes.length != player.MO.XLevel.Subsectors.length || lastMapHash != player.MO.XLevel.MapHash) {
    OnMapChanged();
  }
#endif

  ITarget = none;
  //Actor item = none;
  itemFirstSeenTime = 0;
  bItemIsWeapon = false;
  bItemIsPowerup = false;
  goal = none;
  node = none;
  prev = none;
  posdest_valid = false;
  posdest_set_time = 0;
  enemy = none;
  lastpos_valid = false;
  missile = none;

  ally = none;
  itemIgnoreTimeout.reset();
  ResetCurrPath();

  lastThinkTic = 0;

  // forgot who killed us (sometimes)
  if (FRandomFull() < 0.7) player.Attacker = none;

  //EntityEx(player.MO).TraceIsDangerousSectorCB = &IsDangerous;
}


defaultproperties {
#include "botnames.vc"
}
