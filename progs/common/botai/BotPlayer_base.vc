//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//
//  This section contains the main bot AI. The
//  main bot AI loop, B_Think, is called every tic.
//  Also included are various bot decision-making
//  procedures, such as B_CheckStuff and B_SetEnemy.
//
//**************************************************************************
class BotPathNode : EntityEx;

struct Transition : PathInfo {
  int subnum;
}

int ssnum;

// reachable subsectors (should be at least one, zero means "don't know yet")
array!Transition ssreachable;

// used in pathfinder
int validCount;
int cameFrom;
int unreachablePartners;
//int goToNext;


final bool CanReachSS (subsector_t *ss) {
  if (!ss) return false;
  int dsnum = ss-&XLevel.Subsectors[0];
  if (dsnum == ssnum) return true;
  foreach (const ref auto tr; ssreachable) if (tr.subnum == dsnum) return true;
  return false;
}


final bool CanReachSSByIndex (int dsnum) {
  if (dsnum < 0 || dsnum >= XLevel.Subsectors.length) return false;
  if (dsnum == ssnum) return true;
  foreach (const ref auto tr; ssreachable) if (tr.subnum == dsnum) return true;
  return false;
}


final Transition *FindSSTranstion (subsector_t *ss) {
  if (!ss) return nullptr;
  int dsnum = ss-&XLevel.Subsectors[0];
  if (dsnum == ssnum) return nullptr;
  foreach (const ref auto tr; ssreachable) if (tr.subnum == dsnum) return &tr;
  return nullptr;
}


defaultproperties {
  bSolid = false;
  bNoSector = true; // don't use the sector links (invisible but touchable)
  bNoBlockmap = true; // don't use the BlockLinks (inert but displayable)
  bNoGravity = true;
  bColideWithThings = false;
  bColideWithWorld = false;
  bCheckLineBlocking = false;
  bCheckLineBlockMonsters = false;
  bInvisible = true; // don't draw this actor

  bSpecial = false;
  bShootable = false;
  bPickUp = false;
  bCountItem = false;
  bNoInteraction = true;
}


// ////////////////////////////////////////////////////////////////////////// //
// Main bot class
class BotPlayerBase : GameObject;

// random bot names
array!string BotNames;


#define BOT_ALLOW_JUMPS

const float FORWARDWALK = 200.0;
const float FORWARDRUN  = 400.0;
const float SIDEWALK    = 192.0;
const float SIDERUN     = 320.0;

/*const float MAX_TRAVERSE_DIST     (1024*FRACUNIT) //10 meters, used within b_func.c*/
const float MAX_TRAVERSE_DIST = 307.2; // 3 meters, used within b_func.c -> 1 meter = 102.4 units
const float AVOID_DIST        = 512.0; // try to avoid incoming missiles once they reached this close
const float SAFE_SELF_MISDIST = 128.0; // distance from self to target where it's safe to pull a rocket
/*const float FRIEND_DIST         (128*FRACUNIT)  //To friend.
const float DARK_DIST         (256*FRACUNIT)  //Distance that bot can see enemies in the dark from.
const float WHATS_DARK          64        //light value thats classed as dark.
const float MAX_MONSTER_TARGET_DIST   (1024*FRACUNIT) //Too high can slow down the performance, see P_mobj.c*/
const float ENEMY_SCAN_FOV = 120.0;
/*const float MAXMOVEHEIGHT       (32*FRACUNIT) //MAXSTEPMOVE but with jumping counted in.
const float GETINCOMBAT         (512*FRACUNIT)  //Max distance to item. if it's due to be icked up in a combat situation.*/
const float SHOOTFOV = 60.0;
/*const float MAXROAM           (5*TICRATE)   //When this time is elapsed the bot will roam after something else.*/
const float MONSTER_SCAN_RADIUS = 1024.0;
const float ITEM_SCAN_RADIUS = 1024.0;

const float ITEM_GIVEUP_TIME = 1.5; // if bot cannot get item for this time, ignore it
const float ITEM_IGNORE_TIME = 10.0; // time bot should ignore item
const float ITEM_IGNORE_TIME_DEVIATION = 3.0; // random deviation for ignore time


/*
  Class definitions for botinfo, chatinfo, and
  other various bot information thingamabobers.
*/

enum {
  bsk_verypoor,
  bsk_poor,
  bsk_low,
  bsk_medium,
  bsk_high,
  bsk_excellent,
  bsk_supreme
};

struct botinfo_t {
  string Name;    // bot's name
  int accuracy;   // accuracy with "instant" weapons (this includes "leading")
  int intelect;   // accuracy with "missile" weapons (rocket launcher, etc.)
  int evade;      // ability to dodge incoming missiles
  int anticip;    // ability to anticipate "instant" shots
  int reaction;   // overall reaction time (lower is "better")
/*
  int pisschance;   // chance the bot will get pissed when his threshold is reached
  int threshold;    // how much it takes to frustrate/piss off the bot
  int dangerlevel;  // when health is below this, we need some health
  int wpfav;      // favorite weapon
  int chatinfo;   // bot's chat strings
  int chattime;   // how long it takes us to type a line
  int chatty;     // how talkative the bot is
  char *colour;   // colour (in form of a string)
  char *gender;   // male/female/it :)
  char *skin;     // skin
  int railcolour;   // railgun trail colour
  bool revealed;    // hidden bots must be revealed
*/
  string userinfo;
};

/*
struct chatline_t {
  char *string;
  chattype_t bot;
  chatline_t *line;
};

struct chatinfo_t {
  chatline_t intro[5];
  chatline_t inter[5];
  chatline_t rare[5];
  chatline_t frag[15];
  chatline_t died[10];
  chatline_t roam[10];
  chatline_t pissed[5];
  chatline_t frustrated[5];
  chatline_t special[20];
} chatinfo_t;
*/

// The things the bot knows about their enemy
/*
struct enemyinfo_t {
  int health;
  weapontype_t weap;
};
*/

//
// Bot states
//
enum {
  BST_NOTHING, // deciding what to do
  BST_OFFENSE, // bot is "fetching" something (skull, whatever)
  BST_DEFENSE, // bot is defending something
  BST_RETURN, // bot is heading to scoring place
};


Player player; // points to reference player
Actor botmo;
Actor ITarget;  // immediate target (where to go) (k8: currently unused)

// destinations
Actor item; // item (roam towards weapon, etc)
float itemFirstSeenTime; // so bot can give up if it cannot reach item for some time
bool bItemIsWeapon;
bool bItemIsPowerup;
Actor goal; // teamgame goal spot
Actor node; // node we're heading towards
Actor prev; // previous node we were at
TVec posdest; // position of our destination (doesn't have to be an actor)
bool posdest_valid;
TVec posdestLast; // used to invalidate `posdest_set_time`
float posdest_set_time;
Actor enemy; // the dead meat
TVec lastpos; // last place we saw our enemy
bool lastpos_valid;
Actor missile; // a threathing missile that got to be avoided

Actor ally; // ally to tag along with
float t_strafe;
float t_react;
float t_fire; // seconds left until our gun will actually fire again
float t_shootcooldown;

float forwardmove; // for building ucmd
float sidemove;

// misc booleans
bool bAllRound;
bool bNewItemIsWeapon;
bool bNewItemIsPowerup;

botinfo_t info; // aiming, name, perfection, yadda yadda

int angerlevel;

float angle; // the wanted angle that the bot tries to get every tic

int lastThinkTic;

// bot options
array!Weapon weaponList;

// bot will ignore item if it cannot obtain it for some time
dictionary!(Actor, float) itemIgnoreTimeout;

// nodes for subsectors
array!BotPathNode ssnodes;

// current path, numbered by subsectors
array!int currPath;
int validCount;
// to avoid blocks, reset node link if we cannot move for some time
int lastCurrFollowSS;
TVec lastCurrFollowPos;
float lastCurrFollowTime;
float lastSSChangeTime; // so we can replan our route if it takes too long

bool dbgDumpPathSearch;

string lastMapHash;


//==========================================================================
//
//  ResetCurrPath
//
//==========================================================================
final void ResetCurrPath () {
  currPath.reset();
  lastCurrFollowSS = -1;
  lastCurrFollowTime = 0;
  lastSSChangeTime = 0;
}


//==========================================================================
//
//  DumpNodes
//
//==========================================================================
final void DumpNodes () {
  EntityEx mo = EntityEx(player.MO);
  if (!mo) return;
  print("=== NODES FOR '%s' ===", player.PlayerName);
  foreach (int nidx, BotPathNode node; ssnodes) {
    if (!node) continue;
    print(" node #%s (%s) has #%d transitions", nidx, node.ssnum, node.ssreachable.length);
    foreach (int tridx, const ref auto tr; node.ssreachable) {
      print("  transition #%d: dest=%s; angle=%s; maxdist=%s; jump=%B; use=%B; success=%B", tridx, tr.subnum, tr.angle, tr.maxdist, tr.needJump, tr.needUse, tr.success);
    }
  }
}


//==========================================================================
//
//  TestFindPathTo
//
//==========================================================================
final void TestFindPathTo (TVec dest) {
  EntityEx mo = EntityEx(player.MO);
  if (!mo) return;
  botmo = Actor(mo);
  if (!botmo) return;
  subsector_t *ss = botmo.XLevel.PointInSubsector(dest);
  if (!ss) return;
  dbgDumpPathSearch = true;
  if (!HavePathToSS(ss)) {
    print("bot '%s' cannot find path from #%s to #%s", player.PlayerName, botmo.SubSector-&botmo.XLevel.Subsectors[0], ss-&botmo.XLevel.Subsectors[0]);
  } else {
    print("bot '%s' found path from #%s to #%s", player.PlayerName, botmo.SubSector-&botmo.XLevel.Subsectors[0], ss-&botmo.XLevel.Subsectors[0]);
    foreach (int sidx; currPath) print("  ss: #%d", sidx);
  }
  dbgDumpPathSearch = false;
}


//==========================================================================
//
//  PutItemToIgnoreList
//
//  put item into ignore list
//
//==========================================================================
final void PutItemToIgnoreList (Actor item, optional float timeoutMult) {
  if (!item || !item.IsDestroyed()) return;
  if (!specified_timeoutMult) timeoutMult = 1;
  float currTime = botmo.XLevel.Time;
  float timeout = ITEM_IGNORE_TIME+(FRandomFull()-0.5)*(ITEM_IGNORE_TIME_DEVIATION*2);
  timeout *= timeoutMult;
  timeout += currTime;
  if (GetCvarB('bot_developer_messages_items')) print("bot '%s' gives up on %C for %s", player.PlayerName, item.Class, timeout-currTime);
  itemIgnoreTimeout.put(item, timeout);
}


//==========================================================================
//
//  CheckAndDropNodeFromTo
//
//==========================================================================
final void CheckAndDropNodeAt (subsector_t *ss, optional bool atBotOrigin) {
  if (!ss) return;
  botmo = Actor(player.MO);
  if (!botmo) return;
  if (botmo.Health < 1 || botmo.Height < 8) return;

  bool oldNode = false;

  int ssnum = ss-&botmo.XLevel.Subsectors[0];
  if (ssnodes[ssnum]) {
    if (!ssnodes[ssnum].unreachablePartners) return;
    oldNode = true;
  }
  if (GetCvarB('bot_developer_messages_path')) print("want to drop a new node in subsector #%d", ssnum);

  // get subsector center
  TVec cpos = vector(0, 0, 0);
  int ccount = 0;
  foreach (auto lidx; ss.firstline..ss.firstline+ss.numlines) {
    cpos += *botmo.XLevel.Segs[lidx].v1;
    ++ccount;
  }
  if (!ccount) return; // oops
  cpos = cpos/float(ccount);
  cpos.z = EntityEx::ONFLOORZ;

  Entity::tmtrace_t tmtrace;
  if (botmo.CheckRelPosition(&tmtrace, cpos, noPickups:true)) {
    cpos = tmtrace.End;
  } else {
    if (GetCvarB('bot_developer_messages_path')) print("oops; cannot spawn node at subsector #%d center...", ssnum);
    if (!atBotOrigin) return;
    cpos = botmo.Origin;
  }

  BotPathNode node = (oldNode ? ssnodes[ssnum] : BotPathNode(botmo.Spawn(BotPathNode, cpos)));
  if (!node) return; // something is very wrong here
  node.ssnum = ssnum;

  int sscount = 0;
  int ssreach = 0;

  // check reachable subsectors
  foreach (auto lidx; ss.firstline..ss.firstline+ss.numlines) {
    seg_t *seg = &botmo.XLevel.Segs[lidx];
    if (!seg.partner || seg.partner.front_sub == seg.front_sub) continue;
    int psnum = seg.partner.front_sub-&botmo.XLevel.Subsectors[0];
    ++sscount;
    BotPathNode otherNode = ssnodes[psnum];
    if (otherNode) {
      EntityEx::PathInfo pi;
      TAVec ang;
      TVec dir = otherNode.Origin-node.Origin;
      float dist = dir.length2D;
      if (!oldNode || !node.CanReachSSByIndex(psnum)) {
        otherNode.unreachablePartners = 1; // so it will be rechecked; just in case
        VectorAngles(dir, out ang);
        if (botmo.TracePath(ang.yaw, dist, out pi, allowJump:true, srcOrigin:node.Origin)) {
          if (GetCvarB('bot_developer_messages_path')) print("subsector #%d is reachable from #%d", psnum, ssnum);
          auto tr = node.ssreachable.alloc();
          tr.subnum = psnum;
          tr.angle = pi.angle;
          tr.needdist = pi.needdist;
          tr.maxdist = pi.maxdist;
          tr.needJump = pi.needJump;
          tr.needUse = pi.needUse;
          tr.dirxy = pi.dirxy;
          tr.success = pi.success;
          ++ssreach;
        }
      } else {
        ++ssreach;
      }

      if (!oldNode || !otherNode.CanReachSSByIndex(ssnum)) {
        otherNode.unreachablePartners = 1; // so it will be rechecked
        dir = node.Origin-ssnodes[psnum].Origin;
        VectorAngles(dir, out ang);
        if (botmo.TracePath(ang.yaw, dist, allowJump:true, srcOrigin:ssnodes[psnum].Origin)) {
          if (GetCvarB('bot_developer_messages_path')) print("subsector #%d is reachable from #%d", ssnum, psnum);
          auto tr = ssnodes[psnum].ssreachable.alloc();
          tr.subnum = ssnum;
          tr.angle = pi.angle;
          tr.needdist = pi.needdist;
          tr.maxdist = pi.maxdist;
          tr.needJump = pi.needJump;
          tr.needUse = pi.needUse;
          tr.dirxy = pi.dirxy;
          tr.success = pi.success;
        }
      }
    }
  }
  node.unreachablePartners = (ssreach != sscount ? 1 : 0);

  ssnodes[ssnum] = node;
}


//==========================================================================
//
//  CheckAndDropNode
//
//==========================================================================
final void CheckAndDropNode () {
  if (!botmo.SubSector) return;
  CheckAndDropNodeAt(botmo.SubSector, atBotOrigin:true);
}


//==========================================================================
//
//  IncValidCount
//
//==========================================================================
final void IncValidCount () {
  if (++validCount == int.max) {
    validCount = 1;
    foreach (ref BotPathNode node; ssnodes) if (node) node.validCount = 0;
  }
}


private transient array!int nodesToCheck;


//==========================================================================
//
//  BuildPathTo
//
//  last path node is our starting node (it is easier this way)
//
//==========================================================================
final bool BuildPathTo (ref array!int path, subsector_t *ss) {
  path.reset();
  if (!ss) return false;
  int snum = botmo.SubSector-&botmo.XLevel.Subsectors[0];
  if (!ssnodes[snum]) return false;
  int dnum = ss-&botmo.XLevel.Subsectors[0];
  if (!ssnodes[dnum]) return false;
  // naive search; should be replaced with a-star, for example
  IncValidCount();
  nodesToCheck.reset();
  nodesToCheck[$] = snum;
  int ntcNext = 0;
  ssnodes[snum].validCount = validCount;
  ssnodes[snum].cameFrom = -1;
  if (dbgDumpPathSearch /*GetCvarB('bot_developer_messages_path')*/) print("looking for path from #%d to #%d (vc=%s)", snum, dnum, validCount);
  //ssnodes[snum].goToNext = -1;
  while (ntcNext < nodesToCheck.length) {
    BotPathNode node = ssnodes[nodesToCheck[ntcNext++]];
    if (node.ssnum == dnum) {
      // path found
      if (dbgDumpPathSearch /*GetCvarB('bot_developer_messages_path')*/) print(" GOT PATH from #%d to #%d", snum, dnum);
      /*
      int sscur = node.ssnum;
      while (sscur >= 0) {
        int psc = ssnodes[sscur].cameFrom;
        if (psc >= 0) ssnodes[psc].goToNext = sscur;
        sscur = psc;
      }
      sscur = snum;
      while (sscur != dnum) {
        node = ssnodes[sscur];
        path[$] = node.ssnum;
        sscur = node.goToNext;
      }
      */
      int sscur = node.ssnum;
      while (sscur >= 0) {
        node = ssnodes[sscur];
        if (dbgDumpPathSearch /*GetCvarB('bot_developer_messages_path')*/) print("  ss #%d (%d)", node.ssnum, sscur);
        path[$] = node.ssnum;
        sscur = node.cameFrom;
      }
      return true;
    }
    // if this node leads to some unvisited subsectors, store them as next level subsectors
    if (dbgDumpPathSearch /*GetCvarB('bot_developer_messages_path')*/) print(" node at ss #%d has #%d exits", node.ssnum, node.ssreachable.length);
    foreach (const ref auto tr; node.ssreachable) {
      BotPathNode nextNode = ssnodes[tr.subnum];
      if (nextNode.validCount != validCount) {
        if (dbgDumpPathSearch /*GetCvarB('bot_developer_messages_path')*/) print(" added transition from #%d to #%d", node.ssnum, nextNode.ssnum);
        nextNode.validCount = validCount;
        nextNode.cameFrom = node.ssnum;
        nodesToCheck[$] = nextNode.ssnum;
      } else {
        if (dbgDumpPathSearch /*GetCvarB('bot_developer_messages_path')*/) print(" skipped transition from #%d to #%d (%s : %s)", node.ssnum, nextNode.ssnum, nextNode.validCount, validCount);
      }
    }
  }
  // alas
  return false;
}


//==========================================================================
//
//  HavePathToSS
//
//  fills currPath (or destroys it)
//
//==========================================================================
final bool HavePathToSS (subsector_t *ss) {
  ResetCurrPath();
  return BuildPathTo(ref currPath, ss);
}


//==========================================================================
//
//  HavePathToPoint
//
//  fills currPath (or destroys it)
//
//==========================================================================
final bool HavePathToPoint (TVec dest) {
  subsector_t *ss = botmo.XLevel.PointInSubsector(dest);
  return HavePathToSS(ss);
}


//==========================================================================
//
//  BotTick
//
//  Main bot function
//
//==========================================================================
void BotTick (float deltaTime) {
  botmo = Actor(player.MO);
  int currTic = botmo.XLevel.TicTime;

  CheckAndDropNode();

  bool doReplan = (lastThinkTic != currTic);
  lastThinkTic = currTic;

  if (botmo.Health <= 0) player.Health = 0; // wtf? sometimes this is it
  //print("%s health is %s (%s)", player.PlayerName, player.Health, botmo.Health);

  if (player.Health <= 0 || doReplan) {
    player.ForwardMove = 0.0;
    player.SideMove = 0.0;
    player.FlyMove = 0.0;
  }
  player.Buttons = 0;

  // we're dead, so hit space to respawn
  if (player.Health <= 0) {
    player.Buttons |= BT_USE;
    return;
  }

  if (doReplan) {
    // weed out any bad destinations/enemies
    CheckStuff();

    // destination setting
    SetEnemy();
    Scan();

    // turning towards destination
    BotAim();
  }

  Turn();

  // moving towards destination
  Attack();
  if (doReplan) Move(deltaTime);

  //Pitch();

  if (doReplan) {
    // only walk if we're on skill 0
    /*
    if (!MainGameInfo(player.Level.Game).botskill || GetCvarB('bot_no_run')) {
      if (forwardmove == FORWARDRUN) forwardmove = FORWARDWALK;
      if (forwardmove == -FORWARDRUN) forwardmove = -FORWARDWALK;
      if (sidemove == SIDERUN) sidemove = SIDEWALK;
      if (sidemove == -SIDERUN) sidemove = -SIDEWALK;
    }
    */

    player.SideMove = sidemove;
    player.ForwardMove = forwardmove;
  }

  t_react = fmax(0, t_react-deltaTime);
  t_shootcooldown = fmax(0, t_shootcooldown-deltaTime);
  t_fire = fmax(0, t_fire-deltaTime);
}


//==========================================================================
//
//  AngleTo
//
//==========================================================================
final float AngleTo (TVec dest) {
  TAVec ang;
  TVec dir = dest-botmo.Origin;
  VectorAngles(dir, out ang);
  return ang.yaw;
}


//==========================================================================
//
//  PitchTo
//
//==========================================================================
final float PitchTo (TVec dest, optional bool useRealHeight) {
  TVec org = botmo.Origin;
  if (useRealHeight) org.z += botmo.Height*0.5-botmo.FloorClip+player.GetAttackZOfs;

  TAVec ang;
  TVec dir = dest-org;

  VectorAngles(dir, out ang);
  return ang.pitch;
}


//==========================================================================
//
//  PitchToEntity
//
//==========================================================================
final float PitchToEntity (EntityEx ent, optional bool useRealHeight) {
  if (!ent) return 0;
  TVec eorig = ent.Origin;
  if (useRealHeight) eorig.z += ent.Height*0.95-ent.FloorClip;

  TVec org = botmo.Origin;
  if (useRealHeight) org.z += botmo.Height*0.5-botmo.FloorClip+player.GetAttackZOfs;

  TAVec ang;
  TVec dir = eorig-org;

  VectorAngles(dir, out ang);
  return ang.pitch;
}


//==========================================================================
//
//  CheckWeaponItem
//
//  return `true` to exit from `CheckItem` with `res` result
//  otherwise `res` has no meaning
//
//==========================================================================
bool CheckWeaponItem (Weapon Wpn, out bool res) {
  if (!Wpn) return false;

  // we cannot use melee weapons anyway
  if (Wpn.bBotMelee) { res = false; return true; }

  // if we don't have the weapon, pick it up
  Weapon exwpn = Weapon(botmo.FindInventory(class!Inventory(Wpn.Class)));
  if (!exwpn) { res = true; return true; }

  if (!Wpn.CanPickupForAmmo(exwpn)) { res = false; return true; }

  // if we have no more room for the ammo it gives
  auto ammo1 = (Wpn.AmmoType1 ? botmo.FindInventory(Wpn.AmmoType1) : none);
  if (ammo1 && ammo1.Amount == ammo1.MaxAmount) { res = false; return true; }

  // can't pick it up because we have it and it's not a dropped weapon
  if (!Wpn.bDropped) { res = false; return true; }

  res = true;
  return true;
}


//==========================================================================
//
//  CheckSpecialItem
//
//  return `true` to exit from `CheckItem` with `res` result
//  otherwise `res` has no meaning
//
//==========================================================================
bool CheckSpecialItem (Actor item, out bool res) {
  return false;
}


//==========================================================================
//
//  CheckAmmoItem
//
//  return `true` to exit from `CheckItem` with `res` result
//  otherwise `res` has no meaning
//
//==========================================================================
bool CheckAmmoItem (Ammo ammo, out bool res) {
  // if we have no more room for the ammo it gives
  Inventory AmmoItem = botmo.FindInventory(ammo.GetParentAmmo());
  if (AmmoItem && AmmoItem.Amount >= AmmoItem.MaxAmount) { res = false; return true; }

  res = true;
  return true;
}


//==========================================================================
//
//  CheckOtherItem
//
//  return `true` to exit from `CheckItem` with `res` result
//  otherwise `res` has no meaning
//
//==========================================================================
bool CheckOtherItem (Actor item, out bool res) {
  if (Health(item) && botmo.Health >= Player::MAXHEALTH) { res = false; return true; }
  //if ((item.Class == Soulsphere || item.Class == Megasphere) && botmo.Health >= 2*Player::MAXHEALTH) return false;

  BasicArmor Armor = BasicArmor(botmo.FindInventory(BasicArmor));
  if (!Armor) return false;

  if (BasicArmorPickup(item) && (Armor.Amount >= BasicArmorPickup(item).SaveAmount)) { res = false; return true; }
  //if (item.Class == Megasphere && Armor.Amount >= 200) return false;

  return false;
}


//==========================================================================
//
//  CheckItem
//
//  Determines if we should bother picking up an item or not
//
//==========================================================================
bool CheckItem (Actor item) {
  bool res;

  bNewItemIsWeapon = false;
  bNewItemIsPowerup = false;

  if (!item) return false;
  if (!item.bSpecial || item.bInvisible) return false;

  Weapon Wpn = Weapon(item);
  if (Wpn) {
    bNewItemIsWeapon = true;
    if (CheckWeaponItem(Wpn, out res)) return res;
  }

  if (CheckSpecialItem(item, out res)) return res;

  Ammo ammo = Ammo(item);
  if (ammo && CheckAmmoItem(ammo, out res)) return res;

  if (CheckOtherItem(item, out res)) return res;

  // guess we're okay
  return true;
}


//==========================================================================
//
//  FindAllyToSupport
//
//==========================================================================
Actor FindAllyToSupport (bool allowESP) {
  if (player.Level.Game.deathmatch) return none;
  // search for player enemies in deathmatch
  //print("looking for player...");
  Actor target = none;
  float closest_dist = 99999.0;
  foreach (auto i; 0..MAXPLAYERS) {
    auto plr = player.Level.Game.Players[i];
    if (!plr) continue;
    if (!plr.bIsBot && plr.bSpawned && plr.MO.Health > 0 && botmo != plr.MO) {
      float temp = plr.MO.DistTo(botmo);
      if (temp > SAFE_SELF_MISDIST && temp < closest_dist) {
        if (Check_LOS(Actor(plr.MO), 360) || CheckTo(plr.MO.Origin)) {
          closest_dist = temp;
          target = Actor(plr.MO);
        }
      }
    }
  }
  if (target) {
    ResetCurrPath();
    return target;
  }

  if (allowESP) {
    // use ESP to get to player, lol
    foreach (auto i; 0..MAXPLAYERS) {
      auto plr = player.Level.Game.Players[i];
      if (!plr) continue;
      if (!plr.bIsBot && plr.bSpawned && plr.MO.Health > 0 && botmo != plr.MO) {
        if (HavePathToSS(plr.MO.SubSector)) {
          if (GetCvarB('bot_developer_messages_path')) print("*** ESP activated! src=%d, dst=%d", botmo.SubSector-&botmo.XLevel.Subsectors[0], plr.MO.SubSector-&botmo.XLevel.Subsectors[0]);
          break;
        } else {
          if (GetCvarB('bot_developer_messages_path')) print("*** CANNOT activate ESP! src=%d, dst=%d", botmo.SubSector-&botmo.XLevel.Subsectors[0], plr.MO.SubSector-&botmo.XLevel.Subsectors[0]);
        }
      }
    }
    if (currPath.length < 2) {
      ResetCurrPath();
    }
  }

  return none;
}


//==========================================================================
//
//  SetEnemy
//
//==========================================================================
void SetEnemy () {
  // never attack other players in coop
  if (enemy && enemy.bIsPlayer && !player.Level.Game.deathmatch) {
    // reset enemy
    if (GetCvarB('bot_developer_messages_attack')) print("bot '%s': oops, coop enemy is another player!", player.PlayerName);
    enemy = none;
  }

  if (enemy && enemy.Health > 0 && player.MO && player.MO.CanSee(enemy)) {
    return;
  }

  bAllRound = !!enemy;
  enemy = FindEnemy();

  if (!enemy) return;

  // double check the validity of the enemy
  if (!enemy.bShootable) enemy = none;

  // run to human player to give some support
  if (!enemy) {
    Actor target = FindAllyToSupport(allowESP:true);
    if (target && botmo.DistTo2(target) > 96) {
      SetAngle(AngleTo(target.Origin));
      player.ViewAngles.yaw = GetAngle();
      botmo.Angles.yaw = GetAngle();
      lastpos = target.Origin;
      lastpos_valid = true;
      posdest_valid = false;
      posdest_set_time = 0;
      item = none;
      if (GetCvarB('bot_developer_messages_roam')) print("bot '%s': going to support %C", player.PlayerName, target);
    }
  }
}


//==========================================================================
//
//  CheckStuff
//
//  Make sure that our destinations/enemies and everything are valid.
//
//==========================================================================
void CheckStuff () {
  if (item) {
    if (!item.bSpecial || item.bInvisible || item.IsDestroyed() /*|| // somebody picked
        !CheckTo(item.Origin)*/) // can't reach
    {
      PutItemToIgnoreList(item, 0.8);
      item = none;
      itemFirstSeenTime = 0;
    }
  }

  if (missile) {
    if (!missile.bMissile || missile.IsDestroyed()) missile = none;
  }

  if (node) {
    if (!CheckTo(node.Origin) || botmo.DistTo2(node) < botmo.Radius) {
      prev = node;
      node = none;
    }
  }

  /*
  if (posdest_valid) {
    TVec dir = posdest-botmo.Origin;
    dir.z = 0.0;
    if (Length2D(dir) < botmo.Radius || !CheckTo(posdest)) {
      posdest_valid = false;
    }
  }

  if (lastpos_valid) {
    TVec dir = lastpos-botmo.Origin;
    dir.z = 0.0;
    if (Length2D(dir) < botmo.Radius || !CheckTo(lastpos)) {
      lastpos_valid = false;
    }
  }
  */

  if (enemy) {
    if (enemy.IsDestroyed() || enemy.Health <= 0 || !enemy.bShootable) enemy = none;
  }
}


transient array!Actor otherItems;


//==========================================================================
//
//  Scan
//
//  Scan all mobj's visible to the bot for incoming missiles, enemies, and
//  various items to pick up.
//
//==========================================================================
void Scan () {
  if (currPath.length) return;

  if (!FindAllyToSupport(allowESP:false)) {
    FindAllyToSupport(allowESP:true);
    if (currPath.length) {
      item = none;
      return;
    }
  }

  float currTime = botmo.XLevel.Time;

  // check if bot tried to get current item for too long
  if (item) {
    if (currTime-itemFirstSeenTime > ITEM_GIVEUP_TIME) {
      PutItemToIgnoreList(item);
      item = none;
      itemFirstSeenTime = 0;
    }
  }

  Entity ee;
  otherItems.reset();
  foreach botmo.RadiusThings(out ee, botmo.Origin, ITEM_SCAN_RADIUS) {
    Actor actor = Actor(ee);
    if (!actor) continue;
    if (actor.bInvisible) continue;
    if (!actor.bSpecial && !actor.bMissile) {
      // not interested in this one
      continue;
    }
    if (Check_LOS(actor, 90.0)) {
      // look for special items
      if (!item && actor.bSpecial) {
        // check if we should ignore this item
        auto dip = itemIgnoreTimeout.find(actor);
        if (dip) {
          if (*dip > currTime) continue; // ignore it
          if (GetCvarB('bot_developer_messages_items')) print("bot '%s' wants %C again (%s)", player.PlayerName, actor.Class, currTime-(*dip));
          // it is ok to obtain, remove from list
          itemIgnoreTimeout.del(actor);
        }
        if (CheckItem(actor) && HavePathToSS(actor.SubSector)) {
          if (GetCvarB('bot_developer_messages_items')) print("bot '%s' wants %s", player.PlayerName, actor.Class);
          item = actor;
          bItemIsWeapon = bNewItemIsWeapon;
          bItemIsPowerup = bNewItemIsPowerup;
        } else {
          if (GetCvarB('bot_developer_messages_items')) print("bot '%s' ignores %s", player.PlayerName, actor.Class);
        }
      } else if (!missile && actor.bMissile && botmo.DistTo(actor) < AVOID_DIST) {
        missile = actor;
      }
    } else if (actor.bSpecial) {
      auto dip = itemIgnoreTimeout.find(actor);
      if (dip) {
        if (*dip > currTime) continue; // ignore it
        if (GetCvarB('bot_developer_messages_items')) print("bot '%s' wants %C again (%s)", player.PlayerName, actor.Class, currTime-(*dip));
        // it is ok to obtain, remove from list
        itemIgnoreTimeout.del(actor);
      }
      Weapon wpn = Weapon(actor);
      if (wpn) otherItems[$] = actor;
    }
  }

  if (!item && otherItems.length) {
    while (otherItems.length) {
      int idx = round(FRandomFull()*otherItems.length)%otherItems.length;
      Actor act = otherItems[idx];
      otherItems.remove(idx);
      if (CheckItem(act) && HavePathToSS(act.SubSector)) {
        print("going to unseen item %C", act);
        item = act;
        break;
      }
    }
  }
}


//==========================================================================
//
//  SkillLower
//
//==========================================================================
int SkillLower (int skill, int num) {
  if (num <= 0) return skill;
  skill = max(0, skill-num);
  return skill;
}


//==========================================================================
//
//  SetAngle
//
//==========================================================================
final void SetAngle (float an) {
  angle = AngleMod360(an);
}


//==========================================================================
//
//  GetAngle
//
//==========================================================================
final float GetAngle () {
  return angle;
}


//==========================================================================
//
//  IsDangerous
//
//  Checks if a sector is dangerous.
//
//==========================================================================
bool IsDangerous (sector_t *sec) {
  return false;
}


//==========================================================================
//
//  DistToPlane
//
//==========================================================================
final float DistToPlane (const ref TPlane plane, const ref TVec point) {
  return fabs(DotProduct(point, plane.normal));
}


//==========================================================================
//
//  PerformLastCheckActions
//
//==========================================================================
void PerformLastCheckActions (const ref EntityEx::PathInfo pi) {
#ifdef BOT_ALLOW_JUMPS
  if (pi.needJump && !GetCvarB('bot_no_jump')) player.Buttons |= BT_JUMP;
#endif
  if (pi.needUse) EntityEx(player.MO).UseLines(Player::USERANGE, Player::USETHINGRANGE, '*usefail');
}


//==========================================================================
//
//  CheckTo
//
//  Checks if an location is reachable
//
//==========================================================================
bool CheckTo (TVec pos, optional out EntityEx::PathInfo pi) {
  TVec v2 = botmo.Origin-pos;
  v2.z = 0;
  if (!v2) return true;
  float dist = Length2D(v2);
  float an = GetAngle();
  return botmo.TracePath(an, dist, pi!optional, allowJump:true);
}


//==========================================================================
//
//  CheckToEnt
//
//  Checks if an location is reachable
//
//==========================================================================
bool CheckToEnt (Entity ent, optional out EntityEx::PathInfo pi) {
  TVec v2 = botmo.Origin-ent.Origin;
  v2.z = 0;
  if (!v2) return true;
  float dist = Length2D(v2);
  float an = GetAngle();
  return botmo.TracePath(an, dist, pi!optional, distEnt:ent, allowJump:true);
}


//==========================================================================
//
//  CanGetCloserTo
//
//  Checks if we can move a little closer
//
//==========================================================================
bool CanGetCloserTo (TVec pos) {
  TVec v2 = botmo.Origin-pos;
  v2.z = 0;
  if (!v2) return true;
  float dist = Length2D(v2);
  float an = GetAngle();
  EntityEx::PathInfo pi;
  if (botmo.TracePath(an, dist, out pi, allowJump:true)) return true;
  return (pi.maxdist >= 32); // at least half of a tile
}


//==========================================================================
//
//  CanGetCloserToEnt
//
//  Checks if we can move a little closer
//
//==========================================================================
bool CanGetCloserToEnt (Entity ent) {
  TVec v2 = botmo.Origin-ent.Origin;
  v2.z = 0;
  if (!v2) return true;
  float dist = Length2D(v2);
  float an = GetAngle();
  EntityEx::PathInfo pi;
  if (botmo.TracePath(an, dist, out pi, distEnt:ent, allowJump:true)) return true;
  return (pi.maxdist >= 32); // at least half of a tile
}


//==========================================================================
//
//  Check_LOS
//
//  Doesnt check LOS, checks visibility with a set view angle.
//  B_Checksight checks LOS (straight line)
//
//  Check if mo1 has free line to mo2 and if mo2 is within mo1 viewangle
// (vangle) given with normal degrees. If these conditions are true, the
// function returns true. GOOD TO KNOW is that the players view angle in
// doom is 90 degrees infront.
//
//==========================================================================
final bool Check_LOS (Actor to, float vangle, optional bool skipCanSee) {
  if (!to) return false;
  if (vangle <= 0) return false; // looker seems to be blind
  if (vangle < 360.0) {
    // check FOV
    if (fabs(AngleMod180(AngleTo(to.Origin)-botmo.Angles.yaw)) > vangle/2.0) return false;
  }
  if (!skipCanSee && !botmo.CanSee(to)) return false; // out of sight
  return true;
}


//==========================================================================
//
//  GoodAngle
//
//==========================================================================
final bool GoodAngle (Actor to, float vangle) {
  if (!to) return true;
  if (vangle <= 0) return false; // looker seems to be blind
  if (vangle >= 360.0) return true;
  // check FOV
  return (fabs(AngleMod180(AngleTo(to.Origin)-botmo.Angles.yaw)) <= vangle/2.0);
}


//==========================================================================
//
//  BotAimProjectile
//
//==========================================================================
void BotAimProjectile (float dist, bool right, float an) {
  if (!enemy) return; // just in case

  // splash weapons
  //bot->SetAngle(R_PointToAngle2(MO->x, MO->y, enemy->x, enemy->y));

  // [BC] cajun prediction
  // here goes the prediction.
  float m = dist/875.0; //FIXME: determine current weapon's missile speed
  float px = enemy.Origin.x+(enemy.Velocity.x*m*2.0);
  float py = enemy.Origin.y+(enemy.Velocity.y*m*2.0);

  // projectile weapons
  switch (info.intelect) {
    case bsk_verypoor:
    case bsk_poor:
      if (MainGameInfo(player.Level.Game).botskill > 3 && Random() < 0.01) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      } else {
        // aim right at the enemy
        SetAngle(an);
      }
      break;
    case bsk_low:
      if (MainGameInfo(player.Level.Game).botskill > 2 && Random() < 0.03) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      } else {
        // aim right at the enemy
        SetAngle(an);
      }
      break;
    case bsk_medium:
      if (MainGameInfo(player.Level.Game).botskill > 2 && Random() < 0.09) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      } else {
        if (right) SetAngle(an+Random()*20.0); else SetAngle(an-Random()*20.0);
      }
      break;
    case bsk_high:
      if (MainGameInfo(player.Level.Game).botskill > 1 && Random() < 0.9) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      }
      else {
        if (right) SetAngle(an+Random()*20.0); else SetAngle(an-Random()*20.0);
      }
      break;
    case bsk_excellent:
      if (MainGameInfo(player.Level.Game).botskill > 1 && Random() < 0.3) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      } else {
        if (right) SetAngle(an+Random()*20.0); else SetAngle(an-Random()*20.0);
      }
      break;
    case bsk_supreme:
      if (MainGameInfo(player.Level.Game).botskill > 0 && Random() < 0.1) {
        SetAngle(AngleTo(vector(px, py, enemy.Origin.z)));
      } else {
        if (right) SetAngle(an+Random()*20.0); else SetAngle(an-Random()*20.0);
      }
      break;
    default:
      Error("Unknown bot skill level: %d", info.intelect);
      return;
  }
}


//==========================================================================
//
//  BotAimInstant
//
//  instant weapons
//
//==========================================================================
void BotAimInstant (float dist, bool right, float an) {
  // [CW]
  if (info.accuracy > bsk_verypoor && info.accuracy <= bsk_high && dist <= EntityEx::MELEERANGE*2.0) {
    SetAngle(an);
    return;
  }

  //FIXME: Implement botskill, accuracy, and intelligence
  switch (info.accuracy) {
    case bsk_verypoor:
      if (right) SetAngle(an+Random()*60.0); else SetAngle(an-Random()*60.0);
      break;
    case bsk_poor:
      if (right) SetAngle(an+Random()*45.0); else SetAngle(an-Random()*45.0);
      break;
    case bsk_low:
      if (right) SetAngle(an+Random()*30.0); else SetAngle(an-Random()*30.0);
      break;
    case bsk_medium:
      if (right) SetAngle(an+Random()*15.0); else SetAngle(an-Random()*15.0);
      break;
    case bsk_high:
      SetAngle(an);
      break;
    case bsk_excellent:
      SetAngle(AngleTo(enemy.Origin+enemy.Velocity*0.1));
      break;
    case bsk_supreme://FIXME
      SetAngle(AngleTo(enemy.Origin+enemy.Velocity*0.1));
      break;
    default:
      Error("BotPlayer::AimInstant::Unknown bot accuracy skill level: %d", info.accuracy);
      return;
  }
}


//==========================================================================
//
//  BotAimSpecial
//
//==========================================================================
bool BotAimSpecial (float dist, bool right, float an) {
  /*
  if (player.ReadyWeapon.bBotBfg) {
    // BFG9000
    SetAngle(AngleTo(enemy.Origin));
    return true;
  }
  */
  return false;
}


//==========================================================================
//
//  BotAim
//
//==========================================================================
void BotAim () {
  float dist;
  bool right;
  float an;

  if (!enemy) return;

  if (t_react) return;

  // distance to enemy
  dist = botmo.DistTo2(enemy);

  right = !!(P_Random()&1);
  an = AngleTo(enemy.Origin);

  //Pitch(); // do it in attack code instead

  if (BotAimSpecial(dist, right, an)) return;

  if (player.ReadyWeapon.bBotProjectile) {
    BotAimProjectile(dist, right, an);
  } else {
    BotAimInstant(dist, right, an);
  }
}


//==========================================================================
//
//  FindMonsterOffender
//
//==========================================================================
Actor FindMonsterOffender () {
  if (player.Level.Game.deathmatch) return none;

  //print("looking for other player's offenders...");
  // roughTarget is for fellow bot, narrowTarget is for human player
  float bestNarrowDist = float.max;
  float bestRoughDist = float.max;
  Actor narrowTarget = none;
  Actor roughTarget = none;

  foreach (auto i; 0..MAXPLAYERS) {
    auto plr = player.Level.Game.Players[i];
    if (!plr) continue;
    if (!plr.bSpawned /*|| plr.MO.Health <= 0*/ || botmo == plr.MO) continue;
    auto act = Actor(PlayerEx(plr).Attacker);
    if (!act || !act.bMonster || act.bMissile || act.Health <= 0) continue;
    if (!Check_LOS(act, 360)) continue;
    if (GetCvarB('bot_developer_messages_attack')) print("  bot '%s': player %d offender is %C", player.PlayerName, i, act);
    float dist = botmo.DistTo2(act);
    if (plr.bIsBot) {
      if (!roughTarget || dist < bestRoughDist) { roughTarget = act; bestRoughDist = dist; }
    } else {
      if (!narrowTarget || dist < bestNarrowDist) { narrowTarget = act; bestNarrowDist = dist; }
    }
  }

  //print(" narrow: %C; rough: %C", narrowTarget, roughTarget);
  return (narrowTarget ? narrowTarget : roughTarget);
}



//==========================================================================
//
//  FindMonsterEnemy
//
//==========================================================================
Actor FindMonsterEnemy () {
  auto oldEnemy = enemy;
  scope(exit) enemy = oldEnemy;
  // if we have no enemy, but an attacker, switch to attacker
  Actor narrowTarget = none;
  float bestNarrowDist = float.max;
  Actor roughTarget = none;
  float bestRoughDist = float.max;

  Entity ee;
  foreach botmo.RadiusThings(ee, botmo.Origin, MONSTER_SCAN_RADIUS) {
    if (ee == botmo) continue; // don't target self
    Actor act = Actor(ee);
    if (!act) continue;
    if (!act.bShootable || !act.bMonster || act.bMissile) continue; // not interesting
    if (act.Health <= 0) continue; // it is dead
    float temp = act.DistTo(botmo);
    if (temp < 512 && temp < bestNarrowDist && GoodAngle(act, 120)) {
      enemy = act; // for `Check_LOS()`
      if (Check_LOS(act, 360) /*|| CheckTo(act.Origin)*/) {
        bestNarrowDist = temp;
        narrowTarget = act;
      }
    }
    if (!roughTarget && temp < bestRoughDist && GoodAngle(act, 180)) {
      enemy = act; // for `Check_LOS()`
      if (Check_LOS(act, 360) /*|| CheckTo(act.Origin)*/) {
        bestRoughDist = temp;
        roughTarget = act;
      }
    }
  }

  if (narrowTarget) return narrowTarget;
  if (roughTarget) return roughTarget;

  // if no targets, and we are in coop, attack the monster than hurts the player
  return FindMonsterOffender();
}


//==========================================================================
//
//  FindEnemy
//
//==========================================================================
Actor FindEnemy () {
  // note: it's hard to ambush a bot who is not alone
  float vangle = (bAllRound || ally ? 360.0 : ENEMY_SCAN_FOV);
  bAllRound = false;

  Actor target = none;
  float closest_dist = 99999.0;

  // if we have no enemy, but an attacker, switch to attacker
  if (!enemy && player.Attacker) {
    Actor act = Actor(player.Attacker);
    if (act && act != botmo && act.Health > 0 && act.bShootable && (act.bMonster || act.bIsPlayer)) {
      if (Check_LOS(act, 360)) {
        if (GetCvarB('bot_developer_messages_attack')) print("bot '%s' is retaliating to %C", player.PlayerName, act);
        return act;
      }
    }
  }

  if (player.Level.Game.deathmatch) {
    // search for player enemies in deathmatch
    bool ignoreHumans = GetCvarB('bot_ignore_humans');
    foreach (auto i; 0..MAXPLAYERS) {
      auto plr = player.Level.Game.Players[i];
      if (!plr) continue;
      if (!plr.bSpawned || plr.MO == botmo || plr.MO.Health <= 0) continue;
      if (ignoreHumans && !plr.bIsBot) continue;
      float temp = plr.MO.DistTo(botmo);
      if (temp < closest_dist) {
        if (Check_LOS(Actor(plr.MO), vangle)) {
          closest_dist = temp;
          target = Actor(plr.MO);
        }
      }
    }
  }

  // if no target, try to find some monster
  if (!target) target = FindMonsterEnemy();

  return target;
}


//==========================================================================
//
//  RoamRandom
//
//  support function for roaming
//  returns `true` if no further roam actions should be taken
//
//==========================================================================
void RoamRandom (out TVec dest) {
  float an = player.ViewAngles.yaw;

  if (GetCvarB('bot_developer_messages_roam')) print("bot '%s' has nothing to do; an=%s", player.PlayerName, an);

  posdest_valid = false;

  EntityEx::PathInfo piFwd, piLeft, piRight;
  float dist = 1024.0;

  Actor allyToSupport = FindAllyToSupport(allowESP:true);
  if (allyToSupport) {
    CheckTo(allyToSupport.Origin, out piFwd);
    if (GetCvarB('bot_developer_messages_roam')) print("bot '%s', ally to support is '%C', angle=%s; maxdist=%s", player.PlayerName, allyToSupport, piFwd.maxdist, piFwd.angle);
    if (piFwd.maxdist > 96) {
      SetAngle(piFwd.angle);
      player.ViewAngles.yaw = GetAngle();
      botmo.Angles.yaw = GetAngle();
      PerformLastCheckActions(piFwd);
      forwardmove = FORWARDRUN;
      lastpos = allyToSupport.Origin;
      lastpos_valid = true;
      posdest_valid = false;
      posdest_set_time = 0;
      item = none;
      return;
    }
  }

  if (FollowPath()) return;

  if (botmo.TracePath(an, dist, out piFwd)) {
    posdest_valid = true;
    posdest = botmo.Origin+dist*piFwd.dirxy;
    SetAngle(piFwd.angle);
    PerformLastCheckActions(piFwd);
    forwardmove = FORWARDWALK;
    return;
  }

  // check left and right
  botmo.TracePath(an+45, dist, out piLeft);
  botmo.TracePath(an-45, dist, out piRight);

  // random choice
  EntityEx::PathInfo *pip[3];
  pip[0] = &piFwd;
  pip[1] = &piLeft;
  pip[2] = &piRight;

  int swap0 = 0, swap1 = 0;
  if (P_Random() > 127) {
    swap0 = 1;
    swap1 = 2;
  } else if (P_Random() > 127) {
    swap0 = 0;
    swap1 = 1;
  } else if (P_Random() > 127) {
    swap0 = 0;
    swap1 = 2;
  }
  {
    auto tmp = pip[swap0]; pip[swap0] = pip[swap1]; pip[swap1] = tmp;
  }

  int idx = P_Random()%pip.length;
  foreach (auto n; 0..pip.length) {
    EntityEx::PathInfo *pi = pip[n];
    n = (n+1)%pip.length;
    if (pi.success || pi.maxdist > 64) {
      posdest_valid = true;
      posdest = botmo.Origin+dist*pi.dirxy;
      SetAngle(pi.angle);
      PerformLastCheckActions(*pi);
      forwardmove = FORWARDWALK;
      return;
    }
  }

  // cannot move, turn around
  SetAngle(GetAngle()+10.0+35.0*FRandomFull());
  // walk anyway
  forwardmove = FORWARDWALK;
  // do random jump in case we can free ourself with it
#ifdef BOT_ALLOW_JUMPS
  if (P_Random() > 127 && !GetCvarB('bot_no_jump')) player.Buttons |= BT_JUMP;
#endif

  return;
}


//==========================================================================
//
//  FollowPath
//
//==========================================================================
final bool FollowPath () {
  float currTime = botmo.XLevel.Time;
  int ssnum = botmo.SubSector-&botmo.XLevel.Subsectors[0];
  EntityEx::PathInfo pi;
  // running by path
  while (currPath.length) {
    BotPathNode node = ssnodes[currPath[$-1]];
    if (GetCvarB('bot_developer_messages_path')) print("going to subsector #%d (from #%d)", node.ssnum, ssnum);
    if (ssnum == node.ssnum) {
      // drop it, and continue
      currPath.length -= 1;
      continue;
    }
    if (!lastCurrFollowTime || lastCurrFollowSS != node.ssnum) {
      lastCurrFollowSS = node.ssnum;
      lastCurrFollowTime = currTime;
      lastCurrFollowPos = botmo.Origin;
      lastSSChangeTime = currTime;
    } else {
      TVec moved = lastCurrFollowPos-botmo.Origin;
      if (moved.length2DSquared < 8*8) {
        if (currTime-lastCurrFollowTime > 6) {
          print("FUCK! cannot move from subsector #%d to subsector #%d, dropping the path", ssnum, node.ssnum);
          ResetCurrPath();
          return false;
        }
      } else {
        lastCurrFollowTime = currTime;
        lastCurrFollowPos = botmo.Origin;
        if (currTime-lastSSChangeTime > 4) {
          print("DAMMIT! cannot move from subsector #%d to subsector #%d, replanning the path", ssnum, node.ssnum);
          if (!HavePathToSS(&botmo.XLevel.Subsectors[node.ssnum])) {
            print("  SHIT! cannot reach, dropping path");
            ResetCurrPath();
            return false;
          }
        }
      }
    }
    //player.ViewAngles.yaw = AngleTo(node.Origin);
    SetAngle(AngleTo(node.Origin));
    float dist = (botmo.Origin-node.Origin).length2D;
         if (dist <= 64+32) forwardmove = FORWARDWALK;
    else forwardmove = FORWARDRUN;
    botmo.TracePath(player.ViewAngles.yaw, FORWARDRUN, out pi, allowJump:true);
    PerformLastCheckActions(pi);
    return true;
  }

  return false;
}


//==========================================================================
//
//  Roam
//
//  Handle non-attack/dodging movement
//
//==========================================================================
void Roam () {
  if (FindAllyToSupport(allowESP:false)) {
    ResetCurrPath();
  }

  if (FollowPath()) return;

  TVec dest;
  float currTime = botmo.XLevel.Time;

  /*
  if (lastpos_valid) {
    TVec dir = lastpos-botmo.Origin;
    dir.z = 0.0;
    if (Length2D(dir) <= 32.0) lastpos_valid = false;
  }
  */

  if (item && !CheckTo(item.Origin)) {
    if (!HavePathToSS(item.SubSector)) {
      // forget for some time
      PutItemToIgnoreList(item, 1.0/4.0);
      item = none;
      itemFirstSeenTime = 0;
    } else {
      if (FollowPath()) return;
    }
  }

  if (item && currTime-itemFirstSeenTime > ITEM_GIVEUP_TIME) {
    PutItemToIgnoreList(item, 0.9);
    item = none;
    itemFirstSeenTime = 0;
  }

  EntityEx::PathInfo pi;
  bool destValid = false;

  // order of item response precedence
  if (goal) {
    dest = goal.Origin;
    if (CanGetCloserTo(dest)) {
      destValid = true;
      if (GetCvarB('bot_developer_messages_roam')) print("bot '%s' is going to goal at %s from %s", player.PlayerName, dest, botmo.Origin);
    }
  }

  if (!destValid && lastpos_valid) {
    dest = lastpos;
    if (HavePathToPoint(dest) || CanGetCloserTo(dest)) {
      destValid = true;
      if (GetCvarB('bot_developer_messages_roam')) print("bot '%s' is going to lastpost at %s from %s", player.PlayerName, dest, botmo.Origin);
    }
  }

  if (item) {
    dest = item.Origin;
    if (HavePathToSS(item.SubSector) || CanGetCloserTo(dest)) {
      destValid = true;
      if (GetCvarB('bot_developer_messages_roam') || GetCvarB('bot_developer_messages_item')) print("bot '%s' is going to item at %s from %s", player.PlayerName, dest, botmo.Origin);
      //if (botmo.DistTo2(item) <= botmo.Radius*2) noRun = true;
    }
  }

  if (node) {
    dest = node.Origin;
    if (HavePathToSS(node.SubSector) || CanGetCloserTo(dest)) {
      destValid = true;
      if (GetCvarB('bot_developer_messages_roam')) print("bot '%s' is going to node at %s from %s", player.PlayerName, dest, botmo.Origin);
    }
  }

  if (posdest_valid) {
    dest = posdest;
    if (HavePathToPoint(dest) || CanGetCloserTo(dest)) {
      destValid = true;
      if (GetCvarB('bot_developer_messages_roam')) print("bot '%s' is going to posdest at %s from %s (dist=%s)", player.PlayerName, dest, botmo.Origin, (dest-botmo.Origin).length2D);
    }
  }

  if (FollowPath()) return;

  if (!destValid) {
    // no target, so just run around until we find something
    RoamRandom(dest);
    return;
  }

  if (HavePathToPoint(dest)) {
    if (FollowPath()) return;
  }

  CheckTo(dest, out pi); // to setup flags
  // unconditionally, just for fun
  PerformLastCheckActions(pi);

  // bots are very bad at navigation, and even worser when running, so help 'em a little
  float distDest = (dest-botmo.Origin).length2DSquared;
  if (distDest <= 64*64) {
    forwardmove = FORWARDWALK/2.0;
  } else if (distDest <= 128*128) {
    forwardmove = FORWARDWALK;
  } else {
    forwardmove = FORWARDRUN;
  }

  // forget after some time
  if (posdestLast == dest && posdest_set_time > 0) {
    if (currTime-posdest_set_time > 5) {
      if (GetCvarB('bot_developer_messages_roam')) print("bot '%s': cannot reach destination, timeout is %s", player.PlayerName, currTime-posdest_set_time);
      lastpos_valid = false;
      posdest_valid = false;
      posdest_set_time = 0;
    } else {
      //posdest_set_time = currTime;
    }
  } else {
    posdestLast = dest;
    posdest_set_time = currTime;
  }

  //forwardmove = (noRun ? FORWARDWALK : FORWARDRUN);
  SetAngle(AngleTo(dest));
}


//==========================================================================
//
//  CheckWantCurrentItem
//
//==========================================================================
bool CheckWantCurrentItem () {
  if (!item) return false;
  if (!item.bSpecial || item.bInvisible || item.IsDestroyed()) { item = none; return false; } // picked up by someone
  if (bItemIsPowerup) return true; // always collect powerups
  if (!bItemIsWeapon) return false; // don't bother with non-weapons
  Weapon wpn = Weapon(item);
  if (!wpn) return false;
  if (!player.ReadyWeapon || !CanAttackWithCurrentWeapon()) return true; // want any weapon
  if (wpn.bWimpyWeapon || wpn.bBotMelee) return false;
  Weapon currWpn = Weapon(player.ReadyWeapon);
  if (!currWpn) return true; // just in case
  if (currWpn.bWimpyWeapon) return true; // replace wimpy weapon
  if (currWpn.bBotMelee) return true; // replace melee weapon
  // assume that higher slot means "better weapon" (this is not always true, but...)
  if (wpn.SelectionOrder && currWpn.SelectionOrder) return (wpn.SelectionOrder < currWpn.SelectionOrder);
  if (wpn.SlotNumber > 0 && currWpn.SlotNumber > 0 && wpn.SlotNumber > currWpn.SlotNumber) return true;
  return true; //(wpn.SelectionOrder < currWpn.SelectionOrder);
}


//==========================================================================
//
//  Move
//
//  main bot movement function.
//  dodging/attacking movement is also handled here
//
//==========================================================================
void Move (float deltaTime) {
  // worry about missiles above all else
  if (missile) {
    if (t_strafe) {
      t_strafe = fmax(0, t_strafe-deltaTime);
      if (!t_strafe) {
        // don't change direction while dodging missiles (that could be bad)
        //bot->sidemove = -bot->sidemove;
        t_strafe = 2.0;
      }
    }

    // look at the missle and sidestep it
    SetAngle(AngleTo(missile.Origin));
    forwardmove = -FORWARDRUN;
    return;
  }

  // anticipate a shot: time to dodge!
  if (enemy && t_shootcooldown <= 0.25) {
    if (!sidemove) sidemove = SIDERUN;

    switch (info.anticip) {
      case bsk_verypoor:
        // deer caught in the headlights
        sidemove = 0.0;
        return;

      case bsk_poor:
        // always walk right
        sidemove = SIDEWALK;
        break;

      case bsk_low:
        // always run right
        sidemove = SIDERUN;
        break;

      case bsk_medium:
        // just switch directions every couple seconds
        if (t_strafe) {
          t_strafe = fmax(0, t_strafe-deltaTime);
          if (!t_strafe) {
            sidemove = -sidemove;
            t_strafe = 2.0;
          }
        }
        break;

      case bsk_high:
        // switch directions when we think our opponent will fire
        if (!t_shootcooldown) sidemove = -sidemove;
        break;

      case bsk_excellent:
        // move in a somewhat random direction when we think our opponent will fire
        if (!t_shootcooldown) {
          sidemove = (Random() < 0.5 ? SIDERUN : -SIDERUN);
          if (Random() < 0.5) forwardmove = -FORWARDWALK;
        }
        break;

      case bsk_supreme:
        // what a squirmy little fucker!
        if (!t_shootcooldown) {
          switch (P_Random()&3) {
            case 0: sidemove = SIDERUN; break;
            case 1: sidemove = SIDEWALK; break;
            case 2: sidemove = -SIDERUN; break;
            case 3: sidemove = -SIDEWALK; break;
          }
          switch (P_Random()&3) {
            case 0: forwardmove = FORWARDRUN; break;
            case 1: forwardmove = FORWARDWALK; break;
            case 2: forwardmove = -FORWARDRUN; break;
            case 3: forwardmove = -FORWARDWALK; break;
          }
        }
        break;

      default:
        Error("Unknown bot skill level: %d", info.anticip);
        return;
    }
  }

  // now handle attack movement
  if (enemy) {
    EntityEx::PathInfo pi;

    if (!sidemove) sidemove = SIDERUN;

    if (t_strafe) {
      t_strafe = fmax(0, t_strafe-deltaTime);
      if (!t_strafe) {
        sidemove = -sidemove;
        t_strafe = 2.0;
      }
    }

    float dist = botmo.DistTo(enemy);

    // remember where we saw him last in case he gets away
    lastpos = enemy.Origin;
    lastpos_valid = true;
    if (GetCvarB('bot_developer_messages_roam')) print("bot '%s': going to enemy lastpos %C", player.PlayerName, enemy);

    // check if we'd rather pick up something than fight
    if (item) {
      if (CheckWantCurrentItem()) {
        sidemove = 0;
        Roam();
        return;
      }
    }

    float an = botmo.Angles.yaw;
    if (sidemove < 0.0) an -= 90.0; else an += 90.0;

    if (!botmo.TracePath(an, 48.0, out pi)) {
      // we're blocked, so go the other way!
      sidemove = -sidemove;
    }

    if (CheckTo(enemy.Origin, out pi) && dist > player.ReadyWeapon.BotCombatDist) {
      forwardmove = FORWARDRUN;
    } else {
      if (botmo.TracePath(an+180, 64, out pi)) {
        forwardmove = -FORWARDRUN;
      } else {
        forwardmove = FORWARDRUN;
      }
    }

    // unconditionally, just for fun
    PerformLastCheckActions(pi);
    return;
  }

  if (t_strafe) {
    t_strafe = fmax(0, t_strafe-deltaTime);
    if (!t_strafe) {
      sidemove = -sidemove;
      t_strafe = 2.0;
    }
  }

  // roam after an item
  Roam();
}


//==========================================================================
//
//  AttackSpecial
//
//==========================================================================
bool AttackSpecial () {
  /*
  if (player.ReadyWeapon.Class == Chaingun)
  {
    // Double tap the chaingun for extreme accuracy
    if (info.accuracy == bsk_supreme)
      if (t_fire)
        return true;
  }
  */
  return false;
}


//==========================================================================
//
//  CanAttackWithCurrentWeapon
//
//==========================================================================
bool CanAttackWithCurrentWeapon (optional bool ignorePending) {
  if (ignorePending) {
    if (player.PendingWeapon) return false; // we're going to switch weapons, cannot attack
  } else {
    if (player.PendingWeapon) {
      if (player.PendingWeapon.CheckAmmo(Weapon::FIRE_Primary, AutoSwitch:false)) return true;
    }
  }

  if (player.ReadyWeapon) {
    if (player.ReadyWeapon.CheckAmmo(Weapon::FIRE_Primary, AutoSwitch:false)) return true;
  }

  return false;
}


//==========================================================================
//
//  BuildWeaponList
//
//==========================================================================
void BuildWeaponList () {
  weaponList.reset(); // don't reallocate
  if (!botmo) return;

  auto pawn = PlayerPawn(botmo);
  if (!pawn) return;

  int currSlot = 0;
  int currIndex = -1;

  foreach (auto i; 0..PlayerPawn::MAX_WEAPONS_PER_SLOT*(PlayerPawn::NUM_WEAPON_SLOTS+1)) {
    if (++currIndex == PlayerPawn::MAX_WEAPONS_PER_SLOT) {
      currIndex = 0;
      currSlot = (currSlot+1)%(PlayerPawn::NUM_WEAPON_SLOTS+1);
    }
    class!Weapon swc = pawn.GetWeaponInSlot(currSlot, currIndex);
    if (!swc) continue;
    Weapon Wpn = Weapon(botmo.FindInventory(swc));
    if (Wpn) {
      if (Wpn.SisterWeapon && Wpn.SisterWeapon.bPoweredUp) {
        bool Powered = !!botmo.FindInventory(PowerWeaponLevel2);
        if (Powered) Wpn = Wpn.SisterWeapon;
      }
      weaponList[$] = Wpn;
    }
  }
}


//==========================================================================
//
//  BotSwitchWeapon
//
//==========================================================================
void BotSwitchWeapon () {
  BuildWeaponList();
  Weapon bestwpn = player.ReadyWeapon;
  if (bestwpn && !bestwpn.CheckAmmo(Weapon::FIRE_Primary, AutoSwitch:false)) bestwpn = none;
  foreach (Weapon wpn; weaponList) {
    if (!wpn.CheckAmmo(Weapon::FIRE_Primary, AutoSwitch:false)) continue;
    //if (!bestwpn) { bestwpn = wpn; continue; }
    if (wpn.bBotProjectile) {
      if (!enemy) continue;
      if (enemy.DistTo(botmo) <= SAFE_SELF_MISDIST) continue;
      if (!bestwpn || !bestwpn.bBotBfg) bestwpn = wpn;
      continue;
    }
    if (wpn.bBotBfg) {
      bestwpn = wpn;
      continue;
    }
    if (bestwpn && bestwpn.bBotMelee && !wpn.bBotMelee) {
      bestwpn = wpn;
      continue;
    }
    if (!bestwpn && (enemy || !wpn.bBotProjectile)) {
      bestwpn = wpn;
      continue;
    }
    if (bestwpn && !bestwpn.bBotBfg && wpn.SelectionOrder < bestwpn.SelectionOrder) {
      bestwpn = wpn;
    }
  }
  //print("  found weapon %C", bestwpn);
  if (bestwpn && bestwpn != player.ReadyWeapon) {
    //print("   setting weapon %C (ready is %C, pending is %C)", bestwpn, player.ReadyWeapon, player.PendingWeapon);
    player.PendingWeapon = bestwpn;
  }
}


//==========================================================================
//
//  Attack
//
//==========================================================================
void Attack () {
  // still reacting to something
  if (t_react) return;
  if (player.PendingWeapon) return;

  // check if we can fire current weapon, and
  // try to switch weapons if we can't
  if (!player.PendingWeapon) {
    BotSwitchWeapon();
    if (player.PendingWeapon) return;
  }

  // don't have an enemy to fight
  if (!enemy || enemy.Health <= 0) return;

  // never attack other players in coop
  if (enemy.bIsPlayer && !player.Level.Game.deathmatch) {
    // reset enemy
    if (GetCvarB('bot_developer_messages_attack')) print("bot '%s': oops, coop enemy is another player!", player.PlayerName);
    enemy = none;
    return;
  }

  if (!CanAttackWithCurrentWeapon(ignorePending:true)) return;

  // it we better pickup an item, don't attack
  if (CheckWantCurrentItem()) return;

  //if (player.ReadyWeapon) print("CANATTACK with %C: %B", player.ReadyWeapon, player.ReadyWeapon.CheckAmmo(Weapon::FIRE_Primary, AutoSwitch:false));

  // no point in firing if we won't hit them
  if (!Check_LOS(enemy, SHOOTFOV)) return;

  {
    TVec eorig = enemy.Origin;
    eorig.z += enemy.Height*0.95-enemy.FloorClip;

    TVec org = botmo.Origin;
    org.z += botmo.Height*0.5-botmo.FloorClip+player.GetAttackZOfs;

    TVec hp, norm;
    if (!botmo.XLevel.TraceLine(org, eorig, out hp, out norm)) {
      // try sidemove
      EntityEx::PathInfo piLeft;
      if (botmo.TracePath(GetAngle()-90, SIDEWALK, out piLeft)) {
        sidemove = -SIDEWALK;
        t_react = 0.3;
        return;
      }
      EntityEx::PathInfo piRight;
      if (botmo.TracePath(GetAngle()+90, SIDEWALK, out piRight)) {
        sidemove = SIDEWALK;
        t_react = 0.3;
        return;
      }
      sidemove = (piLeft.maxdist > piRight.maxdist ? -SIDERUN : SIDERUN);
      forwardmove = -FORWARDWALK;
      t_react = 0.3;
      return;
    }
  }

  // set dodge time
  t_shootcooldown = 0.3+0.5*FRandomFull();

  // set pitch here, so headshot checks will work as expected
  //FIXME: allies-in-water situation should be moved to separate function
  Pitch();

  if (AttackSpecial()) return;

  if (!t_fire) {
    if (GetCvarB('bot_developer_messages_attack')) print("bot '%s': attacking %s", player.PlayerName, enemy.Class);
    player.Buttons |= BT_ATTACK;
    //HACK: for plasmagun, do not release attack button
    if (player.ReadyWeapon && player.ReadyWeapon.bBotFastShoot) {
      t_fire = 0;
    } else {
      t_fire = 1.0/35.0*2.5;
    }
  }
}


//==========================================================================
//
//  Turn
//
//  [BC] Ahh, the new and improved turning...
//
//==========================================================================
void Turn () {
  float distance = GetAngle()-botmo.Angles.yaw;

       if (distance > 180.0) distance -= 360.0;
  else if (distance < -180.0) distance += 360.0;

  /*
  if (!enemy) {
    player.ViewAngles.yaw = GetAngle();
    return;
  }
  */

  // [BC] Don't act crazy while trying to aim
  switch (info.accuracy) {
    case bsk_verypoor:
    case bsk_poor:
    case bsk_low:
      distance = fclamp(distance, -7.5, 7.5);
      break;
    case bsk_medium:
      distance = fclamp(distance, -15, 15);
      break;
    case bsk_high:
      distance = fclamp(distance, -22.5, 22.5);
      break;
    case bsk_excellent:
      distance = fclamp(distance, -30, 30);
      break;
    case bsk_supreme:
      distance = fclamp(distance, -37.5, 37.5);
      break;
  }

  player.ViewAngles.yaw = AngleMod360(botmo.Angles.yaw+distance);
}


//==========================================================================
//
//  Pitch
//
//==========================================================================
void Pitch () {
  bool doHeadshots = GetCvarB('bot_always_headshots');
  float hsdist = 512; // average

  if (!player.ReadyWeapon || player.ReadyWeapon.bBotProjectile || !GetCvarB('k8HSEnabled')) {
    doHeadshots = false;
  } else {
    if (!doHeadshots) {
      switch (info.intelect) {
        case bsk_verypoor:
          if (FRandomFull() < 0.2) { doHeadshots = true; hsdist = 256; }
          break;
        case bsk_poor:
          if (FRandomFull() < 0.3) { doHeadshots = true; hsdist = 256; }
          break;
        case bsk_low:
          if (FRandomFull() < 0.4) { doHeadshots = true; hsdist = (P_Random()&1 ? 384 : 256); }
          break;
        case bsk_medium:
          if (FRandomFull() < 0.5) { doHeadshots = true; hsdist = (P_Random()&1 ? 384 : 256); }
          break;
        case bsk_high:
          if (FRandomFull() < 0.6) { doHeadshots = true; hsdist = (P_Random()&1 ? 512 : 384); }
          break;
        case bsk_excellent:
          if (FRandomFull() < 0.8) { doHeadshots = true; hsdist = (P_Random()&1 ? 512 : 384); }
          break;
        case bsk_supreme:
          if (FRandomFull() < 0.9) { doHeadshots = true; hsdist = (P_Random()&1 ? 512 : 384); }
          break;
      }
    }
  }

  if (enemy) {
    if (doHeadshots && botmo.DistTo2(enemy) <= hsdist) {
      if (GetCvarB('bot_developer_messages_attack')) print("bot '%s': HEADSHOTTING %C", player.PlayerName, enemy);
    } else {
      if (GetCvarB('bot_developer_messages_attack')) print("bot '%s': shooting at %C", player.PlayerName, enemy);
      doHeadshots = false;
    }
  } else {
    doHeadshots = false;
  }

  botmo.Angles.pitch = 0.0;

  // new code
  // [FB] Set pitch for underwater areas
  if (player.MO.WaterLevel > 2) {
    if (enemy) {
      botmo.Angles.pitch = PitchToEntity(enemy, doHeadshots);
    } else {
      // [FB] Follow our buddy if we're tagging along
      if (ally || (ally && !enemy)) {
        botmo.Angles.pitch = PitchToEntity(ally);
      }
    }
  } else {
    if (enemy) {
      botmo.Angles.pitch = PitchToEntity(enemy, doHeadshots);
      //print("bot: enemy at %s, bot at %s, pitch is %s (%s) (%s)", eorig, org, botmo.Angles.pitch, player.ViewAngles.pitch, enemy.Class);
      //print("     real: enemy at %s, bot at %s (eheight=%s, bheight=%s, efclip=%s, bfclip=%s, zofs=%s)", enemy.Origin, botmo.Origin, enemy.Height, botmo.Height, enemy.FloorClip, botmo.FloorClip, player.GetAttackZOfs);
    }
  }

  //k8: if we won't do this, it won't work right
  player.ViewAngles.pitch = botmo.Angles.pitch;
}


//==========================================================================
//
//  Killed
//
//==========================================================================
void Killed (EntityEx victim) {
  // [BC] Let some anger out
  angerlevel -= 5;
  enemy = none;

  // [BC] Don't need to worry about following him anymore
  lastpos_valid = false;
}


//==========================================================================
//
//  Died
//
//==========================================================================
void Died (EntityEx killer) {
  lastThinkTic = 0;
}


//==========================================================================
//
//  OnBeginPlay
//
//==========================================================================
void OnBeginPlay () {
  int botskill = 4;
  int bottype = 0;
  botinfo_t *binfo;

  bool randomBot = true;

  if (player.PlayerName) {
    foreach (auto i; 0..MainGameInfo::NUMTOTALBOTS) {
      if (stricmp(MainGameInfo(player.Level.Game).botinfo[i].Name, player.PlayerName) == 0) {
        bottype = i;
        randomBot = false;
        break;
      }
    }
  }

  if (randomBot) {
    // if the user doesn't input a name, don't
    // spawn one of the "special" bots, only one of the
    // normal ones.
    bottype = P_Random()%MainGameInfo::NUMBOTTYPES;
  }

  //print("bottype=%s; name='%s'", bottype, player.PlayerName);

  binfo = &MainGameInfo(player.Level.Game).botinfo[bottype];

  t_strafe = 1.0;

  if (botskill > 4) botskill = 4;
  if (botskill < 0) botskill = 0;

  // implement skill settings
  info.accuracy = SkillLower(binfo->accuracy, 4-botskill);
  info.intelect = SkillLower(binfo->intelect, 4-botskill);
  info.evade = SkillLower(binfo->evade, 4-botskill);
  info.anticip = SkillLower(binfo->anticip, 4-botskill);
  info.reaction = SkillLower(binfo->reaction, 4-botskill);
  player.UserInfo = binfo->userinfo;

  if (randomBot && default.BotNames.length) {
    //print("OLD USERINFO: '%s'", player.UserInfo);
    // use random bot name
    string botName;
    foreach (; 0..100) {
      botName = default.BotNames[round(FRandomFull()*default.BotNames.length)%default.BotNames.length];
      bool found = false;
      foreach (auto pidx; 0..MAXPLAYERS) {
        auto plr = player.Level.Game.Players[pidx];
        if (!plr) continue;
        if (stricmp(plr.PlayerName, botName) == 0) { found = true; break; }
      }
      if (!found) break;
    }
    if (player.UserInfo.strStartsWith("\\Name")) {
      auto idx = player.UserInfo.strIndexOf("\\", 1);
      idx = player.UserInfo.strIndexOf("\\", idx+1);
      if (idx > 0) {
        player.UserInfo = "\\Name\\"~botName~player.UserInfo[idx..$];
      } else {
        player.UserInfo ~= "\\Name\\"~botName;
      }
    } else {
      player.UserInfo ~= "\\Name\\"~botName;
    }
    //print("NEW USERINFO: '%s'", player.UserInfo);
  }

  /*
  if (!player.Level.Game.deathmatch) {
    info.accuracy = bsk_high;
    info.intelect = bsk_high;
    info.evade = bsk_high;
    info.anticip = bsk_high;
    info.reaction = bsk_high;
  }
  */
}


//==========================================================================
//
//  OnSpawn
//
//==========================================================================
void OnSpawn () {
  if (ssnodes.length != player.MO.XLevel.Subsectors.length || lastMapHash != player.MO.XLevel.MapHash) {
    lastMapHash = player.MO.XLevel.MapHash;
    foreach (ref BotPathNode node; ssnodes) delete node;
    ssnodes.length = player.MO.XLevel.Subsectors.length; // clear it
    foreach (ref BotPathNode node; ssnodes) node = none;
  }

  ITarget = none;
  Actor item = none;
  itemFirstSeenTime = 0;
  bItemIsWeapon = false;
  bItemIsPowerup = false;
  goal = none;
  node = none;
  prev = none;
  posdest_valid = false;
  posdest_set_time = 0;
  enemy = none;
  lastpos_valid = false;
  missile = none;

  ally = none;
  itemIgnoreTimeout.reset();
  ResetCurrPath();

  lastThinkTic = 0;

  // forgot who killed us (sometimes)
  if (FRandomFull() < 0.7) player.Attacker = none;

  EntityEx(player.MO).TraceIsDangerousSectorCB = &IsDangerous;
}


defaultproperties {
#include "botnames.vc"
}
