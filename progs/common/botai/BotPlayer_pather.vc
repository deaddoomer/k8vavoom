//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
// this is base pathfinding for bots
//
// we don't need to build any navigational mesh, as we arealdy have one!
// really, we were dropping breadcrumbs into each subsector center, but
// we don't need those breadcumbs, we can use subsectors themselves.
//
// there is some overhead in checking subsector segs, though.
// we can cache this info in Level object later.
//**************************************************************************
// A-Star node
class BotPathNode : MiAStarNodeBase;

// created for each passable seg
struct Transition {
  GameObject::seg_t *seg;
  GameObject::subsector_t *sub;
  int subnum;
  float dist; // <0: impassable
  float moveCost; // +20 for "needUse", arbitrary weight; <0: impassable
  bool needJump;
  bool needUse;
  // compare this with sector's values to see if we need to reevaluate "passability"
  float floorDist, ceilDist;
}

Level XLevel; // level object (i.e. actual map)
TVec Origin;
int ssnum;
GameObject::subsector_t *sub;
bool door; // is this subsector a door part?
bool valid;

int queryCounter;

// reachable subsectors (should be at least one, zero means "don't know yet")
array!Transition exits;
array!int sectorExits; // indicies in `exits` that leads to other sectors

// `true` if this node has some impassable 2-sided walls
// this means that this node should be re-evaluated next time the bot hits it
// this is done so the bot can notice opened secret doors like one on MAP01, for example
float myFloorDist, myCeilDist;
bool needRefresh; // false if we have only minisegs here


static final BotPathNode CreateNew (Level axlevel) {
  BotPathNode res = SpawnObject(BotPathNode);
  res.XLevel = axlevel;
  return res;
}


/*
override void Destroy () {
  exits.length = 0;
  ::Destroy();
}
*/


defaultproperties {
}


// ////////////////////////////////////////////////////////////////////////// //
class BotPathGraph : MiAStarGraphBase;

BotPlayerBase bot;

// a-star nodes
array!BotPathNode nodes;
// this flag will be set if some node was refreshed
// we need to reset cache, and look for path again
bool cacheIsInvalid;

int queryCounter;
// nodes that need to be fully refreshed
// key: node index, value: nobody cares
dictionary!(int, int) refreshMap;

bool debugDump;


override void Destroy () {
  foreach (ref auto node; nodes) delete node;
  nodes.length = 0;
  ::Destroy();
}


final void IncQueryCounter () {
  Reset();
  if (!(++queryCounter)) {
    foreach (auto node; nodes) node.queryCounter = 0;
    queryCounter = 1;
  }
}


final bool needOpenDoor (GameObject::sector_t *sec) {
  return (sec.ceiling.minz-sec.floor.maxz < bot.player.MO.Height);
}


final bool isDoorSector (GameObject::sector_t *sec, GameObject::subsector_t *sub) {
  // check if this sector has door activation lines
  GameObject::line_t *ld;
  //print("checking sector #%s for 'doorness' (%d lines; sub #%d)...", sec-&bot.player.MO.XLevel.Sectors[0], sec.lines.length, sub-&bot.player.MO.XLevel.Subsectors[0]);
  foreach (int idx, ld; sec.lines) {
    if (EntityEx.isGoodDoorLinedef(sec, ld)) return true;
  }
  return false;
}


// prerequisite: sector must be a door
// returns `true` if we need to restore a sector
final bool fakeOpenDoor (GameObject::subsector_t *sub, out EntityEx::FakeDoorInfo fi) {
  GameObject::sector_t *sec = sub.sector;
  auto lowest = EntityEx.findLowestCeilingSurrounding(sec);
  if (!lowest) return false;
  return EntityEx(bot.player.MO).fakeSaveOpenDoor(out fi, sec, lowest);
}


final void restoreFakeOpenDoor (const ref EntityEx::FakeDoorInfo fi) {
  EntityEx(bot.player.MO).restoreFakeOpenDoor(fi);
}


final bool IsGoodMapPosition (ref TVec pos) {
  Entity::tmtrace_t tmtrace;
  pos.z = EntityEx::ONFLOORZ;
  if (bot.player.MO.CheckRelPosition(&tmtrace, pos, noPickups:true, ignoreMonsters:true, ignorePlayers:true)) {
    pos = tmtrace.End;
    return true;
  } else {
    return false;
  }
}


final void queueRefreshNode (BotPathNode node) {
  refreshMap.put(node.ssnum, true);
}


// should be called when sector heights changed
// returns `true` if something was changed
final bool validateNode (BotPathNode node) {
  if (node.queryCounter == queryCounter) return false;
  node.queryCounter = queryCounter;

  auto sec = node.sub.sector;
  bool changed = (sec.floor.dist != node.myFloorDist || sec.ceiling.dist != node.myCeilDist);

  if (changed) {
    node.myFloorDist = sec.floor.dist;
    node.myCeilDist = sec.ceiling.dist;

    EntityEx::FakeDoorInfo savedPlane;
    Level lev = bot.player.MO.XLevel;

    print("sector #%d (sub #%d) moved!", node.sub.sector-&lev.Sectors[0], node.ssnum);

    GameObject::subsector_t *sub = node.sub;
    bool fakeRestore = (node.door ? fakeOpenDoor(sub, out savedPlane) : false);
    scope(exit) if (fakeRestore) restoreFakeOpenDoor(savedPlane);
    TVec cpos = lev.GetSubsectorCenter(sub);
    // try various map positions
    if (!IsGoodMapPosition(cpos)) {
      // cannot stand here, try corners
      bool ok = false;
      TVec center = lev.GetSubsectorCenter(sub);
      foreach (auto lidx; sub.firstline..sub.firstline+sub.numlines) {
        GameObject::seg_t *seg = &lev.Segs[lidx];
        TVec dir = center-(*seg->v1);
        if (dir.length2DSquared < 4*4) continue;
        TVec dest = (*seg->v1)+(dir.normalise2D)*3.5;
        dest.z = EntityEx::ONFLOORZ;
        if (IsGoodMapPosition(dest)) {
          auto dss = lev.PointInSubsector(dest);
          if (dss == sub) {
            ok = true;
            cpos = dest;
            break;
          }
        }
      }
      if (node.valid != ok || node.Origin != cpos) {
        print("node #%d becomes %svalid (door:%B; sector: %s)", node.ssnum, (ok ? "" : "in"), node.door, node.sub.sector-&lev.Sectors[0]);
        node.Origin = cpos;
        node.valid = ok;
        cacheIsInvalid = true;
        return true;
      }
    } else {
      if (!node.valid || node.Origin != cpos) {
        print("node #%d becomes valid (door:%B; sector: %s)", node.ssnum, node.door, node.sub.sector-&lev.Sectors[0]);
        node.Origin = cpos;
        node.valid = true;
        cacheIsInvalid = true;
        return true;
      }
    }
  }

  if (changed) cacheIsInvalid = true;
  return changed;
}


final bool refreshNodeExit (BotPathNode node, int exitnum) {
  EntityEx botmo = EntityEx(bot.player.MO);
  Level lev = botmo.XLevel;
  auto tr = &node.exits[exitnum];

  GameObject::seg_t *seg = tr.seg;
  GameObject::line_t *ld = seg.linedef;
  GameObject::sector_t *sec = tr.sub.sector;

  if (sec.floor.dist == tr.floorDist && sec.ceiling.dist == tr.ceilDist) return false;

  tr.floorDist = sec.floor.dist;
  tr.ceilDist = sec.ceiling.dist;

  // ok, this looks like something interesting
  int psnum = tr.subnum;
  BotPathNode otherNode = nodes[psnum];

  bool changed = validateNode(otherNode);

  if (!otherNode.valid) {
    if (tr.dist != -1) {
      print("invalidated exit #%d from node #%d to sub #%d due to other-invalid", exitnum, node.ssnum, tr.subnum);
      tr.dist = -1;
      tr.needJump = false;
      tr.needUse = false;
      tr.moveCost = -1;
      cacheIsInvalid = true;
      return true;
    }
  }

  EntityEx::PathInfo pi;
  TVec dir = otherNode.Origin-node.Origin;
  dir.z = 0;
  float dist = dir.length2D;

  float yaw = VectorAngleYaw(dir.normalise2D);
  bool reached = botmo.TracePath(yaw, dist, out pi, allowJump:true, allowDrop:true, ignoreMonsters:true, srcOrigin:node.Origin);
  // if not reached, but the destination is in required subsector, consider this node reachable
  if (!reached) {
    dir.z = 0;
    TVec res = node.Origin+dir.normalise2D*pi.maxdist;
    GameObject::subsector_t *dss = lev.PointInSubsector(res);
    if (dss == tr.sub) reached = true;
  }

  // if reached, record this path
  if (reached) {
    //if (dumpReachable && tr.dist < 0) print("  can reach sub #%d from sub #%d", tr.subnum, node.ssnum);
    bool wasValid = (tr.dist >= 0);
    if (!changed && (tr.dist != pi.maxdist || tr.needJump != pi.needJump || tr.needUse != pi.needUse)) changed = true;
    tr.dist = pi.maxdist;
    tr.needJump = pi.needJump;
    tr.needUse = pi.needUse;
    float oldCost = tr.moveCost;
    tr.moveCost = pi.maxdist*pi.maxdist+(pi.needUse ? 20 : 0);
    if (bot.IsDangerous(tr.sub.sector)) tr.moveCost *= 9;
    if (!changed && tr.moveCost != oldCost) changed = true;
    if (changed && !wasValid) print("validated exit #%d from node #%d to sub #%d", exitnum, node.ssnum, tr.subnum);
  } else {
    if (tr.dist != -1) {
      tr.dist = -1;
      tr.needJump = false;
      tr.needUse = false;
      tr.moveCost = -1;
      changed = true;
      if (changed) print("invalidated exit #%d from node #%d to sub #%d", exitnum, node.ssnum, tr.subnum);
    }
  }

  if (changed) cacheIsInvalid = true;
  return changed;
}


final bool refreshNode (BotPathNode node) {
  if (node.queryCounter == queryCounter) return false;
  bool changed = validateNode(node);
  foreach (auto tridx, ref auto tr; node.exits) {
    if (refreshNodeExit(node, tridx)) changed = true;
  }
  if (changed) cacheIsInvalid = true;
  return changed;
}


final void Setup (BotPlayerBase abot) {
  if (!abot) FatalError("something is very wrong with bot pathfinder");
  bot = abot;
  foreach (ref auto node; nodes) delete node;
  EntityEx botmo = EntityEx(bot.player.MO);
  Level lev = botmo.XLevel;

  Reset();
  queryCounter = 1;

  EntityEx::FakeDoorInfo savedPlane;

  // create nodes
  nodes.length = lev.Subsectors.length;
  foreach (auto idx, ref auto node; nodes) {
    GameObject::subsector_t *sub = &lev.Subsectors[idx];
    node = BotPathNode.CreateNew(lev);
    node.sub = sub;
    node.ssnum = idx;
    TVec cpos = lev.GetSubsectorCenter(sub);
    cpos.z = EntityEx::ONFLOORZ;
    node.Origin = cpos;
    node.myFloorDist = float.max; //sub.sector.floor.dist;
    node.myCeilDist = float.max; //sub.sector.ceiling.dist;
    node.needRefresh = false;
    node.door = isDoorSector(sub.sector, sub);
    node.queryCounter = 0;
    validateNode(node);
  }

  foreach (auto node; nodes) {
    GameObject::subsector_t *sub = node.sub;

    // if this sector a door, fake-open it
    bool fakeRestore = (node.door ? fakeOpenDoor(sub, out savedPlane) : false);
    scope(exit) if (fakeRestore) restoreFakeOpenDoor(savedPlane);

    // check reachable subsectors
    foreach (auto lidx; sub.firstline..sub.firstline+sub.numlines) {
      GameObject::seg_t *seg = &lev.Segs[lidx];
      if (!seg.partner || seg.partner.front_sub == seg.front_sub) continue; // not interesting

      GameObject::line_t *ld = seg.linedef;
      if (ld) {
        // not a miniseg
        if (!(ld.flags&GameObject::ML_TWOSIDED)) continue; // not interesting
        if (ld.flags&(GameObject::ML_BLOCKING|GameObject::ML_BLOCKPLAYERS|GameObject::ML_BLOCKEVERYTHING)) continue; // not interesting
        node.needRefresh = true;
      }

      auto tr = node.exits.alloc();
      tr.seg = seg;
      tr.sub = seg.partner.front_sub;
      tr.subnum = tr.sub-&lev.Subsectors[0];

      if (tr.sub.sector != sub.sector) {
        node.sectorExits[$] = node.exits.length-1;
      }

      refreshNodeExit(node, node.exits.length-1);
    }
  }
}


// estimate distance between two nodes
// use squared distance, because it doesn't matter, so we can avoid `sqrt()` call
override float LeastCostEstimate (MiAStarNodeBase start, MiAStarNodeBase end) {
  BotPathNode s = BotPathNode(start);
  BotPathNode e = BotPathNode(end);
  refreshNode(s);
  refreshNode(e);
  if (debugDump) print("LeastCostEstimate from %d (%B) to %d (%B); est=%s", s.ssnum, s.valid, e.ssnum, e.valid, (s.Origin-e.Origin).length2DSquared);
  if (!s.valid || !e.valid) return 999999;
  return (s.Origin-e.Origin).length2DSquared;
}


// should always generate the same set for the same node,
// so we cannot update nodes here
override void AdjacentCost (MiAStarNodeBase node) {
  BotPathNode pn = BotPathNode(node);
  if (debugDump) print("AdjacentCost for %s (%B)", pn.ssnum, pn.valid);
  refreshNode(pn);
  if (!pn.valid) return;
  foreach (const ref auto tr; pn.exits) {
    refreshNode(nodes[tr.subnum]);
    if (tr.moveCost >= 0 && nodes[tr.subnum].valid) {
      if (debugDump) print("  for %s: adj is #%s (cost=%s)", pn.ssnum, tr.subnum, tr.moveCost);
      PushAdjacentCost(nodes[tr.subnum], tr.moveCost);
    } else {
      if (debugDump) print("  for %s: adj is #%s DROPPED", pn.ssnum, tr.subnum);
    }
  }
}


// returns `false` if there is no path
final bool BuildPath (TVec from, GameObject::subsector_t *fromsub, TVec dest, GameObject::subsector_t *destsub) {
  BotPlayerBase abot = bot;
  if (!abot || !abot.player || abot.player.Health <= 0) return false;
  // we may need alive bot mobile to re-evaluate nodes
  Actor botmo = Actor(abot.player.MO);
  if (!botmo || botmo.Health <= 0) return false; // dead bot cannot go anywhere
  Level lev = bot.player.MO.XLevel;

  if (!fromsub) fromsub = lev.PointInSubsector(from);
  if (!destsub) destsub = lev.PointInSubsector(dest);

  // early exit: same subsector is always reachable
  if (fromsub == destsub) {
    PathArrayClear();
    PathArrayPushNode(nodes[fromsub-&lev.Subsectors[0]]);
    pathCost = 0;
    return true;
  }

  if (cacheIsInvalid) { Reset(); cacheIsInvalid = false; }
  refreshNode(nodes[fromsub-&lev.Subsectors[0]]);
  refreshNode(nodes[destsub-&lev.Subsectors[0]]);
  if (cacheIsInvalid) { Reset(); cacheIsInvalid = false; }

  // run solver
  for (;;) {
    cacheIsInvalid = false;
    bool res = Solve(nodes[fromsub-&lev.Subsectors[0]], nodes[destsub-&lev.Subsectors[0]]);
    if (!cacheIsInvalid) return res;
    // something was changed, result is nonsensical; reset cache and restart
    print("bot '%s' reset path cache", abot.player.PlayerName);
    Reset();
  }
}


defaultproperties {
}
