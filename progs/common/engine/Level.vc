//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class Level : GameObject native;

const int MAX_LEVEL_TRANSLATIONS = 0xffff;
const int MAX_BODY_QUEUE_TRANSLATIONS = 0xff;

// script types
const int
  SCRIPT_Closed      = 0,
  SCRIPT_Open        = 1,
  SCRIPT_Respawn     = 2,
  SCRIPT_Death       = 3,
  SCRIPT_Enter       = 4,
  SCRIPT_Pickup      = 5,
  SCRIPT_BlueReturn  = 6,
  SCRIPT_RedReturn   = 7,
  SCRIPT_WhiteReturn = 8,
  SCRIPT_Lightning   = 12,
  SCRIPT_Unloading   = 13,
  SCRIPT_Disconnect  = 14,
  SCRIPT_Return      = 15;

struct StateCall {
  Entity Item;
  state State;
  ubyte Result;
};

struct SectorLink {
  int index;
  int mts; // bit 30: set if ceiling; low byte: movetype
  int next; // index, or -1
};

native readonly name MapName;
native readonly string MapHash; // lowercase
native readonly string MapHashMD5; // lowercase
native readonly int LSSHash; // xxHash32 of linedefs, sidedefs, sectors (in this order)
native readonly int SegHash; // xxHash32 of segs

// flags
native readonly private bool bForServer; // true if this level belongs to the server
native readonly bool bExtended; // true if level was in Hexen format
native readonly private bool bGLNodesV5; // true if using version 5 GL nodes
native readonly bool bTextMap; // UDMF format map
// used in map fixer
native transient bool bForceRebuildNodes;
native transient bool bForceAllowSeveralPObjInSubsector;
native transient bool bForceNoTexturePrecache;
native transient bool bForceNoPrecalcStaticLights;
native transient bool bForceNoDeepwaterFix;
native transient bool bForceNoFloorFloodfillFix;
native transient bool bForceNoCeilingFloodfillFix;
// not in C++
native transient bool bConvertSectorLightsToStatic;

// map-related data
native TVec[] Vertexes;
native sector_t[] Sectors;
native side_t[] Sides;
native line_t[] Lines;
native readonly seg_t[] Segs;
native readonly subsector_t[] Subsectors;
native readonly private node_t[] Nodes;

native readonly private ubyte *VisData;
native readonly private ubyte *NoVis;

// !!! Used only during level loading
native mthing_t[] Things;

native readonly private int BlockMapLumpSize;
native readonly private ubyte *BlockMapLump;
native readonly private ubyte *BlockMap;
native readonly private int BlockMapWidth;
native readonly private int BlockMapHeight;
native readonly private float BlockMapOrgX;
native readonly private float BlockMapOrgY;
native readonly private ubyte *BlockLinks;
native readonly private ubyte *PolyBlockMap;

native readonly private ubyte *RejectMatrix;
native readonly private int RejectMatrixSize;

// strife conversations
native RogueConSpeech[] GenericSpeeches;
native RogueConSpeech[] LevelSpeeches;

// list of all poly-objects on the level
native readonly private int[] PolyObjs;
native readonly private int[] PolyAnchorPoints;

// sound environments for sector zones
native int[] Zones;

native readonly private Thinker ThinkerHead;
native readonly private Thinker ThinkerTail;

native readonly LevelInfo LevelInfo;
native readonly WorldInfo WorldInfo;

native readonly void *Acs;

native readonly private void *RenderData;
native readonly private void *NetContext;

native readonly private void *BaseLines;
native readonly private void *BaseSides;
native readonly private void *BaseSectors;
native readonly private void *BasePolyObjs;

//native readonly private int[] StaticLights;
native readonly private void *StaticLights;
native readonly private int NumStaticLights;

// not really array of ints, and properly cleared by C++ code
native readonly private array!int ActiveSequences;
native readonly private array!int CameraTextures;

native readonly float Time; // game time, in seconds
native readonly int TicTime; // game time, in tics (35 per second)

native readonly private msecnode_t *SectorList;
native readonly private msecnode_t *HeadSecNode;

// not really array of void pointers, and properly cleared by C++ code
native readonly private array!(void *) Translations;
native readonly private array!(void *) BodyQueueTransl;

native readonly state CallingState;
native readonly StateCall *StateCall;

native readonly private int NextSoundOriginID;

native readonly private void *__decanimlist;
native readonly private int __decanimuid;

// don't mark as native, so serializer will do the work for us
/*native*/ array!int sectorlinkStart; // can be less than sectors; indexed by sector index
/*native*/ array!SectorLink sectorlinks;

// not really array of void pointers, and properly cleared by C++ code
native transient array!(/*VLevelScriptThinker*/void *) scriptThinkers;

native transient private int csTouchCount;
native transient private int *csTouched; // for ChangeSector; Z_Malloc'ed, NumSectors elements

native transient private array!int FakeFCSectors;
native transient private array!int TaggedSectors;


// ////////////////////////////////////////////////////////////////////////// //
// natives
native final int GetLineIndex (line_t *line);

// use BSP to find sector where the given point lies
native final subsector_t *PointInSubsector (const TVec Point);
native final sector_t *PointInSector (const TVec Point);
// BSP trace
native final bool TraceLine (const TVec start, const TVec end, out TVec HitPoint, out TVec HitNormal);
// call this after sector height changed, to notify things
// crunch means "crush actors" (otherwise first unfitting actor will stop notifying)
// returns `false` if there was any unfitting actor
native final bool ChangeSector (sector_t *sector, int crunch);
// this is used to create ROR and various 3d structures
native final sec_region_t *AddExtraFloor (line_t *line, sector_t *dst);
// swap sector's floor and ceiling, it's used by level converter to support EDGE and Legacy 3D floors
native final void SwapPlanes (sector_t *s);

native final void SetFloorLightSector (sector_t *Sector, sector_t *SrcSector);
native final void SetCeilingLightSector (sector_t *Sector, sector_t *SrcSector);
native final void SetHeightSector (sector_t *Sector, sector_t *SrcSector, int Flags);

// return next sector # that line tag refers to
native final int FindSectorFromTag (int tag, optional int start);
native final line_t *FindLine (int lineTag, int *searchPosition);

// support for linked sectors
native final void SectorSetLink (int controltag, int tag, int surface, int movetype);


// ////////////////////////////////////////////////////////////////////////// //
// polyobj functions
native final void SpawnPolyobj (float x, float y, int tag, bool crush, bool hurt);
native final void AddPolyAnchorPoint (float x, float y, int tag);
native final polyobj_t *GetPolyobj (int polyNum);
native final int GetPolyobjMirror (int poly);
native final bool RotatePolyobj (int num, float angle);
native final bool MovePolyobj (int num, float x, float y, optional bool forced);


// ////////////////////////////////////////////////////////////////////////// //
// ACS functions
native final int StartACS (int number, int map, int arg1, int arg2, int arg3,
                           Entity activator, line_t *line, int side, bool Always, bool WantResult);
native final bool SuspendACS (int number, int map);
native final bool TerminateACS (int number, int map);
native final void StartTypedACScripts (int Type, int Arg1, int Arg2, int Arg3,
                                       Entity Activator, bool Always, bool RunNow);

native final bool RunACS (Entity activator, int script, int map, int s_arg1, int s_arg2, int s_arg3, int s_arg4);
native final bool RunACSAlways (Entity activator, int script, int map, int s_arg1, int s_arg2, int s_arg3, int s_arg4);
native final int RunACSWithResult (Entity activator, int script, int s_arg1, int s_arg2, int s_arg3, int s_arg4);

native final bool RunNamedACS (Entity activator, string script, int map, int s_arg1, int s_arg2, int s_arg3, int s_arg4);
native final bool RunNamedACSAlways (Entity activator, string script, int map, int s_arg1, int s_arg2, int s_arg3, int s_arg4);
native final int RunNamedACSWithResult (Entity activator, string script, int s_arg1, int s_arg2, int s_arg3, int s_arg4);

native final int SetBodyQueueTrans (int Slot, int Transl);


// ////////////////////////////////////////////////////////////////////////// //
// decal functions
native final void AddDecal (TVec org, name dectype, int side, line_t *li);
native final void AddDecalById (TVec org, int id, int side, line_t *li);


// ////////////////////////////////////////////////////////////////////////// //
// iterators
native final iterator AllThinkers (class!Thinker Class, out Thinker Thinker);
native final static iterator AllActivePlayers (out BasePlayer Player);


// ////////////////////////////////////////////////////////////////////////// //
// this moved to C++ code to make sound propagation on huge maps faster
native final void doRecursiveSound (int validcount, ref array!Entity elist, sector_t *sec,
                                    int soundblocks, Entity soundtarget, float maxdist, const TVec sndorigin);

// debug function
final int calcSecIdx (sector_t *sec) {
  if (!sec) return -1;
  return sec-&Sectors[0];
}


// ////////////////////////////////////////////////////////////////////////// //
void BeforeWorldTick (float DeltaTime) { /*print("BEFORE: %s", DeltaTime);*/ }
void AfterWorldTick (float DeltaTime) { /*print("AFTER: %s", DeltaTime);*/ }

// called after `OnMapSpawn()`, `ent` is never `none`
void OnEntitySpawned (Entity ent) {}

// called after entity was removed from lists, and marked for deletion; `ent` is never `none`
void OnEntityDying (Entity ent) {}

// this is called after LevelInfo handler when game is loaded (hub or savegame)
void AfterUnarchiveThinkers () {}


native int LdrTexNumForName (string texname, int Type, optional bool CMap, optional bool fromUDMF);

#include "LevelMapFixer.vc"


// ////////////////////////////////////////////////////////////////////////// //
// useful for variuos limiters
final void k8LimiterCleanup (class!Entity thc, int allowed, ref int counter, ref int deathCounter, optional bool debugmsg) {
  if (!thc) return;
  if (counter > allowed) {
    // remove old blood
    array!Entity elist;
    Entity e;
    foreach AllThinkers(thc, out e) elist[$] = e;
    if (elist.length < 1) return;
    if (allowed < 1) {
      if (debugmsg) print("REMOVING ALL blood entities out of %s (%s allowed)", elist.length, allowed);
      counter -= elist.length;
      deathCounter += elist.length;
      foreach (auto i; 0..elist.length) {
        //print("    KILLING %C (spawn time is %s)", elist[i], elist[i].SpawnTime);
        elist[i].Destroy();
      }
      return;
    }
    //print("  %s blood entities found", elist.length);
    if (elist.length > allowed) {
      elist.sort(delegate int (Entity a, Entity b) { float d = (a.SpawnTime-b.SpawnTime); return (d < 0 ? -1 : d > 0 ? 1 : 0); });
      // destroy half of list, from older
      int toremove = 2048;
      if (allowed <= 256) {
        toremove = elist.length/3;
      } else {
        /*if (toremove < elist.length/4)*/ toremove = elist.length/3;
        //if (toremove < 256) toremove = 256;
        if (allowed >= 3000 && toremove < 2048) toremove = 2048;
        toremove = min(toremove, elist.length);
      }
      if (elist.length-toremove > allowed) toremove = clamp(elist.length-allowed, 0, elist.length);
      if (toremove < 1) return;
      if (debugmsg) print("REMOVING %s blood entities out of %s (%s allowed)", toremove, elist.length, allowed);
      counter -= toremove;
      deathCounter += toremove;
      foreach (auto i; 0..toremove) {
        //print("    KILLING %C (spawn time is %s)", elist[i], elist[i].SpawnTime);
        elist[i].Destroy();
      }
      if (debugmsg) print("%s blood entities removed out of %s", deathCounter, elist.length);
    }
  }
}


final void k8LimiterUnarchiveThinkers (class!Entity thc, int allowed, ref int counter, ref int deathCounter, optional bool debugmsg) {
  int oldcounter = counter;
  counter = 0;
  Entity e;
  array!Entity elist;
  foreach AllThinkers(thc, out e) {
    //print("* FOUND %C", e);
    elist[$] = e;
  }
  counter = elist.length;
  if (debugmsg) print("*** LOADED (%C): counter=%s; skip=%s; counted=%s", thc, oldcounter, deathCounter, counter);
  deathCounter = 0;
  if (elist.length > allowed) {
    elist.sort(delegate int (Entity a, Entity b) { float d = (a.SpawnTime-b.SpawnTime); return (d < 0 ? -1 : d > 0 ? 1 : 0); });
    int toremove = elist.length-allowed;
    counter -= toremove;
    deathCounter += toremove;
    foreach (auto i; 0..toremove) {
      elist[i].Destroy();
    }
  }
}


defaultproperties {
}
