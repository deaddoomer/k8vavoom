//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
class Level : GameObject native;

const int MAX_LEVEL_TRANSLATIONS = 0xffff;
const int MAX_BODY_QUEUE_TRANSLATIONS = 0xff;

// script types
const int
  SCRIPT_Closed      = 0,
  SCRIPT_Open        = 1,
  SCRIPT_Respawn     = 2,
  SCRIPT_Death       = 3,
  SCRIPT_Enter       = 4,
  SCRIPT_Pickup      = 5,
  SCRIPT_BlueReturn  = 6,
  SCRIPT_RedReturn   = 7,
  SCRIPT_WhiteReturn = 8,
  SCRIPT_Lightning   = 12,
  SCRIPT_Unloading   = 13,
  SCRIPT_Disconnect  = 14,
  SCRIPT_Return      = 15;

struct StateCall {
  Entity Item;
  state State;
  ubyte Result;
};

struct SectorLink {
  int index;
  int mts; // bit 30: set if ceiling; low byte: movetype
  int next; // index, or -1
};

native readonly name MapName;
native readonly string MapHash;
native readonly string MapHashMD5;

// flags
native readonly private bool bForServer; // true if this level belongs to the server
native readonly bool bExtended; // true if level was in Hexen format
native readonly private bool bGLNodesV5; // true if using version 5 GL nodes
native readonly bool bTextMap; // UDMF format map

// MAP related Lookup tables.
// Store VERTEXES, LINEDEFS, SIDEDEFS, etc.

native TVec[] Vertexes;
native sector_t[] Sectors;
native side_t[] Sides;
native line_t[] Lines;
native readonly seg_t[] Segs;
native readonly subsector_t[] Subsectors;
native readonly private int/*node_t*/[] Nodes;

native readonly private void *VisData;
native readonly private void *NoVis;

// !!! Used only during level loading
native mthing_t[] Things;

native readonly private int BlockMapLumpSize;
native readonly private void *BlockMapLump;
native readonly private void *BlockMap;
native readonly private int BlockMapWidth;
native readonly private int BlockMapHeight;
native readonly private float BlockMapOrgX;
native readonly private float BlockMapOrgY;
native readonly private void *BlockLinks;
native readonly private void *PolyBlockMap;

native readonly private void *RejectMatrix;
native readonly private int RejectMatrixSize;

// strife conversations
native RogueConSpeech[] GenericSpeeches;
native RogueConSpeech[] LevelSpeeches;

// list of all poly-objects on the level
native readonly private int[] PolyObjs;
native readonly private int[] PolyAnchorPoints;

// sound environments for sector zones
native int[] Zones;

native readonly private Thinker ThinkerHead;
native readonly private Thinker ThinkerTail;

native readonly LevelInfo LevelInfo;
native readonly WorldInfo WorldInfo;

native readonly void *Acs;

native readonly private void *RenderData;
native readonly private void *NetContext;

native readonly private void *BaseLines;
native readonly private void *BaseSides;
native readonly private void *BaseSectors;
native readonly private void *BasePolyObjs;

native readonly private int[] StaticLights;

native readonly private array!int ActiveSequences;

native readonly private array!int CameraTextures;

native readonly float Time; // game time, in seconds
native readonly int TicTime; // game time, in tics (35 per second)

native readonly private void *SectorList;
native readonly private void *HeadSecNode;

native readonly private array!(void *) Translations;
native readonly private array!(void *) BodyQueueTransl;

native readonly state CallingState;
native readonly StateCall *StateCall;

native readonly private int NextSoundOriginID;

native readonly private void *__decanimlist;
native readonly private int __decanimuid;

native array!int sectorlinkStart; // can be less than sectors; indexed by sector index
native array!SectorLink sectorlinks;


// ////////////////////////////////////////////////////////////////////////// //
// natives
native final int GetLineIndex (line_t *line);

// use BSP to find sector where the given point lies
native final subsector_t *PointInSubsector (const TVec Point);
native final sector_t *PointInSector (const TVec Point);
// BSP trace
native final bool TraceLine (const TVec start, const TVec end, out TVec HitPoint, out TVec HitNormal);
// call this after sector height changed, to notify things
// crunch means "crush actors" (otherwise first unfitting actor will stop notifying)
// returns `false` if there was any unfitting actor
native final bool ChangeSector (sector_t *sector, int crunch);
// this is used to create ROR and various 3d structures
native final sec_region_t *AddExtraFloor (line_t *line, sector_t *dst);
// swap sector's floor and ceiling, it's used by level converter to support EDGE and Legacy 3D floors
native final void SwapPlanes (sector_t *s);

native final void SetFloorLightSector (sector_t *Sector, sector_t *SrcSector);
native final void SetCeilingLightSector (sector_t *Sector, sector_t *SrcSector);
native final void SetHeightSector (sector_t *Sector, sector_t *SrcSector, int Flags);

// return next sector # that line tag refers to
native final int FindSectorFromTag (int tag, int start);
native final line_t *FindLine (int lineTag, int *searchPosition);

// support for linked sectors
native final void SectorSetLink (int controltag, int tag, int surface, int movetype);


// ////////////////////////////////////////////////////////////////////////// //
// polyobj functions
native final void SpawnPolyobj (float x, float y, int tag, bool crush, bool hurt);
native final void AddPolyAnchorPoint (float x, float y, int tag);
native final polyobj_t *GetPolyobj (int polyNum);
native final int GetPolyobjMirror (int poly);
native final bool RotatePolyobj (int num, float angle);
native final bool MovePolyobj (int num, float x, float y);


// ////////////////////////////////////////////////////////////////////////// //
// ACS functions
native final int StartACS (int number, int map, int arg1, int arg2, int arg3,
                           Entity activator, line_t *line, int side, bool Always, bool WantResult);
native final bool SuspendACS (int number, int map);
native final bool TerminateACS (int number, int map);
native final void StartTypedACScripts (int Type, int Arg1, int Arg2, int Arg3,
                                       Entity Activator, bool Always, bool RunNow);

native final bool RunACS (Entity activator, int script, int map, int s_arg1, int s_arg2, int s_arg3, int s_arg4);
native final bool RunACSAlways (Entity activator, int script, int map, int s_arg1, int s_arg2, int s_arg3, int s_arg4);
native final int RunACSWithResult (Entity activator, int script, int s_arg1, int s_arg2, int s_arg3, int s_arg4);

native final bool RunNamedACS (Entity activator, string script, int map, int s_arg1, int s_arg2, int s_arg3, int s_arg4);
native final bool RunNamedACSAlways (Entity activator, string script, int map, int s_arg1, int s_arg2, int s_arg3, int s_arg4);
native final int RunNamedACSWithResult (Entity activator, string script, int s_arg1, int s_arg2, int s_arg3, int s_arg4);

native final int SetBodyQueueTrans (int Slot, int Transl);


// ////////////////////////////////////////////////////////////////////////// //
// decal functions
native final void AddDecal (TVec org, name dectype, int side, line_t *li);
native final void AddDecalById (TVec org, int id, int side, line_t *li);


// ////////////////////////////////////////////////////////////////////////// //
// this moved to C++ code to make sound propagation on huge maps faster
native final void doRecursiveSound (int validcount, ref array!Entity elist, sector_t *sec,
                                    int soundblocks, Entity soundtarget, float maxdist, const TVec sndorigin);

// debug function
final int calcSecIdx (sector_t *sec) {
  if (!sec) return -1;
  return sec-&Sectors[0];
}


// ////////////////////////////////////////////////////////////////////////// //
void BeforeWorldTick (float DeltaTime) { /*print("BEFORE: %s", DeltaTime);*/ }
void AfterWorldTick (float DeltaTime) { /*print("AFTER: %s", DeltaTime);*/ }

// called after `OnMapSpawn()`, `ent` is never `none`
void OnEntitySpawned (Entity ent) {}

// called after entity was removed from lists, and marked for deletion; `ent` is never `none`
void OnEntityDying (Entity ent) {}


defaultproperties {
}
