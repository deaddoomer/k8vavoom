//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//
//  Extended player object info
//
//**************************************************************************
class BasePlayer : GameObject native abstract;

// constants for FixedColourmap
enum {
  NUMCOLOURMAPS    = 32,
  INVERSECOLOURMAP = 32,
  GOLDCOLOURMAP    = 33,
  REDCOLOURMAP     = 34,
  GREENCOLOURMAP   = 35,
};

const float TOCENTRE = -128.0;

struct VViewState {
  state State; // a 0 state means not active
  float StateTime;
  float SX;
  float SY;
};

readonly LevelInfo Level;

readonly bool bActive;
readonly bool bSpawned;
readonly bool bIsBot;
bool bFixAngle;
bool bAttackDown; // `true` if button down last tic
bool bUseDown;
bool bDidSecret; // `true` if secret level has been done
readonly private bool bCentreing;
readonly bool bIsClient; // player on client side
bool bAutomapRevealed;
bool bAutomapShowThings;
bool bReloadQueued; // true if "reload" was pressed

native readonly private void *Net;

string UserInfo;

string PlayerName;
ubyte BaseClass;
ubyte PClass; // player class type
ubyte TranslStart;
ubyte TranslEnd;
int Colour;

float ClientForwardMove; // *2048 for move
float ClientSideMove; // *2048 for move
float ForwardMove; // *2048 for move
float SideMove; // *2048 for move
float FlyMove; // fly up/down/centreing
/*ubyte*/transient int Buttons; // fire, use
/*ubyte*/transient int Impulse; // weapon changes, inventory, etc
// for ACS, see C++ code
transient readonly int AcsCurrButtonsPressed;
transient readonly int AcsCurrButtons;
transient readonly int AcsButtons;
transient readonly int OldButtons;
transient readonly float AcsNextButtonUpdate;
transient readonly float AcsPrevMouseX, AcsPrevMouseY; // previous ACS mouse movement
transient readonly float AcsMouseX, AcsMouseY; // current ACS mouse movement

Entity MO;
Entity Camera;
int PlayerState;

// determine POV, including viewpoint bobbing during movement
// focal origin above r.z
TVec ViewOrg;

TAVec ViewAngles;

// this is only used between levels,
// mo->health is used during levels.
int Health;

// frags, kills of other players
int Frags;
int Deaths;

// for intermission stats
int KillCount;
int ItemCount;
int SecretCount;

// so gun flashes light up areas
ubyte ExtraLight;

// for lite-amp and invulnarability powers
ubyte FixedColourmap;

// colour shifts for damage, powerups and content types
int CShift;

// overlay view sprites (gun, etc)
VViewState ViewStates[NUMPSPRITES];
int DispSpriteFrame[NUMPSPRITES];
name DispSpriteName[NUMPSPRITES];
float PSpriteSY;

float WorldTimer; // total time the player's been playing

native readonly ubyte ClientNum;

int SoundEnvironment;

native readonly ClientGameBase ClGame; // valid only on client side

PlayerReplicationInfo playerReplicationInfo;


replication {
  reliable if (!bIsClient)
    Health, Frags, Deaths, ExtraLight, FixedColourmap, CShift,
    PSpriteSY, KillCount, ItemCount, SecretCount,
    ViewStates, DispSpriteFrame, DispSpriteName,
    ClientNum, WorldTimer, MO, Camera, bAutomapRevealed,
    bAutomapShowThings, SoundEnvironment, bAttackDown, bReloadQueued;

  unreliable if (!bIsClient)
    ClientStartSound, ClientStopSound, ClientSetViewOrg;

  reliable if (!bIsClient)
    ClientStartSequence, ClientAddSequenceChoice, ClientStopSequence,
    ClientPrint, ClientCentrePrint, ClientSetAngles, ClientIntermission,
    ClientPause, ClientSkipIntermission, ClientFinale, ClientChangeMusic,
    ClientSetServerInfo, ClientHudMessage;

  // movement variables
  reliable if (bIsClient)
    ViewAngles, ClientForwardMove, ClientSideMove, FlyMove, Buttons;

  // methods client can execute on server
  reliable if (bIsClient)
    ServerImpulse, ServerSetUserInfo;
}


// print to client
native final void cprint (string format, ...) [printf,1];
// client's centre message
native final void centreprint (string format, ...) [printf,1];
alias centerprint = centreprint;
native final int GetPlayerNum ();
native final void ClearPlayer ();

native final void SetViewObject (Object vobj);
native final void SetViewObjectIfNone (Object vobj);
native final void SetViewState (int position, state stnum);
native final void AdvanceViewStates (float deltaTime);
native final void DisconnectBot ();

// for networking
// OriginId==-666: local (use player's SoundOriginID)
native void ClientStartSound (int SoundId, TVec Org, int OriginId,
                              int Channel, float Volume, float Attenuation, bool Loop);
native void ClientStopSound (int OriginId, int Channel);
native void ClientStartSequence (TVec Origin, int OriginId, name Name, int ModeNum);
native void ClientAddSequenceChoice (int OriginId, name Choice);
native void ClientStopSequence (int OriginId);
native void ClientPrint (string Str);
native void ClientCentrePrint (string Str);
native void ClientSetAngles (TAVec Angles);
native void ClientIntermission (name NextMap);
native void ClientPause (bool Paused);
native void ClientSkipIntermission ();
native void ClientFinale (string Type);
native void ClientChangeMusic (name Song);
native void ClientSetServerInfo (string Key, string Value);
native void ClientHudMessage (string Message, name Font, int Type, int Id,
                              int Colour, string ColourName, float x, float y,
                              int HudWidth, int HudHeight, float HoldTime,
                              float Time1, float Time2);

native void ServerSetUserInfo (string Info);


//==========================================================================
//
//  PutClientIntoServer
//
//==========================================================================
void PutClientIntoServer () {
}


//==========================================================================
//
//  SpawnClient
//
//==========================================================================
void SpawnClient () {
}


//==========================================================================
//
//  NetGameReborn
//
//==========================================================================
void NetGameReborn () {
}


//==========================================================================
//
//  DisconnectClient
//
//==========================================================================
void DisconnectClient () {
}


//==========================================================================
//
//  UserinfoChanged
//
//==========================================================================
void UserinfoChanged () {
}


//==========================================================================
//
//  PlayerBeforeExitMap
//
//==========================================================================
void PlayerBeforeExitMap () {
}


//==========================================================================
//
//  PlayerExitMap
//
//==========================================================================
void PlayerExitMap (bool clusterChange) {
}


//==========================================================================
//
//  PlayerTick
//
//==========================================================================
void PlayerTick (float deltaTime) {
}


//==========================================================================
//
//  ClientTick
//
//==========================================================================
void ClientTick (float deltaTime) {
}


//==========================================================================
//
//  SetViewPos
//
//==========================================================================
void SetViewPos () {
}


//==========================================================================
//
//  PreTravel
//
//==========================================================================
void PreTravel () {
}


//==========================================================================
//
//  UseInventory
//
//==========================================================================
void UseInventory (string Inv) {
}


//==========================================================================
//
//  CheckDoubleFiringSpeed
//
//==========================================================================
bool CheckDoubleFiringSpeed () {
  return false;
}


//==========================================================================
//
//  ServerImpulse
//
//==========================================================================
void ServerImpulse (int AImpulse) {
  Impulse = AImpulse;
}


//==========================================================================
//
//  ClientSetViewOrg
//
//==========================================================================
void ClientSetViewOrg (float x, float y, float z) {
  ViewOrg = vector(x, y, z);
}


//==========================================================================
//
//  eventGetReadyWeapon
//
//==========================================================================
Entity eventGetReadyWeapon () {
  return none;
}


// ////////////////////////////////////////////////////////////////////////// //
// various cheat commands
// TODO: generalize this (make some way to register console commands from scripts)
void Cheat_God () {}
void Cheat_Buddha () {}
void Cheat_Summon () {}
void Cheat_NoClip () {}
void Cheat_Gimme () {}
void Cheat_KillAll () {}
void Cheat_Morph () {}
void Cheat_NoWeapons () {}
void Cheat_Class () {}
void Cheat_Fly () {}
void Cheat_NoTarget () {}
void Cheat_Anubis () {}
void Cheat_Freeze () {}
void Cheat_Jumper () {}
void Cheat_ShooterKing () {}
void Cheat_Regeneration () {}
void Cheat_DumpInventory () {}
void Cheat_VScriptCommand (ref array!string args) {}


defaultproperties {
}
