//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//
//  Base class of all classes
//
//==========================================================================
class Object native abstract transient;

#include "Object_common.vc"
#ifdef VCC_STANDALONE_EXECUTOR
# include "vccrun/Object_vccrun.vc"
#else
# include "Object_vavoom.vc"
#endif


defaultproperties {
}


// ////////////////////////////////////////////////////////////////////////// //
// Micropather A-Star solver interface
// ////////////////////////////////////////////////////////////////////////// //

class MiAStarNodeBase : Object;

defaultproperties {
}


// ////////////////////////////////////////////////////////////////////////// //
class MiAStarGraphBase : Object native abstract;

native readonly private transient void *__intr;
native readonly private transient void *__pather;
native readonly private transient void *__adjarray;

float pathCost; // valid after successfull solution

// default values for micropather
int initParam_PoolSize = 250;
int initParam_TypicalAdjacent = 8;
int initParam_CachePathes = true;

//native override void Destroy ();

// usually pathfinder is initialised on the first call to `Solve*()`.
// after that, there is no sense in changing defaults.
native final bool IsInitialized ();

// this must be used in `AdjacentCost()`, to push all neighbours.
native final void PushAdjacentCost (MiAStarNodeBase node, float cost);

// two abstract methods, must be overriden
/*
  Return the least possible cost between 2 states. For example, if your pathfinding
  is based on distance, this is simply the straight distance between 2 points on the
  map. If you pathfinding is based on minimum time, it is the minimal travel time
  between 2 points given the best possible terrain.
*/
native float LeastCostEstimate (MiAStarNodeBase start, MiAStarNodeBase end);

/*
  Return the exact cost from the given state to all its neighboring states. This
  may be called multiple times, or cached by the solver. It *must* return the same
  exact values for every call to MicroPather::Solve(). It should generally be a simple,
  fast function with no callbacks into the pather.

  Push all neighbours with `PushAdjacentCost()`.
*/
native void AdjacentCost (MiAStarNodeBase node);

// used to clear current solved path
native final void PathArrayClear ();
// used to retrieve solved path after calling `Solve()`
native final int PathArrayLength ();
native final MiAStarNodeBase PathArrayNode (int index);
// force-push node to path array
native final void PathArrayPushNode (MiAStarNodeBase node);

// used to clear current near nodes list
native final void NearArrayClear ();
// used to retrieve solved path after calling `SolveForNearStates()`
native final int NearArrayLength ();
native final MiAStarNodeBase NearArrayNode (int index);
native final MiAStarNodeBase NearArrayNodeAndCost (int index, out float cost);
// force-push node to near array
native final void NearArrayPushNode (MiAStarNodeBase node, float cost);

/*
  Solve for the path from start to end.

  startState -- the starting state for the path.
  endState   -- the ending state for the path.

  Outputs solution that can be retrieved with `PathArrayXXX()` methods.
  Also puts cost to `pathCost`.
  Returns `true` if solution was found.

  if start and end states are the same, creates path from one state, with zero cost.
*/
native final bool Solve (MiAStarNodeBase startState, MiAStarNodeBase endState);

/*
  Find all the states within a given cost from startState.

  startState -- the starting state for the path.
  maxCost    -- the maximum cost that will be returned.
                Higher values return larger 'near' sets and take more time to compute.

  Outputs solution that can be retrieved with `NearArrayXXX()` methods.
  Returns success or failure.
*/
native final bool SolveForNearStates (MiAStarNodeBase startState, float maxCost);

/* Should be called whenever the cost between states or the connection between states changes.
  Also frees overhead memory used by MicroPather, and calling will free excess memory.
*/
native final void Reset ();


defaultproperties {
}
