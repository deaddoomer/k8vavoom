//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2021 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//
//  Base class of all classes
//
//==========================================================================
class Object native abstract transient;

//**************************************************************************
//
//  common Object things, shared between VaVoom and vccrun
//
//==========================================================================
// [internal] fields won't be touched by initialization (and other object copying duties)
// don't use the following fields
native readonly private transient [internal] void *__CxxVTable;
native readonly private transient [internal] void *__VTable;
native readonly private transient [internal] int __ObjectIndex;
native readonly protected transient [internal] int __ObjectUniqueId;
native readonly private transient [internal] int __ObjectFlags;
// object class
native readonly transient [internal] class Class;

native void Destroy ();
native final bool IsA (name CheckName);
//native final bool IsDestroyed (); // checks "delayed destroy" flag; converted to built-in property
native static final void GC_CollectGarbage (optional bool destroyDelayed);
native static final int GC_AliveObjects { get; }
native static final int GC_LastCollectedObjects { get; }
native static final float GC_LastCollectDuration { get; } // in seconds
native static final float GC_LastCollectTime { get; } // in seconds
native static final bool GC_MessagesAllowed { get; set; }

final int UniqueId { get { return __ObjectUniqueId; } }

#include "RTTI.vc"


//**************************************************************************
// not needed anymore (you can use `int.min` and `int.max`)
const int MININT = 0x80000000;
const int MAXINT = 0x7fffffff;


//==========================================================================
//
//  3D math - vectors and planes
//
//==========================================================================
// sadly, `TVec` currently cannot have any methods, because it is a special struct
vector TVec {
  float x;
  float y;
  float z;

  native bool isZero () const;
  native bool isZero2D () const;

  native TVec ClosestPointOnBox3D (const TVec bmin, const TVec bmax) const;
  native TVec ClosestPointOnDoomBox3D (const TVec origin, const float radius, const float height) const;
  native TVec ClosestPointOnBox2D (const TVec bmin, const TVec bmax) const;
  native TVec ClosestPointOnDoomBox2D (const TVec origin, const float radius) const;
  native float Box3DDistanceSquared (const TVec bmin, const TVec bmax) const;
  native float DoomBox3DDistanceSquared (const TVec origin, const float radius, const float height) const;
  native float Box2DDistanceSquared (const TVec bmin, const TVec bmax) const;
  native float DoomBox2DDistanceSquared (const TVec origin, const float radius) const;
};


vector TAVec {
  float pitch;
  float yaw;
  float roll;
};


struct TPlane {
  TVec normal;
  float dist;

  native float PointDistance (const TVec p) const;
  // initialises vertical plane from point and direction
  native void SetPointDirXY (const TVec point, const TVec dir);
  // initialises vertical plane from 2 points
  native void Set2Points (const TVec v1, const TVec v2);
  // initialises "full" plane from point and direction
  // `norm` must be normalized, both vectors must be valid
  native void SetPointNormal3D (const TVec point, const TVec norm);
  // initialises "full" plane from point and direction (direction will be normalised)
  native void SetPointNormal3DSafe (const TVec point, const TVec dir);
  // the normal will point out of the clock for clockwise ordered points
  native void SetFromTriangle (const TVec a, const TVec b, const TVec c);
  native bool isFloor () const;
  native bool isCeiling () const;
  native bool isSlope () const;
  // valid only for horizontal planes!
  native float GetRealDist () const;
  // WARNING! do not call this repeatedly, or on normalized plane!
  //          due to floating math inexactness, you will accumulate errors.
  native void NormaliseInPlace ();
  native void FlipInPlace ();
  // returns intersection time (or -1 if there is no intersection)
  // negative means "no intersection" (and `*currhit` is not modified)
  // yeah, we have too many of those
  // this one is used in various plane checks in the engine (it happened so historically)
  native float IntersectionTime (const TVec linestart, const TVec lineend, optional out TVec currhit) const;
  // some other intersection methods, for infinite lines
  // intersection time; [0..1] is for the actual line segment
  // returns +INF for coplanar lines (check with res.isfinite)
  // time is from `p0`
  native float LineIntersectTime (const TVec p0, const TVec p1, optional const float eps/*=0*/) const;
  // returns intersection point; that point must be out of line segment
  // returns invalid vector (infinite) for coplanar lines (res.x.isfinite)
  // time is from `p0`
  native TVec LineIntersect (const TVec p0, const TVec p1, optional const float eps/*=0*/) const;
  // this adds `shift` to plane distance
  native float LineIntersectTimeWithShift (const TVec p0, const TVec p1, const float shift, optional const float eps/*=0*/) const;
  native float GetPointZ (const TVec v) const;
  native float GetPointZRev (const TVec v) const;
  native TVec Project (const TVec v) const;
  // intersection of 3 planes
  // returns invalid vector if there is no intersection (check with `res.x.isNaN`)
  native TVec IntersectionPoint (const ref TPlane plane2, const ref TPlane plane3) const;
  // sphere sweep test; if `true` (hit), `hitpos` will be sphere position when it hits this plane, and `u` will be normalized collision time
  native bool SweepSphere (const TVec origin, const float radius, const TVec amove, optional out TVec hitpos, optional out float u) const;
  // box must be valid
  // `time` will be set only if our box hits/penetrates the plane
  // if the box is initially stuck, time will be negative
  // `bbox` are bounding box *coordinates*
  // returns `true` on hit/stuck
  native bool SweepBox3D (const TVec bmin, const TVec bmax, const TVec vdelta, optional out float time, optional out TVec hitpoint) const;
  native bool SweepDoomBox3D (const TVec origin, const float radius, const float height, const TVec vdelta, optional out float time, optional out TVec hitpoint) const;
  // box must be valid
  // `time` will be set only if our box hits/penetrates the plane
  // negative time means "stuck" (and it will be exit time)
  // `vstart` and `vend` are for bounding box center point
  // returns `true` on hit/stuck
  native bool SweepBox3DEx (const float radius, const float height, const TVec vstart, const TVec vend, optional out float time, optional out TVec hitpoint) const;
  // returns side 0 (front) or 1 (back, or on plane)
  native int PointOnSide (const TVec point) const;
  // returns side 0 (front), 1 (back), or 2 (on)
  native int PointOnSide2 (const TVec point) const;
  // returns side 0 (front), 1 (back)
  // if at least some part of the sphere is on a front side, it means "front"
  native int SphereOnSide (const TVec center, float radius) const;
  native bool SphereTouches (const TVec center, float radius) const;
  // returns side 0 (front), 1 (back), or 2 (collides)
  native int SphereOnSide2 (const TVec center, float radius) const;
  // returns `false` if the box fully is on the back side of the plane
  native bool checkBox3D (const TVec bmin, const TVec bmax) const;
  // returns `false` if the box fully is on the back side of the plane
  // returns `true` for non-vertical planes (because our box is 2d)
  native bool checkBox2D (const TVec bmin, const TVec bmax) const;
  // returns `false` if the box fully is on the back side of the plane
  native bool checkDoomBox3D (const TVec origin, const float radius, const float height) const;
  // returns `false` if the box fully is on the back side of the plane
  // returns `true` for non-vertical planes (because our box is 2d)
  native bool checkDoomBox2D (const TVec origin, const float radius) const;
  // returns side 0 (front), 1 (back), or 2 (collides)
  // if the box is touching the plane from the front, it is still assumed to be in front
  native int Box3DOnSide2 (const TVec bmin, const TVec bmax) const;
  // returns side 0 (front), 1 (back), or 2 (collides)
  // if the box is touching the plane from the front, it is still assumed to be in front
  native int DoomBox3DOnSide2 (const TVec origin, const float radius, const float height) const;
  // returns side 0 (front), 1 (back), or 2 (collides)
  // if the box is touching the plane from the front, it is still assumed to be in front
  // returns 2 for non-vertical planes (because our box is 2d)
  native int Box2DOnSide2 (const TVec bmin, const TVec bmax) const;
  // returns side 0 (front), 1 (back), or 2 (collides)
  // if the box is touching the plane from the front, it is still assumed to be in front
  // returns 2 for non-vertical planes (because our box is 2d)
  native int DoomBox2DOnSide2 (const TVec origin, const float radius) const;

  native TVec GetBox2DAcceptPoint (const TVec bmin, const TVec bmax);
  native TVec GetBox3DAcceptPoint (const TVec bmin, const TVec bmax);
  native TVec GetDoomBox2DAcceptPoint (const TVec origin, const float radius, const float height);
  native TVec GetDoomBox3DAcceptPoint (const TVec origin, const float radius);

  native TVec GetBox2DRejectPoint (const TVec bmin, const TVec bmax);
  native TVec GetBox3DRejectPoint (const TVec bmin, const TVec bmax);
  native TVec GetDoomBox2DRejectPoint (const TVec origin, const float radius, const float height);
  native TVec GetDoomBox3DRejectPoint (const TVec origin, const float radius);
};


//**************************************************************************
// Keys and buttons
enum {
  K_ESCAPE = 27,
  K_ENTER = 13,
  K_TAB = 9,
  K_BACKSPACE = 8,

  K_SPACE = 32,

  K_N0 = 48, K_N1, K_N2, K_N3, K_N4, K_N5, K_N6, K_N7, K_N8, K_N9,

  K_a = 97, K_b, K_c, K_d, K_e, K_f,  K_g, K_h, K_i, K_j, K_k, K_l,
  K_m, K_n, K_o, K_p, K_q, K_r, K_s, K_t, K_u, K_v, K_w, K_x, K_y, K_z,

  K_FIRST_CONTROL_KEYCODE = 0x80,

  K_UPARROW = 0x80, K_LEFTARROW, K_RIGHTARROW, K_DOWNARROW,
  K_INSERT, K_DELETE, K_HOME, K_END, K_PAGEUP, K_PAGEDOWN,

  K_PAD0, K_PAD1, K_PAD2, K_PAD3, K_PAD4, K_PAD5, K_PAD6, K_PAD7, K_PAD8, K_PAD9,

  K_NUMLOCK,
  K_PADDIVIDE, K_PADMULTIPLE,
  K_PADMINUS, K_PADPLUS,
  K_PADENTER, K_PADDOT,

  K_CAPSLOCK,
  K_BACKQUOTE,

  K_F1, K_F2, K_F3, K_F4, K_F5, K_F6, K_F7, K_F8, K_F9, K_F10, K_F11, K_F12,

  K_LSHIFT, K_RSHIFT,
  K_LCTRL, K_RCTRL,
  K_LALT, K_RALT,

  K_LWIN, K_RWIN,
  K_MENU,

  K_PRINTSCRN,
  K_SCROLLLOCK,
  K_PAUSE,

  // mouse
  K_MOUSE1, // left
  K_MOUSE2, // right
  K_MOUSE3, // middle
  K_MOUSE4, // x1
  K_MOUSE5, // x2
  K_MOUSE6, K_MOUSE7, K_MOUSE8, K_MOUSE9,
  K_MWHEELUP, K_MWHEELDOWN,

  // joysticks
  K_JOY1, K_JOY2, K_JOY3, K_JOY4, K_JOY5, K_JOY6, K_JOY7, K_JOY8, K_JOY9,
  K_JOY10, K_JOY11, K_JOY12, K_JOY13, K_JOY14, K_JOY15, K_JOY16,

  // controllers
  K_AXIS_LEFTX, K_AXIS_LEFTY,
  K_AXIS_RIGHTX, K_AXIS_RIGHTY,
  K_AXIS_TRIGGERLEFT, K_AXIS_TRIGGERRIGHT,

  K_BUTTON_A, K_BUTTON_B,
  K_BUTTON_X, K_BUTTON_Y,
  K_BUTTON_BACK, K_BUTTON_GUIDE, K_BUTTON_START,
  K_BUTTON_LEFTSTICK, K_BUTTON_RIGHTSTICK,
  K_BUTTON_LEFTSHOULDER, K_BUTTON_RIGHTSHOULDER,
  K_BUTTON_DPAD_UP, K_BUTTON_DPAD_DOWN,
  K_BUTTON_DPAD_LEFT, K_BUTTON_DPAD_RIGHT,
  K_BUTTON_TRIGGER_LEFT, K_BUTTON_TRIGGER_RIGHT,

  // intervals
  K_MOUSE_FIRST = K_MOUSE1,
  K_MOUSE_LAST = K_MWHEELDOWN,

  K_MOUSE_BUTTON_FIRST = K_MOUSE1,
  K_MOUSE_BUTTON_LAST = K_MOUSE9,

  K_JOY_FIRST = K_JOY1,
  K_JOY_LAST = K_JOY16,

  K_CONTROLLER_FIRST = K_AXIS_LEFTX,
  K_CONTROLLER_LAST = K_BUTTON_TRIGGER_RIGHT,

  K_CONTROLLER_AXIS_FIRST = K_AXIS_LEFTX,
  K_CONTROLLER_AXIS_LAST = K_AXIS_TRIGGERRIGHT,

  K_CONTROLLER_BUTTON_FIRST = K_BUTTON_A,
  K_CONTROLLER_BUTTON_LAST = K_BUTTON_TRIGGER_RIGHT,
};


// [input] event types
enum {
  ev_keydown,
  ev_keyup,
  ev_mouse, // "mouse moved" event, with deltas in `dx`/`dy`
  ev_joystick,
  ev_click, // click or doubleclick (see `clickcnt`); keycode is K_MOUSEn; `x` and `y` holds widget-local coords
  ev_enter, // mouse enters the widget; `x` and `y` holds widget-local coords
  ev_leave, // mouse leaves the widget; `x` and `y` holds widget-local coords
  // extended events
  ev_uimouse, // "mouse moved" event, with actual coords in `x`/`y` (widget-locals)
  ev_winfocus,
  // only for vccrun
  ev_timer, // data1: timer id
  ev_closequery,
  // socket library
  ev_socket, // see below
  // sent when resolution changed; no data
  ev_resolution,
  // this event will be broadcased to all widgets
  // it cannot be canceled or consumed, and all modifications will be reverted
  // note that is will be broadcasted to disabled and invisible widgets too
  ev_broadcast,
  // for neoUI library
  ev_neoui = 69,
  ev_user = 666,
};


// all events except `evsock_sqempty` and `evsock_error` must be either eaten, or cancelled, or
// socked will be destroyed
enum {
  evsock_connected,
  evsock_disconnected, // autodestruct
  evsock_cantconnect, // autodestruct
  evsock_gotdata, // received some data
  evsock_sqempty, // sent queue is empty (generated when all queued data was sent)
  evsock_gotclient, // new connection comes for listening sockets
  evsock_error, // some error occured, socket will be destroyed after dispatching this message
  evsock_timeout, // timeout, socket will be destroyed after dispatching this message
}

/*
  ev_socket event:
    data1: subevent type
    data2: socket id
    data3: socketid for "gotclient"

  if you will not "eat" "gotdata" event, socket will be closed
  if you will not send data or ping socket, nothing will happen until timeout

  if you will not accept "gotclient" event, client socket will be closed
 */


// event structure
struct event_t {
  int type;  // event type
  int data1; // keys / mouse / joystick buttons
  int data2; // mouse / joystick x move
  int data3; // mouse / joystick y move
  int data4; // joystick index (modern controllers usually have two analog sticks)
  //int flags; // EFlag.XXX bitset
  bool eaten;
  bool cancelled;
  bool bubbling;
  bool deleteObj; // new UI dispatcher should delete `obj`
  // for new UI
  Object obj; // usually `none`, can be used as event source
  Object dest; // usually `none`, used as "destination widget" in UI system
  // for key
  alias keycode = data1;
  // for ev_mouse/ev_joystick
  alias dx = data2;
  alias dy = data3;
  // for ev_joystick
  alias joyidx = data4; // 0 or 1
  // for ev_mouse
  alias msx = data1;
  alias msy = data4;
  // for ev_uimouse, mouse button down/up
  alias x = data2;
  alias y = data3;
  // for focus
  alias focused = data1;
  // for timer
  alias timerid = data1;
  // for socket
  alias sockev = data1;
  alias sockid = data2;
  alias sockdata = data3;
  // for ev_click
  alias clickcnt = data4;
  // modifiers/buttons state
  // modifiers state changed *after* processing an even
  // i.e. if `K_?CTRL` is pressed, the flag will be set after calling `onEvent()`,
  // and if `K_?CTRL` is released, the flag will be reset after calling `onEvent()`
  bool bCtrl; // any
  bool bAlt; // any
  bool bShift; // any
  bool bHyper; // any
  bool bLMB;
  bool bMMB;
  bool bRMB;
  bool bCtrlLeft;
  bool bAltLeft;
  bool bShiftLeft;
  bool bCtrlRight;
  bool bAltRight;
  bool bShiftRight;

  native void clear ();
  alias Clear = clear;

  native bool isAnyMouse () const;
  alias IsAnyMouse = isAnyMouse;

  // default is both press and release
  native bool isMouseButton (optional bool down/*=undefined*/) const;
  alias IsMouseButton = isMouseButton;
};

static final void EventClear (ref event_t evt) { evt.clear(); }
static final bool EventIsAnyMouse (ref event_t evt) { return evt.isAnyMouse(); }
// default is both press and release
static final bool EventIsMouseButton (ref event_t evt, optional bool down/*=undefined*/) { return evt.isMouseButton(down!optional); }


bitenum ModMask {
  Empty = none,
  Ctrl,
  Alt,
  Shift,
  Hyper,
  LMB,
  MMB,
  RMB,
  CtrlLeft,
  AltLeft,
  ShiftLeft,
  CtrlRight,
  AltRight,
  ShiftRight,
}

#ifndef VC_COMPILER_TEST
static final ModMask eventBuildModMask (const ref event_t evt) {
  ModMask res = ModMask.Empty;
  if (evt.bCtrl) res |= ModMask.Ctrl;
  if (evt.bAlt) res |= ModMask.Alt;
  if (evt.bShift) res |= ModMask.Shift;
  if (evt.bHyper) res |= ModMask.Hyper;
  if (evt.bLMB) res |= ModMask.LMB;
  if (evt.bMMB) res |= ModMask.MMB;
  if (evt.bRMB) res |= ModMask.RMB;
  if (evt.bCtrlLeft) res |= ModMask.CtrlLeft;
  if (evt.bAltLeft) res |= ModMask.AltLeft;
  if (evt.bShiftLeft) res |= ModMask.ShiftLeft;
  if (evt.bCtrlRight) res |= ModMask.CtrlRight;
  if (evt.bAltRight) res |= ModMask.AltRight;
  if (evt.bShiftRight) res |= ModMask.ShiftRight;
  return res;
}
#endif

native static final string GetInputKeyStrName (int kcode);
native static final int GetInputKeyCode (string kname);


// returns `false` if queue is full
// add event to the bottom of the current queue
// it is unspecified if posted event will be processed in the current
// frame, or in the next one
native static final bool PostEvent (const ref event_t ev);

// returns `false` if queue is full
// add event to the top of the current queue
// it is unspecified if posted event will be processed in the current
// frame, or in the next one
native static final bool InsertEvent (const ref event_t ev);

// check if event queue has any unprocessed events
// returns number of events in queue or 0
// it is unspecified if unprocessed events will be processed in the current
// frame, or in the next one
native static final int CountQueuedEvents ();

// peek event from queue
// event with index 0 is the top one
native static final bool PeekEvent (int idx, out event_t ev);

// get top event from queue
// returns `false` if there are no more events
native static final bool GetEvent (out event_t ev);

// returns maximum size of event queue
// note that event queue may be longer that the returned value
native static final int GetEventQueueSize ();


//==========================================================================
//
//              COMMON BUILTINS
//
//==========================================================================

// ////////////////////////////////////////////////////////////////////////// //
// error functions

// shutdown client and server, go to title
native static final void Error (string format, ...) [printf,1];
// abort with error
native static final void FatalError (string format, ...) [printf,1];
// this is called when assertion failed
native static final void AssertError (string message);


// ////////////////////////////////////////////////////////////////////////// //
// math functions (angles are in degrees)

native static final int roundi (float v) [builtin RoundF2I];
native static final float fround (float v) [builtin RoundF2F];
native static final int trunci (float v) [builtin TruncF2I];
native static final float ftrunc (float v) [builtin TruncF2F];
native static final float fceil (float v) [builtin FloatCeil];
native static final float ffloor (float v) [builtin FloatFloor];
//native static final float frac (float v) [builtin FloatFrac];
//native static final float fint (float v) [builtin FloatInt];

// linear interpolation between `a` and `b`; `delta` should be in [0..1]
native static final float flerp (float a, float b, float delta) [builtin FloatLerp];
// this will round the result
native static final int lerp (int a, int b, float delta) [builtin IntLerp];

// interpolate between p2 and p3 along a Catmull-Rom spline; `delta` should be in [0..1]
// http://research.microsoft.com/~hollasch/cgindex/curves/catmull-rom.html
final static float slerp (float p1, float p2, float p3, float p4, float delta) {
  float t = delta;
  float res = 2.0*p2;
  res += (p3-p1)*delta;
  t *= delta;
  res += (2.0*p1-5.0*p2+4.0*p3-p4)*t;
  t *= delta;
  res += (3.0*p2-3.0*p3+p4-p1)*t;
  return 0.5*res;
}

// `smoothstep` performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1
// results are undefined if edge0 >= edge1
native static final float smoothstep (float edge0, float edge1, float x) [builtin FloatSmoothStep];
native static final float smoothstepPerlin (float edge0, float edge1, float x) [builtin FloatSmoothStepPerlin];

native static final float AngleMod360 (float angle); // normalises angle in range 0..360
native static final float AngleMod180 (float angle); // normalises angle in range -180..180
native static final float deg2rad (float angle) [builtin DegToRad]; // degrees --> radians
native static final float rad2deg (float angle) [builtin RadToDeg]; // radians -> degrees
native static final int abs (int val) [builtin IntAbs]; // absolute value
native static final float fabs (float val) [builtin FloatAbs]; // absolute value
native static final int sign (int val) [builtin IntSign]; // sign (-1, 0, 1)
native static final float fsign (float val) [builtin FloatSign]; // sign (-1, 0, 1)
#if option(csfields)
native static final int Min (int v1, int v2) [builtin IntMin]; // minimal value
native static final float FMin (float v1, float v2) [builtin FloatMin]; // minimal value
native static final int Max (int v1, int v2) [builtin IntMax]; // maximal value
native static final float FMax (float v1, float v2) [builtin FloatMax]; // maximal value
native static final int Clamp (int Val, int Min, int Max) [builtin IntClamp]; // clamped value
native static final float FClamp (float Val, float Min, float Max) [builtin FloatClamp]; // clamped value
#endif
native static final int min (int v1, int v2) [builtin IntMin]; // minimal value
native static final float fmin (float v1, float v2) [builtin FloatMin]; // minimal value
native static final int max (int v1, int v2) [builtin IntMax]; // maximal value
native static final float fmax (float v1, float v2) [builtin FloatMax]; // maximal value
native static final int clamp (int Val, int Min, int Max) [builtin IntClamp]; // clamped value
native static final float fclamp (float Val, float Min, float Max) [builtin FloatClamp]; // clamped value
native static final TVec vfmin (const TVec v1, const float v) [builtin VectorMinF];
native static final TVec vfmax (const TVec v1, const float v) [builtin VectorMaxF];
native static final TVec vecmin (const TVec v1, const TVec v2) [builtin VectorMinV];
native static final TVec vecmax (const TVec v1, const TVec v2) [builtin VectorMaxV];
native static final TVec vabs (const TVec v1) [builtin VectorAbs];
native static final TVec vecabs (const TVec v1) [builtin VectorAbs];
native static final TVec vclamp (const TVec v, const float Min, const float Max) [builtin VectorClampF]; // clamped value
native static final TVec vfclamp (const TVec v, const float Min, const float Max) [builtin VectorClampF]; // clamped value
native static final TVec vecclamp (const TVec v, const TVec vmin, const TVec vmax) [builtin VectorClampV]; // clamped value
native static final TVec vclampscale (const TVec v, const float absmax) [builtin VectorClampScaleF]; // clamps with rescaling
native static final TVec vfclampscale (const TVec v, const float absmax) [builtin VectorClampScaleF]; // clamps with rescaling
native static final float sin (float angle) [builtin Sin]; // sine
native static final float cos (float angle) [builtin Cos]; // cosine
native static final void sincos (float angle, out float sin, out float cos) [builtin SinCos];
native static final float tan (float angle) [builtin Tan]; // tangent
native static final float asin (float x) [builtin ASin]; // arcsine
native static final float acos (float x) [builtin ACos]; // arccosine
native static final float atan (float slope) [builtin ATan]; // arctangent
native static final float atan2 (float y, float x) [builtin ATan2]; // arctangent
native static final float sqrt (float x) [builtin Sqrt]; // square root
native static final float length (const TVec vec) [builtin VecLength]; // vector length
native static final float lengthSquared (const TVec vec) [builtin VecLengthSquared]; // vector length
alias Length = length;
alias LengthSquared = lengthSquared;
// vector length without z component
native static final float length2D (const TVec vec) [builtin VecLength2D];
native static final float length2DSquared (const TVec vec) [builtin VecLength2DSquared];
alias Length2D = length2D;
alias length2d = length2D;
alias Length2DSquared = length2DSquared;
alias length2dSquared = length2DSquared;
// normalises vector
native static final TVec normalise (const TVec vec) [builtin VecNormalize];
alias Normalise = normalise;
alias Normalize = normalise;
alias normalize = normalise;
// normalises 2d vector (ignores z)
native static final TVec normalise2D (const TVec vec) [builtin VecNormalize2D];
alias Normalise2D = normalise2D;
alias normalise2d = normalise2D;
alias Normalize2D = normalise2D;
alias normalize2d = normalise2D;
// dot product
native static final float dot (const TVec v1, const TVec v2) [builtin VecDot];
alias DotProduct = dot;
// dot product of 2d vector (ignores z)
native static final float dot2d (const TVec v1, const TVec v2) [builtin VecDot2D];
alias DotProduct2D = dot2d;
alias dot2D = dot2d;
// cross product (perpendicular vector)
native static final TVec cross (const TVec v1, const TVec v2) [builtin VecCross];
alias CrossProduct = cross;
// 2d cross product (signed magnitude, z, as x and y are effectively zero in 2d)
native static final float cross2d (const TVec v1, const TVec v2) [builtin VecCross2D];
alias CrossProduct2D = cross2d;
alias cross2D = cross2d;
// creates vectors for given angle vector
native static final void AngleVectors (const TAVec angles, out TVec forward, optional out TVec right, optional out TVec up);
// simplified version of AngleVectors, creates only forward vector (this is slightly faster)
native static final void AngleVector (const TAVec angles, out TVec forward);
// create angle vector for a vector
native static final void VectorAngles (const TVec vec, out TAVec angles);
native static final void DirVectorsAngles (const TVec forward, const TVec right, const TVec up, out TAVec angles);
native static final float VectorAngleYaw (const TVec vec);
native static final float VectorAnglePitch (const TVec vec);
native static final TVec AngleYawVector (const float yaw);
native static final TVec AnglePitchVector (const float pitch);
native static final TVec AnglesRightVector (const TAVec angles);
native static final TVec YawVectorRight (float yaw);
native static final TVec RotatePointAroundVector (const TVec dir, const TVec point, float degrees);
static final float AngleDiff (float afrom, float ato) { return AngleMod360(ato-afrom+180)-180; }
// get z of point with given x and y coords (don't try to use it on a vertical plane)
native static final float GetPlanePointZ (const ref TPlane plane, const TVec point);
native static final float GetPlanePointZRev (const ref TPlane plane, const TVec point);
// returns side 0 (front), or 1 (back)
native static final int PointOnPlaneSide (const TVec point, const ref TPlane plane);
// returns side 0 (front), 1 (back), or 2 (on)
native static final int PointOnPlaneSide2 (const TVec point, const ref TPlane plane);
// 2d bounding box
enum {
  BOX2D_TOP,
  BOX2D_BOTTOM,
  BOX2D_LEFT,
  BOX2D_RIGHT,
};
// or this
enum {
  BOX2D_MAXY,
  BOX2D_MINY,
  BOX2D_MINX,
  BOX2D_MAXX,
};
// this is for 3d bboxes
// bounding box
enum {
  BOX3D_MINX,
  BOX3D_MINY,
  BOX3D_MINZ,
  BOX3D_MAXX,
  BOX3D_MAXY,
  BOX3D_MAXZ,
};
// various constants
enum {
  BOX3D_MINIDX = 0,
  BOX3D_MAXIDX = 3,
};
// add those to MINIDX/MAXIDX to get the corresponding element
enum {
  BOX3D_X,
  BOX3D_Y,
  BOX3D_Z,
};
native static final void CreateDoomBox2D (out TVec bmin, out TVec bmax, const TVec origin, const float radius); // z will be 0
native static final void CreateDoomBox3D (out TVec bmin, out TVec bmax, const TVec origin, const float radius, const float height);
// considers the line to be infinite
// returns 0 - front, 1 - back, -1 - box crosses the line
native static final int BoxOnLineSide2DV (const TVec bmin, const TVec bmax, const TVec v1, const TVec v2);
#ifndef VCC_STANDALONE_EXECUTOR
native static final int BoxOnLineSide2D (const ref GameObject::line_t line, const TVec bmin, const TVec bmax);
native static final bool BoxLineHit2D (const ref GameObject::line_t line, const TVec bmin, const TVec bmax);
#endif
// rotates a direction vector
native static final TVec RotateDirectionVector (const TVec vec, const TAVec rot);
// rotates vector around Z axis
native static final void VectorRotateAroundZ (ref TVec vec, float angle);
// rotates vector around another vector
native static final TVec RotateVectorAroundVector (const TVec Vector, const TVec Axis, float angle);
// use on `sec_plane_t` to check if the plane is non-sloped
native static final bool IsPlainFloor (const ref TPlane plane); // valid only for floors
native static final bool IsPlainCeiling (const ref TPlane plane); // valid only for ceilings
native static final bool IsSlopedFlat (const ref TPlane plane);
native static final bool IsVerticalPlane (const ref TPlane plane);

native static final TVec RayLineIntersection2D (const TVec rayO, const TVec rayE, const TVec vv1, const TVec vv2);
native static final TVec RayLineIntersection2DDir (const TVec rayO, const TVec rayDir, const TVec vv1, const TVec vv2);

#ifndef VC_COMPILER_TEST
//TODO: move to native code?
static final bool CalcLinesIntersection (TVec lav1, TVec lav2, TVec lbv1, TVec lbv2, optional out TVec crosspt) {
  float x11 = lav1.x, y11 = lav1.y;
  float x12 = lav2.x, y12 = lav2.y;
  float x21 = lbv1.x, y21 = lbv1.y;
  float x22 = lbv2.x, y22 = lbv2.y;
  float maxx1 = fmax(x11, x12), maxy1 = fmax(y11, y12);
  float minx1 = fmin(x11, x12), miny1 = fmin(y11, y12);
  float maxx2 = fmax(x21, x22), maxy2 = fmax(y21, y22);
  float minx2 = fmin(x21, x22), miny2 = fmin(y21, y22);

  if (minx1 > maxx2 || maxx1 < minx2 || miny1 > maxy2 || maxy1 < miny2) return false;

  float dx1 = x12-x11, dy1 = y12-y11; // first line projection to x & y axes
  float dx2 = x22-x21, dy2 = y22-y21; // second line projection to x & y axes
  float dxx = x11-x21, dyy = y11-y21;

  float mul;
  float div = (dy2*dx1-dx2*dy1);
  if (div == 0.0) return false; // parallel lines
  if (div > 0.0) {
    mul = (dx1*dyy-dy1*dxx);
    if (mul < 0.0 || mul > div) return false; // first line crossing out of limits
    mul = (dx2*dyy-dy2*dxx);
    if (mul < 0.0 || mul > div) return false; // second line crossing out of limits
  }

  mul = -(dx1*dyy-dy1*dxx);
  if (mul < 0.0 || mul > -div) return false; // first line crossing out of limits
  mul = -(dx2*dyy-dy2*dxx);
  if (mul < 0.0 || mul > -div) return false; // second line crossing out of limits

  if (specified_crosspt) {
    float factor = (dx2*dyy-dy2*dxx)/div;
    crosspt = vector(x11+factor*(x21-x11), y11+factor*(y21-y11));
  }

  return true;
}

static final float AngleClamp180Signed (float angle) {
  /*
  while (angle < -180.0) angle += 180.0;
  while (angle > 180.0) angle -= 180.0;
  return angle;
  */
  return fclamp(angle, -180.0, 180.0);
}

static final float AngleClamp360Signed (float angle) {
  /*
  while (angle < -360.0) angle += 360.0;
  while (angle > 360.0) angle -= 360.0;
  return angle;
  */
  return fclamp(angle, -360.0, 360.0);
}
#endif

// ////////////////////////////////////////////////////////////////////////// //
// plane functions

// initialises vertical plane from point and direction
native static final void PlaneForPointDir (out TPlane plane, TVec point, TVec dir);

// initialises vertical plane from point and direction
native static final void PlaneForPointNormal (out TPlane plane, TVec point, TVec norm, optional bool normNormalised);

// initialises vertical plane from two points
native static final void PlaneForLine (out TPlane plane, TVec pointA, TVec pointB);

native static final TVec PlaneProjectPoint (const ref TPlane plane, TVec v);

// *signed* point distance
native static final float PlanePointDistance (const ref TPlane plane, TVec v);

native static final float PlaneLineIntersectTime (const ref TPlane plane, TVec v0, TVec v1);
native static final bool PlaneLineIntersect (const ref TPlane plane, TVec v0, TVec v1, out TVec vint);


// ////////////////////////////////////////////////////////////////////////// //
// colors

// opaque alpha is 255
// color is: AA_RR_GG_BB
// int RGBA components range is [0..255] (they will be clamped)
// float RGBA components range is [0..1] (they will be clamped)
native static final int RGB (int r, int g, int b);
native static final int RGBA (int r, int g, int b, int a);

native static final int RGBf (float r, float g, float b);
native static final int RGBAf (float r, float g, float b, float a);

native static final ubyte RGBGetR (int clr);
native static final ubyte RGBGetG (int clr);
native static final ubyte RGBGetB (int clr);
native static final ubyte RGBGetA (int clr);

native static final int RGBSetR (int clr, int v);
native static final int RGBSetG (int clr, int v);
native static final int RGBSetB (int clr, int v);
native static final int RGBSetA (int clr, int v);

native static final float RGBGetRf (int clr);
native static final float RGBGetGf (int clr);
native static final float RGBGetBf (int clr);
native static final float RGBGetAf (int clr);

native static final int RGBSetRf (int clr, float v);
native static final int RGBSetGf (int clr, float v);
native static final int RGBSetBf (int clr, float v);
native static final int RGBSetAf (int clr, float v);

// saturation is [0..1]
// hue is in degrees [0..360)
// input values won't be clamped/sanitized
native static final void RGB2HSV (int rgb, out float h, out float s, out float v);
native static final int HSV2RGB (float h, float s, float v);

// hue is in degrees [0..360)
// input values won't be clamped/sanitized
native static final void RGB2HSL (int rgb, out float h, out float s, out float l);
native static final int HSL2RGB (float h, float s, float l);

native static final int RGBDistanceSquared (int c0, int c1);

// input: [0..1]; output: [0..255]
native static final ubyte sRGBGamma (float v);
// input: [0..255]; output: [0..1]
native static final float sRGBUngamma (int v);

native static final ubyte sRGBIntensity (int clr);


// ////////////////////////////////////////////////////////////////////////// //
// returns number of planes created (0 for point)
// max result is six planes: two for line, two+two axial bevels
struct CD_LinePlanes {
  TPlane[6] planes;
  int count;
  TVec lineA, lineB; // we'll need this later
}

#ifndef VC_COMPILER_TEST
static final void CD_BuildLinePlanes (out CD_LinePlanes lpl, TVec a, TVec b) {
  a.z = 0;
  b.z = 0;
  lpl.lineA = a;
  lpl.lineB = b;
  if (a == b) {
    // point, create four axial planes to represent it as a box
    lpl.planes[0].normal = vector( 0, -1); lpl.planes[0].dist = -a.y; // top
    lpl.planes[1].normal = vector( 0,  1); lpl.planes[1].dist = a.y; // bottom
    lpl.planes[2].normal = vector(-1,  0); lpl.planes[2].dist = -a.x; // left
    lpl.planes[3].normal = vector( 1,  0); lpl.planes[3].dist = a.x; // right
    lpl.count = 4; // four planes created
    return;
  }
  // horizontal line?
  if (a.y == b.y) {
    if (a.x < b.x) {
      lpl.planes[0].normal = vector( 0, -1); lpl.planes[0].dist = -a.y; // top
      lpl.planes[1].normal = vector( 0,  1); lpl.planes[1].dist = a.y; // bottom
    } else {
      lpl.planes[1].normal = vector( 0, -1); lpl.planes[1].dist = -a.y; // top
      lpl.planes[0].normal = vector( 0,  1); lpl.planes[0].dist = a.y; // bottom
    }
    lpl.planes[2].normal = vector(-1,  0); lpl.planes[2].dist = -fmin(a.x, b.x); // left
    lpl.planes[3].normal = vector( 1,  0); lpl.planes[3].dist = fmax(a.x, b.x); // right
    lpl.count = 4; // four planes created
    return;
  }
  // vertical line?
  if (a.x == b.x) {
    if (a.y > b.y) {
      lpl.planes[0].normal = vector(-1,  0); lpl.planes[0].dist = -a.x; // left
      lpl.planes[1].normal = vector( 1,  0); lpl.planes[1].dist = a.x; // right
    } else {
      lpl.planes[1].normal = vector(-1,  0); lpl.planes[1].dist = -a.x; // left
      lpl.planes[0].normal = vector( 1,  0); lpl.planes[0].dist = a.x; // right
    }
    lpl.planes[2].normal = vector( 0, -1); lpl.planes[2].dist = -fmin(a.y, b.y); // top
    lpl.planes[3].normal = vector( 0,  1); lpl.planes[3].dist = fmax(a.y, b.y); // bottom
    lpl.count = 4; // four planes created
    return;
  }
  // ok, not an ortho-axis line, create line planes the old way
  // two line planes
  PlaneForLine(out lpl.planes[0], a, b);
  //PlaneForLine(out lpl.planes[1], b, a);
  lpl.planes[1].normal = -lpl.planes[0].normal;
  lpl.planes[1].dist = -lpl.planes[0].dist;
  // caps
  lpl.planes[2].normal = vector(-1,  0); lpl.planes[2].dist = -fmin(a.x, b.x); // left
  lpl.planes[3].normal = vector( 1,  0); lpl.planes[3].dist = fmax(a.x, b.x); // right
  lpl.planes[4].normal = vector( 0, -1); lpl.planes[4].dist = -fmin(a.y, b.y); // top
  lpl.planes[5].normal = vector( 0,  1); lpl.planes[5].dist = fmax(a.y, b.y); // bottom
  lpl.count = 6; // six planes created
}
#endif


// ////////////////////////////////////////////////////////////////////////// //
// keep 1/8 unit away to avoid various numeric issues
//const float CD_CLIP_EPSILON = 1.0f/8.0f;
// keep 1/16 unit away to avoid various numeric issues
const float CD_CLIP_EPSILON = 1.0f/16.0f;

enum CD_HitType {
  CD_HT_None,
  CD_HT_Point,
  // sides
  CD_HT_Top,
  CD_HT_Bottom,
  CD_HT_Left,
  CD_HT_Right,
  // used in tracer
  CD_HT_Floor,
  CD_HT_Ceiling,
}


#ifndef VC_COMPILER_TEST
static final float CD_SweepLineAABB (TVec lineA, TVec lineB, TVec vstart, TVec vend, TVec bmin, TVec bmax,
                                     optional out TPlane hitPlane, optional out TVec contactPoint, optional out CD_HitType hitType)
{
  CD_LinePlanes linePlanes;
  CD_BuildLinePlanes(out linePlanes, lineA, lineB);
  return CD_SweepLineAABBlpl(ref linePlanes, vstart, vend, bmin, bmax, hitPlane!optional, contactPoint!optional, hitType!optional);
}


// ////////////////////////////////////////////////////////////////////////// //
// returns collision time, -1 if started inside, exactly 1 if no collision
// in both such cases, `hitNormal` is undefined, as we have no hit plane
// the moving thing is AABB
// returns contact point in `contactPoint`
// actually, `contactPoint` has little sense for non-point hits, and is somewhat arbitrary
// `hitplanenum` indicates which line side we hit: front (0), back(1), or caps; can be -1
static final float CD_SweepLineAABBlpl (const ref CD_LinePlanes linePlanes, TVec vstart, TVec vend, TVec bmin, TVec bmax,
                                        optional out TPlane hitPlane, optional out TVec contactPoint,
                                        optional out CD_HitType hitType, optional out int hitplanenum,
                                        optional float eps/*=CD_CLIP_EPSILON*/)
{
  if (!specified_eps) eps = CD_CLIP_EPSILON;
  hitType = CD_HitType.CD_HT_None;
  hitplanenum = -1;

  float ifrac = -1.0f;
  float ofrac = +1.0f;

  bool startsOut = false;
  //bool endsOut = false;
  int phit = -1;

  foreach (auto pidx; 0..linePlanes.count) {
    TPlane *plane = &linePlanes.planes[pidx];
    // box
    // line plane normal z is always zero, so don't bother checking it
    TVec offset = vector((plane.normal.x < 0.0f ? bmax.x : bmin.x), (plane.normal.y < 0.0f ? bmax.y : bmin.y), /*(plane.normal.z < 0.0f ? bmax.z : bmin.z)*/bmin.z);
    // adjust the plane distance apropriately for mins/maxs
    float dist = plane.dist-DotProduct(offset, plane.normal);
    float idist = DotProduct(vstart, plane.normal)-dist;
    float odist = DotProduct(vend, plane.normal)-dist;

    if (idist <= 0.0f && odist <= 0.0f) continue; // doesn't cross this plane, don't bother

    if (idist > 0.0f) {
      startsOut = true;
      // if completely in front of face, no intersection with the entire brush
      if (odist >= eps || odist >= idist) return 1.0f;
    }
    //if (odist > 0.0f) endsOut = true;

    // crosses plane
    if (idist > odist) {
      // line is entering into the brush
      float fr = fmax(0.0f, (idist-eps)/(idist-odist));
      if (fr > ifrac) {
        ifrac = fr;
        phit = pidx;
      }
    } else {
      // line is leaving the brush
      float fr = fmin(1.0f, (idist+eps)/(idist-odist));
      if (fr < ofrac) ofrac = fr;
    }
  }

  // all planes have been checked, and the trace was not completely outside the brush
  if (!startsOut) {
    // original point was inside brush
    return -1.0f;
  }

  if (ifrac > -1.0f && ifrac < ofrac) {
    // might be exact hit
    ifrac = fclamp(ifrac, 0.0f, 1.0f);
    if (/*ifrac == 0.0f ||*/ ifrac == 1.0f) return ifrac; // just in case
    hitplanenum = phit;
    hitPlane = linePlanes.planes[phit];
    //print("ifrac=%s; hp(%s): %s:%s", ifrac, phit, hitPlane.normal, hitPlane.dist);
    // check what kind of hit this is
    if (phit > 1 && !hitPlane.normal.y) {
      // left or right side of the box
      hitType = (hitPlane.normal.x < 0.0f ? CD_HitType.CD_HT_Right : CD_HitType.CD_HT_Left);
      contactPoint =
        linePlanes.lineA.x < linePlanes.lineB.x ?
          (hitType == CD_HitType.CD_HT_Right ? linePlanes.lineA : linePlanes.lineB) :
          (hitType == CD_HitType.CD_HT_Right ? linePlanes.lineB : linePlanes.lineA);
      contactPoint -= (vend-vstart).normalise*eps;
    } else if (phit > 1 && !hitPlane.normal.x) {
      // top or down side of the box
      hitType = (hitPlane.normal.y < 0.0f ? CD_HitType.CD_HT_Bottom : CD_HitType.CD_HT_Top);
      contactPoint =
        linePlanes.lineA.y < linePlanes.lineB.y ?
          (hitType == CD_HitType.CD_HT_Bottom ? linePlanes.lineA : linePlanes.lineB) :
          (hitType == CD_HitType.CD_HT_Bottom ? linePlanes.lineB : linePlanes.lineA);
      contactPoint -= (vend-vstart).normalise*eps;
    } else {
      // point hit
      hitType = CD_HitType.CD_HT_Point;
      if (linePlanes.count == 4 && linePlanes.lineA.xy == linePlanes.lineB.xy) {
        // point
        contactPoint = linePlanes.lineA-(vend-vstart).normalise*eps;
      } else {
        bool fixX = false, fixY = false;
        if (!hitPlane.normal.x) {
          // horizontal line
          contactPoint = vector(0.0f, (hitPlane.normal.y < 0.0f ? bmax.y : hitPlane.normal.y > 0.0f ? bmin.y : 0.0f), bmin.z);
          fixX = true;
        } else if (!hitPlane.normal.y) {
          // vertical line
          contactPoint = vector((hitPlane.normal.x < 0.0f ? bmax.x : hitPlane.normal.x > 0.0f ? bmin.x : 0.0f), 0.0f, bmin.z);
          fixY = true;
        } else {
          contactPoint = vector((hitPlane.normal.x < 0.0f ? bmax.x : bmin.x), (hitPlane.normal.y < 0.0f ? bmax.y : bmin.y), bmin.z);
        }
        contactPoint += vstart+(vend-vstart)*ifrac;
        if (fixX) {
          if (linePlanes.lineA.x < linePlanes.lineB.x) {
            contactPoint.x = fclamp(contactPoint.x, linePlanes.lineA.x, linePlanes.lineB.x);
          } else {
            contactPoint.x = fclamp(contactPoint.x, linePlanes.lineB.x, linePlanes.lineA.x);
          }
        } else if (fixY) {
          if (linePlanes.lineA.y < linePlanes.lineB.y) {
            contactPoint.y = fclamp(contactPoint.y, linePlanes.lineA.y, linePlanes.lineB.y);
          } else {
            contactPoint.y = fclamp(contactPoint.y, linePlanes.lineB.y, linePlanes.lineA.y);
          }
        }
      }
    }
    return ifrac;
  }

  return 1.0f;
}
#endif


// ////////////////////////////////////////////////////////////////////////// //
// random numbers

// floating random number 0.0 ... 0.999999
native static final float Random ();
alias FRandom = Random;
// floating random number 0.0 ... 1.0
native static final float FRandomFull ();
// floating random number [minv..maxv] (inclusive)
native static final float FRandomBetween (float minv, float maxv);
// integer random number 0 .. 255
native static final int P_Random ();
// generates a random seen in range [1..0xffff_ffff]
native static final int GenRandomSeedU32 ();
// this is faster than `GenRandomSeedU32()`
// generates a random number in range [0..0x7fff_ffff]
native static final int GenRandomU31 ();

// ////////////////////////////////////////////////////////////////////////// //
// http://burtleburtle.net/bob/rand/smallprng.html
struct BJPRNGCtx {
  int a, b, c, d;
}

// seed with a random seed
native static final void bjprngSeedRandom (out BJPRNGCtx ctx);
// seed with the given seed
native static final void bjprngSeed (out BJPRNGCtx ctx, int aseed);
// full 32-bit value (so it can be negative)
native static final int bjprngNext (ref BJPRNGCtx ctx);
// only positives, 31-bit
native static final int bjprngNextU31 (ref BJPRNGCtx ctx);
// [0..1) (WARNING! not really uniform!)
native static final float bjprngNextFloat (ref BJPRNGCtx ctx);
// [0..1] (WARNING! not really uniform!)
native static final float bjprngNextFloatFull (ref BJPRNGCtx ctx);

// ////////////////////////////////////////////////////////////////////////// //
// 64-bit number
struct PCG3264Ctx {
  int lo, hi;
}

// seed with a random seed
native static final void pcg3264SeedRandom (out PCG3264Ctx ctx);
// seed with the given seed
native static final void pcg3264Seed (out PCG3264Ctx ctx, int aseed);
// full 32-bit value (so it can be negative)
native static final int pcg3264Next (ref PCG3264Ctx ctx);
// only positives, 31-bit
native static final int pcg3264NextU31 (ref PCG3264Ctx ctx);
// [0..1) (WARNING! not really uniform!)
native static final float pcg3264NextFloat (ref PCG3264Ctx ctx);
// [0..1] (WARNING! not really uniform!)
native static final float pcg3264NextFloatFull (ref PCG3264Ctx ctx);

// ////////////////////////////////////////////////////////////////////////// //
struct ChaChaCtx {
  ubyte[105] state_;
}

// is given chacha prng valid?
// WARNING! call this after seeding too!
native static final bool chachaIsValid (const ref ChaChaCtx ctx);
// get number of chacha rounds (undefined on invalid prng)
native static final int chachaGetRounds (const ref ChaChaCtx ctx);
// seed with a random seed (chacha20)
native static final void chachaSeedRandom (out ChaChaCtx ctx);
// seed with the given seed (chacha20)
native static final void chachaSeed (out ChaChaCtx ctx, int aseed);
// seed with the given seeds and rounds
native static final void chachaSeedEx (out ChaChaCtx ctx, int aseed0, int aseed1, int astream0, int astream1, int rounds);
// full 32-bit value (so it can be negative)
native static final int chachaNext (ref ChaChaCtx ctx);
// only positives, 31-bit
native static final int chachaNextU31 (ref ChaChaCtx ctx);
// [0..1) (WARNING! not really uniform!)
native static final float chachaNextFloat (ref ChaChaCtx ctx);
// [0..1] (WARNING! not really uniform!)
native static final float chachaNextFloatFull (ref ChaChaCtx ctx);


// ////////////////////////////////////////////////////////////////////////// //
// name functions
// compare names ingnoring case (not utf8-aware)
native static final int nameicmp (name s1, name s2) [property(name) icmp];
// compare string and name ignoring case (not utf8-aware)
native static final int namestricmp (name s1, string s2) [property(name) stricmp];
// compare names ignoring case (not utf8-aware)
native static final bool nameEquCI (name s1, name s2);
// compare name and string (not utf8-aware)
native static final bool nameStrEqu (name s1, string s2) [property(name) strEqu];
// compare name and string ignoring case (not utf8-aware)
native static final bool nameStrEquCI (name s1, string s2) [property(name) strEquCI];


// ////////////////////////////////////////////////////////////////////////// //
// string functions

// compare strings
native static final bool strEqu (string s1, string s2);
// compare strings ingnoring case (not utf8-aware)
native static final bool strEquCI (string s1, string s2);
// compare string and name
native static final bool strNameEqu (string s1, name s2) [property(string) nameEqu];
// compare string and name ingnoring case (not utf8-aware)
native static final bool strNameEquCI (string s1, name s2) [property(string) nameEquCI];
// compare strings
native static final int strcmp (string s1, string s2) [property(string) cmp];
// compare strings ingnoring case (not utf8-aware)
native static final int stricmp (string s1, string s2) [property(string) icmp];
// convert string to lowercase (not utf8-aware)
native static final string strlwr (string s) [property(string) toLowerCase];
// convert string to uppercase (not utf8-aware)
native static final string strupr (string s) [property(string) toUpperCase];
// string length (utf8-aware)
native static final int strlenutf8 (string s) [property(string) lengthUtf8];
// gets a substring (utf8-aware)
native static final string substrutf8 (string Str, int Start, int Len) [property(string) substrUtf8];
// creates one-char non-utf8 string from the given char code&0xff; 0 is allowed
native static final string strFromChar (int ch);
// creates one-char utf8 string from the given char code (or empty string if char code is invalid); 0 is allowed
native static final string strFromCharUtf8 (int ch);
// gets a substring (not utf8-aware)
native static final string strmid (string Str, int Start, optional int Len) [property(string) mid];
// gets left part of a string (not utf8-aware)
native static final string strleft (string Str, int len) [property(string) left];
// gets right part of a string (not utf8-aware)
native static final string strright (string Str, int len) [property(string) right];
// gets right part of a string (not utf8-aware); default ch is space
native static final string strrepeat (int len, optional int ch);
alias strRepeat = strrepeat;
// creates string from a number
native static final string strFromInt (int v);
// creates string from a number
native static final string strFromFloat (float v);
// do glob matching (knows '*' and '?')
// (not utf8-aware)
native static final bool globmatch (const string str, const string pat, optional bool caseSensitive/*=true*/);
// returns a value from zero to one indicating an approximate
// percentage of how closely two strings match
// case difference matters too
// this algo is not a speed demon, but it does the work
native static final float strApproxMatch (const string stra, const string strb) [property(string) approxMatch];
// returns 0-based index or -1
// negative startpos means offset from string end; startpos doesn't affect result
// (not utf8-aware)
native static final int strIndexOf (const string str, const string pat, optional int startpos, optional bool caseSensitive/*=true*/) [property(string) indexOf];
// returns 0-based index or -1
// negative startpos means offset from string end; startpos doesn't affect result
// (not utf8-aware)
native static final int strLastIndexOf (const string str, const string pat, optional int startpos, optional bool caseSensitive/*=true*/) [property(string) lastIndexOf];

// does varargs print into a temporary buffer
native static final string va (string format, ...) [printf,1];

// returns existing name, or ''
// (not utf8-aware)
native static final name findExistingName (string s, optional bool locase);

// converts string to integer
native static final int atoi (string str, optional out bool err);
// converts string to float
native static final float atof (string str, optional out bool err);

// checks if string starts with given string
// (not utf8-aware)
native static final bool StrStartsWith (string Str, string Check, optional bool caseSensitive/*=true*/) [property(string) startsWith];
alias strStartsWith = StrStartsWith;
// checks if string ends with given string
// (not utf8-aware)
native static final bool StrEndsWith (string Str, string Check, optional bool caseSensitive/*=true*/) [property(string) endsWith];
alias strEndsWith = StrEndsWith;
// replaces substrings with another string
// (not utf8-aware)
native static final string StrReplace (string Str, string Search, string Replacement) [property(string) replace];
alias strReplace = StrReplace;

// checks if string starts with given string
// (not utf8-aware)
native static final bool StrStartsWithCI (string Str, string Check) [property(string) startsWithCI];
alias strStartsWithCI = StrStartsWithCI;
// checks if string ends with given string
// (not utf8-aware)
native static final bool StrEndsWithCI (string Str, string Check) [property(string) endsWithCI];
alias strEndsWithCI = StrEndsWithCI;

// remove all color codes from the string
native static final string strRemoveColors (string s) [property(string) removeColors];

// removes all [0..32] chars from both string ends
native static final string strXStrip (string s) [property(string) xstrip];
// removes all [0..32] chars from both string ends
native static final string strTrimAll (string s) [property(string) trimAll];
// removes all leading [0..32] chars
native static final string strTrimLeft (string s) [property(string) trimLeft];
// removes all trailing [0..32] chars
native static final string strTrimRight (string s) [property(string) trimRight];


// ////////////////////////////////////////////////////////////////////////// //
//  Printing to console

// print to console
native static final void print (string format, ...) [printf,1];
// print to console only when developer == 1
native static final void dprint (string format, ...) [printf,1];
// print warning to console
native static final void printwarn (string format, ...) [printf,1];
// print error to console
native static final void printerror (string format, ...) [printf,1];
// print debug message to console (not filtered, just another message type)
native static final void printdebug (string format, ...) [printf,1];

// WARNING! keep in sync with C++ code!
enum PMSG {
  Log,
  Warning,
  Error,
  Debug,
  Init,
  DevNet,
  //
  Bot,
  BotDev,
  BotDevAI,
  BotDevRoam,
  BotDevCheckPos,
  BotDevItems,
  BotDevAttack,
  BotDevPath,
  BotDevCrumbs,
  BotDevPlanPath,
}

native static final void printmsg (PMSG type, string format, ...) [printf,2];


// ////////////////////////////////////////////////////////////////////////// //
// type conversions

// converts name to internal index (as name is just an int internally)
native static final int NameToIIndex (name Name) [builtin NameToIIndex];


// ////////////////////////////////////////////////////////////////////////// //
// class methods

native static final class FindClass (name Name);
native static final class FindClassNoCase (name Name);
native static final class FindClassNoCaseStr (string Name);
native static final spawner class FindClassNoCaseEx (class BaseClass, name Name);
native static final spawner class FindClassNoCaseExStr (class BaseClass, string Name);
native static final bool ClassIsChildOf (class SomeClass, class BaseClass);
native static final bool IsAbstractClass (class C) [property(class) IsAbstract];
native static final bool IsNativeClass (class C) [property(class) IsNative];
native static final name GetClassName (class C) [property(class) Name];
native static final string GetFullClassName (class C) [property(class) FullName];
native static final string GetClassLocationStr (class C) [property(class) Loc];
native static final class GetClassParent (class C) [property(class) Parent];
native static final class GetClassReplacement (class C) [property(class) Replacement];
native static final spawner class GetCompatibleClassReplacement (class CType, class C); // returns `none` if replacement is not compatible with `CType`
native static final class GetClassReplacee (class C) [property(class) Replacee];
native static final state FindClassState (class C, name StateName, optional name SubLabel, optional bool exact);
native static final int GetClassNumOwnedStates (class C) [property(class) NumOwnedStates];
native static final state GetClassFirstState (class C) [property(class) FirstState];
native static final name GetClassGameObjName (class C) [property(class) GameObjectName];
native static final int GetClassInstanceCount (class C) [property(class) InstanceCount];
native static final int GetClassInstanceCountWithSub (class C) [property(class) InstanceCountWithSub];


// ////////////////////////////////////////////////////////////////////////// //
// state methods

enum StateTicKind {
  Normal,
  Random, // random(Arg1, Arg2)
}

native static final string GetStateLocationStr (state State);
native static final string GetFullStateName (state State);
native static final bool StateIsInRange (state State, state Start, state End, int MaxDepth);
native static final bool StateIsInSequence (state State, state Start);
native static final name GetStateSpriteName (state State);
native static final int GetStateSpriteFrame (state State);
native static final int GetStateSpriteFrameWidth (state State);
native static final int GetStateSpriteFrameHeight (state State);
native static final void GetStateSpriteFrameSize (state State, out int w, out int h);
native static final float GetStateDuration (state State);
native static final state GetStatePlus (state S, int Offset, optional bool IgnoreJump/*=true*/);
native static final state GetNextState (state State); // by execution
native static final state GetNextStateInProg (state State); // by declaration
native static final bool StateHasAction (state State);
native static final void CallStateAction (Object actobj, state State);
native static final int GetStateSpriteFrameOfsX (state State);
native static final int GetStateSpriteFrameOfsY (state State);
native static final void GetStateSpriteFrameOffset (state State, out int dx, out int dy);
native static final int GetStateMisc1 (state State);
native static final int GetStateMisc2 (state State);
native static final void SetStateMisc1 (state State, int v);
native static final void SetStateMisc2 (state State, int v);
native static final StateTicKind GetStateTicKind (state State);
native static final int GetStateArgN (state State, int argn); // argn is zero-based
native static final void SetStateArgN (state State, int argn, int v); // argn is zero-based
native static final int GetStateFRN (state State);
native static final void SetStateFRN (state State, int v);


// ////////////////////////////////////////////////////////////////////////// //
// iterators

native static final iterator AllObjects (class BaseClass, out Object Obj);
native static final iterator AllClasses (class BaseClass, out class Class);
native static final iterator AllClassStates (class BaseClass, out state State);


// ////////////////////////////////////////////////////////////////////////// //
// misc

// default `skipReplacement` is:
//   `false` for VaVoom and VCC
//   `false` for vccrun
native static final spawner Object SpawnObject (class cid, optional bool skipReplacement);


//==========================================================================
//
//  date/time utils
//
//==========================================================================
struct TTimeVal {
  int secs; // actually, unsigned
  int usecs;
  // for 2030+
  int secshi;
}

struct TDateTime {
  int sec; // [0..60] (yes, *sometimes* it can be 60)
  int min; // [0..59]
  int hour; // [0..23]
  int month; // [0..11]
  int year; // normal value, i.e. 2042 for 2042
  int mday; // [1..31] -- day of the month
  //
  int wday; // [0..6] -- day of the week (0 is sunday)
  int yday; // [0..365] -- day of the year
  int isdst; // is daylight saving time?
}

native static final bool GetTimeOfDay (out TTimeVal tv);
native static final bool DecodeTimeVal (out TDateTime tm, const ref TTimeVal tv);

// see mktime(3)
// `wday`, `yday`, and `isdst` are set on success; `isdst` is used if `usedist` is `true`
native static final bool EncodeTimeVal (out TTimeVal tv, ref TDateTime tm, optional bool usedst);


//==========================================================================
//
//              MISC BUILTINS
//
//==========================================================================
native final static class FindMObjId (int id, optional int GameFilter);
native final static class FindScriptId (int id, optional int GameFilter);
native final static class FindClassByGameObjName (name aname, optional name pkgname);


// ////////////////////////////////////////////////////////////////////////// //
// cvar functions

bitenum {
  CVAR_ARCHIVE, // set to cause it to be saved to config file
  CVAR_USERINFO, // added to userinfo  when changed
  CVAR_SERVERINFO, // added to serverinfo when changed
  CVAR_INIT,  // don't allow change from console at all, but can be set from the command line
  CVAR_LATCH, // save changes until server restart
  CVAR_ROM, // display only, cannot be set by user at all
  CVAR_CHEAT, // can not be changed if cheats are disabled
  CVAR_MODIFIED, // set each time the cvar is changed
  CVAR_FROMMOD, // came from cvarinfo
}

enum {
  CVAR_PREINIT = 0x4000, // CLI change for this cvar should be processed before initializing main game
  CVAR_AlwaysArchive = 0x8000, // always write to config
  CVAR_ACS = 0x10000, // created from ACS script
}

native static final bool CvarExists (name Name); // is cvar exists?
native static final int CvarGetFlags (name Name); // -1: no such var
native static final string GetCvarHelp (name Name); // get cvar help text
native static final string GetCvarDefault (name Name); // get cvar default value
native static final void CreateCvar (name Name, string defaultValue, string helpText, optional int flags); // create a new cvar
native static final void CreateCvarInt (name Name, int defaultValue, string helpText, optional int flags); // create a new cvar
native static final void CreateCvarFloat (name Name, float defaultValue, string helpText, optional int flags); // create a new cvar
native static final void CreateCvarBool (name Name, bool defaultValue, string helpText, optional int flags); // create a new cvar
native static final void CreateCvarStr (name Name, string defaultValue, string helpText, optional int flags); // create a new cvar
native static final int GetCvar (name Name); // read int value
native static final void SetCvar (name Name, int value); // set cvar int value
alias GetCvarI = GetCvar; // read int value
alias SetCvarI = SetCvar; // set cvar int value
native static final float GetCvarF (name Name); // read float value
native static final void SetCvarF (name Name, float value); // set cvar float value
native static final string GetCvarS (name Name); // read string value
native static final void SetCvarS (name Name, string value); // set cvar string value
native static final bool GetCvarB (name Name); // read boolean value
native static final void SetCvarB (name Name, bool value); // set cvar boolean value
native static final void CvarUnlatchAll (); // NOOP in network game (so can be called safely)

native static final void SetShadowCvar (name Name, int value); // set cvar int value
native static final void SetShadowCvarF (name Name, float value); // set cvar float value
native static final void SetShadowCvarS (name Name, string value); // set cvar string value
native static final void SetShadowCvarB (name Name, bool value); // set cvar boolean value
alias SetShadowCvarI = SetShadowCvar; // set cvar int value


// ////////////////////////////////////////////////////////////////////////// //
// temporary name set functions
// used to prevent warning spam

// returns `false` if element wasn't in set
native static final bool SetNamePutElement (name setName, name value);
native static final bool SetNameCheckElement (name setName, name value);


#ifdef VCC_STANDALONE_EXECUTOR
# include "vccrun/Object_vccrun.vc"
#else
# include "Object_vavoom.vc"
#endif


defaultproperties {
}


// ////////////////////////////////////////////////////////////////////////// //
// Micropather A-Star solver interface
// ////////////////////////////////////////////////////////////////////////// //

class MiAStarNodeBase : Object;

defaultproperties {
}


// ////////////////////////////////////////////////////////////////////////// //
class MiAStarGraphBase : Object native abstract;

native readonly private transient void *__intr;
native readonly private transient void *__pather;
native readonly private transient void *__adjarray;

float pathCost; // valid after successfull solution

// default values for micropather
int initParam_PoolSize = 250;
int initParam_TypicalAdjacent = 8;
int initParam_CachePathes = true;

//native override void Destroy ();

// usually pathfinder is initialised on the first call to `Solve*()`.
// after that, there is no sense in changing defaults.
native final bool IsInitialized ();

// this must be used in `AdjacentCost()`, to push all neighbours.
native final void PushAdjacentCost (MiAStarNodeBase node, float cost);

// two abstract methods, must be overriden
/*
  Return the least possible cost between 2 states. For example, if your pathfinding
  is based on distance, this is simply the straight distance between 2 points on the
  map. If you pathfinding is based on minimum time, it is the minimal travel time
  between 2 points given the best possible terrain.
*/
native float LeastCostEstimate (MiAStarNodeBase start, MiAStarNodeBase end);

/*
  Return the exact cost from the given state to all its neighboring states. This
  may be called multiple times, or cached by the solver. It *must* return the same
  exact values for every call to MicroPather::Solve(). It should generally be a simple,
  fast function with no callbacks into the pather.

  Push all neighbours with `PushAdjacentCost()`.
*/
native void AdjacentCost (MiAStarNodeBase node);

// used to clear current solved path
native final void PathArrayClear ();
// used to retrieve solved path after calling `Solve()`
native final int PathArrayLength ();
native final MiAStarNodeBase PathArrayNode (int index);
// force-push node to path array
native final void PathArrayPushNode (MiAStarNodeBase node);

// used to clear current near nodes list
native final void NearArrayClear ();
// used to retrieve solved path after calling `SolveForNearStates()`
native final int NearArrayLength ();
native final MiAStarNodeBase NearArrayNode (int index);
native final MiAStarNodeBase NearArrayNodeAndCost (int index, out float cost);
// force-push node to near array
native final void NearArrayPushNode (MiAStarNodeBase node, float cost);

/*
  Solve for the path from start to end.

  startState -- the starting state for the path.
  endState   -- the ending state for the path.

  Outputs solution that can be retrieved with `PathArrayXXX()` methods.
  Also puts cost to `pathCost`.
  Returns `true` if solution was found.

  if start and end states are the same, creates path from one state, with zero cost.
*/
native final bool Solve (MiAStarNodeBase startState, MiAStarNodeBase endState);

/*
  Find all the states within a given cost from startState.

  startState -- the starting state for the path.
  maxCost    -- the maximum cost that will be returned.
                Higher values return larger 'near' sets and take more time to compute.

  Outputs solution that can be retrieved with `NearArrayXXX()` methods.
  Returns success or failure.
*/
native final bool SolveForNearStates (MiAStarNodeBase startState, float maxCost);

/* Should be called whenever the cost between states or the connection between states changes.
  Also frees overhead memory used by MicroPather, and calling will free excess memory.
*/
native final void Reset ();


defaultproperties {
}
