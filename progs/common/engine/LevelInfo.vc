//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2021 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class LevelInfo : Thinker native abstract;

const int TID_HASH_SIZE = 128;

/* in Object
struct VMapSpecialAction {
  name TypeName;
  int Special;
  int Args[5];
};
*/

// k8: this duplicates list of bools in levelinfo.
//     i am too lazy to replace mapinfo flag fields with bools.
enum {
  LIF_DoubleSky                 = 0x00000001, // parallax sky: sky2 behind sky1
  LIF_Lightning                 = 0x00000002, // use of lightning on the level flashes from sky1 to sky2
  LIF_Map07Special              = 0x00000004,
  LIF_BaronSpecial              = 0x00000008,
  LIF_CyberDemonSpecial         = 0x00000010,
  LIF_SpiderMastermindSpecial   = 0x00000020,
  LIF_MinotaurSpecial           = 0x00000040,
  LIF_DSparilSpecial            = 0x00000080,
  LIF_IronLichSpecial           = 0x00000100,
  LIF_SpecialActionOpenDoor     = 0x00000200,
  LIF_SpecialActionLowerFloor   = 0x00000400,
  LIF_SpecialActionKillMonsters = 0x00000800,
  LIF_NoIntermission            = 0x00001000,
  LIF_AllowMonsterTelefrags     = 0x00002000,
  LIF_NoAllies                  = 0x00004000,
  LIF_DeathSlideShow            = 0x00008000,
  LIF_ForceNoSkyStretch         = 0x00010000,
  LIF_LookupName                = 0x00020000,
  LIF_FallingDamage             = 0x00040000,
  LIF_OldFallingDamage          = 0x00080000,
  LIF_StrifeFallingDamage       = 0x00100000,
  LIF_MonsterFallingDamage      = 0x00200000,
  LIF_NoFreelook                = 0x00400000,
  LIF_NoJump                    = 0x00800000,
  LIF_NoAutoSndSeq              = 0x01000000,
  LIF_ActivateOwnSpecial        = 0x02000000,
  LIF_MissilesActivateImpact    = 0x04000000,
  LIF_FilterStarts              = 0x08000000,
  LIF_InfiniteFlightPowerup     = 0x10000000,
  LIF_ClipMidTex                = 0x20000000,
  LIF_WrapMidTex                = 0x40000000,
  LIF_KeepFullInventory         = 0x80000000,
};

enum {
  LIF2_CompatShortTex        = 0x00000001,
  LIF2_CompatStairs          = 0x00000002,
  LIF2_CompatLimitPain       = 0x00000004,
  LIF2_CompatNoPassOver      = 0x00000008,
  LIF2_CompatNoTossDrops     = 0x00000010,
  LIF2_CompatUseBlocking     = 0x00000020,
  LIF2_CompatNoDoorLight     = 0x00000040,
  LIF2_CompatRavenScroll     = 0x00000080,
  LIF2_CompatSoundTarget     = 0x00000100,
  LIF2_CompatDehHealth       = 0x00000200,
  LIF2_CompatTrace           = 0x00000400,
  LIF2_CompatDropOff         = 0x00000800,
  LIF2_CompatBoomScroll      = 0x00001000,
  LIF2_CompatInvisibility    = 0x00002000,
  LIF2_LaxMonsterActivation  = 0x00004000,
  LIF2_HaveMonsterActivation = 0x00008000,
  LIF2_ClusterHub            = 0x00010000,
  LIF2_BegunPlay             = 0x00020000,
  LIF2_Frozen                = 0x00040000,
  LIF2_NoCrouch              = 0x00080000,
  LIF2_ResetHealth           = 0x00100000,
  LIF2_ResetInventory        = 0x00200000,
  LIF2_ResetItems            = 0x00400000,
  LIF2_CheckSwitchRange      = 0x00800000, // force "check switch range" flag
  LIF2_NoCheckSwitchRange    = 0x01000000, // ignore "check switch range" flag
};


native readonly GameInfo Game;
native readonly WorldInfo World;

string LevelName;
int LevelNum;
ubyte Cluster;

name NextMap;
name SecretMap;

int ParTime;
int SuckTime;

int Sky1Texture;
int Sky2Texture;
float Sky1ScrollDelta;
float Sky2ScrollDelta;
name SkyBox;

name FadeTable;
int Fade;
int OutsideFog;

name SongLump;

bool bDoubleSky; // parallax sky: sky2 behind sky1
bool bLightning; // use of lightning on the level flashes from sky1 to sky2
// special actions, as set in MAPINFO
bool bMap07Special;
bool bBaronSpecial;
bool bCyberDemonSpecial;
bool bSpiderMastermindSpecial;
bool bMinotaurSpecial;
bool bDSparilSpecial;
bool bIronLichSpecial;
bool bSpecialActionOpenDoor;
bool bSpecialActionLowerFloor;
bool bSpecialActionKillMonsters;
bool bNoIntermission;
bool bAllowMonsterTelefrags;
bool bNoAllies;
bool bDeathSlideShow;
bool bForceNoSkyStretch;
bool bLookupName;
bool bFallingDamage;
bool bOldFallingDamage;
bool bStrifeFallingDamage;
bool bMonsterFallingDamage;
bool bNoFreelook;
bool bNoJump;
bool bNoAutoSndSeq;
bool bActivateOwnSpecial;
bool bMissilesActivateImpact;
bool bFilterStarts;
bool bInfiniteFlightPowerup;
bool bClipMidTex;
bool bWrapMidTex;
bool bKeepFullInventory;

bool bCompatShortTex;
bool bCompatStairs;
bool bCompatLimitPain;
bool bCompatNoPassOver;
bool bCompatNoTossDrops;
bool bCompatUseBlocking;
bool bCompatNoDoorLight;
bool bCompatRavenScroll;
bool bCompatSoundTarget;
bool bCompatDehHealth;
bool bCompatTrace;
bool bCompatDropOff;
bool bCompatBoomScroll;
bool bCompatInvisibility;
bool bLaxMonsterActivation;
bool bHaveMonsterActivation;
bool bClusterHub;
readonly bool bBegunPlay;
bool bFrozen;
bool bNoCrouch;
bool bResetHealth;
bool bResetInventory;
bool bResetItems;
bool bCheckSwitchRange; // force "check switch range" flag
bool bNoCheckSwitchRange; // ignore "check switch range" flag

int TotalKills;
int TotalItems;
int TotalSecret; // for intermission
int CurrentKills;
int CurrentItems;
int CurrentSecret;

float CompletitionTime; // for intermission

// maintain single and multi player starting spots
array!mthing_t DeathmatchStarts; // player spawn spots for deathmatch
array!mthing_t PlayerStarts; // player spawn spots

private Entity TIDHash[TID_HASH_SIZE];

float Gravity; // level gravity
float AirControl;
int Infighting;
array!VMapSpecialAction SpecialActions;

// 0: no
// bit 0: hunt monsters
// bit 1: hunt players (monster is a priority target, tho)
// bit 2: wander instead of idle
// bit 3: total infighting
// set to 0x0d (13) for pure fun ;-)
transient int PerfectHatredMode;

bitenum {
  PHM_HUNT_MONSTERS,
  PHM_HUNT_PLAYERS,
  PHM_WANDER,
  PHM_INFIGHTING,
}

replication {
  reliable if (Role == ROLE_Authority)
    SongLump,
    Sky1Texture, Sky2Texture, Sky1ScrollDelta, Sky2ScrollDelta, SkyBox,
    FadeTable, Fade, OutsideFog,
    bDoubleSky, bLightning,
    TotalKills, TotalItems, TotalSecret,
    CurrentKills, CurrentItems, CurrentSecret, CompletitionTime;

  reliable if (Role == ROLE_Authority && bNetInitial)
    LevelName, LevelNum, Cluster, ParTime, SuckTime,
    bNoIntermission, bForceNoSkyStretch, bLookupName,
    bNoFreelook, bNoJump,
    Gravity, AirControl;
}


native final bool CompatShortTex { get; } // compat_shorttex
native final bool CompatStairs { get; } // compat_stairs
native final bool CompatLimitPain { get; } // compat_limitpain
native final bool CompatNoPassOver { get; } // compat_nopassover
native final bool CompatNoTossDrops { get; } // compat_notossdrops
native final bool CompatUseBlocking { get; } // compat_useblocking
native final bool CompatNoDoorLight { get; } // compat_nodoorlight
native final bool CompatRavenScroll { get; } // compat_ravenscroll
native final bool CompatSoundTarget { get; } // compat_soundtarget
native final bool CompatDehHealth { get; } // compat_dehhealth
native final bool CompatTrace { get; } // compat_trace
native final bool CompatDropOff { get; } // compat_dropoff
native final bool CompatBoomScroll { get; } // compat_boomscroll
native final bool CompatInvisibility { get; } // compat_invisibility

// ////////////////////////////////////////////////////////////////////////// //
// static lights
native final void AddStaticLight (Entity ent, TVec origin, float radius, optional TVec coneDirection, optional float coneAngle, optional int flags);
native final void AddStaticLightRGB (Entity ent, TVec origin, float radius, int color, optional TVec coneDirection, optional float coneAngle, optional int flags);
// scale<0: attenuated
native final void AddStaticLightRGBSector (Entity ent, TVec origin, sector_t *sector, float scale, int color, optional TVec coneDirection, optional float coneAngle, optional int flags);
native final void MoveStaticLightByOwner (Entity ent, TVec origin);
native final void RemoveStaticLightByOwner (Entity ent);


// ////////////////////////////////////////////////////////////////////////// //
// sound sequences
native final void SectorStartSequence (sector_t *sector, name sequence, int ModeNum);
native final void SectorStopSequence (sector_t *sector);
native final void PolyobjStartSequence (polyobj_t *mobj, name sequence, int ModeNum);
native final void PolyobjStopSequence (polyobj_t *mobj);

// ////////////////////////////////////////////////////////////////////////// //
// exiting the level
native final void ExitLevel (int Position);
native final void SecretExitLevel (int Position);
native final void Completed (int Map, int Position, int SaveAngle);

// ////////////////////////////////////////////////////////////////////////// //
// special thinker utilites
native static final bool IsSwitchTexture (int textureid);
native final bool ChangeSwitchTexture (int SideNum, int useAgain, name DefaultSound, out ubyte Quest);
native final Entity FindMobjFromTID (int tid, Entity Prev);
// checkpoint saves are lightweight, but they aren't saving map state, only player inventory
native final void AutoSave (optional bool checkpoint);

native final void ChangeMusic (name SongName);

native final int FindFreeTID (optional int tidstart, optional int limit);
native final bool IsTIDUsed (int tid);

// the same as ACS call
native final void ChangeSky (string skytex1, optional string skytex2/*=skytex1*/);


// ////////////////////////////////////////////////////////////////////////// //
/* old version
static float StaticIntensityToRadius (float Val) {
  if (Val <= 20.0) return Val*3.5;
  if (Val <= 30.0) return Val*3.0;
  if (Val <= 40.0) return Val*2.8;
  if (Val <= 60.0) return Val*2.4;
  return Val*2.0;
}
*/

static float GZSizeToRadius (float Val, bool attenuated, optional float attmult/*=1.04*/) {
  //printdebug("GZSizeToRadius: Val=%s; attenuated=%s; attmult=%s:%s", Val, attenuated, specified_attmult, attmult);
  if (attenuated) {
    if (!specified_attmult) attmult = 1.04; // size in map units; k8: 1.04f is just because i feel it
    return fmax(0, Val*attmult);
  } else {
    Val = fmax(0, Val);
    if (Val <= 20.0) return Val*4.5;
    if (Val <= 30.0) return Val*3.6;
    if (Val <= 40.0) return Val*3.3;
    if (Val <= 60.0) return Val*2.8;
    return Val*2.5;
  }
}


// ////////////////////////////////////////////////////////////////////////// //
struct MobjByTIDIteratorInfo {
  Entity prev;
  int tid; // 0: use activator (it is in prev)
}

final bool eachTID_opIterInit (out MobjByTIDIteratorInfo it, int tid, optional Entity activator) {
  if (tid == 0) {
    // 0 is activator
    if (!EntityEx(activator)) return false;
    //if (!activator) return false;
    it.prev = activator;
  } else {
    // get first entity
    it.prev = FindMobjFromTID(tid, none);
    // skip non-EntityEx objects
    while (it.prev && !EntityEx(it.prev)) {
      it.prev = FindMobjFromTID(tid, it.prev);
    }
    if (!it.prev) return false; // no entities, do not iterate
  }
  it.tid = tid;
  return true;
}

final bool eachTID_opIterNext (ref MobjByTIDIteratorInfo it, out EntityEx ent) {
  ent = EntityEx(it.prev);
  if (!ent) {
    assert(!it.prev);
    return false; // done
  }
  if (it.tid) {
    // skip non-EntityEx objects
    for (;;) {
      it.prev = FindMobjFromTID(it.tid, it.prev);
      if (!it.prev || EntityEx(it.prev)) break;
    }
  } else {
    // only activator
    it.prev = none;
  }
  return true;
}


//==========================================================================
//
//  AfterSetMapInfo
//
//==========================================================================
void AfterSetMapInfo (VLevel lvl) {
  if (!lvl) return;
  // shorttex (taken from GZDoom)
  if (lvl.MapHashMD5 == "0eecbf37b328c9caaf20ded4949a4157") {
    // Sudtic e2m6
    printwarn("MAPFIX: Sudtic E2M6 ShortTex fix applied");
    bCompatShortTex = true;
  } else if (lvl.MapHashMD5 == "4ace0644883bda0cba254fa02c9acf83") {
    // Teutic e3m4
    printwarn("MAPFIX: Teutic E3M4 ShortTex fix applied");
    bCompatShortTex = true;
  } else if (lvl.MapHashMD5 == "9f2be080a33f775294bd78822456924e") {
    // Nukemine e1m4
    printwarn("MAPFIX: Nukemine E1M4 ShortTex fix applied");
    bCompatShortTex = true;
  } else if (lvl.MapHashMD5 == "cd31793d3a4b00231b124c0c23649644") {
    // Strain map02
    printwarn("MAPFIX: Strain MAP02 ShortTex fix applied");
    bCompatShortTex = true;
  } else if (lvl.MapHashMD5 == "19094aeb53d12efc8e0568424f659f11") {
    // Strain map31
    printwarn("MAPFIX: Strain MAP31 ShortTex fix applied");
    bCompatShortTex = true;
  } else if (lvl.MapHashMD5 == "60733bdd1aa3f4b2262adc79b2e1b5ab") {
    // Memento Mori map29
    printwarn("MAPFIX: Memento Mori MAP29 ShortTex fix applied");
    bCompatShortTex = true;
  } else if (lvl.MapHashMD5 == "f84ab4557464a383e93f37cd3a82ac48") {
    // MM2 map03
    printwarn("MAPFIX: Memento Mori 2 MAP03 ShortTex fix applied");
    bCompatShortTex = true;
  } else if (lvl.MapHashMD5 == "1497894956b3c8ebe8a240b7fdd99c6a") {
    // MM2 map25
    printwarn("MAPFIX: Memento Mori 2 MAP25 ShortTex fix applied");
    bCompatShortTex = true;
  } else if (lvl.MapHashMD5 == "941e4cb56ee4184e0b1ed43486ab0bbf") {
    // AV map07
    printwarn("MAPFIX: Alien Vendetta MAP07 ShortTex fix applied");
    bCompatShortTex = true;
  } else if (lvl.MapHashMD5 == "6d4156ee0d12b77ad143a37c4d3dcf98") {
    // dmonfear.wad map22
    printwarn("MAPFIX: DemonFear MAP22 ShortTex fix applied");
    bCompatShortTex = true;
  } else if (lvl.MapHashMD5 == "6da6fcba8089161bdec6a1d3f6c8d60f") {
    printwarn("MAPFIX: Eternal Doom MAP25");
    bCompatStairs = true;
  } else if (lvl.MapHashMD5 == "10e1e2b36302d31ac4ae68c84b5dc457") {
    printwarn("MAPFIX: Eternal Doom MAP28");
    bCompatTrace = true;
    bCompatUseBlocking = true;
  } else if (lvl.MapHashMD5 == "2fe901f659a16e58d7bcd7c30021c238") {
    printwarn("MAPFIX: Alien Vendetta MAP15");
    bCompatTrace = true;
  } else if (lvl.MapHashMD5 == "74af92e96fe10d039d31c1f6526d7d7c") {
    printwarn("MAPFIX: Real World MAP11");
    bCompatTrace = true;
  } else if (lvl.MapHashMD5 == "71c2e6d9cfa3d8750c6a9599fb2453bd") {
    printwarn("MAPFIX: Hacx MAP03");
    bCompatUseBlocking = true;
  } else if (lvl.MapHashMD5 == "96368eb950e33af62ea6423434e3cef7") {
    printwarn("MAPFIX: Hacx MAP17");
    bCompatUseBlocking = true;
  } else if (lvl.MapHashMD5 == "ba530202af0ba0c6cbae6a0c7076fb72") {
    printwarn("MAPFIX: Requiem MAP04");
    bCompatUseBlocking = true;
  } else if (lvl.MapHashMD5 == "811a0c97777a198bc9b2bb558cb46e6a") {
    printwarn("MAPFIX: Hell Revealed MAP19");
    bCompatLimitPain = true;
  }
}


//==========================================================================
//
//  MapFixerRemoveEntitiesHelper
//
//==========================================================================
void MapFixerRemoveEntitiesHelper (name entname, optional string msg) {
  if (!entname) return;
  auto moClass = class!EntityEx(FindClassNoCase(entname));
  if (!moClass) return;
  printdebug("removing `%s`", entname);
  array!EntityEx elist;
  EntityEx ent;
  foreach AllThinkers(moClass, out ent) {
    if (ent.Owner) continue;
    if (ent.bIsPlayer) continue;
    elist[$] = ent;
  }
  if (elist.length == 0) return;
  foreach (EntityEx e; elist) delete e;
  if (msg) {
    printwarn("MAPFIX: "~msg, elist.length);
  } else {
    printwarn("MAPFIX: removed %s `%s` entities", elist.length, entname);
  }
}


//==========================================================================
//
//  SpawnSpecials
//
//==========================================================================
void SpawnSpecials () {
  // Vela Pax MAP01: remove barrels
  if (XLevel.MapHashMD5 == "dae64fe4b2a4c17f4b4682bf7b63f12f") {
    if (!GetCvarB('vm_optimise_statics')) {
      MapFixerRemoveEntitiesHelper('ExplosiveBarrel', "Vela Pax, MAP01: removed %s annoying barrels (for speed)");
    }
    return;
  }

  // Plutonium Sandpit (ka_tech.pk3): remove bubble spawners
  if (XLevel.MapHashMD5 == "acb63fdf33586f3a0f03a4da67c2ac9d") {
    MapFixerRemoveEntitiesHelper('BubbleSpawner', "Plutonium Sandpit: removed %s bubble spawners (for speed)");
    return;
  }
}


//==========================================================================
//
//  UpdateSpecials
//
//==========================================================================
void UpdateSpecials () {
}


//==========================================================================
//
//  AfterUnarchiveThinkers
//
//==========================================================================
void AfterUnarchiveThinkers () {}


//==========================================================================
//
//  PolyRotateMobj
//
//==========================================================================
void PolyRotateMobj (Entity A, float dangle) {
}


//==========================================================================
//
//  PolyThrustMobj
//
//  returns `true` if po is blocked, `false` if mobj is killed
//  `thrustDir` is zero if it is impossible to thrust away
//  `vertical` is redunant this way, but... meh.
//
//==========================================================================
bool PolyThrustMobj (Entity A, TVec thrustDir, polyobj_t *po, bool vertical) {
  return true;
}


//==========================================================================
//
//  PolyCrushMobj
//
//==========================================================================
void PolyCrushMobj (Entity A, polyobj_t *po) {
}


//==========================================================================
//
//  TagBusy
//
//==========================================================================
bool TagBusy (int tag) {
  int sectorIndex;
  sector_t *sector;
  for (sectorIndex = XLevel.FindSectorFromTag(out sector, tag); sectorIndex >= 0;
       sectorIndex = XLevel.FindSectorFromTag(out sector, tag, sectorIndex))
  {
    if (sector.FloorData || sector.CeilingData) {
      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  PolyBusy
//
//==========================================================================
bool PolyBusy (int polyobj) {
  return false;
}


//==========================================================================
//
//  PolyAngle
//
//==========================================================================
float PolyAngle (int polyobj) {
  return -1;
}


//==========================================================================
//
//  ThingCount
//
//==========================================================================
int ThingCount (int type, name TypeName, int tid, int SectorTag) {
  return 0;
}


//==========================================================================
//
//  ExecuteActionSpecial
//
//==========================================================================
int ExecuteActionSpecial (int Special, int Arg1, int Arg2, int Arg3,
                          int Arg4, int Arg5, line_t *line, int side, Entity A)
{
  return 0;
}


//==========================================================================
//
//  EV_ThingProjectile
//
//==========================================================================
bool EV_ThingProjectile (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
                         int grav, int newtid, name TypeName, Entity Activator)
{
  return false;
}


//==========================================================================
//
//  StartPlaneWatcher
//
//==========================================================================
void StartPlaneWatcher (Entity it, line_t *line, int lineSide, bool ceiling,
                        int tag, int height, int special, int arg0, int arg1,
                        int arg2, int arg3, int arg4)
{
}


//**************************************************************************
//**
//**    special thinker utilites
//**
//**************************************************************************

//==========================================================================
//
//  getNextSector
//
//  Return sector_t* of sector next to current. nullptr if not two-sided line
//
//==========================================================================
final sector_t *getNextSector (line_t *line, sector_t *sec) {
  if (!(line->flags&ML_TWOSIDED)) return nullptr;

  if (line->frontsector == sec) {
    return (line->backsector == sec ? nullptr : line->backsector);
  }

  return line->frontsector;
}


//==========================================================================
//
//  FindLowestFloorSurrounding
//
//  find lowest floor height in surrounding sectors
//
//==========================================================================
final float FindLowestFloorSurrounding (sector_t *sec, TVec *v) {
  TVec spot = *sec->lines[0]->v1;
  float floor = GetPlanePointZ(ref sec->floor, spot);
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);

    if (!other) continue;

    float ofloor = GetPlanePointZ(ref other->floor, *check->v1);
    if (ofloor < floor && ofloor < GetPlanePointZ(ref sec->floor, *check->v1)) {
      floor = ofloor;
      spot = *check->v1;
    }

    ofloor = GetPlanePointZ(ref other->floor, *check->v2);
    if (ofloor < floor && ofloor < GetPlanePointZ(ref sec->floor, *check->v2)) {
      floor = ofloor;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return floor;
}


//==========================================================================
//
//  FindHighestFloorSurrounding
//
//  find highest floor height in surrounding sectors
//
//==========================================================================
final float FindHighestFloorSurrounding (sector_t *sec, TVec *v) {
  if (sec.lines.length == 0) return sec.floor.maxz;
  TVec spot = *sec->lines[0]->v1;
  float floor = -float.max;
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (!other) continue;

    float ofloor = GetPlanePointZ(ref other->floor, *check->v1);
    if (ofloor > floor) {
      floor = ofloor;
      spot = *check->v1;
    }

    ofloor = GetPlanePointZ(ref other->floor, *check->v2);
    if (ofloor > floor) {
      floor = ofloor;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return floor;
}


//==========================================================================
//
//  FindNextHighestFloor
//
//  Passed a sector, returns the value of the smallest floor height in a
//  surrounding sector larger than the floor height of passed sector. If no
//  such height exists the floor height of passed sector is returned.
//
//  Rewritten by Lee Killough to avoid fixed array and to be faster
//
//==========================================================================
final float FindNextHighestFloor (sector_t *sec, TVec *v) {
  if (sec.lines.length == 0) return sec.floor.maxz;
  TVec spot = *sec->lines[0]->v1;
  float height = GetPlanePointZ(ref sec->floor, spot);
  float heightdiff = float.max;
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (!other) continue;

    float ofloor = GetPlanePointZ(ref other->floor, *check->v1);
    float floor = GetPlanePointZ(ref sec->floor, *check->v1);
    if (ofloor > floor && ofloor-floor < heightdiff) {
      heightdiff = ofloor-floor;
      height = ofloor;
      spot = *check->v1;
    }

    ofloor = GetPlanePointZ(ref other->floor, *check->v2);
    floor = GetPlanePointZ(ref sec->floor, *check->v2);
    if (ofloor > floor && ofloor-floor < heightdiff) {
      heightdiff = ofloor-floor;
      height = ofloor;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


//==========================================================================
//
//  FindNextLowestFloor
//
//  Passed a sector, returns the value of the largest floor height in a
//  surrounding sector smaller than the floor height of passed sector. If no
//  such height exists the floor height of passed sector is returned.
//
//  jff 02/03/98 Twiddled Lee's P_FindNextHighestFloor to make this
//
//==========================================================================
final float FindNextLowestFloor (sector_t *sec, TVec *v) {
  if (sec.lines.length == 0) return sec.floor.maxz;
  TVec spot = *sec->lines[0]->v1;
  float height = GetPlanePointZ(ref sec->floor, spot);
  float heightdiff = float.max;
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (!other) continue;

    float ofloor = GetPlanePointZ(ref other->floor, *check->v1);
    float floor = GetPlanePointZ(ref sec->floor, *check->v1);
    if (ofloor < floor && floor-ofloor < heightdiff) {
      heightdiff = floor-ofloor;
      height = ofloor;
      spot = *check->v1;
    }

    ofloor = GetPlanePointZ(ref other->floor, *check->v2);
    floor = GetPlanePointZ(ref sec->floor, *check->v2);
    if (ofloor < floor && floor-ofloor < heightdiff) {
      heightdiff = floor-ofloor;
      height = ofloor;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


//==========================================================================
//
//  FindNextLowestCeiling
//
//  Passed a sector, returns the value of the largest ceiling height in a
//  surrounding sector smaller than the ceiling height of passed sector. If
//  no such height exists the ceiling height of passed sector is returned.
//
//  jff 02/03/98 Twiddled Lee's P_FindNextHighestFloor to make this
//
//==========================================================================
final float FindNextLowestCeiling (sector_t *sec, TVec *v) {
  if (sec.lines.length == 0) return sec.ceiling.minz; //k8: gozzo uses floor here; why?
  TVec spot = *sec->lines[0]->v1;
  float height = GetPlanePointZ(ref sec->ceiling, spot);
  float heightdiff = float.max;
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (!other) continue;

    float oceil = GetPlanePointZ(ref other->ceiling, *check->v1);
    float ceil = GetPlanePointZ(ref sec->ceiling, *check->v1);
    if (oceil < ceil && ceil-oceil < heightdiff) {
      heightdiff = ceil-oceil;
      height = oceil;
      spot = *check->v1;
    }

    oceil = GetPlanePointZ(ref other->ceiling, *check->v2);
    ceil = GetPlanePointZ(ref sec->ceiling, *check->v2);
    if (oceil < ceil && ceil-oceil < heightdiff) {
      heightdiff = ceil-oceil;
      height = oceil;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


//==========================================================================
//
//  FindNextHighestCeiling
//
//  Passed a sector, returns the value of the smallest ceiling height in a
//  surrounding sector larger than the ceiling height of passed sector. If
//  no such height exists the ceiling height of passed sector is returned.
//
//  jff 02/03/98 Twiddled Lee's P_FindNextHighestFloor to make this
//
//==========================================================================
final float FindNextHighestCeiling (sector_t *sec, TVec *v) {
  if (sec.lines.length == 0) return sec.ceiling.minz;
  TVec spot = *sec->lines[0]->v1;
  float height = GetPlanePointZ(ref sec->ceiling, spot);
  float heightdiff = float.max;
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (!other) continue;

    float oceil = GetPlanePointZ(ref other->ceiling, *check->v1);
    float ceil = GetPlanePointZ(ref sec->ceiling, *check->v1);
    if (oceil > ceil && oceil-ceil < heightdiff) {
      heightdiff = oceil-ceil;
      height = oceil;
      spot = *check->v1;
    }

    oceil = GetPlanePointZ(ref other->ceiling, *check->v2);
    ceil = GetPlanePointZ(ref sec->ceiling, *check->v2);
    if (oceil > ceil && oceil-ceil < heightdiff) {
      heightdiff = oceil-ceil;
      height = oceil;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


//==========================================================================
//
//  FindLowestCeilingSurrounding
//
//  find lowest ceiling in the surrounding sectors
//
//==========================================================================
final float FindLowestCeilingSurrounding (sector_t *sec, TVec *v) {
  if (sec.lines.length == 0) return sec.ceiling.minz;
  TVec spot = *sec->lines[0]->v1;
  float height = float.max;
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (!other) continue;

    float oceil = GetPlanePointZ(ref other->ceiling, *check->v1);
    if (oceil < height) {
      height = oceil;
      spot = *check->v1;
    }

    oceil = GetPlanePointZ(ref other->ceiling, *check->v2);
    if (oceil < height) {
      height = oceil;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


//==========================================================================
//
//  FindHighestCeilingSurrounding
//
//  find highest ceiling in the surrounding sectors
//
//==========================================================================
final float FindHighestCeilingSurrounding (sector_t *sec, TVec *v) {
  if (sec.lines.length == 0) return sec.ceiling.minz;
  TVec spot = *sec->lines[0]->v1;
  float height = -float.max;
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (!other) continue;

    float oceil = GetPlanePointZ(ref other->ceiling, *check->v1);
    if (oceil > height) {
      height = oceil;
      spot = *check->v1;
    }

    oceil = GetPlanePointZ(ref other->ceiling, *check->v2);
    if (oceil > height) {
      height = oceil;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


//==========================================================================
//
//  FindShortestTextureAround
//
//  Passed a sector number, returns the shortest lower texture on a
//  linedef bounding the sector.
//
//  jff 02/03/98 Add routine to find shortest lower texture
//
//==========================================================================
final float FindShortestTextureAround (sector_t *sec) {
  float minsize = 99999.0;
  foreach (int i; 0..sec.lines.length) {
    if (!(sec->lines[i]->flags&ML_TWOSIDED)) continue;

    int texnum = XLevel.Sides[sec->lines[i]->sidenum[0]].BottomTexture;
    if (texnum > 0 || (texnum == 0 && CompatShortTex)) {
      if (TextureHeight(texnum) < minsize) minsize = TextureHeight(texnum);
    }

    int s2i = sec->lines[i]->sidenum[1];
    if (s2i >= 0) {
      texnum = XLevel.Sides[s2i].BottomTexture;
      if (texnum > 0 || (texnum == 0 && CompatShortTex)) {
        if (TextureHeight(texnum) < minsize) minsize = TextureHeight(texnum);
      }
    }
  }
  return (minsize < 99999.0 ? minsize : TextureHeight(0));
}


//==========================================================================
//
//  FindShortestUpperAround
//
//  Passed a sector number, returns the shortest upper texture on a
//  linedef bounding the sector.
//
//  Note: If no upper texture exists MAXINT is returned.
//
//  jff 03/20/98 Add routine to find shortest upper texture
//
//==========================================================================
final float FindShortestUpperAround (sector_t *sec) {
  float minsize = 99999.0;
  foreach (int i; 0..sec.lines.length) {
    if (!(sec->lines[i]->flags&ML_TWOSIDED)) continue;

    int texnum = XLevel.Sides[sec->lines[i]->sidenum[0]].TopTexture;
    if (texnum > 0 || (texnum == 0 && CompatShortTex)) {
      if (TextureHeight(texnum) < minsize) minsize = TextureHeight(texnum);
    }

    int s2i = sec->lines[i]->sidenum[1];
    if (s2i >= 0) {
      texnum = XLevel.Sides[s2i].TopTexture;
      if (texnum > 0 || (texnum == 0 && CompatShortTex)) {
        if (TextureHeight(texnum) < minsize) minsize = TextureHeight(texnum);
      }
    }
  }
  return (minsize < 99999.0 ? minsize : TextureHeight(0));
}


//==========================================================================
//
//  FindModelFloorSector
//
//  Passed a floor height and a sector number, return a pointer to a
//  a sector with that floor height across the lowest numbered two sided
//  line surrounding the sector.
//
//  Note: If no sector at that height bounds the sector passed, return nullptr
//
//  jff 02/03/98 Add routine to find numeric model floor
//               around a sector specified by sector number
//  jff 3/14/98 change first parameter to plain height to allow call
//              from routine not using floormove_t
//
//==========================================================================
final sector_t *FindModelFloorSector (sector_t *sec, float height) {
  //jff 5/23/98 don't disturb sec.lines.length while searching, but allow early exit in old demos (???)
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (other &&
        (GetPlanePointZ(ref other->floor, *check->v1) == height ||
         GetPlanePointZ(ref other->floor, *check->v2) == height))
    {
      return other;
    }
  }
  return nullptr;
}


//==========================================================================
//
//  FindModelCeilingSector
//
//  Passed a ceiling height and a sector number, return a pointer to a
//  a sector with that ceiling height across the lowest numbered two sided
//  line surrounding the sector.
//
//  Note: If no sector at that height bounds the sector passed, return nullptr
//
//  jff 02/03/98 Add routine to find numeric model ceiling
//               around a sector specified by sector number
//               used only from generalised ceiling types
//  jff 3/14/98 change first parameter to plain height to allow call
//              from routine not using ceiling_t
//
//==========================================================================
final sector_t *FindModelCeilingSector (sector_t *sec, float height) {
  //jff 5/23/98 don't disturb sec.lines.length while searching, but allow early exit in old demos (???)
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (other &&
        (GetPlanePointZ(ref other->ceiling, *check->v1) == height ||
         GetPlanePointZ(ref other->ceiling, *check->v2) == height))
    {
      return other;
    }
  }
  return nullptr;
}


//==========================================================================
//
//  FindMinSurroundingLight
//
//  Find minimum light from an adjacent sector
//
//==========================================================================
final int FindMinSurroundingLight (sector_t *sector, int min) {
  foreach (int i; 0..sector.lines.length) {
    line_t *line = sector->lines[i];
    sector_t *check = getNextSector(line, sector);
    if (!check) continue;

    if (check->params.lightlevel < min) min = check->params.lightlevel;
  }
  return min;
}


//==========================================================================
//
//  FindHighestFloorPoint
//
//  Find the highest point on the floor of the sector
//
//==========================================================================
final float FindHighestFloorPoint (sector_t *sec, TVec *v) {
  if (!sec->floor.normal.x && !sec->floor.normal.y) {
    if (v) *v = *sec->lines[0]->v1;
    return sec->floor.dist;
  }

  TVec spot;
  float height = -float.max;
  foreach (int i; 0..sec.lines.length) {
    line_t *line = sec->lines[i];

    float probeheight = GetPlanePointZ(ref sec->floor, *line->v1);
    if (probeheight > height) {
      height = probeheight;
      spot = *line->v1;
    }

    probeheight = GetPlanePointZ(ref sec->floor, *line->v2);
    if (probeheight > height)
    {
      height = probeheight;
      spot = *line->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


//==========================================================================
//
//  FindLowestCeilingPoint
//
//  Find the lowest point on the ceiling of the sector
//
//==========================================================================
final float FindLowestCeilingPoint (sector_t *sec, TVec *v) {
  if (!sec->ceiling.normal.x && !sec->ceiling.normal.y) {
    if (v) *v = *sec->lines[0]->v1;
    return -sec->ceiling.dist;
  }

  TVec spot;
  float height = float.max;
  foreach (int i; 0..sec.lines.length) {
    line_t *line = sec->lines[i];
    float probeheight = GetPlanePointZ(ref sec->ceiling, *line->v1);
    if (probeheight < height) {
      height = probeheight;
      spot = *line->v1;
    }

    probeheight = GetPlanePointZ(ref sec->ceiling, *line->v2);
    if (probeheight < height) {
      height = probeheight;
      spot = *line->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


struct AllTouchingThingsIter {
  VLevel xlevel;
  sector_t *sec;
  msecnode_t *currnode;
}


//==========================================================================
//
//  allTouchingThings
//
//==========================================================================
final bool allTouchingThings_opIterInit (out AllTouchingThingsIter it, sector_t *sec) {
  it.xlevel = XLevel;
  it.sec = sec;
  it.currnode = (sec ? sec->TouchingThingList : nullptr);
  return !!it.currnode;
}


static final bool allTouchingThings_opIterNext (ref AllTouchingThingsIter it, out EntityEx ent) {
  while (it.currnode) {
    ent = EntityEx(it.currnode->Thing);
    it.currnode = it.currnode->SNext;
    if (ent) return true;
  }
  return false;
}


//==========================================================================
//
//  SpawnMapThing
//
//==========================================================================
void SpawnMapThing (mthing_t *mthing) {
}


//==========================================================================
//
//  CopyMThing
//
//==========================================================================
final void CopyMThing (mthing_t *from, mthing_t *to) {
  to->tid = from->tid;
  to->x = from->x;
  to->y = from->y;
  to->height = from->height;
  to->angle = from->angle;
  to->pitch = from->pitch;
  to->roll = from->roll;
  to->type = from->type;
  to->options = from->options;
  to->SkillClassFilter = from->SkillClassFilter;
  to->special = from->special;
  foreach (int f; 0..from->args.length) to->args[f] = from->args[f];
  to->health = from->health;
  to->scaleX = from->scaleX;
  to->scaleY = from->scaleY;
  to->gravity = from->gravity;
  to->arg0str = from->arg0str;
  to->renderStyle = from->renderStyle;
  to->renderAlpha = from->renderAlpha;
  to->stencilColor = from->stencilColor;
  to->conversationId = from->conversationId;
  // flags
  to->bUseHealth = from->bUseHealth;
  to->bUseScaleX = from->bUseScaleX;
  to->bUseScaleY = from->bUseScaleY;
  to->bUseGravity = from->bUseGravity;
  to->bUseArg0Str = from->bUseArg0Str;
  to->bUsePitch = from->bUsePitch;
  to->bUseRoll = from->bUseRoll;
  to->bUseRenderStyle = from->bUseRenderStyle;
  to->bUseRenderAlpha = from->bUseRenderAlpha;
  to->bUseStencilColor = from->bUseStencilColor;
  to->UseConversationId = from->UseConversationId;
  to->bCountAsSecret = from->bCountAsSecret;
}


//==========================================================================
//
//  GetPlayerStart
//
//==========================================================================
final mthing_t *GetPlayerStart (int PNum, int Position, optional bool failIfNotFound) {
  if (!specified_failIfNotFound) failIfNotFound = true;
  ++PNum;
  mthing_t *Best = nullptr;
  foreach (int i; 0..PlayerStarts.length; reverse) {
    if (PlayerStarts[i].type != PNum) continue;
    if (PlayerStarts[i].args[0] == Position) return &PlayerStarts[i];
    if (!Best) Best = &PlayerStarts[i];
  }
  if (failIfNotFound) {
    if (!Best) Error("Player %d has no start spots (GetPlayerStart)", PNum);
    print("Player %d has no start spot for position %d", PNum, Position);
  }
  return Best;
}


//==========================================================================
//
//  ParticleEffect
//
//==========================================================================
void ParticleEffect (int count, int type1, int type2, TVec origin, float ornd,
                     TVec velocity, float vrnd, float acceleration, float grav,
                     int color, float duration, float ramp, optional TVec accelV)
{
}


//==========================================================================
//
//  UpdateParticle
//
//==========================================================================
void UpdateParticle (particle_t *p, float DeltaTime) {
}


//==========================================================================
//
//  AcsSpawnThing
//
//==========================================================================
int AcsSpawnThing (name Name, TVec Org, int Tid, float Angle, bool forced) {
  return false;
}


//==========================================================================
//
//  AcsSpawnSpot
//
//==========================================================================
int AcsSpawnSpot (name Name, int SpotTid, int Tid, float Angle, bool forced) {
  return false;
}


//==========================================================================
//
//  AcsSpawnSpotFacing
//
//==========================================================================
int AcsSpawnSpotFacing (name Name, int SpotTid, int Tid, bool forced) {
  return false;
}


//==========================================================================
//
//  AcsDamageActor
//
//==========================================================================
int AcsDamageActor (int targettid, int targetptr, int inflictortid, int inflictorptr,
                    int damage, name damagetype, Entity Activator)
{
  return 0;
}


//==========================================================================
//
//  AcsSpawnDecal
//
//==========================================================================
int AcsSpawnDecal (Entity ent, name decalname, TVec org, float dist, float angle, bool permanent) {
  return 0;
}


//==========================================================================
//
//  AcsPolyMoveRotateEx
//
//==========================================================================
int AcsPolyMoveRotateEx (int po, int hspeed, int yawangle, int dist,
                         int vspeed, int vdist, float deltaangle, int moveflags, Entity Activator)
{
  return 0;
}


//==========================================================================
//
//  AcsPolyMoveToRotateEx
//
//==========================================================================
int AcsPolyMoveToRotateEx (int po, int speed, int x, int y, int z, float deltaangle, int moveflags, Entity Activator) {
  return 0;
}


//==========================================================================
//
//  AcsPolyMoveToSpotRotateEx
//
//  this uses target height too
//
//==========================================================================
int AcsPolyMoveToSpotRotateEx (int po, int speed, int targettid, float deltaangle, int moveflags, Entity Activator) {
  return 0;
}


//==========================================================================
//
//  AcsPolyRotateEx
//
//==========================================================================
int AcsPolyRotateEx (int po, int speed, float deltaangle, int moveflags, Entity Activator) {
  return 0;
}


//==========================================================================
//
//  SectorDamage
//
//==========================================================================
void SectorDamage (int Tag, int Amount, name DamageType, name ProtectionType, int Flags) {
}


//==========================================================================
//
//  DoThingDamage
//
//==========================================================================
int DoThingDamage (int Tid, int Amount, name DmgType, Entity Activator) {
  return 0;
}


//==========================================================================
//
//  SetMarineWeapon
//
//==========================================================================
void SetMarineWeapon (int Tid, int Weapon, Entity Activator) {
}


//==========================================================================
//
//  SetMarineSprite
//
//==========================================================================
void SetMarineSprite (int Tid, name SrcClassName, Entity Activator) {
}


//==========================================================================
//
//  AcsFadeRange
//
//==========================================================================
void AcsFadeRange (float BlendR1, float BlendG1, float BlendB1, float BlendA1,
                   float BlendR2, float BlendG2, float BlendB2, float BlendA2,
                   float Duration, Entity Activator)
{
}


//==========================================================================
//
//  AcsCancelFade
//
//==========================================================================
void AcsCancelFade (Entity Activator) {
}


//==========================================================================
//
//  AcsRadiusQuake2
//
//==========================================================================
void AcsRadiusQuake2 (Entity Activator, int tid, int intensity, int duration, int damrad, int tremrad, name sound) {
}


//==========================================================================
//
//  AcsWarp
//
//==========================================================================
void AcsWarp (Entity Activator, int tid, float xofs, float yofs, float zofs, float angle, int flags,
              name succState, bool exact, float heightoffset, float radiusoffset, float pitch)
{
}


defaultproperties {
  bAlwaysRelevant = true;
  AirControl = 1.0/256.0;
}
