//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class LevelInfo : Thinker native abstract;

const int TID_HASH_SIZE = 128;

struct MapSpecialAction {
  name TypeName;
  int Special;
  int Args[5];
};

native readonly GameInfo Game;
native readonly WorldInfo World;

string LevelName;
int LevelNum;
ubyte Cluster;

name NextMap;
name SecretMap;

int ParTime;
int SuckTime;

int Sky1Texture;
int Sky2Texture;
float Sky1ScrollDelta;
float Sky2ScrollDelta;
name SkyBox;

name FadeTable;
int Fade;
int OutsideFog;

name SongLump;

bool bDoubleSky; // parallax sky: sky2 behind sky1
bool bLightning; // use of lightning on the level flashes from sky1 to sky2
// special actions, as set in MAPINFO
bool bMap07Special;
bool bBaronSpecial;
bool bCyberDemonSpecial;
bool bSpiderMastermindSpecial;
bool bMinotaurSpecial;
bool bDSparilSpecial;
bool bIronLichSpecial;
bool bSpecialActionOpenDoor;
bool bSpecialActionLowerFloor;
bool bSpecialActionKillMonsters;
bool bNoIntermission;
bool bAllowMonsterTelefrags;
bool bNoAllies;
bool bDeathSlideShow;
bool bForceNoSkyStretch;
bool bLookupName;
bool bFallingDamage;
bool bOldFallingDamage;
bool bStrifeFallingDamage;
bool bMonsterFallingDamage;
bool bNoFreelook;
bool bNoJump;
bool bNoAutoSndSeq;
bool bActivateOwnSpecial;
bool bMissilesActivateImpact;
bool bFilterStarts;
bool bInfiniteFlightPowerup;
bool bClipMidTex;
bool bWrapMidTex;
bool bKeepFullInventory;

bool bCompatShortTex;
bool bCompatStairs;
bool bCompatLimitPain;
bool bCompatNoPassOver;
bool bCompatNoTossDrops;
bool bCompatUseBlocking;
bool bCompatNoDoorLight;
bool bCompatRavenScroll;
bool bCompatSoundTarget;
bool bCompatDehHealth;
bool bCompatTrace;
bool bCompatDropOff;
bool bCompatBoomScroll;
bool bCompatInvisibility;
bool bLaxMonsterActivation;
bool bHaveMonsterActivation;
bool bClusterHub;
readonly bool bBegunPlay;
bool bFrozen;

int TotalKills;
int TotalItems;
int TotalSecret; // for intermission
int CurrentKills;
int CurrentItems;
int CurrentSecret;

float CompletitionTime; // for intermission

// maintain single and multi player starting spots
array!mthing_t DeathmatchStarts; // player spawn spots for deathmatch
array!mthing_t PlayerStarts; // player spawn spots

private Entity TIDHash[TID_HASH_SIZE];

float Gravity; // level gravity
float AirControl;
int Infighting;
array!MapSpecialAction SpecialActions;


replication {
  reliable if (Role == ROLE_Authority)
    LevelName, Cluster, ParTime, SuckTime, Sky1Texture, Sky2Texture,
    Sky1ScrollDelta, Sky2ScrollDelta, SkyBox, FadeTable, Fade, OutsideFog,
    SongLump, bDoubleSky, bLightning, bNoIntermission,
    bForceNoSkyStretch, bLookupName, TotalKills, TotalItems, TotalSecret,
    CurrentKills, CurrentItems, CurrentSecret, CompletitionTime,
    bNoFreelook;
}


bool CompatShortTex { get { return bCompatShortTex || GetCvar('compat_shorttex'); } }
bool CompatStairs { get { return bCompatStairs || GetCvar('compat_stairs'); } }
bool CompatLimitPain { get { return bCompatLimitPain || GetCvar('compat_limitpain'); } }
bool CompatNoPassOver { get { return bCompatNoPassOver || GetCvar('compat_nopassover'); } }
bool CompatNoTossDrops { get { return bCompatNoTossDrops || GetCvar('compat_notossdrops'); } }
bool CompatUseBlocking { get { return bCompatUseBlocking || GetCvar('compat_useblocking'); } }
bool CompatNoDoorLight { get { return bCompatNoDoorLight || GetCvar('compat_nodoorlight'); } }
bool CompatRavenScroll { get { return bCompatRavenScroll || GetCvar('compat_ravenscroll'); } }
bool CompatSoundTarget { get { return bCompatSoundTarget || GetCvar('compat_soundtarget'); } }
bool CompatDehHealth { get { return bCompatDehHealth || GetCvar('compat_dehhealth'); } }
bool CompatTrace { get { return bCompatTrace || GetCvar('compat_trace'); } }
bool CompatDropOff { get { return bCompatDropOff || GetCvar('compat_dropoff'); } }
bool CompatBoomScroll { get { return bCompatBoomScroll || GetCvar('compat_boomscroll'); } }
bool CompatInvisibility { get { return bCompatInvisibility || GetCvar('compat_invisibility'); } }

// ////////////////////////////////////////////////////////////////////////// //
// static lights
native final void AddStaticLight (TVec origin, float radius);
native final void AddStaticLightRGB (TVec origin, float radius, int colour);

// ////////////////////////////////////////////////////////////////////////// //
// sound sequences
native final void SectorStartSequence (sector_t *sector, name sequence, int ModeNum);
native final void SectorStopSequence (sector_t *sector);
native final void PolyobjStartSequence (polyobj_t *mobj, name sequence, int ModeNum);
native final void PolyobjStopSequence (polyobj_t *mobj);

// ////////////////////////////////////////////////////////////////////////// //
// exiting the level
native final void ExitLevel (int Position);
native final void SecretExitLevel (int Position);
native final void Completed (int Map, int Position, int SaveAngle);

// ////////////////////////////////////////////////////////////////////////// //
// special thinker utilites
native final bool ChangeSwitchTexture (int SideNum, int useAgain, name DefaultSound, out ubyte Quest);
native final Entity FindMobjFromTID (int tid, Entity Prev);
native final void AutoSave ();

native final void ChangeMusic (name SongName);

native final int FindFreeTID (optional int tidstart, optional int limit);
native final bool IsTIDUsed (int tid);


// ////////////////////////////////////////////////////////////////////////// //
struct MobjByTIDIteratorInfo {
  Entity prev;
  int tid; // 0: use activator (it is in prev)
}

final bool eachTID_opIterInit (out MobjByTIDIteratorInfo it, int tid, optional Entity activator) {
  if (tid == 0) {
    // 0 is activator
    if (!activator) return false;
    it.prev = activator;
  } else {
    // get first entity
    it.prev = FindMobjFromTID(tid, none);
    if (!it.prev) return false; // no entities, do not iterate
  }
  it.tid = tid;
  return true;
}

final bool eachTID_opIterNext (out MobjByTIDIteratorInfo it, out Entity ent) {
  ent = it.prev;
  if (!ent) return false; // done
  it.prev = (it.tid ? FindMobjFromTID(it.tid, ent) : none);
  return true;
}


//==========================================================================
//
//  SpawnSpecials
//
//==========================================================================
void SpawnSpecials () {
}


//==========================================================================
//
//  UpdateSpecials
//
//==========================================================================
void UpdateSpecials () {
}


//==========================================================================
//
//  AfterUnarchiveThinkers
//
//==========================================================================
void AfterUnarchiveThinkers () {
}


//==========================================================================
//
//  PolyThrustMobj
//
//==========================================================================
void PolyThrustMobj (Entity A, TVec thrustDir, polyobj_t *po) {
}


//==========================================================================
//
//  PolyCrushMobj
//
//==========================================================================
void PolyCrushMobj (Entity A, polyobj_t *po) {
}


//==========================================================================
//
//  TagBusy
//
//==========================================================================
bool TagBusy (int tag) {
  int sectorIndex;
  for (sectorIndex = XLevel.FindSectorFromTag(tag, -1); sectorIndex >= 0;
       sectorIndex = XLevel.FindSectorFromTag(tag, sectorIndex))
  {
    if (XLevel.Sectors[sectorIndex].FloorData || XLevel.Sectors[sectorIndex].CeilingData) {
      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  PolyBusy
//
//==========================================================================
bool PolyBusy (int polyobj) {
  return false;
}


//==========================================================================
//
//  ThingCount
//
//==========================================================================
int ThingCount (int type, name TypeName, int tid, int SectorTag) {
  return 0;
}


//==========================================================================
//
//  ExecuteActionSpecial
//
//==========================================================================
int ExecuteActionSpecial (int Special, int Arg1, int Arg2, int Arg3,
                          int Arg4, int Arg5, line_t *line, int side, Entity A)
{
  return 0;
}


//==========================================================================
//
//  EV_ThingProjectile
//
//==========================================================================
bool EV_ThingProjectile (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
                         int gravity, int newtid, name TypeName, Entity Activator)
{
  return false;
}


//==========================================================================
//
//  StartPlaneWatcher
//
//==========================================================================
void StartPlaneWatcher (Entity it, line_t *line, int lineSide, bool ceiling,
                        int tag, int height, int special, int arg0, int arg1,
                        int arg2, int arg3, int arg4)
{
}


//**************************************************************************
//**
//**    special thinker utilites
//**
//**************************************************************************

//==========================================================================
//
//  getNextSector
//
//  Return sector_t* of sector next to current. nullptr if not two-sided line
//
//==========================================================================
final sector_t *getNextSector (line_t *line, sector_t *sec) {
  if (!(line->flags&ML_TWOSIDED)) return nullptr;

  if (line->frontsector == sec) {
    if (line->backsector == sec) return nullptr;
    return line->backsector;
  }

  return line->frontsector;
}


//==========================================================================
//
//  FindLowestFloorSurrounding
//
//  find lowest floor height in surrounding sectors
//
//==========================================================================
final float FindLowestFloorSurrounding (sector_t *sec, TVec *v) {
  TVec spot = *sec->lines[0]->v1;
  float floor = GetPlanePointZ(ref sec->floor, spot);
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);

    if (!other) continue;

    float ofloor = GetPlanePointZ(ref other->floor, *check->v1);
    if (ofloor < floor && ofloor < GetPlanePointZ(ref sec->floor, *check->v1)) {
      floor = ofloor;
      spot = *check->v1;
    }

    ofloor = GetPlanePointZ(ref other->floor, *check->v2);
    if (ofloor < floor && ofloor < GetPlanePointZ(ref sec->floor, *check->v2)) {
      floor = ofloor;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return floor;
}


//==========================================================================
//
//  FindHighestFloorSurrounding
//
//  find highest floor height in surrounding sectors
//
//==========================================================================
final float FindHighestFloorSurrounding (sector_t *sec, TVec *v) {
  TVec spot = *sec->lines[0]->v1;
  float floor = -99999.0;
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (!other) continue;

    float ofloor = GetPlanePointZ(ref other->floor, *check->v1);
    if (ofloor > floor) {
      floor = ofloor;
      spot = *check->v1;
    }

    ofloor = GetPlanePointZ(ref other->floor, *check->v2);
    if (ofloor > floor) {
      floor = ofloor;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return floor;
}


//==========================================================================
//
//  FindNextHighestFloor
//
//  Passed a sector, returns the value of the smallest floor height in a
//  surrounding sector larger than the floor height of passed sector. If no
//  such height exists the floor height of passed sector is returned.
//
//  Rewritten by Lee Killough to avoid fixed array and to be faster
//
//==========================================================================
final float FindNextHighestFloor (sector_t *sec, TVec *v) {
  TVec spot = *sec->lines[0]->v1;
  float height = GetPlanePointZ(ref sec->floor, spot);
  float heightdiff = 99999.0;
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (!other) continue;

    float ofloor = GetPlanePointZ(ref other->floor, *check->v1);
    float floor = GetPlanePointZ(ref sec->floor, *check->v1);
    if (ofloor > floor && ofloor-floor < heightdiff) {
      heightdiff = ofloor-floor;
      height = ofloor;
      spot = *check->v1;
    }

    ofloor = GetPlanePointZ(ref other->floor, *check->v2);
    floor = GetPlanePointZ(ref sec->floor, *check->v2);
    if (ofloor > floor && ofloor-floor < heightdiff) {
      heightdiff = ofloor-floor;
      height = ofloor;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


//==========================================================================
//
//  FindNextLowestFloor
//
//  Passed a sector, returns the value of the largest floor height in a
//  surrounding sector smaller than the floor height of passed sector. If no
//  such height exists the floor height of passed sector is returned.
//
//  jff 02/03/98 Twiddled Lee's P_FindNextHighestFloor to make this
//
//==========================================================================
final float FindNextLowestFloor (sector_t *sec, TVec *v) {
  TVec spot = *sec->lines[0]->v1;
  float height = GetPlanePointZ(ref sec->floor, spot);
  float heightdiff = 99999.0;
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (!other) continue;

    float ofloor = GetPlanePointZ(ref other->floor, *check->v1);
    float floor = GetPlanePointZ(ref sec->floor, *check->v1);
    if (ofloor < floor && floor-ofloor < heightdiff) {
      heightdiff = floor-ofloor;
      height = ofloor;
      spot = *check->v1;
    }

    ofloor = GetPlanePointZ(ref other->floor, *check->v2);
    floor = GetPlanePointZ(ref sec->floor, *check->v2);
    if (ofloor < floor && floor-ofloor < heightdiff) {
      heightdiff = floor-ofloor;
      height = ofloor;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


//==========================================================================
//
//  FindNextLowestCeiling
//
//  Passed a sector, returns the value of the largest ceiling height in a
//  surrounding sector smaller than the ceiling height of passed sector. If
//  no such height exists the ceiling height of passed sector is returned.
//
//  jff 02/03/98 Twiddled Lee's P_FindNextHighestFloor to make this
//
//==========================================================================
final float FindNextLowestCeiling (sector_t *sec, TVec *v) {
  TVec spot = *sec->lines[0]->v1;
  float height = GetPlanePointZ(ref sec->ceiling, spot);
  float heightdiff = 99999.0;
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (!other) continue;

    float oceil = GetPlanePointZ(ref other->ceiling, *check->v1);
    float ceil = GetPlanePointZ(ref sec->ceiling, *check->v1);
    if (oceil < ceil && ceil-oceil < heightdiff) {
      heightdiff = ceil-oceil;
      height = oceil;
      spot = *check->v1;
    }

    oceil = GetPlanePointZ(ref other->ceiling, *check->v2);
    ceil = GetPlanePointZ(ref sec->ceiling, *check->v2);
    if (oceil < ceil && ceil-oceil < heightdiff) {
      heightdiff = ceil-oceil;
      height = oceil;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


//==========================================================================
//
//  FindNextHighestCeiling
//
//  Passed a sector, returns the value of the smallest ceiling height in a
//  surrounding sector larger than the ceiling height of passed sector. If
//  no such height exists the ceiling height of passed sector is returned.
//
//  jff 02/03/98 Twiddled Lee's P_FindNextHighestFloor to make this
//
//==========================================================================
final float FindNextHighestCeiling (sector_t *sec, TVec *v) {
  TVec spot = *sec->lines[0]->v1;
  float height = GetPlanePointZ(ref sec->ceiling, spot);
  float heightdiff = 99999.0;
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (!other) continue;

    float oceil = GetPlanePointZ(ref other->ceiling, *check->v1);
    float ceil = GetPlanePointZ(ref sec->ceiling, *check->v1);
    if (oceil > ceil && oceil-ceil < heightdiff) {
      heightdiff = oceil-ceil;
      height = oceil;
      spot = *check->v1;
    }

    oceil = GetPlanePointZ(ref other->ceiling, *check->v2);
    ceil = GetPlanePointZ(ref sec->ceiling, *check->v2);
    if (oceil > ceil && oceil-ceil < heightdiff) {
      heightdiff = oceil-ceil;
      height = oceil;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


//==========================================================================
//
//  FindLowestCeilingSurrounding
//
//  find lowest ceiling in the surrounding sectors
//
//==========================================================================
final float FindLowestCeilingSurrounding (sector_t *sec, TVec *v) {
  TVec spot = *sec->lines[0]->v1;
  float height = 99999.0;
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (!other) continue;

    float oceil = GetPlanePointZ(ref other->ceiling, *check->v1);
    if (oceil < height) {
      height = oceil;
      spot = *check->v1;
    }

    oceil = GetPlanePointZ(ref other->ceiling, *check->v2);
    if (oceil < height) {
      height = oceil;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


//==========================================================================
//
//  FindHighestCeilingSurrounding
//
//  find highest ceiling in the surrounding sectors
//
//==========================================================================
final float FindHighestCeilingSurrounding (sector_t *sec, TVec *v) {
  TVec spot = *sec->lines[0]->v1;
  float height = -99999.0;
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (!other) continue;

    float oceil = GetPlanePointZ(ref other->ceiling, *check->v1);
    if (oceil > height) {
      height = oceil;
      spot = *check->v1;
    }

    oceil = GetPlanePointZ(ref other->ceiling, *check->v2);
    if (oceil > height) {
      height = oceil;
      spot = *check->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


//==========================================================================
//
//  FindShortestTextureAround
//
//  Passed a sector number, returns the shortest lower texture on a
//  linedef bounding the sector.
//
//  jff 02/03/98 Add routine to find shortest lower texture
//
//==========================================================================
final float FindShortestTextureAround (sector_t *sec) {
  float minsize = 99999.0;
  foreach (int i; 0..sec.lines.length) {
    if (!(sec->lines[i]->flags&ML_TWOSIDED)) continue;

    int texnum = XLevel.Sides[sec->lines[i]->sidenum[0]].BottomTexture;
    if (texnum > 0 || (texnum == 0 && CompatShortTex)) {
      if (TextureHeight(texnum) < minsize) minsize = TextureHeight(texnum);
    }

    texnum = XLevel.Sides[sec->lines[i]->sidenum[1]].BottomTexture;
    if (texnum > 0 || (texnum == 0 && CompatShortTex)) {
      if (TextureHeight(texnum) < minsize) minsize = TextureHeight(texnum);
    }
  }
  return (minsize < 99999.0 ? minsize : TextureHeight(0));
}


//==========================================================================
//
//  FindShortestUpperAround
//
//  Passed a sector number, returns the shortest upper texture on a
//  linedef bounding the sector.
//
//  Note: If no upper texture exists MAXINT is returned.
//
//  jff 03/20/98 Add routine to find shortest upper texture
//
//==========================================================================
final float FindShortestUpperAround (sector_t *sec) {
  float minsize = 99999.0;
  foreach (int i; 0..sec.lines.length) {
    if ((sec->lines[i]->flags&ML_TWOSIDED)) continue;

    int texnum = XLevel.Sides[sec->lines[i]->sidenum[0]].TopTexture;
    if (texnum > 0 || (texnum == 0 && CompatShortTex)) {
      if (TextureHeight(texnum) < minsize) minsize = TextureHeight(texnum);
    }

    texnum = XLevel.Sides[sec->lines[i]->sidenum[1]].TopTexture;
    if (texnum > 0 || (texnum == 0 && CompatShortTex)) {
      if (TextureHeight(texnum) < minsize) minsize = TextureHeight(texnum);
    }
  }
  return minsize < 99999.0 ? minsize : TextureHeight(0);
}


//==========================================================================
//
//  FindModelFloorSector
//
//  Passed a floor height and a sector number, return a pointer to a
//  a sector with that floor height across the lowest numbered two sided
//  line surrounding the sector.
//
//  Note: If no sector at that height bounds the sector passed, return nullptr
//
//  jff 02/03/98 Add routine to find numeric model floor
//               around a sector specified by sector number
//  jff 3/14/98 change first parameter to plain height to allow call
//              from routine not using floormove_t
//
//==========================================================================
final sector_t *FindModelFloorSector (sector_t *sec, float height) {
  //jff 5/23/98 don't disturb sec.lines.length while searching, but allow early exit in old demos (???)
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (other &&
        (GetPlanePointZ(ref other->floor, *check->v1) == height ||
         GetPlanePointZ(ref other->floor, *check->v2) == height))
    {
      return other;
    }
  }
  return nullptr;
}


//==========================================================================
//
//  FindModelCeilingSector
//
//  Passed a ceiling height and a sector number, return a pointer to a
//  a sector with that ceiling height across the lowest numbered two sided
//  line surrounding the sector.
//
//  Note: If no sector at that height bounds the sector passed, return nullptr
//
//  jff 02/03/98 Add routine to find numeric model ceiling
//               around a sector specified by sector number
//               used only from generalised ceiling types
//  jff 3/14/98 change first parameter to plain height to allow call
//              from routine not using ceiling_t
//
//==========================================================================
final sector_t *FindModelCeilingSector (sector_t *sec, float height) {
  //jff 5/23/98 don't disturb sec.lines.length while searching, but allow early exit in old demos (???)
  foreach (int i; 0..sec.lines.length) {
    line_t *check = sec->lines[i];
    sector_t *other = getNextSector(check, sec);
    if (other &&
        (GetPlanePointZ(ref other->ceiling, *check->v1) == height ||
         GetPlanePointZ(ref other->ceiling, *check->v2) == height))
    {
      return other;
    }
  }
  return nullptr;
}


//==========================================================================
//
//  FindMinSurroundingLight
//
//  Find minimum light from an adjacent sector
//
//==========================================================================
final int FindMinSurroundingLight (sector_t *sector, int min) {
  foreach (int i; 0..sector.lines.length) {
    line_t *line = sector->lines[i];
    sector_t *check = getNextSector(line, sector);
    if (!check) continue;

    if (check->params.lightlevel < min) min = check->params.lightlevel;
  }
  return min;
}


//==========================================================================
//
//  FindHighestFloorPoint
//
//  Find the highest point on the floor of the sector
//
//==========================================================================
final float FindHighestFloorPoint (sector_t *sec, TVec *v) {
  if (!sec->floor.normal.x && !sec->floor.normal.y) {
    if (v) *v = *sec->lines[0]->v1;
    return sec->floor.dist;
  }

  TVec spot;
  float height = -99999.0;
  foreach (int i; 0..sec.lines.length) {
    line_t *line = sec->lines[i];

    float probeheight = GetPlanePointZ(ref sec->floor, *line->v1);
    if (probeheight > height) {
      height = probeheight;
      spot = *line->v1;
    }

    probeheight = GetPlanePointZ(ref sec->floor, *line->v2);
    if (probeheight > height)
    {
      height = probeheight;
      spot = *line->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


//==========================================================================
//
//  FindLowestCeilingPoint
//
//  Find the lowest point on the ceiling of the sector
//
//==========================================================================
final float FindLowestCeilingPoint (sector_t *sec, TVec *v) {
  if (!sec->ceiling.normal.x && !sec->ceiling.normal.y) {
    if (v) *v = *sec->lines[0]->v1;
    return -sec->ceiling.dist;
  }

  TVec spot;
  float height = 99999.0;
  foreach (int i; 0..sec.lines.length) {
    line_t *line = sec->lines[i];
    float probeheight = GetPlanePointZ(ref sec->ceiling, *line->v1);
    if (probeheight < height) {
      height = probeheight;
      spot = *line->v1;
    }

    probeheight = GetPlanePointZ(ref sec->ceiling, *line->v2);
    if (probeheight < height) {
      height = probeheight;
      spot = *line->v2;
    }
  }
  if (v) *v = spot;
  return height;
}


//==========================================================================
//
//  SpawnMapThing
//
//==========================================================================
void SpawnMapThing (mthing_t *mthing) {
}


//==========================================================================
//
//  CopyMThing
//
//==========================================================================
final void CopyMThing (mthing_t *from, mthing_t *to) {
  to->tid = from->tid;
  to->x = from->x;
  to->y = from->y;
  to->height = from->height;
  to->angle = from->angle;
  to->type = from->type;
  to->options = from->options;
  to->SkillClassFilter = from->SkillClassFilter;
  to->special = from->special;
  to->arg1 = from->arg1;
  to->arg2 = from->arg2;
  to->arg3 = from->arg3;
  to->arg4 = from->arg4;
  to->arg5 = from->arg5;
}


//==========================================================================
//
//  GetPlayerStart
//
//==========================================================================
final mthing_t *GetPlayerStart (int PNum, int Position) {
  mthing_t *Best = nullptr;
  foreach (int i; 0..PlayerStarts.Num; reverse) {
    if (PlayerStarts[i].type != PNum+1) continue;
    if (PlayerStarts[i].arg1 == Position) return &PlayerStarts[i];
    if (!Best) Best = &PlayerStarts[i];
  }

  if (!Best) Error("Player %d has no start spots", PNum+1);
  print("Player %d has no start spot for position %d", PNum+1, Position);
  return Best;
}


//==========================================================================
//
//  ParticleEffect
//
//==========================================================================
void ParticleEffect (int count, int type1, int type2, TVec origin, float ornd,
                     TVec velocity, float vrnd, float acceleration, float grav,
                     int colour, float duration, float ramp)
{
}


//==========================================================================
//
//  UpdateParticle
//
//==========================================================================
void UpdateParticle (particle_t *p, float DeltaTime) {
}


//==========================================================================
//
//  AcsSpawnThing
//
//==========================================================================
int AcsSpawnThing (name Name, TVec Org, int Tid, float Angle, bool forced) {
  return false;
}


//==========================================================================
//
//  AcsSpawnSpot
//
//==========================================================================
int AcsSpawnSpot (name Name, int SpotTid, int Tid, float Angle, bool forced) {
  return false;
}


//==========================================================================
//
//  AcsSpawnSpotFacing
//
//==========================================================================
int AcsSpawnSpotFacing (name Name, int SpotTid, int Tid, bool forced) {
  return false;
}


//==========================================================================
//
//  SectorDamage
//
//==========================================================================
void SectorDamage (int Tag, int Amount, name DamageType, name ProtectionType, int Flags) {
}


//==========================================================================
//
//  DoThingDamage
//
//==========================================================================
int DoThingDamage (int Tid, int Amount, name DmgType, Entity Activator) {
  return 0;
}


//==========================================================================
//
//  SetMarineWeapon
//
//==========================================================================
void SetMarineWeapon (int Tid, int Weapon, Entity Activator) {
}


//==========================================================================
//
//  SetMarineSprite
//
//==========================================================================
void SetMarineSprite (int Tid, name SrcClassName, Entity Activator) {
}


//==========================================================================
//
//  AcsFadeRange
//
//==========================================================================
void AcsFadeRange (float BlendR1, float BlendG1, float BlendB1, float BlendA1,
                   float BlendR2, float BlendG2, float BlendB2, float BlendA2,
                   float Duration, Entity Activator)
{
}


//==========================================================================
//
//  AcsCancelFade
//
//==========================================================================
void AcsCancelFade (Entity Activator) {
}


//==========================================================================
//
//  AcsRadiusQuake2
//
//==========================================================================
void AcsRadiusQuake2 (Entity Activator, int tid, int intensity, int duration, int damrad, int tremrad, name sound) {
}


defaultproperties {
  bAlwaysRelevant = true;
  AirControl = 1.0 / 256.0;
}
