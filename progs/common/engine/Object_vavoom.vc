//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//
//  VaVoom-specific things
//
//==========================================================================
const int MAXPLAYERS = 8;

// some defines for ACS (and other) flags
const int MF_SPECIAL = 0x00000001;
const int MF_SOLID = 0x00000002;
const int MF_SHOOTABLE = 0x00000004;
const int MF_NOSECTOR = 0x00000008;
const int MF_NOBLOCKMAP = 0x00000010;
const int MF_AMBUSH = 0x00000020;
const int MF_JUSTHIT = 0x00000040;
const int MF_JUSTATTACKED = 0x00000080;
const int MF_SPAWNCEILING = 0x00000100;
const int MF_NOGRAVITY = 0x00000200;
const int MF_DROPOFF = 0x00000400;
const int MF_PICKUP = 0x00000800;
const int MF_NOCLIP = 0x00001000;
const int MF_INCHASE = 0x00002000;
const int MF_FLOAT = 0x00004000;
const int MF_TELEPORT = 0x00008000;
const int MF_MISSILE = 0x00010000;
const int MF_DROPPED = 0x00020000;
const int MF_SHADOW = 0x00040000;
const int MF_NOBLOOD = 0x00080000;
const int MF_CORPSE = 0x00100000;
const int MF_INFLOAT = 0x00200000;
const int MF_INBOUNCE = 0x00200000;
const int MF_COUNTKILL = 0x00400000;
const int MF_COUNTITEM = 0x00800000;
const int MF_SKULLFLY = 0x01000000;
const int MF_NOTDMATCH = 0x02000000;
const int MF_SPAWNSOUNDSOURCE = 0x04000000;
const int MF_FRIENDLY = 0x08000000;
const int MF_UNMORPHED = 0x10000000;
const int MF_NOLIFTDROP = 0x20000000;
const int MF_STEALTH = 0x40000000;
const int MF_ICECORPSE = 0x80000000;


//**************************************************************************
//**
//**    CLIENT DEFINES
//**
//**************************************************************************

// horisontal text alignement
enum {
  hleft,
  hcentre,
  hright,
};
alias hcenter = hcentre;

// vertical text alignement
enum {
  vtop,
  vcentre,
  vbottom,
};
alias vcenter = vcentre;

// text colours
enum {
  CR_UNDEFINED = -1,
  CR_BRICK, //A
  CR_TAN, //B
  CR_GRAY, //C
  CR_GREEN, //D
  CR_BROWN, //E
  CR_GOLD, //F
  CR_RED, //G
  CR_BLUE, //H
  CR_ORANGE, //I
  CR_WHITE, //J
  CR_YELLOW, //K
  CR_UNTRANSLATED, //L
  CR_BLACK, //M
  CR_LIGHTBLUE, //N
  CR_CREAM, //O
  CR_OLIVE, //P
  CR_DARKGREEN, //Q
  CR_DARKRED, //R
  CR_DARKBROWN, //S
  CR_PURPLE, //T
  CR_DARKGRAY, //U
  CR_CYAN, //V
  CR_ICE, //W
  CR_FIRE, //X
  CR_SAPPHIRE, //Y
  CR_TEAL, //Z
  NUM_TEXT_COLOURS
};

// status bar view type
enum {
  SB_VIEW_NORMAL,
  SB_VIEW_AUTOMAP,
  SB_VIEW_FULLSCREEN
};


//**************************************************************************
//
//  Client types
//
//**************************************************************************

// server list

enum { HOSTCACHESIZE = 8 };

struct hostcache_t {
  string Name;
  string Map;
  string CName;
  string WadFiles[20];
  int Users;
  int MaxUsers;
};

struct slist_t {
  bool bInProgress;
  hostcache_t[] Cache;
  //hostcache_t *Cache;
  //int Count;
  string ReturnReason;
};

struct im_t {
  name LeaveMap;
  int LeaveCluster;
  string LeaveName;
  name LeaveTitlePatch;
  name ExitPic;

  name EnterMap;
  int  EnterCluster;
  string EnterName;
  name EnterTitlePatch;
  name EnterPic;

  name InterMusic;

  string Text;
  name TextFlat;
  name TextPic;
  name TextMusic;

  bool bTextIsLump;
};

struct picinfo_t {
  int width;
  int height;
  int xoffset;
  int yoffset;
};

struct EpisodeDef {
  name Name;
  name TeaserName;
  string Text;
  name PicName;
  bool bLookupText;
  bool bNoSkillMenu;
  bool bOptional;
  string Key;
};

struct SkillPlayerClassName {
  string ClassName;
  string MenuName;
};

struct SkillDef {
  string Name;
  float AmmoFactor;
  float DoubleAmmoFactor;
  float DamageFactor;
  float RespawnTime;
  int RespawnLimit;
  float Aggressiveness;
  int SpawnFilter;
  int AcsReturn;
  string MenuName;
  array!SkillPlayerClassName PlayerClassNames;
  string ConfirmationText;
  string Key;
  string TextColour;
  bool bFastMonsters;
  bool bDisableCheats;
  bool bEasyBossBrain;
  bool bAutoUseHealth;
  bool bMenuNameIsPic;
  bool bMustConfirm;
  bool bSlowMonsters;
};


//==========================================================================
//
//              COMMON BUILTINS
//
//==========================================================================

// "doom", "doom2", "tnt", "plutonia" -- you got the idea
final string GameName { get { return GetCvarS('game_name'); } }

final bool IsDoom { get { return (GetCvarS('game_name') == "doom"); } }
final bool IsDoom2 { get { return (GetCvarS('game_name') == "doom2"); } }
final bool IsAnyDoom2 { get { return (GetCvarS('game_name') != "doom"); } } // FIXME: invalid for heretic/hexen/strife
final bool IsPlutonia { get { return (GetCvarS('game_name') == "plutonia"); } }
final bool IsTnt { get { return (GetCvarS('game_name') == "tnt"); } }
final bool IsNerve { get { return (GetCvarS('game_name') == "nerve"); } }

final bool IsReleaseMode { get { return GetCvarB('_release_mode'); } }


// ////////////////////////////////////////////////////////////////////////// //
// texture / flat number retrieval

native static final int CheckTextureNumForName (name Name);
native static final int TextureNumForName (name Name);
native static final int CheckFlatNumForName (name Name);
native static final int FlatNumForName (name Name);
native static final float TextureHeight (int pic);
native static final name GetTextureName (int Handle);


// ////////////////////////////////////////////////////////////////////////// //
// console command functions

native static final int Cmd_CheckParm (string str);
native static final int Cmd_GetArgC ();
native static final string Cmd_GetArgV (int idx);
// adds text to command buffer, same as typing it in console
native static final void CmdBuf_AddText (string format, ...) [printf,1];


// ////////////////////////////////////////////////////////////////////////// //
// keyboard cheats

native static final void KBCheatClearAll ();
native static final void KBCheatAppend (string keys, string concmd);


// ////////////////////////////////////////////////////////////////////////// //
// state methods

native static final bool AreStateSpritesPresent (state State);


// ////////////////////////////////////////////////////////////////////////// //
// misc

native static final int RGB (ubyte r, ubyte g, ubyte b);
native static final int RGBA (ubyte r, ubyte g, ubyte b, ubyte a);
// reads key value from info string (userinfo or serverinfo)
native static final string Info_ValueForKey (string info, string key);
// checks if WAD lump is present, used to check for shareware/extended WADs
native static final bool WadLumpPresent (name Name);
native static final GameObject::VAnimDoorDef *FindAnimDoor (int BaseTex);
native static final string GetLangString (name Id);
native static final GameObject::LockDef *GetLockDef (int Lock);
native static final int ParseColour (string Name);
native static final string TextColourString (int Colour);
native static final bool StartTitleMap ();
native static final void LoadBinaryLump (name LumpName, out array!ubyte Array);
native static final bool IsMapPresent (name MapName);

native static final int P_GetMapIndexByLevelNum (int map);
native static final int P_GetNumMaps ();

native static final bool HasDecal (name aname);


struct VMapSpecialAction {
  name TypeName;
  int Special;
  int Args[5];
};


struct mapInfo_t {
  name LumpName;
  string Name; // name of map
  int LevelNum; // level number for action specials
  int Cluster; // defines what cluster level belongs to
  int WarpTrans; // actual map number in case maps are not sequential
  name NextMap; // map to teleport to upon exit of timed deathmatch
  name SecretMap; // map to teleport upon secret exit
  name SongLump; // background music (MUS or MIDI)
  int Sky1Texture; // default sky texture
  int Sky2Texture; // alternate sky displayed in Sky2 sectors
  float Sky1ScrollDelta; // Default sky texture speed
  float Sky2ScrollDelta; // Alternate sky texture speed
  name SkyBox; // sky box
  name FadeTable; // fade table {fogmap}
  int Fade; // unsigned
  int OutsideFog; // unsigned
  float Gravity; // Map gravity
  float AirControl; // Air control in this map.
  int Flags; // unsigned
  int Flags2; // unsigned
  name TitlePatch;
  int ParTime;
  int SuckTime;
  ubyte HorizWallShade;
  ubyte VertWallShade;
  ubyte Infighting;
  array!VMapSpecialAction SpecialActions;
  name RedirectType;
  name RedirectMap;
  name ExitPic;
  name EnterPic;
  name InterMusic;
};

native static final mapInfo_t *P_GetMapInfo (int map);


//==========================================================================
//
//              CLIENT BUILTINS
//
//==========================================================================

// ////////////////////////////////////////////////////////////////////////// //
// graphics

native static final void SetVirtualScreen (int Width, int Height);
native static final int GetVirtualWidth ();
native static final int GetVirtualHeight ();
native static final int GetRealScreenWidth ();
native static final int GetRealScreenHeight ();

// registers a graphic, returns handle
native static final int R_RegisterPic (name Name);
// registers a graphic with custom palette, returns handle
native static final int R_RegisterPicPal (name Name, name palname);
// retrieves pic info
native static final void R_GetPicInfo (int handle, picinfo_t *info);
// draws a pic
native static final void R_DrawPic (int x, int y, int handle);
// installs a sprite model
native static final void R_InstallSprite (string Name, int index);
// draws a sprite
native static final void R_DrawSpritePatch (int x, int y, int sprite,
  int frame, int rot, int TranslStart, int TranslEnd, int Colour);
// installs model
native static final void *InstallModel (string Name);
// draws a model
native static final void R_DrawModelFrame (TVec origin, float angle,
  void *model, int frame, int nextframe, string skin, int TranslStart,
  int TranslEnd, int Colour);
// draws a coloured rectangle
native static final void R_FillRect (int x, int y, int w, int h, int colour);

native static final float R_GetAspectRatio ();


// ////////////////////////////////////////////////////////////////////////// //
// client sound stuff

// plays a sound
native static final void LocalSound (name Name);
// checks if sound is still playing
native static final bool IsLocalSoundPlaying (name Name);
// stops all local sounds
native static final void StopLocalSounds ();

// handle shift+key
native static final string TranslateKey (int c);

native static final bool PostEvent (const ref event_t ev); // returns `false` if queue is full

native static final string P_GetMapName (int map);
native static final name P_GetMapLumpName (int map);
native static final name P_TranslateMap (int map);
native static final int P_GetNumEpisodes ();
native static final EpisodeDef *P_GetEpisodeDef (int i);
native static final int P_GetNumSkills ();
native static final SkillDef *P_GetSkillDef (int i);
native static final bool SV_GetSaveString (int i, string *buf);
native static final void SV_GetSaveDateString (int i, string *buf);
native static final void StartSearch (bool Master);
native static final slist_t *GetSlist ();
native static final string KeyNameForNum (int KeyNr);
native static final void IN_GetBindingKeys (string cmd, int *key1, int *key2);
native static final void IN_SetBinding (int key, string ondown, string onup);
native static final string LoadTextLump (name Name);


//==========================================================================
//
//              SERVER BUILTINS
//
//==========================================================================

// ////////////////////////////////////////////////////////////////////////// //
// map utilites

native static final GameObject::opening_t *LineOpenings (GameObject::line_t *linedef, TVec point, optional bool do3dmidtex);
// returns 0 - front, 1 - back, -1 - on
native static final int P_BoxOnLineSide (float *tmbox, GameObject::line_t *ld);
// used for various 3dmidtex calculations
native static final bool P_GetMidTexturePosition (const GameObject::line_t *line, int sideno, out float ptextop, out float ptexbot);
// find the best gap that the thing could fit in, given a certain Z
// position (z1 is foot, z2 is head).
native static final GameObject::sec_region_t *FindThingGap (GameObject::sec_region_t *gaps, TVec point, float z1, float z2);
// find the best opening
native static final GameObject::opening_t *FindOpening (GameObject::opening_t *gaps, float z1, float z2);
// find best region in sector for a given point
native static final GameObject::sec_region_t *PointInRegion (GameObject::sector_t *sector, TVec p);
// given a point (x,y), returns the point (ox,oy) on the sector's defining
// lines that is nearest to (x,y).
// ignores `z`.
native static final TVec SectorClosestPoint (GameObject::sector_t *sec, TVec in);


// ////////////////////////////////////////////////////////////////////////// //
// sound functions

native static final bool GetSoundPlayingInfo (Entity mobj, int sound_id);
native static final int GetSoundID (name Name);
native static final void SetSeqTrans (name Name, int Num, int SeqType);
native static final name GetSeqTrans (int Num, int SeqType);
native static final name GetSeqSlot (name Sequence);
native static final void StopAllSounds ();

native static final GameObject::VTerrainInfo *TerrainType (int pic);
native static final GameObject::VSplashInfo *GetSplashInfo (name Name);
native static final GameObject::VTerrainInfo *GetTerrainInfo (name Name);
native static final void SB_Start ();
native static final class FindClassFromEditorId (int Id, int GameFilter);
native static final class FindClassFromScriptId (int Id, int GameFilter);


// ////////////////////////////////////////////////////////////////////////// //
// wad lump iteration
// boom namespaces
enum EWadNamespace {
  Global,
  Sprites,
  Flats,
  ColourMaps,
  ACSLibrary,
  NewTextures,
  Voices,
  HiResTextures,

  // special namespaces for zip files, in wad file they will be searched in global namespace
  ZipSpecial,
  Patches,
  Graphics,
  Sounds,
  Music,
};

native static final int W_IterateNS (int Prev, EWadNamespace NS);
native static final int W_IterateFile (int Prev, string Name);

//WARNING! UNSAFE!
// only use lump number from iterator here!
native static final int W_LumpLength (int lump);
native static final name W_LumpName (int lump);
native static final string W_FullLumpName (int lump);
native static final int W_LumpFile (int lump);

native static final int W_CheckNumForName (name Name, optional EWadNamespace NS /*= WADNS_Global*/);
native static final int W_GetNumForName (name Name, optional EWadNamespace NS /*= WADNS_Global*/);

// you can use result of `W_LumpFile()` with the following
native static final int W_CheckNumForNameInFile (name Name, int File, optional EWadNamespace NS /*= WADNS_Global*/);

#include "Object_vv_lumpiter.vc"


// ////////////////////////////////////////////////////////////////////////// //
struct refdef_t {
  int x, y;
  int width, height;
  float fovx, fovy;
  bool drawworld;
  bool DrawCamera;
};


native static final void GetCurrRefDef (out refdef_t rd);
