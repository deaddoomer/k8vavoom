//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//
//                              ENTITY DATA
//
//  NOTES: Entity
//
//  Entities are used to tell the refresh where to draw an image, tell the
// world simulation when objects are contacted, and tell the sound driver
// how to position a sound.
//
//  The refresh uses the snext and sprev links to follow lists of things in
// sectors as they are being drawn. The sprite, frame, and angle elements
// determine which patch_t is used to draw the sprite if it is visible.
// The sprite and frame values are allmost allways set from state_t
// structures. The xyz origin point represents a point at the bottom middle
// of the sprite (between the feet of a biped). This is the default origin
// position for patch_ts grabbed with lumpy.exe. A walking creature will have
// its z equal to the floor it is standing on.
//
//  The sound code uses the x,y, and z fields to do stereo positioning of any
// sound emmited by the Entity.
//
//  The play simulation uses the BlockLinks, x,y,z, radius, height to
// determine when mobj_ts are touching each other, touching lines in the map,
// or hit by trace lines (gunshots, lines of sight, etc). The Entity->flags
// element has various bit flags used by the simulation.
//
//  Every Entity is linked into a single sector based on its origin
// coordinates. The subsector_t is found with R_PointInSubsector(x,y), and
// the sector_t can be found with subsector->sector. The sector links are
// mostly used by the rendering code; the play simulation can ocasionally use
// sector info to adjust heights and do some cheap checks (mostly for
// "noblockmap" and "nointeraction" entities).
//
//  Sector info is updated by `LinkToWorld()`, so make sure that you will
// call this even for "noblockmap" entities.
//
//  Any Entity that needs to be acted upon by something else in the play
// world (block movement, be shot, etc) will also need to be linked into the
// blockmap. If the thing has the MF_NOBLOCK flag set, it will not use the
// block links. It can still interact with other things, but only as the
// instigator (missiles will run into other things, but nothing can run into
// a missile). Each block in the grid is 128*128 units, and knows about every
// line_t that it contains a piece of, and every interactable Entity that has
// its origin contained.
//
//  A valid Entity is a Entity that has the proper subsector_t filled in for
// its xy coordinates and is linked into the sector from which the subsector
// was made, or has the MF_NOSECTOR flag set (the subsector_t needs to be
// valid even if MF_NOSECTOR is set), and is linked into a blockmap block or
// has the MF_NOBLOCKMAP flag set. Links should only be modified by the
// P_[Un]SetThingPosition() functions. Do not change the MF_NO? flags while
// a thing is valid.
//
//  Any questions?
//
//**************************************************************************
class Entity : Thinker native abstract;

enum {
  STYLE_None, // do not draw
  STYLE_Normal, // normal: just copy the image to the screen
  STYLE_Fuzzy, // draw silhouette using "fuzz" effect
  STYLE_SoulTrans, // draw translucent with amount in r_transsouls
  STYLE_OptFuzzy, // draw as fuzzy or translucent, based on user preference
  STYLE_Translucent = 64, // draw translucent
  STYLE_Add, // draw additive
  STYLE_Stencil, // solid color
  STYLE_AddStencil, // solid color, additive
};

// color tralslation types
enum {
  TRANSL_None, // no translation
  TRANSL_Standard, // game's standard translations
  TRANSL_Player, // per-player translations
  TRANSL_Level, // ACS translations
  TRANSL_BodyQueue, // translations of dead players
  TRANSL_Decorate, // translations defined in DECORATE
  TRANSL_Blood, // blood translations, for blood color
  TRANSL_Max
};

const int TRANSL_TYPE_SHIFT = 16;

// flags for A_LookEx method
enum {
  LOF_NOSIGHTCHECK = 1,
  LOF_NOSOUNDCHECK = 2,
  LOF_DONTCHASEGOAL = 4,
  LOF_NOSEESOUND = 8,
  LOF_FULLVOLSEESOUND = 16,
};


struct LightEffectDef {
  name Name;
  ubyte Type;
  int Color;
  float Radius;
  float Radius2;
  float MinLight;
  TVec Offset;
  float Chance;
  float Interval;
  float Scale;
  int NoSelfShadow; // this will become flags
};


struct ParticleEffectDef {
  name Name;
  ubyte Type;
  ubyte Type2;
  int Color;
  TVec Offset;
  int Count;
  float OrgRnd;
  TVec Velocity;
  float VelRnd;
  float Accel;
  float Grav;
  float Duration;
  float Ramp;
};


struct DropItemInfo {
  class!Entity Type;
  name TypeName;
  int Amount;
  float Chance;
};


struct DamageFactor {
  name DamageType;
  float Factor;
};


struct PainChanceInfo {
  name DamageType;
  float Chance;
};


struct tmtrace_t {
  Entity StepThing;
  TVec End;
  float[4] BBox;
  float FloorZ;
  float CeilingZ;
  float DropOffZ;

  TSecPlaneRef EFloor;
  TSecPlaneRef ECeiling;

  bool bFloatOk; // if true, move would be ok if within tmtrace.FloorZ-tmtrace.CeilingZ

  // keep track of the line that lowers the ceiling,
  // so missiles don't explode against sky hack walls
  line_t *CeilingLine;
  line_t *FloorLine;
  // also keep track of the blocking line, for checking
  // against doortracks
  line_t *BlockingLine; // only lines without backsector

  // keep track of special lines as they are hit,
  // but don't process them until the move is proven valid
  array!(line_t *) SpecHit;

  Entity BlockingMobj;
  line_t *AnyBlockingLine; // any blocking line
};

// info for drawing: position
TVec Origin;

// for smooth movement
native transient TVec LastMoveOrigin;
native transient TAVec LastMoveAngles;
native transient float LastMoveTime;
native transient float LastMoveDuration;
native transient bool bIntrJustMoved;

// momentums, used to update position
TVec Velocity;

TAVec Angles; // orientation

readonly state State;
readonly int DispSpriteFrame; // high 8 bits is frame
readonly name DispSpriteName;
float StateTime; // state tic counter

// more drawing info
ubyte SpriteType; // how to draw sprite
name FixedSpriteName;
string FixedModelName;
ubyte ModelVersion;
native int NumRenderedShadows;

ubyte RenderStyle;
float Alpha;
int Translation;

int StencilColor;

float FloorClip; // value to use for floor clipping

// scaling
float ScaleX;
float ScaleY;

// mostly reliable, but you'd better don't use this
native readonly subsector_t *SubSector;
native readonly sector_t *Sector;

// interaction info, by BLOCKMAP
// links in blocks (if needed)
native readonly private Entity BlockMapNext;
native readonly private Entity BlockMapPrev;
native readonly private int BlockMapCell;

// links in sector (if needed)
native readonly Entity SNext;
native readonly Entity SPrev;

native readonly msecnode_t *TouchingSectorList;

// the closest interval over all contacted Sectors
native float FloorZ;
native float CeilingZ;
native float DropOffZ;

// closest floor and ceiling, source of floorz and ceilingz
native TSecPlaneRef EFloor;
native TSecPlaneRef ECeiling;

// if == validcount, already checked
//native int ValidCount;

// flags
bool bSolid; // blocks
bool bNoSector; // don't use the sector links (invisible but touchable)
bool bNoBlockmap; // don't use the BlockLinks (inert but displayable)
bool bIsPlayer; // player or player-bot
bool bFixedModel; // internal renderer flag
bool bNoGravity; // don't apply gravity every tic
bool bPassMobj; // enable z block checking; if on, this flag will allow the mobj to pass over/under other mobjs
bool bColideWithThings;
bool bColideWithWorld;
bool bCheckLineBlocking;
bool bCheckLineBlockMonsters;
bool bDropOff; // allow jumps from high places
bool bFloat; // allow moves to any height, no gravity
bool bFly; // fly mode is active
bool bBlasted; // missile will pass through ghosts
bool bCantLeaveFloorpic; // stay within a certain floor type
bool bFloorClip; // if feet are allowed to be clipped
bool bIgnoreCeilingStep; // continue walk without lowering itself
bool bIgnoreFloorStep; // continue walk ignoring floor height changes
bool bAvoidingDropoff; // used to move monsters away from dropoffs
bool bOnMobj; // mobj is resting on top of another mobj
bool bCorpse; // don't stop moving halfway off a step
bool bFullBright; // make current state full bright
bool bInvisible; // don't draw this actor
bool bMissile; // don't hit same species, explode on block
bool bDontOverlap; // prevent some things from overlapping
bool bKillOnUnarchive; // remove this entity on loading game
bool bActLikeBridge; // always allow objects to pass
bool bNoDropOff; // can't drop off under any circumstances
bool bBright; // always render full bright
bool bCanJump; // can perform standard jump
bool bStepMissile; // missile can "walk" up steps

int Health;
int InitialHealth;

// for movement checking
float Radius;
// WARNING: for PlayerPawn, you should use `SetHeight()` method
//          actually, you'd better use this method for all entities
float Height;

// additional info record for player avatars only
// only valid if type == MT_PLAYER
BasePlayer Player;

readonly int TID; // thing identifier
readonly private Entity TIDHashNext;
readonly private Entity TIDHashPrev;

int Special; // special
int Args[5]; // special arguments

readonly private int SoundOriginID;

// params
float Mass;
float MaxStepHeight;
float MaxDropoffHeight;
float Gravity;

// water
ubyte WaterLevel;
ubyte WaterType;

// variables, so it may be customised
float WaterSinkFactor = 3.0;
float WaterSinkSpeed = 0.5;


// for player sounds
name SoundClass;
name SoundGender;

// owner entity of inventory item
Entity Owner;

name DecalName;


replication {
  reliable if (Role == ROLE_Authority)
    Origin, Angles, FloorClip, State, StateTime, SpriteType,
    FixedSpriteName, ModelVersion, RenderStyle, Alpha,
    Translation, StencilColor, ScaleX, ScaleY,
    bFly, bNoSector, bInvisible, bFullBright,
    bFixedModel, SoundOriginID/*, bUseDispState*/, bBright,
    DispSpriteFrame, DispSpriteName,
    DecalName;

  reliable if (Role == ROLE_Authority && bFixedModel)
    FixedModelName;

  reliable if (Role == ROLE_Authority && bNetOwner)
    Owner;
}


// ////////////////////////////////////////////////////////////////////////// //
// natives
native final void SetTID (int tid);

// various state functions
native final bool SetState (state State);
native final void SetInitialState (state State);
native final bool AdvanceState (float deltaTime);
native final state FindState (name StateName, optional name SubLabel, optional bool Exact);
native final state FindStateEx (string StateName, optional bool Exact);
native final state HasSpecialStates (name StateName);
native final void GetStateEffects (out array!(LightEffectDef *) Lights, out array!(ParticleEffectDef *) Particles);
native final bool CallStateChain (Entity Actor, state State);

// sound functions
native final void PlaySound (name SoundName, int Channel, optional float Volume,
                             optional float Atenuation, optional bool Loop, optional bool Local);
native final void StopSound (int Channel);
native final bool AreSoundsEquivalent (name Sound1, name Sound2);
native final bool IsSoundPresent (name Sound);

native final void StartSoundSequence (name sequence, int ModeNum);
native final void AddSoundSequenceChoice (name Choice);
native final void StopSoundSequence ();

native final bool CheckSides (TVec lsPos);
native final void CheckDropOff (out float DeltaX, out float DeltaY);
native final bool CheckPosition (TVec Pos);
native final bool CheckRelPosition (tmtrace_t *tmtrace, TVec Pos, optional bool noPickups/*=false*/, optional bool ignoreMonsters, optional bool ignorePlayers);
native final bool TryMove (TVec newPos, bool AllowDropOff, optional bool checkOnly);
native final bool TryMoveEx (tmtrace_t *tmtrace, TVec newPos, bool AllowDropOff, optional bool checkOnly);
native final bool TestMobjZ ();

native final void SlideMove (float StepVelScale);
native final void BounceWall (float overbounce, float bouncefactor);

native final bool CheckWater ();

// moved from native to VC code
//native final void UpdateVelocity ();

native final Entity CheckOnmobj ();

// always call this before changing x and y coordinates (z can be changed freely)
// i.e. first unlink, then change coords, then link again
// by default, `LinkToWorld` checks only entity Origin.
// if you want to do a proper check, call it with `properFloorCheck:true`.
native final void LinkToWorld (optional bool properFloorCheck);
native final void UnlinkFromWorld ();

native final bool CanSee (Entity Other, optional bool disableBetterSight/*=false*/);
// always "better sight", used for radius damage
native final bool CanSeeAdv (Entity Other);
native final bool CanShoot (Entity Other);

native final iterator RoughBlockSearch (out Entity EntPtr, int Distance);

native final void SetDecorateFlag (string Name, bool Value);
native final bool GetDecorateFlag (string Name);


//==========================================================================
//
//  IsMonster
//
//==========================================================================
bool IsMonster () {
  return false;
}


//==========================================================================
//
//  UpdateVelocity
//
//  moved from native to VC code
//
//==========================================================================
void UpdateVelocity (float DeltaTime) {
  /*
  if (Origin.z <= FloorZ && !Velocity && !bCountKill && !bIsPlayer) {
    // no gravity for non-moving things on ground to prevent static objects from sliding on slopes
    return;
  }
  */

  // don't add gravity if standing on slope with normal.z > 0.7 (aprox 45 degrees)
  if (Sector && !bNoGravity && (Origin.z > FloorZ || EFloor.spGetNormalZ() <= 0.7f)) {
    if (WaterLevel < 2) {
      Velocity.z -= Gravity*Level.Gravity*Sector.Gravity*DeltaTime;
    } else if (!bIsPlayer || Health <= 0) {
      // water gravity
      Velocity.z -= Gravity*Level.Gravity*Sector.Gravity/10.0*DeltaTime;
      float startvelz = Velocity.z;
      float sinkspeed = -WaterSinkSpeed/(bCorpse ? 3.0 : 1.0);
      if (Velocity.z < sinkspeed) {
        Velocity.z = (startvelz < sinkspeed ? startvelz : sinkspeed);
      } else {
        Velocity.z = startvelz+(Velocity.z-startvelz)*WaterSinkFactor;
      }
    }
  }

  // friction
  if (Velocity.x || Velocity.y/* || Velocity.z*/) {
    ApplyFriction(DeltaTime);
  }
}


//===========================================================================
//
//  OnMapSpawn
//
//===========================================================================
void OnMapSpawn (mthing_t *mthing) {
  InitialHealth = Health;
}


//==========================================================================
//
//  BeginPlay
//
//==========================================================================
void BeginPlay () {
}


//==========================================================================
//
//  Destroyed
//
//==========================================================================
void Destroyed () {
}


//==========================================================================
//
//  Touch
//
//==========================================================================
bool Touch (Entity Other) {
  return !Other.bSolid;
}


//===========================================================================
//
//  CheckForPushSpecial
//
//===========================================================================
void CheckForPushSpecial (line_t *line, int side) {
}


//==========================================================================
//
//  BlastedHitLine
//
//==========================================================================
void BlastedHitLine () {
}


//==========================================================================
//
//  PushLine
//
//==========================================================================
void PushLine (tmtrace_t *tmtrace) {
}


//==========================================================================
//
//  HandleFloorclip
//
//==========================================================================
void HandleFloorclip () {
}


//==========================================================================
//
//  CrossSpecialLine
//
//==========================================================================
void CrossSpecialLine (line_t *ld, int side) {
}


//==========================================================================
//
//  ApplyFriction
//
//==========================================================================
void ApplyFriction (float DeltaTime) {
}


//==========================================================================
//
//  SectorChanged
//  called after sector height changed, to notify things
//  `CrushChange` means "crush unfitting actors"
//  returns `false` if actor cannot fit
//
//==========================================================================
bool SectorChanged (int CrushChange) {
  return true;
}


//===========================================================================
//
//  ClearInventory
//
//===========================================================================
void ClearInventory () {
}


//===========================================================================
//
//  GiveInventory
//
//===========================================================================
void GiveInventory (name ItemName, int Amount) {
}


//===========================================================================
//
//  TakeInventory
//
//===========================================================================
void TakeInventory (name ItemName, int Amount) {
}


//===========================================================================
//
//  CheckInventory
//
//===========================================================================
int CheckInventory (name ItemName) {
  return 0;
}


//===========================================================================
//
//  UseInventoryName
//
//===========================================================================
int UseInventoryName (name ItemName) {
  return 0;
}


//===========================================================================
//
//  GetSigilPieces
//
//===========================================================================
int GetSigilPieces () {
  return 0;
}


//===========================================================================
//
//  GetArmorPoints
//
//===========================================================================
int GetArmorPoints () {
  return 0;
}


//===========================================================================
//
//  GetArmorPointsForType
//
//===========================================================================
int GetArmorPointsForType (name armtype) {
  return 0;
}


//===========================================================================
//
//  CheckNamedWeapon
//
//===========================================================================
int CheckNamedWeapon (name Name) {
  return 0;
}


//===========================================================================
//
//  SetNamedWeapon
//
//===========================================================================
int SetNamedWeapon (name Name) {
  return 0;
}


//===========================================================================
//
//  GetAmmoCapacity
//
//===========================================================================
int GetAmmoCapacity (name Name) {
  return 0;
}


//===========================================================================
//
//  SetAmmoCapacity
//
//===========================================================================
void SetAmmoCapacity (name Name, int Amount) {
}


//===========================================================================
//
//  MoveThing
//
//===========================================================================
bool MoveThing (TVec Pos, bool Fog) {
  return false;
}


//==========================================================================
//
//  GetStateTime
//
//==========================================================================
float GetStateTime (state AState, float AStateTime) {
  switch (GetStateTicKind(AState)) {
    case StateTicKind.Normal: return AStateTime;
    case StateTicKind.Random: return float(GetStateArgN(AState, 0)+trunci(Random()*(GetStateArgN(AState, 1)-GetStateArgN(AState, 0)+1)))/35.0f;
    default: return AStateTime;
  }
}


//==========================================================================
//
//  SetActorProperty
//
//==========================================================================
void SetActorProperty (int Prop, int IntVal, string StrVal) {
}


//==========================================================================
//
//  GetActorProperty
//
//==========================================================================
int GetActorProperty (int Prop) {
  return 0;
}


//==========================================================================
//
//  CheckForSectorActions
//
//==========================================================================
void CheckForSectorActions (sector_t *OldSec, bool OldAboveFakeFloor,
                            bool OldAboveFakeCeiling)
{
}


//==========================================================================
//
//  SkyBoxGetAlways
//
//==========================================================================
bool SkyBoxGetAlways () {
  return false;
}


//==========================================================================
//
//  SkyBoxGetMate
//
//==========================================================================
Entity SkyBoxGetMate () {
  return none;
}


//==========================================================================
//
//  SkyBoxGetPlaneAlpha
//
//==========================================================================
float SkyBoxGetPlaneAlpha () {
  return 0.0;
}


//==========================================================================
//
//  ClassifyActor
//
//==========================================================================
int ClassifyActor () {
  return 0;
}


//==========================================================================
//
//  MorphActor
//
//==========================================================================
int MorphActor (name PlayerClass, name MonsterClass, float Duration,
                int Style, name MorphFlash, name UnmorphFlash)
{
  return 0;
}


//==========================================================================
//
//  UnmorphActor
//
//==========================================================================
int UnmorphActor (Entity Activator, int Force) {
  return 0;
}


//==========================================================================
//
//  GetViewEntRenderParams
//
//==========================================================================
void GetViewEntRenderParams (ref float OutAlpha, ref int OutRenderStyle) {
}


//==========================================================================
//
//  CalcFakeZMovement
//
//==========================================================================
void CalcFakeZMovement (out TVec Ret, float DeltaTime) {
}


//==========================================================================
//
//  SetOrigin
//
//==========================================================================
final void SetOrigin (TVec NewOrigin, optional bool properFloorCheck) {
  UnlinkFromWorld();
  Origin = NewOrigin;
  LastMoveOrigin = NewOrigin;
  bIntrJustMoved = false;
  LinkToWorld(properFloorCheck:properFloorCheck!optional);
}


//==========================================================================
//
//  RemoveThing
//
//==========================================================================
void RemoveThing () {
  Destroy();
}


//==========================================================================
//
//  GetViewHeight
//
//==========================================================================
float GetViewHeight () {
  return fmax(0, Height*0.5);
}


//==========================================================================
//
//  GetCentre
//
//==========================================================================
final TVec GetCentre () {
  return Origin+vector(0.0, 0.0, Height*0.5-FloorClip);
}


//==========================================================================
//
//  GetCentreZ
//
//==========================================================================
final float GetCentreZ () {
  return Origin.z+(Height*0.5-FloorClip);
}


//==========================================================================
//
//  DistTo
//
//==========================================================================
final float DistTo (Entity Other) {
  return Length(Other.GetCentre()-GetCentre());
}


//==========================================================================
//
//  DistTo2
//
//==========================================================================
final float DistTo2 (Entity Other) {
  TVec dir = Other.Origin-Origin;
  dir.z = 0.0;
  return Length2D(dir);
}


//==========================================================================
//
//  AngleTo
//
//==========================================================================
final float AngleTo (Entity Other) {
  TVec dir = Other.Origin-Origin;
  float res = atan2(dir.y, dir.x);
  return (res.isfinite ? res : 0);
}


//==========================================================================
//
//  AngleToWithOfs
//
//==========================================================================
final float AngleToWithOfs (Entity Other, const TVec ofs) {
  TVec dir = (Other.Origin-Origin)+ofs;
  float res = atan2(dir.y, dir.x);
  return (res.isfinite ? res : 0);
}


//==========================================================================
//
//  AngleDelta
//
//  returns signed angle from a1 to a2, [-180..180]
//
//==========================================================================
static final float AngleDelta (float a1, float a2) {
  return AngleMod360(a2-a1+180)-180;
}


//===========================================================================
//
//  FindActivePowerupTime
//
//===========================================================================
float FindActivePowerupTime (name className) {
  return 0;
}


//===========================================================================
//
//  PickActor
//
//===========================================================================
Entity PickActor (optional TVec Origin, TVec dir, float distance, optional int actorMask, optional int wallMask) {
  return none;
}


//===========================================================================
//
//  eventDoAAPtr
//
//===========================================================================
Entity eventDoAAPtr (int ptr) {
  if (ptr == 0) return self;
  return none;
}


//===========================================================================
//
//  eventFindTargetForACS
//
//===========================================================================
Entity eventFindTargetForACS () {
  return none;
}


//===========================================================================
//
//  eventSetPointerForACS
//
//===========================================================================
bool eventSetPointerForACS (int assign_slot, int tid, int aptr, int flags) {
  return 0;
}


//===========================================================================
//
//  eventLineAttackACS
//
//===========================================================================
void eventLineAttackACS (TVec dir, float distance, int LADamage, name pufftype, name damagetype, int flags, int pufftid) {
}


// ////////////////////////////////////////////////////////////////////////// //
// for decorate
final float _GetOriginX () { return Origin.x; }
final float _GetOriginY () { return Origin.y; }
final float _GetOriginZ () { return Origin.z; }

final float _GetVelocityX () { return Velocity.x; }
final float _GetVelocityY () { return Velocity.y; }
final float _GetVelocityZ () { return Velocity.z; }

final float _GetAnglesYaw () { return Angles.yaw; }
final float _GetAnglesPitch () { return Angles.pitch; }
final float _GetAnglesRoll () { return Angles.roll; }


//==========================================================================
//
//  GetHeight
//
//  use this instead of directly reading `Height`
//  this is required due to height modifications in PlayerPawn
//
//==========================================================================
float GetHeight () {
  return Height;
}


//==========================================================================
//
//  SetHeight
//
//  use this instead of directly changing `Height`
//  this is required due to height modifications in PlayerPawn
//
//==========================================================================
void SetHeight (float newvalue) {
  Height = newvalue;
}


//==========================================================================
//
//  eventDropItem
//
//==========================================================================
bool eventDropItem (name itemName, int amount, float chance) {
  return false;
}


//==========================================================================
//
//  ClearEntityInventoryQS
//
//==========================================================================
void QS_ClearEntityInventory () {}


//==========================================================================
//
//  GetEntityInventoryQS
//
//  returns entity `Inventory` field, or `none`
//
//==========================================================================
Entity QS_GetEntityInventory () { return none; }


//==========================================================================
//
//  SpawnEntityInventoryQS
//
//  adds to current inventory
//
//==========================================================================
Entity QS_SpawnEntityInventory (name className) { return none; }


//==========================================================================
//
//  QS_Save
//
//==========================================================================
void QS_Save () {}


//==========================================================================
//
//  QS_Load
//
//==========================================================================
void QS_Load () {}


// ////////////////////////////////////////////////////////////////////////// //
// this is hack used for quicksaves
native final void QS_PutInt (string fieldname, int value);
native final void QS_PutName (string fieldname, name value);
native final void QS_PutStr (string fieldname, string value);
native final void QS_PutFloat (string fieldname, float value);

native final int QS_GetInt (string fieldname, optional int defvalue);
native final name QS_GetName (string fieldname, optional name defvalue);
native final string QS_GetStr (string fieldname, optional string defvalue);
native final float QS_GetFloat (string fieldname, optional float defvalue);


defaultproperties {
  RenderStyle = STYLE_Normal;
  Alpha = 1.0;
  ScaleX = 1.0;
  ScaleY = 1.0;
  bColideWithThings = true;
  bColideWithWorld = true;
  MaxDropoffHeight = 24.0;
  Gravity = 1.0;
  SoundClass = 'player';
  SoundGender = 'male';
}
