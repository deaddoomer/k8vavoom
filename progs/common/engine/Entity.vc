//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//
//                              ENTITY DATA
//
//  NOTES: Entity
//
//  Entities are used to tell the refresh where to draw an image, tell the
// world simulation when objects are contacted, and tell the sound driver
// how to position a sound.
//
//  The refresh uses the snext and sprev links to follow lists of things in
// sectors as they are being drawn. The sprite, frame, and angle elements
// determine which patch_t is used to draw the sprite if it is visible.
// The sprite and frame values are allmost allways set from state_t
// structures. The xyz origin point represents a point at the bottom middle
// of the sprite (between the feet of a biped). This is the default origin
// position for patch_ts grabbed with lumpy.exe. A walking creature will have
// its z equal to the floor it is standing on.
//
//  The sound code uses the x,y, and z fields to do stereo positioning of any
// sound emmited by the Entity.
//
//  The play simulation uses the BlockLinks, x,y,z, radius, height to
// determine when mobj_ts are touching each other, touching lines in the map,
// or hit by trace lines (gunshots, lines of sight, etc). The Entity->flags
// element has various bit flags used by the simulation.
//
//  Every Entity is linked into a single sector based on its origin
// coordinates. The subsector_t is found with R_PointInSubsector(x,y), and
// the sector_t can be found with subsector->sector. The sector links are
// mostly used by the rendering code; the play simulation can ocasionally use
// sector info to adjust heights and do some cheap checks (mostly for
// "noblockmap" and "nointeraction" entities).
//
//  Sector info is updated by `LinkToWorld()`, so make sure that you will
// call this even for "noblockmap" entities.
//
//  Any Entity that needs to be acted upon by something else in the play
// world (block movement, be shot, etc) will also need to be linked into the
// blockmap. If the thing has the MF_NOBLOCK flag set, it will not use the
// block links. It can still interact with other things, but only as the
// instigator (missiles will run into other things, but nothing can run into
// a missile). Each block in the grid is 128*128 units, and knows about every
// line_t that it contains a piece of, and every interactable Entity that has
// its origin contained.
//
//  A valid Entity is a Entity that has the proper subsector_t filled in for
// its xy coordinates and is linked into the sector from which the subsector
// was made, or has the MF_NOSECTOR flag set (the subsector_t needs to be
// valid even if MF_NOSECTOR is set), and is linked into a blockmap block or
// has the MF_NOBLOCKMAP flag set. Links should only be modified by the
// P_[Un]SetThingPosition() functions. Do not change the MF_NO? flags while
// a thing is valid.
//
//  Any questions?
//
//**************************************************************************
class Entity : Thinker native abstract;

// render style constants
enum [decorate] /*ERenderStyle*/ {
  STYLE_None, // do not draw
  STYLE_Normal, // normal; just copy the image to the screen
  STYLE_Fuzzy, // draw silhouette using "fuzz" effect
  STYLE_SoulTrans, // draw translucent with amount in r_transsouls
  STYLE_OptFuzzy, // draw as fuzzy or translucent, based on user preference
  STYLE_Stencil, // solid color
  STYLE_Translucent, // draw translucent
  STYLE_Add, // draw additive
  STYLE_Shaded, // implemented
  STYLE_TranslucentStencil, // implemented
  STYLE_Shadow, // implemented
  STYLE_Subtract, // implemented
  STYLE_AddStencil, // solid color, additive
  STYLE_AddShaded, // implemented
  // special style for sprites only
  STYLE_Dark = 64,
};

// color tralslation types
enum {
  TRANSL_None, // no translation
  TRANSL_Standard, // game's standard translations
  TRANSL_Player, // per-player translations
  TRANSL_Level, // ACS translations
  TRANSL_BodyQueue, // translations of dead players
  TRANSL_Decorate, // translations defined in DECORATE
  TRANSL_Blood, // blood translations, for blood color
  TRANSL_Max
};

const int TRANSL_TYPE_SHIFT = 16;


struct LightEffectDef {
  name Name;
  ubyte Type;
  int Color;
  float Radius;
  float Radius2;
  float MinLight;
  TVec Offset;
  float Chance;
  float Interval;
  float Scale;
  float ConeAngle;
  TVec ConeDir;
  // flags
  bool bNoSelfShadow;
  bool bNoShadow;
};


struct ParticleEffectDef {
  name Name;
  ubyte Type;
  ubyte Type2;
  int Color;
  TVec Offset;
  int Count;
  float OrgRnd;
  TVec Velocity;
  float VelRnd;
  float Accel;
  float Grav;
  float Duration;
  float Ramp;
};


struct DropItemInfo {
  class!Entity Type;
  name TypeName;
  int Amount;
  float Chance;
};


struct PainChanceInfo {
  name DamageType;
  float Chance;
};


struct tmtrace_t {
  Entity StepThing;
  TVec End;
  float[4] BBox;
  float FloorZ;
  float CeilingZ;
  float DropOffZ;

  TSecPlaneRef EFloor;
  TSecPlaneRef ECeiling;

  bool bFloatOk; // if true, move would be ok if within tmtrace.FloorZ-tmtrace.CeilingZ

  // keep track of the line that lowers the ceiling,
  // so missiles don't explode against sky hack walls
  line_t *CeilingLine;
  line_t *FloorLine;
  // also keep track of the blocking line, for checking
  // against doortracks
  line_t *BlockingLine; // only lines without backsector

  // keep track of special lines as they are hit,
  // but don't process them until the move is proven valid
  array!(line_t *) SpecHit;

  Entity BlockingMobj;
  // any blocking line (including passable two-sided!); only has any sense if trace returned `false`
  // note that this is really *any* line, not necessarily first or last crossed!
  line_t *AnyBlockingLine;

  // polyobject we are standing on, valid for cptrace_t
  polyobj_t *PolyObj;

  // from cptrace_t
  //TVec Pos; // valid for cptrace_t
};


// info for drawing: position
TVec Origin;

// for smooth movement
native transient TVec LastMoveOrigin;
native transient TAVec LastMoveAngles;
native transient float LastMoveTime;
native transient float LastMoveDuration;
native transient bool bIntrJustMoved;

// momentums, used to update position
TVec Velocity;
TAVec Angles; // orientation

readonly state State;
readonly int DispSpriteFrame; // high 8 bits is frame
readonly name DispSpriteName;
float StateTime; // state tic counter

// more drawing info
ubyte SpriteType; // how to draw sprite
name FixedSpriteName;
string FixedModelName;
ubyte ModelVersion;
native int NumRenderedShadows;

ubyte RenderStyle;
float Alpha;
int Translation;

int StencilColor;

float FloorClip; // value to use for floor clipping

// scaling
float ScaleX;
float ScaleY;

native readonly transient subsector_t *SubSector; // can be `nullptr` for `EF_NoSector` entities
native readonly transient sector_t *Sector; // can be `nullptr` for `EF_NoSector` entities
native readonly transient polyobj_t *PolyObj; // polyobject this entity stands on (needed for ChangeSector)
    // set by `LinkToWorld()`, required for 3d pobjs -- they need to move/rotate actors
native readonly transient sector_t *LastSector; // set by `UnlinkFromWorld()`, used to remove excessive gore actors
native readonly transient TVec PrevTickOrigin; // set in `VEntity::Tick()`

// non-polyobject
native readonly transient subsector_t *BaseSubSector; // cannot be `nullptr`, it is always set
native readonly transient sector_t *BaseSector; // cannot be `nullptr`, it is always set

// interaction info, by BLOCKMAP
// links in blocks (if needed)
native readonly private Entity BlockMapNext;
native readonly private Entity BlockMapPrev;
native readonly private int BlockMapCell;

// links in sector (if needed)
native readonly Entity SNext;
native readonly Entity SPrev;

native readonly msecnode_t *TouchingSectorList;

// the closest interval over all contacted Sectors
native float FloorZ;
native float CeilingZ;
native float DropOffZ;

// closest floor and ceiling, source of floorz and ceilingz
native TSecPlaneRef EFloor;
native TSecPlaneRef ECeiling;

//native transient int validcount; // moved to VThinker

// flags
bool bSolid; // blocks
bool bNoSector; // don't use the sector links (invisible but touchable)
bool bNoBlockmap; // don't use the BlockLinks (inert but displayable)
bool bIsPlayer; // player or player-bot
bool bFixedModel; // internal renderer flag
bool bNoGravity; // don't apply gravity every tic
bool bPassMobj; // enable z block checking; if on, this flag will allow the mobj to pass over/under other mobjs
bool bColideWithThings;
bool bColideWithWorld;
bool bCheckLineBlocking;
bool bCheckLineBlockMonsters;
bool bDropOff; // allow jumps from high places
bool bFloat; // allow moves to any height, no gravity
bool bFly; // fly mode is active
bool bBlasted; // missile will pass through ghosts
bool bCantLeaveFloorpic; // stay within a certain floor type
bool bFloorClip; // if feet are allowed to be clipped
bool bIgnoreCeilingStep; // continue walk without lowering itself
bool bIgnoreFloorStep; // continue walk ignoring floor height changes
bool bAvoidingDropoff; // used to move monsters away from dropoffs
bool bOnMobj; // mobj is resting on top of another mobj
bool bCorpse; // don't stop moving halfway off a step
bool bFullBright; // make current state full bright
bool bInvisible; // don't draw this actor
bool bMissile; // don't hit same species, explode on block
bool bDontOverlap; // prevent some things from overlapping
bool bKillOnUnarchive; // remove this entity on loading game
bool bActLikeBridge; // always allow objects to pass
bool bNoDropOff; // can't drop off under any circumstances
bool bBright; // always render full bright
bool bCanJump; // can perform standard jump
bool bStepMissile; // missile can "walk" up steps

int Health;
int InitialHealth;

// extra flags
bool bMonster; // moved from `EntityEx`
bool bWasRendered; // used in automap
transient bool bNetDetach; // server is using this flag for some replication conditions
bool bNoInteraction; // thing is completely excluded from any gameplay related checks (moved from EntityEx)
bool bNoTickGrav; // do not call `Tick()` (but process gravity) (processed in C++ code)
bool bPseudoCorpse; // set in DECORATE for corpse decorations, so sprite offset fixer can recongize them
bool bFloatBob; // use float bobbing z movement (moved from `EntityEx`)
bool bNoTickGravLifeTime; // if `bNoTickGrav` set, perform lifetime logic
// physics will put this entity to floor or ceiling (floor has precedence)
bool bStickToFloor;
bool bStickToCeiling;
transient bool bDetachFromServer;
// don't store it, because nobody cares
// we may randomly set it on unarchiving
transient bool bCorpseFlipped;
transient native readonly bool bAlwaysTick; // cannot optimise physics for this entity
// two flags to avoid calling `IsChildOf()` each time
// set in C++ postctor, refreshed in serializer (to avoid serializing them)
transient native readonly bool bThisIsEntityEx;
transient native readonly bool bThisIsActor;
transient native readonly bool bAllowSimpleTick; // do not fallback to full physics code even for states with action method calls

// 0: none
// 1: switches object to "k8vavoomInternalNoTickGrav" when it enters idle state (the one with negative duration)
// 2: this one switches object to "NoInteraction" when it enters idle state (the one with negative duration)
// both "no interaction" state changes removes object from blockmap
// checked in `AdvanceState()`
ubyte NoTickGravOnIdleType;

// for movement checking
float Radius;
// WARNING: for PlayerPawn, you should use `SetHeight()` method
//          actually, you'd better use this method for all entities
float Height;
// height in the vanilla engine; used in `sv_decoration_block_projectiles 0` mode
// can be zero or negative
// there is no need to save it, as it should not be modified in-game
// negative means "use absolute value in compatibility mode"
// positive means "use always"
// used only for projectiles (missiles)
transient float VanillaHeight;

// additional info record for player avatars only
// only valid if type == MT_PLAYER
BasePlayer Player;

readonly int TID; // thing identifier
readonly private Entity TIDHashNext;
readonly private Entity TIDHashPrev;

int Special; // special
int Args[5]; // special arguments

readonly private int SoundOriginID;

// params
float Mass;
float MaxStepHeight;
float MaxDropoffHeight;
float Gravity;
float Friction;

// water
ubyte WaterLevel;
ubyte WaterType;

int Score;
int Accuracy;
int Stamina;

// variables, so it may be customised
float WaterSinkFactor = 3.0;
float WaterSinkSpeed = 0.5;

float FloatBobPhase; // moved from EntityEx; in seconds
float FloatBobStrength; // default is 1

// for player sounds
name SoundClass;
name SoundGender;

// owner entity of inventory item
Entity Owner;

name DecalName;

// set this field in `BeginPlay()` to override `VThinker::SpawnThinker()` result
// this is required for `RandomSpawner`
native transient Entity BeginPlayResult;

// internal C++ fields
readonly private native transient int setStateWatchCat;
readonly private native transient state setStateNewState;

// moved here from `SkyViewpoint`, so i don't have to call any VM methods to get it
bool bAlways;
/*SkyViewpoint*/Entity Mate;
float PlaneAlpha;

// for renderer; if <= 0, use `Radius` instead
float RenderRadius;

// thing being chased/attacked (or nullptr)
// also the originator for missiles
EntityEx Target; // moved from `EntityEx`
EntityEx Tracer; // moved from `EntityEx`
EntityEx Master; // moved from `EntityEx`

transient int OwnerSUId; // for networking; will be automatically replicated by the server when `Owner` is replicated
transient int TracerSUId; // for networking; will be automatically replicated by the server when `Tracer` is replicated
transient int TargetSUId; // for networking; will be automatically replicated by the server when `Target` is replicated
transient int MasterSUId; // for networking; will be automatically replicated by the server when `Master` is replicated

// gametime when the data was sent; required for client-side prediction (and interpolation)
// interpolation not yet implemented, though
// set in `Tick()`, already delta-advanced
transient float DataGameTime;

// used in network code; set to `Ent->XLevel->Time` when we got a new origin
transient float NetLastOrgUpdateTime;


replication {
  reliable if (!bDetachComplete && (Role == ROLE_Authority || bNetDetach))
    Origin, Angles, DataGameTime,/* for interpolator*/
    FloorClip, State, StateTime, SpriteType,
    FixedSpriteName, ModelVersion, RenderStyle, Alpha,
    Translation, StencilColor, ScaleX, ScaleY,
    bFly, bNoSector, bInvisible,
    bFixedModel, SoundOriginID
    // corpse state is required for proper rendering
    // floatbob is done in renderer too
    /*, bUseDispState*/, bFullBright, bBright, bCorpse, bPseudoCorpse, bFloatBob,
    DispSpriteFrame, DispSpriteName,
    Score, Accuracy, Stamina;

  /* partial interpolation */
  /*
  reliable if (bMonster && (Role == ROLE_Authority || bNetDetach))
    LastMoveOrigin, LastMoveAngles, LastMoveTime, LastMoveDuration, bIntrJustMoved;
  */

  // if this becomes detached object, transfer those fields too
  reliable if (Role == ROLE_Authority && bNetDetach)
    // see below for `PlaneAlpha`
    bNoTickGrav, bNoTickGravLifeTime, LastMoveTime, // this is required for "notick" entities
    bNoGravity, bStickToFloor, bStickToCeiling;

  reliable if (Role == ROLE_Authority && (bNetDetach || bIsPlayer))
    Velocity;

  reliable if (Role == ROLE_Authority && bNetInitial)
    Radius, Height, VanillaHeight, RenderRadius, FloatBobStrength,
    /*DecalName,*/ bIsPlayer;

  reliable if (Role == ROLE_Authority && bNetDetach && bMissile)
    bMissile, bStepMissile,
    Target, Tracer, Master;

  reliable if (Role == ROLE_Authority && bNetInitial && bFloatBob)
    FloatBobPhase;

  reliable if (Role == ROLE_Authority && bFixedModel)
    FixedModelName;

  reliable if (Role == ROLE_Authority && bNetOwner)
    Owner;

  // `PlaneAlpha` is used for detached notickers too
  reliable if (Role == ROLE_Authority && (bNetDetach || SkyViewpoint(self)))
    bAlways, Mate, PlaneAlpha;
}


// ////////////////////////////////////////////////////////////////////////// //
// natives
native final void SetTID (int tid);

// various state functions
native final bool SetState (state State);
native final void SetInitialState (state State);
native final bool AdvanceState (float deltaTime);
native final state FindState (name StateName, optional name SubLabel, optional bool Exact);
native final state FindStateEx (string StateName, optional bool Exact);
native final state HasSpecialStates (name StateName);
native final void GetStateEffects (out array!(LightEffectDef *) Lights, out array!(ParticleEffectDef *) Particles);
native final bool HasAnyLightEffects ();
native final bool CallStateChain (Entity Actor, state State);

// sound functions
native final void PlaySound (name SoundName, int Channel, optional float Volume,
                             optional float Atenuation, optional bool Loop, optional bool Local);
native final void StopSound (int Channel);
native final bool AreSoundsEquivalent (name Sound1, name Sound2);
native final bool IsSoundPresent (name Sound);

native final void StartSoundSequence (name sequence, int ModeNum);
native final void AddSoundSequenceChoice (name Choice);
native final void StopSoundSequence ();

struct DropOffLineInfo {
  line_t *line;
  int side; // is front dropoff?
  // side -> dir:
  //  0: line->normal
  //  1: -line->normal
}

native final int FindDropOffLine (ref array!DropOffLineInfo list, TVec pos); // returns number of *added* lines (i.e. it won't clear `list`)
native final void CheckDropOff (out float DeltaX, out float DeltaY, optional float baseSpeed/*=32.0*/);

//  This routine checks for Lost Souls trying to be spawned    // phares
//  across 1-sided lines, impassible lines, or "monsters can't //   |
//  cross" lines. Draw an imaginary line between the PE        //   V
//  and the new Lost Soul spawn spot. If that line crosses
//  a 'blocking' line, then disallow the spawn. Only search
//  lines in the blocks of the blockmap where the bounding box
//  of the trajectory line resides. Then check bounding box
//  of the trajectory vs. the bounding box of each blocking
//  line to see if the trajectory and the blocking line cross.
//  Then check the PE and LS to see if they're on different
//  sides of the blocking line. If so, return true, otherwise
//  false.
native final bool CheckSides (TVec lsPos);

native final bool FixMapthingPos ();
native final bool CheckPosition (TVec Pos);
native final bool CheckRelPosition (out tmtrace_t tmtrace, TVec Pos, optional bool noPickups/*=false*/, optional bool ignoreMonsters, optional bool ignorePlayers);
native final bool CheckRelPositionPoint (out tmtrace_t tmtrace, TVec Pos); // ignores things
native final bool TryMove (TVec newPos, bool AllowDropOff, optional bool checkOnly);
native final bool TryMoveEx (out tmtrace_t tmtrace, TVec newPos, bool AllowDropOff, optional bool checkOnly);
native final bool TestMobjZ ();

// `noPickups` means "don't activate specials" too
native final void SlideMove (float StepVelScale, optional bool noPickups/*=false*/);
native final void BounceWall (float DeltaTime, const line_t *blockline, float overbounce, float bouncefactor);

// this sets `WaterLevel` and `WaterType`
native final void CheckWater ();

// moved from native to VC code
//native final void UpdateVelocity ();

// use this to get blocking height of enother entity, so missiles can use vanilla height for obstacles
native final float GetBlockingHeightFor (Entity other);

native final Entity CheckOnmobj ();

native final bool IsInPolyObj (polyobj_t *po);

// always call this before changing x and y coordinates (z can be changed freely)
// i.e. first unlink, then change coords, then link again
// by default, `LinkToWorld` checks only entity Origin.
// if you want to do a proper check, call it with `properFloorCheck:true`.
// pass -666 to force proper check (sorry for this hack)
native final void LinkToWorld (optional int properFloorCheck);
native final void UnlinkFromWorld ();

native final bool CanSee (Entity Other, optional bool disableBetterSight/*=false*/);
// always "better sight", used for radius damage
native final bool CanSeeAdv (Entity Other);
native final bool CanShoot (Entity Other);

native final iterator RoughBlockSearch (out Entity EntPtr, int Distance);

native final void SetDecorateFlag (string Name, bool Value);
native final bool GetDecorateFlag (string Name);


//==========================================================================
//
//  KeepChainResult
//
//  should be called if state action should not affect state chain results
//
//==========================================================================
final void KeepChainResult () {
  if (XLevel && XLevel.StateCall) XLevel.StateCall->Result = 0;
}


//==========================================================================
//
//  SuccessChainResult
//
//  should be called if state action should success state chain results
//  note that only the last called action can success
//
//==========================================================================
final void SuccessChainResult () {
  if (XLevel && XLevel.StateCall) XLevel.StateCall->Result = 1;
}


//==========================================================================
//
//  CopyTranslations
//
//==========================================================================
void CopyTranslations (Entity src) {
  if (src) {
    Translation = src.Translation;
  }
}


//==========================================================================
//
//  UpdateVelocity
//
//  called from entity `Physics()`
//  you can override it
//
//==========================================================================
native void UpdateVelocity (float DeltaTime, bool allowSlopeFriction);


//===========================================================================
//
//  OnMapSpawn
//
//===========================================================================
void OnMapSpawn (mthing_t *mthing) {
  if (mthing && mthing./*health*/bUseHealth) {
    // per specs
    Health = int((mthing.health < 0 ? -1 : Health)*mthing.health);
    // overflow protection
    if (Health < 0) Health = int.max/8;
    Health = min(Health, int.max/8);
  }
  InitialHealth = Health;
}


//==========================================================================
//
//  BeginPlay
//
//==========================================================================
void BeginPlay () {
}


//==========================================================================
//
//  Destroyed
//
//==========================================================================
void Destroyed () {
}


//==========================================================================
//
//  Touch
//
//  return `false` if movement should be blocked
//  if `disableEffects` is true, don't perform any special effects
//
//==========================================================================
bool Touch (Entity Other, bool disableEffects) {
  return (Other.bCorpse ? true : !Other.bSolid);
}


//===========================================================================
//
//  CheckForPushSpecial
//
//===========================================================================
void CheckForPushSpecial (line_t *line, int side) {
}


//==========================================================================
//
//  BlastedHitLine
//
//==========================================================================
void BlastedHitLine () {
}


//==========================================================================
//
//  PushLine
//
//==========================================================================
void PushLine (tmtrace_t *tmtrace) {
}


//==========================================================================
//
//  HandleFloorclip
//
//==========================================================================
void HandleFloorclip () {
}


//==========================================================================
//
//  CrossSpecialLine
//
//==========================================================================
void CrossSpecialLine (line_t *ld, int side) {
}


//==========================================================================
//
//  ApplyFriction
//
//==========================================================================
void ApplyFriction (float DeltaTime) {
}


//==========================================================================
//
//  SectorChanged
//  called after sector height changed, to notify things
//  `CrushChange` means "crush unfitting actors"
//  returns `false` if actor cannot fit
//
//==========================================================================
bool SectorChanged (int CrushChange) {
  return true;
}


//===========================================================================
//
//  ClearInventory
//
//===========================================================================
void ClearInventory () {
}


//===========================================================================
//
//  EngineHelperGetInventory
//
//===========================================================================
Entity EngineHelperGetInventory () {
  return none;
}


//===========================================================================
//
//  GiveInventory
//
//===========================================================================
void GiveInventory (name ItemName, int Amount, bool allowReplacement) {
}


//===========================================================================
//
//  TakeInventory
//
//===========================================================================
void TakeInventory (name ItemName, int Amount, bool allowReplacement) {
}


//===========================================================================
//
//  CheckInventory
//
//===========================================================================
int CheckInventory (name ItemName, bool allowReplacement, bool fromACS) {
  return 0;
}


//===========================================================================
//
//  UseInventoryName
//
//===========================================================================
int UseInventoryName (name ItemName, bool allowReplacement) {
  return 0;
}


//===========================================================================
//
//  GetSigilPieces
//
//===========================================================================
int GetSigilPieces () {
  return 0;
}


//===========================================================================
//
//  GetArmorPoints
//
//===========================================================================
int GetArmorPoints () {
  return 0;
}


//===========================================================================
//
//  GetArmorPointsForType
//
//===========================================================================
int GetArmorPointsForType (name armtype) {
  return 0;
}


//===========================================================================
//
//  CheckNamedWeapon
//
//  used from ACS
//
//===========================================================================
int CheckNamedWeapon (name Name) {
  return 0;
}


//===========================================================================
//
//  SetNamedWeapon
//
//  used from ACS
//
//===========================================================================
int SetNamedWeapon (name Name) {
  return 0;
}


//===========================================================================
//
//  GetAmmoCapacity
//
//===========================================================================
int GetAmmoCapacity (name Name) {
  return 0;
}


//===========================================================================
//
//  SetAmmoCapacity
//
//===========================================================================
void SetAmmoCapacity (name Name, int Amount) {
}


//===========================================================================
//
//  MoveThing
//
//===========================================================================
bool MoveThing (TVec Pos, bool Fog) {
  return false;
}


//==========================================================================
//
//  GetStateTime
//
//==========================================================================
float GetStateTime (state AState, float AStateTime) {
  int a0, a1, t;
  switch (GetStateTicKind(AState)) {
    case StateTicKind.Normal: return AStateTime;
    case StateTicKind.Random:
      a0 = max(0, GetStateArgN(AState, 0));
      a1 = max(0, GetStateArgN(AState, 1));
           if (a0 > a1) { t = a0; a0 = a1; a1 = t; }
      else if (a0 == a1) return float(a0)/35.0f;
      return float(a0+trunci(Random()*(a1-a0+1)))/35.0f;
    default: return AStateTime;
  }
}


//==========================================================================
//
//  SetActorProperty
//
//==========================================================================
void SetActorProperty (int Prop, int IntVal, string StrVal) {
}


//==========================================================================
//
//  GetActorProperty
//
//==========================================================================
int GetActorProperty (int Prop) {
  return 0;
}


//==========================================================================
//
//  CheckForSectorActions
//
//==========================================================================
void CheckForSectorActions (sector_t *OldSec, bool OldAboveFakeFloor,
                            bool OldAboveFakeCeiling)
{
}


/*
bool SkyBoxGetAlways () { return false; }
Entity SkyBoxGetMate () { return none; }
float SkyBoxGetPlaneAlpha () { return 0.0; }
*/


//==========================================================================
//
//  ClassifyActor
//
//==========================================================================
int ClassifyActor () {
  return 0;
}


//==========================================================================
//
//  MorphActor
//
//==========================================================================
int MorphActor (name PlayerClass, name MonsterClass, float Duration,
                int Style, name MorphFlash, name UnmorphFlash)
{
  return 0;
}


//==========================================================================
//
//  UnmorphActor
//
//==========================================================================
int UnmorphActor (Entity Activator, int Force) {
  return 0;
}


//==========================================================================
//
//  GetViewEntRenderParams
//
//==========================================================================
void GetViewEntRenderParams (ref float OutAlpha, ref int OutRenderStyle) {
}


//==========================================================================
//
//  CalcFakeZMovement
//
//==========================================================================
void CalcFakeZMovement (out TVec Ret, float DeltaTime) {
}


//==========================================================================
//
//  SetOrigin
//
//  pass -666 to force proper check (sorry for this hack)
//
//==========================================================================
final void SetOrigin (TVec NewOrigin, optional int properFloorCheck) {
  UnlinkFromWorld();
  Origin = NewOrigin;
  LastMoveOrigin = NewOrigin;
  bIntrJustMoved = false;
  LinkToWorld(properFloorCheck:properFloorCheck!optional);
}


//==========================================================================
//
//  RemoveThing
//
//==========================================================================
void RemoveThing () {
  Destroy();
}


//==========================================================================
//
//  GetViewHeight
//
//==========================================================================
float GetViewHeight () {
  return fmax(0, Height*0.5);
}


//==========================================================================
//
//  GetCenter
//
//==========================================================================
final TVec GetCenter () {
  return Origin+vector(0.0, 0.0, Height*0.5-FloorClip);
}


//==========================================================================
//
//  GetCenterZ
//
//==========================================================================
final float GetCenterZ () {
  return Origin.z+(Height*0.5-FloorClip);
}


//==========================================================================
//
//  DistTo
//
//==========================================================================
final float DistTo (Entity Other) {
  return Length(Other.GetCenter()-GetCenter());
}


//==========================================================================
//
//  DistToSquared
//
//==========================================================================
final float DistToSquared (Entity Other) {
  return LengthSquared(Other.GetCenter()-GetCenter());
}


//==========================================================================
//
//  DistTo2
//
//==========================================================================
final float DistTo2 (Entity Other) {
  TVec dir = Other.Origin-Origin;
  dir.z = 0.0;
  return Length2D(dir);
}


//==========================================================================
//
//  DistTo2Squared
//
//==========================================================================
final float DistTo2Squared (Entity Other) {
  TVec dir = Other.Origin-Origin;
  //dir.z = 0.0;
  return Length2DSquared(dir);
}


//==========================================================================
//
//  AngleTo
//
//==========================================================================
final float AngleTo (Entity Other) {
  TVec dir = Other.Origin-Origin;
  float res = atan2(dir.y, dir.x);
  return (res.isfinite ? res : 0);
}


//==========================================================================
//
//  AngleToWithOfs
//
//==========================================================================
final float AngleToWithOfs (Entity Other, const TVec ofs) {
  TVec dir = (Other.Origin-Origin)+ofs;
  float res = atan2(dir.y, dir.x);
  return (res.isfinite ? res : 0);
}


//==========================================================================
//
//  AngleDelta
//
//  returns signed angle from a1 to a2, [-180..180]
//
//==========================================================================
static final float AngleDelta (float a1, float a2) {
  return AngleMod360(a2-a1+180)-180;
}


//===========================================================================
//
//  FindActivePowerupTime
//
//===========================================================================
float FindActivePowerupTime (name className) {
  return 0;
}


//===========================================================================
//
//  PickActor
//
//===========================================================================
Entity PickActor (optional TVec org, TVec dir, float distance, optional int actorMask, optional int wallMask) {
  return none;
}


//===========================================================================
//
//  eventDoAAPtr
//
//===========================================================================
Entity eventDoAAPtr (int ptr) {
  if (ptr == 0) return self;
  return none;
}


//===========================================================================
//
//  eventFindTargetForACS
//
//===========================================================================
Entity eventFindTargetForACS () {
  return none;
}


//===========================================================================
//
//  eventSetPointerForACS
//
//===========================================================================
bool eventSetPointerForACS (int assign_slot, int atid, int aptr, int flags) {
  return 0;
}


//===========================================================================
//
//  eventLineAttackACS
//
//===========================================================================
void eventLineAttackACS (TVec dir, float distance, int LADamage, name aPuffType, name damagetype, int flags, int pufftid) {
}


// ////////////////////////////////////////////////////////////////////////// //
// for decorate
final float _GetOriginX () { return Origin.x; }
final float _GetOriginY () { return Origin.y; }
final float _GetOriginZ () { return Origin.z; }

final float _GetVelocityX () { return Velocity.x; }
final float _GetVelocityY () { return Velocity.y; }
final float _GetVelocityZ () { return Velocity.z; }

final float _GetAnglesYaw () { return Angles.yaw; }
final float _GetAnglesPitch () { return Angles.pitch; }
final float _GetAnglesRoll () { return Angles.roll; }


//==========================================================================
//
//  GetHeight
//
//  use this instead of directly reading `Height`
//  this is required due to height modifications in PlayerPawn
//
//==========================================================================
float GetHeight () {
  return Height;
}


//==========================================================================
//
//  SetHeight
//
//  use this instead of directly changing `Height`
//  this is required due to height modifications in PlayerPawn
//
//==========================================================================
void SetHeight (float newvalue) {
  Height = newvalue;
}


//==========================================================================
//
//  eventDropItem
//
//==========================================================================
bool eventDropItem (name itemName, int amount, float chance) {
  return false;
}


//==========================================================================
//
//  ACSDropInventory
//
//==========================================================================
bool ACSDropInventory (name itemName) {
  return false;
}


//==========================================================================
//
//  ACSIsPointerEqual
//
//==========================================================================
bool ACSIsPointerEqual (int aptr0, int aptr1, Entity src1) {
  return false;
}


//===========================================================================
//
//  ACSCanRaise
//
//===========================================================================
state CanRaise () {
  return none;
}


//==========================================================================
//
//  ClearEntityInventoryQS
//
//==========================================================================
void QS_ClearEntityInventory () {}


//==========================================================================
//
//  GetEntityInventoryQS
//
//  returns entity `Inventory` field, or `none`
//
//==========================================================================
Entity QS_GetEntityInventory () { return none; }


//==========================================================================
//
//  SpawnEntityInventoryQS
//
//  adds to current inventory
//
//==========================================================================
Entity QS_SpawnEntityInventory (name className) { return none; }


//==========================================================================
//
//  QS_Save
//
//==========================================================================
void QS_Save () {}


//==========================================================================
//
//  QS_Load
//
//==========================================================================
void QS_Load () {}


//==========================================================================
//
//  do_CheckProximity
//
//  this is used both for decorate and for ACSF
//
//==========================================================================
bool do_CheckProximity (name classname, float distance, optional int count, optional int flags, optional int aptr) {
  return false;
}


//==========================================================================
//
//  PhysicsCheckScroller
//
//  returns `true` if this Entity is standing on a scroller
//  all prerequisites are checked by the C++ code
//
//==========================================================================
bool PhysicsCheckScroller () {
  return true;
}


//==========================================================================
//
//  SimplifiedTick
//
//  called when entity doesn't need physics
//
//==========================================================================
void SimplifiedTick (float deltaTime) {
}


//==========================================================================
//
//  DamageMe
//
//  so we will be able to call this from C++ code
//
//==========================================================================
final int DamageMe (Entity target, Entity inflictor, Entity source, int damage,
                    name DmgType, bool NoArmor, bool forced,
                    bool spawnBlood, bool ignoreDamageFactors, bool ignorePowerups)
{
  EntityEx etarget = EntityEx(self);
  if (!etarget) return 0;
  //k8: clamp damage, just because
  return etarget.Damage(EntityEx(inflictor), EntityEx(source), clamp(damage, 0, 100000), DmgType, NoArmor, forced, spawnBlood, ignoreDamageFactors, ignorePowerups);
}


//==========================================================================
//
//  GibMe
//
//  crunch bodies to giblets
//  this entity may be destroyed (replaced with giblets)
//  returns `nullptr` on failure, or giblets (may return self)
//  this won't gib entities with `Health > 0`, and non-gibbing
//  note that returned entity may be already destroyed
//
//  `gibtype` is "Death" state suffix (may be '')
//
//  so we will be able to call this from C++ code
//
//==========================================================================
final Entity GibMe (name gibtype) {
  EntityEx etarget = EntityEx(self);
  if (!etarget) return none;
  return etarget.GibEntity(gibtype);
}


//==========================================================================
//
//  GetTouchedFloorSector
//
//  used for 3d floors
//  can return `nullptr`
//  `orgsector` can be used to avoid BSP search (nullptr allowed)
//
//==========================================================================
// this prefers swimmable sector
native final sector_t *GetTouchedFloorSector ();
// this returns solid sector (if any), and swimmable (if any)
native final sector_t *GetTouchedFloorSectorEx (out sector_t *swimmable);


// ////////////////////////////////////////////////////////////////////////// //
// this is hack used for quicksaves
native final void QS_PutInt (string fieldname, int value);
native final void QS_PutName (string fieldname, name value);
native final void QS_PutStr (string fieldname, string value);
native final void QS_PutFloat (string fieldname, float value);

native final int QS_GetInt (string fieldname, optional int defvalue);
native final name QS_GetName (string fieldname, optional name defvalue);
native final string QS_GetStr (string fieldname, optional string defvalue);
native final float QS_GetFloat (string fieldname, optional float defvalue);


defaultproperties {
  RenderStyle = STYLE_Normal;
  Alpha = 1.0;
  ScaleX = 1.0;
  ScaleY = 1.0;
  bColideWithThings = true;
  bColideWithWorld = true;
  MaxDropoffHeight = 24.0;
  Gravity = 1.0;
  Friction = 1.0;
  SoundClass = 'player';
  SoundGender = 'male';
  FloatBobPhase = -1.0f;
  FloatBobStrength = 1.0;
}
