//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class GameObject : Object native abstract;

const int TICRATE = 35;

enum {
  // Generate the sprite's axes, with sprup straight up in worldspace,
  // and sprright parallel to the viewplane.
  SPR_VP_PARALLEL_UPRIGHT,
  // Generate the sprite's axes, with sprup straight up in worldspace,
  // and sprright perpendicular to sprorigin.
  SPR_FACING_UPRIGHT,
  // Generate the sprite's axes, completely parallel to the viewplane.
  SPR_VP_PARALLEL,
  // Generate the sprite's axes, according to the sprite's world
  // orientation
  SPR_ORIENTED,
  // Generate the sprite's axes, parallel to the viewplane, but
  // rotated in that plane around the centre according to the sprite
  // entity's roll angle. So sprforward stays the same, but sprright
  // and sprup rotate
  SPR_VP_PARALLEL_ORIENTED,
  // Generate the sprite's axes, with sprup straight up in worldspace,
  // and sprright parallel to the viewplane and then rotated in that
  // plane around the centre according to the sprite entity's roll
  // angle. So sprforward stays the same, but sprright and sprup rotate
  SPR_VP_PARALLEL_UPRIGHT_ORIENTED,
  //
  SPR_ORIENTED_OFS, // 6 (offset slightly by pitch -- for floor/ceiling splats)
};

// frame flags:
// handles maximum brightness (torches, muzzle flare, light sources)
enum {
  FF_FRAMEMASK  = 0x7f,

  FF_FULLBRIGHT = 0x00080, // flag in Frame
  FF_CANRAISE   = 0x00100, // flag in Frame
  FF_DONTCHANGE = 0x00200, // keep old frame
  FF_SKIPOFFS   = 0x00400, // skip this state in offset calculation
  FF_SKIPMODEL  = 0x00800, // skip this state in model frame numbering
  FF_FAST       = 0x01000, // flag in Frame
  FF_SLOW       = 0x02000, // flag in Frame
  FF_KEEPSPRITE = 0x04000, // sprite number can be replaced, so we need to store this flag
};

enum {
  ps_weapon,
  ps_flash,
  NUMPSPRITES
};

// button/action code definitions
enum {
  BT_ATTACK      = 0x00000001, // press "fire"
  BT_USE         = 0x00000002, // use button, to open doors, activate switches
  BT_JUMP        = 0x00000004,
  BT_ALT_ATTACK  = 0x00000008,
  BT_BUTTON_5    = 0x00000010,
  BT_BUTTON_6    = 0x00000020,
  BT_BUTTON_7    = 0x00000040,
  BT_BUTTON_8    = 0x00000080,
  BT_RELOAD      = 0x00000100,
  BT_SPEED       = 0x00000200,
  BT_STRAFE      = 0x00000400,
  BT_CROUCH      = 0x00000800,
  BT_MOVELEFT    = 0x00001000,
  BT_MOVERIGHT   = 0x00002000,
  BT_LEFT        = 0x00004000,
  BT_RIGHT       = 0x00008000,
  BT_FORWARD     = 0x00010000,
  BT_BACKWARD    = 0x00020000,
  BT_FLASHLIGHT  = 0x00100000,
  BT_SUPERBULLET = 0x00200000,
};

// player states
enum {
  PST_LIVE, // playing or camping
  PST_DEAD, // dead on the ground, view follows killer
  PST_REBORN, // ready to restart/respawn?
};

enum {
  DI_EAST,
  DI_NORTHEAST,
  DI_NORTH,
  DI_NORTHWEST,
  DI_WEST,
  DI_SOUTHWEST,
  DI_SOUTH,
  DI_SOUTHEAST,
  DI_NODIR,
  NUMDIRS
};

enum {
  RES_OK,
  RES_CRUSHED,
  RES_PASTDEST,
};

const float MAXRADIUS = 32.0;

// LineDef attributes
const int
  ML_BLOCKING            = 0x00000001, // Solid, is an obstacle.
  ML_BLOCKMONSTERS       = 0x00000002, // Blocks monsters only.
  ML_TWOSIDED            = 0x00000004, // Backside will not be present at all
  ML_DONTPEGTOP          = 0x00000008, // upper texture unpegged
  ML_DONTPEGBOTTOM       = 0x00000010, // lower texture unpegged
  ML_SECRET              = 0x00000020, // don't map as two sided: IT'S A SECRET!
  ML_SOUNDBLOCK          = 0x00000040, // don't let sound cross two of these
  ML_DONTDRAW            = 0x00000080, // don't draw on the automap
  ML_MAPPED              = 0x00000100, // set if already drawn in automap
  ML_REPEAT_SPECIAL      = 0x00000200, // special is repeatable
  ML_ADDITIVE            = 0x00000400, // Additive translucency.
  ML_MONSTERSCANACTIVATE = 0x00002000, // Monsters (as well as players) can activate the line
  ML_BLOCKPLAYERS        = 0x00004000, // Blocks players only.
  ML_BLOCKEVERYTHING     = 0x00008000, // Line blocks everything.
  ML_ZONEBOUNDARY        = 0x00010000, // Boundary of reverb zones.
  ML_RAILING             = 0x00020000,
  ML_BLOCK_FLOATERS      = 0x00040000,
  ML_CLIP_MIDTEX         = 0x00080000, // Automatic for every Strife line
  ML_WRAP_MIDTEX         = 0x00100000,
  ML_3DMIDTEX            = 0x00200000, // not implemented
  ML_CHECKSWITCHRANGE    = 0x00400000, // not implemented: if a switch is completely above or below the player and this option is on, the switch won't activate
  ML_FIRSTSIDEONLY       = 0x00800000, // Actiavte only when crossed from front side.
  ML_BLOCKPROJECTILE     = 0x01000000,
  ML_BLOCKUSE            = 0x02000000, // blocks all use actions through this line
  ML_BLOCKSIGHT          = 0x04000000, // blocks monster line of sight
  ML_BLOCKHITSCAN        = 0x08000000, // blocks hitscan attacks
  ML_3DMIDTEX_IMPASS     = 0x10000000, // (not implemented) [TP] if 3D midtex, behaves like a height-restricted ML_BLOCKING
  ML_KEEPDATA            = 0x20000000, // keep FloorData or CeilingData after activating them
                                       // used to simulate original Heretic behaviour
  ML_NODECAL             = 0x40000000; // don't spawn decals on this linedef

// these will be converted
const int
  ML_PASSUSE_BOOM          = 0x0200, // Boom's ML_PASSUSE flag (conflicts with ML_REPEAT_SPECIAL)
  ML_RAILING_STRIFE        = 0x0200,
  ML_BLOCK_FLOATERS_STRIFE = 0x0400,
  ML_UNKNOWN2_STRIFE       = 0x0800,
  ML_TRANSLUCENT_STRIFE    = 0x1000;

// special activation types
enum {
  SPAC_Cross      = 0x0001, // when player crosses line
  SPAC_Use        = 0x0002, // when player uses line
  SPAC_MCross     = 0x0004, // when monster crosses line
  SPAC_Impact     = 0x0008, // when projectile hits line
  SPAC_Push       = 0x0010, // when player pushes line
  SPAC_PCross     = 0x0020, // when projectile crosses line
  SPAC_UseThrough = 0x0040, // SPAC_USE, but passes it through
  // SPAC_PTouch is remapped as SPAC_Impact|SPAC_PCross
  SPAC_AnyCross   = 0x0080,
  SPAC_MUse       = 0x0100, // when monster uses line
  SPAC_MPush      = 0x0200, // when monster pushes line
  SPAC_UseBack    = 0x0400, // can be used from the backside
};

// sector plane flags
enum {
  SPF_NOBLOCKING   = 1,
  SPF_NOBLOCKSIGHT = 2,
  SPF_NOBLOCKSHOOT = 4,
  SPF_ADDITIVE     = 8,
};

const int SKY_FROM_SIDE = 0x8000;

// sidedef flags
const int SDF_ABSLIGHT = 0x0001; // light is absolute value

const float ATTN_NONE   = 0.0;
const float ATTN_NORMAL = 1.0;
const float ATTN_IDLE   = 2.0;
const float ATTN_STATIC = 3.0;

enum {
  PT_ADDLINES  = 1,
  PT_ADDTHINGS = 2,
  PT_EARLYOUT  = 4,
};

const float DEFAULT_GRAVITY = 1225.0;

enum {
  SEQ_Door,
  SEQ_Platform,
  SEQ_Environment
};

enum {
  SECSPEC_None,
  SECSPEC_LightPhased,
  SECSPEC_LightSequenceStart,
  SECSPEC_LightSequence,
  SECSPEC_LightSequenceAlt,

  SECSPEC_StairsSpecial1 = 26,
  SECSPEC_StairsSpecial2,

  SECSPEC_WindEastSlow = 40,//40
  SECSPEC_WindEastMedium,
  SECSPEC_WindEastFast,
  SECSPEC_WindNorthSlow,
  SECSPEC_WindNorthMedium,
  SECSPEC_WindNorthFast,
  SECSPEC_WindSouthSlow,
  SECSPEC_WindSouthMedium,
  SECSPEC_WindSouthFast,
  SECSPEC_WindWestSlow,
  SECSPEC_WindWestMedium,//50
  SECSPEC_WindWestFast,

  SECSPEC_LightFlicker = 65,
  SECSPEC_LightStrobeFast,
  SECSPEC_LightStrobeSlow,
  SECSPEC_LightStrobeFastDamage,
  SECSPEC_DamageHellslime,
  SECSPEC_DamageSludge,//70
  SECSPEC_DamageNukage,
  SECSPEC_LightGlow,

  SECSPEC_DoorCloseIn30 = 74,
  SECSPEC_DamageSuperHellslimeExit,
  SECSPEC_LightSyncStrobeSlow,
  SECSPEC_LightSyncStrobeFast,
  SECSPEC_DoorRaiseIn5Minutes,
  SECSPEC_FrictionLow,
  SECSPEC_DamageSuperHellslime,// 80
  SECSPEC_LightFireFlicker,
  SECSPEC_DamageLavaWimpy,
  SECSPEC_DamageLavaHefty,
  SECSPEC_ScrollEastLavaDamage,

  SECSPEC_DamageHazard = 105,

  SECSPEC_DamageInstantDeath = 115,
  SECSPEC_DamageSuperHazard,

  SECSPEC_ScrollCurrent = 118,

  //  These are handled by the engine.
  SECSPEC_LightningOutdoor = 197,
  SECSPEC_LightningIndoor1,
  SECSPEC_Lightningindoor2,
  SECSPEC_Sky2,//200
  SECSPEC_ScrollNorthSlow,
  SECSPEC_ScrollNorthMedium,
  SECSPEC_ScrollNorthFast,
  SECSPEC_ScrollEastSlow,
  SECSPEC_ScrollEastMedium,
  SECSPEC_ScrollEastFast,
  SECSPEC_ScrollSouthSlow,
  SECSPEC_ScrollSouthMedium,
  SECSPEC_ScrollSouthFast,
  SECSPEC_ScrollWestSlow,//210
  SECSPEC_ScrollWestMedium,
  SECSPEC_ScrollWestFast,
  SECSPEC_ScrollNorthWestSlow,
  SECSPEC_ScrollNorthWestMedium,
  SECSPEC_ScrollNorthWestFast,
  SECSPEC_ScrollNorthEastSlow,
  SECSPEC_ScrollNorthEastMedium,
  SECSPEC_ScrollNorthEastFast,
  SECSPEC_ScrollSouthEastSlow,
  SECSPEC_ScrollSouthEastMedium,//220
  SECSPEC_ScrollSouthEastFast,
  SECSPEC_ScrollSouthWestSlow,
  SECSPEC_ScrollSouthWestMedium,
  SECSPEC_ScrollSouthWestFast,
  SECSPEC_ScrollEast5,
  SECSPEC_ScrollEast10,
  SECSPEC_ScrollEast25,
  SECSPEC_ScrollEast30,
  SECSPEC_ScrollEast35,
  SECSPEC_ScrollNorth5,//230
  SECSPEC_ScrollNorth10,
  SECSPEC_ScrollNorth25,
  SECSPEC_ScrollNorth30,
  SECSPEC_ScrollNorth35,
  SECSPEC_ScrollSouth5,
  SECSPEC_ScrollSouth10,
  SECSPEC_ScrollSouth25,
  SECSPEC_ScrollSouth30,
  SECSPEC_ScrollSouth35,
  SECSPEC_ScrollWest5,//240
  SECSPEC_ScrollWest10,
  SECSPEC_ScrollWest25,
  SECSPEC_ScrollWest30,
  SECSPEC_ScrollWest35,

  SECSPEC_Max
};

enum {
  SECSPEC_BASE_MASK     = 0x00ff,
  SECSPEC_DAMAGE_MASK   = 0x0300,
  SECSPEC_SECRET_MASK   = 0x0400,
  SECSPEC_FRICTION_MASK = 0x0800,
  SECSPEC_PUSH_MASK     = 0x1000,
};

enum {
  LNSPEC_None,
  LNSPEC_PolyStartLine,
  LNSPEC_PolyRotateLeft,
  LNSPEC_PolyRotateRight,
  LNSPEC_PolyMove,
  LNSPEC_PolyExplicitLine,
  LNSPEC_PolyMoveTimes8,
  LNSPEC_PolyDoorSwing,
  LNSPEC_PolyDoorSlide,
  LNSPEC_LineHorizon,
  LNSPEC_DoorClose,// 10
  LNSPEC_DoorOpen,
  LNSPEC_DoorRaise,
  LNSPEC_DoorLockedRaise,
  LNSPEC_DoorAnimated,
  LNSPEC_Autosave,
  LNSPEC_TransferWallLight,
  LNSPEC_ThingRaise,
  LNSPEC_StartConversation,
  LNSPEC_ThingStop,
  LNSPEC_FloorLowerByValue,// 20
  LNSPEC_FloorLowerToLowest,
  LNSPEC_FloorLowerToNearest,
  LNSPEC_FloorRaiseByValue,
  LNSPEC_FloorRaiseToHighest,
  LNSPEC_FloorRaiseToNearest,
  LNSPEC_StairsBuildDownNormal,
  LNSPEC_StairsBuildUpNormal,
  LNSPEC_FloorRaiseAndCrush,
  LNSPEC_PillarBuild,
  LNSPEC_PillarOpen,// 30
  LNSPEC_StairsBuildDownSync,
  LNSPEC_StairsBuildUpSync,
  LNSPEC_ForceField,
  LNSPEC_ClearForceField,
  LNSPEC_FloorRaiseByValueTimes8,
  LNSPEC_FloorLowerByValueTimes8,
  LNSPEC_FloorMoveToValue,
  LNSPEC_CeilingWaggle,
  LNSPEC_TeleportZombieChanger,
  LNSPEC_CeilingLowerByValue,// 40
  LNSPEC_CeilingRaiseByValue,
  LNSPEC_CeilingCrushAndRaise,
  LNSPEC_CeilingLowerAndCrush,
  LNSPEC_CeilingCrushStop,
  LNSPEC_CeilingCrushRaiseAndStay,
  LNSPEC_FloorCrushStop,
  LNSPEC_CeilingMoveToValue,

  LNSPEC_GlassBreak = 49,
  LNSPEC_ExtraFloorLightOnly = 50,

  LNSPEC_SectorSetLink = 51,
  LNSPEC_ScrollWall = 52,
  LNSPEC_LineSetTextureOffset,
  LNSPEC_SectorChangeFlags,
  LNSPEC_LineSetBlocking, // 55

  LNSPEC_PolyobjMoveToSpotOverride = 59,

  LNSPEC_PlatPerpetualRaise = 60,
  LNSPEC_PlatStop,
  LNSPEC_PlatDownWaitUpStay,
  LNSPEC_PlatDownByValueWaitUpStay,
  LNSPEC_PlatUpWaitDownStay,
  LNSPEC_PlatUpByValueWaitDownStay,
  LNSPEC_FloorLowerTimes8Instant,
  LNSPEC_FloorRaiseTimes8Instant,
  LNSPEC_FloorMoveToValueTimes8,
  LNSPEC_CeilingMoveToValueTimes8,
  LNSPEC_Teleport,// 70
  LNSPEC_TeleportNoFog,
  LNSPEC_ThrustThing,
  LNSPEC_DamageThing,
  LNSPEC_TeleportNewMap,
  LNSPEC_TeleportEndGame,
  LNSPEC_TeleportOther,
  LNSPEC_TeleportGroup,
  LNSPEC_TeleportSector,

  LNSPEC_ACSExecute = 80,// 80
  LNSPEC_ACSSuspend,
  LNSPEC_ACSTerminate,
  LNSPEC_ACSLockedExecute,
  LNSPEC_ACSExecuteWithResult,
  LNSPEC_ACSLockedExecuteDoor,

  LNSPEC_PolyobjMoveToSpot = 86,
  LNSPEC_PolyobjStop = 87,
  LNSPEC_PolyobjMoveTo = 88,
  LNSPEC_PolyobjMoveToOverride = 89,

  LNSPEC_PolyRotateLeftOverride = 90,// 90
  LNSPEC_PolyRotateRightOverride,
  LNSPEC_PolyMoveOverride,
  LNSPEC_PolyMoveTimes8Override,
  LNSPEC_PillarBuildCrush,
  LNSPEC_FloorAndCeilingLowerByValue,
  LNSPEC_FloorAndCeilingRaiseByValue,

  LNSPEC_ScrollTextureLeft = 100,// 100
  LNSPEC_ScrollTextureRight,
  LNSPEC_ScrollTextureUp,
  LNSPEC_ScrollTextureDown,

  LNSPEC_LightForceLightning = 109,
  LNSPEC_LightRaiseByValue,// 110
  LNSPEC_LightLowerByValue,
  LNSPEC_LightChangeToValue,
  LNSPEC_LightFade,
  LNSPEC_LightGlow,
  LNSPEC_LightFlicker,
  LNSPEC_LightStrobe,
  LNSPEC_LightStop,

  LNSPEC_PlaneCopy, // 118

  LNSPEC_ThingDamage = 119,
  LNSPEC_QuakeTremor,// 120
  LNSPEC_LineSetIdentification,

  LNSPEC_ThingMove = 125,

  LNSPEC_ThingSetSpecial = 127,
  LNSPEC_ThrustThingZ,

  LNSPEC_UsePuzzleItem = 129,
  LNSPEC_ThingActivate,// 130
  LNSPEC_ThingDeactivate,
  LNSPEC_ThingRemove,
  LNSPEC_ThingDestroy,
  LNSPEC_ThingProjectile,
  LNSPEC_ThingSpawn,
  LNSPEC_ThingProjectileGravity,
  LNSPEC_ThingSpawnNoFog,
  LNSPEC_FloorWaggle,
  LNSPEC_ThingSpawnFacing,
  LNSPEC_SectorSoundChange,// 140

  LNSPEC_SectorSetPlaneReflection = 159,
  LNSPEC_SectorSet3dFloor,// 160
  LNSPEC_Contents,

  LNSPEC_CeilingGenericCrush2 = 169,
  LNSPEC_SectorSetCeilingScale2,// 170
  LNSPEC_SectorSetFloorScale2,
  LNSPEC_PlaneUpNearestWaitDownStay,
  LNSPEC_NoiseAlert,
  LNSPEC_SendToCommunicator,
  LNSPEC_ThingProjectileIntercept,
  LNSPEC_ThingChangeTID,
  LNSPEC_ThingHate,
  LNSPEC_ThingProjectileAimed,
  LNSPEC_ChangeSkill,
  LNSPEC_ThingSetTranslation,// 180
  LNSPEC_PlaneAlign,
  LNSPEC_LineMirror,
  LNSPEC_LineAlignCeiling,
  LNSPEC_LineAlignFloor,
  LNSPEC_SectorSetRotation,
  LNSPEC_SectorSetCeilingPanning,
  LNSPEC_SectorSetFloorPanning,
  LNSPEC_SectorSetCeilingScale,
  LNSPEC_SectorSetFloorScale,
  LNSPEC_StaticInit,// 190
  LNSPEC_SetPlayerProperty,
  LNSPEC_CeilingLowerToHighestFloor,
  LNSPEC_CeilingLowerInstant,
  LNSPEC_CeilingRaiseInstant,
  LNSPEC_CeilingCrushRaiseAndStayA,
  LNSPEC_CeilingCrushAndRaiseA,
  LNSPEC_CeilingCrushAndRaiseSilentA,
  LNSPEC_CeilingRaiseByValueTimes8,
  LNSPEC_CeilingLowerByValueTimes8,
  LNSPEC_FloorGeneric,// 200
  LNSPEC_CeilingGeneric,
  LNSPEC_DoorGeneric,
  LNSPEC_PlatGeneric,
  LNSPEC_StairsGeneric,
  LNSPEC_CeilingGenericCrush,
  LNSPEC_PlatDownWaitUpStayLip,
  LNSPEC_PlatPerpetualRaiseLip,
  LNSPEC_LineTranslucent,
  LNSPEC_TransferHeights,
  LNSPEC_TransferFloorLight,// 210
  LNSPEC_TransferCeilingLight,
  LNSPEC_SectorSetColour,
  LNSPEC_SectorSetFade,
  LNSPEC_SectorSetDamage,
  LNSPEC_TeleportLine,
  LNSPEC_SectorSetGravity,
  LNSPEC_StairsBuildUpDoom,
  LNSPEC_SectorSetWind,
  LNSPEC_SectorSetFriction,
  LNSPEC_SectorSetCurrent,// 220
  LNSPEC_ScrollTextureBoth,
  LNSPEC_ScrollTextureModel,
  LNSPEC_ScrollFloor,
  LNSPEC_ScrollCeiling,
  LNSPEC_ScrollTextureOffsets,
  LNSPEC_ACSExecuteAlways,
  LNSPEC_PointPushSetForce,
  LNSPEC_FloorRaiseToNearestChange,
  LNSPEC_ThingSetGoal,
  LNSPEC_FloorRaiseByValueChangeTex,// 230
  LNSPEC_PlatToggle,
  LNSPEC_LightStrobeDoom,
  LNSPEC_LightMinNeighbor,
  LNSPEC_LightMaxNeighbor,
  LNSPEC_FloorTransferTrigger,
  LNSPEC_FloorTransferNumeric,
  LNSPEC_ChangeCamera,
  LNSPEC_FloorRaiseToLowestCeiling,
  LNSPEC_FloorRaiseByValueChange,
  LNSPEC_FloorRaiseByTexture,// 240
  LNSPEC_FloorLowerToLowestChange,
  LNSPEC_FloorLowerToHighest,
  LNSPEC_ExitNormal,
  LNSPEC_ExitSecret,
  LNSPEC_ElevatorRaiseToNearest,
  LNSPEC_ElevatorMoveToFloor,
  LNSPEC_ElevatorLowerToNearest,
  LNSPEC_HealThing,
  LNSPEC_DoorCloseWaitOpen,
  LNSPEC_FloorDonut,// 250
  LNSPEC_FloorAndCeilingLowerRaise,
  LNSPEC_CeilingRaiseToNearest,
  LNSPEC_CeilingLowerToLowest,
  LNSPEC_CeilingLowerToFloor,
  LNSPEC_CeilingCrushRaiseAndStaySilentA,

  LNSPEC_Max,

  LNSPEC_SectorSetPortal = 57,
  LNSPEC_LineSetPortal = 156,
};


//==========================================================================
//
//  internal renderer structs; exposed for debugging
//
//==========================================================================

// TODO: document this!
struct texinfo_t {
  native transient TVec saxis;
  native transient float soffs;
  native transient TVec taxis;
  native transient float toffs;
  native transient void/*VTexture*/ *Tex;
  native transient int noDecals;
  // 1.1 for solid surfaces
  // alpha for masked surfaces
  native transient float Alpha;
  native transient int Additive;
  native transient ubyte ColourMap;
};


// TODO: document this!
struct segpart_t {
  segpart_t *next;
  texinfo_t texinfo;
  surface_t *surfs;
  float frontTopDist;
  float frontBotDist;
  float backTopDist;
  float backBotDist;
  float TextureOffset;
  float RowOffset;
};

// TODO: document this!
struct drawseg_t {
  seg_t *seg;
  drawseg_t *next;

  segpart_t *top;
  segpart_t *mid;
  segpart_t *bot;
  segpart_t *topsky;
  segpart_t *extra;

  surface_t *HorizonTop;
  surface_t *HorizonBot;
};

struct sec_surface_t {
  sec_plane_t *secplane;
  texinfo_t texinfo;
  float dist;
  float XScale;
  float YScale;
  float Angle;
  surface_t *surfs;
};

struct surface_t {
  surface_t *next;
  texinfo_t *texinfo;
  TPlane *plane;
  sec_plane_t *HorizonPlane;
  int Light; // light level and colour (unsigned)
  int Fade; // (unsigned)
  subsector_t *subsector; // owning subsector
  seg_t *seg; // owning seg (can be `nullptr` for floor/ceiling)
  // this has more fields in C++, but they aren't exposed
  // so never copy this struct, and never keep it anywhere as value
};


//==========================================================================
//
//  Level
//
//==========================================================================

// LineDef
struct line_t : TPlane {
  // vertices, from v1 to v2
  TVec *v1;
  TVec *v2;

  // precalculated v2-v1 for side checking
  TVec dir;

  int flags;
  int SpacFlags;
  int exFlags;

  // visual appearance: SideDefs
  // sidenum[1] will be -1 if one sided
  int[2] sidenum;

  // neat. another bounding box, for the extent of the LineDef
  float[4] bbox;

  // to aid move clipping
  int slopetype;

  // front and back sector
  // note: redundant? can be retrieved from SideDefs
  sector_t *frontsector;
  sector_t *backsector;

  // if == validcount, already checked (used in various traversing, like LOS, and other line tracing)
  int validcount;

  float alpha;

  int special;
  int arg1;
  int arg2;
  int arg3;
  int arg4;
  int arg5;

  int LineTag;
  int HashFirst;
  int HashNext;

  seg_t *firstseg; // linked by lsnext

  int decalMark;

  // lines connected to `v1`
  line_t*[] v1lines;
  //line_t **v1lines;
  //int v1linesCount;

  // lines connected to `v2`
  line_t*[] v2lines;
  //line_t **v2lines;
  //int v2linesCount;
};


// the SideDef
struct side_t {
  // add this to the calculated texture column
  float TopTextureOffset;
  float BotTextureOffset;
  float MidTextureOffset;

  // add this to the calculated texture top
  float TopRowOffset;
  float BotRowOffset;
  float MidRowOffset;

  // texture indices: we do not maintain names here
  // 0 means "no texture"; -1 means "i forgot what it is"
  int TopTexture;
  int BottomTexture;
  int MidTexture;

  // sector the SideDef is facing
  sector_t *Sector;

  int LineNum; // line index in `Lines`

  int Flags; // SDF_XXX

  int Light;
};


struct sec_plane_t : TPlane {
  float minz;
  float maxz;

  // use for wall texture mapping
  float TexZ;

  int pic;

  float xoffs;
  float yoffs;

  float XScale;
  float YScale;

  float Angle;

  float BaseAngle;
  float BaseYOffs;

  int flags;
  float Alpha;
  float MirrorAlpha;

  int LightSourceSector;

  Entity SkyBox;
};


struct sec_params_t {
  int lightlevel;
  int LightColour;
  int Fade;
  int contents;
};


struct sec_region_t {
  // linked list of regions in bottom to top order
  sec_region_t *prev;
  sec_region_t *next;

  // planes
  sec_plane_t *floor;
  sec_plane_t *ceiling;

  sec_params_t *params;
  line_t *extraline;
};

//
// phares 3/14/98
//
// Sector list node showing all sectors an object appears in.
//
// There are two threads that flow through these nodes. The first thread
// starts at TouchingThingList in a sector_t and flows through the SNext
// links to find all mobjs that are entirely or partially in the sector.
// The second thread starts at TouchingSectorList in a VEntity and flows
// through the TNext links to find all sectors a thing touches. This is
// useful when applying friction or push effects to sectors. These effects
// can be done as thinkers that act upon all objects touching their sectors.
// As an mobj moves through the world, these nodes are created and
// destroyed, with the links changed appropriately.
//
// For the links, nullptr means top or end of list.
//
struct msecnode_t {
  sector_t *Sector; // a sector containing this object
  Entity Thing;  // this object
  msecnode_t *TPrev;  // prev msecnode_t for this thing
  msecnode_t *TNext;  // next msecnode_t for this thing
  msecnode_t *SPrev;  // prev msecnode_t for this sector
  msecnode_t *SNext;  // next msecnode_t for this sector
  int Visited; // killough 4/4/98, 4/7/98: used in search algorithms
};


struct fakefloor_t {
  sec_plane_t floorplane;
  sec_plane_t ceilplane;
  sec_params_t params;
};


//
//  The SECTORS record, at runtime.
//  Stores things/mobjs.
//
struct sector_t {
  sec_plane_t floor;
  sec_plane_t ceiling;
  sec_params_t params;

  sec_region_t *topregion; // highest region
  sec_region_t *botregion; // lowest region

  sector_t *deepref; // deep water hack

  int special;
  int tag;
  int HashFirst;
  int HashNext;

  float skyheight;

  // stone, metal, heavy, etc...
  int seqType;

  // mapblock bounding box for height changes
  int[4] blockbox;

  // origin for any sounds played by the sector
  TVec soundorg;

  // if == validcount, already checked (used in various traversing, like LOS, and other line tracing)
  int validcount;

  // list of subsectors in sector
  // used to check if client can see this sector (it needs to be updated)
  subsector_t *subsectors;

  // list of things in sector
  Entity ThingList;
  msecnode_t *TouchingThingList;

  line_t*[] lines; // [linecount] size
  //line_t **lines; // [linecount] size
  //int linecount;

  // Boom's fake floors
  sector_t *heightsec;
  native transient fakefloor_t *fakefloorinfo; // info for rendering

  // flags
  bool bHasExtrafloors;   // this sector has extrafloors
  bool bExtrafloorSource; // this sector is a source of an extrafloor
  bool bTransferSource;   // source of an heightsec or transfer light
  bool bFakeFloorOnly;    // when used as heightsec in R_FakeFlat, only copies floor
  bool bClipFakePlanes;   // as a heightsec, clip planes to target sector's planes
  bool bNoFakeLight;      // heightsec does not change lighting
  bool bIgnoreHeightSec;  // heightsec is only for triggering sector actions
  bool bUnderWater;       // sector is underwater
  bool bSilent;           // actors don't make noise in this sector
  bool bNoFallingDamage;  // no falling damage in this sector
  bool bFakeCeilingOnly;  // when used as heightsec in R_FakeFlat, only copies ceiling

  // 0 = untraversed, 1,2 = sndlines -1
  int soundtraversed;

  // thing that made a sound (or null)
  Entity SoundTarget;

  // thinker for reversable actions
  Thinker FloorData;
  Thinker CeilingData;
  Thinker LightingData;
  Thinker AffectorData;

  // sector action triggers
  Entity ActionList;

  int Damage;

  float Friction;
  float MoveFactor;
  float Gravity; // Sector gravity (1.0 is normal)

  int Sky;

  int Zone; // reverb zone id

  // this is used to check for "floor holes" that should be filled to emulate original flat floodfill bug
  // if sector has more than one neighbour, this is `nullptr`
  sector_t *othersecFloor;
  sector_t *othersecCeiling;
};


// LineSeg
struct seg_t : TPlane {
  TVec *v1;
  TVec *v2;

  float offset;
  float length;

  side_t *sidedef;
  line_t *linedef;
  seg_t *lsnext; // next seg in linedef

  // sector references
  // could be retrieved from linedef, too
  // backsector is nullptr for one sided lines
  sector_t *frontsector;
  sector_t *backsector;

  seg_t *partner; // from glnodes
  subsector_t *front_sub; // front subsector (we need this for self-referencing deep water)

  // side of line (for light calculations: 0 or 1)
  int side;

  int flags; // SF_xxx

  native transient drawseg_t *drawsegs;
  native transient void/*decal_t*/ *decals;
};

//
//  Polyobj data
//
struct polyobj_t {
  seg_t **segs;
  int numsegs;
  TVec startSpot;
  TVec *originalPts; // used as the base for the rotations
  TVec *prevPts; // use to restore the old point values
  float angle;
  int tag; // reference tag assigned in HereticEd
  int[4] bbox;
  int validcount;
  bool bCrush; // should the polyobj attempt to crush mobjs?
  bool bHurtOnTouch;
  int seqType;
  subsector_t *subsector;
  Thinker SpecialData;  // pointer a thinker, if the poly is moving
};

//
// SubRegion
//

struct subregion_t {
  sec_region_t *secregion;
  subregion_t *next;
  sec_plane_t *floorplane;
  sec_plane_t *ceilplane;
  native transient sec_surface_t *floor;
  native transient sec_surface_t *ceil;
  int count;
  native transient drawseg_t *lines;
};


// a subsector; references a sector
// basically, this is a list of LineSegs, indicating
// the visible walls that define (all or some) sides of a convex BSP leaf
struct subsector_t {
  sector_t *sector;
  native transient subsector_t *seclink;
  int numlines;
  int firstline;
  polyobj_t *poly;

  native transient node_t *parent;
  int VisFrame; // unsigned
  int updateWorldFrame; // unsigned

  sector_t *deepref;

  //k8: i love bounding boxes! (this one doesn't store z, though)
  float[4] bbox;

  int dlightbits;
  int dlightframe;

  native transient subregion_t *regions;
};


//==========================================================================
//
//  Node
//
//==========================================================================

// indicate a leaf
enum {
  NF_SUBSECTOR = 0x80000000,
};

// BSP node
struct node_t : TPlane {
  // bounding box for each child
  //float bbox[2][6];
  float[6] bbox0;
  float[6] bbox1;

  // if NF_SUBSECTOR its a subsector
  int[2] children; // unsigned

  native transient node_t *parent;
  int VisFrame; // unsigned
};


//==========================================================================
//
//  Thing
//
//==========================================================================

// map thing definition with initialised fields for global use
struct mthing_t {
  int tid;
  float x;
  float y;
  float height;
  int angle;
  int type;
  int options;
  int SkillClassFilter;
  int special;
  int arg1;
  int arg2;
  int arg3;
  int arg4;
  int arg5;
};

//
//  Strife conversation scripts
//

struct RogueConChoice {
  int GiveItem; // item given on success
  int NeedItem1; // required item 1
  int NeedItem2; // required item 2
  int NeedItem3; // required item 3
  int NeedAmount1; // amount of item 1
  int NeedAmount2; // amount of item 2
  int NeedAmount3; // amount of item 3
  string Text; // text of the answer
  string TextOK; // message displayed on success
  int Next; // dialog to go on success, negative values to go here immediately
  int Objectives; // mission objectives, LOGxxxx lump
  string TextNo; // message displayed on failure (player doesn't
                 // have needed thing, it haves enough health/ammo,
                 // item is not ready, quest is not completed)
};

struct RogueConSpeech {
  int SpeakerID; // type of the object (MT_xxx)
  int DropItem; // item dropped when killed
  int CheckItem1; // item 1 to check for jump
  int CheckItem2; // item 2 to check for jump
  int CheckItem3; // item 3 to check for jump
  int JumpToConv; // jump to conversation if have certain item(s)
  string Name; // name of the character
  name Voice; // voice to play
  name BackPic; // picture of the speaker
  string Text; // message
  RogueConChoice[5] Choices; // choices
};


//==========================================================================
//
//  Other stuff
//
//==========================================================================
struct opening_t {
  float top;
  float bottom;
  float range;
  float lowfloor;
  float highceiling;
  sec_plane_t *floor;
  sec_plane_t *ceiling;
  sec_plane_t *lowfloorplane;
  sec_plane_t *highceilingplane;
  opening_t *next;
};


struct intercept_t {
  float frac; // along trace line
  bool bIsALine;
  bool bIsABackSide; // not yet
  Entity Thing;
  line_t *line;
};


struct VAnimDoorDef {
  int Texture;
  name OpenSound;
  name CloseSound;
  int[] Frames;
  //int *Frames;
  //int NumFrames;
};


struct VSplashInfo {
  name Name;

  class SmallClass;
  float SmallClip;
  name SmallSound;

  class BaseClass;
  class ChunkClass;
  float ChunkXVelMul;
  float ChunkYVelMul;
  float ChunkZVelMul;
  float ChunkBaseZVel;
  name Sound;
  bool bNoAlert;
};


struct VTerrainInfo {
  name Name;
  name Splash;
  bool bLiquid;
  bool bAllowProtection;
  float FootClip;
  int DamageTimeMask;
  int DamageAmount;
  name DamageType;
  float Friction;
  float MoveFactor;
  float StepVolume;
  float WalkingStepTime;
  float RunningStepTime;
  name LeftStepSounds;
  name RightStepSounds;
};


struct LockGroup {
  array!class AnyKeyList;
};


struct LockDef {
  array!LockGroup Locks;
  string Message;
  string RemoteMessage;
  int MapColour;
  name LockedSound;
};


struct dlight_t {
  TVec origin;
  float radius;
  float die; // stop lighting after this time
  float decay; // drop this each second
  float minlight; // don't add when contributing less
  int type;
  int colour;
  readonly Thinker owner;
  readonly int lightid;
  TVec coneDirection;
  float coneAngle; // 0 means "point light", otherwise it is spotlight
  bool bPlayerLight; // set in alloc, player lights should survive
  bool bNoSelfShadow;
  bool bNoShadow;
};


struct particle_t {
  TVec org;
  int colour;
  float Size;
  particle_t *next;
  TVec vel;
  TVec accel;
  float die;
  int type;
  float ramp;
  float gravity;
  float dur; // for pt_fading
};



// ////////////////////////////////////////////////////////////////////////// //
// decorate uservar manipulation

// this field MUST be serialized
readonly Object _stateRouteSelf; // used to replace state self for uservars if not none

native final int _get_user_var_int (name fldname, optional int index);
native final float _get_user_var_float (name fldname, optional int index);

native final void _set_user_var_int (name fldname, int value, optional int index);
native final void _set_user_var_float (name fldname, float value, optional int index);

enum UserVarFieldType {
  None, // field is missing, or type is invalid
  Int,
  Float,
  IntArray,
  FloatArray,
}

native final UserVarFieldType _get_user_var_type (name fldname);
native final int _get_user_var_dim (name fldname); // array dimension; -1: not an array, or absent


defaultproperties {
}
