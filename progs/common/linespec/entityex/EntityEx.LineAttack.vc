//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
const int FHF_NORANDOMPUFFZ = 1;
const int FHF_NOIMPACTDECAL = 2;


//**************************************************************************
//
//  aiming
//
//**************************************************************************
struct trsplat_t {
  TVec org;
  TVec hit;
  line_t *line;
  sector_t *sec;
  int side;
  bool didhit; // can be true even if `line` is empty (it means floor/ceiling hit)
  Entity mobj; // for other tracers
};


//==========================================================================
//
//  CalcProperThingHit
//
//==========================================================================
static final bool CalcProperThingHit (ref TVec hit_point, Entity th, const TVec shootOrigin, const TVec dir, const float distance) {
  if (hit_point.z > th.Origin.z+th.Height) {
    // trace enters above actor
    if (dir.z >= 0) return false; // going up: can't hit
    // does it hit the top of the actor?
    float dist = (th.Origin.z+th.Height-shootOrigin.z)/dir.z;
    if (dist > distance) return false;
    //float frac = dist/distance;
    hit_point = shootOrigin+dir*dist;
    // calculated coordinate is outside the actor's bounding box
    if (fabs(hit_point.x-th.Origin.x) > th.Radius ||
        fabs(hit_point.y-th.Origin.y) > th.Radius)
    {
      return false;
    }
  } else if (hit_point.z < th.Origin.z) {
    // trace enters below actor
    if (dir.z <= 0) return false; // going down: can't hit
    // does it hit the bottom of the actor?
    float dist = (th.Origin.z-shootOrigin.z)/dir.z;
    if (dist > distance) return false;
    //frac = dist/distance;
    hit_point = shootOrigin+dir*dist;
    // calculated coordinate is outside the actor's bounding box
    if (fabs(hit_point.x-th.Origin.x) > th.Radius ||
        fabs(hit_point.y-th.Origin.y) > th.Radius)
    {
      return false;
    }
  }
  return true;
}


//==========================================================================
//
//  CalculateLineAttackZOfs
//
//  calculate z offset for line attack (will be added to origin)
//
//==========================================================================
float CalculateLineAttackZOfs () {
  // to make the shot go through the crosshair, we should return `ViewHeight`
  float res = Height*0.5-FloorClip;
  if (bIsPlayer) {
    if (!GetCvarB('gm_fix_attack_offset')) return res+PlayerEx(Player).GetAttackZOfs;
    return PlayerEx(Player).ViewHeight;
  } else {
    return res+8.0;
  }
}


//==========================================================================
//
//  CalculateMissileAttackZOfs
//
//  calculate z offset for missile attack (will be added to origin)
//
//==========================================================================
float CalculateMissileAttackZOfs (class!EntityEx type) {
  // missiles are spawned 4 units lower than hitscan attacks
  // add an extra unit to simulate Doom's original behaviour
  if (bIsPlayer) {
    auto pex = PlayerEx(Player);
    if (!pex) return Height*0.5-FloorClip+8.0-3.0; // just in case
    if (GetCvarB('gm_fix_projectile_attack_offset_broken')) {
      // 4 is for autoaim
      //return Height*0.5-FloorClip+(type ? type.default.Height*0.5f : pex.GetAttackZOfs-3.0);
      return Height*0.5-FloorClip+(type ? type.default.Height*0.5f : pex.GetAttackZOfs-3.0);
    } else {
      return Height*0.5-FloorClip+pex.GetAttackZOfs-3.0;
    }
  } else {
    return Height*0.5-FloorClip+8.0-3.0;
  }
}


//==========================================================================
//
//  PickActor
//
//==========================================================================
override Entity PickActor (optional TVec org, TVec dir, float distance, optional int actorMask, optional int wallMask) {
  intercept_t *in;
  TVec lineEnd;

  if (!specified_actorMask) actorMask = MF_SHOOTABLE;
  if (!specified_wallMask) wallMask = ML_BLOCKEVERYTHING|ML_BLOCKHITSCAN;

  if (actorMask == 0) return none; // cannot realisticaly hit anything at all

  if (!specified_org) {
    org = Origin;
    org.z += CalculateLineAttackZOfs();
  }

  TVec shootOrigin = org;
  TVec dst = shootOrigin+distance*dir;
  TVec lineStart = shootOrigin;

  foreach PathTraverse(in, org.x, org.y, dst.x, dst.y, PT_ADDLINES|PT_ADDTHINGS/*|PT_EARLYOUT*/) {
    TVec hit_point;
    line_t *li;
    EntityEx th;

    //printdebug("LineAttack: isline=%d; frac=%f", (in->bIsALine ? 1 : 0), in->frac);
    //if (!in->bIsALine) printdebug("LineAttack: frac=%f; thing=%C; dist=%f", in->frac, in->Thing, length2D(in.Thing.Origin-org));

    if (in->bIsALine) {
      sector_t *sec;

      li = in->line;
      hit_point = shootOrigin+(distance*in->frac)*dir;
      if ((li->flags&ML_TWOSIDED) && PointOnPlaneSide(shootOrigin, *li)) {
        sec = li->backsector;
      } else {
        sec = li->frontsector;
      }

      lineEnd = hit_point;

      // check for shooting floor or ceiling
      if (!ShootCheckPlanes(sec, li, lineStart, lineEnd, distance, PuffType:none, outHitPoint:nullptr)) return none;

      lineStart = lineEnd;

      if (Level.CompatTrace && li->frontsector == li->backsector) continue;

      if (li->flags&ML_TWOSIDED) {
        // crosses a two sided line
        opening_t *open;
        float opentop = 0.0;

        open = LineOpenings(li, hit_point, SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT);
        if (open) opentop = open->top;
        while (open) {
          if (open->bottom <= hit_point.z && open->top >= hit_point.z) {
            //if (!(li->flags&(ML_BLOCKEVERYTHING|ML_BLOCKHITSCAN))) break; // shot continues
            if (!(li->flags&wallMask)) {
              // shot continues
              //printdebug("PickActor: line skipped; flags=0x%08x; mask=0x%08x", li->flags, wallMask);
              break;
            }
          }
          open = open->next;
        }
        if (open) continue;
        if (li->frontsector->ceiling.pic == Level.Game.skyflatnum &&
            li->backsector->ceiling.pic == Level.Game.skyflatnum &&
            hit_point.z > opentop)
        {
          // it's a sky hack wall
          //if (outHitPoint) *outHitPoint = hit_point;
          return none;
        }
      } else {
        // always stop on one-sided lines
        //if (outHitPoint) *outHitPoint = hit_point;
        return none;
      }

      // line hit, no thing found
      return none;
    }

    // hit a thing
    th = EntityEx(in->Thing);

    if (th == self) continue; // can't pick self

    // ignore ghosts
    if (th.bGhost) continue;

    int thflags = th.CalcEntityFlags();
    if (!(thflags&actorMask)) continue; // mask check failed

    // check angles to see if the thing can be aimed at
    hit_point = shootOrigin+(distance*in->frac)*dir;

    if (!CalcProperThingHit(ref hit_point, th, shootOrigin, dir, distance)) continue;
    //printdebug("  thing: %C (over:%B; under:%B; tz=(%f,%f); hpz=%f)", th, (th.Origin.z+th.Height < hit_point.z), (th.Origin.z > hit_point.z), th.Origin.z, th.Origin.z+th.Height, hit_point.z);

    if (th.Origin.z+th.Height < hit_point.z) continue; // shot over the thing
    if (th.Origin.z > hit_point.z) continue; // shot under the thing

    if (in->bExtraThingCheck && !XLevel.BSPTraceLine(shootOrigin, hit_point, nullptr, nullptr, SPF_NOBLOCKING)) {
      //printdebug("%C: cannot be hit!", th);
      continue;
    }

    // hit thing
    // position a bit closer
    //hit_point -= 10.0*dir;
    hit_point -= 2.0*dir;

    //if (outHitPoint) *outHitPoint = hit_point;

    //printdebug("PickActor: th=%C (thflags=0x%08x; mask=0x%08x)", th, thflags, actorMask);
    // don't go any farther
    return th;
  }

  return none;
}


//==========================================================================
//
//  DebugCheckMidTex
//
//==========================================================================
final void DebugCheckMidTex () {
  TVec aimDir;
  //Aim(aimDir, 16.0*64.0, default, /*noAAim*/true);
  AngleVector(Angles, out aimDir);

  auto shootOrigin = Origin;
  shootOrigin.z += CalculateLineAttackZOfs();

  trsplat_t tr;
  TraceLineEx(shootOrigin, aimDir, 8192, allowEntities:false, &tr, stopat3dmidtex:true, nozofs:true);
  if (tr.didhit && tr.line) {
    float top, bot;
    bool ok = P_GetMidTexturePosition(tr.line, tr.side, out top, out bot);
    printdebug("DebugCheckMidTex(%B): hitpoint=%s; top=%s; bot=%s; flags=0x%08x", ok, tr.hit, top, bot, (tr.line ? tr.line->flags : 0));
    if (tr.line) {
      //tr.line.alpha = 1.0;
      if (tr.line.frontsector && tr.line.backsector /*&&
          tr.line.frontsector.floor.normal.z == 1 && tr.line.frontsector.ceiling.normal.z == -1 &&
          tr.line.backsector.floor.normal.z == 1 && tr.line.backsector.ceiling.normal.z == -1*/)
      {
        //printdebug("linedef #%d", tr.line-&XLevel.Lines[0]);
        float ffz1 = tr.line.frontsector.floor.GetPointZClamped(*tr.line.v1);
        float ffz2 = tr.line.frontsector.floor.GetPointZClamped(*tr.line.v2);
        //if (ffz1 != ffz2) Error("OOPS(front floor)");
        float fcz1 = tr.line.frontsector.ceiling.GetPointZClamped(*tr.line.v1);
        float fcz2 = tr.line.frontsector.ceiling.GetPointZClamped(*tr.line.v2);
        //if (fcz1 != fcz2) Error("OOPS(front ceiling)");
        float bfz1 = tr.line.backsector.floor.GetPointZClamped(*tr.line.v1);
        float bfz2 = tr.line.backsector.floor.GetPointZClamped(*tr.line.v2);
        //if (bfz1 != bfz2) Error("OOPS(back floor)");
        float bcz1 = tr.line.backsector.ceiling.GetPointZClamped(*tr.line.v1);
        float bcz2 = tr.line.backsector.ceiling.GetPointZClamped(*tr.line.v2);
        //if (bcz1 != bcz2) Error("OOPS(back ceiling)");
        printdebug("linedef %d: (f/b secs=%d/%d); ffz=(%f:%f); fcz=(%f:%f); bfz=(%f:%f); bcz=(%f:%f); alpha=%f; special=%s<%s>; arg=(%s,%s,%s,%s,%s)",
            tr.line-&XLevel.Lines[0],
            tr.line.frontsector-&XLevel.Sectors[0], tr.line.backsector-&XLevel.Sectors[0],
            ffz1, ffz2, fcz1, fcz2, bfz1, bfz2, bcz1, bcz2,
            tr.line.alpha,
            tr.line.special, LineSpecial2Str(tr.line.special),
            tr.line.arg1, tr.line.arg2, tr.line.arg3, tr.line.arg4, tr.line.arg5);
        printdebug("fsec(%d): ceiling=%f; floor=%f", tr.line.frontsector-&XLevel.Sectors[0], tr.line.frontsector.ceiling.minz, tr.line.frontsector.floor.maxz);
        printdebug("bsec(%d): ceiling=%f; floor=%f", tr.line.backsector-&XLevel.Sectors[0], tr.line.backsector.ceiling.minz, tr.line.backsector.floor.maxz);
      } else {
        float ffz1 = tr.line.frontsector.floor.GetPointZClamped(*tr.line.v1);
        float ffz2 = tr.line.frontsector.floor.GetPointZClamped(*tr.line.v2);
        //if (ffz1 != ffz2) Error("OOPS(front floor)");
        float fcz1 = tr.line.frontsector.ceiling.GetPointZClamped(*tr.line.v1);
        float fcz2 = tr.line.frontsector.ceiling.GetPointZClamped(*tr.line.v2);
        //if (fcz1 != fcz2) Error("OOPS(front ceiling)");
        printdebug("linedef %d: (f sec=%d); ffz=(%f:%f); fcz=(%f:%f); special=%s<%s>; arg=(%s,%s,%s,%s,%s)",
            tr.line-&XLevel.Lines[0],
            tr.line.frontsector-&XLevel.Sectors[0],
            ffz1, ffz2, fcz1, fcz2,
            tr.line.special, LineSpecial2Str(tr.line.special),
            tr.line.arg1, tr.line.arg2, tr.line.arg3, tr.line.arg4, tr.line.arg5);
      }
      foreach (auto snum; 0..2) {
        if (tr.line.sidenum[snum] < 0) continue;
        side_t *sd = &XLevel.Sides[tr.line.sidenum[snum]];
        printdebug("side %s: toptex(%d)=%s; midtex(%d)=%s; bottex(%d)=%s", snum,
          sd.TopTexture, GetTextureName(sd.TopTexture),
          sd.MidTexture, GetTextureName(sd.MidTexture),
          sd.BottomTexture, GetTextureName(sd.BottomTexture));
      }
    }

    auto real_hit_point = tr.hit;
    auto hit_point = real_hit_point-(4.0*aimDir);
    // spawn bullet puff
    SpawnPuff(hit_point, /*distance*/8192, BulletPuff, false, tr.sec, tr.line, real_hit_point);
  }

  /+
  LineAttack(aimDir, /*Range*/10000, /*damage*/10000,
    BulletPuff, default, default,
    default, false);
  +/
}


//==========================================================================
//
//  TraceLineEx
//
//  Trace line to the wall or entity.
//  Returns `true` if wall was hit.
//  Returns `false` if floor/ceiling was hit, or nothing was hit.
//
//==========================================================================
final bool TraceLineEx (TVec org, TVec dir, float distance, bool allowEntities, optional trsplat_t *tr, optional bool stopat3dmidtex, optional bool nozofs) {
  TVec dst;
  intercept_t *in;
  TVec lineStart;
  TVec lineEnd;
  TVec shootOrigin;
  TVec outHitPoint;

  shootOrigin = org;
  if (!nozofs) shootOrigin.z += (bIsPlayer ? PlayerEx(Player).GetAttackZOfs : 8.0);

  dst = shootOrigin+distance*dir;

  if (tr) {
    tr->org = org;
    tr->hit = dst;
    tr->line = nullptr;
    tr->sec = nullptr;
    tr->didhit = false;
    tr->mobj = none;
  }

  lineStart = shootOrigin;
  foreach PathTraverse(in, org.x, org.y, dst.x, dst.y, PT_ADDLINES|(allowEntities ? PT_ADDTHINGS : 0)/*|PT_EARLYOUT*/) {
    TVec hit_point;
    line_t *li;

    if (in->bIsALine) {
      int side;
      sector_t *sec;

      li = in->line;
      hit_point = shootOrigin+(distance*in->frac)*dir;
      if ((li->flags&ML_TWOSIDED) && PointOnPlaneSide(shootOrigin, *li)) {
        side = 1;
        sec = li->backsector;
      } else {
        side = 0;
        sec = li->frontsector;
      }

      lineEnd = hit_point;

      // check for shooting floor or ceiling
      if (!ShootCheckPlanes(sec, li, lineStart, lineEnd, distance, PuffType:none, &outHitPoint)) {
        // process floor and ceiling here
        if (tr) { tr->hit = outHitPoint; tr->didhit = true; }
        return false;
      }

      lineStart = lineEnd;

      if (Level.CompatTrace && li->frontsector == li->backsector) continue;

      /*if (stopat3dmidtex && (li->flags&ML_3DMIDTEX)) {
        // stop right here
        printdebug("!!!!");
      } else*/ {
        if (li->flags&ML_TWOSIDED) {
          // crosses a two sided line
          float opentop = 0.0;

          opening_t *open = LineOpenings(li, hit_point, SPF_NOBLOCKING, stopat3dmidtex);
          if (open) {
            printdebug("SKYFLAT: %d (%s)", Level.Game.skyflatnum, GetTextureName(Level.Game.skyflatnum));
            printdebug(":: line #%d (flags=0x%08x) ::", li-&XLevel.Lines[0], li->flags);
            foreach (auto snum; 0..2) {
              if (li.sidenum[snum] < 0) continue;
              side_t *sd = &XLevel.Sides[li.sidenum[snum]];
              printdebug("side %s: toptex(%d)=%s; midtex(%d)=%s; bottex(%d)=%s", snum,
                sd.TopTexture, GetTextureName(sd.TopTexture),
                sd.MidTexture, GetTextureName(sd.MidTexture),
                sd.BottomTexture, GetTextureName(sd.BottomTexture));
            }
            for (opening_t *o = open; o; o = o->next) {
              printdebug(" opening:");
              printdebug("  open bot: %s", o->bottom);
              printdebug("  open top: %s", o->top);
              printdebug("  open range: %s", o->range);
              printdebug("  open lowfloor: %s", o->lowfloor);
              printdebug("  open floor: (%s:%s)", o->efloor.spGetNormal(), o->efloor.spGetDist());
              printdebug("  open ceiling: (%s:%s)", o->eceiling.spGetNormal(), o->eceiling.spGetDist());
            }
          }
          if (stopat3dmidtex && (li->flags&ML_3DMIDTEX)) {
            // stop right here
            printdebug("!!!!");
            open = nullptr;
          }

          if (open) opentop = open->top;
          while (open) {
            //!opentop = fmax(opentop, open->top);
            if (open->bottom <= hit_point.z && open->top >= hit_point.z) {
              if (!(li->flags&ML_BLOCKEVERYTHING)) break; // shot continues
            }
            open = open->next;
          }
          if (open) continue;
          printdebug("opening: no opening!");

          if (li->frontsector->ceiling.pic == Level.Game.skyflatnum &&
              li->backsector->ceiling.pic == Level.Game.skyflatnum &&
              hit_point.z > opentop)
          {
            // it's a sky hack wall
            printdebug("opening: skyhack!");
            if (tr) { tr->hit = hit_point; tr->didhit = true; }
            return false;
          }
        }
      }

      outHitPoint = hit_point;

      if (li->special == LNSPEC_LineHorizon) {
        if (tr) tr->hit = hit_point;
        return false; // don't spawn decals on sky
      }

      // Hit line
      if (tr) {
        tr->hit = hit_point;
        tr->line = li;
        tr->sec = sec;
        tr->side = side;
        tr->didhit = true;
      }

      // don't go any farther
      return true;
    } else if (in->Thing && !in->Thing.IsA('DoomPlayer')) {
      // thing
      hit_point = shootOrigin+(distance*in->frac)*dir;
      if (!CalcProperThingHit(ref hit_point, in->Thing, shootOrigin, dir, distance)) continue;
      if (hit_point.z >= in->Thing.Origin.z && hit_point.z < in->Thing.Origin.z+in->Thing.Height) {
        tr->hit = hit_point;
        tr->mobj = in->Thing;
        return false;
      }
    }
  }

  lineEnd = dst;
  if (!ShootCheckPlanes(XLevel.PointInSector(dst), line:default, lineStart, lineEnd, distance, PuffType:none, &outHitPoint)) {
    // process floor and ceiling here
    if (tr) { tr->hit = outHitPoint; tr->didhit = true; }
  }

  return false;
}


//==========================================================================
//
//  AimLineAttack
//
//  Sets linetaget and aim_slope when a target is aimed at.
//
//==========================================================================
final EntityEx AimLineAttack (out TVec OutDir, TAVec aangles, float distance,
                              optional bool noVertAutoAim, optional class!EntityEx rocketType)
{
  float x2, y2;
  float topangle, botangle;
  TVec dir;
  intercept_t *in;
  EntityEx linetarget; // who got hit (or nullptr)

  // height if not aiming up or down
  // ???: use slope for monsters?
  float aim_z;
  float aim_range;
  float aim_slope;
  TVec aim_dir;
  float aim_topslope;
  float aim_bottomslope; // slopes to top and bottom of target
  float aim_range2d;

  AngleVector(aangles, out aim_dir);
  x2 = Origin.x+distance*aim_dir.x;
  y2 = Origin.y+distance*aim_dir.y;
  aim_z = Origin.z+(rocketType ? CalculateMissileAttackZOfs(rocketType) : CalculateLineAttackZOfs());
  aim_range2d = Length2D(vector(distance*aim_dir.x, distance*aim_dir.y));

  // can't shoot outside view angles
  topangle = AngleMod180(-aangles.pitch+30.0);
  botangle = AngleMod180(-aangles.pitch-30.0);
  if (topangle > 89.0) topangle = 89.0;
  if (botangle < -89.0) botangle = -89.0;
  aim_topslope = tan(topangle);
  aim_bottomslope = tan(botangle);

  aim_range = distance;
  linetarget = none;

  TVec shootOrigin = vector(Origin.x, Origin.z, aim_z);

  foreach PathTraverse(in, Origin.x, Origin.y, x2, y2, PT_ADDLINES|PT_ADDTHINGS/*|PT_EARLYOUT*/) {
    line_t *li;
    EntityEx th;
    float thingtopslope;
    float thingbottomslope;
    float dist;
    float slope;
    opening_t *open;

    if (in->bIsALine) {
      TVec hit_point;

      li = in->line;

      if (!(li->flags&ML_TWOSIDED) || (li->flags&(ML_BLOCKEVERYTHING|ML_BLOCKHITSCAN))) break; // stop

      // crosses a two sided line
      // a two sided line will restrict the possible target ranges
      dist = aim_range*in->frac;
      if (dist < 0.01) continue; // shooter is on the line

      hit_point = Origin+dist*aim_dir;
      //open = LineOpenings(li, hit_point);
      //open = FindOpening(open, hit_point.z, hit_point.z);
      open = FindLineOpening(li, hit_point, 0, SPF_NOBLOCKING|SPF_NOBLOCKSHOOT);

      if (!open || open->bottom >= open->top) break; // stop

      dist = aim_range2d*in->frac;

      slope = (open->bottom-aim_z)/dist;
      if (slope > aim_bottomslope) aim_bottomslope = slope;

      slope = (open->top-aim_z)/dist;
      if (slope < aim_topslope) aim_topslope = slope;

      if (aim_topslope <= aim_bottomslope) break; // stop

      continue; // shot continues
    }

    // shoot a thing
    th = EntityEx(in->Thing);
    if (th == self) continue; // can't shoot self

    if (!th.bShootable) continue; // corpse or something

    if (th.bCantAutoAim) continue; // can't auto-aim at pods

    if (IsTeammate(th)) continue; // don't aim at fellow co-op players

    // check angles to see if the thing can be aimed at
    dist = aim_range2d*in->frac;
    if (dist < 0.01) continue; // too close, must be above or below
    thingtopslope = (th.Origin.z+th.Height-aim_z)/dist;

    if (thingtopslope < aim_bottomslope) continue; // shot over the thing

    thingbottomslope = (th.Origin.z-aim_z)/dist;

    if (thingbottomslope > aim_topslope) continue; // shot under the thing

    // this thing can be hit! (maybe)
    if (in->bExtraThingCheck) {
      // check angles to see if the thing can be aimed at
      TVec hit_point = shootOrigin+(distance*in->frac)*aim_dir;
      if (!XLevel.BSPTraceLine(shootOrigin, hit_point, nullptr, nullptr, SPF_NOBLOCKING)) {
        //printdebug("%C: cannot be hit!", th);
        continue;
      }
    }

    if (thingtopslope > aim_topslope) thingtopslope = aim_topslope;

    if (thingbottomslope < aim_bottomslope) thingbottomslope = aim_bottomslope;

    aim_slope = (thingtopslope+thingbottomslope)/2.0;
    linetarget = th;

    break; // don't go any farther
  }

  if (linetarget && !noVertAutoAim) aangles.pitch = -atan(aim_slope);
  AngleVector(aangles, out dir);
  OutDir = dir;
  return linetarget;
}


//===========================================================================
//
//  Aim
//
//  Sets a slope so a near miss is at aproximately the height of the
//  intended target
//
//  note that it is impossible to disable autoaim for monsters
//
//===========================================================================
final EntityEx Aim (out TVec OutDir, float distance, optional float yaw,
                    optional bool noAutoaim, optional bool noVertAutoAim,
                    optional class!EntityEx rocketType)
{
  TAVec ang;
  TVec dir;
  EntityEx LineTarget;
  bool aaim;

  if (bIsPlayer) {
    aaim = PlayerEx(Player).bAutoAim;
    if (aaim && specified_noAutoaim) {
      //printdebug("AIM<%C>: noaa=%s", self, (noAutoaim ? "tan" : "ona"));
      if (noAutoaim) aaim = false;
    }
  } else {
    aaim = true; // monsters should always autoaim
  }

  // see which target is to be aimed at
  ang = Angles;
  if (specified_yaw) ang.yaw = yaw;
  if (!aaim) {
    //ang.pitch = AngleMod360(ang.pitch-4);
    AngleVector(ang, out dir);
    OutDir = dir;
  }

  // try to aim at a target
  // this is done even when autoaim is off so that we get a LineTarget that is needed for seeker missiles
  LineTarget = AimLineAttack(out dir, ang, distance, rocketType:rocketType!optional);
  if (!LineTarget) {
    auto origYaw = ang.yaw;
    ang.yaw = AngleMod360(ang.yaw+45.0/8.0);
    LineTarget = AimLineAttack(out dir, ang, distance, noVertAutoAim!optional, rocketType:rocketType!optional);
    if (!LineTarget) {
      ang.yaw = AngleMod360(ang.yaw-45.0/4.0);
      LineTarget = AimLineAttack(out dir, ang, distance, noVertAutoAim!optional, rocketType:rocketType!optional);
      if (!LineTarget) {
        //ang.yaw = AngleMod360(ang.yaw+45.0/8.0);
        ang.yaw = origYaw;
        AngleVector(ang, out dir);
      }
    }
  }

  if (aaim) OutDir = dir;

  return LineTarget;
}


//==========================================================================
//
//  AimEx
//
//==========================================================================
final EntityEx AimEx (out TVec OutDir, float Range, float AngleInc, int NumSteps,
                      optional float FinalRange, optional class!EntityEx rocketType) {
  TAVec aimangles;
  //TVec vforward;
  EntityEx LineTarget;

  foreach (auto i; 0..NumSteps) {
    // try to the left
    aimangles = Angles;
    aimangles.yaw = AngleMod360(aimangles.yaw+float(i)*AngleInc);
    LineTarget = AimLineAttack(out OutDir, aimangles, Range, rocketType:rocketType!optional);
    if (LineTarget) return LineTarget;

    // try to the right
    aimangles = Angles;
    aimangles.yaw = AngleMod360(aimangles.yaw-float(i)*AngleInc);
    LineTarget = AimLineAttack(out OutDir, aimangles, Range, rocketType:rocketType!optional);
    if (LineTarget) return LineTarget;
  }

  if (FinalRange) {
    // didn't find any creatures, so try to strike any walls
    aimangles = Angles;
    LineTarget = AimLineAttack(out OutDir, aimangles, FinalRange, rocketType:rocketType!optional);
  } else {
    //AngleVector(Angles, out vforward);
    //OutDir = vforward;
    AngleVector(Angles, out OutDir);
  }

  return LineTarget;
}


//**************************************************************************
//
//  SHOOTING
//
//**************************************************************************


//==========================================================================
//
//  ShootCheckPlanes
//
//==========================================================================
final bool ShootCheckPlanes (sector_t *sec, optional line_t *line,
                             TVec linestart, TVec lineend, float range,
                             class!EntityEx PuffType, TVec *outHitPoint,
                             optional out EntityEx puffEntity)
{
  TVec hitpoint, hitnormal;
  bool hitsky;
  if (!CheckPassPlanes(sec, linestart, lineend, SPF_NOBLOCKSHOOT/*|SPF_IGNORE_BASE_REGION*/, out hitpoint, out hitnormal, out hitsky)) {
    if (outHitPoint) *outHitPoint = hitpoint;
    // if we are shooting floor or ceiling we are adjusting position
    // to spawn puff on floor or ceiling, not on wall
    if (!hitsky && PuffType) {
      // position a bit closer
      //hitpoint += 1.5*hitnormal;
      // spawn bullet puffs
      //SpawnPuff(lineend, range, PuffType, false, sec, li); //k8: we can't do decals on non-walls yet
      //printdebug("%C: spawning puff '%C' from planes", self, PuffType);
      puffEntity = SpawnPuff(hitpoint, range, PuffType, false);
    }
    return false;
  }
  if (outHitPoint) *outHitPoint = lineend;
  return true;
}


//==========================================================================
//
//  eventLineAttackACS
//
//==========================================================================
override void eventLineAttackACS (TVec dir, float distance, int LADamage, name aPuffType, name adamagetype, int flags, int pufftid) {
  /*k8: old code
  class!EntityEx PuffType = none;
  if (adamagetype) PuffType = class!EntityEx(FindClassNoCase(adamagetype));
  */
  class!EntityEx PuffType = (aPuffType ? class!EntityEx(FindClassNoCase(aPuffType)) : none);
  //printdebug("%C: eventLineAttackACS: dir=%s; dist=%s; LADamage=%s; aPuffType=%s(%C); adamagetype=%s; flags=%s; pufftid=%s", self, dir, distance, LADamage, aPuffType, PuffType, adamagetype, flags, pufftid);
  if (flags&FHF_NOIMPACTDECAL) {
    LineAttack(dir, distance, LADamage, PuffType, NoAttackGhosts:true, DmgType:adamagetype, decalType:'', pufftid:pufftid, !!(flags&FHF_NORANDOMPUFFZ));
  } else {
    LineAttack(dir, distance, LADamage, PuffType, NoAttackGhosts:true, DmgType:adamagetype, pufftid:pufftid, !!(flags&FHF_NORANDOMPUFFZ));
  }
}


//==========================================================================
//
//  LineAttack
//
//  to prevent decal spawning, pass 'none' as `decalType`
//  (or something else that is non-existing)
//  decalType of '' means "use default puff decal"
//
//  returns `true` if DIDN'T hit anything
//
//==========================================================================
final bool LineAttack (TVec dir, float distance, int LADamage,
                       class!EntityEx PuffType, optional bool NoAttackGhosts,
                       optional TVec *outHitPoint, optional name DmgType,
                       optional bool secondary, optional name decalType,
                       optional int pufftid, optional bool disableRandomZ,
                       optional out EntityEx hitEntity, optional out EntityEx puffEntity)
{
  TVec dst;
  intercept_t *in;
  TVec lineStart;
  TVec lineEnd;
  TVec shootOrigin;

  //printdebug("LineAttack: self=<%C>", self);

  //Entity e; printdebug("%f", e.Height);
  puffEntity = none;
  hitEntity = none;
  if (!Level.Game.IsAuthority) return false;

  shootOrigin = Origin;
  shootOrigin.z += CalculateLineAttackZOfs();

  dst = shootOrigin+distance*dir;
  lineStart = shootOrigin;

  TVec hit_point, real_hit_point;
  line_t *li;
  EntityEx th;

  //printdebug("=== LineAttack ===");
  foreach PathTraverse(in, Origin.x, Origin.y, dst.x, dst.y, PT_ADDLINES|PT_ADDTHINGS/*|PT_EARLYOUT*/) {
    //printdebug("LineAttack: isline=%B; frac=%s; lstart=%s", in->bIsALine, in->frac, lineStart);
    //if (!in->bIsALine) printdebug("LineAttack:   thing: frac=%s; thing=%C; dist=%s", in->frac, in->Thing, length2D(in.Thing.Origin-Origin));

    if (in->bIsALine) {
      sector_t *sec;

      li = in->line;
      hit_point = shootOrigin+(distance*in->frac)*dir;
      if ((li->flags&ML_TWOSIDED) && PointOnPlaneSide(shootOrigin, *li)) {
        sec = li->backsector;
      } else {
        sec = li->frontsector;
      }

      //printdebug("LineAttack:   line hit_point=%s", hit_point);

      lineEnd = hit_point;

      // check for shooting floor or ceiling
      if (!ShootCheckPlanes(sec, li, lineStart, lineEnd, distance, PuffType, outHitPoint, puffEntity:puffEntity)) {
        //printdebug("%C: hit floor/ceiling (puff=%C)", self, PuffType);
        return false;
      }

      lineStart = lineEnd;

      if (Level.CompatTrace && li->frontsector == li->backsector) continue;

      // execute line special after checking for hitting floor or ceiling when we know that it actally hits line
      if (li->special && !bNoTrigger) LineSpecialLevelInfo(Level).ActivateLine(li, self, 0, SPAC_Impact);

      if (li->flags&ML_TWOSIDED) {
        // crosses a two sided line
        opening_t *open;
        float opentop = 0.0;

        open = LineOpenings(li, hit_point, SPF_NOBLOCKING|SPF_NOBLOCKSHOOT);
        if (open) opentop = open->top;
        while (open) {
          if (open->bottom <= hit_point.z && open->top >= hit_point.z) {
            if (!(li->flags&(ML_BLOCKEVERYTHING|ML_BLOCKHITSCAN))) break; // shot continues
          }
          open = open->next;
        }
        if (open) continue;
        if (li->frontsector->ceiling.pic == Level.Game.skyflatnum &&
            li->backsector->ceiling.pic == Level.Game.skyflatnum &&
            hit_point.z > opentop)
        {
          // it's a sky hack wall
          if (outHitPoint) *outHitPoint = hit_point;
          return false;
        }
      }

      if (outHitPoint) *outHitPoint = hit_point;

      if (li->special == LNSPEC_LineHorizon) return false; // don't spawn puffs on sky

      // hit line

      // position a bit closer
      real_hit_point = hit_point;
      hit_point -= 4.0*dir;

      // spawn bullet puffs
      if (PuffType) {
        puffEntity = SpawnPuff(hit_point, distance, PuffType, false, sec, li, real_hit_point, decalType!optional, pufftid!optional, disableRandomZ!optional);
      }

      // don't go any farther
      return false;
    }

    // shoot a thing
    th = EntityEx(in->Thing);

    //printdebug("  thing: %n (isself:%d)", GetClassName(th.Class), (th == self ? 1 : 0));

    if (th == self) continue; // can't shoot self

    if (!th.bShootable) continue; // corpse or something

    // check angles to see if the thing can be aimed at
    hit_point = shootOrigin+(distance*in->frac)*dir;
    //printdebug("LineAttack:   thing hit_point=%s; lineEnd=%s", hit_point, lineEnd);

    if (!CalcProperThingHit(ref hit_point, th, shootOrigin, dir, distance)) continue;
    //printdebug("  thing: %C (over:%B; under:%B; tz=(%f,%f); hpz=%f)", th, (th.Origin.z+th.Height < hit_point.z), (th.Origin.z > hit_point.z), th.Origin.z, th.Origin.z+th.Height, hit_point.z);

    if (th.Origin.z+th.Height < hit_point.z) continue; // shot over the thing
    if (th.Origin.z > hit_point.z) continue; // shot under the thing

    // check for physical attacks on a ghost
    if (th.bGhost && NoAttackGhosts) continue;

    if (in->bExtraThingCheck && !XLevel.BSPTraceLine(shootOrigin, hit_point, nullptr, nullptr, SPF_NOBLOCKING)) {
      //printdebug("%C: cannot be hit!", th);
      continue;
    }

    // hit a thing
    // position a bit closer
    //hit_point -= 10.0*dir;
    hit_point -= 2.0*dir;
    if (outHitPoint) *outHitPoint = hit_point;

    bool UseAxeBlood = bIsPlayer && PlayerEx(Player).ReadyWeapon && PlayerEx(Player).ReadyWeapon.bAxeBlood;
    bool UseBloodSplatter = UseAxeBlood || bBloodSplatter ||
                            (bIsPlayer && PlayerEx(Player).ReadyWeapon && PlayerEx(Player).ReadyWeapon.bBloodSplatter);

    // spawn bullet puffs or blood spots, depending on target type
    if ((PuffType && PuffType.default.bPuffOnActors) || th.bNoBlood || th.bInvulnerable || th.bDormant) {
      puffEntity = SpawnPuff(hit_point, distance, PuffType, true, pufftid:pufftid!optional, disableRandomZ:disableRandomZ!optional);
    }

    if (!PuffType || !PuffType.default.bBloodlessImpact) {
      if (!UseBloodSplatter && !th.bNoBlood && !th.bInvulnerable && !th.bDormant) {
        th.SpawnBlood(hit_point, LADamage, shootOrigin);
      }
      if (LADamage && UseBloodSplatter) {
        if (!th.bNoBlood && !th.bInvulnerable && !th.bDormant) {
          if (UseAxeBlood) th.SpawnBloodSplatter2(hit_point, shootOrigin);
          if (P_Random() < 192) th.SpawnBloodSplatter(hit_point, LADamage, shootOrigin);
        }
      }
    }

    if (LADamage) {
      bool NoArmor = false;
      // allow bPierceArmor on weapons as well
      if (bIsPlayer && PlayerEx(Player).ReadyWeapon && PlayerEx(Player).ReadyWeapon.bPierceArmor) NoArmor = true;
      if (bIsPlayer) {
        TVec thp = hit_point-th.Origin;
        th.DamageEx(self, self, LADamage, DmgType, NoArmor, thp, secondary);
      } else {
        th.Damage(self, self, LADamage, DmgType, NoArmor);
      }
    }

    // don't go any farther
    hitEntity = th;
    return false;
  }

  lineEnd = dst;
  if (!ShootCheckPlanes(XLevel.PointInSector(dst), default, lineStart, lineEnd, distance, PuffType, outHitPoint, puffEntity:puffEntity)) {
    return false;
  }

  if (PuffType) {
    if (PuffType.default.ActiveSound) PlaySound(PuffType.default.ActiveSound, /*CHAN_WEAPON*/CHAN_AUTO); // play miss sound
    if (PuffType.default.bAlwaysPuff) puffEntity = SpawnPuff(lineEnd, distance, PuffType, false, pufftid:pufftid!optional, disableRandomZ:disableRandomZ!optional);
  }

  return true;
}


//**************************************************************************
//
//  RAILGUN
//
//**************************************************************************


//==========================================================================
//
//  RailCheckPlanes
//
//==========================================================================
final bool RailCheckPlanes (sector_t *sec, TVec linestart, out TVec lineend,
                            float range, class!EntityEx PuffType)
{
  return ShootCheckPlanes(sec, line:default, linestart, lineend, range, PuffType, nullptr);
}


//==========================================================================
//
//  RailAttack
//
//==========================================================================

final void RailAttack (TVec dir, float Offset, int RailDamage,
                       optional int Col1, optional int Col2, optional float MaxDiff,
                       optional class!EntityEx PuffType, optional bool Silent,
                       optional bool DontPierce, optional float distance,
                       optional float spawnofs_z, optional int pierceLimit)
{
  TVec dst;
  intercept_t *in;
  TVec lineStart;
  TVec lineEnd;
  TVec shootOrigin;
  float sina, cosa;

  if (!Level.Game.IsAuthority) return;
  if (!Silent) PlaySound('weapons/railgf', CHAN_WEAPON);

  if (!specified_PuffType) PuffType = BulletPuff;

  if (!specified_pierceLimit) pierceLimit = int.max;

  name DmgType = 'Railgun';
  if (PuffType && PuffType.default.DamageType) DmgType = PuffType.default.DamageType;

  shootOrigin = Origin;
  shootOrigin.z += CalculateLineAttackZOfs();
  shootOrigin.z += spawnofs_z;
  sincos(Angles.yaw-90.0, out sina, out cosa);
  shootOrigin.x += Offset*cosa;
  shootOrigin.y += Offset*sina;

  //float distance = 8192.0;
  if (!specified_distance || !distance) distance = 8192.0;
  dst = shootOrigin+distance*dir;
  lineStart = shootOrigin;
  bool DidHit = false;
  foreach PathTraverse(in, Origin.x, Origin.y, dst.x, dst.y, PT_ADDLINES|PT_ADDTHINGS/*|PT_EARLYOUT*/) {
    TVec hit_point;
    line_t *li;
    EntityEx th;

    if (in->bIsALine) {
      sector_t *sec;

      li = in->line;
      hit_point = shootOrigin+(distance*in->frac)*dir;
      if ((li->flags&ML_TWOSIDED) && PointOnPlaneSide(shootOrigin, *li)) {
        sec = li->backsector;
      } else {
        sec = li->frontsector;
      }

      lineEnd = hit_point;

      // check for shooting floor or ceiling
      if (!RailCheckPlanes(sec, lineStart, lineEnd, distance, PuffType)) {
        DidHit = true;
        break;
      }

      lineStart = lineEnd;

      // execute line special after checking for hitting floor or ceiling
      // when we know that it actally hits line
      if (li->special && !bNoTrigger) LineSpecialLevelInfo(Level).ActivateLine(li, self, 0, SPAC_Impact);

      if (li->flags&ML_TWOSIDED) {
        // crosses a two sided line
        opening_t *open;
        float opentop = 0.0;

        open = LineOpenings(li, hit_point, SPF_NOBLOCKING|SPF_NOBLOCKSHOOT);
        if (open) opentop = open->top;
        while (open) {
          if (open->bottom <= hit_point.z && open->top >= hit_point.z) {
            if (!(li->flags&ML_BLOCKEVERYTHING)) break; // shot continues
          }
          open = open->next;
        }
        if (open) continue;
        if (li->frontsector->ceiling.pic == Level.Game.skyflatnum &&
            li->backsector->ceiling.pic == Level.Game.skyflatnum &&
            hit_point.z > opentop)
        {
          // it's a sky hack wall
          DidHit = true;
          break;
        }
      }

      // hit line

      // position a bit closer
      hit_point -= 4.0*dir;

      if (PuffType) SpawnPuff(hit_point, distance, PuffType, false); // spawn bullet puffs

      // don't go any farther
      lineEnd = hit_point;
      DidHit = true;
      break;
    }

    // shoot a thing
    th = EntityEx(in->Thing);

    if (th == self) continue; // can't shoot self

    if (!th.bShootable) continue; // corpse or something

    // check angles to see if the thing can be aimed at
    hit_point = shootOrigin+(distance*in->frac)*dir;

    if (th.Origin.z+th.Height < hit_point.z) continue; // shot over the thing
    if (th.Origin.z > hit_point.z) continue; // shot under the thing

    // invulnerable things completely block the shot
    if (th.bInvulnerable) {
      DidHit = true;
      lineEnd = hit_point;
      break;
    }

    // hit thing
    if (in->bExtraThingCheck && !XLevel.BSPTraceLine(shootOrigin, hit_point, nullptr, nullptr, SPF_NOBLOCKING)) {
      //printdebug("%C: cannot be hit!", th);
      continue;
    }

    // position a bit closer
    hit_point -= 10.0*dir;

    // spawn bullet puffs or blood spots, depending on target type
    if (th.bNoBlood || th.bInvulnerable || th.bDormant) {
      if (PuffType) SpawnPuff(hit_point, distance, PuffType, true);
    } else {
      if (!PuffType || !PuffType.default.bBloodlessImpact) th.SpawnBlood(hit_point, RailDamage, shootOrigin);
    }

    th.Damage(self, self, RailDamage, DmgType);

    if (--pierceLimit < 1) DontPierce = true;

    if (th && DontPierce) {
      // we did hit a thing and we can't pierce so we can stop now...
      DidHit = true;
      lineEnd = hit_point;
      break;
    }
  }

  if (!DidHit) {
    lineEnd = dst;
    RailCheckPlanes(XLevel.PointInSector(dst), lineStart, lineEnd, distance, PuffType);
  }

  // yep, "not specified" is processed in client trail code
  if (Col1 || Col2 || !specified_Col1 || !specified_Col2) {
    PlayerEx P;
    foreach AllActivePlayers(P) {
      P.ClientRailTrail(shootOrigin, lineEnd, Col1!optional, Col2!optional, MaxDiff);
    }
  }
}
