//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
const int FHF_NORANDOMPUFFZ = 1;
const int FHF_NOIMPACTDECAL = 2;


//**************************************************************************
//
//  aiming
//
//**************************************************************************
struct trsplat_t {
  TVec org;
  TVec hit;
  line_t *line;
  sector_t *sec;
  int side;
  bool didhit; // can be true even if `line` is empty (it means floor/ceiling hit)
  Entity mobj; // for other tracers
};


//==========================================================================
//
//  CalcProperThingHit
//
//==========================================================================
static final bool CalcProperThingHit (ref TVec hit_point, Entity th, const TVec shootOrigin, const TVec dir, const float distance) {
  if (hit_point.z > th.Origin.z+th.Height) {
    // trace enters above actor
    if (dir.z >= 0) return false; // going up: can't hit
    // does it hit the top of the actor?
    float dist = (th.Origin.z+th.Height-shootOrigin.z)/dir.z;
    if (dist > distance) return false;
    //float frac = dist/distance;
    hit_point = shootOrigin+dir*dist;
    // calculated coordinate is outside the actor's bounding box
    if (fabs(hit_point.x-th.Origin.x) > th.Radius ||
        fabs(hit_point.y-th.Origin.y) > th.Radius) return false;
  } else if (hit_point.z < th.Origin.z) {
    // trace enters below actor
    if (dir.z <= 0) return false; // going down: can't hit
    // does it hit the bottom of the actor?
    float dist = (th.Origin.z-shootOrigin.z)/dir.z;
    if (dist > distance) return false;
    //frac = dist/distance;
    hit_point = shootOrigin+dir*dist;
    // calculated coordinate is outside the actor's bounding box
    if (fabs(hit_point.x-th.Origin.x) > th.Radius ||
        fabs(hit_point.y-th.Origin.y) > th.Radius) return false;
  }
  return true;
}


//==========================================================================
//
//  PickActor
//
//==========================================================================
final override Entity PickActor (optional TVec org, TVec dir, float distance, optional int actorMask, optional int wallMask) {
  intercept_t *in;
  TVec lineEnd;

  if (!specified_actorMask) actorMask = MF_SHOOTABLE;
  if (!specified_wallMask) wallMask = ML_BLOCKEVERYTHING|ML_BLOCKHITSCAN;

  if (actorMask == 0) return none; // cannot realisticaly hit anything at all

  if (!specified_org) {
    org = Origin;
    org.z += Height*0.5-FloorClip;
    org.z += (bIsPlayer ? PlayerEx(Player).GetAttackZOfs : 8.0);
  }

  TVec shootOrigin = org;
  TVec dst = shootOrigin+distance*dir;
  TVec lineStart = shootOrigin;

  foreach PathTraverse(in, org.x, org.y, dst.x, dst.y, PT_ADDLINES|PT_ADDTHINGS/*|PT_EARLYOUT*/) {
    TVec hit_point, real_hit_point;
    line_t *li;
    EntityEx th;

    //print("LineAttack: isline=%d; frac=%f", (in->bIsALine ? 1 : 0), in->frac);
    //if (!in->bIsALine) print("LineAttack: frac=%f; thing=%C; dist=%f", in->frac, in->Thing, length2D(in.Thing.Origin-org));

    if (in->bIsALine) {
      sector_t *sec;

      li = in->line;
      hit_point = shootOrigin+(distance*in->frac)*dir;
      if ((li->flags&ML_TWOSIDED) && PointOnPlaneSide(shootOrigin, *li)) {
        sec = li->backsector;
      } else {
        sec = li->frontsector;
      }

      lineEnd = hit_point;

      // check for shooting floor or ceiling
      if (!ShootCheckPlanes(sec, li, lineStart, lineEnd, distance, PuffType:none, outHitPoint:nullptr)) return none;

      lineStart = lineEnd;

      if (Level.CompatTrace && li->frontsector == li->backsector) continue;

      if (li->flags&ML_TWOSIDED) {
        // crosses a two sided line
        opening_t *open;
        float opentop = 0.0;

        open = LineOpenings(li, hit_point);
        if (open) opentop = open->top;
        while (open) {
          if (open->bottom <= hit_point.z && open->top >= hit_point.z) {
            //if (!(li->flags&(ML_BLOCKEVERYTHING|ML_BLOCKHITSCAN))) break; // shot continues
            if (!(li->flags&wallMask)) {
              // shot continues
              //print("PickActor: line skipped; flags=0x%08x; mask=0x%08x", li->flags, wallMask);
              break;
            }
          }
          open = open->next;
        }
        if (open) continue;
        if (li->frontsector->ceiling.pic == Level.Game.skyflatnum &&
            li->backsector->ceiling.pic == Level.Game.skyflatnum &&
            hit_point.z > opentop)
        {
          // it's a sky hack wall
          //if (outHitPoint) *outHitPoint = hit_point;
          return none;
        }
      } else {
        // always stop on one-sided lines
        //if (outHitPoint) *outHitPoint = hit_point;
        return none;
      }

      // line hit, no thing found
      return none;
    }

    // hit a thing
    th = EntityEx(in->Thing);

    if (th == self) continue; // can't pick self

    // ignore ghosts
    if (th.bGhost) continue;

    int thflags = th.CalcEntityFlags();
    if (!(thflags&actorMask)) continue; // mask check failed

    // check angles to see if the thing can be aimed at
    hit_point = shootOrigin+(distance*in->frac)*dir;

    if (!CalcProperThingHit(hit_point, th, shootOrigin, dir, distance)) continue;
    //print("  thing: %C (over:%B; under:%B; tz=(%f,%f); hpz=%f)", th, (th.Origin.z+th.Height < hit_point.z), (th.Origin.z > hit_point.z), th.Origin.z, th.Origin.z+th.Height, hit_point.z);

    if (th.Origin.z+th.Height < hit_point.z) continue; // shot over the thing
    if (th.Origin.z > hit_point.z) continue; // shot under the thing

    // hit thing
    // position a bit closer
    //hit_point -= 10.0*dir;
    hit_point -= 2.0*dir;

    //if (outHitPoint) *outHitPoint = hit_point;

    //print("PickActor: th=%C (thflags=0x%08x; mask=0x%08x)", th, thflags, actorMask);
    // don't go any farther
    return th;
  }

  return none;
}


//==========================================================================
//
//  DebugCheckMidTex
//
//==========================================================================
final void DebugCheckMidTex () {
  TVec aimDir;
  //Aim(aimDir, 16.0*64.0, default, /*noAAim*/true);
  AngleVector(Angles, out aimDir);

  auto shootOrigin = Origin;
  shootOrigin.z += Height*0.5-FloorClip;
  shootOrigin.z += (bIsPlayer ? PlayerEx(Player).GetAttackZOfs : 8.0);

  trsplat_t tr;
  TraceLineEx(shootOrigin, aimDir, 8192, allowEntities:false, &tr, stopat3dmidtex:true, nozofs:true);
  if (tr.didhit && tr.line) {
    float top, bot;
    bool ok = P_GetMidTexturePosition(tr.line, tr.side, out top, out bot);
    print("DebugCheckMidTex(%B): hitpoint=%s; top=%s; bot=%s; flags=0x%08x", ok, tr.hit, top, bot, (tr.line ? tr.line->flags : 0));

    auto real_hit_point = tr.hit;
    auto hit_point = real_hit_point-(4.0*aimDir);
    // spawn bullet puff
    SpawnPuff(hit_point, /*distance*/8192, BulletPuff, false, tr.sec, tr.line, real_hit_point);
  }

  /+
  LineAttack(aimDir, /*Range*/10000, /*damage*/10000,
    BulletPuff, default, default,
    default, false);
  +/
}


//==========================================================================
//
// TraceLineEx
//
// Trace line to the wall or entity.
// Returns `true` if wall was hit.
// Returns `false` if floor/ceiling was hit, or nothing was hit.
//
//==========================================================================
final bool TraceLineEx (TVec org, TVec dir, float distance, bool allowEntities, optional trsplat_t *tr, optional bool stopat3dmidtex, optional bool nozofs) {
  TVec dst;
  intercept_t *in;
  TVec lineStart;
  TVec lineEnd;
  TVec shootOrigin;
  TVec outHitPoint;

  shootOrigin = org;
  if (!nozofs) shootOrigin.z += (bIsPlayer ? PlayerEx(Player).GetAttackZOfs : 8.0);

  dst = shootOrigin+distance*dir;

  if (tr) {
    tr->org = org;
    tr->hit = dst;
    tr->line = nullptr;
    tr->sec = nullptr;
    tr->didhit = false;
    tr->mobj = none;
  }

  lineStart = shootOrigin;
  foreach PathTraverse(in, org.x, org.y, dst.x, dst.y, PT_ADDLINES|(allowEntities ? PT_ADDTHINGS : 0)/*|PT_EARLYOUT*/) {
    TVec hit_point, real_hit_point;
    line_t *li;

    if (in->bIsALine) {
      int side;
      sector_t *sec;

      li = in->line;
      hit_point = shootOrigin+(distance*in->frac)*dir;
      if ((li->flags&ML_TWOSIDED) && PointOnPlaneSide(shootOrigin, *li)) {
        side = 1;
        sec = li->backsector;
      } else {
        side = 0;
        sec = li->frontsector;
      }

      lineEnd = hit_point;

      // check for shooting floor or ceiling
      if (!ShootCheckPlanes(sec, li, lineStart, lineEnd, distance, PuffType:none, &outHitPoint)) {
        // process floor and ceiling here
        if (tr) { tr->hit = outHitPoint; tr->didhit = true; }
        return false;
      }

      lineStart = lineEnd;

      if (Level.CompatTrace && li->frontsector == li->backsector) continue;

      /*if (stopat3dmidtex && (li->flags&ML_3DMIDTEX)) {
        // stop right here
        print("!!!!");
      } else*/ {
        if (li->flags&ML_TWOSIDED) {
          // crosses a two sided line
          float opentop = 0.0;

          opening_t *open = LineOpenings(li, hit_point, stopat3dmidtex);
          if (open) {
            print(":: line #%d (flags=0x%08x) ::", li-&XLevel.Lines[0], li->flags);
            for (opening_t *o = open; o; o = o->next) {
              print(" opening:");
              print("  open top: %s", o->top);
              print("  open bot: %s", o->bottom);
              print("  open range: %s", o->range);
              print("  open lowfloor: %s", o->lowfloor);
              print("  open highceiling: %s", o->highceiling);
            }
          }
          if (stopat3dmidtex && (li->flags&ML_3DMIDTEX)) {
            // stop right here
            print("!!!!");
            open = nullptr;
          }

          if (open) opentop = open->top;
          while (open) {
            if (open->bottom <= hit_point.z && open->top >= hit_point.z) {
              if (!(li->flags&ML_BLOCKEVERYTHING)) break; // shot continues
            }
            open = open->next;
          }
          if (open) continue;

          if (li->frontsector->ceiling.pic == Level.Game.skyflatnum &&
              li->backsector->ceiling.pic == Level.Game.skyflatnum &&
              hit_point.z > opentop)
          {
            // it's a sky hack wall
            if (tr) { tr->hit = hit_point; tr->didhit = true; }
            return false;
          }
        }
      }

      outHitPoint = hit_point;

      if (li->special == LNSPEC_LineHorizon) {
        if (tr) tr->hit = hit_point;
        return false; // don't spawn decals on sky
      }

      // Hit line
      if (tr) {
        tr->hit = hit_point;
        tr->line = li;
        tr->sec = sec;
        tr->side = side;
        tr->didhit = true;
      }

      // don't go any farther
      return true;
    } else if (in->Thing && !in->Thing.IsA('DoomPlayer')) {
      // thing
      hit_point = shootOrigin+(distance*in->frac)*dir;
      if (!CalcProperThingHit(hit_point, in->Thing, shootOrigin, dir, distance)) continue;
      if (hit_point.z >= in->Thing.Origin.z && hit_point.z < in->Thing.Origin.z+in->Thing.Height) {
        tr->hit = hit_point;
        tr->mobj = in->Thing;
        return false;
      }
    }
  }

  lineEnd = dst;
  if (!ShootCheckPlanes(XLevel.PointInSector(dst), line:default, lineStart, lineEnd, distance, PuffType:none, &outHitPoint)) {
    // process floor and ceiling here
    if (tr) { tr->hit = outHitPoint; tr->didhit = true; }
  }

  return false;
}


//==========================================================================
//
//  AimLineAttack
//
//  Sets linetaget and aim_slope when a target is aimed at.
//
//==========================================================================
final EntityEx AimLineAttack (out TVec OutDir, TAVec angles, float distance, optional bool noVertAutoAim) {
  float x2, y2;
  float topangle, botangle;
  TVec dir;
  intercept_t *in;
  EntityEx linetarget; // who got hit (or nullptr)

  // height if not aiming up or down
  // ???: use slope for monsters?
  float aim_z;
  float aim_range;
  float aim_slope;
  TVec aim_dir;
  float aim_topslope;
  float aim_bottomslope; // slopes to top and bottom of target
  float aim_range2d;

  AngleVector(angles, out aim_dir);
  x2 = Origin.x+distance*aim_dir.x;
  y2 = Origin.y+distance*aim_dir.y;
  aim_z = Origin.z+Height/2.0-FloorClip;
  if (bIsPlayer) {
    aim_z += PlayerEx(Player).GetAttackZOfs;
  } else {
    aim_z += 8.0;
  }
  aim_range2d = Length(vector(distance*aim_dir.x, distance*aim_dir.y, 0.0));

  // can't shoot outside view angles
  topangle = AngleMod180(-angles.pitch+30.0);
  botangle = AngleMod180(-angles.pitch-30.0);
  if (topangle > 89.0) topangle = 89.0;
  if (botangle < -89.0) botangle = -89.0;
  aim_topslope = tan(topangle);
  aim_bottomslope = tan(botangle);

  aim_range = distance;
  linetarget = none;

  foreach PathTraverse(in, Origin.x, Origin.y, x2, y2, PT_ADDLINES|PT_ADDTHINGS/*|PT_EARLYOUT*/) {
    line_t *li;
    EntityEx th;
    float thingtopslope;
    float thingbottomslope;
    float dist;
    float slope;
    opening_t *open;

    if (in->bIsALine) {
      TVec hit_point;

      li = in->line;

      if (!(li->flags&ML_TWOSIDED) || (li->flags&(ML_BLOCKEVERYTHING|ML_BLOCKHITSCAN))) break; // stop

      // crosses a two sided line
      // a two sided line will restrict the possible target ranges
      dist = aim_range*in->frac;
      if (dist < 0.01) continue; // shooter is on the line

      hit_point = Origin+dist*aim_dir;
      open = LineOpenings(li, hit_point);
      open = FindOpening(open, hit_point.z, hit_point.z);

      if (!open || open->bottom >= open->top) break; // stop

      dist = aim_range2d*in->frac;

      slope = (open->bottom-aim_z)/dist;
      if (slope > aim_bottomslope) aim_bottomslope = slope;

      slope = (open->top-aim_z)/dist;
      if (slope < aim_topslope) aim_topslope = slope;

      if (aim_topslope <= aim_bottomslope) break; // stop

      continue; // shot continues
    }

    // shoot a thing
    th = EntityEx(in->Thing);
    if (th == self) continue; // can't shoot self

    if (!th.bShootable) continue; // corpse or something

    if (th.bCantAutoAim) continue; // can't auto-aim at pods

    if (IsTeammate(th)) continue; // don't aim at fellow co-op players

    // check angles to see if the thing can be aimed at
    dist = aim_range2d*in->frac;
    if (dist < 0.01) continue; // too close, must be above or below
    thingtopslope = (th.Origin.z+th.Height-aim_z)/dist;

    if (thingtopslope < aim_bottomslope) continue; // shot over the thing

    thingbottomslope = (th.Origin.z-aim_z)/dist;

    if (thingbottomslope > aim_topslope) continue; // shot under the thing

    // this thing can be hit!
    if (thingtopslope > aim_topslope) thingtopslope = aim_topslope;

    if (thingbottomslope < aim_bottomslope) thingbottomslope = aim_bottomslope;

    aim_slope = (thingtopslope+thingbottomslope)/2.0;
    linetarget = th;

    break;  // don't go any farther
  }

  if (linetarget && !noVertAutoAim) angles.pitch = -atan(aim_slope);
  AngleVector(angles, out dir);
  OutDir = dir;
  return linetarget;
}


//===========================================================================
//
//  Aim
//
//  Sets a slope so a near miss is at aproximately the height of the
//  intended target
//
//===========================================================================
final EntityEx Aim (out TVec OutDir, float distance, optional float yaw, optional bool noAutoaim, optional bool noVertAutoAim) {
  TAVec ang;
  TVec dir;
  EntityEx LineTarget;

  bool aaim = (bIsPlayer && PlayerEx(Player).bAutoAim);
  if (specified_noAutoaim) {
    //print("AIM<%C>: noaa=%s", self, (noAutoaim ? "tan" : "ona"));
    if (noAutoaim) aaim = false;
  }

  // see which target is to be aimed at
  ang = Angles;
  if (specified_yaw) ang.yaw = yaw;
  if (bIsPlayer && /*!PlayerEx(Player).bAutoAim*/!aaim) {
    //ang.pitch = AngleMod360(ang.pitch-4);
    AngleVector(ang, out dir);
    OutDir = dir;
  }

  // try to aim at a target
  // this is done even when autoaim is off so that we get a LineTarget that is needed for seeker missiles
  LineTarget = AimLineAttack(dir, ang, distance);
  if (!LineTarget) {
    auto origYaw = ang.yaw;
    ang.yaw = AngleMod360(ang.yaw+45.0/8.0);
    LineTarget = AimLineAttack(dir, ang, distance, noVertAutoAim!optional);
    if (!LineTarget) {
      ang.yaw = AngleMod360(ang.yaw-45.0/4.0);
      LineTarget = AimLineAttack(dir, ang, distance, noVertAutoAim!optional);
      if (!LineTarget) {
        //ang.yaw = AngleMod360(ang.yaw+45.0/8.0);
        ang.yaw = origYaw;
        AngleVector(ang, out dir);
      }
    }
  }

  if (!bIsPlayer || aaim/*PlayerEx(Player).bAutoAim*/) OutDir = dir;

  return LineTarget;
}


//==========================================================================
//
//  AimEx
//
//==========================================================================
final EntityEx AimEx (out TVec OutDir, float Range, float AngleInc, int NumSteps, optional float FinalRange) {
  TAVec angles;
  //TVec vforward;
  EntityEx LineTarget;

  foreach (auto i; 0..NumSteps) {
    // try to the left
    angles = Angles;
    angles.yaw = AngleMod360(angles.yaw+float(i)*AngleInc);
    LineTarget = AimLineAttack(OutDir, angles, Range);
    if (LineTarget) return LineTarget;

    // try to the right
    angles = Angles;
    angles.yaw = AngleMod360(angles.yaw-float(i)*AngleInc);
    LineTarget = AimLineAttack(OutDir, angles, Range);
    if (LineTarget) return LineTarget;
  }

  if (FinalRange) {
    // didn't find any creatures, so try to strike any walls
    angles = Angles;
    LineTarget = AimLineAttack(out OutDir, angles, FinalRange);
  } else {
    //AngleVector(Angles, out vforward);
    //OutDir = vforward;
    AngleVector(Angles, out OutDir);
  }

  return LineTarget;
}


//**************************************************************************
//
//  SHOOTING
//
//**************************************************************************

//==========================================================================
//
//  ShootHitPlane
//
//  This spawn poofs for floor/ceiling.
//
//==========================================================================
final bool ShootHitPlane (sector_t *sec, line_t *li, sec_plane_t *plane,
                          TVec linestart, TVec lineend, float range,
                          class!EntityEx PuffType, TVec *outHitPoint)
{
  if (plane->flags&SPF_NOBLOCKSHOOT) return true; // doesn't block shooting

  float org_dist = DotProduct(linestart, plane->normal)-plane->dist;
  if (org_dist < 0.0) return true; // don't shoot back side

  float hit_dist = DotProduct(lineend, plane->normal)-plane->dist;
  if (hit_dist >= 0.0) return true; // didn't hit plane

  // hit plane
  if (plane->pic == Level.Game.skyflatnum) {
    // don't shoot the sky!
    if (outHitPoint) *outHitPoint = lineend;
    return false;
  }

  // if we are shooting floor or ceiling we are adjusting position
  // to spawn puff on floor or ceiling, not on wall
  lineend -= (lineend-linestart)*hit_dist/(hit_dist-org_dist);

  // position a bit closer
  lineend += 4.0*plane->normal;

  // spawn bullet puffs
  //SpawnPuff(lineend, range, PuffType, false, sec, li); //k8: we can't do decals on non-walls yet
  if (PuffType) SpawnPuff(lineend, range, PuffType, false);

  if (outHitPoint) *outHitPoint = lineend;

  // don't go any farther
  return false;
}


//==========================================================================
//
//  ShootCheckPlanes
//
//==========================================================================
final bool ShootCheckPlanes (sector_t *sec, optional line_t *line,
                             TVec linestart, TVec lineend, float range,
                             class!EntityEx PuffType, TVec *outHitPoint)
{
  sec_region_t *reg;
  sec_region_t *startreg;

  startreg = PointInRegion(sec, linestart);

  for (reg = startreg; reg; reg = reg->next) {
    if (!ShootHitPlane(sec, line, reg->floor, linestart, lineend, range, PuffType, outHitPoint)) return false; // hit floor
    if (!ShootHitPlane(sec, line, reg->ceiling, linestart, lineend, range, PuffType, outHitPoint)) return false; // hit ceiling
  }

  for (reg = startreg->prev; reg; reg = reg->prev) {
    if (!ShootHitPlane(sec, line, reg->floor, linestart, lineend, range, PuffType, outHitPoint)) return false; // hit floor
    if (!ShootHitPlane(sec, line, reg->ceiling, linestart, lineend, range, PuffType, outHitPoint)) return false; // hit ceiling
  }

  return true;
}


//==========================================================================
//
//  eventLineAttackACS
//
//==========================================================================
override void eventLineAttackACS (TVec dir, float distance, int LADamage, name pufftype, name damagetype, int flags, int pufftid) {
  class!EntityEx PuffType = none;
  if (damagetype) PuffType = class!EntityEx(FindClassNoCase(damagetype));
  if (flags&FHF_NOIMPACTDECAL) {
    LineAttack(dir, distance, LADamage, PuffType, NoAttackGhosts:true, DmgType:damagetype, decalType:'', pufftid:pufftid, !!(flags&FHF_NORANDOMPUFFZ));
  } else {
    LineAttack(dir, distance, LADamage, PuffType, NoAttackGhosts:true, DmgType:damagetype, pufftid:pufftid, !!(flags&FHF_NORANDOMPUFFZ));
  }
}


//==========================================================================
//
//  LineAttack
//
//  to prevent decal spawning, pass 'none' as `decalType`
//  (or something else that is non-existing)
//  decalType of '' means "use default puff decal"
//
//==========================================================================
final int LineAttack (TVec dir, float distance, int LADamage,
                      class!EntityEx PuffType, optional bool NoAttackGhosts,
                      optional TVec *outHitPoint, optional name DmgType,
                      optional bool secondary, optional name decalType,
                      optional int pufftid, optional bool disableRandomZ)
{
  TVec dst;
  intercept_t *in;
  TVec lineStart;
  TVec lineEnd;
  TVec shootOrigin;

  //print("LineAttack: self=<%C>", self);

  //Entity e; print("%f", e.Height);

  shootOrigin = Origin;
  shootOrigin.z += Height*0.5-FloorClip;
  shootOrigin.z += (bIsPlayer ? PlayerEx(Player).GetAttackZOfs : 8.0);

  dst = shootOrigin+distance*dir;
  lineStart = shootOrigin;

  //print("=== LineAttack ===");
  foreach PathTraverse(in, Origin.x, Origin.y, dst.x, dst.y, PT_ADDLINES|PT_ADDTHINGS/*|PT_EARLYOUT*/) {
    TVec hit_point, real_hit_point;
    line_t *li;
    EntityEx th;

    //print("LineAttack: isline=%d; frac=%f", (in->bIsALine ? 1 : 0), in->frac);
    //if (!in->bIsALine) print("LineAttack: frac=%f; thing=%C; dist=%f", in->frac, in->Thing, length2D(in.Thing.Origin-Origin));

    if (in->bIsALine) {
      sector_t *sec;

      li = in->line;
      hit_point = shootOrigin+(distance*in->frac)*dir;
      if ((li->flags&ML_TWOSIDED) && PointOnPlaneSide(shootOrigin, *li)) {
        sec = li->backsector;
      } else {
        sec = li->frontsector;
      }

      lineEnd = hit_point;

      // check for shooting floor or ceiling
      if (!ShootCheckPlanes(sec, li, lineStart, lineEnd, distance, PuffType, outHitPoint)) return false;

      lineStart = lineEnd;

      if (Level.CompatTrace && li->frontsector == li->backsector) continue;

      // execute line special after checking for hitting floor or ceiling when we know that it actally hits line
      if (li->special && !bNoTrigger) LineSpecialLevelInfo(Level).ActivateLine(li, self, 0, SPAC_Impact);

      if (li->flags&ML_TWOSIDED) {
        // crosses a two sided line
        opening_t *open;
        float opentop = 0.0;

        open = LineOpenings(li, hit_point);
        if (open) opentop = open->top;
        while (open) {
          if (open->bottom <= hit_point.z && open->top >= hit_point.z) {
            if (!(li->flags&(ML_BLOCKEVERYTHING|ML_BLOCKHITSCAN))) break; // shot continues
          }
          open = open->next;
        }
        if (open) continue;
        if (li->frontsector->ceiling.pic == Level.Game.skyflatnum &&
            li->backsector->ceiling.pic == Level.Game.skyflatnum &&
            hit_point.z > opentop)
        {
          // it's a sky hack wall
          if (outHitPoint) *outHitPoint = hit_point;
          return false;
        }
      }

      if (outHitPoint) *outHitPoint = hit_point;

      if (li->special == LNSPEC_LineHorizon) return false; // don't spawn puffs on sky

      // hit line

      // position a bit closer
      real_hit_point = hit_point;
      hit_point -= 4.0*dir;

      // spawn bullet puffs
      if (PuffType) {
        SpawnPuff(hit_point, distance, PuffType, false, sec, li, real_hit_point, decalType!optional, pufftid!optional, disableRandomZ!optional);
      }

      // don't go any farther
      return false;
    }

    // shoot a thing
    th = EntityEx(in->Thing);

    //print("  thing: %n (isself:%d)", GetClassName(th.Class), (th == self ? 1 : 0));

    if (th == self) continue; // can't shoot self

    if (!th.bShootable) continue; // corpse or something

    // check angles to see if the thing can be aimed at
    hit_point = shootOrigin+(distance*in->frac)*dir;

    if (!CalcProperThingHit(hit_point, th, shootOrigin, dir, distance)) continue;
    //print("  thing: %C (over:%B; under:%B; tz=(%f,%f); hpz=%f)", th, (th.Origin.z+th.Height < hit_point.z), (th.Origin.z > hit_point.z), th.Origin.z, th.Origin.z+th.Height, hit_point.z);

    if (th.Origin.z+th.Height < hit_point.z) continue; // shot over the thing
    if (th.Origin.z > hit_point.z) continue; // shot under the thing

    // hit thing
    // position a bit closer
    //hit_point -= 10.0*dir;
    hit_point -= 2.0*dir;

    // check for physical attacks on a ghost
    if (th.bGhost && NoAttackGhosts) continue;

    if (outHitPoint) *outHitPoint = hit_point;

    bool UseAxeBlood = bIsPlayer && PlayerEx(Player).ReadyWeapon && PlayerEx(Player).ReadyWeapon.bAxeBlood;
    bool UseBloodSplatter = UseAxeBlood || bBloodSplatter ||
                            (bIsPlayer && PlayerEx(Player).ReadyWeapon && PlayerEx(Player).ReadyWeapon.bBloodSplatter);

    // spawn bullet puffs or blood spots, depending on target type
    if (PuffType.default.bPuffOnActors || th.bNoBlood || th.bInvulnerable || th.bDormant) {
      SpawnPuff(hit_point, distance, PuffType, true, pufftid:pufftid!optional, disableRandomZ:disableRandomZ!optional);
    }
    if (!UseBloodSplatter && !th.bNoBlood && !th.bInvulnerable && !th.bDormant) {
      th.SpawnBlood(hit_point, LADamage, shootOrigin);
    }
    if (LADamage && UseBloodSplatter) {
      if (!th.bNoBlood && !th.bInvulnerable && !th.bDormant) {
        if (UseAxeBlood) th.SpawnBloodSplatter2(hit_point, shootOrigin);
        if (P_Random() < 192) th.SpawnBloodSplatter(hit_point, LADamage, shootOrigin);
      }
    }

    if (LADamage) {
      bool NoArmor = false;
      // allow bPierceArmor on weapons as well
      if (bIsPlayer && PlayerEx(Player).ReadyWeapon && PlayerEx(Player).ReadyWeapon.bPierceArmor) NoArmor = true;
      if (bIsPlayer) {
        TVec thp;
        thp = hit_point-th.Origin;
        th.DamageEx(self, self, LADamage, DmgType, NoArmor, thp, secondary);
      } else {
        th.Damage(self, self, LADamage, DmgType, NoArmor);
      }
    }

    // don't go any farther
    return false;
  }

  lineEnd = dst;
  if (!ShootCheckPlanes(XLevel.PointInSector(dst), default, lineStart, lineEnd, distance, PuffType, outHitPoint)) {
    return false;
  }

  if (PuffType) {
    if (PuffType.default.ActiveSound) PlaySound(PuffType.default.ActiveSound, CHAN_WEAPON); // play miss sound
    if (PuffType.default.bAlwaysPuff) SpawnPuff(lineEnd, distance, PuffType, false, pufftid:pufftid!optional, disableRandomZ:disableRandomZ!optional);
  }

  return true;
}


//**************************************************************************
//
//  RAILGUN
//
//**************************************************************************

//==========================================================================
//
//  RailHitPlane
//
//==========================================================================
final bool RailHitPlane (sec_plane_t *plane, TVec linestart, out TVec lineend,
                         float range, class!EntityEx PuffType)
{
  if (plane->flags&SPF_NOBLOCKSHOOT) return true; // doesn't block shooting
  float org_dist = DotProduct(linestart, plane->normal)-plane->dist;

  if (org_dist < 0.0) return true; // don't shoot back side

  float hit_dist = DotProduct(lineend, plane->normal)-plane->dist;
  if (hit_dist >= 0.0) return true; // didn't hit plane

  // hit plane
  if (plane->pic == Level.Game.skyflatnum) return false; // don't shoot the sky!

  // if we are shooting floor or ceiling we are adjusting position
  // to spawn puff on floor or ceiling, not on wall
  lineend -= (lineend-linestart)*hit_dist/(hit_dist-org_dist);

  // position a bit closer
  lineend += 4.0*plane->normal;

  if (PuffType) SpawnPuff(lineend, range, PuffType, false); // spawn bullet puffs

  // don't go any farther
  return false;
}


//==========================================================================
//
//  RailCheckPlanes
//
//==========================================================================
final bool RailCheckPlanes (sector_t *sec, TVec linestart, out TVec lineend,
                            float range, class!EntityEx PuffType)
{
  sec_region_t *reg;

  sec_region_t *startreg = PointInRegion(sec, linestart);

  for (reg = startreg; reg; reg = reg->next) {
    if (!RailHitPlane(reg->floor, linestart, lineend, range, PuffType)) return false; // hit floor
    if (!RailHitPlane(reg->ceiling, linestart, lineend, range, PuffType)) return false; // hit ceiling
  }

  for (reg = startreg->prev; reg; reg = reg->prev) {
    if (!RailHitPlane(reg->floor, linestart, lineend, range, PuffType)) return false; // hit floor
    if (!RailHitPlane(reg->ceiling, linestart, lineend, range, PuffType)) return false; // hit ceiling
  }

  return true;
}


//==========================================================================
//
//  RailAttack
//
//==========================================================================

final void RailAttack (TVec dir, float Offset, int RailDamage,
                       optional int Col1, optional int Col2, optional float MaxDiff,
                       optional class!EntityEx PuffType, optional bool Silent,
                       optional bool DontPierce, optional float distance,
                       optional float spawnofs_z, optional int pierceLimit)
{
  TVec dst;
  intercept_t *in;
  TVec lineStart;
  TVec lineEnd;
  TVec shootOrigin;

  if (!Silent) PlaySound('weapons/railgf', CHAN_WEAPON);

  if (!specified_PuffType) PuffType = BulletPuff;

  if (!specified_pierceLimit) pierceLimit = int.max;

  name DmgType = 'Railgun';
  if (PuffType && PuffType.default.DamageType) DmgType = PuffType.default.DamageType;

  shootOrigin = Origin;
  shootOrigin.z += Height*0.5-FloorClip;
  if (bIsPlayer) {
    shootOrigin.z += PlayerEx(Player).GetAttackZOfs;
  } else {
    shootOrigin.z += 8.0;
  }
  shootOrigin.z += spawnofs_z;
  shootOrigin.x += Offset*cos(Angles.yaw-90.0);
  shootOrigin.y += Offset*sin(Angles.yaw-90.0);

  //float distance = 8192.0;
  if (!specified_distance || !distance) distance = 8192.0;
  dst = shootOrigin+distance*dir;
  lineStart = shootOrigin;
  bool DidHit = false;
  foreach PathTraverse(in, Origin.x, Origin.y, dst.x, dst.y, PT_ADDLINES|PT_ADDTHINGS/*|PT_EARLYOUT*/) {
    TVec hit_point;
    line_t *li;
    EntityEx th;

    if (in->bIsALine) {
      sector_t *sec;

      li = in->line;
      hit_point = shootOrigin+(distance*in->frac)*dir;
      if (li->flags&ML_TWOSIDED && PointOnPlaneSide(shootOrigin, *li)) {
        sec = li->backsector;
      } else {
        sec = li->frontsector;
      }

      lineEnd = hit_point;

      // check for shooting floor or ceiling
      if (!RailCheckPlanes(sec, lineStart, lineEnd, distance, PuffType)) {
        DidHit = true;
        break;
      }

      lineStart = lineEnd;

      // execute line special after checking for hitting floor or ceiling
      // when we know that it actally hits line
      if (li->special && !bNoTrigger) LineSpecialLevelInfo(Level).ActivateLine(li, self, 0, SPAC_Impact);

      if (li->flags&ML_TWOSIDED) {
        // crosses a two sided line
        opening_t *open;
        float opentop = 0.0;

        open = LineOpenings(li, hit_point);
        if (open) opentop = open->top;
        while (open) {
          if (open->bottom <= hit_point.z && open->top >= hit_point.z) {
            if (!(li->flags&ML_BLOCKEVERYTHING)) break; // shot continues
          }
          open = open->next;
        }
        if (open) continue;
        if (li->frontsector->ceiling.pic == Level.Game.skyflatnum &&
            li->backsector->ceiling.pic == Level.Game.skyflatnum &&
            hit_point.z > opentop)
        {
          // it's a sky hack wall
          DidHit = true;
          break;
        }
      }

      // hit line

      // position a bit closer
      hit_point -= 4.0*dir;

      if (PuffType) SpawnPuff(hit_point, distance, PuffType, false); // spawn bullet puffs

      // don't go any farther
      lineEnd = hit_point;
      DidHit = true;
      break;
    }

    // shoot a thing
    th = EntityEx(in->Thing);

    if (th == self) continue; // can't shoot self

    if (!th.bShootable) continue; // corpse or something

    // check angles to see if the thing can be aimed at
    hit_point = shootOrigin+(distance*in->frac)*dir;

    if (th.Origin.z+th.Height < hit_point.z) continue; // shot over the thing
    if (th.Origin.z > hit_point.z) continue; // shot under the thing

    // invulnerable things completely block the shot
    if (th.bInvulnerable) {
      DidHit = true;
      lineEnd = hit_point;
      break;
    }

    // hit thing
    // position a bit closer
    hit_point -= 10.0*dir;

    // spawn bullet puffs or blood spots, depending on target type
    if (th.bNoBlood || th.bInvulnerable || th.bDormant) {
      if (PuffType) SpawnPuff(hit_point, distance, PuffType, true);
    } else {
      th.SpawnBlood(hit_point, RailDamage, shootOrigin);
    }

    th.Damage(self, self, RailDamage, DmgType);

    if (--pierceLimit < 1) DontPierce = true;

    if (th && DontPierce) {
      // we did hit a thing and we can't pierce so we can stop now...
      DidHit = true;
      lineEnd = hit_point;
      break;
    }
  }

  if (!DidHit) {
    lineEnd = dst;
    RailCheckPlanes(XLevel.PointInSector(dst), lineStart, lineEnd, distance, PuffType);
  }

  PlayerEx P;
  foreach AllActivePlayers(P) {
    P.ClientRailTrail(shootOrigin, lineEnd, Col1, Col2, MaxDiff);
  }
}
