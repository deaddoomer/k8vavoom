//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//
//  Object movement
//
//**************************************************************************
// define this to check velocity before clamping
//#define PHYSICS_VELOCITY_CHECKS


//==========================================================================
//
//  GetFloorAndCeiling
//
//==========================================================================
final void GetFloorAndCeiling (out tmtrace_t tmtrace) {
  bool oldWithThings = bColideWithThings;
  bool oldWithWorld = bColideWithWorld;
  scope(exit) {
    bColideWithThings = oldWithThings;
    bColideWithWorld = oldWithWorld;
  }
  bColideWithThings = false;
  bColideWithWorld = false;
  // find new position
  CheckRelPosition(&tmtrace, Origin, noPickups:true, ignoreMonsters:true, ignorePlayers:true);
}


//==========================================================================
//
//  GetFloorAndCeilingEx
//
//==========================================================================
final void GetFloorAndCeilingEx (out tmtrace_t tmtrace, TVec org, optional bool collideWorld, optional bool collideThings) {
  bool oldWithThings = bColideWithThings;
  bool oldWithWorld = bColideWithWorld;
  scope(exit) {
    bColideWithThings = oldWithThings;
    bColideWithWorld = oldWithWorld;
  }
  bColideWithThings = collideThings;
  bColideWithWorld = collideWorld;
  // find new position
  CheckRelPosition(&tmtrace, org, noPickups:true, ignoreMonsters:true, ignorePlayers:true);
}


//==========================================================================
//
//  Physics
//
//  returns `false` if mobj is destroyed
//  actually, `false` means "stop processing current tick code", so you
//  can return `false` for this reason too
//
//==========================================================================
bool Physics (float DeltaTime) {
  //if (bIsPlayer) { printdebug("%C: bSlide=%B", self, bSlide); /*bSlide = true;*/ }

  // GZDoom does it like this, so we should do it this way too
  if (bNoInteraction) {
    // `bNoTimeFreeze` is checked in `Tick()`
    if (Velocity || !bNoBlockmap) {
      // move, and unlink from blockmap
      UnlinkFromWorld();
      // it is safe to change this flag here
      bNoBlockmap = true;
      // it is safe to change origin here
      if (bStickToFloor || bStickToCeiling) Velocity.z = 0;
      TVec vel = Velocity*DeltaTime;
      Origin += vel;
      // link it back
      LinkToWorld(properFloorCheck:false);
    }
    if (bStickToFloor || bStickToCeiling) {
      tmtrace_t tmtrace;
      GetFloorAndCeiling(out tmtrace);
      // no need to relink for z change
      Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
      bIntrJustMoved = false; // disable movement interpolation
    }
    return true;
  }

  // check flat sticking
  if (bStickToFloor || bStickToCeiling) {
    bIntrJustMoved = false; // disable movement interpolation
    Velocity.z = 0;
  }

  // process boom transporters
  float CummX = 0.0;
  float CummY = 0.0;

  //if (bOnScroll) printdebug("%C: ON SCROLLER!", self);

  //k8: do we even need to process entity without sector set here?
  if (Sector) {
    #if 0
    // old code
    if (Sector->AffectorData && bColideWithWorld && !bNoSector) {
      // killough 3/7/98: Carry things on floor
      // killough 3/20/98: use new sector list which reflects true members
      // killough 3/27/98: fix carrier bug
      // killough 4/4/98: Underwater, carry things even w/o gravity

      // move objects only if on floor or underwater, non-floating, and clipped
      // k8: this should work with 3d floors, but now it doesn't
      int CountX = 0;
      int CountY = 0;
      SectorThinker SecThink;
      for (SecThink = SectorThinker(Sector->AffectorData); SecThink; SecThink = SecThink.NextAffector) {
        auto sth = Scroller(SecThink);
        if (!sth) continue;
        float scrollx = sth.CarryScrollX;
        float scrolly = sth.CarryScrollY;
        if (!scrollx && !scrolly) continue;
        if (bNoGravity && (!Sector->heightsec || Sector->heightsec->bIgnoreHeightSec)) continue;
        float height = GetPointZClamped(ref Sector->floor, Origin);
        if (Origin.z > height) {
          if (!Sector->heightsec || Sector->heightsec->bIgnoreHeightSec) continue;
          float waterheight = GetPointZClamped(ref Sector->heightsec->floor, Origin);
          if (waterheight > height && Origin.z >= waterheight) continue;
        }

        CummX += scrollx;
        CummY += scrolly;
        if (scrollx) ++CountX;
        if (scrolly) ++CountY;
      }

      // Some levels designed with Boom in mind actually want things to accelerate
      // at neighboring scrolling sector boundaries. But it is only important for
      // non-player objects.
      if (bIsPlayer || !Level.CompatBoomScroll) {
        if (CountX > 1) CummX /= float(CountX);
        if (CountY > 1) CummY /= float(CountY);
      }
      //if (CummX || CummY) print("%C: CALCULATED SCROLL=(%s,%s); vel=%s", self, CummX, CummY, Velocity);
    }
    #else
    // new code
    if (GetClassInstanceCountWithSub(Scroller) && bColideWithWorld && !bNoSector && Origin != lastScrollCheckOrigin) {
      //printdebug("%C(%s): SCROLLER CHECK!", self, UniqueId);
      lastScrollCheckOrigin = Origin;
      // killough 3/7/98: Carry things on floor
      // killough 3/20/98: use new sector list which reflects true members
      // killough 3/27/98: fix carrier bug
      // killough 4/4/98: Underwater, carry things even w/o gravity
      // k8: check all sectors we are touching, because this is how it should work
      // k8: sector cannot appear twice in list, so there is no reason to protect iteration with a counter
      //int vismark = 0; // don't create it until necessary
      // k8: this should work with 3d floors, but now it doesn't
      int CountX = 0;
      int CountY = 0;
      bool resetCheck = false;
      for (msecnode_t *mnode = TouchingSectorList; mnode; mnode = mnode.TNext) {
        sector_t *sec = mnode.Sector;
        if (!sec->AffectorData) continue;
        // move objects only if on floor or underwater, non-floating, and clipped
        for (SectorThinker SecThink = SectorThinker(sec->AffectorData); SecThink; SecThink = SecThink.NextAffector) {
          auto sth = Scroller(SecThink);
          if (!sth) continue;
          resetCheck = true;
          float scrollx = sth.CarryScrollX;
          float scrolly = sth.CarryScrollY;
          if (!scrollx && !scrolly) continue;
          if (bNoGravity && (!sec->heightsec || sec->heightsec->bIgnoreHeightSec)) continue;
          float height = GetPointZClamped(ref sec->floor, Origin);
          if (Origin.z > height) {
            if (!sec->heightsec || sec->heightsec->bIgnoreHeightSec) continue;
            float waterheight = GetPointZClamped(ref sec->heightsec->floor, Origin);
            if (waterheight > height && Origin.z >= waterheight) continue;
          }
          // don't process sectors twice (eh, it is guaranteed by the list builder)
          //if (!vismark) vismark = XLevel.GetNextVisitedCount();
          //if (mnode.Visited == vismark) continue;
          //mnode.Visited = vismark;
          CummX += scrollx;
          CummY += scrolly;
          if (scrollx) ++CountX;
          if (scrolly) ++CountY;
        }
      }
      // reset check, so scroller will work next time
      if (resetCheck) lastScrollCheckOrigin = vector(-90000, -90000, -90000);

      // Some levels designed with Boom in mind actually want things to accelerate
      // at neighboring scrolling sector boundaries. But it is only important for
      // non-player objects.
      if (bIsPlayer || !Level.CompatBoomScroll) {
        if (CountX > 1) CummX /= float(CountX);
        if (CountY > 1) CummY /= float(CountY);
      }
      //if (CummX || CummY) print("%C: CALCULATED SCROLL=(%s,%s); vel=%s", self, CummX, CummY, Velocity);
    }
    /*
    else {
      printdebug("%C(%s): SCROLLER CHECK SKIP! Origin=%s; last=%s", self, UniqueId, Origin, lastScrollCheckOrigin);
    }
    */
    #endif

    //k8: re-check it only when z position or sector was changed
    if (tmp_phys_last_water_sector != Sector || Origin.z != tmp_phys_last_water_z) {
      CheckWater();
      tmp_phys_last_water_sector = Sector;
      tmp_phys_last_water_z = Origin.z;
      tmp_phys_last_floor_pic = EFloor.splane->pic;
    }
    // `UpdateVelocity()` does nothing if "no gravity" set
    //FIXME: make a separate flag for this?
    //if (!bNoGravity && (!bFloatBob || !bSpecial)) UpdateVelocity(DeltaTime);
    if (!bFloatBob || !bSpecial) UpdateVelocity(DeltaTime);
    // apply friction here
    if (Velocity.xy) ApplyFriction(DeltaTime);
  }

  // momentum (velocity) movement
  // handle X and Y momentums
  float oldfloorz = XYMovement(DeltaTime, CummX, CummY);
  if (IsDestroyed) return false; // mobj was removed
  // apply friction here
  //if (Velocity.x || Velocity.y) ApplyFriction(DeltaTime);

  if (bFloatBob) {
    float oldFloatZ = Origin.z;
    if (bSpecial) {
      // floating item bobbing motion (special1 is height)
      if (Sector && Sector->bHasExtrafloors) {
        // make sure FloorZ is from bottom region
        Origin.z = ONFLOORZ;
        LinkToWorld();
        if (fabs(oldFloatZ-Origin.z) >= 10) oldFloatZ = Origin.z;
      }
      FloatBobPhase += DeltaTime;
      if (Sector) Origin.z = GetPointZClamped(ref Sector->floor, Origin)+Special1f+Level.Game.FloatBobOffsets[int(FloatBobPhase*35.0)&63];
    } else {
      // floating bobbing motion for monsters
      float savedz = Origin.z;

      Origin.z -= Level.Game.FloatBobOffsets[int(FloatBobPhase*35.0)&63];
      if (!TestMobjZ()) Origin.z = savedz;
      FloatBobPhase += DeltaTime;

      savedz = Origin.z;
      Origin.z += Level.Game.FloatBobOffsets[int(FloatBobPhase*35.0)&63];
      if (!TestMobjZ()) Origin.z = savedz;
    }

    // interpolation
    float diffz = oldFloatZ-Origin.z;
    if (diffz < 10) tmp_phys_z_change += diffz;
  }

  // k8: thingy bridges should be checked even if we have zero vertical velocity.
  //     the following code looks like optimization attempt, and it introduced a bug:
  //     if a player (or a monster, i think) moved into step-like thing while
  //     standing on a floor, that thing will be ignored. meh, just always check
  //     things, 'cause why not?
  EntityEx onmo = EntityEx(CheckOnmobj());
  if (onmo || Velocity.z ||
      (Origin.z != FloorZ &&
       (!bFloatBob || (!bSpecial && Origin.z-Level.Game.FloatBobOffsets[int(FloatBobPhase*35.0)&63] != FloorZ))))
  {
    if (bPassMobj && !bMissile && !Level.CompatNoPassOver) {
      // handle Z momentum and gravity
      //EntityEx onmo = EntityEx(CheckOnmobj());
      if (onmo && !onmo.bCorpse) {
        if (bIsPlayer) {
          //print("Player is on thing %C", onmo);
          if (Velocity.z < -DEFAULT_GRAVITY*0.25 && !bFly && !bNoGravity) PlayerLandedOnThing();
        }

        if (onmo.Origin.z+onmo.Height-Origin.z <= MaxStepHeight) {
          if (bIsPlayer) {
            PlayerEx pex = PlayerEx(Player);
            if (pex && pex.MO == self) {
              pex.ViewHeight -= onmo.Origin.z+onmo.Height-Origin.z;
              if (PlayerPawn(self)) pex.DeltaViewHeight = (PlayerPawn(self).GetPawnViewHeight-pex.ViewHeight)*4.0;
            }
          }
          Origin.z = onmo.Origin.z+onmo.Height;
        }

        //GZDoom does it here
        onmo.CheckDoBumpSpecial(self);

        bOnMobj = true;
        Velocity.z = 0.0;
        Crash();

        if (onmo.bOnmobjCopyVel) {
          Velocity.x = onmo.Velocity.x;
          Velocity.y = onmo.Velocity.y;
        }

        if (onmo.Origin.z < onmo.FloorZ) {
          Origin.z += onmo.FloorZ-onmo.Origin.z;
          if (onmo.bIsPlayer) {
            PlayerEx pex = PlayerEx(onmo.Player);
            if (pex && pex.MO == onmo) {
              pex.ViewHeight -= onmo.FloorZ-onmo.Origin.z;
              if (PlayerPawn(onmo)) pex.DeltaViewHeight = (PlayerPawn(onmo).GetPawnViewHeight-pex.ViewHeight)*4.0;
            }
          }
          onmo.Origin.z = onmo.FloorZ;
        }
      } else {
        ZMovement(DeltaTime, oldfloorz);
        bOnMobj = false;
      }
      if (IsDestroyed) return false; // entity was removed
    } else {
      // handle Z momentum and gravity
      ZMovement(DeltaTime, oldfloorz);
      if (IsDestroyed) return false; // entity was removed
    }
  }

  if (bStickToFloor || bStickToCeiling) {
    tmtrace_t tmtrace;
    GetFloorAndCeiling(out tmtrace);
    // no need to relink for z change
    Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
    bIntrJustMoved = false; // disable movement interpolation
  }

  // move static light, if there is any
  if (/*bStaticLight &&*/ bStaticLightSpawned) {
    Level.MoveStaticLightByOwner(self, Origin+LightOffset);
  }

  // apply friction here
  //if (Velocity.x || Velocity.y) ApplyFriction(DeltaTime);
  return true;
}


//==========================================================================
//
//  PerformSectorWindThrust
//
//==========================================================================
final bool PerformSectorWindThrust (float DeltaTime, sector_t *sector) {
  int special = sector->special&SECSPEC_BASE_MASK;
  switch (special) {
    case SECSPEC_WindEastSlow:
    case SECSPEC_WindEastMedium:
    case SECSPEC_WindEastFast:
      //printdebug("    EAST");
      Thrust(0.0, LineSpecialGameInfo(Level.Game).windTab[special-SECSPEC_WindEastSlow]*DeltaTime*35.0);
      return true;
    case SECSPEC_WindNorthSlow:
    case SECSPEC_WindNorthMedium:
    case SECSPEC_WindNorthFast:
      //printdebug("    NORTH");
      Thrust(90.0, LineSpecialGameInfo(Level.Game).windTab[special-SECSPEC_WindNorthSlow]*DeltaTime*35.0);
      return true;
    case SECSPEC_WindSouthSlow:
    case SECSPEC_WindSouthMedium:
    case SECSPEC_WindSouthFast:
      //printdebug("    SOUTH");
      Thrust(270.0, LineSpecialGameInfo(Level.Game).windTab[special-SECSPEC_WindSouthSlow]*DeltaTime*35.0);
      return true;
    case SECSPEC_WindWestSlow:
    case SECSPEC_WindWestMedium:
    case SECSPEC_WindWestFast:
      //printdebug("    WEST");
      Thrust(180.0, LineSpecialGameInfo(Level.Game).windTab[special-SECSPEC_WindWestSlow]*DeltaTime*35.0);
      return true;
  }
  return false;
}


//==========================================================================
//
//  XYMovement
//
//  returns old floor z
//
//==========================================================================
final float XYMovement (float DeltaTime, float ScrollX, float ScrollY) {
  float oldfloorz = FloorZ;

  if (bWindThrust && Sector) {
    #if 0
    // check winds for all touching sectors?
    for (msecnode_t *mnode = TouchingSectorList; mnode; mnode = mnode.TNext) {
      sector_t *sec = mnode.Sector;
      if (sec->special&SECSPEC_BASE_MASK) {
        PerformSectorWindThrust(DeltaTime, sec);
      }
    }
    #else
    if (Sector->special&SECSPEC_BASE_MASK) PerformSectorWindThrust(DeltaTime, Sector);
    #endif
  }

  //if (self isa 'DH_GaussBall') printdebug("%C: 000 (max=%s): %s  %s", self, MAXMOVE, Velocity, Normalise(Velocity));
  //k8: no need to do this (i hope)
  //Velocity = vclampscale(Velocity, MAXMOVE);
  //if (self isa 'DH_GaussBall') printdebug("%C: 001 (max=%s): %s  %s", self, MAXMOVE, Velocity, Normalise(Velocity));

  float xmove = Velocity.x*DeltaTime;
  float ymove = Velocity.y*DeltaTime;
  bool forceSlide = false;
  bool absoluteSlide = true;

  if (ScrollX || ScrollY) {
    forceSlide = true;
    //if (bIsPlayer) printdebug("%C: 00: scroll=%s : %s ; vel=%s", self, ScrollX, ScrollY, Velocity);
    // scroll is already deltatime-corrected
    /*
    print("%C: scroll=(%s,%s); cst=%s; newscroll=(%s,%s); deltav=(%s,%s); v=%s; ss=%s", self, ScrollX, ScrollY, CARRYSTOPSPEED*DeltaTime,
      ScrollX*(CARRYFACTOR*DeltaTime), ScrollY*(CARRYFACTOR*DeltaTime),
      ScrollX/DeltaTime, ScrollY/DeltaTime, Velocity, STOPSPEED);
    */

    // Carrying sectors didn't work with low speeds in BOOM. This is because
    // BOOM relied on the speed being fast enough to accumulate despite
    // friction. If the speed is too low, then its movement will get
    // cancelled, and it won't accumulate to the desired speed.
    if (!GetCvarB('sv_transporters_absolute')) {
      absoluteSlide = false;
      float CarryStopSpeed = CARRYSTOPSPEED*DeltaTime;
      if (fabs(ScrollX) > CarryStopSpeed) {
        ScrollX *= CARRYFACTOR*DeltaTime;
        Velocity.x += ScrollX/DeltaTime;
      }
      if (fabs(ScrollY) > CarryStopSpeed) {
        ScrollY *= CARRYFACTOR*DeltaTime;
        Velocity.y += ScrollY/DeltaTime;
      }
      //print("   nv=%s", Velocity);
    }

    //if (bIsPlayer) printdebug("%C: 01: scroll=%s : %s ; vel=%s", self, ScrollX, ScrollY, Velocity);
    xmove += ScrollX;
    ymove += ScrollY;
  }

  if (!xmove && !ymove) {
    if (bSkullFly) {
      // a flying mobj slammed into something
      bSkullFly = false;
      Velocity = vector(0.0, 0.0, 0.0);
      if (Health > 0) SetState(SeeState ? SeeState : IdleState);
    } else if (bBlasted) {
      // reset to not blasted when momentums are gone
      ResetBlasted();
    }
    if (bTouchy && !IsSentient()) {
      // arm a mine which has come to rest
      bArmed = true;
    }
    return oldfloorz;
  }

  // split move in multiple steps if moving too fast
  int Steps = 1;
  float XStep = fabs(xmove);
  float YStep = fabs(ymove);
  float MaxStep = Radius-1.0;

  if (MaxStep <= 0.0) MaxStep = MAXMOVESTEP;

  if (XStep > MaxStep || YStep > MaxStep) {
    if (XStep > YStep) {
      Steps = int(XStep/MaxStep)+1;
    } else {
      Steps = int(YStep/MaxStep)+1;
    }
  }

  float StepXMove = xmove/float(Steps);
  float StepYMove = ymove/float(Steps);

  //int Step = 1;
  TVec oldOrigin = Origin;
  foreach (; 0..Steps) {
    float ptryx = Origin.x+StepXMove;
    float ptryy = Origin.y+StepYMove;

    tmtrace_t tmtrace;
    if (!bNoInteraction && !TryMoveEx(&tmtrace, vector(ptryx, ptryy, Origin.z), AllowDropOff:true)) {
      // blocked move
      if (DecalName && (bDecals2SPass || bDecalsOnly2S)) {
        //print("tracing decal '%s' (hit)", DecalName);
        TVec spdir = Velocity.normalise();
        float spdist = length(Origin-oldOrigin);
        TraceSplat(oldOrigin, spdir, spdist, tr:nullptr, zofs:0, DecalName:DecalName, pass2S:bDecals2SPass, only2S:bDecalsOnly2S, translation:(bCopyBloodTranslation ? Translation : 0));
      }
      if (tmtrace.BlockingMobj) {
        //if (GetCvarB('k8ExplodeMissleTest')) print("MOBJ!");
        HitMobj(tmtrace.BlockingMobj, ptryx, ptryy);
      } else {
        /*
        if (GetCvarB('k8ExplodeMissleTest')) {
          print("LINE! (%d)", tmtrace.SpecHit.Length);
          if (!tmtrace.BlockingLine) print("*** BUT NO LINE!");
          if (!tmtrace.AnyBlockingLine) print("*** BUT NO ANY-LINE!");
          if (!tmtrace.AnyBlockingLine) {
            if (tmtrace.CeilingLine) print("      CEILING LINE IS HERE!");
            if (tmtrace.FloorLine) print("      FLOOR LINE IS HERE!");
            if (tmtrace.CeilingLine == tmtrace.FloorLine && tmtrace.FloorLine) print("      FLOOR AND CEILING LINE IS THE SAME!");
          }
        }
        */
        /*
        if (!tmtrace.BlockingLine && !tmtrace.AnyBlockingLine) {
          tmtrace_t tr2;
          if (CheckRelPosition(&tr2, vector(ptryx, ptryy, Origin.z))) {
            print("second trace returned TRUE!: l:%s; al:%s", (tr2.BlockingLine ? "tan" : "ona"), (tr2.AnyBlockingLine ? "tan" : "ona"));
          } else {
            print("second trace returned FALSE!: l:%s; al:%s", (tr2.BlockingLine ? "tan" : "ona"), (tr2.AnyBlockingLine ? "tan" : "ona"));
          }
        }
        */
        if (forceSlide) {
          if (absoluteSlide) {
            //k8: this is absolutely wrong! but without this, idiotic Boom transporters won't make objects slide
            /*
            TVec oldvel = Velocity;
            TVec scvel = vector(ScrollX/DeltaTime, ScrollY/DeltaTime);
            Velocity += scvel;
            //if (bIsPlayer) printdebug("%C: 00: scvel=%s; oldvel=%s; newVelocity=%s", self, scvel, oldvel, Velocity);
            HitLine(&tmtrace, DeltaTime/float(Steps), true);
            //if (bIsPlayer) printdebug("%C: 01: scvel=%s; oldvel=%s; newVelocity=%s", self, scvel, oldvel, Velocity);
            Velocity -= scvel;
            //if (bIsPlayer) printdebug("%C: 02: scvel=%s; oldvel=%s; newVelocity=%s", self, scvel, oldvel, Velocity);
            // don't thrust back
            if (fsign(Velocity.x) != fsign(oldvel.x)) Velocity.x = 0;
            if (fsign(Velocity.y) != fsign(oldvel.y)) Velocity.y = 0;
            //if (bIsPlayer) printdebug("%C: 03: scvel=%s; oldvel=%s; newVelocity=%s", self, scvel, oldvel, Velocity);
            */
            tmp_transporter_velocity = vector(ScrollX/DeltaTime, ScrollY/DeltaTime);
            HitLine(&tmtrace, DeltaTime/float(Steps), true);
          } else {
            tmp_transporter_velocity = vector(0, 0, 0);
            HitLine(&tmtrace, DeltaTime/float(Steps), true);
          }
        } else {
          HitLine(&tmtrace, DeltaTime/float(Steps), false);
        }
      }
      return oldfloorz;
    }
  } //while (Step++ < Steps);

  if (DecalName && (bDecals2SPass || bDecalsOnly2S)) {
    //print("tracing decal '%s' (pass)", DecalName);
    TVec spdir = Velocity.normalise();
    float spdist = length(Origin-oldOrigin);
    TraceSplat(oldOrigin, spdir, spdist, tr:nullptr, zofs:0, DecalName:DecalName, pass2S:bDecals2SPass, only2S:bDecalsOnly2S, translation:(bCopyBloodTranslation ? Translation : 0));
  }

  return oldfloorz;
}


//==========================================================================
//
//  ZMovement
//
//==========================================================================
final void ZMovement (float DeltaTime, float OldFloorZ) {
  float oldz = Origin.z;

  //Mass = (Mass.isinf ? 10000 : fclamp(Mass, 0, 10000)); // done in C++ code

  // [RH] Double gravity only if running off a ledge. Coming down from
  // an upward thrust (e.g. a jump) should not double it.
  // Make objects fall to their own weight.
  if (oldz > FloorZ && !bNoGravity && Sector) {
    float grav = (Gravity*Level.Gravity*(WaterLevel < 2 ? Sector->Gravity : Sector->Gravity/10.0))/1.220703125; // 9.8 (1053.52)
    if (grav.isinf) grav = 1000;
    //float xmass = (Mass.isinf ? 10000.0 : fmax(1, Mass));
    float xmass = fmax(1, Mass);
    //print("WL=%s; grav=%s; Gravity=%s, LGravity=%s; SGravity=%s; mass=%s; vz=%s", WaterLevel, grav, Gravity, Level.Gravity, Sector->Gravity, xmass, Velocity.z);

    if (Velocity.z == 0.0 && OldFloorZ > FloorZ && oldz == OldFloorZ) {
      if (WaterLevel < 2) {
        Velocity.z -= ((grav+grav)/xmass)*DeltaTime;
      } else {
        Velocity.z -= (((grav+grav)/10.0)/xmass)*DeltaTime;
      }
    } else {
      if (WaterLevel < 2) {
        Velocity.z -= (grav/xmass)*DeltaTime;
      } else {
        Velocity.z -= ((grav/10.0)/xmass)*DeltaTime;
      }
    }
  }

  // check for smooth step up
  if (bIsPlayer && oldz < FloorZ) {
    PlayerEx pex = PlayerEx(Player);
    if (pex && pex.MO == self) {
      float dfz = FloorZ-oldz;
      // arbitrary number
      if (dfz > 0.6 || EFloor.spGetNormalZ == 1.0) {
        pex.ViewHeight -= dfz;
        pex.DeltaViewHeight = (PlayerPawn(self).GetPawnViewHeight-pex.ViewHeight)*4.0;
        //if (EFloor.spGetNormalZ != 1.0) print("FUCK1! z=%s; fz=%s; sfz=(%s:%s); dfz=%s", oldz, FloorZ, Sector.floor.minz, Sector.floor.maxz, dfz);
      } else {
        //print("FUCK0! z=%s; fz=%s; sfz=(%s:%s); dfz=%s", oldz, FloorZ, Sector.floor.minz, Sector.floor.maxz, dfz);
      }
    }
  }

  // adjust height
  if (!bFloatBob) Origin.z += Velocity.z*DeltaTime;
  float origz = Origin.z;

  if (bFloat && !bDormant && Target) {
    // float down towards enemy if too close
    if (!bSkullFly && !bInFloat) {
      float dist = DistTo2(Target);
      float delta = Target.Origin.z+Height/2.0-origz;
      if (delta < 0.0 && dist < -(delta*3.0)) {
        Velocity.z = 0.0;
        EntityEx onmo = EntityEx(CheckOnmobj());
        if (((onmo && onmo.TestMobjZ()) || !onmo) && TestMobjZ()) {
          Origin.z -= FloatSpeed*DeltaTime;
        } else {
          return;
        }
      } else if (delta > 0.0 && dist < delta*3.0) {
        Velocity.z = 0.0;
        EntityEx onmo = EntityEx(CheckOnmobj());
        if (((onmo && onmo.TestMobjZ()) || !onmo) && TestMobjZ()) {
          Origin.z += FloatSpeed*DeltaTime;
        } else {
          return;
        }
      }
      origz = Origin.z;
    }
  }

  if (bIsPlayer && bFly && origz > FloorZ /*&& (XLevel.TicTime&2)*/) {
    //FIXME: this is time-dependent, rewrite!
    //Origin.z += sin(90.0*35.0/20.0*AngleMod360(int(XLevel.Time)))/2.0;
    auto plx = PlayerEx(Player);
    if (plx && !(plx.Cheats&PlayerEx::CF_NOCLIP)) {
      Origin.z = plx.CalcFlyZ(Origin.z);
      origz = Origin.z;
    }
  }

  // clip movement
  if (!bNoInteraction) {
    if (origz <= FloorZ+0.1) {
      // hit the floor
      if (!HitFloor(oldz)) return;
    }

    if (origz+Height > CeilingZ) {
      // hit the ceiling
      if (!HitCeiling(oldz)) return;
    }

    CheckFakeFloorTriggers(oldz);
  }
}


//==========================================================================
//
//  HitLine
//
//  if entity is moving with transporter, it should slide along walls
//  in any case
//
//==========================================================================
final void HitLine (tmtrace_t *tmtrace, float StepVelScale, bool forceSlide) {
  if (bMissile) {
    if (bBounceWalls || BounceType == BOUNCE_Doom || BounceType == BOUNCE_Hexen) {
      // if number of bounces is limited
      if (BounceCount > 0 && --BounceCount <= 0) {
        ExplodeMissile(none, line:(tmtrace ? tmtrace.BlockingLine : nullptr));
        return;
      }

      // explode a missile
      if (tmtrace->CeilingLine && tmtrace->CeilingLine->backsector &&
          tmtrace->CeilingLine->backsector->ceiling.pic == Level.Game.skyflatnum)
      {
        // hack to prevent missiles exploding against the sky
        // does not handle sky floors
        float pf = tmtrace->CeilingLine->frontsector->floor.maxz;
        float pb = tmtrace->CeilingLine->backsector->floor.maxz;
        bool hitsky = true;
        if (pf != pb) {
          int siden = PointOnPlaneSide(Origin-Velocity*2, ref *tmtrace->CeilingLine);
          if (!siden) {
            hitsky = (pf < pb && tmtrace.End.z > pb);
          } else {
            hitsky = (pb < pf && tmtrace.End.z > pf);
          }
        }
        if (hitsky) {
               if (bBounceSky) Velocity = vector(0.0, 0.0, -1.0*35.0);
          else if (bExplodeOnSky) ExplodeMissile(none);
          else Destroy();
          return;
        }
      }

      if (tmtrace->BlockingLine && tmtrace->BlockingLine->special == LNSPEC_LineHorizon) {
        SightSound = '';
        Destroy();
        return;
      }

      // struck a wall
      if (bBounceWalls || BounceType == BOUNCE_Doom || BounceType == BOUNCE_Hexen) {
        BounceWall(BOUNCE_VAL, WallBounceFactor);
        if (!bNoBounceSound && !bNoWallBounceSnd && (BounceSound || SightSound)) {
          PlaySound((BounceSound ? BounceSound : SightSound), CHAN_VOICE);
        }
      }
      return;
    }

    // explode a missile
    if (tmtrace->CeilingLine && tmtrace->CeilingLine->backsector &&
        tmtrace->CeilingLine->backsector->ceiling.pic == Level.Game.skyflatnum)
    {
      // hack to prevent missiles exploding against the sky
      // does not handle sky floors
      float pf = tmtrace->CeilingLine->frontsector->floor.maxz;
      float pb = tmtrace->CeilingLine->backsector->floor.maxz;
      bool hitsky = true;
      if (pf != pb) {
        int siden = PointOnPlaneSide(Origin-Velocity*2, ref *tmtrace->CeilingLine);
        if (!siden) {
          hitsky = (pf < pb && tmtrace.End.z > pb);
        } else {
          hitsky = (pb < pf && tmtrace.End.z > pf);
        }
      }
      if (hitsky) {
             if (bBounceSky) Velocity = vector(0.0, 0.0, -1.0*35.0);
        else if (bExplodeOnSky) ExplodeMissile(none);
        else Destroy();
        return;
      }
    }

    if (tmtrace->BlockingLine && tmtrace->BlockingLine->special == LNSPEC_LineHorizon) {
      if (bBounceSky) Velocity = vector(0.0, 0.0, -1.0*35.0); else Destroy();
      return;
    }

    line_t *hitline = tmtrace->BlockingLine;
    if (!hitline) hitline = tmtrace->CeilingLine;
    if (!hitline) hitline = tmtrace->FloorLine;
    if (!hitline) hitline = tmtrace->AnyBlockingLine; //k8: nope; this was my hack, and it is wrong here
    if (!hitline && tmtrace->SpecHit.Length) {
      bool wasBlockAll = false;
      line_t *blockall;
      foreach (int f; 0..tmtrace->SpecHit.Length) {
        line_t *ln = tmtrace->SpecHit[f];
        if (ln->flags&ML_BLOCKING) { hitline = ln; break; }
        if (!wasBlockAll && (ln->flags&ML_BLOCKEVERYTHING) != 0) { blockall = ln; wasBlockAll = true; }
      }
      if (!hitline) {
        if (wasBlockAll) hitline = blockall; else hitline = tmtrace->SpecHit[0];
      }
    }

    // wtf?!
    if (!hitline) {
      //printwarn("missile '%C' get to `HitLine` without a blocking line; THIS IS ENGINE BUG!!!", self);
      Destroy();
      return;
    }

    // just in case, again
    if (hitline->special == LNSPEC_LineHorizon) {
      if (bBounceSky) Velocity = vector(0.0, 0.0, -1.0*35.0); else Destroy();
      return;
    }

    ExplodeMissile(none, hitline);
  } else if (bSlide || forceSlide) {
    // try to slide for transporter
    if (forceSlide) {
      if (tmp_transporter_velocity) {
        TVec oldvel = Velocity;
        Velocity = tmp_transporter_velocity;
        SlideMove(StepVelScale);
        Velocity = oldvel;
      }
    }
    // try to slide with the original velocity
    SlideMove(StepVelScale);
  } else {
    Velocity.x = 0.0;
    Velocity.y = 0.0;
  }
}


//==========================================================================
//
//  HitMobj
//
//==========================================================================
final void HitMobj (Entity Other, float ptryx, float ptryy) {
  float angle;
  float speed;
  float sina, cosa;

  if (bMissile) {
    EntityEx otherEnt = EntityEx(Other);

    if (bBounceOnActors || bBounceOnAllActors || BounceType == BOUNCE_Doom || BounceType == BOUNCE_Hexen) {
      // if number of bounces is limited
      if (BounceCount > 0 && --BounceCount <= 0) {
        ExplodeMissile(none);
        return;
      }

      // bounce against walls and non-killable objects
      //if ((bBounceOnActors || otherEnt.bReflective || (!Other.bIsPlayer && !otherEnt.bMonster) || !otherEnt.IsSentient()) ||
      //    otherEnt.bBounceOnAllActors)
      if (bBounceOnAllActors ||
          //k8: no, GZDoom doesn't check this:otherEnt.bBounceOnAllActors || /* other is absolutely bounceable */
          (!Other.bIsPlayer && !otherEnt.bMonster) || /* not a player, and not a monster */
          !otherEnt.IsSentient() || /* non-sentient monster */
          /* ripper checks (only for reflective monsters; dunno, GZDoom does it like this) */
          (otherEnt.bReflective && (!bRip || !otherEnt.bDontRip || (bNoBossRip && otherEnt.bBoss))))
      {
        //printwarn("%C: BOUNCE! actb=%B; allactb=%B; other=%C; refl=%B, sent=%B", self, bBounceOnActors, bBounceOnAllActors, otherEnt, otherEnt.bReflective, otherEnt.IsSentient());
        //printwarn("    ooball=%B", otherEnt.bBounceOnAllActors);
        angle = AngleMod360(atan2(Origin.y-Other.Origin.y, Origin.x-Other.Origin.x)+(Random()*16.0-8.0));
        speed = Length(Velocity)*WallBounceFactor;
        Angles.yaw = angle;
        sincos(angle, out sina, out cosa);
        Velocity.x = speed*cosa;
        Velocity.y = speed*sina;
        if (!bNoBounceSound && (BounceSound || SightSound)) {
          PlaySound(BounceSound ? BounceSound : SightSound, CHAN_VOICE);
        }
      } else {
        // struck a player/creature
        //printwarn("%C: EXPLODE!", self);
        ExplodeMissile(otherEnt);
      }
      return;
    }

    if (otherEnt.bReflective) {
      angle = otherEnt.GetReflectedAngle(self);
      if (angle != -1.0) {
        // reflect the missile along angle
        Angles.yaw = angle;
        sincos(angle, out sina, out cosa);
        Velocity.x = (Speed/2.0)*cosa;
        Velocity.y = (Speed/2.0)*sina;
        Velocity.z = -Velocity.z*0.5;
        if (bSeekerMissile) Tracer = Target;
        Target = otherEnt;
        return;
      }
    }

    // explode a missile
    ExplodeMissile(otherEnt);
  } else if (bSlide) {
    // try to slide along it
    // slide against mobj
         if (TryMove(vector(Origin.x, ptryy, Origin.z), AllowDropOff:true)) Velocity.x = 0.0;
    else if (TryMove(vector(ptryx, Origin.y, Origin.z), AllowDropOff:true)) Velocity.y = 0.0;
    else { Velocity.x = 0.0; Velocity.y = 0.0; }
  } else {
    Velocity.x = 0.0;
    Velocity.y = 0.0;
  }
}


//==========================================================================
//
//  HitFloor
//
//==========================================================================
final bool HitFloor (float prevz) {
  // trigger hit floor sector actions
  if (Sector && Sector->ActionList && GetPointZClamped(ref Sector->floor, Origin) == FloorZ) {
    SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_HitFloor);
  }

  // killough 11/98: touchy objects explode on impact
  // allow very short drops to be safe, so that a touchy can be summoned without exploding
  if (bTouchy && (bArmed || IsSentient()) && Velocity.z < -5.0) {
    bArmed = false; // disarm
    Damage(none, none, Health, spawnBlood:true);  // kill object
    return true;
  }

  bool justLanded = (prevz > FloorZ);

  if (bMissile && (bColideWithWorld || !LineSpecialGameInfo(Level.Game).bNoClipIgnoreFloor)) {
    // physics caller will setup interpolation with `tmp_phys_z_change`
    // if we have no velocity, don't bother interpolating
    if (Velocity.xy && Origin.z > FloorZ) tmp_phys_z_change += FloorZ-Origin.z;
    Origin.z = FloorZ;
    if (bBounceFloors || BounceType != BOUNCE_None) {
      FloorBounceMissile();
      return false;
    }
    if (bNoExplodeFloor) {
      // the spirit struck the ground
      Velocity.z = 0.0;
      HitFloorType(justLanded);
      return false;
    }
    if (bIgnoreFloorStep) {
      // minotaur floor fire can go up steps
      return false;
    }
    HitFloorType(justLanded);
    ExplodeMissile(none);
    return false;
  }

  float vdot = DotProduct(Velocity, EFloor.spGetNormal());
  if (bMonster) {
    // blasted mobj falling
    if (vdot < -23.0*35.0) MonsterFallingDamage();
  }

  // physics caller will setup interpolation with `tmp_phys_z_change`
  //if ((self isa 'LifeEssence') || (self isa 'ZombieMan')) print("%C: myz=%s; floorz=%s; fz-mz=%s (tzc=%s)", self, Origin.z, FloorZ, FloorZ-Origin.z, tmp_phys_z_change);
  // if we have no velocity, don't bother interpolating
  if (Velocity.xy && Origin.z > FloorZ) tmp_phys_z_change += FloorZ-Origin.z;
  Origin.z = FloorZ;

  if (vdot < -0.1) {
    // spawn splashes, etc
    //if (bIsPlayer) printdebug("000: %C: Velocity=%s; vdot=%s", self, Velocity, vdot);
    // do not spawn excessive splashes if not moving
    HitFloorType(justLanded);
    if (!Inventory(self) && nameicmp(DamageType, 'Ice') == 0 && vdot < -DEFAULT_GRAVITY*0.25) {
      StateTime = 0.1;
      //Velocity = vector(0.0, 0.0, 0.0);
      Velocity.z = 0.0;
      return false;
    }
    if (bCanJump) JumpTime = 0.5; // delay any jumping for a short time
    // do some special action when hitting the floor
    OnHitFloor();
    if (bIsPlayer) {
      PlayerEx(Player).JumpTime = 0.2; // delay any jumping for a short time
      if (vdot < -DEFAULT_GRAVITY*0.25 && !bNoGravity) {
        // squat down
        // decrease ViewHeight for a moment after hitting the ground (hard), and utter appropriate sound
        PlayerLandedOnThing();
      }
    }
    TVec Vel = vdot*EFloor.spGetNormal();
    Velocity.z -= Vel.z;
    //if (bIsPlayer) printdebug("001: %C: Velocity=%s; vdot=%s", self, Velocity, vdot);
  }
  /*
  else {
    if (bIsPlayer) printdebug("***: %C: Velocity=%s; vdot=%s", self, Velocity, vdot);
  }
  */

  if (bSkullFly) {
    // the skull slammed into something
    Velocity.z = -Velocity.z;
  }

  Crash();
  return true;
}


//==========================================================================
//
//  HitCeiling
//
//==========================================================================
final bool HitCeiling (float prevz) {
  // trigger hit ceiling sector actions
  if (Sector && Sector->ActionList && GetPointZClamped(ref Sector->ceiling, Origin) == CeilingZ) {
    SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_HitCeiling);
  }

  // physics caller will setup interpolation with `tmp_phys_z_change`
  // if we have no velocity, don't bother interpolating
  if (Velocity.xy) tmp_phys_z_change += (CeilingZ-Height)-Origin.z;
  Origin.z = CeilingZ-Height;

  if (bMissile && (bColideWithWorld || !LineSpecialGameInfo(Level.Game).bNoClipIgnoreFloor)) {
    if (bBounceCeilings || BounceType != BOUNCE_None) {
      CeilingBounceMissile();
      return false;
    }
    if (bIgnoreCeilingStep) return false;
    if (ECeiling.splane->pic == Level.Game.skyflatnum) {
           if (bBounceSky) Velocity = vector(0.0, 0.0, -1.0*35.0);
      else if (bExplodeOnSky) ExplodeMissile(none);
      else Destroy();
      return false;
    }
    ExplodeMissile(none);
    return false;
  }

  float vdot = DotProduct(Velocity, ECeiling.spGetNormal());

  if (vdot < 0.0) {
    TVec Vel = vdot*ECeiling.spGetNormal();
    Velocity.z -= Vel.z;
  }

  if (bSkullFly) {
    // the skull slammed into something
    Velocity.z = -Velocity.z;
  }

  return true;
}


//==========================================================================
//
//  TurnOffAllBouncingFlags
//
//==========================================================================
void TurnOffAllBouncingFlags () {
  bBounceWalls = false;
  bBounceFloors = false;
  bBounceCeilings = false;
  bBounceOnActors = false;
  bBounceOnAllActors = false;
}


//==========================================================================
//
//  FloorBounceMissile
//
//==========================================================================
void FloorBounceMissile () {
  float vdot;

  if (HitFloorType()) {
    // landed on some kind of liquid
    if (bExplodeOnWater) {
      ExplodeMissile(none);
      return;
    }
    if (!bCanBounceWater) {
      Destroy();
      return;
    }
  }

  // if number of bounces is limited
  if (BounceCount > 0 && --BounceCount <= 0) {
    ExplodeMissile(none);
    return;
  }

  vdot = DotProduct(Velocity, EFloor.spGetNormal());

  if (bBounceLikeHeretic || (BounceType == BOUNCE_Heretic && !bMBFBounce)) {
    Velocity -= 2.0*(vdot*EFloor.spGetNormal());
    Angles.yaw = atan2(Velocity.y, Velocity.x);
    SetState(FindState('Death'));
    return;
  }

  if (bMBFBounce) {
    Velocity = Velocity-(2.0*(vdot*EFloor.spGetNormal()));
    Velocity.z = Velocity.z*BounceFactor;
    Angles.yaw = atan2(Velocity.y, Velocity.x);
  } else {
    Velocity = (Velocity-(2.0*(vdot*EFloor.spGetNormal())))*BounceFactor;
    Angles.yaw = atan2(Velocity.y, Velocity.x);
  }

  // put it to rest, or...
  /*if (fabs(Velocity.z) <= 0.1) {
    Velocity.z = 0;
  } else*/ {
    // ...play bounce sound
    if (!bNoBounceSound && (BounceSound || SightSound)) {
      PlaySound(BounceSound ? BounceSound : SightSound, CHAN_VOICE);
    }
  }

  if (bMBFBounce) {
    if (Velocity.z < (fmax(1, Mass)*Gravity)/64.0) {
      // Bring it to rest below a certain speed
      Velocity.z = 0.0;
    }
  }

  //print("%C: bBounceFloors=%B; bBounceAutoOff=%B; bNoGravity=%B; Velocity.z=%s; btype=%s", self, bBounceFloors, bBounceAutoOff, bNoGravity, Velocity.z, BounceType);
  //print("%C: Mass=%s; Gravity=%s; Velocity.z=%s; lim=%s", self, Mass, Gravity, Velocity.z, (Mass*Gravity)/64.0);
  if (bBounceAutoOff || BounceType == BOUNCE_Doom) {
    if (!bNoGravity && Velocity.z < 2.5/*3.0*/*35.0) {
      BounceType = BOUNCE_None;
      TurnOffAllBouncingFlags(); // otherwise it will bounce forever
    }
  }
}


//==========================================================================
//
//  CeilingBounceMissile
//
//==========================================================================
final void CeilingBounceMissile () {
  float vdot;

  // if number of bounces is limited
  if (BounceCount > 0 && --BounceCount <= 0) {
    ExplodeMissile(none);
    return;
  }

  vdot = DotProduct(Velocity, ECeiling.spGetNormal());

  if (bBounceLikeHeretic || (BounceType == BOUNCE_Heretic && !bMBFBounce)) {
    Velocity -= 2.0*(vdot*ECeiling.spGetNormal());
    Angles.yaw = atan2(Velocity.y, Velocity.x);
    SetState(FindState('Death'));
    return;
  }

  // reverse momentum here for ceiling bounce
  if (bMBFBounce) {
    Velocity = Velocity-(2.0*(vdot*ECeiling.spGetNormal()));
    Velocity.z = Velocity.z*BounceFactor;
    Angles.yaw = atan2(Velocity.y, Velocity.x);
  } else {
    Velocity = (Velocity-(2.0*(vdot*ECeiling.spGetNormal())))*BounceFactor;
    Angles.yaw = atan2(Velocity.y, Velocity.x);
  }

  if (!bNoBounceSound && (BounceSound || SightSound)) {
    PlaySound(BounceSound ? BounceSound : SightSound, CHAN_VOICE);
  }

  if (bMBFBounce) {
    if (Velocity.z < (fmax(1, Mass)*Gravity/64.0)) {
      // bring it to rest below a certain speed
      Velocity.z = 0.0;
    }
  }

  if (bBounceAutoOff || BounceType == BOUNCE_Doom) {
    if (!bNoGravity && Velocity.z < 2.5/*3.0*/*35.0) {
      BounceType = BOUNCE_None;
      TurnOffAllBouncingFlags(); // otherwise it will bounce forever
    }
  }
}


//==========================================================================
//
//  GetReflectedAngle
//
//==========================================================================
final float GetReflectedAngle (EntityEx Other) {
  if (Other.bDontReflect) return -1.0;

  float angle = atan2(Other.Origin.y-Origin.y, Other.Origin.x-Origin.x);

  if (bShieldReflect) {
    // change angle for delflection/reflection
    if (fabs(AngleMod180(angle-Angles.yaw)) > 45.0*45.0/32.0) return -1.0;
    if (Other.bDontShieldReflect) return -1.0;
    // deflection
         if (Random() < 0.5) angle = AngleMod360(angle+45.0);
    else angle = AngleMod360(angle-45.0);
    return angle;
  }

  if (bDeflect) {
    // change angle for delflection
         if (Random() < 0.5) angle = AngleMod360(angle+45.0);
    else angle = AngleMod360(angle-45.0);
    return angle;
  }

  // change angle for reflection
  angle = AngleMod360(angle+Random()*16.0-8.0);
  return angle;
}


//==========================================================================
//
//  Crash
//
//==========================================================================
final void Crash () {
  state CrashState = FindState('Crash');
  if (CrashState && bCorpse && DamageType != 'Ice' && !bCrashed) {
    SetState(CrashState);
    bCrashed = true;
  }
}


//===========================================================================
//
//  PlayerLandedOnThing
//
//===========================================================================
final void PlayerLandedOnThing () {
  auto pex = PlayerEx(Player);
  if (pex.MO == self) pex.DeltaViewHeight = Velocity.z/8.0;
  FallingDamage();
  if (Health > 0 && !pex.MorphTime) {
    if (Velocity.z < -DEFAULT_GRAVITY*0.375) {
      PlaySound('*grunt', CHAN_VOICE);
    }
    if ((Origin.z > FloorZ || !GetFloorType()->bLiquid) && !AreSoundsEquivalent('*grunt', '*land')) {
      PlaySound('*land', CHAN_BODY);
    }
  }
  //FIXME Player.centreing = true;
}


//==========================================================================
//
//  FallingDamage
//
//==========================================================================
final void FallingDamage () {
  //print("fdam: %B %B %B", Level.bFallingDamage, Level.bOldFallingDamage, Level.bStrifeFallingDamage);
  int damage;
  float dist;

  if (Sector && Sector->bNoFallingDamage) return;

  float mom = fabs(Velocity.z);

  if (Level.bFallingDamage) {
    // Hexen style falling damage
    if (mom <= 23.0*35.0) return; // not fast enough
    if (mom >= 63.0*35.0) {
      damage = 10000; // automatic death
    } else {
      dist = mom/35.0*16.0/23.0;
      damage = int(dist*dist/10.0)-24;
      if (Velocity.z > -39.0*35.0 && damage > Health && Health != 1) {
        // no-death threshold
        damage = Health-1;
      }
    }
  } else if (Level.bOldFallingDamage) {
    // ZDoom style falling damage, less damaging
    if (mom <= 19.0*35.0) return; // not fast enough
    if (mom >= 84.0*35.0) {
      damage = 10000; // automatic death
    } else {
      mom = mom/35.0;
      damage = (int(mom*mom*11.0/128.0)-30)/2;
      if (damage < 1) damage = 1;
    }
  } else if (Level.bStrifeFallingDamage) {
    // Strife style falling damage, very strong
    if (mom <= 20.0*35.0) return; // not fast enough
    damage = int(mom*(8192.0/3125.0/35.0));
  } else {
    return;
  }

  Damage(none, none, damage, 'Falling', spawnBlood:true);
  LineSpecialLevelInfo(Level).NoiseAlert(self, self);
}


//==========================================================================
//
//  MonsterFallingDamage
//
//==========================================================================
final void MonsterFallingDamage () {
  int damage;
  float mom;

  if (!Level.bMonsterFallingDamage) return;
  if (Sector && Sector->bNoFallingDamage) return;

  mom = fabs(Velocity.z)/35.0;
  if (mom > 35.0) {
    // automatic death
    damage = 10000;
  } else {
    damage = int((mom-23.0)*6.0);
  }
  damage = 10000; // always kill 'em
  Damage(none, none, damage, 'Falling', spawnBlood:true);
}


//==========================================================================
//
//  ResetBlasted
//
//==========================================================================
final void ResetBlasted () {
  bBlasted = false;
  if (!bIceCorpse) bSlide = false;
}


//==========================================================================
//
//  OnHitFloor
//
//==========================================================================
void OnHitFloor () {
}


//==========================================================================
//
//  CheckSplash
//
//  Checks for splashes caused by explosions
//
//==========================================================================
void CheckSplash (float distance) {
  if (Origin.z <= FloorZ+distance) {
    // Explosion splashes never alert monsters. This is because A_Explode has
    // a separate parameter for that so this would get in the way of proper
    // behavior.
    HitFloorType();
  }
}


//==========================================================================
//
//  HitFloorType
//
//==========================================================================
final bool HitFloorType (optional bool justLanded) {
  EntityEx A;
  TVec org;
  bool smallsplash = false;

  if (!Sector || FloorZ != GetPointZClamped(ref Sector->floor, Origin)) {
    // don't splash if landing on the edge above water/lava/etc....
    return false;
  }

  // things that don't splash go here
  if (bFloatBob || bNoSplash) return false;

  VTerrainInfo *TInfo = GetFloorType();

  // small splash for small masses
  if (Mass < 10.0 || bSmallSplash) smallsplash = true;

  if (TInfo->DamageAmount && bIsPlayer && (XLevel.TicTime&TInfo->DamageTimeMask)) {
    Damage(none, none, TInfo->DamageAmount, TInfo->DamageType/*, spawnBlood:true*/);
  }

  VSplashInfo *SInfo = GetSplashInfo(TInfo->Splash);
  if (!SInfo) return TInfo->bLiquid;

  // called from Z movement, perform some checks
  if (specified_justLanded) {
    if (!justLanded) {
      // stayed on the floor; check if it is the same floor
      if (tmp_phys_last_floor_pic == EFloor.splane->pic) {
        // check splash time
        if (tmp_phys_last_splash_time+0.6 > XLevel.Time) {
          // don't splash
          //printdebug("%C: splash time=%s; time=%s", self, tmp_phys_last_splash_time, XLevel.Time);
          return TInfo->bLiquid;
        }
        // check velocity
        if (Velocity.length2DSquared < 6) {
          // don't splash
          return TInfo->bLiquid;
        }
        //printdebug("%C: Velocity=%s (%s)", self, Velocity, Velocity.length2DSquared);
      }
    }
  }

  // remember splash time
  tmp_phys_last_splash_time = XLevel.Time;

  // spawn splash
  org = Origin;
  org.z = FloorZ;

  if (smallsplash) {
    if (SInfo->SmallClass) {
      A = Spawn(class!EntityEx(SInfo->SmallClass), org);
      A.FloorClip += SInfo->SmallClip;
      if (SInfo->SmallSound) A.PlaySound(SInfo->SmallSound, CHAN_SPLASH);
    }
  } else {
    if (SInfo->BaseClass) {
      A = Spawn(class!EntityEx(SInfo->BaseClass), org);
      if (SInfo->Sound && !SInfo->ChunkClass) A.PlaySound(SInfo->Sound, CHAN_SPLASH);
    }
    if (SInfo->ChunkClass) {
      A = Spawn(class!EntityEx(SInfo->ChunkClass), org);
      A.Target = self;
      A.Velocity.x = (Random()-Random())*SInfo->ChunkXVelMul*35.0;
      A.Velocity.y = (Random()-Random())*SInfo->ChunkYVelMul*35.0;
      A.Velocity.z = (SInfo->ChunkBaseZVel+Random()*SInfo->ChunkZVelMul)*35.0;
      if (SInfo->Sound) A.PlaySound(SInfo->Sound, CHAN_SPLASH);
    }
    if (SInfo->Sound && !SInfo->BaseClass && !SInfo->ChunkClass) PlaySound(SInfo->Sound, CHAN_SPLASH);
    if (!SInfo->bNoAlert && bIsPlayer) LineSpecialLevelInfo(Level).NoiseAlert(self, self, true);
  }
  return TInfo->bLiquid;
}


//===========================================================================
//
//  GetFloorType
//
//===========================================================================
final VTerrainInfo *GetFloorType () {
  return TerrainType(EFloor.splane->pic);
}


//==========================================================================
//
//  HandleFloorclip
//
//==========================================================================
override void HandleFloorclip () {
  if (bFloorClip) {
    VTerrainInfo *TInfo = GetFloorType();
    if (Origin.z == FloorZ && TInfo->bLiquid) {
      FloorClip = TInfo->FootClip;
    } else {
      FloorClip = 0.0;
    }
  }
}


//==========================================================================
//
//  ApplyFriction
//
//==========================================================================
override void ApplyFriction (float DeltaTime) {
  if (bMissile || bSkullFly) return; // no friction for missiles ever

  //k8: no, really? no friction while knee-dip in the water? i don't think so
  //    was: `WaterLevel < 2`
  if (Origin.z > FloorZ && !bOnMobj && WaterLevel == 0 && !bFly && !bFallingFriction) {
    // no friction when airborne
    // but do friction on slopes
    /*
    float fzdist = fabs(Sector.floor.maxz-Sector.floor.minz);
    if (fzdist && fzdist <= MaxStepHeight && Origin.z-FloorZ <= MaxStepHeight/3) {
      //TVec Vel = EFloor.spGetNormal();
      //if (!Vel.xy) return; // not a slope
      //float dot = DotProduct(Velocity, Vel);
      //if (dot >= 0.0) return; // bad floor (it seems)
      if (bIsPlayer) {
        tmtrace_t tmtrace;
        GetFloorAndCeilingEx(out tmtrace, Origin, collideWorld:true);
        TVec Vel = EFloor.spGetNormal();
        printdebug("*** SKIP SLOPING! height=%s; vel=%s; dot=%s; vdot=%s; z=%s; cz=%s tz=%s; tfz=%s (%s)", fabs(Sector.floor.maxz-Sector.floor.minz), Vel, DotProduct(Velocity, Vel), Vel*DotProduct(Velocity, Vel),
          Origin.z, EFloor.spGetPointZ(Origin), tmtrace.FloorZ, tmtrace.EFloor.spGetPointZ(Origin), (Origin.z-tmtrace.EFloor.spGetPointZ(Origin)));
        if (tmtrace.FloorLine) printdebug("  HAS FLOOR LINE!");
        float dot = DotProduct(Velocity, Vel);
        if (dot < 0.0) {
          Vel *= dot*0.5;
          Velocity -= Vel.xy;
        }
      }
      return;
    } else
    */
    {
      //print("AIRBORNE!");
      return;
    }
  }

  // vanilla hack: floor with height -32768 teleports entity to ceiling
  if (bIsPlayer && /*Sector &&*/ Sector.floor.maxz <= -32768) {
    if (Origin.z <= -32768) {
      //print("!!!! z=%s; fz=%s %C : %s", Origin.z, FloorZ, self, self.UniqueId);
      bIntrJustMoved = false; // don't interpolate
      Origin.z = Sector.ceiling.minz-Height;
      // find out new floor plane
      if (Sector.bHasExtrafloors) GetFloorAndCeiling(nullptr);
      Origin.z = CeilingZ-Height;
      Velocity.z = 0;
    }
    return; // assume airborne
  }

  // clip velocity on sloped floors
  // TODO: don't clip on small slopes
  // implementation: don't clip if slope is less or equal to maximum allowed step height
  // this will allow to easily climb onto small steep slopes (see "ma_put", for example)
  if (Origin.z <= FloorZ && fabs(Sector.floor.maxz-Sector.floor.minz) > MaxStepHeight) {
    TVec Vel = EFloor.spGetNormal();
    if (bIsPlayer && PlayerEx(Player) && (PlayerEx(Player).Cheats&PlayerEx::CF_NOCLIP)) {
      //print("noclip cheat!");
      Vel = vector(0, 0, 0);
    }
    if (Vel.xy) {
      float dot = DotProduct(Velocity, Vel);
      if (dot < 0.0) {
        //TVec Vel = dot*EFloor.spGetNormal();
        Vel *= dot;
        //print("mht=%s; hgt=%s", MaxStepHeight, Sector.floor.maxz-Sector.floor.minz);
        /*
        print("vv: Vel=%s; dot=%s; norm=%s", Vel, dot, EFloor.spGetNormal());
        print("  : z=%s; fminz=%s; fmaxz=%s", Origin.z, Sector.floor.minz, Sector.floor.maxz);
        print("  : velocity: %s -- %s", Velocity, Velocity-Vel.xy);
        */
        Velocity -= Vel.xy;
      }
    }
  } else {
    /*
    if (bIsPlayer && Origin.z <= FloorZ && fabs(Sector.floor.maxz-Sector.floor.minz) && fabs(Sector.floor.maxz-Sector.floor.minz) <= MaxStepHeight) {
      TVec Vel = EFloor.spGetNormal();
      printdebug("SKIP SLOPING! height=%s; vel=%s; dot=%s; vdot=%s; z=%s : %s", fabs(Sector.floor.maxz-Sector.floor.minz), Vel, DotProduct(Velocity, Vel), Vel*DotProduct(Velocity, Vel),
        Origin.z, EFloor.spGetPointZ(Origin));
    }
    */
  }

  float vx = Velocity.x;
  float vy = Velocity.y;

  if (bCorpse) {
    // don't stop sliding if halfway off a step with some momentum
    if (vx > 0.25*35.0 || vx < -0.25*35.0 ||
        vy > 0.25*35.0 || vy < -0.25*35.0)
    {
      if ((/*Sector &&*/ FloorZ > GetPointZClamped(ref Sector->floor, Origin)) || DropOffZ != FloorZ) {
        return;
      }
    }
  }

  if (fabs(vx) < STOPSPEED && fabs(vy) < STOPSPEED &&
      (!bIsPlayer || (Player.MO == self && !Player.ForwardMove && !Player.SideMove)))
  {
    if (bIsPlayer) {
      // if in a walking frame, stop moving
      if (StateIsInRange(State, SeeState, none, 4)) SetState(IdleState);
    }
    Velocity.x = 0.0;
    Velocity.y = 0.0;
  } else {
    // slow down
    TVec vdiff = Velocity.xy*(GetFriction()*DeltaTime);
    Velocity -= vdiff;
    //Velocity.x -= Velocity.x*(GetFriction()*DeltaTime);
    //Velocity.y -= Velocity.y*(GetFriction()*DeltaTime);
    // roughly smaller than lowest fixed point 16.16 (it is more like 0.0000152587890625)
    if (fabs(Velocity.x) < 0.000016) Velocity.x = 0;
    if (fabs(Velocity.y) < 0.000016) Velocity.y = 0;
    //k8: do we need this for Voodoo Dolls?
    if (bIsPlayer && !Velocity.xy) {
      // if in a walking frame, stop moving
      if (StateIsInRange(State, SeeState, none, 4)) SetState(IdleState);
    }
  }
}


//===========================================================================
//
//  GetFriction
//
//===========================================================================
final float GetFriction () {
  if (WaterLevel > 1) return FRICTION_WATER;
  if (bFly && Origin.z > FloorZ && !bOnMobj) return FRICTION_FLY;
  if (Sector && (Sector->special&SECSPEC_BASE_MASK) == SECSPEC_FrictionLow) return FRICTION_LOW;
  VTerrainInfo *TInfo = GetFloorType();
  if (TInfo && TInfo->Friction) return TInfo->Friction;
  if (Sector && (Sector->special&SECSPEC_FRICTION_MASK)) return Sector->Friction;
  return FRICTION_NORMAL;
}
