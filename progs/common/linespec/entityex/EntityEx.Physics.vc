//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//
//  Object movement
//
//**************************************************************************

//==========================================================================
//
//  GetFloorAndCeiling
//
//==========================================================================
final void GetFloorAndCeiling (out tmtrace_t tmtrace) {
  bool oldWithThings = bColideWithThings;
  bool oldWithWorld = bColideWithWorld;
  scope(exit) {
    bColideWithThings = oldWithThings;
    bColideWithWorld = oldWithWorld;
  }
  bColideWithThings = false;
  bColideWithWorld = false;
  // find new position
  CheckRelPosition(&tmtrace, Origin, noPickups:true, ignoreMonsters:true, ignorePlayers:true);
}


//==========================================================================
//
//  GetFloorAndCeilingEx
//
//==========================================================================
final void GetFloorAndCeilingEx (out tmtrace_t tmtrace, TVec org, optional bool collideWorld, optional bool collideThings) {
  bool oldWithThings = bColideWithThings;
  bool oldWithWorld = bColideWithWorld;
  scope(exit) {
    bColideWithThings = oldWithThings;
    bColideWithWorld = oldWithWorld;
  }
  bColideWithThings = collideThings;
  bColideWithWorld = collideWorld;
  // find new position
  CheckRelPosition(&tmtrace, org, noPickups:true, ignoreMonsters:true, ignorePlayers:true);
}


//==========================================================================
//
//  FixNormalVelocity
//
//==========================================================================
final void FixNormalVelocity () {
  if (!(Velocity.x.isfinite && Velocity.y.isfinite && Velocity.z.isfinite)) {
    print("*** FUCKED VELOCITY FOR '%C': %s; Speed=%s; Mass=%s; Gravity=%s; Radius=%s; Height=%s", self, Velocity, Speed, Mass, Gravity, Radius, Height);
    Velocity = vector(0, 0, 0);
  }
  if (!Speed.isfinite) Speed = 0;
}


//==========================================================================
//
//  ClampNormalVelocity
//
//==========================================================================
final void ClampNormalVelocity () {
  if (!(Velocity.x.isfinite && Velocity.y.isfinite && Velocity.z.isfinite)) {
    print("*** FUCKED VELOCITY FOR '%C': %s; Speed=%s; Mass=%s; Gravity=%s; Radius=%s; Height=%s", self, Velocity, Speed, Mass, Gravity, Radius, Height);
    Velocity = vector(0, 0, 0);
  } else {
    // why not?
    Velocity = vclamp(Velocity, -MAXMOVE*4, MAXMOVE*4);
  }
  Speed = (Speed.isfinite ? fclamp(Speed, -MAXMOVE, MAXMOVE) : 0.0);
}


//==========================================================================
//
//  Physics
//
//  returns `false` if mobj is destroyed
//  actually, `false` means "stop processing current tick code", so you
//  can return `false` for this reason too
//
//==========================================================================
bool Physics (float DeltaTime) {
  //ClampNormalVelocity();
  scope(exit) ClampNormalVelocity();

  // GZDoom does it like this, so we should do it this way too
  if (bNoInteraction) {
    // `bNoTimeFreeze` is checked in `Tick()`
    if (Velocity || !bNoBlockmap) {
      // move, and unlink from blockmap
      UnlinkFromWorld();
      // it is safe to change this flag here
      bNoBlockmap = true;
      // it is safe to change origin here
      if (bStickToFloor || bStickToCeiling) Velocity.z = 0;
      TVec vel = Velocity*DeltaTime;
      Origin += vel;
      // link it back
      LinkToWorld(properFloorCheck:false);
      if (bStickToFloor || bStickToCeiling) {
        tmtrace_t tmtrace;
        GetFloorAndCeiling(out tmtrace);
        // no need to relink for z change
        Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
        bIntrJustMoved = false; // disable movement interpolation
      }
    } else if (bStickToFloor || bStickToCeiling) {
      tmtrace_t tmtrace;
      GetFloorAndCeiling(out tmtrace);
      // no need to reling for z change
      Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
      bIntrJustMoved = false; // disable movement interpolation
    }
    return true;
  }

  // check flat sticking
  if (bStickToFloor || bStickToCeiling) {
    bIntrJustMoved = false; // disable movement interpolation
    Velocity.z = 0;
  }

  // process boom transporters
  float CummX = 0.0;
  float CummY = 0.0;

  if (Sector && Sector->AffectorData && bColideWithWorld && !bNoSector) {
    // killough 3/7/98: Carry things on floor
    // killough 3/20/98: use new sector list which reflects true members
    // killough 3/27/98: fix carrier bug
    // killough 4/4/98: Underwater, carry things even w/o gravity

    // move objects only if on floor or underwater, non-floating, and clipped
    // k8: this should work with 3d floors, but now it doesn't

    int CountX = 0;
    int CountY = 0;
    SectorThinker SecThink;
    for (SecThink = SectorThinker(Sector->AffectorData); SecThink; SecThink = SecThink.NextAffector) {
      auto sth = Scroller(SecThink);
      if (!sth) continue;
      float scrollx = sth.CarryScrollX;
      float scrolly = sth.CarryScrollY;
      if (!scrollx && !scrolly) continue;
      if (bNoGravity && (!Sector->heightsec || Sector->heightsec->bIgnoreHeightSec)) continue;
      float height = GetPlanePointZ(ref Sector->floor, Origin);
      if (Origin.z > height) {
        if (!Sector->heightsec || Sector->heightsec->bIgnoreHeightSec) continue;
        float waterheight = GetPlanePointZ(ref Sector->heightsec->floor, Origin);
        if (waterheight > height && Origin.z >= waterheight) continue;
      }

      CummX += scrollx;
      CummY += scrolly;
      if (scrollx) ++CountX;
      if (scrolly) ++CountY;
    }

    // Some levels designed with Boom in mind actually want things to accelerate
    // at neighboring scrolling sector boundaries. But it is only important for
    // non-player objects.
    if (bIsPlayer || !Level.CompatBoomScroll) {
      if (CountX > 1) CummX /= float(CountX);
      if (CountY > 1) CummY /= float(CountY);
    }
    //if (CummX || CummY) print("%C: CALCULATED SCROLL=(%s,%s); vel=%s", self, CummX, CummY, Velocity);
  }

  CheckWater();
  if (!bFloatBob || !bSpecial) {
    UpdateVelocity(DeltaTime);
  }

  // momentum (velocity) movement
  // handle X and Y momentums
  float oldfloorz = XYMovement(DeltaTime, CummX, CummY);
  if (IsDestroyed()) return false; // mobj was removed
  // apply friction here
  if (Velocity.x || Velocity.y) ApplyFriction(DeltaTime);

  if (bFloatBob) {
    if (bSpecial) {
      // floating item bobbing motion (special1 is height)
      if (Sector && Sector->bHasExtrafloors) {
        // make sure FloorZ is from bottom region
        Origin.z = ONFLOORZ;
        LinkToWorld();
      }
      FloatBobPhase += DeltaTime;
      if (Sector) Origin.z = GetPlanePointZ(ref Sector->floor, Origin)+Special1f+Level.Game.FloatBobOffsets[int(FloatBobPhase*35.0)&63];
    } else {
      // floating bobbing motion for monsters
      float savedz = Origin.z;

      Origin.z -= Level.Game.FloatBobOffsets[int(FloatBobPhase*35.0)&63];
      if (!TestMobjZ()) Origin.z = savedz;
      FloatBobPhase += DeltaTime;

      savedz = Origin.z;
      Origin.z += Level.Game.FloatBobOffsets[int(FloatBobPhase*35.0)&63];
      if (!TestMobjZ()) Origin.z = savedz;
    }
  }

  // k8: thingy bridges should be checked even if we have zero vertical velocity.
  //     the following code looks like optimization attempt, and it introduced a bug:
  //     if a player (or a monster, i think) moved into step-like thing while
  //     standing on a floor, that thing will be ignored. meh, just always check
  //     things, 'cause why not?
  EntityEx onmo = EntityEx(CheckOnmobj());
  if (onmo || Velocity.z ||
      (Origin.z != FloorZ &&
       (!bFloatBob || (!bSpecial && Origin.z-Level.Game.FloatBobOffsets[int(FloatBobPhase*35.0)&63] != FloorZ))))
  {
    if (bPassMobj && !bMissile && !Level.CompatNoPassOver) {
      // handle Z momentum and gravity
      //EntityEx onmo = EntityEx(CheckOnmobj());
      if (onmo && !onmo.bCorpse) {
        if (bIsPlayer) {
          //print("Player is on thing %C", onmo);
          if (Velocity.z < -DEFAULT_GRAVITY*0.25 && !bFly && !bNoGravity) PlayerLandedOnThing();
        }

        if (onmo.Origin.z+onmo.Height-Origin.z <= MaxStepHeight) {
          if (bIsPlayer) {
            PlayerEx pex = PlayerEx(Player);
            if (pex && pex.MO == self) {
              pex.ViewHeight -= onmo.Origin.z+onmo.Height-Origin.z;
              if (PlayerPawn(self)) pex.DeltaViewHeight = (PlayerPawn(self).ViewHeight-pex.ViewHeight)*4.0;
            }
          }
          Origin.z = onmo.Origin.z+onmo.Height;
        }

        bOnMobj = true;
        Velocity.z = 0.0;
        Crash();

        if (onmo.bOnmobjCopyVel) {
          Velocity.x = onmo.Velocity.x;
          Velocity.y = onmo.Velocity.y;
        }

        if (onmo.Origin.z < onmo.FloorZ) {
          Origin.z += onmo.FloorZ-onmo.Origin.z;
          if (onmo.bIsPlayer) {
            PlayerEx pex = PlayerEx(onmo.Player);
            if (pex && pex.MO == onmo) {
              pex.ViewHeight -= onmo.FloorZ-onmo.Origin.z;
              if (PlayerPawn(onmo)) pex.DeltaViewHeight = (PlayerPawn(onmo).ViewHeight-pex.ViewHeight)*4.0;
            }
          }
          onmo.Origin.z = onmo.FloorZ;
        }
      } else {
        ZMovement(DeltaTime, oldfloorz);
        bOnMobj = false;
      }
      if (IsDestroyed()) return false; // entity was removed
    } else {
      // handle Z momentum and gravity
      ZMovement(DeltaTime, oldfloorz);
      if (IsDestroyed()) return false; // entity was removed
    }
  }

  if (bStickToFloor || bStickToCeiling) {
    tmtrace_t tmtrace;
    GetFloorAndCeiling(out tmtrace);
    // no need to reling for z change
    Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
    bIntrJustMoved = false; // disable movement interpolation
  }

  // move static light, if there is any
  if (/*bStaticLight &&*/ bStaticLightSpawned) {
    Level.MoveStaticLightByOwner(self, Origin+LightOffset);
  }

  return true;
}


//==========================================================================
//
//  XYMovement
//
//  returns old floor z
//
//==========================================================================
final float XYMovement (float DeltaTime, float ScrollX, float ScrollY) {
  float oldfloorz = FloorZ;

  //FixNormalVelocity();
  //scope(exit) ClampNormalVelocity();

  if (bWindThrust && Sector) {
    int special = Sector->special&SECSPEC_BASE_MASK;
    switch (special) {
      case SECSPEC_WindEastSlow:
      case SECSPEC_WindEastMedium:
      case SECSPEC_WindEastFast:
        Thrust(0.0, LineSpecialGameInfo(Level.Game).windTab[special-SECSPEC_WindEastSlow]*DeltaTime*35.0);
        break;
      case SECSPEC_WindNorthSlow:
      case SECSPEC_WindNorthMedium:
      case SECSPEC_WindNorthFast:
        Thrust(90.0, LineSpecialGameInfo(Level.Game).windTab[special-SECSPEC_WindNorthSlow]*DeltaTime*35.0);
        break;
      case SECSPEC_WindSouthSlow:
      case SECSPEC_WindSouthMedium:
      case SECSPEC_WindSouthFast:
        Thrust(270.0, LineSpecialGameInfo(Level.Game).windTab[special-SECSPEC_WindSouthSlow]*DeltaTime*35.0);
        break;
      case SECSPEC_WindWestSlow:
      case SECSPEC_WindWestMedium:
      case SECSPEC_WindWestFast:
        Thrust(180.0, LineSpecialGameInfo(Level.Game).windTab[special-SECSPEC_WindWestSlow]*DeltaTime*35.0);
        break;
    }
  }

  Velocity.x = fclamp(Velocity.x, -MAXMOVE, MAXMOVE);
  Velocity.y = fclamp(Velocity.y, -MAXMOVE, MAXMOVE);

  float xmove = Velocity.x*DeltaTime;
  float ymove = Velocity.y*DeltaTime;

  if (ScrollX || ScrollY) {
    // scroll is already deltatime-corrected
    /*
    print("%C: scroll=(%s,%s); cst=%s; newscroll=(%s,%s); deltav=(%s,%s); v=%s; ss=%s", self, ScrollX, ScrollY, CARRYSTOPSPEED*DeltaTime,
      ScrollX*(CARRYFACTOR*DeltaTime), ScrollY*(CARRYFACTOR*DeltaTime),
      ScrollX/DeltaTime, ScrollY/DeltaTime, Velocity, STOPSPEED);
    */

    // Carrying sectors didn't work with low speeds in BOOM. This is because
    // BOOM relied on the speed being fast enough to accumulate despite
    // friction. If the speed is too low, then its movement will get
    // cancelled, and it won't accumulate to the desired speed.
    if (!GetCvarB('sv_transporters_absolute')) {
      float CarryStopSpeed = CARRYSTOPSPEED*DeltaTime;
      if (fabs(ScrollX) > CarryStopSpeed) {
        ScrollX *= CARRYFACTOR*DeltaTime;
        Velocity.x += ScrollX/DeltaTime;
      }
      if (fabs(ScrollY) > CarryStopSpeed) {
        ScrollY *= CARRYFACTOR*DeltaTime;
        Velocity.y += ScrollY/DeltaTime;
      }
      //print("   nv=%s", Velocity);
    }

    xmove += ScrollX;
    ymove += ScrollY;
  }

  if (!xmove && !ymove) {
    if (bSkullFly) {
      // a flying mobj slammed into something
      bSkullFly = false;
      Velocity = vector(0.0, 0.0, 0.0);
      if (Health > 0) SetState(SeeState ? SeeState : IdleState);
    } else if (bBlasted) {
      // reset to not blasted when momentums are gone
      ResetBlasted();
    }
    if (bTouchy && !IsSentient()) {
      // arm a mine which has come to rest
      bArmed = true;
    }
    return oldfloorz;
  }

  // split move in multiple steps if moving too fast
  int Steps = 1;
  float XStep = fabs(xmove);
  float YStep = fabs(ymove);
  float MaxStep = Radius-1.0;

  if (MaxStep <= 0.0) MaxStep = MAXMOVESTEP;

  if (XStep > MaxStep || YStep > MaxStep) {
    if (XStep > YStep) {
      Steps = int(XStep/MaxStep)+1;
    } else {
      Steps = int(YStep/MaxStep)+1;
    }
  }

  float StepXMove = xmove/float(Steps);
  float StepYMove = ymove/float(Steps);

  //int Step = 1;
  TVec oldOrigin = Origin;
  foreach (; 0..Steps) {
    float ptryx = Origin.x+StepXMove;
    float ptryy = Origin.y+StepYMove;

    tmtrace_t tmtrace;
    if (!bNoInteraction && !TryMoveEx(&tmtrace, vector(ptryx, ptryy, Origin.z), AllowDropOff:true)) {
      // blocked move
      if (DecalName && (bDecals2SPass || bDecalsOnly2S)) {
        //print("tracing decal '%s' (hit)", DecalName);
        TVec spdir = Velocity.normalise();
        float spdist = length(Origin-oldOrigin);
        TraceSplat(oldOrigin, spdir, spdist, tr:nullptr, zofs:0, DecalName:DecalName, pass2S:bDecals2SPass, only2S:bDecalsOnly2S);
      }
      if (tmtrace.BlockingMobj) {
        //if (GetCvarB('k8ExplodeMissleTest')) print("MOBJ!");
        HitMobj(tmtrace.BlockingMobj, ptryx, ptryy);
      } else {
        /*
        if (GetCvarB('k8ExplodeMissleTest')) {
          print("LINE! (%d)", tmtrace.SpecHit.Length);
          if (!tmtrace.BlockingLine) print("*** BUT NO LINE!");
          if (!tmtrace.AnyBlockingLine) print("*** BUT NO ANY-LINE!");
          if (!tmtrace.AnyBlockingLine) {
            if (tmtrace.CeilingLine) print("      CEILING LINE IS HERE!");
            if (tmtrace.FloorLine) print("      FLOOR LINE IS HERE!");
            if (tmtrace.CeilingLine == tmtrace.FloorLine && tmtrace.FloorLine) print("      FLOOR AND CEILING LINE IS THE SAME!");
          }
        }
        */
        /*
        if (!tmtrace.BlockingLine && !tmtrace.AnyBlockingLine) {
          tmtrace_t tr2;
          if (CheckRelPosition(&tr2, vector(ptryx, ptryy, Origin.z))) {
            print("second trace returned TRUE!: l:%s; al:%s", (tr2.BlockingLine ? "tan" : "ona"), (tr2.AnyBlockingLine ? "tan" : "ona"));
          } else {
            print("second trace returned FALSE!: l:%s; al:%s", (tr2.BlockingLine ? "tan" : "ona"), (tr2.AnyBlockingLine ? "tan" : "ona"));
          }
        }
        */
        HitLine(&tmtrace, DeltaTime/float(Steps), (ScrollX || ScrollY ? true : false));
      }
      return oldfloorz;
    }
  } //while (Step++ < Steps);

  if (DecalName && (bDecals2SPass || bDecalsOnly2S)) {
    //print("tracing decal '%s' (pass)", DecalName);
    TVec spdir = Velocity.normalise();
    float spdist = length(Origin-oldOrigin);
    TraceSplat(oldOrigin, spdir, spdist, tr:nullptr, zofs:0, DecalName:DecalName, pass2S:bDecals2SPass, only2S:bDecalsOnly2S);
  }

  return oldfloorz;
}


//==========================================================================
//
//  ZMovement
//
//==========================================================================
final void ZMovement (float DeltaTime, float OldFloorZ) {
  float dist;
  float delta;
  float OldZ = Origin.z;

  //print("*** vz=%s", Velocity.z);
  //FixNormalVelocity();
  //scope(exit) ClampNormalVelocity();

  if (Mass.isinf) Mass = 10000;
  //else if (Mass < 0) Mass = 0;
  Mass = fclamp(Mass, 0, 10000);

  bool hasGravity = (!bNoGravity && Sector);

  // [RH] Double gravity only if running off a ledge. Coming down from
  // an upward thrust (e.g. a jump) should not double it.
  // Make objects fall to their own weight.
  if (hasGravity && Origin.z > FloorZ) {
    float grav = (Gravity*Level.Gravity*(WaterLevel < 2 ? Sector->Gravity : Sector->Gravity/10.0))/1.220703125; // 9.8 (1053.52)
    if (grav.isinf) grav = 1000;
    //float xmass = (Mass.isinf ? 10000.0 : fmax(1, Mass));
    float xmass = fmax(1, Mass);
    //print("WL=%s; grav=%s; Gravity=%s, LGravity=%s; SGravity=%s; mass=%s; vz=%s", WaterLevel, grav, Gravity, Level.Gravity, Sector->Gravity, xmass, Velocity.z);

    if (Velocity.z == 0.0 && OldFloorZ > FloorZ && Origin.z == OldFloorZ) {
      if (WaterLevel < 2) {
        Velocity.z -= ((grav+grav)/xmass)*DeltaTime;
      } else {
        Velocity.z -= (((grav+grav)/10.0)/xmass)*DeltaTime;
      }
    } else {
      if (WaterLevel < 2) {
        Velocity.z -= (grav/xmass)*DeltaTime;
      } else {
        Velocity.z -= ((grav/10.0)/xmass)*DeltaTime;
      }
    }
  }

  // check for smooth step up
  if (bIsPlayer && Origin.z < FloorZ) {
    PlayerEx pex = PlayerEx(Player);
    if (pex && pex.MO == self) {
      float dfz = FloorZ-Origin.z;
      // arbitrary number
      if (dfz > 0.6 || EFloor.spGetNormalZ == 1.0) {
        pex.ViewHeight -= dfz;
        pex.DeltaViewHeight = (PlayerPawn(self).ViewHeight-pex.ViewHeight)*4.0;
        //if (EFloor.spGetNormalZ != 1.0) print("FUCK1! z=%s; fz=%s; sfz=(%s:%s); dfz=%s", Origin.z, FloorZ, Sector.floor.minz, Sector.floor.maxz, dfz);
      } else {
        //print("FUCK0! z=%s; fz=%s; sfz=(%s:%s); dfz=%s", Origin.z, FloorZ, Sector.floor.minz, Sector.floor.maxz, dfz);
      }
    }
  }

  // adjust height
  if (!bFloatBob) Origin.z += Velocity.z*DeltaTime;

  if (bFloat && !bDormant && Target) {
    // float down towards enemy if too close
    if (!bSkullFly && !bInFloat) {
      dist = DistTo2(Target);
      delta = Target.Origin.z+Height/2.0-Origin.z;
      if (delta < 0.0 && dist < -(delta*3.0)) {
        Velocity.z = 0.0;
        EntityEx onmo = EntityEx(CheckOnmobj());
        if (((onmo && onmo.TestMobjZ()) || !onmo) && TestMobjZ()) {
          Origin.z -= FloatSpeed*DeltaTime;
        } else {
          return;
        }
      } else if (delta > 0.0 && dist < delta*3.0) {
        Velocity.z = 0.0;
        EntityEx onmo = EntityEx(CheckOnmobj());
        if (((onmo && onmo.TestMobjZ()) || !onmo) && TestMobjZ()) {
          Origin.z += FloatSpeed*DeltaTime;
        } else {
          return;
        }
      }
    }
  }

  if (bIsPlayer && bFly && Origin.z > FloorZ /*&& (XLevel.TicTime&2)*/) {
    //FIXME: this is time-dependent, rewrite!
    //Origin.z += sin(90.0*35.0/20.0*AngleMod360(int(XLevel.Time)))/2.0;
    Origin.z = PlayerEx(Player).CalcFlyZ(Origin.z);
  }

  // clip movement
  if (!bNoInteraction) {
    if (Origin.z <= FloorZ+0.1) {
      // hit the floor
      if (!HitFloor()) return;
    }

    if (Origin.z+Height > CeilingZ) {
      // hit the ceiling
      if (!HitCeiling()) return;
    }

    CheckFakeFloorTriggers(OldZ);
  }
}


//==========================================================================
//
//  HitLine
//
//  if entity is moving with transported, it should slide along walls
//  in any case
//
//==========================================================================
final void HitLine (tmtrace_t *tmtrace, float StepVelScale, bool forceSlide) {
  if (bMissile) {
    if (bBounceWalls || BounceType == BOUNCE_Doom || BounceType == BOUNCE_Hexen) {
      // if number of bounces is limited.
      if (BounceCount > 0 && --BounceCount <= 0) {
        ExplodeMissile(none);
        return;
      }

      // explode a missile
      if (tmtrace->CeilingLine && tmtrace->CeilingLine->backsector &&
          tmtrace->CeilingLine->backsector->ceiling.pic == Level.Game.skyflatnum)
      {
        // hack to prevent missiles exploding against the sky
        // does not handle sky floors
        float pf = tmtrace->CeilingLine->frontsector->floor.maxz;
        float pb = tmtrace->CeilingLine->backsector->floor.maxz;
        bool hitsky = true;
        if (pf != pb) {
          int siden = PointOnPlaneSide(Origin-Velocity*2, ref *tmtrace->CeilingLine);
          if (!siden) {
            hitsky = (pf < pb && tmtrace.End.z > pb);
          } else {
            hitsky = (pb < pf && tmtrace.End.z > pf);
          }
        }
        if (hitsky) {
               if (bBounceSky) Velocity = vector(0.0, 0.0, -1.0*35.0);
          else if (bExplodeOnSky) ExplodeMissile(none);
          else Destroy();
          return;
        }
      }

      if (tmtrace->BlockingLine && tmtrace->BlockingLine->special == LNSPEC_LineHorizon) {
        SightSound = '';
        Destroy();
        return;
      }

      // struck a wall
      if (bBounceWalls || BounceType == BOUNCE_Doom || BounceType == BOUNCE_Hexen) {
        BounceWall(BOUNCE_VAL, WallBounceFactor);
        if (!bNoBounceSound && !bNoWallBounceSnd && (BounceSound || SightSound)) {
          PlaySound((BounceSound ? BounceSound : SightSound), CHAN_VOICE);
        }
      }
      return;
    }

    // explode a missile
    if (tmtrace->CeilingLine && tmtrace->CeilingLine->backsector &&
        tmtrace->CeilingLine->backsector->ceiling.pic == Level.Game.skyflatnum)
    {
      // hack to prevent missiles exploding against the sky
      // does not handle sky floors
      float pf = tmtrace->CeilingLine->frontsector->floor.maxz;
      float pb = tmtrace->CeilingLine->backsector->floor.maxz;
      bool hitsky = true;
      if (pf != pb) {
        int siden = PointOnPlaneSide(Origin-Velocity*2, ref *tmtrace->CeilingLine);
        if (!siden) {
          hitsky = (pf < pb && tmtrace.End.z > pb);
        } else {
          hitsky = (pb < pf && tmtrace.End.z > pf);
        }
      }
      if (hitsky) {
             if (bBounceSky) Velocity = vector(0.0, 0.0, -1.0*35.0);
        else if (bExplodeOnSky) ExplodeMissile(none);
        else Destroy();
        return;
      }
    }

    if (tmtrace->BlockingLine && tmtrace->BlockingLine->special == LNSPEC_LineHorizon) {
      if (bBounceSky) Velocity = vector(0.0, 0.0, -1.0*35.0); else Destroy();
      return;
    }

    line_t *hitline = tmtrace->BlockingLine;
    if (!hitline) hitline = tmtrace->CeilingLine;
    if (!hitline) hitline = tmtrace->FloorLine;
    if (!hitline) hitline = tmtrace->AnyBlockingLine;
    if (!hitline && tmtrace->SpecHit.Length) {
      bool wasBlockAll = false;
      line_t *blockall;
      foreach (int f; 0..tmtrace->SpecHit.Length) {
        line_t *ln = tmtrace->SpecHit[f];
        if (ln->flags&ML_BLOCKING) { hitline = ln; break; }
        if (!wasBlockAll && (ln->flags&ML_BLOCKEVERYTHING) != 0) { blockall = ln; wasBlockAll = true; }
      }
      if (!hitline) {
        if (wasBlockAll) hitline = blockall; else hitline = tmtrace->SpecHit[0];
      }
    }
    // wtf?!
    if (!hitline) {
      Destroy();
      return;
    }
    ExplodeMissile(none, hitline);
  } else if (bSlide || forceSlide) {
    // try to slide along it
    SlideMove(StepVelScale);
  } else {
    Velocity.x = 0.0;
    Velocity.y = 0.0;
  }
}


//==========================================================================
//
//  HitMobj
//
//==========================================================================
final void HitMobj (Entity Other, float ptryx, float ptryy) {
  float angle;
  float speed;
  float sina, cosa;

  if (bMissile) {
    if (bBounceOnActors || bBounceOnAllActors || BounceType == BOUNCE_Doom || BounceType == BOUNCE_Hexen) {
      // if number of bounces is limited
      if (BounceCount > 0 && --BounceCount <= 0) {
        ExplodeMissile(none);
        return;
      }

      // bounce against walls and non-killable objects
      if ((bBounceOnActors || EntityEx(Other).bReflective || (!Other.bIsPlayer && !EntityEx(Other).bMonster) || !EntityEx(Other).IsSentient()) ||
          EntityEx(Other).bBounceOnAllActors)
      {
        angle = AngleMod360(atan2(Origin.y-Other.Origin.y, Origin.x-Other.Origin.x)+(Random()*16.0-8.0));
        speed = Length(Velocity)*WallBounceFactor;
        Angles.yaw = angle;
        sincos(angle, out sina, out cosa);
        Velocity.x = speed*cosa;
        Velocity.y = speed*sina;
        if (!bNoBounceSound && (BounceSound || SightSound)) {
          PlaySound(BounceSound ? BounceSound : SightSound, CHAN_VOICE);
        }
      } else {
        // struck a player/creature
        ExplodeMissile(EntityEx(Other));
      }
      return;
    }

    if (EntityEx(Other).bReflective) {
      angle = EntityEx(Other).GetReflectedAngle(self);
      if (angle != -1.0) {
        // reflect the missile along angle
        Angles.yaw = angle;
        sincos(angle, out sina, out cosa);
        Velocity.x = (Speed/2.0)*cosa;
        Velocity.y = (Speed/2.0)*sina;
        Velocity.z = -Velocity.z*0.5;
        if (bSeekerMissile) Tracer = Target;
        Target = EntityEx(Other);
        return;
      }
    }

    // explode a missile
    ExplodeMissile(EntityEx(Other));
  } else if (bSlide) {
    // try to slide along it
    // slide against mobj
         if (TryMove(vector(Origin.x, ptryy, Origin.z), AllowDropOff:true)) Velocity.x = 0.0;
    else if (TryMove(vector(ptryx, Origin.y, Origin.z), AllowDropOff:true)) Velocity.y = 0.0;
    else { Velocity.x = 0.0; Velocity.y = 0.0; }
  } else {
    Velocity.x = 0.0;
    Velocity.y = 0.0;
  }
}


//==========================================================================
//
//  HitFloor
//
//==========================================================================
final bool HitFloor () {
  // trigger hit floor sector actions
  if (Sector && Sector->ActionList && GetPlanePointZ(ref Sector->floor, Origin) == FloorZ) {
    SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_HitFloor);
  }

  // killough 11/98: touchy objects explode on impact
  // allow very short drops to be safe, so that a touchy can be summoned without exploding
  if (bTouchy && (bArmed || IsSentient()) && Velocity.z < -5.0) {
    bArmed = false; // disarm
    Damage(none, none, Health, spawnBlood:true);  // kill object
    return true;
  }

  if (bMissile && (bColideWithWorld || !LineSpecialGameInfo(Level.Game).bNoClipIgnoreFloor)) {
    // physics caller will setup interpolation with `tmp_phys_z_change`
    tmp_phys_z_change += FloorZ-Origin.z;
    Origin.z = FloorZ;
    if (bBounceFloors || BounceType != BOUNCE_None) {
      FloorBounceMissile();
      return false;
    }
    if (bNoExplodeFloor) {
      // the spirit struck the ground
      Velocity.z = 0.0;
      HitFloorType();
      return false;
    }
    if (bIgnoreFloorStep) {
      // minotaur floor fire can go up steps
      return false;
    }
    HitFloorType();
    ExplodeMissile(none);
    return false;
  }

  float vdot = DotProduct(Velocity, EFloor.spGetNormal());
  if (bMonster) {
    // blasted mobj falling
    if (vdot < -23.0*35.0) MonsterFallingDamage();
  }

  // physics caller will setup interpolation with `tmp_phys_z_change`
  tmp_phys_z_change += FloorZ-Origin.z;
  Origin.z = FloorZ;

  if (vdot < -0.1) {
    // spawn splashes, etc
    HitFloorType();
    if (!Inventory(self) && nameicmp(DamageType, 'Ice') == 0 && vdot < -DEFAULT_GRAVITY*0.25) {
      StateTime = 0.1;
      //Velocity = vector(0.0, 0.0, 0.0);
      Velocity.z = 0.0;
      return false;
    }
    if (bCanJump) JumpTime = 0.5; // delay any jumping for a short time
    // do some special action when hitting the floor
    OnHitFloor();
    if (bIsPlayer) {
      PlayerEx(Player).JumpTime = 0.2; // delay any jumping for a short time
      if (vdot < -DEFAULT_GRAVITY*0.25 && !bNoGravity) {
        // squat down
        // decrease ViewHeight for a moment after hitting the ground (hard), and utter appropriate sound
        PlayerLandedOnThing();
      }
    }
    TVec Vel = vdot*EFloor.spGetNormal();
    Velocity.z -= Vel.z;
  }

  if (bSkullFly) {
    // the skull slammed into something
    Velocity.z = -Velocity.z;
  }

  Crash();
  return true;
}


//==========================================================================
//
//  HitCeiling
//
//==========================================================================
final bool HitCeiling () {
  // trigger hit ceiling sector actions
  if (Sector && Sector->ActionList && GetPlanePointZ(ref Sector->ceiling, Origin) == CeilingZ) {
    SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_HitCeiling);
  }

  // physics caller will setup interpolation with `tmp_phys_z_change`
  tmp_phys_z_change += (CeilingZ-Height)-Origin.z;
  Origin.z = CeilingZ-Height;

  if (bMissile && (bColideWithWorld || !LineSpecialGameInfo(Level.Game).bNoClipIgnoreFloor)) {
    if (bBounceCeilings || BounceType != BOUNCE_None) {
      CeilingBounceMissile();
      return false;
    }
    if (bIgnoreCeilingStep) return false;
    if (ECeiling.splane->pic == Level.Game.skyflatnum) {
           if (bBounceSky) Velocity = vector(0.0, 0.0, -1.0*35.0);
      else if (bExplodeOnSky) ExplodeMissile(none);
      else Destroy();
      return false;
    }
    ExplodeMissile(none);
    return false;
  }

  float vdot = DotProduct(Velocity, ECeiling.spGetNormal());

  if (vdot < 0.0) {
    TVec Vel = vdot*ECeiling.spGetNormal();
    Velocity.z -= Vel.z;
  }

  if (bSkullFly) {
    // the skull slammed into something
    Velocity.z = -Velocity.z;
  }

  return true;
}


//==========================================================================
//
//  TurnOffAllBouncingFlags
//
//==========================================================================
void TurnOffAllBouncingFlags () {
  bBounceWalls = false;
  bBounceFloors = false;
  bBounceCeilings = false;
  bBounceOnActors = false;
  bBounceOnAllActors = false;
}


//==========================================================================
//
//  FloorBounceMissile
//
//==========================================================================
void FloorBounceMissile () {
  float vdot;

  if (HitFloorType()) {
    // landed on some kind of liquid
    if (bExplodeOnWater) {
      ExplodeMissile(none);
      return;
    }
    if (!bCanBounceWater) {
      Destroy();
      return;
    }
  }

  // if number of bounces is limited
  if (BounceCount > 0 && --BounceCount <= 0) {
    ExplodeMissile(none);
    return;
  }

  vdot = DotProduct(Velocity, EFloor.spGetNormal());

  if (bBounceLikeHeretic || (BounceType == BOUNCE_Heretic && !bMBFBounce)) {
    Velocity -= 2.0*(vdot*EFloor.spGetNormal());
    Angles.yaw = atan2(Velocity.y, Velocity.x);
    SetState(FindState('Death'));
    return;
  }

  if (bMBFBounce) {
    Velocity = Velocity-(2.0*(vdot*EFloor.spGetNormal()));
    Velocity.z = Velocity.z*BounceFactor;
    Angles.yaw = atan2(Velocity.y, Velocity.x);
  } else {
    Velocity = (Velocity-(2.0*(vdot*EFloor.spGetNormal())))*BounceFactor;
    Angles.yaw = atan2(Velocity.y, Velocity.x);
  }

  // put it to rest, or...
  /*if (fabs(Velocity.z) <= 0.1) {
    Velocity.z = 0;
  } else*/ {
    // ...play bounce sound
    if (!bNoBounceSound && (BounceSound || SightSound)) {
      PlaySound(BounceSound ? BounceSound : SightSound, CHAN_VOICE);
    }
  }

  if (bMBFBounce) {
    if (Velocity.z < (fmax(1, Mass)*Gravity)/64.0) {
      // Bring it to rest below a certain speed
      Velocity.z = 0.0;
    }
  }

  //print("%C: bBounceFloors=%B; bBounceAutoOff=%B; bNoGravity=%B; Velocity.z=%s; btype=%s", self, bBounceFloors, bBounceAutoOff, bNoGravity, Velocity.z, BounceType);
  //print("%C: Mass=%s; Gravity=%s; Velocity.z=%s; lim=%s", self, Mass, Gravity, Velocity.z, (Mass*Gravity)/64.0);
  if (bBounceAutoOff || BounceType == BOUNCE_Doom) {
    if (!bNoGravity && Velocity.z < 2.5/*3.0*/*35.0) {
      BounceType = BOUNCE_None;
      TurnOffAllBouncingFlags(); // otherwise it will bounce forever
    }
  }
}


//==========================================================================
//
//  CeilingBounceMissile
//
//==========================================================================
final void CeilingBounceMissile () {
  float vdot;

  // if number of bounces is limited
  if (BounceCount > 0 && --BounceCount <= 0) {
    ExplodeMissile(none);
    return;
  }

  vdot = DotProduct(Velocity, ECeiling.spGetNormal());

  if (bBounceLikeHeretic || (BounceType == BOUNCE_Heretic && !bMBFBounce)) {
    Velocity -= 2.0*(vdot*ECeiling.spGetNormal());
    Angles.yaw = atan2(Velocity.y, Velocity.x);
    SetState(FindState('Death'));
    return;
  }

  // reverse momentum here for ceiling bounce
  if (bMBFBounce) {
    Velocity = Velocity-(2.0*(vdot*ECeiling.spGetNormal()));
    Velocity.z = Velocity.z*BounceFactor;
    Angles.yaw = atan2(Velocity.y, Velocity.x);
  } else {
    Velocity = (Velocity-(2.0*(vdot*ECeiling.spGetNormal())))*BounceFactor;
    Angles.yaw = atan2(Velocity.y, Velocity.x);
  }

  if (!bNoBounceSound && (BounceSound || SightSound)) {
    PlaySound(BounceSound ? BounceSound : SightSound, CHAN_VOICE);
  }

  if (bMBFBounce) {
    if (Velocity.z < (fmax(1, Mass)*Gravity/64.0)) {
      // bring it to rest below a certain speed
      Velocity.z = 0.0;
    }
  }

  if (bBounceAutoOff || BounceType == BOUNCE_Doom) {
    if (!bNoGravity && Velocity.z < 2.5/*3.0*/*35.0) {
      BounceType = BOUNCE_None;
      TurnOffAllBouncingFlags(); // otherwise it will bounce forever
    }
  }
}


//==========================================================================
//
//  GetReflectedAngle
//
//==========================================================================
final float GetReflectedAngle (EntityEx Other) {
  if (Other.bDontReflect) return -1.0;

  float angle = atan2(Other.Origin.y-Origin.y, Other.Origin.x-Origin.x);

  if (bShieldReflect) {
    // change angle for delflection/reflection
    if (fabs(AngleMod180(angle-Angles.yaw)) > 45.0*45.0/32.0) return -1.0;
    if (Other.bDontShieldReflect) return -1.0;
    // deflection
         if (Random() < 0.5) angle = AngleMod360(angle+45.0);
    else angle = AngleMod360(angle-45.0);
    return angle;
  }

  if (bDeflect) {
    // change angle for delflection
         if (Random() < 0.5) angle = AngleMod360(angle+45.0);
    else angle = AngleMod360(angle-45.0);
    return angle;
  }

  // change angle for reflection
  angle = AngleMod360(angle+Random()*16.0-8.0);
  return angle;
}


//==========================================================================
//
//  Crash
//
//==========================================================================
final void Crash () {
  state CrashState = FindState('Crash');
  if (CrashState && bCorpse && DamageType != 'Ice' && !bCrashed) {
    SetState(CrashState);
    bCrashed = true;
  }
}


//===========================================================================
//
//  PlayerLandedOnThing
//
//===========================================================================
final void PlayerLandedOnThing () {
  auto pex = PlayerEx(Player);
  if (pex.MO == self) pex.DeltaViewHeight = Velocity.z/8.0;
  FallingDamage();
  if (Health > 0 && !pex.MorphTime) {
    if (Velocity.z < -DEFAULT_GRAVITY*0.375) {
      PlaySound('*grunt', CHAN_VOICE);
    }
    if ((Origin.z > FloorZ || !GetFloorType()->bLiquid) && !AreSoundsEquivalent('*grunt', '*land')) {
      PlaySound('*land', CHAN_BODY);
    }
  }
  //FIXME Player.centreing = true;
}


//==========================================================================
//
//  FallingDamage
//
//==========================================================================
final void FallingDamage () {
  //print("fdam: %B %B %B", Level.bFallingDamage, Level.bOldFallingDamage, Level.bStrifeFallingDamage);
  int damage;
  float dist;

  if (Sector && Sector->bNoFallingDamage) return;

  float mom = fabs(Velocity.z);

  if (Level.bFallingDamage) {
    // Hexen style falling damage
    if (mom <= 23.0*35.0) return; // not fast enough
    if (mom >= 63.0*35.0) {
      damage = 10000; // automatic death
    } else {
      dist = mom/35.0*16.0/23.0;
      damage = int(dist*dist/10.0)-24;
      if (Velocity.z > -39.0*35.0 && damage > Health && Health != 1) {
        // no-death threshold
        damage = Health-1;
      }
    }
  } else if (Level.bOldFallingDamage) {
    // ZDoom style falling damage, less damaging
    if (mom <= 19.0*35.0) return; // not fast enough
    if (mom >= 84.0*35.0) {
      damage = 10000; // automatic death
    } else {
      mom = mom/35.0;
      damage = (int(mom*mom*11.0/128.0)-30)/2;
      if (damage < 1) damage = 1;
    }
  } else if (Level.bStrifeFallingDamage) {
    // Strife style falling damage, very strong
    if (mom <= 20.0*35.0) return; // not fast enough
    damage = int(mom*(8192.0/3125.0/35.0));
  } else {
    return;
  }

  Damage(none, none, damage, 'Falling', spawnBlood:true);
  LineSpecialLevelInfo(Level).NoiseAlert(self, self);
}


//==========================================================================
//
//  MonsterFallingDamage
//
//==========================================================================
final void MonsterFallingDamage () {
  int damage;
  float mom;

  if (!Level.bMonsterFallingDamage) return;
  if (Sector && Sector->bNoFallingDamage) return;

  mom = fabs(Velocity.z)/35.0;
  if (mom > 35.0) {
    // automatic death
    damage = 10000;
  } else {
    damage = int((mom-23.0)*6.0);
  }
  damage = 10000; // always kill 'em
  Damage(none, none, damage, 'Falling', spawnBlood:true);
}


//==========================================================================
//
//  ResetBlasted
//
//==========================================================================
final void ResetBlasted () {
  bBlasted = false;
  if (!bIceCorpse) bSlide = false;
}


//==========================================================================
//
//  OnHitFloor
//
//==========================================================================
void OnHitFloor () {
}


//==========================================================================
//
// CheckSplash
//
// Checks for splashes caused by explosions
//
//==========================================================================
void CheckSplash (float distance) {
  if (Origin.z <= FloorZ+distance) {
    // Explosion splashes never alert monsters. This is because A_Explode has
    // a separate parameter for that so this would get in the way of proper
    // behavior.
    HitFloorType();
  }
}


//==========================================================================
//
//  HitFloorType
//
//==========================================================================
final bool HitFloorType () {
  EntityEx A;
  TVec org;
  bool smallsplash = false;
  VTerrainInfo *TInfo;
  VSplashInfo *SInfo;

  if (!Sector || FloorZ != GetPlanePointZ(ref Sector->floor, Origin)) {
    // don't splash if landing on the edge above water/lava/etc....
    return false;
  }

  // things that don't splash go here
  if (bFloatBob || bNoSplash) return false;

  TInfo = GetFloorType();

  // small splash for small masses
  if (Mass < 10.0 || bSmallSplash) smallsplash = true;

  if (TInfo->DamageAmount && bIsPlayer && (XLevel.TicTime&TInfo->DamageTimeMask)) {
    Damage(none, none, TInfo->DamageAmount, TInfo->DamageType/*, spawnBlood:true*/);
  }

  SInfo = GetSplashInfo(TInfo->Splash);
  if (!SInfo) return TInfo->bLiquid;

  org = Origin;
  org.z = FloorZ;

  if (smallsplash) {
    if (SInfo->SmallClass) {
      A = Spawn(class!EntityEx(SInfo->SmallClass), org);
      A.FloorClip += SInfo->SmallClip;
      if (SInfo->SmallSound) A.PlaySound(SInfo->SmallSound, CHAN_VOICE);
    }
  } else {
    if (SInfo->BaseClass) {
      A = Spawn(class!EntityEx(SInfo->BaseClass), org);
      if (SInfo->Sound && !SInfo->ChunkClass) A.PlaySound(SInfo->Sound, CHAN_VOICE);
    }
    if (SInfo->ChunkClass) {
      A = Spawn(class!EntityEx(SInfo->ChunkClass), org);
      A.Target = self;
      A.Velocity.x = (Random()-Random())*SInfo->ChunkXVelMul*35.0;
      A.Velocity.y = (Random()-Random())*SInfo->ChunkYVelMul*35.0;
      A.Velocity.z = (SInfo->ChunkBaseZVel+Random()*SInfo->ChunkZVelMul)*35.0;
      if (SInfo->Sound) A.PlaySound(SInfo->Sound, CHAN_VOICE);
    }
    if (SInfo->Sound && !SInfo->BaseClass && !SInfo->ChunkClass) PlaySound(SInfo->Sound, CHAN_BODY);
    if (!SInfo->bNoAlert && bIsPlayer) LineSpecialLevelInfo(Level).NoiseAlert(self, self, true);
  }
  return TInfo->bLiquid;
}


//===========================================================================
//
//  GetFloorType
//
//===========================================================================
final VTerrainInfo *GetFloorType () {
  return TerrainType(EFloor.splane->pic);
}


//==========================================================================
//
//  HandleFloorclip
//
//==========================================================================
override void HandleFloorclip () {
  if (bFloorClip) {
    VTerrainInfo *TInfo = GetFloorType();
    if (Origin.z == FloorZ && TInfo->bLiquid) {
      FloorClip = TInfo->FootClip;
    } else {
      FloorClip = 0.0;
    }
  }
}


//==========================================================================
//
//  ApplyFriction
//
//==========================================================================
override void ApplyFriction (float DeltaTime) {
  if (bMissile || bSkullFly) return; // no friction for missiles ever

  //k8: no, really? no friction while knee-dip in the water? i don't think so
  //    was: `WaterLevel < 2`
  if (Origin.z > FloorZ && !bOnMobj && WaterLevel == 0 && !bFly && !bFallingFriction) {
    // no friction when airborne
    //print("AIRBORNE!");
    return;
  }

  //FixNormalVelocity();

  // vanilla hack: floor with height -32768 teleports entity to ceiling
  if (bIsPlayer && Sector && Sector.floor.maxz <= -32768) {
    if (Origin.z <= -32768) {
      //print("!!!! z=%s; fz=%s %C : %s", Origin.z, FloorZ, self, self.UniqueId);
      bIntrJustMoved = false; // don't interpolate
      Origin.z = Sector.ceiling.minz-Height;
      // find out new floor plane
      if (Sector.bHasExtrafloors) GetFloorAndCeiling(nullptr);
      Origin.z = CeilingZ-Height;
      Velocity.z = 0;
    }
    return; // assume airborne
  }

  // clip velocity on sloped floors
  // TODO: don't clip on small slopes
  if (Origin.z <= FloorZ) {
    TVec Vel = EFloor.spGetNormal();
    if (Vel.x || Vel.y) {
      float dot = DotProduct(Velocity, Vel);
      if (dot < 0.0) {
        //TVec Vel = dot*EFloor.spGetNormal();
        Vel *= dot;
        //print("vv: Vel=%s; dot=%s; norm=%s", Vel, dot, EFloor.spGetNormal());
        //print("  : z=%s; fminz=%s; fmaxz=%s", Origin.z, Sector.floor.minz, Sector.floor.maxz);
        Velocity.x -= Vel.x;
        Velocity.y -= Vel.y;
      }
    }
  }

  if (bCorpse) {
    // don't stop sliding if halfway off a step with some momentum
    if (Velocity.x > 0.25*35.0 || Velocity.x < -0.25*35.0 ||
        Velocity.y > 0.25*35.0 || Velocity.y < -0.25*35.0)
    {
      if ((Sector && FloorZ > GetPlanePointZ(ref Sector->floor, Origin)) || DropOffZ != FloorZ) {
        return;
      }
    }
  }

  if (fabs(Velocity.x) < STOPSPEED &&
      fabs(Velocity.y) < STOPSPEED &&
      (!bIsPlayer || (Player.MO == self && !Player.ForwardMove && !Player.SideMove)))
  {
    if (bIsPlayer) {
      // if in a walking frame, stop moving
      if (StateIsInRange(State, SeeState, none, 4)) SetState(IdleState);
    }
    Velocity.x = 0.0;
    Velocity.y = 0.0;
  } else {
    // slow down
    Velocity.x -= Velocity.x*(GetFriction()*DeltaTime);
    Velocity.y -= Velocity.y*(GetFriction()*DeltaTime);
    // roughly smaller than lowest fixed point 16.16 (it is more like 0.0000152587890625)
    if (fabs(Velocity.x) < 0.00001) Velocity.x = 0;
    if (fabs(Velocity.y) < 0.00001) Velocity.y = 0;
    //k8: do we need this for Voodoo Dolls?
    if (bIsPlayer && !Velocity.x && !Velocity.y) {
      // if in a walking frame, stop moving
      if (StateIsInRange(State, SeeState, none, 4)) SetState(IdleState);
    }
  }
}


//===========================================================================
//
//  GetFriction
//
//===========================================================================
final float GetFriction () {
  if (WaterLevel > 1) return FRICTION_WATER;
  if (bFly && Origin.z > FloorZ && !bOnMobj) return FRICTION_FLY;
  if (Sector && (Sector->special&SECSPEC_BASE_MASK) == SECSPEC_FrictionLow) return FRICTION_LOW;
  VTerrainInfo *TInfo = GetFloorType();
  if (TInfo && TInfo->Friction) return TInfo->Friction;
  if (Sector && (Sector->special&SECSPEC_FRICTION_MASK)) return Sector->Friction;
  return FRICTION_NORMAL;
}
