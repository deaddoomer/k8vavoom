//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2023 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//
//  Object movement
//
//**************************************************************************
// define this to check velocity before clamping
//#define PHYSICS_VELOCITY_CHECKS
//#define ENABLE_LINGUORTALS
//#define PHYSICS_DEBUG_ROCKET


const float DOOM_BOUNCE_STOP_VEL = 2.5/*3.0*/*35.0;

const float AUTOCROUCH_LIMIT = 0.75;


//==========================================================================
//
//  GetFloorAndCeiling
//
//==========================================================================
final void GetFloorAndCeiling (out tmtrace_t tmtrace) {
  /*
  bool oldWithThings = bColideWithThings;
  bool oldWithWorld = bColideWithWorld;
  scope(exit) {
    bColideWithThings = oldWithThings;
    bColideWithWorld = oldWithWorld;
  }
  bColideWithThings = false;
  bColideWithWorld = false;
  */
  // find new position
  CheckRelPositionPoint(out tmtrace, Origin);
}


//==========================================================================
//
//  GetFloorAndCeilingEx
//
//  if `collideWorld` is `false`, does point check
//  never checks things
//
//==========================================================================
final void GetFloorAndCeilingEx (out tmtrace_t tmtrace, TVec org, optional bool collideWorld) {
  if (collideWorld) {
    bool oldWithThings = bColideWithThings;
    bool oldWithWorld = bColideWithWorld;
    scope(exit) {
      bColideWithThings = oldWithThings;
      bColideWithWorld = oldWithWorld;
    }
    bColideWithThings = false;
    bColideWithWorld = true;
    CheckRelPosition(out tmtrace, org, noPickups:true, ignoreMonsters:true, ignorePlayers:true);
  } else {
    CheckRelPositionPoint(out tmtrace, org);
  }
}


//==========================================================================
//
//  PhysicsCheckScroller
//
//==========================================================================
override bool PhysicsCheckScroller () {
  // all prerequisites were checked by the C++ code
  // check conveyors
  TVec eorg;
  float hgt;
  bool einited = false;
  for (msecnode_t *mnode = TouchingSectorList; mnode; mnode = mnode.TNext) {
    sector_t *sec = mnode.Sector;
    if (!sec->AffectorData) continue;
    // move objects only if on floor or underwater, non-floating, and clipped
    for (SectorThinker SecThink = SectorThinker(sec->AffectorData); SecThink; SecThink = SecThink.NextAffector) {
      auto sth = Scroller(SecThink);
      if (!sth) continue;
      if (bNoGravity && (!sec->heightsec || sec->heightsec->bIgnoreHeightSec)) continue;
      if (!sth.CarryScrollX && !sth.CarryScrollY) continue;
      if (!einited) {
        einited = true;
        eorg = Origin;
        hgt = sec->floor.GetPointZClamped(eorg);
      }
      if (eorg.z > hgt) {
        if (!sec->heightsec || sec->heightsec->bIgnoreHeightSec) continue;
        float waterheight = sec->heightsec->floor.GetPointZClamped(eorg);
        if (waterheight > hgt && eorg.z >= waterheight) continue;
      }
      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  Physics
//
//  returns `false` if mobj is destroyed
//  actually, `false` means "stop processing current tick code", so you
//  can return `false` for this reason too
//
//==========================================================================
bool Physics (float DeltaTime) {
  //if (bIsPlayer) { printdebug("%C: bSlide=%B", self, bSlide); /*bSlide = true;*/ }
  #ifdef CLIENT
  //printdebug("%C: physics tick! (noint=%B) gravity=%s; delta=%s; vel=%s", self, bNoInteraction, Gravity, DeltaTime, Velocity);
  #endif

  // GZDoom does it like this, so we should do it this way too
  if (bNoInteraction) {
    // `bNoTimeFreeze` is checked in `Tick()`
    if (Velocity || !bNoBlockmap) {
      // move, and unlink from blockmap
      UnlinkFromWorld();
      // it is safe to change this flag here
      bNoBlockmap = true;
      // it is safe to change origin here
      if (bStickToFloor || bStickToCeiling) Velocity.z = 0;
      TVec vel = Velocity*DeltaTime;
      Origin += vel;
      // link it back
      LinkToWorld(properFloorCheck:false);
    }
    if (bStickToFloor || bStickToCeiling) {
      if (Sector) {
        Origin.z = (bStickToFloor ? FloorZ : CeilingZ-Height);
      } else {
        tmtrace_t tmtrace;
        GetFloorAndCeiling(out tmtrace);
        // no need to relink for z change
        Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
      }
      bIntrJustMoved = false; // disable movement interpolation
    }
    if (bStaticLightSpawned) Level.MoveStaticLightByOwner(self, Origin+LightOffset);
    return true;
  }

  // check flat sticking
  if (bStickToFloor || bStickToCeiling) {
    bIntrJustMoved = false; // disable movement interpolation
    Velocity.z = 0;
  }

  // process boom transporters
  float CummX = 0.0;
  float CummY = 0.0;

  //if (bOnScroll) printdebug("%C: ON SCROLLER!", self);

  if (Sector && !bNoSector) {
    // update velocity and apply friction first, so scrollers could do their work unhindered
    // `UpdateVelocity()` does nothing if "no gravity" set
    //FIXME: make a separate flag for this?
    //if (!bNoGravity && (!bFloatBob || !bSpecial)) UpdateVelocity(DeltaTime);
    //k8: why? floatbob should be affected by gravity, and dropped pickups too
    /*if (!bFloatBob || !bSpecial)*/ UpdateVelocity(DeltaTime, !bSkullFly);
    // apply friction here
    //TODO: should we apply the friction for "no world collision" things here?
    // (don't forget about "collide with things" flag too -- we may stand on a bridge or something)
    // still call it for the player, to take care of state changes and such
    // missile and skullfly check moved here from `ApplyFriction()` for speed reasons
    // no friction for missiles ever
    if (!bMissile && !bSkullFly) {
      if (Velocity.xy || bIsPlayer) ApplyFriction(DeltaTime);
    }

    // new code for scroller checks
    if (GetClassInstanceCountWithSub(Scroller) && bColideWithWorld && Origin != lastScrollCheckOrigin) {
      //if (self isa 'ExplosiveBarrel') printdebug("%C(%s): SCROLLER CHECK!", self, UniqueId);
      lastScrollCheckOrigin = Origin;
      // killough 3/7/98: Carry things on floor
      // killough 3/20/98: use new sector list which reflects true members
      // killough 3/27/98: fix carrier bug
      // killough 4/4/98: Underwater, carry things even w/o gravity
      // k8: check all sectors we are touching, because this is how it should work
      // k8: sector cannot appear twice in list, so there is no reason to protect iteration with a counter
      //int vismark = 0; // don't create it until necessary
      // k8: this should work with 3d floors, but now it doesn't
      int CountX = 0;
      int CountY = 0;
      bool resetCheck = false;
      TVec eorg;
      float hgt, eorgz;
      bool einited = false;
      for (msecnode_t *mnode = TouchingSectorList; mnode; mnode = mnode.TNext) {
        sector_t *sec = mnode.Sector;
        //if (self isa 'ExplosiveBarrel') printdebug("%C(%s):   SCROLLER CHECK at sector %s (%s)", self, UniqueId, sec-&XLevel.Sectors[0], sec->AffectorData);
        if (!sec->AffectorData) continue;
        hgt = sec->floor.GetPointZClamped(eorg);
        eorgz = eorg.z;
        // move objects only if on floor or underwater, non-floating, and clipped
        for (SectorThinker SecThink = SectorThinker(sec->AffectorData); SecThink; SecThink = SecThink.NextAffector) {
          auto sth = Scroller(SecThink);
          if (!sth) continue;
          resetCheck = true;
          float scrollx = sth.CarryScrollX;
          float scrolly = sth.CarryScrollY;
          if (!scrollx && !scrolly) continue;
          if (bNoGravity && (!sec->heightsec || sec->heightsec->bIgnoreHeightSec)) continue;
          if (!einited) {
            einited = true;
            eorg = Origin;
            eorgz = eorg.z;
            hgt = sec->floor.GetPointZClamped(eorg);
          }
          if (eorgz > hgt) {
            if (!sec->heightsec || sec->heightsec->bIgnoreHeightSec) continue;
            float waterheight = sec->heightsec->floor.GetPointZClamped(eorg);
            if (waterheight > hgt && eorgz >= waterheight) continue;
          }
          // don't process sectors twice (eh, it is guaranteed by the list builder)
          CummX += scrollx;
          CummY += scrolly;
          if (scrollx) ++CountX;
          if (scrolly) ++CountY;
        }
      }
      // reset check, so scroller will work next time
      if (resetCheck) lastScrollCheckOrigin = vector(-90000, -90000, -90000);

      // Some levels designed with Boom in mind actually want things to accelerate
      // at neighboring scrolling sector boundaries. But it is only important for
      // non-player objects.
      if (bIsPlayer || !Level.CompatBoomScroll) {
        if (CountX > 1) CummX /= float(CountX);
        if (CountY > 1) CummY /= float(CountY);
      }
      //if (CummX || CummY) print("%C: CALCULATED SCROLL=(%s,%s); vel=%s", self, CummX, CummY, Velocity);
    }

    //k8: re-check it only when z position or sector was changed
    if (tmp_phys_last_water_sector != Sector || Origin.z != tmp_phys_last_water_z) {
      CheckWater();
      tmp_phys_last_water_sector = Sector;
      tmp_phys_last_water_z = Origin.z;
      tmp_phys_last_floor_pic = EFloor.splane->pic;
    }
  } else {
    // still call it, because of minimum velocity clamping
    UpdateVelocity(DeltaTime, false);
  }

  //if ((self isa 'DoomImpBall') && !Level.Game.IsAuthority) printdebug("%C:000: org=%s; vel=%s", self, Origin, Velocity);

  // momentum (velocity) movement
  // handle X and Y momentums
  //sector_t *prevSector = Sector;
  float oldfloorz = FloorZ;
  float oldFloorNZ = EFloor.spGetNormalZ;
  sector_t *oldSector = Sector;
  #if 0
  if (bCorpse && Velocity.xy && !bCorpseSliding) {
    printdebug("%C(%s): vel=%s; csl=%B", self, UniqueId, Velocity, bCorpseSliding);
  }
  #endif
  if (bCorpse && bCorpseWasNudged) {
    // this is to prevent corpses to climb up the stairs
    float ohh = MaxStepHeight;
    MaxStepHeight = 0;
    XYMovement(DeltaTime, CummX, CummY, oldSector);
    MaxStepHeight = ohh;
  } else {
    XYMovement(DeltaTime, CummX, CummY, oldSector);
  }
  if (IsDestroyed) return false; // mobj was removed

  #ifdef FLOAT_BOB_IN_PHYSICS
  // moved to client ticker
  if (bFloatBob) {
    FloatBobPhase += DeltaTime;
    /* moved to renderer
    float oldFloatZ = Origin.z;
    if (bSpecial) {
      // floating item bobbing motion (special1 is height)
      if (Sector && Sector->bHasExtrafloors) {
        // make sure FloorZ is from bottom region
        Origin.z = ONFLOORZ;
        LinkToWorld();
        if (fabs(oldFloatZ-Origin.z) >= 10) oldFloatZ = Origin.z;
      }
      FloatBobPhase += DeltaTime;
      if (Sector) Origin.z = Sector->floor.GetPointZClamped(Origin)+Special1f+Level.Game.FloatBobOffsets[int(FloatBobPhase*35.0)&63];
    } else {
      // floating bobbing motion for monsters
      float savedz = Origin.z;

      Origin.z -= Level.Game.FloatBobOffsets[int(FloatBobPhase*35.0)&63];
      if (!TestMobjZ()) Origin.z = savedz;
      FloatBobPhase += DeltaTime;

      savedz = Origin.z;
      Origin.z += Level.Game.FloatBobOffsets[int(FloatBobPhase*35.0)&63];
      if (!TestMobjZ()) Origin.z = savedz;
    }

    // interpolation
    float diffz = oldFloatZ-Origin.z;
    if (diffz < 10) tmp_phys_z_change += diffz;
    */
  }
  #endif

  EntityEx onmo = EntityEx(CheckOnmobj());
  // more hacks: if we stuck in another object, not standing on it, ignore it
  // this should fix things like E1M5 pillars, where monsters are stuck in the air
  // it should also fix other instances where monsters are stuck in each other, and suspended in the air
  // this is totally wrong, but should do the job for now
  // currently, i'm doing this only for monsters; dunno if it should be done for everything
  if (onmo && bMonster && bSolid && (onmo.bMonster || onmo.bIsPlayer) && onmo.bSolid) {
    float zdelta = Origin.z-onmo.Origin.z;
    // if we are not "above enough", ignore the monster to avoid stucking
    if (zdelta < onmo.Height) {
      onmo = none;
    }
  }

  // k8: thingy bridges should be checked even if we have zero vertical velocity.
  //     the following code looks like optimization attempt, and it introduced a bug:
  //     if a player (or a monster, i think) moved into step-like thing while
  //     standing on a floor, that thing will be ignored. meh, just always check
  //     things, 'cause why not?
  if (onmo || Velocity.z ||
      (Origin.z != FloorZ &&
       /*(!bFloatBob || (!bSpecial && Origin.z-Level.Game.FloatBobOffsets[int(FloatBobPhase*35.0)&63] != FloorZ))*/
       (!bFloatBob || !bSpecial)))
  {
    if (bPassMobj && !bMissile && !Level.CompatNoPassOver) {
      // handle Z momentum and gravity
      //EntityEx onmo = EntityEx(CheckOnmobj());
      if (onmo && !onmo.bCorpse) {
        if (bIsPlayer) {
          //print("Player is on thing %C", onmo);
          if (Velocity.z < -DEFAULT_GRAVITY*0.25 && !bFly && !bNoGravity) PlayerLandedOnThing();
        }

        if (onmo.Origin.z+onmo.Height-Origin.z <= MaxStepHeight) {
          if (bIsPlayer) {
            PlayerEx pex = PlayerEx(Player);
            if (pex && pex.MO == self) {
              pex.ViewHeight -= onmo.Origin.z+onmo.Height-Origin.z;
              if (PlayerPawn(self)) pex.DeltaViewHeight = (PlayerPawn(self).GetPawnViewHeight-pex.ViewHeight)*4.0;
            }
          }
          Origin.z = onmo.Origin.z+onmo.Height;
        }

        //GZDoom does it here
        onmo.CheckDoBumpSpecial(self);

        bOnMobj = true;
        Velocity.z = 0.0;
        Crash();

        if (onmo.bOnmobjCopyVel) {
          Velocity.x = onmo.Velocity.x;
          Velocity.y = onmo.Velocity.y;
        }

        if (onmo.Origin.z < onmo.FloorZ) {
          Origin.z += onmo.FloorZ-onmo.Origin.z;
          if (onmo.bIsPlayer) {
            PlayerEx pex = PlayerEx(onmo.Player);
            if (pex && pex.MO == onmo) {
              pex.ViewHeight -= onmo.FloorZ-onmo.Origin.z;
              if (PlayerPawn(onmo)) pex.DeltaViewHeight = (PlayerPawn(onmo).GetPawnViewHeight-pex.ViewHeight)*4.0;
            }
          }
          onmo.Origin.z = onmo.FloorZ;
        }
      } else {
        ZMovement(DeltaTime, oldfloorz, oldFloorNZ, oldSector);
        bOnMobj = false;
      }
      if (IsDestroyed) return false; // entity was removed
    } else {
      // handle Z momentum and gravity
      ZMovement(DeltaTime, oldfloorz, oldFloorNZ, oldSector);
      if (IsDestroyed) return false; // entity was removed
    }
  }

  if (bStickToFloor || bStickToCeiling) {
    Velocity.z = 0;
    if (Sector) {
      Origin.z = (bStickToFloor ? FloorZ : CeilingZ-Height);
    } else {
      tmtrace_t tmtrace;
      GetFloorAndCeiling(out tmtrace);
      // no need to relink for z change
      Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
    }
    bIntrJustMoved = false; // disable movement interpolation
  } else if (Velocity.z < 0 && Origin.z == FloorZ && !bBounceFloors) {
    // do not accumulate it
    Velocity.z = 0;
  }

  // move static light, if there is any
  if (/*bStaticLight &&*/ bStaticLightSpawned) {
    Level.MoveStaticLightByOwner(self, Origin+LightOffset);
  }

  return true;
}


//==========================================================================
//
//  PerformSectorWindThrust
//
//==========================================================================
final bool PerformSectorWindThrust (float DeltaTime, sector_t *asector) {
  int secspec = asector->special&SECSPEC_BASE_MASK;
  switch (secspec) {
    case SECSPEC_WindEastSlow:
    case SECSPEC_WindEastMedium:
    case SECSPEC_WindEastFast:
      //printdebug("    EAST");
      Thrust(0.0, LineSpecialGameInfo(Level.Game).windTab[secspec-SECSPEC_WindEastSlow]*DeltaTime*35.0);
      return true;
    case SECSPEC_WindNorthSlow:
    case SECSPEC_WindNorthMedium:
    case SECSPEC_WindNorthFast:
      //printdebug("    NORTH");
      Thrust(90.0, LineSpecialGameInfo(Level.Game).windTab[secspec-SECSPEC_WindNorthSlow]*DeltaTime*35.0);
      return true;
    case SECSPEC_WindSouthSlow:
    case SECSPEC_WindSouthMedium:
    case SECSPEC_WindSouthFast:
      //printdebug("    SOUTH");
      Thrust(270.0, LineSpecialGameInfo(Level.Game).windTab[secspec-SECSPEC_WindSouthSlow]*DeltaTime*35.0);
      return true;
    case SECSPEC_WindWestSlow:
    case SECSPEC_WindWestMedium:
    case SECSPEC_WindWestFast:
      //printdebug("    WEST");
      Thrust(180.0, LineSpecialGameInfo(Level.Game).windTab[secspec-SECSPEC_WindWestSlow]*DeltaTime*35.0);
      return true;
  }
  return false;
}


//==========================================================================
//
//  XYMovement
//
//==========================================================================
final void XYMovement (float DeltaTime, float ScrollX, float ScrollY, sector_t *OldSector) {
  tmtrace_t tmtrace, tmtracetmp;

  if (bWindThrust && Sector) {
    #if 0
    // check winds for all touching sectors?
    for (msecnode_t *mnode = TouchingSectorList; mnode; mnode = mnode.TNext) {
      sector_t *sec = mnode.Sector;
      if (sec->special&SECSPEC_BASE_MASK) {
        PerformSectorWindThrust(DeltaTime, sec);
      }
    }
    #else
    if (Sector->special&SECSPEC_BASE_MASK) PerformSectorWindThrust(DeltaTime, Sector);
    #endif
  }

  float xmove = Velocity.x*DeltaTime;
  float ymove = Velocity.y*DeltaTime;
  bool forceSlide = false;
  bool absoluteSlide = true;

  if (ScrollX || ScrollY) {
    forceSlide = true;
    //if (bIsPlayer) printdebug("%C: 00: scroll=%s : %s ; vel=%s", self, ScrollX, ScrollY, Velocity);
    // scroll is already deltatime-corrected
    /*
    print("%C: scroll=(%s,%s); cst=%s; newscroll=(%s,%s); deltav=(%s,%s); v=%s; ss=%s", self, ScrollX, ScrollY, CARRYSTOPSPEED*DeltaTime,
      ScrollX*(CARRYFACTOR*DeltaTime), ScrollY*(CARRYFACTOR*DeltaTime),
      ScrollX/DeltaTime, ScrollY/DeltaTime, Velocity, STOPSPEED);
    */

    // Carrying sectors didn't work with low speeds in BOOM. This is because
    // BOOM relied on the speed being fast enough to accumulate despite
    // friction. If the speed is too low, then its movement will get
    // cancelled, and it won't accumulate to the desired speed.
    if (!GetCvarB('sv_transporters_absolute')) {
      absoluteSlide = false;
      float crStopSpeed = CARRYSTOPSPEED*DeltaTime;
      if (fabs(ScrollX) > crStopSpeed) {
        ScrollX *= CARRYFACTOR*DeltaTime;
        Velocity.x += ScrollX/DeltaTime;
      }
      if (fabs(ScrollY) > crStopSpeed) {
        ScrollY *= CARRYFACTOR*DeltaTime;
        Velocity.y += ScrollY/DeltaTime;
      }
      //print("   nv=%s", Velocity);
    }

    //if (bIsPlayer) printdebug("%C: 01: scroll=%s : %s ; vel=%s", self, ScrollX, ScrollY, Velocity);
    xmove += ScrollX;
    ymove += ScrollY;
  }

  if (!xmove && !ymove) {
    if (bSkullFly) {
      // a flying mobj slammed into something
      bSkullFly = false;
      Velocity = vector(0.0, 0.0, 0.0);
      if (Health > 0) SetState(SeeState ? SeeState : IdleState);
    } else if (bBlasted) {
      // reset to not blasted when momentums are gone
      ResetBlasted();
    }
    if (bTouchy && !IsSentient()) {
      // arm a mine which has come to rest
      bArmed = true;
    }
    //if (bIsPlayer) printdebug("***** PLAYER STANDS! ***");
    return;
  }

  // split move in multiple steps if moving too fast
  int Steps = 1;
  float MyMaxStep = fmax(fabs(xmove), fabs(ymove));
  //float MaxStep = Radius-1.0;
  float MaxStep = Radius*0.7;
       if (MaxStep <= 0.0) MaxStep = MAXMOVESTEP;
  //else if (MaxStep < 0.04) MaxStep = 0.04;

  if (MyMaxStep > MaxStep) Steps = int(MyMaxStep/MaxStep)+1;

  float StepXMove = xmove/cast(float)(Steps);
  float StepYMove = ymove/cast(float)(Steps);

  TVec oldOrigin = Origin;
  foreach (auto snum; 0..Steps) {
    float ptryx = Origin.x+StepXMove;
    float ptryy = Origin.y+StepYMove;

    if (!bNoInteraction && !TryMoveEx(out tmtrace, vector(ptryx, ptryy, Origin.z), AllowDropOff:true)) {
      // blocked move
      // check if we're a player, and can do it with crouching
      // limit autocrouch to AUTOCROUCH_LIMIT of height, and do not step up more than 2/3 of maximum climable ledge
      // sorry, Voodoo Dolls will not crouch; this may break some maps, but i'm ok with it for now
      if (bIsPlayer && Player.MO == self && crouchfactor > AUTOCROUCH_LIMIT &&
          tmtrace.FloorZ-FloorZ <= MaxStepHeight*2/3 && // max height to step up
          PlayerPawn(self) && (PlayerPawn(self).bAutoCrouch || GetCvarB('player_force_autocrouch')))
      {
        //printdebug("%C: 000: Height=%s; rng=%s; fz=%s; cz=%s; drp=%s; selffcz=%s:%s; cfactor=%s", self, Height, tmtrace.CeilingZ-tmtrace.FloorZ, tmtrace.FloorZ, tmtrace.CeilingZ, tmtrace.DropOffZ, FloorZ, CeilingZ, crouchfactor);
        PlayerEx pex = PlayerEx(Player);
        // can we crouch at all?
        if (pex && pex.CanCrouch()) {
          float hgt = PlayerPawn(self).GetRealHeight();
          float rng = tmtrace.CeilingZ-tmtrace.FloorZ;
          //printdebug("%C: 001: Height=%s; hgt=%s; rng=%s; hgtmin=%s", self, Height, hgt, rng, hgt*0.7);
          if (rng < hgt && rng >= hgt*AUTOCROUCH_LIMIT) {
            // yep, can move if we'll crouch, so let's do it
            //printdebug("   ...trying to crouch...");
            // try moving again
            float savedheight = Height; //HACK! we'd better use `GetHeight()` here, but...
            Height = hgt*AUTOCROUCH_LIMIT; // lowest possible crouch factor
            bool oktomove = TryMoveEx(out tmtracetmp, vector(ptryx, ptryy, Origin.z), AllowDropOff:true);
            Height = savedheight;
            if (oktomove) {
              // restore crouch factor, force crouching, don't slide, don't reset velocity
              //printdebug("   ...force crouching!");
              pex.bForceCrouchingDown = XLevel.TicTime+1; // last for one tick
              // return back (for now)
              TryMoveEx(out tmtracetmp, oldOrigin, AllowDropOff:true);
              return;
            }
          }
        }
      }
      if (DecalName && (bDecals2SPass || bDecalsOnly2S)) {
        //print("tracing decal '%s' (hit)", DecalName);
        if (Role == ROLE_Authority) {
          TVec spdir = Velocity.normalise();
          float spdist = length(Origin-oldOrigin)+fmax(1.0, Radius)+2.0;
          TraceSplat(oldOrigin, spdir, spdist, tr:nullptr, zofs:0, aDecalName:DecalName, pass2S:bDecals2SPass, only2S:bDecalsOnly2S, atranslation:(bCopyBloodTranslation ? Translation : 0));
        }
      }
      //if ((self isa 'DoomImpBall') && !Level.Game.IsAuthority) printdebug("%C:101: org=%s; vel=%s", self, Origin, Velocity);
      if (tmtrace.BlockingMobj) {
        //if (self isa 'DoomImpBall') printdebug("%C:600: ouid=%s; tuid=%s; muid=%s; truid=%s; org=%s; vel=%s; hitobj=%C (%s : %s)", self, OwnerSUId, TargetSUId, MasterSUId, TracerSUId, Origin, Velocity, tmtrace.BlockingMobj, tmtrace.BlockingMobj.UniqueId, tmtrace.BlockingMobj.ServerUId);
        HitMobj(tmtrace.BlockingMobj, ptryx, ptryy);
      } else {
        if (forceSlide) {
          if (absoluteSlide) {
            //k8: this is absolutely wrong! but without this, idiotic Boom transporters won't make objects slide
            tmp_transporter_velocity = vector(ScrollX/DeltaTime, ScrollY/DeltaTime);
            HitLine(ref tmtrace, DeltaTime, DeltaTime/float(Steps), forceSlide:true, OldSector:OldSector);
            tmp_transporter_velocity = vector(0, 0, 0);
          } else {
            tmp_transporter_velocity = vector(0, 0, 0);
            HitLine(ref tmtrace, DeltaTime, DeltaTime/float(Steps), forceSlide:true, OldSector:OldSector);
          }
        } else {
          #ifdef PHYSICS_DEBUG_ROCKET
          if (bMissile) {
            printdebug("%C: non-thing obstacle: bline=#%d, cline=#%d, fline=#%d; hitcount=%d; aline=#%d", self,
              (tmtrace.BlockingLine ? tmtrace.BlockingLine-&XLevel.Lines[0] : -1),
              (tmtrace.CeilingLine ? tmtrace.CeilingLine-&XLevel.Lines[0] : -1),
              (tmtrace.FloorLine ? tmtrace.FloorLine-&XLevel.Lines[0] : -1),
              tmtrace.SpecHit.length,
              (tmtrace.AnyBlockingLine ? tmtrace.AnyBlockingLine-&XLevel.Lines[0] : -1)
              );
          }
          #endif
          //tmp_transporter_velocity = vector(0, 0, 0); // just in case
          HitLine(ref tmtrace, DeltaTime, DeltaTime/float(Steps), forceSlide:false, OldSector:OldSector);
        }
      }
      return;
    }
  }

  if (DecalName && (bDecals2SPass || bDecalsOnly2S)) {
    //print("tracing decal '%s' (pass)", DecalName);
    if (Role == ROLE_Authority) {
      TVec spdir = Velocity.normalise();
      float spdist = length(Origin-oldOrigin);
      TraceSplat(oldOrigin, spdir, spdist, tr:nullptr, zofs:0, aDecalName:DecalName, pass2S:bDecals2SPass, only2S:bDecalsOnly2S, atranslation:(bCopyBloodTranslation ? Translation : 0));
    }
  }

  // reset autocrouch
  if (bIsPlayer && Player.MO == self && PlayerEx(Player).bForceCrouchingDown) {
    PlayerEx(Player).bForceCrouchingDown = 0;
  }
}


//==========================================================================
//
//  ZMovement
//
//==========================================================================
final void ZMovement (float DeltaTime, float OldFloorZ, float OldFloorNZ, sector_t *OldSector) {
  float oldz = Origin.z;
  bool wasonground = (oldz == OldFloorZ);

  //if (bIsPlayer) printdebug("000: %C: oldz=%s; FloorZ=%s; OldFloorZ=%s; z=%s; wasonground=%B; EFloor.normal=%s", self, oldz, FloorZ, OldFloorZ, Origin.z, wasonground, EFloor.spGetNormal);
  //if (bIsPlayer) printdebug("%C: JumpTime=%s", self, JumpTime);

  //Mass = (Mass.isinf ? 10000 : fclamp(Mass, 0, 10000)); // done in C++ code

  if (Sector) {
    // [RH] Double gravity only if running off a ledge. Coming down from
    // an upward thrust (e.g. a jump) should not double it.
    // Make objects fall to their own weight.
    if (oldz > FloorZ) {
      if (!bNoGravity) {
        float grav = (Gravity*Level.Gravity*(WaterLevel < 2 ? Sector->Gravity : Sector->Gravity/10.0))/1.220703125; // 9.8 (1053.52)
        if (grav.isinf) grav = 1000;
        float xmass = fmax(1, Mass);
        float prevVelZ = Velocity.z;
        if (!prevVelZ && OldFloorZ > FloorZ && wasonground) grav += grav;
        if (WaterLevel >= 2) grav /= 10.0;
        //!if (bIsPlayer) printdebug("%C: GRAVITY! vz=%s : %s  dfz=%s; wasonground=%s; sequ=%s; normz=%s", self, Velocity.z, (grav/xmass)*DeltaTime, oldz-FloorZ, wasonground, (OldSector == Sector), EFloor.spGetNormalZ);
        Velocity.z -= (grav/xmass)*DeltaTime;
        // check if we're on the same slope
        /*
        if (bIsPlayer) {
          printdebug("%C: DOWN0 delta=%s; fz=%s; vz=%s; normz=%s; ofnz=%s", self, FloorZ-oldz, FloorZ, Velocity.z, EFloor.spGetNormalZ, OldFloorNZ);
          tmtrace_t tmtrace;
          GetFloorAndCeilingEx(out tmtrace, Origin, collideWorld:true);
          printdebug("%C: DOWN1 delta=%s; fz=%s; vz=%s; normz=%s; ofnz=%s; doffz=%s", self, tmtrace.FloorZ-oldz, tmtrace.FloorZ, Velocity.z, tmtrace.EFloor.spGetNormalZ, OldFloorNZ, tmtrace.DropOffZ);
        }
        */
        if (wasonground && prevVelZ <= 0 && OldFloorNZ != 1.0 && EFloor.spGetNormalZ == OldFloorNZ) {
          //if (bIsPlayer) printdebug("%C: same slope (down)!", self);
          oldz = FloorZ;
          Origin.z = oldz;
        }
      }
    } else if (wasonground && oldz < FloorZ) {
      /*
      if (bIsPlayer) {
        printdebug("%C: UP0 delta=%s; fz=%s; vz=%s; normz=%s; ofnz=%s", self, FloorZ-oldz, FloorZ, Velocity.z, EFloor.spGetNormalZ, OldFloorNZ);
        tmtrace_t tmtrace;
        GetFloorAndCeilingEx(out tmtrace, Origin, collideWorld:true);
        printdebug("%C: UP1 delta=%s; fz=%s; vz=%s; normz=%s; ofnz=%s; doffz=%s", self, tmtrace.FloorZ-oldz, tmtrace.FloorZ, Velocity.z, tmtrace.EFloor.spGetNormalZ, OldFloorNZ, tmtrace.DropOffZ);
      }
      */
      if (!bBounceFloors) Velocity.z = fmax(0.0, Velocity.z);
      // check if we're on the same slope
      if (!Velocity.z && OldFloorNZ != 1.0 && EFloor.spGetNormalZ == OldFloorNZ) {
        #if 0
        if (bIsPlayer) {
          printdebug("%C: same slope (up)! Origin.z=%s; oldz=%s; FloorZ=%s; OldFloorZ=%s", self, Origin.z, oldz, FloorZ, OldFloorZ);
          /*
          if (OldSector != Sector) printdebug("%C: !!!sector change!", self);
          tmtrace_t ttx;
          //GetFloorAndCeiling(out ttx);
          GetFloorAndCeilingEx(out ttx, Origin+vector(0, 0, 1), collideWorld:true);
          printdebug("%C:  0:ttx.FloorZ=%s", self, ttx.FloorZ);
          GetFloorAndCeiling(out ttx);
          printdebug("%C:  1:ttx.FloorZ=%s", self, ttx.FloorZ);
          */
        }
        #endif
        //if (!GetCvarB('mv_new_slope_code'))
        {
          oldz = FloorZ;
          Origin.z = oldz;
        }
      }
    }
  }

  // check for smooth step up
  if (bIsPlayer && oldz < FloorZ) {
    PlayerEx pex = PlayerEx(Player);
    if (pex && pex.MO == self) {
      float dfz = FloorZ-oldz;
      // arbitrary number
      //if (/*dfz > 0.6*/ || EFloor.spGetNormalZ == 1.0)
      {
        pex.ViewHeight -= dfz;
        pex.DeltaViewHeight = (PlayerPawn(self).GetPawnViewHeight-pex.ViewHeight)*4.0;
      }
    }
  }

  // adjust height
  // k8: nope, floatbob is affected by gravity too
  /*if (!bFloatBob)*/ Origin.z += Velocity.z*DeltaTime;
  float origz = Origin.z;

  if (bFloat && !bDormant && Target) {
    // float down towards enemy if too close
    if (!bSkullFly && !bInFloat) {
      float dist = DistTo2(Target);
      float delta = Target.Origin.z+Height/2.0-origz;
      if (delta < 0.0 && dist < -(delta*3.0)) {
        Velocity.z = 0.0;
        EntityEx onmo = EntityEx(CheckOnmobj());
        if (((onmo && onmo.TestMobjZ()) || !onmo) && TestMobjZ()) {
          Origin.z -= FloatSpeed*DeltaTime;
        } else {
          return;
        }
      } else if (delta > 0.0 && dist < delta*3.0) {
        Velocity.z = 0.0;
        EntityEx onmo = EntityEx(CheckOnmobj());
        if (((onmo && onmo.TestMobjZ()) || !onmo) && TestMobjZ()) {
          Origin.z += FloatSpeed*DeltaTime;
        } else {
          return;
        }
      }
      origz = Origin.z;
    }
  }

  if (bIsPlayer && bFly && origz > FloorZ /*&& (XLevel.TicTime&2)*/) {
    //FIXME: this is time-dependent, rewrite! (it was)
    //Origin.z += sin(90.0*35.0/20.0*AngleMod360(int(XLevel.Time)))/2.0;
    auto plx = PlayerEx(Player);
    if (plx && !(plx.Cheats&PlayerEx::CF_NOCLIP)) {
      Origin.z = plx.CalcFlyZ(Origin.z);
      origz = Origin.z;
    }
  }

  // clip movement
  // don't do this for "no interaction, no blockmap, no gravity"
  // but do for things that should move with sector
  if (bMoveWithSector || bIsPlayer || bMonster || bMissile || !(bNoInteraction || bNoGravity || bNoBlockmap)) {
    //if (bMissile) printdebug("%C: HitFloor: z=%s; floorz=%s; hit=%B", self, Origin.z, FloorZ, (Origin.z <= FloorZ+0.1));
    if (origz < FloorZ+0.1) {
      // hit the floor
      //if (bIsPlayer && oldz < FloorZ) printdebug("%C: HitFloor: oldz=%s; z=%s; floorz=%s; vz=%s; sector=%d", self, oldz, Origin.z, FloorZ, Velocity.z, (Sector ? Sector-&XLevel.Sectors[0] : -1));
      //FIXME: hack for bullet puffs (not working yet)
      /*
      if (!bIsPlayer && !bMonster && !bMissile) {
        if (Sector && Sector->ownpobj && origz != FloorZ && Velocity.z >= 0.0) {
          //printdebug("333: %C: oldz=%s; FloorZ=%s; z=%s", self, oldz, FloorZ, Origin.z);
          if (origz+Height == CeilingZ) {
            if (!HitCeiling(oldz, OldSector)) return;
          }
          return;
        }
      }
      */
      if (!HitFloor(oldz, OldSector)) return;
      origz = Origin.z;
    }

    if (origz+Height > CeilingZ) {
      // hit the ceiling
      if (!HitCeiling(oldz, OldSector)) return;
    }

    CheckFakeFloorTriggers(oldz);
  }
}


//==========================================================================
//
//  HitLine
//
//  if entity is moving with transporter, it should slide along walls
//  in any case
//
//==========================================================================
final void HitLine (ref tmtrace_t tmtrace, float DeltaTime, float StepVelScale, bool forceSlide, sector_t *OldSector) {
  #ifdef PHYSICS_DEBUG_ROCKET
  if (bMissile) printdebug("%C: HitLine #%d", self, (tmtrace.BlockingLine ? tmtrace.BlockingLine-&XLevel.Lines[0] : -1));
  #endif

  // it may hit a sloped 3d floor
  if (!bNoInteraction && !tmtrace.BlockingLine && bMissile && SectorHas3DSlopes(Sector)) {
    //printdebug("%C: z=%s; FloorZ=%s; CeilingZ=%s; hitf=%B; hitc=%B", self, Origin.z, tmtrace.FloorZ, tmtrace.CeilingZ, (Origin.z <= tmtrace.FloorZ+0.1), (Origin.z+Height > tmtrace.CeilingZ));
    float origz = Origin.z;
    if (origz <= tmtrace.FloorZ+0.1) {
      // hit the floor
      FloorZ = tmtrace.FloorZ; // we need to do this to register a hit
      if (!HitFloor(/*oldz*/origz, OldSector)) return;
      return;
    }

    if (origz+Height > tmtrace.CeilingZ) {
      // hit the ceiling
      CeilingZ = tmtrace.CeilingZ; // we need to do this to register a hit
      if (!HitCeiling(/*oldz*/origz, OldSector)) return;
      return;
    }

    CheckFakeFloorTriggers(/*oldz*/origz);
    return;
  }

  if (bMissile) {
    if (tmtrace.BlockingLine && tmtrace.BlockingLine->special == LNSPEC_LineHorizon) {
      #ifdef PHYSICS_DEBUG_ROCKET
      if (bMissile) printdebug("%C:   HORIZON", self);
      #endif
      SightSound = '';
      Destroy();
      return;
    }


    #if 1
    // skyhack
    if (tmtrace.CeilingLine) {
      int siden = PointOnPlaneSide(Origin-Velocity*2, ref *tmtrace.CeilingLine);
      sector_t *sec = (siden ? tmtrace.CeilingLine->frontsector : tmtrace.CeilingLine->backsector);
      // explode a missile against sky ceilings
      if (sec && sec->ceiling.pic == Level.Game.skyflatnum) {
        float secz = sec->ceiling.maxz;
        bool hitsky = (secz <= tmtrace.End.z);
        #ifdef PHYSICS_DEBUG_ROCKET
        if (bMissile) printdebug("%C:  SKY-CEILING: secz=%s; endz=%s; hitsky=%B", self, secz, tmtrace.End.z, hitsky);
        #endif
        if (hitsky) {
               if (bBounceSky) Velocity = vector(0.0, 0.0, -1.0*35.0);
          else if (bExplodeOnSky) ExplodeMissile(none);
          else Destroy();
          return;
        }
      }
    }
    // floor skyhack: do we even have those?
    if (tmtrace.FloorLine) {
      int siden = PointOnPlaneSide(Origin-Velocity*2, ref *tmtrace.FloorLine);
      sector_t *sec = (siden ? tmtrace.FloorLine->frontsector : tmtrace.FloorLine->backsector);
      // explode a missile against sky floors
      if (sec && sec->floor.pic == Level.Game.skyflatnum) {
        float secz = sec->floor.maxz;
        bool hitsky = (secz >= tmtrace.End.z);
        #ifdef PHYSICS_DEBUG_ROCKET
        if (bMissile) printdebug("%C:  SKY-FLOOR: secz=%s; endz=%s; hitsky=%B", self, secz, tmtrace.End.z, hitsky);
        #endif
        if (hitsky) {
               if (bBounceSky) Velocity = vector(0.0, 0.0, -1.0*35.0);
          else if (bExplodeOnSky) ExplodeMissile(none);
          else Destroy();
          return;
        }
      }
    }
    #else
    //k8: this seems to be buggy
    // explode a missile against sky ceilings
    if (tmtrace.CeilingLine && tmtrace.CeilingLine->backsector &&
        tmtrace.CeilingLine->backsector->ceiling.pic == Level.Game.skyflatnum)
    {
      #ifdef PHYSICS_DEBUG_ROCKET
      if (bMissile) printdebug("%C:   CEILING SKY", self);
      #endif
      // hack to prevent missiles exploding against the sky
      // does not handle sky floors
      //k8: why it is a floor here?
      float zfront = tmtrace.CeilingLine->frontsector->floor.maxz;
      float zback = tmtrace.CeilingLine->backsector->floor.maxz;
      bool hitsky = true;
      #ifdef PHYSICS_DEBUG_ROCKET
      if (bMissile) printdebug("%C:     zfront=%s; zback=%s", self, zfront, zback);
      #endif
      if (zfront != zback) {
        int siden = PointOnPlaneSide(Origin-Velocity*2, ref *tmtrace.CeilingLine);
        #ifdef PHYSICS_DEBUG_ROCKET
        if (bMissile) printdebug("%C:     siden=%s; endz=%s", self, siden, tmtrace.End.z);
        #endif
        if (!siden) {
          // front side
          hitsky = (zfront < zback && tmtrace.End.z > zback);
        } else {
          // back side
          hitsky = (zback < zfront && tmtrace.End.z > zfront);
        }
      }
      if (hitsky) {
             if (bBounceSky) Velocity = vector(0.0, 0.0, -1.0*35.0);
        else if (bExplodeOnSky) ExplodeMissile(none);
        else Destroy();
        return;
      }
    }

    // explode a missile against sky floors
    if (tmtrace.FloorLine && tmtrace.FloorLine->backsector &&
        tmtrace.FloorLine->backsector->ceiling.pic == Level.Game.skyflatnum)
    {
      #ifdef PHYSICS_DEBUG_ROCKET
      if (bMissile) printdebug("%C:   CEILING FLOOR", self);
      #endif
      // hack to prevent missiles exploding against the sky
      // does not handle sky floors
      float zfront = tmtrace.FloorLine->frontsector->floor.maxz;
      float zback = tmtrace.FloorLine->backsector->floor.maxz;
      bool hitsky = true;
      #ifdef PHYSICS_DEBUG_ROCKET
      if (bMissile) printdebug("%C:     zfront=%s; zback=%s", self, zfront, zback);
      #endif
      if (zfront != zback) {
        int siden = PointOnPlaneSide(Origin-Velocity*2, ref *tmtrace.FloorLine);
        #ifdef PHYSICS_DEBUG_ROCKET
        if (bMissile) printdebug("%C:     siden=%s; endz=%s", self, siden, tmtrace.End.z);
        #endif
        if (!siden) {
          // front side
          hitsky = (zfront < zback && tmtrace.End.z > zback);
        } else {
          // back side
          hitsky = (zback < zfront && tmtrace.End.z > zfront);
        }
      }
      if (hitsky) {
             if (bBounceSky) Velocity = vector(0.0, 0.0, 1.0*35.0);
        else if (bExplodeOnSky) ExplodeMissile(none);
        else Destroy();
        return;
      }
    }
    #endif

    if (tmtrace.BlockingLine) {
      // struck a wall
      if (bBounceWalls || BounceType == BOUNCE_Doom || BounceType == BOUNCE_Hexen) {
        // if number of bounces is limited
        if (BounceCount > 0 && --BounceCount <= 0) {
          ExplodeMissile(none, line:tmtrace.BlockingLine);
          return;
        }

        BounceWall(DeltaTime, tmtrace.BlockingLine, BOUNCE_VAL, WallBounceFactor);
        if (!bNoBounceSound && !bNoWallBounceSnd && (WallBounceSound || BounceSound || SightSound)) {
          PlaySound((WallBounceSound ? WallBounceSound : BounceSound ? BounceSound : SightSound), CHAN_VOICE);
        }
        if (bBounceUseState) SetWallBounceState();
        // wall bouncing never changes `Velocity.z`, so there is no need to check for stop here
        return;
      }
    }

    line_t *hitline = tmtrace.BlockingLine;
    if (!hitline) hitline = tmtrace.CeilingLine;
    if (!hitline) hitline = tmtrace.FloorLine;
    if (!hitline) hitline = tmtrace.AnyBlockingLine; //k8: nope; this was my hack, and it is wrong here
    if (!hitline && tmtrace.SpecHit.Length) {
      bool wasBlockAll = false;
      line_t *blockall;
      foreach (int f; 0..tmtrace.SpecHit.Length) {
        line_t *ln = tmtrace.SpecHit[f];
        if (ln->flags&ML_BLOCKING) { hitline = ln; break; }
        if (!wasBlockAll && (ln->flags&ML_BLOCKEVERYTHING) != 0) { blockall = ln; wasBlockAll = true; }
      }
      if (!hitline) {
        if (wasBlockAll) hitline = blockall; else hitline = tmtrace.SpecHit[0];
      }
    }

    // wtf?!
    if (!hitline) {
      #ifdef PHYSICS_DEBUG_ROCKET
      if (bMissile) printdebug("%C:   HitLine without a line", self);
      #endif
      //printwarn("missile '%C' get to `HitLine` without a blocking line; THIS IS ENGINE BUG!!!", self);
      Destroy();
      return;
    }

    // just in case, again
    if (hitline->special == LNSPEC_LineHorizon) {
      if (bBounceSky) Velocity = vector(0.0, 0.0, -1.0*35.0); else Destroy();
      return;
    }

    #ifdef PHYSICS_DEBUG_ROCKET
    if (bMissile) printdebug("%C:   HitLine -- explode", self);
    #endif
    ExplodeMissile(none, hitline);
  } else if (bSlide || forceSlide ||
             (bCorpse && (bCorpseSliding || GetCvarB('gm_corpse_slidemove'))))
  {
    // try to slide for transporter
    if (forceSlide) {
      if (tmp_transporter_velocity) {
        TVec oldvel = Velocity;
        Velocity = tmp_transporter_velocity;
        SlideMove(StepVelScale);
        Velocity = oldvel;
      }
    }
    // try to slide with the original velocity
    SlideMove(StepVelScale);
  } else {
    Velocity.x = 0.0;
    Velocity.y = 0.0;
  }
}


//==========================================================================
//
//  HitMobj
//
//==========================================================================
final void HitMobj (Entity Other, float ptryx, float ptryy) {
  float angle;
  float bncspeed;
  float sina, cosa;

  if (bMissile) {
    EntityEx otherEnt = EntityEx(Other);

    if (bBounceOnActors || bBounceOnAllActors || BounceType == BOUNCE_Doom || BounceType == BOUNCE_Hexen) {
      // if number of bounces is limited
      if (BounceCount > 0 && --BounceCount <= 0) {
        ExplodeMissile(none);
        return;
      }

      if (bDontBounceShootables && otherEnt.bShootable) {
        ExplodeMissile(otherEnt);
        return;
      }

      // bounce against walls and non-killable objects
      //if ((bBounceOnActors || otherEnt.bReflective || (!Other.bIsPlayer && !otherEnt.bMonster) || !otherEnt.IsSentient()) ||
      //    otherEnt.bBounceOnAllActors)
      if (bBounceOnAllActors ||
          //k8: no, GZDoom doesn't check this:otherEnt.bBounceOnAllActors || /* other is absolutely bounceable */
          (!Other.bIsPlayer && !otherEnt.bMonster) || /* not a player, and not a monster */
          !otherEnt.IsSentient() || /* non-sentient monster */
          /* ripper checks (only for reflective monsters; dunno, GZDoom does it like this) */
          (otherEnt.bReflective && (!bRip || !otherEnt.bDontRip || (bNoBossRip && otherEnt.bBoss) || !CheckRipLevel(otherEnt))))
      {
        //printwarn("%C: BOUNCE! actb=%B; allactb=%B; other=%C; refl=%B, sent=%B", self, bBounceOnActors, bBounceOnAllActors, otherEnt, otherEnt.bReflective, otherEnt.IsSentient());
        //printwarn("    ooball=%B", otherEnt.bBounceOnAllActors);
        angle = AngleMod360(atan2(Origin.y-Other.Origin.y, Origin.x-Other.Origin.x)+(Random()*16.0-8.0));
        bncspeed = Length(Velocity)*WallBounceFactor;
        Angles.yaw = angle;
        sincos(angle, out sina, out cosa);
        Velocity.x = bncspeed*cosa;
        Velocity.y = bncspeed*sina;
        if (!bNoBounceSound && (BounceSound || SightSound)) {
          PlaySound((BounceSound ? BounceSound : SightSound), CHAN_VOICE);
        }
        if (bBounceUseState) SetActorBounceState(otherEnt);
      } else {
        // struck a player/creature
        //printwarn("%C: EXPLODE!", self);
        ExplodeMissile(otherEnt);
      }
      return;
    }

    if (otherEnt.bReflective) {
      angle = otherEnt.GetReflectedAngle(self);
      if (angle != -1.0) {
        // reflect the missile along angle
        Angles.yaw = angle;
        sincos(angle, out sina, out cosa);
        Velocity.x = (Speed/2.0)*cosa;
        Velocity.y = (Speed/2.0)*sina;
        Velocity.z = -Velocity.z*0.5;
        if (bSeekerMissile) Tracer = Target;
        Target = otherEnt;
        return;
      }
    }

    // explode a missile
    ExplodeMissile(otherEnt);
  } else if (bSlide) {
    // try to slide along it
    // slide against mobj
         if (TryMove(vector(Origin.x, ptryy, Origin.z), AllowDropOff:true)) Velocity.x = 0.0;
    else if (TryMove(vector(ptryx, Origin.y, Origin.z), AllowDropOff:true)) Velocity.y = 0.0;
    else { Velocity.x = 0.0; Velocity.y = 0.0; }
  } else {
    Velocity.x = 0.0;
    Velocity.y = 0.0;
  }
}


//==========================================================================
//
//  HitFloor
//
//==========================================================================
final bool HitFloor (float prevz, sector_t *OldSector) {
  // trigger hit floor sector actions
  // k8: trigger always, or only when just landed? it was always
  if (Sector && OldSector != Sector && Sector->ActionList && Sector->floor.GetPointZClamped(Origin) == FloorZ) {
    SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_HitFloor);
  }

  bool justLanded = (prevz > FloorZ);

  // killough 11/98: touchy objects explode on impact
  // allow very short drops to be safe, so that a touchy can be summoned without exploding
  if (bTouchy && (bArmed || IsSentient()) && Velocity.z < -5.0) {
    bArmed = false; // disarm
    if (Level.Game.IsAuthority) {
      // if we have no velocity, don't bother interpolating
      if (Velocity.xy && Origin.z > FloorZ) tmp_phys_z_change += FloorZ-Origin.z;
      Damage(none, none, Health, spawnBlood:true);  // kill object
    }
    return true;
  }

  if (bMissile && (bColideWithWorld || !LineSpecialGameInfo(Level.Game).bNoClipIgnoreFloor)) {
    // physics caller will setup interpolation with `tmp_phys_z_change`
    // if we have no velocity, don't bother interpolating
    if (Velocity.xy && Origin.z > FloorZ) tmp_phys_z_change += FloorZ-Origin.z;
    Origin.z = FloorZ;
    if (bBounceFloors || BounceType != BOUNCE_None) {
      FloorBounceMissile();
      return false;
    }
    if (bNoExplodeFloor) {
      // the spirit struck the ground
      Velocity.z = 0.0;
      HitFloorType(justLanded);
      return false;
    }
    if (bIgnoreFloorStep) {
      // minotaur floor fire can go up steps
      return false;
    }
    HitFloorType(justLanded);
    ExplodeMissile(none);
    return false;
  }

  TVec fnorm = EFloor.spGetNormal;

  float vdot = DotProduct(Velocity, fnorm);
  if (bMonster && Level.Game.IsAuthority) {
    // blasted mobj falling
    if (vdot < -23.0*35.0) MonsterFallingDamage();
  }

  // physics caller will setup interpolation with `tmp_phys_z_change`
  // if we have no velocity, don't bother interpolating
  if (Velocity.xy && Origin.z > FloorZ) tmp_phys_z_change += FloorZ-Origin.z;
  Origin.z = FloorZ;

  if (vdot < -0.1) {
    // spawn splashes, etc
    //if (bIsPlayer) printdebug("000: %C: Velocity=%s; vdot=%s", self, Velocity, vdot);
    HitFloorType(justLanded);
    if (!Inventory(self) && nameicmp(DamageType, 'Ice') == 0 && /*vdot*/Velocity.z < -DEFAULT_GRAVITY*0.25) {
      StateTime = 0.1;
      Velocity.z = 0.0;
      return false;
    }
    if (!bIsPlayer && bCanJump && Velocity.z < 0.0 && JumpTime <= 0.0) JumpTime = 0.5; // delay any jumping for a short time
    // do some special action when hitting the floor
    OnHitFloor();
    if (bIsPlayer && Player) {
      //k8: dunno why -6, i just pulled it from my ass
      if (Velocity.z < -6.0 && PlayerEx(Player).JumpTime <= 0.0) {
        //printdebug("%C: jumpblock! velz=%s; fnz=%s", self, Velocity.z, EFloor.spGetNormalZ);
        PlayerEx(Player).JumpTime = 0.2; // delay any jumping for a short time
      }
      //printdebug("%C: vdot=%s %s (%s)", self, vdot, Velocity.z, -DEFAULT_GRAVITY*0.25);
      if (/*vdot*/Velocity.z < -DEFAULT_GRAVITY*0.25 && !bNoGravity) {
        // squat down
        // decrease ViewHeight for a moment after hitting the ground (hard), and utter appropriate sound
        PlayerLandedOnThing();
      }
    }
    if (!bSkullFly && Velocity.z < 0.0) Velocity.z = 0.0;
    //if (bIsPlayer) printdebug("001: %C: Velocity=%s; vdot=%s", self, Velocity, vdot);
  } else {
    if (!bSkullFly && Velocity.z < 0.0) Velocity.z = 0.0;
  }

  if (bSkullFly) {
    // the skull slammed into something
    //Velocity.z = -Velocity.z;
    Velocity.z = fabs(Velocity.z);
  }

  Crash();
  return true;
}


//==========================================================================
//
//  HitCeiling
//
//==========================================================================
final bool HitCeiling (float prevz, sector_t *OldSector) {
  // trigger hit ceiling sector actions
  if (Sector && OldSector != Sector && Sector->ActionList && Sector->ceiling.GetPointZClamped(Origin+vector(0, 0, Height)) == CeilingZ) {
    SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_HitCeiling);
  }

  // physics caller will setup interpolation with `tmp_phys_z_change`
  // if we have no velocity, don't bother interpolating
  float fixz = CeilingZ-Height;
  if (FloorZ <= CeilingZ && fixz < FloorZ) fixz = FloorZ;
  //printdebug("%C:  HITCEILING! prevz=%s; z=%s; fixz=%s", self, prevz, Origin.z, fixz);
  if (Velocity.xy) tmp_phys_z_change += fixz-Origin.z;
  Origin.z = fixz;

  if (bMissile && (bColideWithWorld || !LineSpecialGameInfo(Level.Game).bNoClipIgnoreFloor)) {
    if (bBounceCeilings || BounceType != BOUNCE_None) {
      CeilingBounceMissile();
      return false;
    }
    if (bIgnoreCeilingStep) return false;
    if (ECeiling.splane->pic == Level.Game.skyflatnum) {
           if (bBounceSky) Velocity = vector(0.0, 0.0, -1.0*35.0);
      else if (bExplodeOnSky) ExplodeMissile(none);
      else Destroy();
      return false;
    }
    ExplodeMissile(none);
    return false;
  }

  float vdot = DotProduct(Velocity, ECeiling.spGetNormal());

  if (vdot < 0.0) {
    TVec Vel = vdot*ECeiling.spGetNormal();
    Velocity.z -= Vel.z;
  }

  if (bSkullFly) {
    // the skull slammed into something
    Velocity.z = -fabs(Velocity.z);
  }

  return true;
}


//==========================================================================
//
//  TurnOffAllBouncingFlags
//
//==========================================================================
void TurnOffAllBouncingFlags () {
  BounceType = BOUNCE_None;
  bBounceSky = false;
  bBounceWalls = false;
  bBounceFloors = false;
  bBounceCeilings = false;
  bBounceOnActors = false;
  bBounceOnAllActors = false;
  bBounceLikeHeretic = false;
}


//==========================================================================
//
//  SetWallBounceState
//
//==========================================================================
void SetWallBounceState () {
  state bst = FindState('Bounce', 'Wall');
  if (!bst) bst = FindState('Bounce');
  if (bst) SetState(bst);
}


//==========================================================================
//
//  SetActorBounceState
//
//==========================================================================
void SetActorBounceState (EntityEx other) {
  state bst = none;
  if (other) {
    if (other.bShootable && !other.bNoBlood) bst = FindState('Bounce', 'Actor.Creature');
    if (!bst) bst = FindState('Bounce', 'Actor');
  }
  if (!bst) bst = FindState('Bounce');
  if (bst) SetState(bst);
}


//==========================================================================
//
//  SetFloorCeilingBounceState
//
//==========================================================================
void SetFloorCeilingBounceState (float normz) {
  state bst = FindState('Bounce', (normz >= 0.0f ? 'Floor' : 'Ceiling'));
  if (!bst) bst = FindState('Bounce');
  if (bst) SetState(bst);
}


//==========================================================================
//
//  FlatBounceMissile
//
//  common missile bounce code for floors and ceilings
//
//==========================================================================
void FlatBounceMissile (TVec norm) {
  // if number of bounces is limited
  if (BounceCount > 0 && --BounceCount <= 0) {
    ExplodeMissile(none);
    return;
  }

  //printdebug("%C:%s:000: flat bounce (%s), count=%s; vel=%s; minz=%s", self, UniqueId, norm, BounceCount, Velocity, (fmax(1, Mass)*Gravity)/64.0*35.0);
  float vdot = DotProduct(Velocity, norm);
  //if (self isa 'CryBallMini') printdebug("%C:%s: FlatBounceMissile:000: vel=%s : org=%s : norm=%s : vdot=%s", self, UniqueId, Velocity, Origin, norm, vdot);

  if (bBounceLikeHeretic || (BounceType == BOUNCE_Heretic && !bMBFBounce)) {
    Velocity -= 2.0*(vdot*norm);
    if (fsign(Velocity.z) != fsign(norm.z)) Velocity.z = -Velocity.z; // ensure that it is bounced in the right direction
    Angles.yaw = atan2(Velocity.y, Velocity.x);
    SetState(FindState('Death'));
    return;
  }

  if (bMBFBounce) {
    Velocity -= 2.0*(vdot*norm);
    Velocity.z = Velocity.z*BounceFactor;
    Angles.yaw = atan2(Velocity.y, Velocity.x);
  } else {
    //Velocity = (Velocity-(2.0*(vdot*norm)))*BounceFactor;
    Velocity -= 2.0*(vdot*norm);
    Velocity.z *= BounceFactor;
    Angles.yaw = atan2(Velocity.y, Velocity.x);
  }

  // play bounce sound
  if (!bNoBounceSound && (BounceSound || SightSound)) {
    PlaySound((BounceSound ? BounceSound : SightSound), CHAN_VOICE);
  }

  if (fsign(Velocity.z) != fsign(norm.z)) Velocity.z = -Velocity.z; // ensure that it is bounced in the right direction

  if (bMBFBounce) {
    if (fabs(Velocity.z) < (fmax(1, Mass)*Gravity)/64.0*35.0) {
      // bring it to rest below a certain speed
      Velocity.z = 0.0;
    }
  } else {
    //printdebug("%C:%s:001: flat bounce (%s), count=%s; vel=%s; minz=%s", self, UniqueId, norm, BounceCount, Velocity, (fmax(1, Mass)*Gravity)/64.0*35.0);
    //if (self isa 'CryBallMini') printdebug("%C:%s: FlatBounceMissile:001: vel=%s : org=%s : norm=%s : vdot=%s", self, UniqueId, Velocity, Origin, norm, vdot);
    if (bBounceAutoOff || BounceType == BOUNCE_Doom) {
      if (!bNoGravity && Velocity.z < DOOM_BOUNCE_STOP_VEL) {
        TurnOffAllBouncingFlags(); // otherwise it will bounce forever
      }
    }
  }
  //if (self isa 'CryBallMini') printdebug("%C:%s: FlatBounceMissile:002: vel=%s : org=%s : norm=%s : vdot=%s", self, UniqueId, Velocity, Origin, norm, vdot);

  if (bBounceUseState) SetFloorCeilingBounceState(norm.z);
}


//==========================================================================
//
//  FloorBounceMissile
//
//==========================================================================
void FloorBounceMissile () {
  if (HitFloorType()) {
    // landed on some kind of liquid
    if (bExplodeOnWater) {
      ExplodeMissile(none);
      return;
    }
    if (!bCanBounceWater) {
      Destroy();
      return;
    }
  }

  FlatBounceMissile(EFloor.spGetNormal());
}


//==========================================================================
//
//  CeilingBounceMissile
//
//==========================================================================
void CeilingBounceMissile () {
  FlatBounceMissile(ECeiling.spGetNormal());
}


//==========================================================================
//
//  GetReflectedAngle
//
//==========================================================================
float GetReflectedAngle (EntityEx Other) {
  if (Other.bDontReflect) return -1.0;

  if (bAimReflect && Other.Target && Other.Target != Other) {
    // direction from us to the target
    float a2 = atan2(Other.Target.Origin.y-Origin.y, Other.Target.Origin.x-Origin.x);
    return AngleMod360(a2+180.0);
  }

  // direction from us to the target
  float angle = atan2(Other.Origin.y-Origin.y, Other.Origin.x-Origin.x);

  if (bMirrorReflect) {
    return AngleMod360(angle+180.0);
  }

  if (bShieldReflect) {
    // change angle for delflection/reflection
    if (fabs(AngleMod180(angle-Angles.yaw)) > 45.0*45.0/32.0) return -1.0;
    if (Other.bDontShieldReflect) return -1.0;
    // deflection
         if (Random() < 0.5) angle = AngleMod360(angle+45.0);
    else angle = AngleMod360(angle-45.0);
    return angle;
  }

  if (bDeflect) {
    // change angle for delflection
         if (Random() < 0.5) angle = AngleMod360(angle+45.0);
    else angle = AngleMod360(angle-45.0);
    return angle;
  }

  // change angle for reflection
  angle = AngleMod360(angle+Random()*16.0-8.0);
  return angle;
}


//==========================================================================
//
//  Crash
//
//==========================================================================
void Crash () {
  if (bCorpse && !bCrashed && !nameEquCI(DamageType, 'Ice')) {
    state CrashState = FindState('Crash', DamageType, false); // non-exact
    if (CrashState) {
      SetState(CrashState);
      bCrashed = true;
    }
  }
}


//===========================================================================
//
//  PlayerLandedOnThing
//
//===========================================================================
void PlayerLandedOnThing () {
  auto pex = PlayerEx(Player);
  if (pex && pex.MO == self) pex.DeltaViewHeight = Velocity.z/8.0;
  FallingDamage();
  if (Health > 0 && pex && !pex.MorphTime) {
    //printdebug("%C: vel=%s", self, Velocity.z);
    //float gruntS = DEFAULT_GRAVITY*0.375;
    auto pp = PlayerPawn(self);
    float gruntS = (pp ? pp.GruntSpeed*35.0 : DEFAULT_GRAVITY*0.375);
    if (gruntS > 0.0) {
      //printdebug("%C: vel=%s; gs=%s", self, Velocity.z, gruntS);
      if (Velocity.z < -gruntS) {
        //printdebug("%C: ***grunt***", self);
        PlaySound('*grunt', CHAN_VOICE);
      }
    }
    if ((Origin.z > FloorZ || !GetActorTerrain()->bLiquid) && !AreSoundsEquivalent('*grunt', '*land')) {
      PlaySound('*land', CHAN_BODY);
    }
  }
  //FIXME Player.centering = true;
}


//==========================================================================
//
//  FallingDamage
//
//==========================================================================
void FallingDamage () {
  //print("fdam: %B %B %B", Level.bFallingDamage, Level.bOldFallingDamage, Level.bStrifeFallingDamage);
  int damage;
  float dist;

  if (Sector && Sector->bNoFallingDamage) return;
  if (!Level.Game.IsAuthority) return;

  float mom = fabs(Velocity.z);

  if (Level.bFallingDamage) {
    // Hexen style falling damage
    if (mom <= 23.0*35.0) return; // not fast enough
    if (mom >= 63.0*35.0) {
      damage = 10000; // automatic death
    } else {
      dist = mom/35.0*16.0/23.0;
      damage = int(dist*dist/10.0)-24;
      if (Velocity.z > -39.0*35.0 && damage > Health && Health != 1) {
        // no-death threshold
        damage = Health-1;
      }
    }
  } else if (Level.bOldFallingDamage) {
    // ZDoom style falling damage, less damaging
    if (mom <= 19.0*35.0) return; // not fast enough
    if (mom >= 84.0*35.0) {
      damage = 10000; // automatic death
    } else {
      mom = mom/35.0;
      damage = (int(mom*mom*11.0/128.0)-30)/2;
      if (damage < 1) damage = 1;
    }
  } else if (Level.bStrifeFallingDamage) {
    // Strife style falling damage, very strong
    if (mom <= 20.0*35.0) return; // not fast enough
    damage = int(mom*(8192.0/3125.0/35.0));
  } else {
    return;
  }

  Damage(none, none, damage, 'Falling', spawnBlood:true);
  LineSpecialLevelInfo(Level).NoiseAlert(self, self);
}


//==========================================================================
//
//  MonsterFallingDamage
//
//==========================================================================
void MonsterFallingDamage () {
  int damage;
  float mom;

  if (!Level.bMonsterFallingDamage) return;
  if (Sector && Sector->bNoFallingDamage) return;
  if (!Level.Game.IsAuthority) return;

  mom = fabs(Velocity.z)/35.0;
  if (mom > 35.0) {
    // automatic death
    damage = 10000;
  } else {
    damage = int((mom-23.0)*6.0);
  }
  damage = 10000; // always kill 'em
  Damage(none, none, damage, 'Falling', spawnBlood:true);
}


//==========================================================================
//
//  ResetBlasted
//
//==========================================================================
void ResetBlasted () {
  bBlasted = false;
  //if (!bIceCorpse) bSlide = false;
  bSlide = default.bSlide;
}


//==========================================================================
//
//  OnHitFloor
//
//==========================================================================
void OnHitFloor () {
}


//==========================================================================
//
//  CheckSplash
//
//  Checks for splashes caused by explosions
//
//==========================================================================
void CheckSplash (float distance) {
  if (Origin.z <= FloorZ+distance) {
    // Explosion splashes never alert monsters. This is because A_Explode has
    // a separate parameter for that so this would get in the way of proper
    // behavior.
    HitFloorType();
  }
}


//==========================================================================
//
//  HitFloorType
//
//==========================================================================
bool HitFloorType (optional bool justLanded) {
  // things that don't splash go here
  if (bFloatBob || bNoSplash) return false;
  if (!Level.Game.IsAuthority) return false;

  // 3d floors
  sector_t *tsec = GetTouchedFloorSector();
  if (!tsec) {
    //if (bIsPlayer) printdebug("%C: orgz=%s; fz=%s", self, Origin.z, FloorZ);
    // don't splash if landing on the edge above water/lava/etc....
    return false;
  }
  //if (bIsPlayer && tsec != Sector) printdebug("%C: orgz=%s; fz=%s", self, Origin.z, FloorZ);
  // don't splash if landing on the edge above water/lava/etc....
  //if (FloorZ != tsec->floor.GetPointZClamped(Origin)) return false;

  /*
  if (!Sector || FloorZ != Sector->floor.GetPointZClamped(Origin)) {
    // don't splash if landing on the edge above water/lava/etc....
    //if (bIsPlayer) printdebug("%C: orgz=%s; fz=%s", self, Origin.z, FloorZ);
    return false;
  }
  */

  VTerrainInfo *TInfo = GetActorTerrain();
  //if (bIsPlayer /*&& tsec != Sector*/) printdebug("%C: orgz=%s; fz=%s; TInfo->DamageAmount=%s; floor=%s", self, Origin.z, FloorZ, TInfo->DamageAmount, EFloor.splane->pic);

  // small splash for small masses
  bool smallsplash = (Mass < 10.0 || bSmallSplash);

  // this should be done for Voodoo Dolls only, because for the main player entity it is done in `PlayerEx`
  // also, don't do it more than once per tick
  if (bIsPlayer) {
    PlayerEx pex = PlayerEx(Player);
    if (TInfo->DamageAmount) {
      if (XLevel.TicTime&TInfo->DamageTimeMask) {
        bool doIt = true;
        if (pex) {
               if (pex.MO == self) doIt = false; // check for Voodoo Doll
          else if (pex.LastSectorDamageTic >= XLevel.TicTime) doIt = false; // check for proper tick
          // apply protection suit (leaky)
          // nope, Voodoo Dools cannot have any protection
          //if (doIt && TInfo->bAllowProtection && P_Random() >= 5 && pex.FindProtectionSuit()) doIt = false;
        }
        if (doIt) Damage(none, none, TInfo->DamageAmount, TInfo->DamageType/*, spawnBlood:true*/);
      }
      if (specified_justLanded && justLanded && TInfo->bDamageOnLand) {
        // just landed, damage if the corresponding terrain flag is set
        Damage(none, none, TInfo->DamageAmount, TInfo->DamageType/*, spawnBlood:true*/);
      }
    }

    // play landing sound (but not for Voodoo Dolls)
    if (specified_justLanded && justLanded && pex.MO == self) {
      if (smallsplash) {
        if (TInfo->SmallLandSound && TInfo->SmallLandVolume > 0.0f) {
          PlaySound(TInfo->SmallLandSound, CHAN_SPLASH, fmin(1.0f, TInfo->SmallLandVolume));
        }
      } else {
        if (TInfo->LandSound && TInfo->LandVolume > 0.0f) {
          PlaySound(TInfo->LandSound, CHAN_SPLASH, fmin(1.0f, TInfo->LandVolume));
        }
      }
    }
  }

  VSplashInfo *SInfo = GetSplashInfo(TInfo->Splash);
  if (!SInfo) return TInfo->bLiquid;

  // called from Z movement, perform some checks
  if (specified_justLanded) {
    if (!justLanded) {
      // stayed on the floor; check if it is the same floor
      if (tmp_phys_last_floor_pic == EFloor.splane->pic) {
        // check splash time
        if (tmp_phys_last_splash_time+0.6 > XLevel.Time) {
          // don't splash
          //printdebug("%C: splash time=%s; time=%s", self, tmp_phys_last_splash_time, XLevel.Time);
          return TInfo->bLiquid;
        }
        // check velocity
        if (Velocity.length2DSquared < 6) {
          // don't splash
          return TInfo->bLiquid;
        }
        //printdebug("%C: Velocity=%s (%s)", self, Velocity, Velocity.length2DSquared);
      }
    }
  }

  // remember splash time
  tmp_phys_last_splash_time = XLevel.Time;

  // spawn splash
  TVec org = Origin;
  org.z = FloorZ;
  EntityEx A;

  if (smallsplash) {
    if (class!EntityEx(SInfo->SmallClass)) {
      A = Spawn(class!EntityEx(SInfo->SmallClass), org);
      A.FloorClip += SInfo->SmallClip;
      if (SInfo->SmallSound) A.PlaySound(SInfo->SmallSound, CHAN_SPLASH);
    }
  } else {
    if (class!EntityEx(SInfo->BaseClass)) {
      A = Spawn(class!EntityEx(SInfo->BaseClass), org);
      if (SInfo->Sound && !SInfo->ChunkClass) A.PlaySound(SInfo->Sound, CHAN_SPLASH);
    }
    if (class!EntityEx(SInfo->ChunkClass)) {
      A = Spawn(class!EntityEx(SInfo->ChunkClass), org);
      A.Target = self;
      A.Velocity.x = (Random()-Random())*SInfo->ChunkXVelMul*35.0;
      A.Velocity.y = (Random()-Random())*SInfo->ChunkYVelMul*35.0;
      A.Velocity.z = (SInfo->ChunkBaseZVel+Random()*SInfo->ChunkZVelMul)*35.0;
      if (SInfo->Sound) A.PlaySound(SInfo->Sound, CHAN_SPLASH);
    }
    if (SInfo->Sound && !SInfo->BaseClass && !SInfo->ChunkClass) PlaySound(SInfo->Sound, CHAN_SPLASH);
    if (!SInfo->bNoAlert && bIsPlayer) LineSpecialLevelInfo(Level).NoiseAlert(self, self, true);
  }
  return TInfo->bLiquid;
}


//==========================================================================
//
//  HandleFloorclip
//
//==========================================================================
override void HandleFloorclip () {
  if (bFloorClip) {
    VTerrainInfo *TInfo = GetActorTerrain();
    if (Origin.z == FloorZ && TInfo->bLiquid) {
      FloorClip = TInfo->FootClip;
    } else {
      FloorClip = 0.0;
    }
  }
}


//==========================================================================
//
//  ApplyFriction
//
//==========================================================================
override void ApplyFriction (float DeltaTime) {
  // velocity clamping is done in `UpdateVelocity()`
  // this check is done by the caller (for speed)
  //if (bMissile || bSkullFly) return; // no friction for missiles ever

  //k8: no, really? no friction while knee-dip in the water? i don't think so
  //    was: `WaterLevel < 2`
  if (Origin.z > FloorZ && !bOnMobj && WaterLevel == 0 && !bFly && !bFallingFriction) {
    // no friction when airborne
    return;
  }

  #ifdef ENABLE_LINGUORTALS
  // vanilla hack: floor with height -32768 teleports entity to ceiling
  if (bIsPlayer && /*Sector &&*/ Sector.floor.maxz <= -32768) {
    if (Origin.z <= -32768) {
      //print("!!!! z=%s; fz=%s %C : %s", Origin.z, FloorZ, self, self.UniqueId);
      bIntrJustMoved = false; // don't interpolate
      Origin.z = Sector.ceiling.minz-Height;
      // find out new floor plane
      if (Sector.bHasExtrafloors) GetFloorAndCeiling(nullptr);
      Origin.z = CeilingZ-Height;
      Velocity.z = 0;
    }
    return; // assume airborne
  }
  #endif

  // clip velocity on sloped floors (moved to `UpdateVelocity()`)
  float vx = Velocity.x;
  float vy = Velocity.y;

  if (bCorpse) {
    if (bCorpseSliding/*Slope*/) return; // forced sliding by C++ physics code
    // don't stop sliding if halfway off a step with some momentum
    // but do this only for sectors without 3d floors, and not 3d pobjs
    // (otherwise the body will slide off from any 3d floor/pobj)
    if (Sector == BaseSector && !SectorHas3DFloors(Sector)) {
      /*
      if (vx > 0.25*35.0 || vx < -0.25*35.0 ||
          vy > 0.25*35.0 || vy < -0.25*35.0)
      */
      if (fabs(vx) > 0.25*35.0 || fabs(vy) > 0.25*35.0) {
        if (DropOffZ != FloorZ || FloorZ > Sector->floor.GetPointZClamped(Origin)) {
          return;
        }
      }
    }
  }

  // clamp Voodoo Dolls too
  if (fabs(vx) < STOPSPEED && fabs(vy) < STOPSPEED &&
      (!bIsPlayer || Player.MO != self || (Player.MO == self && !Player.ForwardMove && !Player.SideMove)))
  {
    Velocity.x = 0.0;
    Velocity.y = 0.0;
    if (bIsPlayer) {
      // if in a walking frame, stop moving
      if (IdleState && /*StateIsInRange(State, SeeState, none, 4)*/StateIsInSequence(State, SeeState)) {
        //printdebug("%C: going to idle state %s from %s (0)", self, IdleState, State);
        SetState(IdleState);
      }
    }
  } else {
    // slow down
    float fric = GetFriction();
    //k8: this must be right, i believe, because original code multiplies speed by friction
    //    as we're doing it the opposite way, we should divide subtracted velocity by entity friction factor
    //    zero factor means "infinite friction" (i.e. the entity cannot move at all)
    if (Friction > 0.0) fric /= Friction;
    // apply extra friction for player, so it won't slide
    if (bIsPlayer && Player && Player.MO == self && !Player.ForwardMove && !Player.SideMove && GetCvarB('player_extra_friction_enabled')) {
      // check for conveyor belts
      if (!PhysicsCheckScroller()) {
        float efric = GetCvarF('player_extra_friction');
        if (efric > 0.0) fric *= efric;
      }
    }
    TVec vdiff = Velocity.xy*(fric*DeltaTime);
    if (Friction <= 0.0) vdiff = Velocity.xy; // stop right there, you criminal scum!
    Velocity -= vdiff;
  }
}


//===========================================================================
//
//  GetFriction
//
//===========================================================================
float GetFriction () {
  if (WaterLevel > 1) return FRICTION_WATER;
  if (bFly && Origin.z > FloorZ && !bOnMobj) return FRICTION_FLY;
  if (Sector && (Sector->special&SECSPEC_BASE_MASK) == SECSPEC_FrictionLow) return FRICTION_LOW;
  VTerrainInfo *TInfo = GetActorTerrain();
  if (TInfo && TInfo->Friction) return TInfo->Friction;
  if (Sector && (Sector->special&SECSPEC_FRICTION_MASK)) return Sector->Friction;
  return FRICTION_NORMAL;
}
