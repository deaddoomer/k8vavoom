//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//  BLOOD UTILITIES
//**************************************************************************

final bool BloodCanSplat (class!Actor BloodType) {
  if (!BloodType) return true;
  BloodType = class!Actor(GetClassReplacement(BloodType));
  if (!BloodType) return true;
  //print("cansplat for %s: %B", BloodType, !BloodType.default.bBloodDisableSplats);
  return !BloodType.default.bBloodDisableSplats;
}


//==========================================================================
//
// GetBloodSmearDecalName
//
//==========================================================================
final name GetBloodSmearDecalName () {
  if (bNoBlood || !self.BloodType) return '';
  name dcn = GetClassName(GetClassReplacee(self.BloodType));
  if (dcn == 'BloodGreen') return 'BloodSmearGreen';
  if (dcn == 'BloodBlue') return 'BloodSmearBlue';
  //if (GetClassName(GetClassReplacee(self.BloodType)) == 'BloodGreen') return 'BloodSmearGreen';
  //if (GetClassName(GetClassReplacee(self.BloodType)) == 'BloodBlue') return 'BloodSmearBlue';
  return 'BloodSmear';
}


//==========================================================================
//
// GetBloodSplatRadiusDecalName
//
//==========================================================================
final name GetBloodSplatRadiusDecalName () {
  if (bNoBlood || !self.BloodType) return '';
  name dcn = GetClassName(GetClassReplacee(self.BloodType));
  if (dcn == 'BloodGreen') return 'BloodSplatRadiusGreen';
  if (dcn == 'BloodBlue') return 'BloodSplatRadiusBlue';
  //if (GetClassName(GetClassReplacee(self.BloodType)) == 'BloodGreen') return 'BloodSplatRadiusGreen';
  //if (GetClassName(GetClassReplacee(self.BloodType)) == 'BloodBlue') return 'BloodSplatRadiusBlue';
  return 'BloodSplatRadius';
}


//==========================================================================
//
// GetBloodSmearRadiusDecalName
//
//==========================================================================
final name GetBloodSmearRadiusDecalName () {
  if (bNoBlood || !self.BloodType) return '';
  name dcn = GetClassName(GetClassReplacee(self.BloodType));
  if (dcn == 'BloodGreen') return 'BloodSmearRadiusGreen';
  if (dcn == 'BloodBlue') return 'BloodSmearRadiusBlue';
  return 'BloodSmearRadius';
}


//==========================================================================
//
// GetBloodSplatDecalName
//
//==========================================================================
final name GetBloodSplatDecalName () {
  if (bNoBlood || !self.BloodType) return '';
  name dcn = GetClassName(GetClassReplacee(self.BloodType));
  if (dcn == 'BloodGreen') return 'BloodSplatGreen';
  if (dcn == 'BloodBlue') return 'BloodSplatBlue';
  //if (GetClassName(GetClassReplacee(self.BloodType)) == 'BloodGreen') return 'BloodSplatGreen';
  //if (GetClassName(GetClassReplacee(self.BloodType)) == 'BloodBlue') return 'BloodSplatBlue';
  return 'BloodSplat';
}


//==========================================================================
//
//  k8GetBloodClassName
//
//==========================================================================
final static name k8GetBloodClassName (name newblood, name oldblood) {
  if (FindClass(newblood)) {
    //print("GB: new=%s; old=%s; res=%s", newblood, oldblood, newblood);
    return newblood;
  }
  //print("GB: new=%s; old=%s; res=%s", newblood, oldblood, oldblood);
  return oldblood;
}


//==========================================================================
//
//  SetBloodArgs
//
//  pass some info to spawned blood actor, so decorate/vc can use 'em.
//  should be called on blood entity
//
//  Tracer, Target: bleeding Entity (can be none)
//  Args[0]: damage (can be 0)
//
//==========================================================================
final void SetBloodArgs (EntityEx master, optional int damage) {
  self.Tracer = master;
  self.Target = master;
  self.Args[0] = damage;
}


//==========================================================================
//
//  BloodAddZClamped
//
//  set spos.z to spos.z+delta, but not higher than ceiling
//  delta will be clamped to [0..)
//
//==========================================================================
final void BloodAddZClamped (ref TVec spos, float delta, float height) {
  if (!delta) return;
  auto sec = XLevel.PointInSector(spos);
  height = fmax(0, height);
  float fz, cz;
  GetSectorGapCoords(sec, spos, out fz, out cz);
  if (cz-fz <= height) return;
  spos.z += delta;
  spos.z = fclamp(fz, spos.z, cz-height);
  /*
  opening_t *open = BuildSectorOpeningsAt(sec, spos, SPF_NOBLOCKSHOOT); // each sector has at least one
  open = FindOpening(open, spos.z, spos.z+fmax(0, height));
  if (open) {
    if (delta > 0) {
      // positive delta (up)
      spos.z = fmin(spos.z+delta, open.eceiling.splane.minz-1-fmax(0, height));
    } else {
      // negative delta (down)
      spos.z = fmax(spos.z+delta, open.efloor.splane.maxz+1);
    }
    //print("spz=%s; cmz=%s", spos.z, reg.ceiling.splane.minz);
  } else {
    spos.z += delta;
  }
  */
}


//==========================================================================
//
//  SpawnHeadBloodSpray
//
//  this will be called on XDeath
//
//==========================================================================
void SpawnHeadBloodSpray (int damage, optional bool notDead, optional bool spawnBloodPool) {
  bool doSpray = IsBloodAllowed() && GetCvarB('k8HSHeadKillBloodSpray');
  if (!doSpray) return;

  name bloodClassName = k8GetBloodClassName('K8Gore_BloodTransient', 'Blood');
  name poolClassName = k8GetBloodClassName('K8Gore_GrowingBloodPool', '');
  //print("bloodtype: %C/%C", self.BloodType, GetClassReplacee(self.BloodType));

  if (self.BloodType) {
    name brname = GetClassName(GetClassReplacee(self.BloodType));
    //print("brname=%s", brname);
    if (brname == 'BloodGreen') {
      bloodClassName = 'BloodGreen';
      bloodClassName = k8GetBloodClassName('K8Gore_BloodTransient_Green', bloodClassName);
      //mistClassName = 'K8Gore_BloodmistSmallGreen';
      poolClassName = k8GetBloodClassName('K8Gore_GrowingBloodPool_Green', poolClassName);
    } else if (brname == 'BloodBlue') {
      bloodClassName = 'BloodBlue';
      bloodClassName = k8GetBloodClassName('K8Gore_BloodTransient_Blue', bloodClassName);
      //mistClassName = 'K8Gore_BloodmistSmallBlue';
      poolClassName = k8GetBloodClassName('K8Gore_GrowingBloodPool_Blue', poolClassName);
    }
  }

  //writeln("  bloodclass: ", bloodClassName);

  class!Actor bloodClass = class!Actor(FindClass(bloodClassName));
  if (bloodClass) bloodClass = class!Actor(GetClassReplacement(bloodClass));

  if (bloodClass) {
    //print("BLOOD CLASS: %C (blcn=%s)", bloodClass, bloodClassName);
    int bcc = int(GetCvarF('k8HSHeadKillBloodCount'));
    if (bcc > 0) {
      bcc += int(Random()*7-3); // -3..3
      if (bcc < 3) bcc = 3;
      if (bcc > 32) bcc = 32;
    }

    if (!specified_notDead) notDead = (damage < Health);

    if (bcc > 0 && !spawnBloodPool && notDead) bcc = max(1, bcc-bcc/3);

    float hgt = Height;
    if (hgt < 1 || (bMonster && bCorpse)) hgt = default.Height;

    TVec spos;
    foreach (; 0..bcc) {
      // k8: the blood will fly away on its own, but help it a little
      spos = Origin+vector((FRandomFull()*16-8)/10.0, (FRandomFull()*16-8)/10.0);
      float zmax = hgt+((FRandomFull()*22-11)/10.0);
      BloodAddZClamped(spos, zmax, bloodClass.default.Height);
      EntityEx bld = EntityEx(Level.Spawn(bloodClass, spos)); // optional TAVec AAngles, optional mthing_t *mthing, optional bool AllowReplace
      if (bld) {
        bld.CopyBloodTranslations(self, copyNormalTranslation:true);
        bld.SetBloodArgs(self, damage);
        bld.Velocity = Velocity;
      }
    }
  }

  if (spawnBloodPool && GetCvarB('k8HSHeadKillBloodPool')) {
    //poolClassName = 'SmallBloodPool';
    class!Actor poolClass = class!Actor(FindClass(poolClassName));
    if (poolClass) poolClass = class!Actor(GetClassReplacement(bloodClass));
    if (poolClass) {
      //print("***SPAWNING BLOOD POOL: '%C'", poolClass);
      EntityEx bld = EntityEx(Level.Spawn(poolClass, Origin));
      if (bld) {
        bld.CopyBloodTranslations(self, copyNormalTranslation:true);
        bld.SetBloodArgs(self, damage);
      }
    }
  }
}


//==========================================================================
//
//  IsGootLineForBloodSplat
//
//==========================================================================
bool IsGood2SLineForBloodSplat (const line_t *li) {
  // alpha check for various special fx (additive lines are mostly used for fx too)
  return
    li.special != LNSPEC_LineHorizon &&
    li.alpha > 0.6 &&
    !(li.flags&ML_ADDITIVE);
}


//==========================================================================
//
//  TraceSplat
//
//  trace line to the wall, so we can spawn decal on it.
//  returns `true` if wall was hit.
//  returns `false` if floor/ceiling was hit, or nothing was hit.
//  `dir` must be normalized.
//  (not anymore) if zofs is not given, use default entity vertical offset.
//
//  `only2S` means "spawn decals only on two-sided lines"
//
//  if `DecalName` is given, spawn decals
//
//==========================================================================
final bool TraceSplat (TVec org, TVec dir, float distance, optional trsplat_t *tr, optional float zofs,
                       optional name DecalName, optional bool pass2S, optional bool only2S, optional int translation)
{
  TVec outHitPoint;
  trsplat_t temptr;

  TVec shootOrigin = org;
  //ShootOrigin.z += Height*0.5-FloorClip;
  if (specified_zofs) {
    //shootOrigin.z += zofs;
    BloodAddZClamped(shootOrigin, zofs, 0);
  } else {
    //shootOrigin.z += (bIsPlayer ? PlayerEx(Player).GetAttackZOfs : 8.0);
  }

  TVec dst = shootOrigin+distance*dir;

  if (!tr) tr = &temptr;
  tr->org = org;
  tr->hit = dst;
  tr->line = nullptr;
  tr->sec = nullptr;
  tr->didhit = false;
  tr->mobj = none;

  intercept_t *in;
  int side; // declared here, so VM don't need to clear it in the loop
  sector_t *sec; // declared here, so VM don't need to clear it in the loop
  TVec lineStart = shootOrigin;
  foreach PathTraverse(in, org.x, org.y, dst.x, dst.y, PT_ADDLINES/*|PT_EARLYOUT*/) {
    if (in->bIsALine) {
      line_t *li = in->line;
      TVec hit_point = shootOrigin+(distance*in->frac)*dir;

      if ((li->flags&ML_TWOSIDED) && PointOnPlaneSide(shootOrigin, *li)) {
        side = 1;
        sec = li->backsector;
      } else {
        side = 0;
        sec = li->frontsector;
      }

      TVec lineEnd = hit_point;

      // check for shooting floor or ceiling
      if (!ShootCheckPlanes(sec, li, lineStart, lineEnd, distance, PuffType:none, &outHitPoint)) {
        // process floor and ceiling here
        tr->hit = outHitPoint;
        tr->didhit = true;
        return false;
      }

      lineStart = lineEnd;

      if (Level.CompatTrace && li->frontsector == li->backsector) {
        if (DecalName && (pass2S || only2S) && IsGood2SLineForBloodSplat(li)) {
          SpawnDecal(hit_point, DecalName, side, li, translation!optional);
        }
        continue;
      }

      if (li->flags&ML_TWOSIDED) {
        // crosses a two sided line
        float opentop = -float.max;

        opening_t *open = nullptr;
        // no need to scan openings for blocking line
        if (!(li->flags&(ML_BLOCKING|ML_BLOCKEVERYTHING))) {
          open = LineOpenings(li, hit_point);
          if (open) opentop = open->top;
          while (open) {
            if (open->bottom <= hit_point.z-12 && open->top >= hit_point.z+12) {
              break; // shot continues
            }
            open = open->next;
          }
          // found good opening?
          if (open) {
            // alpha check for various special fx (additive lines are mostly used for fx too)
            if (DecalName && (pass2S || only2S) && IsGood2SLineForBloodSplat(li)) {
              SpawnDecal(hit_point, DecalName, side, li, translation!optional);
            }
            continue;
          }
        }

        if (li->frontsector->ceiling.pic == Level.Game.skyflatnum &&
            li->backsector->ceiling.pic == Level.Game.skyflatnum)
        {
          if (!open) {
            open = LineOpenings(li, hit_point);
            if (open) opentop = open->top;
          }
          if (hit_point.z > opentop) {
            // it's a sky hack wall
            tr->hit = hit_point;
            tr->didhit = true;
            return false;
          }
        }
      }

      outHitPoint = hit_point;

      if (li->special == LNSPEC_LineHorizon) {
        tr->hit = hit_point;
        return false; // don't spawn decals on sky
      }

      // hit line
      tr->hit = hit_point;
      tr->line = li;
      tr->sec = sec;
      tr->side = side;
      tr->didhit = true;

      if (DecalName && !only2S) SpawnDecal(hit_point, DecalName, side, li, translation!optional);

      // don't go any farther if not two-sided
      if (!(li->flags&ML_TWOSIDED)) return true;
      // two-sided, go through it if it is not blocking
      if (li->flags&(ML_BLOCKING|ML_BLOCKEVERYTHING)) return true;
    }
  }

  TVec lineEnd = dst;
  if (!ShootCheckPlanes(XLevel.PointInSector(dst), line:default, lineStart, lineEnd, distance, PuffType:none, &outHitPoint)) {
    // process floor and ceiling here
    tr->hit = outHitPoint;
    tr->didhit = true;
  }

  return false;
}


//==========================================================================
//
//  TraceBleed
//
//  trace line to the wall, spawn blood splats
//
//==========================================================================
final void TraceBleed (int damage, TVec pos, float angle, float pitch, bool radiusDamage) {
  if (damage < 1 || !IsBloodAllowed()) return;

  if (bIsPlayer) {
    // gods don't bleed
    if ((PlayerEx(Player).Cheats&PlayerEx::CF_GODMODE)) return;
  }

  //k8: sorry, this should be one var, but meh
  bool isHighDamage = false;
  bool isSmallDamage = false;

  name bclasssplat = GetBloodSplatDecalName();
  name bclasssmear = GetBloodSmearDecalName();

  if (radiusDamage) {
    if (HasDecal(GetBloodSplatRadiusDecalName())) bclasssplat = GetBloodSplatRadiusDecalName();
    if (HasDecal(GetBloodSmearRadiusDecalName())) bclasssmear = GetBloodSmearRadiusDecalName();
  }

  name bloodType = bclasssplat;

  int count;
  float noise;

  if (damage < 15) {
    // for low damages, there is a chance to not spray blood at all
    if (damage <= 10) {
      if (P_Random() < /*1*//*60*/30) {
        if (!radiusDamage) return;
        isSmallDamage = true;
        //return;
      }
    }
    count = 1+P_Random()%3+1;
    noise = 11.25/256.0;
  } else if (damage < 25) {
    count = 2+P_Random()%3+2;
    noise = 22.5/256.0;
  } else {
    // for high damages, there is a chance to spray just one big glob of blood
    if (P_Random() < 24) {
      bloodType = bclasssmear;
      count = 2+P_Random()%3+2;
      noise = 45.0/256.0;
      isHighDamage = true;
    } else {
      count = 6+P_Random()%4+3;
      noise = 45.0/256.0;
    }
  }

  if (!HasDecal(bloodType)) {
    //print("*** NO BLOOD DECAL '%s'", bloodType);
    return;
  }

  if (isSmallDamage && !radiusDamage) return; // oops

  int btrans = 0;
  if (!bDontTranslate) {
         if (BloodTranslation) btrans = BloodTranslation;
    else if (bCopyBloodTranslation) btrans = Translation;
  }
  //print("btrans for %C is %s", self, btrans);

  trsplat_t tr;
  while (count-- > 0) {
    //float bleedang = AngleMod360(angle+(P_Random()-128)*noise);
    //k8: meh, spray it in all directions sometimes
    //float bleedang = (P_Random() >= 170 ? 360.0*Random() : AngleMod360(angle+(P_Random()-128)*noise));
    float bleedang = (GetCvarB('blood_widespread') || P_Random() >= 220 ? 360.0*Random() : AngleMod360(angle+(P_Random()-128)*noise));
    float bleedpitch = AngleMod360(pitch+(P_Random()-128)*noise);
    //bleedpitch = pitch;
    //double cosp = bleedpitch.Cos();
    float cosp, sinp;
    sincos(bleedpitch, out sinp, out cosp);
    float bas, bac;
    sincos(bleedang, out bas, out bac);
    TVec vdir;
    vdir.x = cosp*bac;
    vdir.y = cosp*bas;
    vdir.z = -sinp;
    //DVector3 vdir = DVector3(cosp * bleedang.Cos(), cosp * bleedang.Sin(), -bleedpitch.Sin());

    if (isSmallDamage && !radiusDamage) continue;

    //print("TraceBleed: %s", bloodType);
    TraceSplat(pos, vdir, 172.0, &tr, 0, bloodType, pass2S:true, only2S:false, translation:btrans);
  }
}


//==========================================================================
//
//  SpawnBlood
//
//==========================================================================
final void SpawnBlood (TVec Org, int damage, optional TVec shootOrg, optional float zofs) {
  EntityEx A;
  int i, c;

  if (!IsBloodAllowed()) return;

  // keep z, but set x and y to our coords
  //Org.x = Origin.x;
  //Org.y = Origin.y;

  if (specified_shootOrg && BloodCanSplat(BloodType)) {
    TVec goup = Origin;
    if (Radius > 0) goup.z += Radius+4+Random()*4;
    TAVec av;
    TVec v = goup-shootOrg;
    VectorAngles(v, out av);
    //print("bleed angles: vel=%s; pitch=%s; roll=%s; yaw=%s", v, av.pitch, av.roll, av.yaw);
    TraceBleed(damage, goup, av.yaw, av.pitch, false);
  }

  //Org.z += (Random()-Random())*4.0;
  if (!specified_zofs) zofs = (Random()-Random())*4.0;
  BloodAddZClamped(Org, zofs, (BloodType ? BloodType.default.Height : 0));
  damage = (damage > 255 ? 255 : damage);
  c = P_Random()>>1;
  for (i = 0; i < MAXPLAYERS; ++i) {
    if (!Level.Game.Players[i]) continue;
    if (!Level.Game.Players[i].bSpawned) continue;
    if (GetCvarB('r_particle_blood')) {
      PlayerEx(Level.Game.Players[i]).ParticleEffect(damage,
        LineSpecialLevelInfo::pt_static, 0, Org, 0.0,
        vector(32.0, 32.0, 32.0), 0.5, 10.0, 40.0,
        BloodColor ? BloodColor : RGB(32+c, c>>4, c>>4), 0.6, 0.0);
    }
  }

  if (!BloodType) return;

  A = Spawn(BloodType, Org);
  if (!A) return; // oops
  A.CopyBloodTranslations(self, copyNormalTranslation:true);
  //print("spawned blood `%C` for `%C` (bt=%s; A.bDontTranslate=%B; a.t=%s; a.bt=%s)", A, self, BloodTranslation, A.bDontTranslate, A.Translation, A.BloodTranslation);
  A.SetBloodArgs(self, damage:damage);

  //print("shooter vel=%s; A vel=%s", Velocity, A.Velocity);

  A.Velocity.z = 2.0*35.0;
  if (LineSpecialGameInfo(Level.Game).bBloodRandomiseTime) {
    A.StateTime -= Random()*0.1;
    if (A.StateTime < 0.1) A.StateTime = 0.1;
  }
  //if (!A.bDontTranslate) A.CopyTranslations(self);
  //if (BloodTranslation && !A.bDontTranslate) { A.Translation = BloodTranslation; A.BloodTranslation = BloodTranslation; }
  A.CopyBloodTranslations(self, copyNormalTranslation:true);

  if (LineSpecialGameInfo(Level.Game).bBloodSpray) {
    if (damage > 13) {
      A.SetState(A.FindState('Spray'));
    } else {
      damage += 2;
    }
  }

  if (GetCvarB('zdoom_blood_hack')) {
    if (damage <= 12 && damage >= 9) {
      A.SetState(GetStatePlus(A.IdleState, 1));
    } else if (damage < 9) {
      A.SetState(GetStatePlus(A.IdleState, 2));
    }
  }
}


//==========================================================================
//
//  SpawnBloodAtHead
//
//==========================================================================
final void SpawnBloodAtHead (int damage, optional TVec shootOrg) {
  TVec goup = Origin;
  float zofs = (Radius > 0 ? Radius+4+Random()*4 : 0);
  SpawnBlood(goup, damage, shootOrg!optional, zofs);
}


//==========================================================================
//
//  SpawnExploBloodAtHead
//
//==========================================================================
final void SpawnExploBloodAtHead (int damage, optional EntityEx src) {
  if (bNoBlood || damage < 1 || !IsBloodAllowed()) return;

  if (src && BloodCanSplat(BloodType)) {
    TVec goup = Origin;
    if (Radius > 0) goup.z += Radius+4+Random()*4;
    TAVec av;
    TVec v;
    if (src.bIsPlayer) v = goup-src.Origin; else v = src.Velocity;
    VectorAngles(v, out av);
    //print("bleed angles: vel=(%f,%f,%f); pitch=%f; roll=%f; yaw=%f", v.x, v.y, v.z, av.pitch, av.roll, av.yaw);
    TraceBleed(damage, goup, av.yaw, av.pitch, true);
  }

  bool isSmallDamage = false;
  bool isHighDamage = false;

       if (damage <= 10) isSmallDamage = true;
  else if (damage < 25) {}
  else isHighDamage = true;

  SpawnBloodAtHead(damage);
  SpawnBloodAtHead(damage);
  if (!isSmallDamage) {
    if (Health <= damage) SpawnBloodAtHead(damage);
    SpawnBloodAtHead(damage);
  }
  // spawn more blood for high damage
  if (isHighDamage) {
    if (Health <= damage) SpawnBloodAtHead(damage);
    if (Health <= damage) SpawnBloodAtHead(damage);
    SpawnBloodAtHead(damage);
    SpawnBloodAtHead(damage);
  } else {
    if (Health <= damage) SpawnBloodAtHead(damage);
    if (Health <= damage) SpawnBloodAtHead(damage);
  }
}


//==========================================================================
//
//  SpawnBloodSplatter
//
//==========================================================================
final void SpawnBloodSplatter (TVec org, int damage, TVec shootOrg) {
  if (!IsBloodAllowed()) return;

  damage = (damage > 255 ? 255 : damage);
  int c = P_Random()>>1;
  foreach (auto i; 0..MAXPLAYERS) {
    if (!Level.Game.Players[i]) continue;
    if (!Level.Game.Players[i].bSpawned) continue;
    if (GetCvarB('r_particle_blood')) {
      PlayerEx(Level.Game.Players[i]).ParticleEffect(damage, LineSpecialLevelInfo::pt_static,
          0, org, 0.0, vector(32.0, 32.0, 32.0), 0.5, 10.0, 40.0, RGB(32+c, c>>4, c>>4),
          0.6, 0.0);
    }
  }

  if (!BloodSplatterType) return;

  EntityEx mo = Spawn(BloodSplatterType, org);
  if (!mo) return;
  mo.SetBloodArgs(self, damage);
  mo.Target = self;
  mo.Velocity.x = (Random()-Random())*4.0*35.0;
  mo.Velocity.y = (Random()-Random())*4.0*35.0;
  mo.Velocity.z = 3.0*35.0;
  mo.CopyBloodTranslations(self, copyNormalTranslation:true);

  {
    TAVec av;
    TVec v = org-shootOrg;
    VectorAngles(v, out av);
    //print("bleed angles: vel=(%f,%f,%f); pitch=%f; roll=%f; yaw=%f", v.x, v.y, v.z, av.pitch, av.roll, av.yaw);
    TraceBleed(damage, org, av.yaw, av.pitch, false);
  }
}


//===========================================================================
//
//  SpawnBloodSplatter2
//
//===========================================================================
final void SpawnBloodSplatter2 (TVec org, TVec shootOrg) {
  if (!IsBloodAllowed()) return;
  if (!AxeBloodType) return;

  org.x += (Random()-0.5)*8.0;
  org.y += (Random()-0.5)*8.0;

  EntityEx mo = Spawn(AxeBloodType, org);
  if (!mo) return;
  mo.SetBloodArgs(self);
  mo.Target = self;
  mo.CopyBloodTranslations(self, copyNormalTranslation:true);

  {
    TAVec av;
    TVec v = org-shootOrg;
    VectorAngles(v, out av);
    //print("bleed angles: vel=(%f,%f,%f); pitch=%f; roll=%f; yaw=%f", v.x, v.y, v.z, av.pitch, av.roll, av.yaw);
    TraceBleed(500, org, av.yaw, av.pitch, false);
  }
}


//==========================================================================
//
//  SpawnRipperBlood
//
//==========================================================================
final void SpawnRipperBlood () {
  if (!BloodType) return;

  TVec org;
  org.x = Origin.x+(Random()-Random())*16.0;
  org.y = Origin.y+(Random()-Random())*16.0;
  org.z = Origin.z;
  BloodAddZClamped(org, (Random()-Random())*16.0, BloodType.default.Height);

  EntityEx th = Spawn(BloodType, org);
  if (!th) return;
  th.SetBloodArgs(self);
  if (LineSpecialGameInfo(Level.Game).bRipperBloodNoGravity) th.bNoGravity = true;
  th.Velocity.x = Velocity.x/2.0;
  th.Velocity.y = Velocity.y/2.0;
  th.StateTime += Random()*0.1;
  th.CopyBloodTranslations(self, copyNormalTranslation:true);
}
