//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************

//==========================================================================
//
//  IsInventoryCheckpointPossible
//
//==========================================================================
bool IsInventoryCheckpointPossible () {
  for (Inventory it = Inventory; it; it = it.Inventory) {
    if (!it.IsCheckpointSaveAllowed()) return false;
  }
  return true;
}


//==========================================================================
//
//  QS_ClearEntityInventory
//
//==========================================================================
override void QS_ClearEntityInventory () {
  DestroyAllInventory();
  if (bIsPlayer && Player && Player.MO == self) {
    PlayerEx plr = PlayerEx(Player);
    plr.SetWeapon(none);
    plr.BringUpWeapon(instant:true, skipSound:true);
  }
}


//==========================================================================
//
//  QS_GetEntityInventory
//
//  returns first item in inventory, or `none`
//
//==========================================================================
override Entity QS_GetEntityInventory () {
  return Inventory;
}


//==========================================================================
//
//  QS_SpawnEntityInventory
//
//  adds to current inventory
//
//==========================================================================
override Entity QS_SpawnEntityInventory (name className) {
  if (!className) return none;

  class!Inventory ec = class!Inventory(FindClass(className));
  if (!ec) return none;
  //ec = GetCompatibleClassReplacement(class!EntityEx, ec);
  //if (ec) ArmorClass = ec;

  Inventory ent = FindInventory(ec, disableReplacement:true);
  if (!ent) {
    EntityEx newEnt = Spawn(ec, AllowReplace:false);
    if (!newEnt) return none;
    ent = Inventory(newEnt);
    if (!ent) { delete newEnt; return none; }
    ent.AttachToOwner(self);
  }

  return ent;
}


//==========================================================================
//
//  AddInventory
//
//==========================================================================
void AddInventory (Inventory Item) {
  if (!Item) return;

  if (Item.Owner) {
    if (Item.Owner == self) return; // already in the inventory
    // remove from current owner's inventory
    EntityEx(Item.Owner).RemoveInventory(Item);
  }

  // add it at the top of the inventory
  Item.Inventory = Inventory;
  Inventory = Item;

  // set item's owner
  Item.Owner = self;
}


//==========================================================================
//
//  RemoveInventory
//
//==========================================================================
void RemoveInventory (Inventory Item) {
  if (!Item) return;

  // find previous item or owner itself, if it's the first item
  EntityEx Prev = self;
  while (Prev && Prev.Inventory != Item) Prev = Prev.Inventory;

  if (!Prev) {
    printwarn("Cannot remove '%C' from inventory of '%C': it is not there!", Item, self);
    if (Item.Owner) {
      if (Item.Owner != self) printwarn(" OWNER: '%C'", Item.Owner); else printwarn(" OWNER: SELF");
      Item.DetachedFromOwner();
      Item.Owner = none;
    }
    return;
  }

  // unlink and remove owner
  Prev.Inventory = Item.Inventory;
  Item.DetachedFromOwner();
  Item.Owner = none;
}


//==========================================================================
//
//  FindInventory
//
//==========================================================================
final Inventory FindInventory (class!Inventory ItemClass, optional bool disableReplacement) {
  if (!ItemClass) return none;
  class!Inventory repl = class!Inventory(GetClassReplacement(ItemClass));

  for (Inventory Check = Inventory; Check; Check = Check.Inventory) {
    if (Check.Class == ItemClass) return Check;
    // consider replacements too
    if (!disableReplacement && GetClassReplacement(Check.Class) == repl) {
      //printdebug("FOUND REPLACEMENT INVENTORY: ItemClass=<%C>; repl=<%C>; Check=<%C>", ItemClass, repl, Check);
      return Check;
    }
  }

  return none;
}


//==========================================================================
//
//  FindInfiniteAmmoPowerup
//
//==========================================================================
final PowerInfiniteAmmo FindInfiniteAmmoPowerup () {
  auto InfiniteAmmo = Inventory;
  while (InfiniteAmmo) {
    auto pwi = PowerInfiniteAmmo(InfiniteAmmo);
    if (pwi) return pwi;
    InfiniteAmmo = InfiniteAmmo.Inventory;
  }
  return none;
}


//==========================================================================
//
//  FindBuddhaPowerup
//
//==========================================================================
final PowerBuddha FindBuddhaPowerup () {
  for (auto inv = Inventory; inv; inv = inv.Inventory) {
    auto pup = PowerBuddha(inv);
    if (pup) return pup;
  }
  return none;
}


//==========================================================================
//
//  FindRegenerationPowerup
//
//==========================================================================
final PowerRegeneration FindRegenerationPowerup () {
  for (auto inv = Inventory; inv; inv = inv.Inventory) {
    auto pup = PowerRegeneration(inv);
    if (pup) return pup;
  }
  return none;
}


//==========================================================================
//
//  ChooserCheckAllowedReplacements
//
//  check if this is a weapon, and replace it if we have a replacement
//
//  this is so `GiveInventory()` with weapon types gives the correct
//  ammo/weapon type with weapon mods
//
//==========================================================================
static final class!Inventory ChooserCheckAllowedReplacements (class!Inventory Type) {
  if (class!Weapon(Type)) {
    class!Inventory repl = class!Inventory(GetClassReplacement(Type));
    if (repl != Type && class!Weapon(repl) && !class!RandomSpawner(repl)) {
      printdebug("ChooserCheckAllowedReplacements: weapon %C replaced with %C", Type, repl);
      Type = repl;
    }
  } else if (class!Ammo(Type)) {
    class!Inventory repl = class!Inventory(GetClassReplacement(Type));
    if (repl != Type && class!Ammo(repl) && !class!RandomSpawner(repl)) {
      printdebug("ChooserCheckAllowedReplacements: ammo %C replaced with %C", Type, repl);
      Type = repl;
    }
  }
  return Type;
}


//==========================================================================
//
//  ChooseInventoryType
//
//  use this instead of directly spawning an inventory item
//
//==========================================================================
static final class!Inventory ChooseInventoryType (class!EntityEx Type, bool disableReplace) {
  if (!Type) return none;

       if (Type isa 'BasicArmor') Type = BasicArmor;
  else if (Type isa 'HexenArmor') Type = HexenArmor;

  class!EntityEx replCls = (disableReplace ? Type : class!EntityEx(GetClassReplacement(Type)));
  if (!replCls) replCls = Type;

  if (class!RandomSpawner(replCls)) {
    class!Inventory invCls = class!Inventory(ChooseFromDropItemList(replCls, AllowReplace:!disableReplace));
    if (!invCls) return none;
    name itpname = 'inventory';
         if (invCls isa 'Ammo') itpname = 'ammo';
    else if (invCls isa 'Weapon') itpname = 'weapon';
    printdebug("RandomSpawner `%C` chose %s item `%C`", replCls, itpname, invCls);
    Type = invCls;
  }

  return ChooserCheckAllowedReplacements(class!Inventory(Type));
}


//==========================================================================
//
//  ChooseInventoryTypeByName
//
//  use this instead of directly spawning an inventory item
//
//==========================================================================
static final class!Inventory ChooseInventoryTypeByName (name ItemName, bool disableReplace) {
  if (!ItemName || nameicmp(ItemName, 'none') == 0) return none;
  if (nameicmp(ItemName, 'armor') == 0) ItemName = 'basicarmor';
  if (nameicmp(ItemName, 'basicarmor') == 0) return ChooseInventoryType(BasicArmor, disableReplace);
  if (nameicmp(ItemName, 'hexenarmor') == 0) return ChooseInventoryType(HexenArmor, disableReplace);
  return ChooseInventoryType(class!EntityEx(FindClassNoCase(ItemName)), disableReplace);
}


//==========================================================================
//
//  SpawnInventoryTypeByName
//
//==========================================================================
static final Inventory SpawnInventoryTypeByName (Thinker spwnr, name ItemName, optional bool disableReplace) {
  class!Inventory Type = ChooseInventoryTypeByName(ItemName, disableReplace:disableReplace!optional);
  if (!Type) return none;
  //k8: if item's pickup code calls some movement functions, this may trigger
  //    another call to pickup handler (due to something bumped into new item),
  //    and it will go on, and on, and on (thanks to TDRR for finding this!).
  //    so i will move the item far away, and let's hope that there will be nobody there
  Inventory inv = spwnr.SpawnEntityChecked(class!Inventory, Type, vector(-33000, -33000, -33000), AllowReplace:false);
  if (!Inventory(inv)) { delete inv; inv = none; }
  return inv;
}


//==========================================================================
//
//  SpawnInventoryTypeChecked
//
//==========================================================================
static final spawner Inventory SpawnInventoryTypeChecked (class!Inventory destType, Thinker spwnr, class!EntityEx Type, optional bool disableReplace) {
  if (!Type || !destType) return none;
  class!Inventory stype = ChooseInventoryType(Type, disableReplace);
  if (!stype) return none;
  if (!destType(stype)) {
    // alas
    printwarn("class `%C` is not a subclass of `%C`, cannot spawn inventory", stype, destType);
    return none;
  }
  //k8: if item's pickup code calls some movement functions, this may trigger
  //    another call to pickup handler (due to something bumped into new item),
  //    and it will go on, and on, and on (thanks to TDRR for finding this!).
  //    so i will move the item far away, and let's hope that there will be nobody there
  Inventory inv = spwnr.SpawnEntityChecked(destType, stype, vector(-33000, -33000, -33000), AllowReplace:false);
  if (inv && !destType(inv.Class)) {
    printwarn("spawned item `%C` is not a subclass of `%C`, discarding", inv, destType);
    delete inv;
    inv = none;
  }
  return inv;
}


//==========================================================================
//
//  SpawnInventoryType
//
//==========================================================================
static final Inventory SpawnInventoryType (Thinker spwnr, class!EntityEx Type, optional bool disableReplace) {
  return SpawnInventoryTypeChecked(class!Inventory, spwnr, Type, disableReplace!optional);
}


//==========================================================================
//
//  SpawnAmmoType
//
//==========================================================================
static final Ammo SpawnAmmoType (Thinker spwnr, class!Ammo Type, optional bool disableReplace) {
  return SpawnInventoryTypeChecked(class!Ammo, spwnr, Type, disableReplace!optional);
}


//==========================================================================
//
//  SpawnWeaponType
//
//==========================================================================
static final Weapon SpawnWeaponType (Thinker spwnr, class!Weapon Type, optional bool disableReplace) {
  return SpawnInventoryTypeChecked(class!Weapon, spwnr, Type, disableReplace!optional);
}


//==========================================================================
//
//  GiveInventoryType
//
//==========================================================================
final Inventory GiveInventoryType (class!Inventory Type, optional bool disableReplace/*=false*/) {
  if (!Type) return none;
  Inventory Item = SpawnInventoryType(self, Type, disableReplace:disableReplace);
  if (!Item) return none;
  if (!Inventory(Item)) {
    printwarn("WUTAFUCK with GiveInventoryType? (%C)", Item);
    delete Item;
    return none;
  }
  // this shouldn't count for the item statistics
  if (Item.bCountItem) {
    Item.bCountItem = false;
    --Level.TotalItems;
  }
  Item.bDropped = true;
  //printdebug("*** Item=%C (%C)", Item, self);
  if (!Item.TryPickup(self)) {
    Item.Destroy();
    return none;
  }
  return Item;
}


//==========================================================================
//
//  DestroyAllInventory
//
//==========================================================================
final void DestroyAllInventory () {
  while (Inventory) Inventory.Destroy();
}


//==========================================================================
//
//  UseInventory
//
//==========================================================================
bool UseInventory (Inventory Item) {
  // don't use items if you are dead
  if (Health <= 0) return false;
  // don't use item if don't actually have it
  if (Item.Amount <= 0) return false;
  // tell item that it is used
  if (!Item.Use(false)) return false;
  // item was used, remove it from inventory
  --Item.Amount;
  if (Item.Amount <= 0 && !Item.bKeepDepleted) Item.Destroy();
  return true;
}


//==========================================================================
//
//  DropInventory
//
//==========================================================================
EntityEx DropInventory (Inventory SrcItem) {
  TVec Dir;
  AngleVector(Angles, out Dir);
  Dir.z = 0.0;
  Dir = Normalise(Dir);
  Inventory Item = SrcItem.CreateTossable();
  if (Item) {
    Item.SetOrigin2(Origin+vector(0.0, 0.0, 32.0)+Dir*(Radius+32.0), properFloorCheck:true);
    Item.Angles.yaw = Angles.yaw;
    Item.Velocity = Dir*128.0;
  }
  return Item;
}


//==========================================================================
//
//  ObtainInventory
//
//==========================================================================
void ObtainInventory (EntityEx Other) {
  if (!Other) return; //k8: just in case

  // actor should not have any inventory
  if (Inventory) Error("ObtainInventory called while still having an inventory");

  Inventory = Other.Inventory;
  Other.Inventory = none;
  Inventory Item;
  for (Item = Inventory; Item; Item = Item.Inventory) Item.Owner = self;
}


//===========================================================================
//
//  ClearInventory
//
//===========================================================================
override void ClearInventory () {
  Inventory Item = Inventory;
  while (Item) {
    Inventory Next = Item.Inventory;
    if (!Item.bUndroppable) {
      // IMHO any item that should be kept should not be dropped, not just ammo
      if (Item.bKeepDepleted) {
        Item.Amount = 0;
      } else {
        Item.Destroy();
      }
    } else if (HexenArmor(Item)) {
      HexenArmor A = HexenArmor(Item);
      A.Slots[0] = 0.0;
      A.Slots[1] = 0.0;
      A.Slots[2] = 0.0;
      A.Slots[3] = 0.0;
    }
    Item = Next;
  }

  if (bIsPlayer) {
    PlayerEx(Player).ReadyWeapon = none;
    PlayerEx(Player).PendingWeapon = none;
    Player.SetViewObject(none);
    Player.SetViewState(PS_WEAPON, none);
    Player.SetViewState(PS_FLASH, none);
  }
}


//===========================================================================
//
//  GiveInventory
//
//  called from ACS
//
//===========================================================================
override void GiveInventory (name ItemName, int Amount, bool allowReplacement) {
  //printwarn("*** %C: GiveInventory: %s %s", ItemName, Amount);
  if (Amount <= 0) return;
  if (!ItemName || nameicmp(ItemName, 'none') == 0) return;

  Inventory Item = SpawnInventoryTypeByName(self, ItemName, disableReplace:!allowReplacement);
  if (!Item) {
    printwarn("GiveInventory: Unknown item type '%s'", ItemName);
    return;
  }

  Weapon SavedPendingWeapon = none;
  bool HadWeapon = true;
  if (bIsPlayer) {
    SavedPendingWeapon = PlayerEx(Player).PendingWeapon;
    HadWeapon = !!PlayerEx(Player).ReadyWeapon;
  }

  // this shouldn't count for the item statistics
  if (Item.bCountItem) {
    Item.bCountItem = false;
    --Level.TotalItems;
  }
       if (BasicArmorPickup(Item)) BasicArmorPickup(Item).SaveAmount *= Amount;
  else if (BasicArmorBonus(Item)) BasicArmorBonus(Item).SaveAmount *= Amount;
  else Item.Amount = Amount;

  if (!Item.TryPickup(self)) {
    Item.Destroy();
  } else if (!Item.IsDestroyed()) {
    // just in case, move it to spawner's origin
    Item.SetOrigin(Origin, properFloorCheck:true);
  }

  // don't automatically bring up weapon
  if (bIsPlayer && HadWeapon) {
    PlayerEx(Player).PendingWeapon = SavedPendingWeapon;
  }
}


//===========================================================================
//
//  FindInventoryClassForACS
//
//===========================================================================
final class!Inventory FindInventoryClassForACS (name ItemName, bool allowReplacement) {
  if (!ItemName || nameicmp(ItemName, 'none') == 0) return none;
  if (nameicmp(ItemName, 'armor') == 0) ItemName = 'basicarmor';
  if (nameicmp(ItemName, 'basicarmor') == 0) return BasicArmor;
  if (nameicmp(ItemName, 'hexenarmor') == 0) return HexenArmor;
  class!EntityEx ecls = class!EntityEx(FindClassNoCase(ItemName));
  if (!ecls) return none;
  if (allowReplacement) {
    class!EntityEx repl = class!EntityEx(GetClassReplacement(ecls));
    if (repl) ecls = repl;
  }
  return class!Inventory(ecls);
}


//===========================================================================
//
//  TakeInventory
//
//===========================================================================
override void TakeInventory (name ItemName, int Amount, bool allowReplacement) {
  //printwarn("*** TakeInventory: %s %s", ItemName, Amount);
  if (Amount <= 0) return;

  class!Inventory ItemClass = FindInventoryClassForACS(ItemName, allowReplacement);
  if (!ItemClass) return;

  Inventory Item = FindInventory(ItemClass, disableReplacement:!allowReplacement);
  if (!Item) return;

  Item.Amount -= Amount;
  if (Item.Amount <= 0) {
    if (Item.bKeepDepleted) {
      Item.Amount = 0;
    } else {
      Item.Destroy();
    }
  }
}


//===========================================================================
//
//  CheckInventory
//
//===========================================================================
override int CheckInventory (name ItemName, bool allowReplacement) {
  //printwarn("*** CheckInventory: %s", ItemName);
  class!Inventory ItemClass = FindInventoryClassForACS(ItemName, allowReplacement);
  if (!ItemClass) return 0;
  Inventory Item = FindInventory(ItemClass, disableReplacement:!allowReplacement);
  return (Item ? Item.Amount : 0);
}


//===========================================================================
//
//  UseInventoryName
//
//===========================================================================
override int UseInventoryName (name ItemName, bool allowReplacement) {
  class!Inventory ItemClass = FindInventoryClassForACS(ItemName, allowReplacement);
  if (!ItemClass) return 0;
  Inventory Item = FindInventory(ItemClass, disableReplacement:!allowReplacement);
  return (Item ? UseInventory(Item) : 0);
}


//===========================================================================
//
//  GetArmorPoints
//
//===========================================================================
override int GetArmorPoints () {
  Inventory A = FindInventory(BasicArmor, disableReplacement:true);
  return (A ? A.Amount : 0);
}


//===========================================================================
//
//  GetArmorPointsForType
//
//===========================================================================
override int GetArmorPointsForType (name armtype) {
  if (!armtype || nameicmp(armtype, 'None') == 0) return 0;
  BasicArmor armor = BasicArmor(FindInventory(BasicArmor, disableReplacement:true));
  if (!armor) return 0;
  //FIXME: should we really try parents here?
  if (nameicmp(armtype, armor.GetArmorName()) == 0) return max(0, armor.Amount);
  /*
  if (armor.GetArmorName() == 'None') return 0;
  class!Inventory aclass = armor.ArmorClass;
  while (aclass) {
    if (nameicmp(armtype, GetClassName(aclass)) == 0) return max(0, armor.Amount);
    aclass = class!Inventory(GetClassParent(aclass));
  }
  */
  return 0;
}


//===========================================================================
//
//  CheckNamedWeapon
//
//===========================================================================
override int CheckNamedWeapon (name Name) {
  if (!bIsPlayer || !PlayerEx(Player).ReadyWeapon) return false;
  return (nameicmp(Name, GetClassName(PlayerEx(Player).ReadyWeapon.Class)) == 0);
}


//===========================================================================
//
//  SetNamedWeapon
//
//===========================================================================
override int SetNamedWeapon (name Name) {
  if (!bIsPlayer) return false;

  Weapon Wpn = Weapon(FindInventory(class!Inventory(FindClassNoCase(Name)), disableReplacement:true));
  if (!Wpn) return false;

  // check if it's already active
  if (PlayerEx(Player).ReadyWeapon == Wpn) {
    // make sure player doesn't switch away from it
    PlayerEx(Player).PendingWeapon = none;
    return true;
  }

  // check if weapon has enough ammo
  if (!Wpn.CheckAmmo(Weapon::FIRE_Either, AutoSwitch:false)) return false;

  PlayerEx(Player).PendingWeapon = Wpn;
  return true;
}


//===========================================================================
//
//  GetAmmoCapacity
//
//===========================================================================
override int GetAmmoCapacity (name Name) {
  class!Ammo AmmoType = class!Ammo(FindClassNoCase(Name));
  if (!AmmoType) return 0;

  // only direct descendants of Ammo class
  if (GetClassParent(AmmoType) != Ammo) return 0;

  // if we have this ammo, return current max amount, otherwise return
  // default for this ammo type
  Inventory Item = FindInventory(AmmoType);
  if (!Item) return AmmoType.default.MaxAmount;
  Ammo ammo = Ammo(Item);
  if (ammo) return ammo.k8GetAmmoKingMax();
  return Item.MaxAmount;
}


//===========================================================================
//
//  SetAmmoCapacity
//
//===========================================================================
override void SetAmmoCapacity (name Name, int Amount) {
  class!Ammo AmmoType = class!Ammo(FindClassNoCase(Name));
  if (!AmmoType) return;

  // only direct descendants of Ammo class
  if (GetClassParent(AmmoType) != Ammo) return;

  // make sure new ammo capacity is not negative
  Amount = max(0, Amount);

  Inventory Item = FindInventory(AmmoType);
  if (!Item) {
    Item = GiveInventoryType(AmmoType);
    if (!Item) {
      printwarn("cannot give ammo of type `%C` (%s)", AmmoType, Name);
      return;
    }
    Item.Amount = 0;
  }
  Item.MaxAmount = Amount;

  // we also should make sure that the current amount doesn't exceed the new limit
  Ammo ammo = Ammo(Item);
  if (ammo) {
    if (ammo.Amount > ammo.k8GetAmmoKingMax()) ammo.Amount = ammo.k8GetAmmoKingMax();
  } else {
    if (Item.Amount > Item.MaxAmount) Item.Amount = Item.MaxAmount;
  }
}


//===========================================================================
//
//  FindActivePowerupTime
//
//===========================================================================
override float FindActivePowerupTime (name className) {
  //EntityEx tgt = EntityEx(DecorDoAAPtr('FindActivePowerupTime', aptr!optional));
  //if (!tgt) return 0;

  if (!className) return 0;
  class!Powerup ptype = class!Powerup(FindClassNoCase(className));
  if (!ptype) return 0;
  class!Powerup ptyperepl = class!Powerup(GetClassReplacement(ptype));

  for (auto Item = self.Inventory; Item; ) {
    Inventory Next = Item.Inventory;
    Powerup pup = Powerup(Item);
    if (pup) {
      if (ptyperepl && pup.Class == ptyperepl) return fmax(0, pup.EffectTime);
      if (pup.Class == ptype) return fmax(0, pup.EffectTime);
    }
    Item = Next;
  }

  return 0;
}
