//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************

//==========================================================================
//
//  IsInventoryCheckpointPossible
//
//==========================================================================
bool IsInventoryCheckpointPossible () {
  for (Inventory it = Inventory; it; it = it.Inventory) {
    if (!it.IsCheckpointSaveAllowed()) return false;
  }
  return true;
}


//==========================================================================
//
//  QS_ClearEntityInventory
//
//==========================================================================
override void QS_ClearEntityInventory () {
  DestroyAllInventory();
  if (bIsPlayer && Player && Player.MO == self) {
    PlayerEx plr = PlayerEx(Player);
    plr.SetWeapon(none);
    plr.BringUpWeapon(instant:true, skipSound:true);
  }
}


//==========================================================================
//
//  QS_GetEntityInventory
//
//  returns first item in inventory, or `none`
//
//==========================================================================
override Entity QS_GetEntityInventory () {
  return Inventory;
}


//==========================================================================
//
//  QS_SpawnEntityInventory
//
//  adds to current inventory
//
//==========================================================================
override Entity QS_SpawnEntityInventory (name className) {
  if (!className) return none;

  class!Inventory ec = class!Inventory(FindClass(className));
  if (!ec) return none;
  //ec = GetCompatibleClassReplacement(class!EntityEx, ec);
  //if (ec) ArmorClass = ec;

  Inventory ent = FindInventory(ec, disableReplacement:true);
  if (!ent) {
    ent = Spawn(ec, AllowReplace:false);
    if (!ent) return none;
    ent.AttachToOwner(self);
  }

  return ent;
}


//==========================================================================
//
//  AddInventory
//
//==========================================================================
void AddInventory (Inventory Item) {
  if (!Item) return;

  if (Item.Owner) {
    if (Item.Owner == self) return; // already in the inventory
    // remove from current owner's inventory
    EntityEx(Item.Owner).RemoveInventory(Item);
  }

  // add it at the top of the inventory
  Item.Inventory = Inventory;
  Inventory = Item;

  // set item's owner
  Item.Owner = self;
}


//==========================================================================
//
//  RemoveInventory
//
//==========================================================================
void RemoveInventory (Inventory Item) {
  if (!Item) return;

  // find previous item or owner itself, if it's the first item
  EntityEx Prev = self;
  while (Prev && Prev.Inventory != Item) Prev = Prev.Inventory;

  if (!Prev) {
    print("Cannot remove '%C' from inventory of '%C': it is not there!", Item, self);
    if (Item.Owner) {
      if (Item.Owner != self) print(" OWNER: '%C'", Item.Owner); else print(" OWNER: SELF");
      Item.DetachedFromOwner();
      Item.Owner = none;
    }
    return;
  }

  // unlink and remove owner
  Prev.Inventory = Item.Inventory;
  Item.DetachedFromOwner();
  Item.Owner = none;
}


//==========================================================================
//
//  FindInventory
//
//==========================================================================
final Inventory FindInventory (class!Inventory ItemClass, optional bool disableReplacement) {
  if (!ItemClass) return none;
  class!Inventory repl = class!Inventory(GetClassReplacement(ItemClass));

  for (Inventory Check = Inventory; Check; Check = Check.Inventory) {
    if (Check.Class == ItemClass) return Check;
    // consider replacements too
    if (!disableReplacement && GetClassReplacement(Check.Class) == repl) {
      //print("FOUND REPLACEMENT INVENTORY: ItemClass=<%C>; repl=<%C>; Check=<%C>", ItemClass, repl, Check);
      return Check;
    }
  }

  return none;
}


//==========================================================================
//
//  FindInfiniteAmmoPowerup
//
//==========================================================================
final PowerInfiniteAmmo FindInfiniteAmmoPowerup () {
  auto InfiniteAmmo = Inventory;
  while (InfiniteAmmo) {
    auto pwi = PowerInfiniteAmmo(InfiniteAmmo);
    if (pwi) return pwi;
    InfiniteAmmo = InfiniteAmmo.Inventory;
  }
  return none;
}


//==========================================================================
//
//  GiveInventoryType
//
//==========================================================================
final Inventory GiveInventoryType (class!Inventory Type, optional bool disableReplace/*=false*/) {
  if (!Type) return none;
  Inventory Item = Spawn(Type, default, default, default, AllowReplace:!disableReplace);
  if (!Item) return none;
  // this shouldn't count for the item statistics
  if (Item.bCountItem) {
    Item.bCountItem = false;
    --Level.TotalItems;
  }
  Item.bDropped = true;
  if (!Item.TryPickup(self)) {
    Item.Destroy();
    return none;
  }
  return Item;
}


//==========================================================================
//
//  DestroyAllInventory
//
//==========================================================================
final void DestroyAllInventory () {
  while (Inventory) Inventory.Destroy();
}


//==========================================================================
//
//  UseInventory
//
//==========================================================================
bool UseInventory (Inventory Item) {
  // don't use items if you are dead
  if (Health <= 0) return false;
  // don't use item if don't actually have it
  if (Item.Amount <= 0) return false;
  // tell item that it is used
  if (!Item.Use(false)) return false;
  // item was used, remove it from inventory
  --Item.Amount;
  if (Item.Amount <= 0 && !Item.bKeepDepleted) Item.Destroy();
  return true;
}


//==========================================================================
//
//  DropInventory
//
//==========================================================================
EntityEx DropInventory (Inventory SrcItem) {
  TVec Dir;
  AngleVector(Angles, out Dir);
  Dir.z = 0.0;
  Dir = Normalise(Dir);
  Inventory Item = SrcItem.CreateTossable();
  if (Item) {
    Item.SetOrigin2(Origin+vector(0.0, 0.0, 32.0)+Dir*(Radius+32.0), properFloorCheck:true);
    Item.Angles.yaw = Angles.yaw;
    Item.Velocity = Dir*128.0;
  }
  return Item;
}


//==========================================================================
//
//  ObtainInventory
//
//==========================================================================
void ObtainInventory (EntityEx Other) {
  if (!Other) return; //k8: just in case

  // actor should not have any inventory
  if (Inventory) Error("ObtainInventory called while still having an inventory");

  Inventory = Other.Inventory;
  Other.Inventory = none;
  Inventory Item;
  for (Item = Inventory; Item; Item = Item.Inventory) Item.Owner = self;
}


//===========================================================================
//
//  ClearInventory
//
//===========================================================================
override void ClearInventory () {
  Inventory Item = Inventory;
  while (Item) {
    Inventory Next = Item.Inventory;
    if (!Item.bUndroppable) {
      // IMHO any item that should be kept should not be dropped, not just ammo
      if (Item.bKeepDepleted) {
        Item.Amount = 0;
      } else {
        Item.Destroy();
      }
    } else if (HexenArmor(Item)) {
      HexenArmor A = HexenArmor(Item);
      A.Slots[0] = 0.0;
      A.Slots[1] = 0.0;
      A.Slots[2] = 0.0;
      A.Slots[3] = 0.0;
    }
    Item = Next;
  }

  if (bIsPlayer) {
    PlayerEx(Player).ReadyWeapon = none;
    PlayerEx(Player).PendingWeapon = none;
    Player.SetViewObject(none);
    Player.SetViewState(PS_WEAPON, none);
    Player.SetViewState(PS_FLASH, none);
  }
}


//===========================================================================
//
//  GiveInventory
//
//===========================================================================
override void GiveInventory (name ItemName, int Amount, bool allowReplacement) {
  //printwarn("*** GiveInventory: %s %s", ItemName, Amount);

  if (Amount <= 0) return;
  if (nameicmp(ItemName, 'armor') == 0) ItemName = 'basicarmor';
  if (allowReplacement && nameicmp(ItemName, 'basicarmor') != 0 && nameicmp(ItemName, 'hexenarmor') != 0) allowReplacement = false;

  // get class of the item
  class EClass = FindClassNoCase(ItemName);
  if (!EClass) {
    print("Unknown item type '%s'", ItemName);
    return;
  }

  class!Inventory ItemClass = class!Inventory(EClass);
  if (!ItemClass) {
    print("'%s' is not an inventory class", ItemName);
    return;
  }

  if (allowReplacement) {
    class!Inventory irepl = class!Inventory(GetClassReplacement(ItemClass));
    if (!irepl) {
      print("'%s' replacement is not an inventory class, ignoring it", ItemName);
    } else {
      ItemClass = irepl;
    }
  }

  Weapon SavedPendingWeapon = none;
  bool HadWeapon = true;
  if (bIsPlayer) {
    SavedPendingWeapon = PlayerEx(Player).PendingWeapon;
    HadWeapon = !!PlayerEx(Player).ReadyWeapon;
  }

  Inventory Item = Spawn(ItemClass, default, default, default, AllowReplace:false);
  if (!Item) return;

  // this shouldn't count for the item statistics
  if (Item.bCountItem) {
    Item.bCountItem = false;
    --Level.TotalItems;
  }
       if (BasicArmorPickup(Item)) BasicArmorPickup(Item).SaveAmount *= Amount;
  else if (BasicArmorBonus(Item)) BasicArmorBonus(Item).SaveAmount *= Amount;
  else Item.Amount = Amount;

  if (!Item.TryPickup(self)) Item.Destroy();

  // don't automatically bring up weapon
  if (bIsPlayer && HadWeapon) {
    PlayerEx(Player).PendingWeapon = SavedPendingWeapon;
  }
}


//===========================================================================
//
//  TakeInventory
//
//===========================================================================
override void TakeInventory (name ItemName, int Amount, bool allowReplacement) {
  //printwarn("*** TakeInventory: %s %s", ItemName, Amount);

  if (Amount <= 0) return;
  if (nameicmp(ItemName, 'armor') == 0) ItemName = 'basicarmor';
  if (allowReplacement && nameicmp(ItemName, 'basicarmor') != 0 && nameicmp(ItemName, 'hexenarmor') != 0) allowReplacement = false;

  // get class of the item
  class!Inventory ItemClass = class!Inventory(FindClassNoCase(ItemName));
  if (!ItemClass) return;

  Inventory Item = FindInventory(ItemClass, disableReplacement:!allowReplacement);
  if (!Item) return;

  Item.Amount -= Amount;
  if (Item.Amount <= 0) {
    if (Item.bKeepDepleted) {
      Item.Amount = 0;
    } else {
      Item.Destroy();
    }
  }
}


//===========================================================================
//
//  CheckInventory
//
//===========================================================================
override int CheckInventory (name ItemName, bool allowReplacement) {
  //printwarn("*** CheckInventory: %s", ItemName);

       if (nameicmp(ItemName, 'armor') == 0) ItemName = 'basicarmor';
  else if (nameicmp(ItemName, 'health') == 0) return Health;
  if (allowReplacement && nameicmp(ItemName, 'basicarmor') != 0 && nameicmp(ItemName, 'hexenarmor') != 0) allowReplacement = false;

  class!Inventory ItemClass = class!Inventory(FindClassNoCase(ItemName));
  if (ItemClass) {
    Inventory Item = FindInventory(ItemClass, disableReplacement:!allowReplacement);
    return (Item ? Item.Amount : 0);
  }
  return 0;
}


//===========================================================================
//
//  UseInventoryName
//
//===========================================================================
override int UseInventoryName (name ItemName, bool allowReplacement) {
  class!Inventory ItemClass = class!Inventory(FindClassNoCase(ItemName));
  if (ItemClass) {
    Inventory Item = FindInventory(ItemClass, disableReplacement:!allowReplacement);
    if (Item) return UseInventory(Item);
  }
  return 0;
}


//===========================================================================
//
//  GetArmorPoints
//
//===========================================================================
override int GetArmorPoints () {
  Inventory A = FindInventory(BasicArmor);
  return (A ? A.Amount : 0);
}


//===========================================================================
//
//  GetArmorPointsForType
//
//===========================================================================
override int GetArmorPointsForType (name armtype) {
  if (!armtype || nameicmp(armtype, 'None') == 0) return 0;
  BasicArmor armor = BasicArmor(FindInventory(BasicArmor));
  if (!armor) return 0;
  //FIXME: should we really try parents here?
  if (nameicmp(armtype, armor.GetArmorName()) == 0) return max(0, armor.Amount);
  /*
  if (armor.GetArmorName() == 'None') return 0;
  class!Inventory aclass = armor.ArmorClass;
  while (aclass) {
    if (nameicmp(armtype, GetClassName(aclass)) == 0) return max(0, armor.Amount);
    aclass = class!Inventory(GetClassParent(aclass));
  }
  */
  return 0;
}


//===========================================================================
//
//  CheckNamedWeapon
//
//===========================================================================
override int CheckNamedWeapon (name Name) {
  if (!bIsPlayer || !PlayerEx(Player).ReadyWeapon) return false;
  return (nameicmp(Name, GetClassName(PlayerEx(Player).ReadyWeapon.Class)) == 0);
}


//===========================================================================
//
//  SetNamedWeapon
//
//===========================================================================
override int SetNamedWeapon (name Name) {
  if (!bIsPlayer) return false;

  Weapon Wpn = Weapon(FindInventory(class!Inventory(FindClassNoCase(Name)), disableReplacement:true));
  if (!Wpn) return false;

  // check if it's already active
  if (PlayerEx(Player).ReadyWeapon == Wpn) {
    // make sure player doesn't switch away from it
    PlayerEx(Player).PendingWeapon = none;
    return true;
  }

  // check if weapon has enough ammo
  if (!Wpn.CheckAmmo(Weapon::FIRE_Either, AutoSwitch:false)) return false;

  PlayerEx(Player).PendingWeapon = Wpn;
  return true;
}


//===========================================================================
//
//  GetAmmoCapacity
//
//===========================================================================
override int GetAmmoCapacity (name Name) {
  class!Ammo AmmoType = class!Ammo(FindClassNoCase(Name));
  if (!AmmoType) return 0;

  // only direct descendants of Ammo class
  if (GetClassParent(AmmoType) != Ammo) return 0;

  // if we have this ammo, return current max amount, otherwise return
  // default for this ammo type
  Inventory Item = FindInventory(AmmoType);
  if (!Item) return AmmoType.default.MaxAmount;
  Ammo ammo = Ammo(Item);
  if (ammo) return ammo.k8GetAmmoKingMax();
  return Item.MaxAmount;
}


//===========================================================================
//
//  SetAmmoCapacity
//
//===========================================================================
override void SetAmmoCapacity (name Name, int Amount) {
  class!Ammo AmmoType = class!Ammo(FindClassNoCase(Name));
  if (!AmmoType) return;

  // only direct descendants of Ammo class
  if (GetClassParent(AmmoType) != Ammo) return;

  // make sure new ammo capacity is not negative
  Amount = max(0, Amount);

  Inventory Item = FindInventory(AmmoType);
  if (!Item) {
    Item = GiveInventoryType(AmmoType);
    if (!Item) {
      print("cannot give ammo of type `%C` (%s)", AmmoType, Name);
      return;
    }
    Item.Amount = 0;
  }
  Item.MaxAmount = Amount;

  // we also should make sure that the current amount doesn't exceed the new limit
  Ammo ammo = Ammo(Item);
  if (ammo) {
    if (ammo.Amount > ammo.k8GetAmmoKingMax()) ammo.Amount = ammo.k8GetAmmoKingMax();
  } else {
    if (Item.Amount > Item.MaxAmount) Item.Amount = Item.MaxAmount;
  }
}


//===========================================================================
//
//  FindActivePowerupTime
//
//===========================================================================
override float FindActivePowerupTime (name className) {
  //EntityEx tgt = EntityEx(DecorDoAAPtr('FindActivePowerupTime', aptr!optional));
  //if (!tgt) return 0;

  if (!className) return 0;
  class!Powerup ptype = class!Powerup(FindClassNoCase(className));
  if (!ptype) return 0;
  class!Powerup ptyperepl = class!Powerup(GetClassReplacement(ptype));

  for (auto Item = self.Inventory; Item; ) {
    Inventory Next = Item.Inventory;
    Powerup pup = Powerup(Item);
    if (pup) {
      if (ptyperepl && pup.Class == ptyperepl) return fmax(0, pup.EffectTime);
      if (pup.Class == ptype) return fmax(0, pup.EffectTime);
    }
    Item = Next;
  }

  return 0;
}
