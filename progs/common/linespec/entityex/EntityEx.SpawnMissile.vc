//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

//==========================================================================
//
//  PlayMissileSpawnSound
//
//==========================================================================

final void PlayMissileSpawnSound(EntityEx Source)
{
  if (SightSound)
  {
    if (!bSpawnSoundSource)
    {
      PlaySound(SightSound, CHAN_VOICE);
    }
    else if (Source)
    {
      Source.PlaySound(SightSound, CHAN_WEAPON);
    }
    else
    {
      PlaySound(SightSound, CHAN_WEAPON);
    }
  }
}

//==========================================================================
//
//  CheckMissileSpawn
//
//  Moves the missile forward a bit and possibly explodes it right there.
//
//==========================================================================

final bool CheckMissileSpawn()
{
  if (bRandomise && StateTime > 0.0)
  {
    StateTime -= Random() * 0.1;
    if (StateTime < 1.0 / 35.0)
      StateTime = 1.0 / 35.0;
  }

  // move a little forward so an angle can be computed if it
  // immediately explodes
  UnlinkFromWorld();
  if (Speed > 100.0 * 35.0)
  {
    //  Ultra-fast missile
    Origin += Velocity * 0.0142857143 / 8.0;
  }
  else
  {
    //  Normal missile
    Origin += Velocity * 0.0142857143;
  }
  LinkToWorld();
  tmtrace_t tmtrace;
  if (!TryMoveEx(&tmtrace, Origin, false))
  {
    //  Don't explode ripping missiles that spawn inside another thing.
    if (!tmtrace.BlockingMobj || !bRip ||
      EntityEx(tmtrace.BlockingMobj).bDontRip)
    {
      if (CountsAsKill())
      {
        bCountKill = false;
        Level.TotalKills--;
      }
      //  Don't explode missiles on horizon lines.
      if (tmtrace.BlockingLine && tmtrace.BlockingLine->special == LNSPEC_LineHorizon)
      {
        Destroy();
      }
      else
      {
        ExplodeMissile(EntityEx(tmtrace.BlockingMobj));
      }
      return false;
    }
  }
  return true;
}


//==========================================================================
//
//  ExplodeMissile
//
//==========================================================================
final bool ExplodeMissile (EntityEx Victim, optional line_t *line) {
  if (bExploCount) {
    if (++Special2 < Special1) return false;
  }

  TVec savedVelocity = Velocity;

  Velocity = vector(0.0, 0.0, 0.0);

  state ExplState = none;
  if (Victim && (Victim.bShootable || Victim.bCorpse)) {
    if (Victim.bNoBlood) ExplState = FindState('Crash');
    if (!ExplState) ExplState = FindState('Death', 'Extreme');
  }
  if (!ExplState) ExplState = FindState('Death');

  if (!SetState(ExplState)) return false;

  //k8:TODO: this should be strictly client-side
  if (line && DecalName) {
    if (GetCvarB('k8ExplodeMissleTest')) print("MISSILE DECAL: <%s> (side:%d:%d) vel:(%f,%f,%f)", NameToStr(DecalName), PointOnPlaneSide(Origin, line), PointOnPlaneSide(Origin-savedVelocity, line), savedVelocity.x, savedVelocity.y, savedVelocity.z);
    //TVec v1, v2;
    TVec dir = Normalise(savedVelocity);
    trsplat_t tr;
    // trace without z offset
    if (TraceSplat(Origin-dir*2, dir, 64.0, &tr, 0)) {
      if (GetCvarB('k8ExplodeMissleTest')) {
        auto side = PointOnPlaneSide(Origin-savedVelocity, line); // move out a little, just in case
        sector_t *sec = (side ? line->backsector : line->frontsector);
        print("  MISSILE SPLAT: side=%d; org=(%f,%f,%f); hit=(%f,%f,%f); sameline:%s; samesec:%s", tr.side, tr.org.x, tr.org.y, tr.org.z, tr.hit.x, tr.hit.y, tr.hit.z, (tr.line == line ? "tan" : "ona"), (tr.sec == sec ? "tan" : "ona"));
      }
      //if (GetCvarB('k8ExplodeMissleTest')) print("    itt=(%f,%f,%f)", itt.x, itt.y, itt.z);
      SpawnDecal(tr.hit, DecalName, tr.side, tr.line);
    } else {
      if (GetCvarB('k8ExplodeMissleTest')) print("  MISSILE SPLAT TRACER FAILED!");
    }
  } else {
    if (GetCvarB('k8ExplodeMissleTest')) {
      if (Victim) print("MISSILE VICTIM: <%n>", GetClassName(Victim.Class));
      else if (DecalName) {
        print("MISSILE DECAL, BUT NO LINE: <%n>", DecalName);
        //print("%p", line->frontsector);
      } else {
        print("MISSILE WITHOUT DECAL (%n) %n %n", GetClassName(Class), DecalName, self.default.DecalName);
      }
    }
  }

  if (bDehExplosion) {
    if (LineSpecialGameInfo(Level.Game).DehExplosionStyle == 255) {
      // explosion style is controlled by a cvar
      if (GetCvar('addrocketexplosion')) {
        RenderStyle = STYLE_Add;
        Alpha = 1.0;
      } else {
        RenderStyle = STYLE_Translucent;
        Alpha = 0.666;
      }
    } else {
      RenderStyle = LineSpecialGameInfo(Level.Game).DehExplosionStyle;
      Alpha = LineSpecialGameInfo(Level.Game).DehExplosionAlpha;
    }
  }

  if (bRandomise) {
    StateTime -= Random()*0.1;
    if (StateTime < 1.0/35.0) StateTime = 1.0/35.0;
  }

  bMissile = false;

  if (DeathSound) {
    PlaySound(DeathSound, CHAN_VOICE, 1.0, (bFullVolDeath ? ATTN_NONE : ATTN_NORMAL));
  }

  if (!bLeaveTrail && bDynamicLight) {
    SendExplosion(DLightColour, DLightRadius, Origin);
    bDynamicLight = false;
  }
  bLeaveTrail = false;
  return true;
}


//==========================================================================
//
//  SpawnMissile
//
//  Returns nullptr if the missile exploded immediately, otherwise returns
// a Actor reference to the missile.
//
//==========================================================================

final EntityEx SpawnMissile(EntityEx dest, class!EntityEx type,
  optional float SpawnHeight)
{
  EntityEx A;
  TVec org;
  TVec dir;

  org = Origin;
  if (specified_SpawnHeight)
  {
    org.z += SpawnHeight;
  }
  else if (type.default.bIgnoreFloorStep)
  {
    org.z = ONFLOORZ + FloorClip;
  }
  else if (type.default.bIgnoreCeilingStep)
  {
    org.z = ONCEILINGZ;
  }
  else
  {
    org.z += 32.0;
  }
  if (org.z != ONFLOORZ)
  {
    org.z -= FloorClip;
  }
  A = Spawn(type, org);
  if (A) A.DecalName = A.default.DecalName;

  A.PlayMissileSpawnSound(self);

  A.Target = self;  // where it came from

  if (dest)
  {
    dir = dest.Origin - Origin;
    if (dest.bShadow)
    {
      // Invisible target
      VectorRotateAroundZ(ref dir, (Random() - Random()) * 45.0 / 2.0);
    }
  }
  else
  {
    dir = Velocity;
  }
  dir = Normalise(dir);
  A.Velocity = dir * A.Speed;
  // Floor and ceiling huggers should never have a vertical component to their velocity
  if (A.bIgnoreCeilingStep || A.bIgnoreFloorStep)
  {
    A.Velocity.z = 0.0;
  }
  // Adjust the trajectory if the missile will go over the target's head.
  else if (dest && Origin.z >= dest.Origin.z && Origin.z <= dest.Origin.z + dest.Height && A.Origin.z >= dest.Origin.z + dest.Height)
  {
    float dist = fmax(1.0, A.DistTo(dest));
    if (!dist.isfinite) dist = 1;
    dir.z += (dest.Origin.z + dest.Height - A.Origin.z) / dist;
    dir = Normalise(dir);

    A.Velocity.z = dir.z * A.Speed;
  }
  VectorAngles(dir, out A.Angles);

  return A.CheckMissileSpawn() ? A : none;
}

//==========================================================================
//
//  SpawnMissileXYZ
//
//  Returns nullptr if the missile exploded immediately, otherwise returns
// a Actor reference to the missile.
//
//==========================================================================

final EntityEx SpawnMissileXYZ(TVec org, EntityEx dest, class!EntityEx type)
{
  TVec    dir;
  EntityEx  A;

  if (org.z != ONFLOORZ)
  {
    org.z -= FloorClip;
  }
  A = Spawn(type, org);
  if (A) A.DecalName = A.default.DecalName;
  A.PlayMissileSpawnSound(self);
  A.Target = self;  // Originator
  dir = dest.Origin - Origin;
  if (dest.bShadow)
  {
    // Invisible target
    VectorRotateAroundZ(ref dir, (Random() - Random()) * 45.0);
  }
  dir = Normalise(dir);
  A.Velocity = dir * A.Speed;
  // Floor and ceiling huggers should never have a vertical component to their velocity
  if (A.bIgnoreCeilingStep || A.bIgnoreFloorStep)
  {
    A.Velocity.z = 0.0;
  }
  // Adjust the trajectory if the missile will go over the target's head.
  else if (dest && Origin.z >= dest.Origin.z && Origin.z <= dest.Origin.z + dest.Height && A.Origin.z >= dest.Origin.z + dest.Height)
  {
    float dist = fmax(1.0, A.DistTo(dest));
    if (!dist.isfinite) dist = 1;
    dir.z += (dest.Origin.z + dest.Height - A.Origin.z) / dist;
    dir = Normalise(dir);

    A.Velocity.z = dir.z * A.Speed;
  }
  VectorAngles(dir, out A.Angles);
  return A.CheckMissileSpawn() ? A : none;
}

//==========================================================================
//
//  SpawnMissileZAimed
//
//==========================================================================

final EntityEx SpawnMissileZAimed(float z, EntityEx dest, class!EntityEx type)
{
  EntityEx  A;
  TVec    dir;
  TVec        org;
  float   dist;

  org = Origin + vector(0.0, 0.0, z != ONFLOORZ ? z - FloorClip : z);

  A = Spawn(type, org);
  if (A) A.DecalName = A.default.DecalName;

  A.PlayMissileSpawnSound(self);

  A.Target = self;  // where it came from

  dist = fmax(1.0, DistTo2(dest));
  if (!dist.isfinite) dist = 0;
  dir.x = cos(Angles.yaw);
  dir.y = sin(Angles.yaw);
  dir.z = (dist != 0.0 ? (dest.Origin.z - Origin.z) / dist : A.Speed);
  // fuzzy player
  if (dest.bShadow)
  {
    VectorRotateAroundZ(ref dir, (Random() - Random()) * 45.0 / 2.0);
  }
  dir = Normalise(dir);
  A.Velocity = dir * A.Speed;
  // Floor and ceiling huggers should never have a vertical component to their velocity
  if (A.bIgnoreCeilingStep || A.bIgnoreFloorStep)
  {
    A.Velocity.z = 0.0;
  }
  // Adjust the trajectory if the missile will go over the target's head.
  else if (dest && Origin.z >= dest.Origin.z && Origin.z <= dest.Origin.z + dest.Height && A.Origin.z >= dest.Origin.z + dest.Height)
  {
    float dist2 = fmax(1.0, A.DistTo(dest));
    if (!dist2.isfinite) dist2 = 1;
    dir.z += (dest.Origin.z + dest.Height - A.Origin.z) / dist2;
    dir = Normalise(dir);

    A.Velocity.z = dir.z * A.Speed;
  }
  VectorAngles(dir, out A.Angles);

  return A.CheckMissileSpawn() ? A : none;
}


//==========================================================================
//
//  SpawnMissileAngles
//
//  Returns nullptr if the missile exploded immediately, otherwise returns
//  a Actor reference to the missile.
//
//==========================================================================
final EntityEx SpawnMissileAngles (class!EntityEx type, float yaw, float pitch,
                                   optional float SpawnHeight)
{
  if (!type) return none;
  TVec dir;

  TVec org = Origin;
       if (specified_SpawnHeight) org.z += SpawnHeight;
  else if (type.default.bIgnoreFloorStep) org.z = ONFLOORZ+FloorClip;
  else if (type.default.bIgnoreCeilingStep) org.z = ONCEILINGZ;
  else org.z += 32.0;

  if (org.z != ONFLOORZ) org.z -= FloorClip;

  EntityEx A = Spawn(type, org);
  if (!A) return none;
  if (!A.DecalName) A.DecalName = type.default.DecalName;
  A.PlayMissileSpawnSound(self);
  A.Target = self; // originator
  A.Angles.yaw = yaw;
  A.Angles.pitch = pitch;
  AngleVector(A.Angles, out dir);
  A.Velocity = A.Speed*dir;
  // floor and ceiling huggers should never have a vertical component to their velocity
  if (A.bIgnoreCeilingStep || A.bIgnoreFloorStep) A.Velocity.z = 0.0;
  return (A.CheckMissileSpawn() ? A : none);
}


//==========================================================================
//
//  SpawnMissileAngle
//
//  Returns nullptr if the missile exploded immediately, otherwise returns
//  a Actor reference to the missile.
//
//==========================================================================
final EntityEx SpawnMissileAngle (class!EntityEx type, float angle,
                                  float momz, optional float SpawnHeight)
{
  if (!type) return none;

  TVec org = Origin;
       if (specified_SpawnHeight) org.z += SpawnHeight;
  else if (type.default.bIgnoreFloorStep) org.z = ONFLOORZ+FloorClip; // minotaur floor fire missile
  else if (type.default.bIgnoreCeilingStep) org.z = ONCEILINGZ;
  else org.z += 32.0;

  if (org.z != ONFLOORZ) org.z -= FloorClip;

  EntityEx mo = Spawn(type, org);
  if (!mo) return none;
  if (!mo.DecalName) mo.DecalName = type.default.DecalName;
  mo.PlayMissileSpawnSound(self);
  mo.Target = self; // originator
  mo.Angles.yaw = angle;
  mo.Velocity.x = mo.Speed*cos(angle);
  mo.Velocity.y = mo.Speed*sin(angle);
  mo.Velocity.z = momz;
  return (mo.CheckMissileSpawn() ? mo : none);
}


//==========================================================================
//
//  SpawnMissileAngleSpeed
//
//  Returns nullptr if the missile exploded immediately, otherwise returns
//  a Actor reference to the missile.
//
//==========================================================================
final EntityEx SpawnMissileAngleSpeed (class!EntityEx type, float angle,
                                       float momz, float speed)
{
  if (!type) return none;

  TVec org = Origin;
  if (org.z != ONFLOORZ) org.z -= FloorClip;

  EntityEx mo = Spawn(type, org);
  if (!mo) return none;
  if (!mo.DecalName) mo.DecalName = type.default.DecalName;
  mo.Tracer = self; // Originator
  mo.Angles.yaw = angle;
  mo.Velocity.x = speed * cos(angle);
  mo.Velocity.y = speed * sin(angle);
  mo.Velocity.z = momz;
  mo.PlayMissileSpawnSound(self);
  return mo.CheckMissileSpawn() ? mo : none;
}


//==========================================================================
//
//  SpawnSubMissile
//
//==========================================================================
final EntityEx SpawnSubMissile (class!EntityEx type, EntityEx AInstigator) {
  TVec dir;

  EntityEx other = Spawn(type, Origin);
  if (!other) return none;

  other.Target = AInstigator;
  other.Angles = Angles;
  other.DecalName = other.default.DecalName;

  other.Velocity.x = other.Speed*cos(Angles.yaw);
  other.Velocity.y = other.Speed*sin(Angles.yaw);
  AimLineAttack(dir, Angles, 1024.0);
  other.Velocity.z = other.Speed*dir.z;
  other.CheckMissileSpawn();
  return other;
}


//==========================================================================
//
//  SpawnPlayerMissile
//
//==========================================================================
final EntityEx SpawnPlayerMissile (class!EntityEx type, optional name decalType) {
  EntityEx AimTarget;
  return SpawnPlayerMissileEx(type, false, AimTarget, default, default, decalType);
}


//==========================================================================
//
//  SpawnPlayerMissileAngle
//
//==========================================================================
final EntityEx SpawnPlayerMissileAngle (class!EntityEx type, float angle) {
  EntityEx AimTarget;
  return SpawnPlayerMissileEx(type, false, AimTarget, angle);
}


//===========================================================================
//
//  SpawnPlayerMissileAngleXYZ
//
//===========================================================================
final EntityEx SpawnPlayerMissileAngleXYZ (TVec org, class!EntityEx type, float angle) {
  EntityEx AimTarget;
  return SpawnPlayerMissileEx(type, false, AimTarget, angle, org);
}


//==========================================================================
//
//  SpawnPlayerMissileEx
//
//  Tries to aim at a nearby monster
//
//==========================================================================
final EntityEx SpawnPlayerMissileEx (class!EntityEx type, bool RetExploded,
  out EntityEx AimTarget, optional float angle, optional TVec SpawnOrg, optional name decalType,
  optional bool noAutoAim)
{
  if (!type) return none;
  TVec dir;

  // try to find a target
  if (specified_angle) {
    AimTarget = Aim(dir, 16.0*64.0, angle, noAutoaim:noAutoAim!optional);
  } else {
    AimTarget = Aim(dir, 16.0*64.0, noAutoaim:noAutoAim!optional);
  }

  TVec org = (specified_SpawnOrg ? SpawnOrg : Origin);
  if (type.default.bIgnoreFloorStep) {
    org.z = ONFLOORZ;
    dir.z = 0.0;
    dir = Normalise(dir);
  } else if (type.default.bIgnoreCeilingStep) {
    org.z = ONCEILINGZ;
    dir.z = 0.0;
    dir = Normalise(dir);
  } else {
    org.z += Height*0.5-FloorClip;
    // missiles are spawned 4 units lower than hitscan attacks
    // add an extra unit to simulate Doom's original behaviour
    if (bIsPlayer) {
      org.z += PlayerEx(Player).GetAttackZOfs(missile:true)-3.0;
    } else {
      org.z += 5.0;
    }
  }

  EntityEx A = Spawn(type, org);
  if (!A) return none;
  if (!A.DecalName) A.DecalName = type.default.DecalName;
  if (specified_decalType && decalType) {
    if (GetCvarB('k8ExplodeMissleTest')) print("missile decal set to <%n>", decalType);
    A.DecalName = decalType;
  }

  A.PlayMissileSpawnSound(self);

  A.Target = self;
  A.Velocity = dir*A.Speed;
  // adjust the trajectory if the missile will go over the target's head
  if (AimTarget && Origin.z >= AimTarget.Origin.z &&
      Origin.z <= AimTarget.Origin.z+AimTarget.Height &&
      A.Origin.z >= AimTarget.Origin.z+AimTarget.Height)
  {
    float dist = fmax(1.0, A.DistTo(AimTarget));
    if (!dist.isfinite) dist = 1;
    dir.z += (AimTarget.Origin.z+AimTarget.Height-A.Origin.z)/dist;
    dir = Normalise(dir);
    A.Velocity.z = dir.z*A.Speed;
  }
  VectorAngles(dir, out A.Angles);

  return (A.CheckMissileSpawn() || RetExploded ? A : none);
}
