//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************

//==========================================================================
//
//  PlayMissileSpawnSound
//
//==========================================================================
final void PlayMissileSpawnSound (EntityEx Source) {
  if (SightSound) {
         if (!bSpawnSoundSource) PlaySound(SightSound, CHAN_VOICE);
    else if (Source) Source.PlaySound(SightSound, CHAN_WEAPON);
    else PlaySound(SightSound, CHAN_WEAPON);
  }
}


//==========================================================================
//
//  CheckMissileSpawn
//
//  Moves the missile forward a bit and possibly explodes it right there.
//
//==========================================================================
final bool CheckMissileSpawn () {
  if (bRandomise && StateTime > 0.0) StateTime = fmax(1.0/35.0, StateTime-Random()*0.1);

  // move a little forward so an angle can be computed if it immediately explodes
  UnlinkFromWorld();
  bIntrJustMoved = false; // disable movement interpolation
  if (Speed > 100.0*35.0) {
    // ultra-fast missile
    Origin += Velocity*0.0142857143/8.0;
  } else {
    // normal missile
    Origin += Velocity*0.0142857143;
  }
  LinkToWorld();

  tmtrace_t tmtrace;
  if (!TryMoveEx(&tmtrace, Origin, AllowDropOff:false)) {
    // don't explode ripping missiles that spawn inside another thing
    if (!tmtrace.BlockingMobj || !bRip || EntityEx(tmtrace.BlockingMobj).bDontRip) {
      if (CountsAsKill()) {
        bCountKill = false;
        --Level.TotalKills;
      }
      // don't explode missiles on horizon lines
      if (tmtrace.BlockingLine && tmtrace.BlockingLine->special == LNSPEC_LineHorizon) {
        Destroy();
      } else {
        ExplodeMissile(EntityEx(tmtrace.BlockingMobj), line:tmtrace.BlockingLine);
      }
      return false;
    }
  }

  return true;
}


//==========================================================================
//
//  ExplodeMissile
//
//==========================================================================
final bool ExplodeMissile (EntityEx Victim, optional line_t *line) {
  if (bExploCount) {
    if (++Special2 < Special1) return false;
  }

  if (line) {
    // don't explode on horizon lines (just in case check)
    if (line->special == LNSPEC_LineHorizon && !bExplodeOnSky) {
      Destroy();
      return false;
    }
  }

  TVec savedVelocity = Velocity;

  Velocity = vector(0.0, 0.0, 0.0);

  state ExplState = none;
  if (Victim && (Victim.bShootable || Victim.bCorpse)) {
    if (Victim.bNoBlood) ExplState = FindState('Crash');
    if (!ExplState) ExplState = FindState('Death', 'Extreme');
  }
  if (!ExplState) ExplState = FindState('Death');

  if (!SetState(ExplState)) return false;

  if (Victim) {
    if (bHitTarget) Target = Victim;
    if (bHitMaster) Master = Victim;
    if (bHitTracer) Tracer = Victim;
    // check for shootable corpses here
  }

  //k8:TODO: this should be strictly client-side
  if (line && DecalName) {
    //if (GetCvarB('k8ExplodeMissleTest')) print("MISSILE DECAL: <%s> (side:%d:%d) vel:(%f,%f,%f)", DecalName, PointOnPlaneSide(Origin, *line), PointOnPlaneSide(Origin-savedVelocity, *line), savedVelocity.x, savedVelocity.y, savedVelocity.z);
    //TVec v1, v2;
    TVec dir = Normalise(savedVelocity);
    trsplat_t tr;
    // trace without z offset
    /*
    if (GetCvarB('k8ExplodeMissleTest')) {
      if (TraceSplat(Origin-dir*2, dir, 64.0, &tr, 0)) {
        auto side = PointOnPlaneSide(Origin-savedVelocity, *line); // move out a little, just in case
        sector_t *sec = (side ? line->backsector : line->frontsector);
        print("  MISSILE SPLAT: side=%d; org=(%f,%f,%f); hit=(%f,%f,%f); sameline:%s; samesec:%s", tr.side, tr.org.x, tr.org.y, tr.org.z, tr.hit.x, tr.hit.y, tr.hit.z, (tr.line == line ? "tan" : "ona"), (tr.sec == sec ? "tan" : "ona"));
      } else {
        print("  MISSILE SPLAT TRACER FAILED!");
      }
    }
    */
    //if (TraceSplat(Origin-dir*2, dir, 64.0, &tr, 0)) SpawnDecal(tr.hit, DecalName, tr.side, tr.line);
    TraceSplat(Origin-dir*2, dir, 64.0, &tr, 0, DecalName, translation:(bCopyBloodTranslation ? Translation : 0));
  } else {
    /*
    if (GetCvarB('k8ExplodeMissleTest')) {
      if (Victim) print("MISSILE VICTIM: <%n>", GetClassName(Victim.Class));
      else if (DecalName) {
        print("MISSILE DECAL, BUT NO LINE: <%n>", DecalName);
        //print("%p", line->frontsector);
      } else {
        print("MISSILE WITHOUT DECAL (%n) %n %n", GetClassName(Class), DecalName, self.default.DecalName);
      }
    }
    */
  }

  if (bDehExplosion) {
    if (LineSpecialGameInfo(Level.Game).DehExplosionStyle == 255) {
      // explosion style is controlled by a cvar
      if (GetCvar('addrocketexplosion')) {
        RenderStyle = STYLE_Add;
        Alpha = 1.0;
      } else {
        RenderStyle = STYLE_Translucent;
        Alpha = 0.666;
      }
    } else {
      RenderStyle = LineSpecialGameInfo(Level.Game).DehExplosionStyle;
      Alpha = LineSpecialGameInfo(Level.Game).DehExplosionAlpha;
    }
  }

  if (bRandomise) StateTime = fmax(1.0/35.0, StateTime-Random()*0.1);

  bMissile = false;

  if (DeathSound) {
    PlaySound(DeathSound, CHAN_VOICE, 1.0, (bFullVolDeath ? ATTN_NONE : ATTN_NORMAL));
  }

  if (!bLeaveTrail && bDynamicLight) {
    SendExplosion(DLightColor, DLightRadius, Origin);
    bDynamicLight = false;
  }
  bLeaveTrail = false;
  return true;
}


//==========================================================================
//
//  SpawnMissile
//
//  Returns nullptr if the missile exploded immediately, otherwise returns
//  a Actor reference to the missile.
//
//==========================================================================
final EntityEx SpawnMissile (EntityEx dest, class!EntityEx type, optional float spawnheight) {
  TVec dir;

  TVec org = Origin;
       if (specified_spawnheight) org.z += spawnheight;
  else if (type.default.bIgnoreFloorStep) org.z = ONFLOORZ+FloorClip;
  else if (type.default.bIgnoreCeilingStep) org.z = ONCEILINGZ;
  else org.z += 32.0;

  if (org.z != ONFLOORZ) org.z -= FloorClip;

  EntityEx A = Spawn(type, org);
  if (A) A.DecalName = A.default.DecalName;
  A.CarryBloodTranslations(self);

  A.PlayMissileSpawnSound(self);

  A.Target = self; // where it came from

  if (dest) {
    dir = dest.Origin-Origin;
    if (dest.bShadow) {
      // invisible target
      VectorRotateAroundZ(ref dir, (Random()-Random())*45.0/2.0);
    }
  } else {
    dir = Velocity;
  }
  dir = Normalise(dir);
  A.Velocity = dir*A.Speed;

  // floor and ceiling huggers should never have a vertical component to their velocity
  if (A.bIgnoreCeilingStep || A.bIgnoreFloorStep) {
    A.Velocity.z = 0.0;
  } else if (dest && Origin.z >= dest.Origin.z && Origin.z <= dest.Origin.z+dest.Height && A.Origin.z >= dest.Origin.z+dest.Height) {
    // adjust the trajectory if the missile will go over the target's head
    float dist = fmax(1.0, A.DistTo(dest));
    if (!dist.isfinite) dist = 1;
    dir.z += (dest.Origin.z+dest.Height-A.Origin.z)/dist;
    dir = Normalise(dir);

    A.Velocity.z = dir.z*A.Speed;
  }
  VectorAngles(dir, out A.Angles);

  return (A.CheckMissileSpawn() ? A : none);
}


//==========================================================================
//
//  SpawnMissileXYZ
//
//  Returns nullptr if the missile exploded immediately, otherwise returns
// a Actor reference to the missile.
//
//==========================================================================
final EntityEx SpawnMissileXYZ (TVec org, EntityEx dest, class!EntityEx type) {
  TVec dir;

  if (org.z != ONFLOORZ) org.z -= FloorClip;

  EntityEx A = Spawn(type, org);
  if (A) A.DecalName = A.default.DecalName;
  A.CarryBloodTranslations(self);
  A.PlayMissileSpawnSound(self);
  A.Target = self;  // Originator
  dir = dest.Origin-Origin;
  if (dest.bShadow) {
    // invisible target
    VectorRotateAroundZ(ref dir, (Random()-Random())*45.0);
  }
  dir = Normalise(dir);
  A.Velocity = dir*A.Speed;

  // floor and ceiling huggers should never have a vertical component to their velocity
  if (A.bIgnoreCeilingStep || A.bIgnoreFloorStep) {
    A.Velocity.z = 0.0;
  } else if (dest && Origin.z >= dest.Origin.z && Origin.z <= dest.Origin.z+dest.Height && A.Origin.z >= dest.Origin.z+dest.Height) {
    // adjust the trajectory if the missile will go over the target's head
    float dist = fmax(1.0, A.DistTo(dest));
    if (!dist.isfinite) dist = 1;
    dir.z += (dest.Origin.z+dest.Height-A.Origin.z)/dist;
    dir = Normalise(dir);

    A.Velocity.z = dir.z*A.Speed;
  }
  VectorAngles(dir, out A.Angles);

  return (A.CheckMissileSpawn() ? A : none);
}


//==========================================================================
//
//  SpawnMissileZAimed
//
//==========================================================================
final EntityEx SpawnMissileZAimed (float z, EntityEx dest, class!EntityEx type) {
  TVec dir;

  TVec org = Origin+vector(0.0, 0.0, z != ONFLOORZ ? z-FloorClip : z);

  EntityEx A = Spawn(type, org);
  if (A) A.DecalName = A.default.DecalName;
  A.CarryBloodTranslations(self);

  A.PlayMissileSpawnSound(self);

  A.Target = self;  // where it came from

  float dist = fmax(1.0, DistTo2(dest));
  if (!dist.isfinite) dist = 0;
  sincos(Angles.yaw, out dir.y, out dir.x);
  dir.z = (dist != 0.0 ? (dest.Origin.z-Origin.z)/dist : A.Speed);
  // fuzzy player
  if (dest.bShadow) VectorRotateAroundZ(ref dir, (Random()-Random())*45.0/2.0);
  dir = Normalise(dir);
  A.Velocity = dir*A.Speed;
  // floor and ceiling huggers should never have a vertical component to their velocity
  if (A.bIgnoreCeilingStep || A.bIgnoreFloorStep) {
    A.Velocity.z = 0.0;
  } else if (dest && Origin.z >= dest.Origin.z && Origin.z <= dest.Origin.z+dest.Height && A.Origin.z >= dest.Origin.z+dest.Height) {
    // adjust the trajectory if the missile will go over the target's head
    float dist2 = fmax(1.0, A.DistTo(dest));
    if (!dist2.isfinite) dist2 = 1;
    dir.z += (dest.Origin.z+dest.Height-A.Origin.z)/dist2;
    dir = Normalise(dir);

    A.Velocity.z = dir.z*A.Speed;
  }
  VectorAngles(dir, out A.Angles);

  return (A.CheckMissileSpawn() ? A : none);
}


//==========================================================================
//
//  SpawnMissileAngles
//
//  Returns nullptr if the missile exploded immediately, otherwise returns
//  a Actor reference to the missile.
//
//==========================================================================
final EntityEx SpawnMissileAngles (class!EntityEx type, float yaw, float pitch,
                                   optional float spawnheight, optional float spawnxyofs,
                                   optional TVec customOrigin)
{
  if (!type) return none;
  TVec dir;

  TVec org = (specified_customOrigin ? customOrigin : Origin);

  if (spawnxyofs) {
    TVec right = AngleYawVector(Angles.yaw+90); //k8: or -90?
    org += right*spawnxyofs;
  }

       if (specified_spawnheight) org.z += spawnheight;
  else if (type.default.bIgnoreFloorStep) org.z = ONFLOORZ+FloorClip;
  else if (type.default.bIgnoreCeilingStep) org.z = ONCEILINGZ;
  else org.z += 32.0;

  if (org.z != ONFLOORZ) org.z -= FloorClip;

  EntityEx A = Spawn(type, org);
  if (!A) return none;
  if (!A.DecalName) A.DecalName = type.default.DecalName;
  A.CarryBloodTranslations(self);
  A.PlayMissileSpawnSound(self);
  A.Target = self; // originator
  A.Angles.yaw = yaw;
  A.Angles.pitch = pitch;
  AngleVector(A.Angles, out dir);
  A.Velocity = A.Speed*dir;
  // floor and ceiling huggers should never have a vertical component to their velocity
  if (A.bIgnoreCeilingStep || A.bIgnoreFloorStep) A.Velocity.z = 0.0;
  return (A.CheckMissileSpawn() ? A : none);
}


//==========================================================================
//
//  SpawnMissileAngle
//
//  Returns nullptr if the missile exploded immediately, otherwise returns
//  a Actor reference to the missile.
//
//==========================================================================
final EntityEx SpawnMissileAngle (class!EntityEx type, float angle,
                                  float momz, optional float spawnheight)
{
  if (!type) return none;

  TVec org = Origin;
       if (specified_spawnheight) org.z += spawnheight;
  else if (type.default.bIgnoreFloorStep) org.z = ONFLOORZ+FloorClip; // minotaur floor fire missile
  else if (type.default.bIgnoreCeilingStep) org.z = ONCEILINGZ;
  else org.z += 32.0;

  if (org.z != ONFLOORZ) org.z -= FloorClip;

  EntityEx mo = Spawn(type, org);
  if (!mo) return none;
  if (!mo.DecalName) mo.DecalName = type.default.DecalName;
  mo.CarryBloodTranslations(self);
  mo.PlayMissileSpawnSound(self);
  mo.Target = self; // originator
  mo.Angles.yaw = angle;
  float sina, cosa;
  sincos(angle, out sina, out cosa);
  mo.Velocity.x = mo.Speed*cosa;
  mo.Velocity.y = mo.Speed*sina;
  mo.Velocity.z = momz;
  return (mo.CheckMissileSpawn() ? mo : none);
}


//==========================================================================
//
//  SpawnMissileAngleSpeed
//
//  Returns nullptr if the missile exploded immediately, otherwise returns
//  a Actor reference to the missile.
//
//==========================================================================
final EntityEx SpawnMissileAngleSpeed (class!EntityEx type, float angle,
                                       float momz, float speed)
{
  if (!type) return none;

  TVec org = Origin;
  if (org.z != ONFLOORZ) org.z -= FloorClip;

  EntityEx mo = Spawn(type, org);
  if (!mo) return none;
  if (!mo.DecalName) mo.DecalName = type.default.DecalName;
  mo.CarryBloodTranslations(self);
  mo.Tracer = self; // Originator
  mo.Angles.yaw = angle;
  float sina, cosa;
  sincos(angle, out sina, out cosa);
  mo.Velocity.x = speed*cosa;
  mo.Velocity.y = speed*sina;
  mo.Velocity.z = momz;
  mo.PlayMissileSpawnSound(self);
  return mo.CheckMissileSpawn() ? mo : none;
}


//==========================================================================
//
//  SpawnSubMissile
//
//==========================================================================
final EntityEx SpawnSubMissile (class!EntityEx type, EntityEx AInstigator) {
  TVec dir;

  EntityEx other = Spawn(type, Origin);
  if (!other) return none;
  other.CarryBloodTranslations(self);

  other.Target = AInstigator;
  other.Angles = Angles;
  other.DecalName = other.default.DecalName;

  float sina, cosa;
  sincos(Angles.yaw, out sina, out cosa);
  other.Velocity.x = other.Speed*cosa;
  other.Velocity.y = other.Speed*sina;
  AimLineAttack(dir, Angles, 1024.0, isRocket:true);
  other.Velocity.z = other.Speed*dir.z;
  other.CheckMissileSpawn();
  return other;
}


//==========================================================================
//
//  SpawnPlayerMissile
//
//==========================================================================
final EntityEx SpawnPlayerMissile (class!EntityEx type, optional name decalType) {
  EntityEx AimTarget;
  return SpawnPlayerMissileEx(type, false, AimTarget, default, default, decalType);
}


//==========================================================================
//
//  SpawnPlayerMissileAngle
//
//==========================================================================
final EntityEx SpawnPlayerMissileAngle (class!EntityEx type, float angle) {
  EntityEx AimTarget;
  return SpawnPlayerMissileEx(type, false, AimTarget, angle);
}


//===========================================================================
//
//  SpawnPlayerMissileAngleXYZ
//
//===========================================================================
final EntityEx SpawnPlayerMissileAngleXYZ (TVec org, class!EntityEx type, float angle) {
  EntityEx AimTarget;
  return SpawnPlayerMissileEx(type, false, AimTarget, angle, org);
}


//==========================================================================
//
//  SpawnPlayerMissileEx
//
//  Tries to aim at a nearby monster
//
//==========================================================================
final EntityEx SpawnPlayerMissileEx (class!EntityEx type, bool RetExploded,
  out EntityEx AimTarget, optional float angle, optional TVec SpawnOrg, optional name decalType,
  optional bool noAutoAim)
{
  if (!type) return none;
  TVec dir;

  // try to find a target
  if (specified_angle) {
    AimTarget = Aim(dir, 16.0*64.0, angle, noAutoaim:noAutoAim!optional, isRocket:true);
  } else {
    AimTarget = Aim(dir, 16.0*64.0, noAutoaim:noAutoAim!optional, isRocket:true);
  }

  TVec org = (specified_SpawnOrg ? SpawnOrg : Origin);
  if (type.default.bIgnoreFloorStep) {
    org.z = ONFLOORZ;
    dir.z = 0.0;
    dir = Normalise(dir);
  } else if (type.default.bIgnoreCeilingStep) {
    org.z = ONCEILINGZ;
    dir.z = 0.0;
    dir = Normalise(dir);
  } else {
    org.z += CalculateMissileAttackZOfs();
    /* done in `CalculateMissileAttackZOfs()`
    // missiles are spawned 4 units lower than hitscan attacks
    // add an extra unit to simulate Doom's original behaviour
    org.z += Height*0.5-FloorClip;
    if (bIsPlayer) {
      org.z += PlayerEx(Player).GetAttackZOfs-3.0;
    } else {
      org.z += 5.0;
    }
    */
  }

  EntityEx A = Spawn(type, org);
  if (!A) return none;
  if (!A.DecalName) A.DecalName = type.default.DecalName;
  A.CarryBloodTranslations(self);
  if (specified_decalType && decalType) {
    //if (GetCvarB('k8ExplodeMissleTest')) print("missile decal set to <%n>", decalType);
    A.DecalName = decalType;
  }

  A.PlayMissileSpawnSound(self);

  A.Target = self;
  A.Velocity = dir*A.Speed;

  // adjust the trajectory if the missile will go over the target's head
  if (noAutoAim) AimTarget = none;
  if (AimTarget && Origin.z >= AimTarget.Origin.z &&
      Origin.z <= AimTarget.Origin.z+AimTarget.Height &&
      A.Origin.z >= AimTarget.Origin.z+AimTarget.Height)
  {
    float dist = fmax(1.0, A.DistTo(AimTarget));
    if (!dist.isfinite) dist = 1;
    dir.z += (AimTarget.Origin.z+AimTarget.Height-A.Origin.z)/dist;
    dir = Normalise(dir);
    A.Velocity.z = dir.z*A.Speed;
  }
  VectorAngles(dir, out A.Angles);

  return (A.CheckMissileSpawn() || RetExploded ? A : none);
}
