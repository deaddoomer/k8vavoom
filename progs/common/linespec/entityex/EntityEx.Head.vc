//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class EntityEx : Entity abstract;

const int
  GAME_Doom    = 0x01,
  GAME_Heretic = 0x02,
  GAME_Hexen   = 0x04,
  GAME_Strife  = 0x08,
  GAME_Raven   = GAME_Heretic|GAME_Hexen,
  GAME_Chex    = 0x10,
  GAME_Any     = 0xff;

const int PTROP_UNSAFETARGET = 1;
const int PTROP_UNSAFEMASTER = 2;

const float ONFLOORZ   = -99999.0;
const float ONCEILINGZ = 99999.0;
const float FLOATRANDZ = 99998.0;

const float FRICTION_NORMAL = 3.28125;
const float FRICTION_LOW    = 0.95703125;
const float FRICTION_FLY    = 2.87109375;
const float FRICTION_WATER  = 3.0;

const float MAXMOVE     = 1050.0;
const float MAXMOVESTEP = MAXMOVE/(35.0*2.0);
const float STOPSPEED   = 2.1875;

const float BOUNCE_VAL  = 1.5;

// follow a player exlusively for 3 seconds
const int BASETHRESHOLD = 100;

const float MELEERANGE   = 64.0;
// use meleerange+1 so the puff doesn't skip the flash
const float SAWRANGE     = MELEERANGE+0.00001;
const float MISSILERANGE = 32.0*64.0;

const float MONS_LOOK_RANGE = 20.0*64.0;
const int MONS_LOOK_LIMIT   = 64;

// factor to scale scrolling effect into mobj-carrying properties = 3/32
// (this is so scrolling floors and objects on them can move at same speed)
const float CARRYFACTOR = 0.09375;
const float CROUCHSPEED = 1.0/12.0;

enum {
  BOUNCE_None,
  BOUNCE_Doom,
  BOUNCE_Heretic,
  BOUNCE_Hexen,
};

enum {
  APROP_Health        = 0, // implemented
  APROP_Speed         = 1, // implemented
  APROP_Damage        = 2, // implemented
  APROP_Alpha         = 3, // implemented
  APROP_RenderStyle   = 4, // implemented
  APROP_SeeSound      = 5, // sounds can only be set, not gotten
  APROP_AttackSound   = 6,
  APROP_PainSound     = 7,
  APROP_DeathSound    = 8,
  APROP_ActiveSound   = 9,
  APROP_Ambush        = 10, // implemented
  APROP_Invulnerable  = 11, // implemented
  APROP_JumpZ         = 12, // implemented
  APROP_ChaseGoal     = 13, // implemented
  APROP_Frightened    = 14, // implemented
  APROP_Gravity       = 15, // implemented
  APROP_Friendly      = 16, // implemented
  APROP_SpawnHealth   = 17, // implemented
  // only getters
  APROP_Dropped       = 18, // implemented
  APROP_Notarget      = 19,
  APROP_Species       = 20, // getter only, implemented in C++ code
  APROP_NameTag       = 21, // getter only, implemented in C++ code
  APROP_Score         = 22,
  APROP_Notrigger     = 23,
  APROP_DamageFactor  = 24,
  APROP_MasterTID     = 25, // implemented
  APROP_TargetTID     = 26, // implemented
  APROP_TracerTID     = 27, // implemented
  APROP_WaterLevel    = 28, // implemented
  APROP_ScaleX        = 29, // implemented
  APROP_ScaleY        = 30, // implemented
  APROP_Dormant       = 31, // implemented
  APROP_Mass          = 32, // implemented
  APROP_Accuracy      = 33,
  APROP_Stamina       = 34,
  APROP_Height        = 35, // implemented
  APROP_Radius        = 36, // implemented
  APROP_ReactionTime  = 37,
  APROP_MeleeRange    = 38, // implemented
  APROP_ViewHeight    = 39, // implemented
  APROP_AttackZOffset = 40, // implemented
  APROP_StencilColor  = 41,
};

enum {
  PROP_FROZEN          = 0,
  PROP_NOTARGET        = 1,
  PROP_INSTANTWEAPONSWITCH = 2,
  PROP_FLY             = 3,
  PROP_TOTALLYFROZEN   = 4,
  PROP_INVULNERABILITY = 5,
  PROP_STRENGTH        = 6,
  PROP_INVISIBILITY    = 7,
  PROP_RADIATIONSUIT   = 8,
  PROP_ALLMAP          = 9,
  PROP_INFRARED        = 10,
  PROP_WEAPONLEVEL2    = 11,
  PROP_FLIGHT          = 12,
  PROP_SPEED           = 15,
  PROP_BUDDHA          = 16,
};

// constants for ClassifyActor
enum {
  ACTOR_NONE       = 0x00000000,
  ACTOR_WORLD      = 0x00000001,
  ACTOR_PLAYER     = 0x00000002,
  ACTOR_BOT        = 0x00000004,
  ACTOR_VOODOODOLL = 0x00000008,
  ACTOR_MONSTER    = 0x00000010,
  ACTOR_ALIVE      = 0x00000020,
  ACTOR_DEAD       = 0x00000040,
  ACTOR_MISSILE    = 0x00000080,
  ACTOR_GENERIC    = 0x00000100,
};

// constants for A_SeekerMissile
enum {
  SMF_LOOK     = 1,
  SMF_PRECISE  = 2,
  SMF_CURSPEED = 4,
};

// states
state IdleState;
state SeeState;
state MeleeState;
state MissileState;

// sounds
name SightSound;
name ActiveSound;
name AttackSound;
name PainSound;
name CrushPainSound;
name DeathSound;
name HowlSound;
name BounceSound;

// flags
bool bSpecial; // call P_SpecialThing when touched
bool bShootable; // can be hit
bool bAmbush;
bool bJustHit; // try to attack right back
bool bJustAttacked; // take at least one step before attacking
bool bSpawnCeiling; // hang from ceiling instead of floor
// movement flags
bool bPickUp; // for players to pick up items
bool bDropped; // dropped by a demon, not level spawned
bool bNoBlood; // don't bleed when shot (use puff)
bool bNoBloodDecals; // don't spawn blood decals (k8:FIXME: dunno)
bool bInFloat; // floating to a height for a move, don't auto float to target's height
bool bSkullFly; // skull in flight
bool bCountKill; // count towards intermission kill total
bool bCountItem; // count towards intermission item total
bool bWindThrust; // gets pushed around by the wind specials
bool bActivateImpact; // an MF_MISSILE mobj can activate SPAC_IMPACT
bool bActivatePushWall; // mobj can push walls
bool bActivateMCross; // can activate monster cross lines
bool bActivatePCross; // can activate projectile cross lines
bool bDormant; // thing is dormant
bool bWaterJump;
bool bNoTeleport; // does not teleport
bool bTelestomp; // mobj can stomp another
bool bCannotPush; // cannot push other pushable mobjs
bool bSmallSplash; // always use small splash
bool bNoSplash; // things that don't splash
bool bStaticLight; // static light source
bool bStaticLightSpawned;
bool bDynamicLight; // dynamic light source
bool bLeaveTrail; // leave particles trail type 1 (Rocket)
bool bLeaveTrail2; // leave particles trail type 2 (Grenade)
bool bTriggerHappy;
bool bFloatBob; // use float bobbing z movement
bool bOnmobjCopyVel;
bool bNoBounceSound; // don't make sound when bouncing
bool bNoWallBounceSnd; // don't make sound when bouncing off a wall
bool bNoSplashAlert; // splashes don't alert this monster
bool bBounceSky; // bounce when hitting the sky
bool bExplodeOnSky; // explodes when hits the sky
bool bBounceWalls; // bounces off of walls
bool bBounceFloors; // bounces off of floors
bool bBounceCeilings; // bounces off of ceilings
bool bBounceOnActors; // bounces against other "non sentient" actors
bool bBounceOnAllActors; // bounces off of ALL actors
bool bBounceAutoOff; // when bouncing off a floor, if the new Z velocity is below 3.0, disable further bouncing
bool bBounceLikeHeretic; // goes into Death state when bouncing on floors or ceilings
bool bSlide; // slides against walls
bool bReflective; // reflects missiles
bool bSeekerMissile; // is a seeker (for reflection)
bool bNoExplodeFloor; // don't explode when hitting the floor
bool bIceCorpse; // a frozen corpse (for blasting)
bool bExplodeOnWater; // explode on water surfaces
bool bCanBounceWater; // bounce on water surfaces
bool bFallingFriction; // apply friction while falling
bool bNoRadiusDamage; // does not take radius damage
bool bCantAutoAim; // can't auto aim at this actor
bool bPuffOnActors; // spawn this puff when hitting actors
bool bInvulnerable; // mobj is invulnerable
bool bFriendly; // will fight on player's side
bool bRandomise; // randomise initial state time
bool bFullVolDeath; // play missile death sound at full volume
bool bExploCount; // use explosion counters
bool bSpectral; // can be killed only with Sigil
bool bDamageInvulnerable; // these inflictors aren't foiled by invulnerability
bool bSkullFlyInvulnerable; // invulnerable during skull fly attack
bool bNoDamageThrust; // does not thrust target when damaging
bool bConditionalFireDamage;
bool bNoExtremeDeath; // does never gib enemies
bool bExtremeDeath; // always gibs enemies
bool bLightning; // electrocutes victims
bool bHowlVictims; // make victims play howl sound when damaged
bool bNoGrudge;
bool bNeverTarget; // never switch target to this actor
bool bNoTargetSwitch; // never switches target until current one is dead
bool bNoGravKill; // doesn't set NoGravity to false when killed
bool bFaster;
bool bFastMelee;
bool bStanding; // don't walk around
bool bBoss; // mobj is a major boss
bool bNonShootable; // mobj is totally non-shootable, but still considered solid
bool bThruGhost; // missile will pass through ghosts
bool bRip; // missile rips through solid targets
bool bPushable; // can be pushed by other moving mobjs
bool bBloodlessImpact; // don't spawn blood when hitting a thing
bool bMonster;
bool bNoDeathmatch;
bool bTeleport; // don't cross lines or look at heights
bool bSpawnFloat; // spawn random float z
bool bNoMorph; // don't morph into chicken/pig
bool bNoBlockMonst; // can cross ML_BLOCKMONSTERS lines
bool bLookAllAround; // actor can see all around
bool bNeutral; // neutral characters (peasants and beggars)
bool bStandMustSeeTarget; // COUNTITEM 800000
bool bInCombat; // actors in combat won't talk
bool bFullVolActive; // play active sound at full volume
bool bDehackedSpecial; // old style special handling
bool bUnknown2; // 8000000
bool bPuffParticles; // puff spawns particles
bool bExplodeParticles; // use particle explosion
bool bStealth; // Andy Baker's Stealth monsters
bool bChaseGoal; // walks to goal instead of target if a valid goal is set
bool bExplosionDontHurtSelf; // for A_Explodearms
bool bNoSightCheck; // go after target without checking sight
bool bHuntPlayers; // with TIDToHate, hate players too
bool bNoHatePlayers; // ignore player attacks
bool bStrifeDamage; // missiles do 4x damage instead of 8x
bool bDontBlast; // not blasted by blast radius
bool bVisibilityPulse; // pulse visibility in and out
bool bArgsDefined; // args are already defined
bool bShadow; // actor is hard for monsters to see
bool bGhost; // actor is a ghost
bool bBossDeath; // A_FreezeDeathChunks calls A_BossDeath
bool bNoIceDeath; // don't use generic ice death
bool bDontTranslate; // don't use translation.
bool bMissileEvenMore;
bool bNoLiftDrop; // don't fall down with the lift
bool bStayMorphed; // don't unmorph
bool bCanBlast; // special cases that can be blasted
bool bShieldReflect; // centaur style shield reflection
bool bDontShieldReflect; // projectile not reflected by shield reflection
bool bDeflect; // different projectile reflection style
bool bDontReflect; // projectile cannot be reflected
bool bFireResist; // actor takes half damage from fire
bool bLowSpectralResist; // actor resists full damage from first sigil projectiles
bool bDontSquash; // death ball can't squash this actor
bool bNoTeleOther; // monster is not affected by teleport other artifact
bool bDontHurtClass; // don't hurt own class with explosions
bool bDontHurtSpecies; // don't hurt own species with explosions
bool bNoDamage; // actor reacts to pain but does not take any damage
bool bDontGib; // don't crunch this corpse to gibs
bool bNoPain; // don't enter pain state
bool bPainless; // actor always inflicts painless damage
bool bForcePain; // forces target into painstate (unless it has the NOPAIN flag)
bool bCantSeek; // seeker missiles cannot home in on this actor
bool bDontSeekInvisible; // for seeker missiles: Don't home in on invisible/shadow targets
bool bPierceArmor; // damage from this actor is not protected by armor
bool bForceRadiusDmg; // override NoRadiusDmg
bool bSpawnSoundSource; // play missile's see sound on spawning object
bool bAlwaysPuff; // always show puff, even when hit nothing
bool bSynchronised; // for map spawned things don't randomise tics
bool bAlwaysFast; // always uses 'fast' attack logic
bool bNeverFast; // never uses 'fast' attack logic
bool bAlwaysRespawn; // always respawns, regardless of skill
bool bNeverRespawn; // never respawns, regardless of skill
bool bDontRip; // ripping projectiles explode when hitting this actor
bool bCanUseWalls; // can activate "use" specials
transient bool bInChase; // used to prevent recursion in A_Chase
bool bUseSpecial; // execute special when this thing is being used
bool bNoInfighting; // disable infighting for this actor
bool bBloodSplatter; // use blood splatter like in Raven games
bool bDehExplosion; // use explosion style specified using DeHackEd
bool bNoVerticalMeleeRange; // Does not check vertical distance for melee range
bool bSummonedMonster; // flag MinotaurFriend and other summoned monsters (i.e. by powerups, etc.)
bool bSeesDaggers; // actor is able to hear dagger attacks
bool bPuffGetsOwner; // [BB] sets the owner of the puff to the player who fired it
bool bNoInteraction; // thing is completely excluded from any gameplay related checks
bool bFrightened; // monster runs away from player
bool bNoFear; // not scared of frightening players
bool bTouchy; // killough 11/98: dies when solids touch it
bool bArmed; // object is armed (for touchy objects)
bool bJumpDown; // generalization of dog behavior with dropoffs
bool bMoveWithSector; // P_ChangeSector() will still process this actor if it has MF_NOBLOCKMAP
bool bNoTrigger; // actor cannot trigger any line actions
bool bBlockedBySolidActors; // blocked by solid actors, even if not solid itself
bool bThruActors; // performs no actor<->actor collision checks
bool bThruSpecies; // actors passes through other of the same species
bool bMThruSpecies; // missile passes through actors of its shooter's species
bool bNoTeleFrag; // actor can't be telefragged
bool bNoBossRip; // for rippermissiles: don't rip through bosses
bool bScreenSeeker; // fails the IsOkayToAttack test if potential target is outside player FOV
bool bBumpSpecial; // actor executes its special when being collided (as the ST flag)
bool bMBFBounce; // doesn't dies while bouncing speed is higher than 0
bool bAvoidsDropOffs; // monster does avoid dropoffs, overrides value of compat_dropoff CVar
bool bNoTimeFreeze; // monster isn't affected by Time Freeze powerups
bool bCrashed; // means a monster that has crash state hasn't crashed and can execute Crash method

// physics will put this entity to floor or ceiling (floor has precedence)
bool bStickToFloor;
bool bStickToCeiling;

bool bHitTarget;
bool bHitMaster;
bool bHitTracer;
bool bHitOwner;

// if `true`, flying projectile will leave decals on 2-sided walls it flied through
bool bDecals2SPass;
// if `true`, flying projectile will leave decals only on 2-sided walls it flied through
bool bDecalsOnly2S;

// params
float Speed;
float FastSpeed;
float FloatSpeed;

int WoundHealth;
int GibsHealth;

// damage info
array!DamageFactor DamageFactors;
float PainChance;
array!PainChanceInfo PainChances;

float MissileChance;
float MissileMinRange;
float MissileMaxRange;

ubyte BounceType;
ubyte BounceCount;
float BounceFactor;
float WallBounceFactor;

// thing being chased/attacked (or nullptr)
// also the originator for missiles
EntityEx Target;
// for monster families
string Species;
// last known enemy -- killogh 2/15/98
EntityEx LastEnemy;
EntityEx Tracer;
// monster's goal if not chasing anything
EntityEx Goal;
// master entity
EntityEx Master;
// last actor this one heard
EntityEx LastHeard;
// ketmar: last position we've seen a player
//         if player cannot be seen, try to walk to this destination,
//         then start wandering
//         note that sometimes monster can forget about player position
//         (roughly in 10% of cases)
//!TVec LastPlayerSeenPos;
//!bool LastPlayerSeenPosValid;

// player number last looked for
int LastLook;
// the same for actor
Entity LastLookActor;

// TID of things to hate, 0 if none
int TIDToHate;

ubyte FriendPlayer;

int MissileDamage; // for missiles
int MissilePoisonDamage;

// for nightmare respawn
mthing_t SpawnPoint;

// reaction time: if non 0, don't attack yet
int ReactionCount;
// used by player to freeze a bit after teleporting
float ReactionTime;

// if >0, the target will be chased no matter what (even if shot)
int Threshold;

// movement direction, movement generation (zig-zagging)
int MoveDir; // 0-7
int MoveCount; // when 0, select a new dir
int strafecount; // killough 9/8/98: monster strafing
int FastChaseStrafeCount;

int VisDir;

float RDFactor;

// static light parameters
TVec LightOffset;
int LightColour;
float LightRadius;

// dynamic light parameters
int DLightColour;
float DLightRadius;
int ExplodeEffect;
float prev_rad;

float MeleeRange;

int Special1; // special info
int Special2; // special info
float Special1f;
float Special2f;
class!EntityEx SpecialCID;

name DamageType;

float DeathHeight;
float BurnHeight;

string StrifeName;

// identifier in conversation scripts, originaly index into mobjinfo
int ConversationID;
int CurrentSpeech; // current speech index

// actor's inventory
Inventory Inventory;

float FloatBobPhase;

// for A_ExplodeParms
int ExplosionDamage;
int ExplosionRadius;

string Obituary;
string HitObituary;

state PrevEffectState;

int MeleeDamage;
name MeleeSound;
float MissileHeight;
class!Actor MissileType;

// view offset when used as a player camera
float CameraHeight;

// customiseable blood
class!Actor BloodType;
class!Actor BloodSplatterType;
class!Actor AxeBloodType;
int BloodColour;
int BloodTranslation;
bool bBloodDisableSplats; // has sense only for blood actors

array!DropItemInfo DropItemList;

int SkillRespawnCount;

// customiseable jump celocity
float JumpVelZ;
float JumpTime;

//float CrouchHeight;
float crouchfactor = 1.0;

bool k8InWeaponReady; // otherwise recursive calls to it may overflow stack

#ifdef VC_SCRIPT_USE_SPAWNED_CHILDREN_ARRAY
//array!EntityEx SpawnedChildren; // set in `A_SpawnItemEx()`, used in `A_RemoveChildren()`
#else
EntityEx SpawnParent; // set in `A_SpawnItemEx()`, used in `A_RemoveChildren()`
#endif


replication {
  reliable if (Role == ROLE_Authority && bNetOwner)
    Inventory, bInvulnerable;
}


//===========================================================================
//
//  eventFindTargetForACS
//
//===========================================================================
override Entity eventFindTargetForACS () {
  // player?
  if (bIsPlayer) {
    if (Player.PlayerState == PST_DEAD) return (Target ? Target : self); // target holds a killer
    // something player is aiming at
    // create direction vector
    TAVec ang = Angles;
    TVec dir;
    AngleVector(ang, dir);
    dir = Normalise(dir);
    return PickActor(default, dir, 8192);
  }
  // for other things, `Target` holds what we want
  return (Target ? Target : self);
}


//==========================================================================
//
//  VerifyTargetChain
//
//  Checks whether this actor is a missile
//  Unfortunately this was buggy in older versions of the code and many
//  released DECORATE monsters rely on this bug so it can only be fixed
//  with an optional flag
//
//  taken directly from Zandronum
//
//==========================================================================
final void VerifyTargetChain (optional bool preciseMissileCheck) {
  if (!specified_preciseMissileCheck) preciseMissileCheck = true;
  if (IsMissile(preciseMissileCheck)) return;

  EntityEx origin = self;
  EntityEx next = origin.Target;

  // origin: the most recent actor that has been verified as appearing only once
  // next: the next actor to be verified; will be "origin" in the next iteration

  // we only care when there are missiles involved
  while (next && next.IsMissile(preciseMissileCheck)) {
    EntityEx compare = self;
    // every new actor must prove not to be the first actor in the chain, or any subsequent actor
    // any actor up to and including "origin" has only appeared once
    for (;;) {
      if (compare == next) {
        // if any of the actors from self to (inclusive) origin match the next actor,
        // self has reached/created a loop
        self.Target = none;
        return;
      }
      if (compare == origin) break; // when "compare" = origin, we know that the next actor is, and should be "next"
      compare = compare.Target;
    }

    origin = next;
    next = next.Target;
  }
}


//===========================================================================
//
//  VerifyMasterChain
//
//  see VerifyTargetChain for detailed comments
//
//===========================================================================
final void VerifyMasterChain () {
  EntityEx origin = self;
  EntityEx next = origin.Master;
  // We always care (See "VerifyTargetChain")
  while (next) {
    EntityEx compare = self;
    for (;;) {
      if (compare == next) {
        self.Master = none;
        return;
      }
      if (compare == origin) break;
      compare = compare.Master;
    }

    origin = next;
    next = next.Master;
  }
}


//===========================================================================
//
//  eventSetPointerForACS
//
//===========================================================================
override bool eventSetPointerForACS (int assign_slot, int tid, int aptr, int flags) {
  int count = 0;
  EntityEx tgt = none;
  foreach (Entity Ent; Level.eachTID(tid, self)) {
    EntityEx e = EntityEx(Ent);
    if (!e) continue;
    e = EntityEx(e.DecorDoAAPtr('eventSetPointerForACS', aptr));
    if (!e) continue;
    tgt = e;
    if (e == self) tgt = none;
    break;
  }
  switch (assign_slot) {
    case AAPTR_TARGET:
      Target = tgt;
      if (!(flags&PTROP_UNSAFETARGET)) VerifyTargetChain();
      return !!Target;
    case AAPTR_MASTER:
      Master = tgt;
      if (!(flags&PTROP_UNSAFEMASTER)) VerifyMasterChain();
      return !!Master;
    case AAPTR_TRACER:
      Tracer = tgt;
      return !!Tracer;
  }
  return !!tgt; // oops, looks like a bug, but Zandronum does it like this
}


//===========================================================================
//
//  decoRearrangePtrGetPtr
//
//===========================================================================
final EntityEx decoRearrangePtrGetPtr (int aptr, EntityEx defval,
                  EntityEx oldTarget, EntityEx oldMaster, EntityEx oldTracer)
{
  switch (aptr) {
    case AAPTR_DEFAULT: return defval;
    case AAPTR_NULL: return none;
    case AAPTR_TARGET: return oldTarget;
    case AAPTR_MASTER: return oldMaster;
    case AAPTR_TRACER: return oldTracer;
  }
  return none;
}


//===========================================================================
//
//  A_RearrangePointers
//
//===========================================================================
final void A_RearrangePointers (int aptrtarget, optional int aptrmaster, optional int aptrtracer, optional int flags) {
  EntityEx oldTarget = Target;
  EntityEx oldMaster = Master;
  EntityEx oldTracer = Tracer;

  Target = decoRearrangePtrGetPtr(aptrtarget, oldTarget, oldTarget, oldMaster, oldTracer);
  if (!(flags&PTROP_UNSAFETARGET)) VerifyTargetChain();

  if (specified_aptrmaster) {
    Master = decoRearrangePtrGetPtr(aptrmaster, oldMaster, oldTarget, oldMaster, oldTracer);
    if (!(flags&PTROP_UNSAFEMASTER)) VerifyMasterChain();
  }

  if (specified_aptrtracer) {
    Tracer = decoRearrangePtrGetPtr(aptrtracer, oldTracer, oldTarget, oldMaster, oldTracer);
  }
}


//===========================================================================
//
//  eventDoAAPtr
//
//===========================================================================
override Entity eventDoAAPtr (int ptr) {
  return DecorDoAAPtr('eventDoAAPtr', ptr);
}


//==========================================================================
//
//  DecorDoAAPtr
//
//==========================================================================
final Entity DecorDoAAPtr (name methodname, optional int ptr) {
  if (!specified_ptr || ptr == AAPTR_DEFAULT) return self;
  // category 1
  if (bIsPlayer) {
    if (ptr&AAPTR_PLAYER_GETTARGET) {
      //EntityEx targ = AimLineAttack(nullptr, Angles, 8192, noVertAutoAim:true);
      bool noAAim = !PlayerEx(self).bAutoAim, noAAVert = false/*true*/;
      Weapon Wpn = PlayerEx(self).ReadyWeapon;
      if (Wpn && Wpn.IsAutoaimDisabled()) noAAim = true; //bNoAutoaim;
      noAAVert = noAAim;
      EntityEx targ = Aim(nullptr, 8192/*16*64*/, Angles.yaw, noAutoaim:noAAim, noVertAutoAim:noAAVert);
      if (targ) return targ;
    }
    // AAPTR_PLAYER_GETCONVERSATION // no strife dialogues, so skip
  }
  // category 2
  if (ptr&AAPTR_TARGET) return Target;
  if (ptr&AAPTR_MASTER) return Master;
  if (ptr&AAPTR_TRACER) return Tracer;
  if (ptr&AAPTR_FRIENDPLAYER) {
    if (FriendPlayer > 0 && FriendPlayer <= MAXPLAYERS) {
      auto plr = Level.Game.Players[FriendPlayer-1];
      if (plr && plr.bSpawned && plr.MO) return plr.MO;
    }
  }
  if (ptr&AAPTR_LINETARGET) {
    EntityEx targ = Aim(nullptr, 2048/*16*64*/, Angles.yaw);
    if (targ) return targ;
  }
  // category 3
  int plridx = -1;
       if (ptr&AAPTR_PLAYER1) plridx = 0;
  else if (ptr&AAPTR_PLAYER2) plridx = 1;
  else if (ptr&AAPTR_PLAYER3) plridx = 2;
  else if (ptr&AAPTR_PLAYER4) plridx = 3;
  else if (ptr&AAPTR_PLAYER5) plridx = 4;
  else if (ptr&AAPTR_PLAYER6) plridx = 5;
  else if (ptr&AAPTR_PLAYER7) plridx = 6;
  else if (ptr&AAPTR_PLAYER8) plridx = 7;
  if (plridx >= 0 && plridx < MAXPLAYERS) {
    auto plr = Level.Game.Players[plridx];
    if (plr && plr.bSpawned && plr.MO) return plr.MO;
  }
  if (ptr&AAPTR_NULL) return none;
  FatalError("%s: unsupported ptr (0x%x)", methodname, ptr);
  return none;
}


/*
final float GetOriginX () { return Origin.x; }
final float GetOriginY () { return Origin.y; }
final float GetOriginZ () { return Origin.z; }

final float GetVelocityX () { return Velocity.x; }
final float GetVelocityY () { return Velocity.y; }
final float GetVelocityZ () { return Velocity.z; }

final float GetAnglesYaw () { return Angles.yaw; }
final float GetAnglesPitch () { return Angles.pitch; }
final float GetAnglesRoll () { return Angles.roll; }
*/

final int _GetUID () { return __ObjectUniqueId; }
final Object _GetSelf () { return self; }
final Object _GetSSR () { /*print("(SSR.self=%C)", self);*/ return _stateRouteSelf; }


// convert bool fields to `MF_XXX` flags
final int CalcEntityFlags () {
  int res = 0;
  if (bSpecial) res |= MF_SPECIAL;
  if (bSolid) res |= MF_SOLID;
  if (bShootable) res |= MF_SHOOTABLE;
  if (bNoSector) res |= MF_NOSECTOR;
  if (bNoBlockmap) res |= MF_NOBLOCKMAP;
  if (bAmbush) res |= MF_AMBUSH;
  if (bJustHit) res |= MF_JUSTHIT;
  if (bJustAttacked) res |= MF_JUSTATTACKED;
  if (bSpawnCeiling) res |= MF_SPAWNCEILING;
  if (bNoGravity) res |= MF_NOGRAVITY;
  if (bDropOff) res |= MF_DROPOFF;
  if (bPickUp) res |= MF_PICKUP;
  if (!bColideWithThings && !bColideWithWorld) res |= MF_NOCLIP;
  if (bInChase) res |= MF_INCHASE;
  if (bFloat) res |= MF_FLOAT;
  if (bTeleport) res |= MF_TELEPORT;
  if (bMissile) res |= MF_MISSILE;
  if (bDropped) res |= MF_DROPPED;
  if (bShadow) res |= MF_SHADOW;
  if (bNoBlood) res |= MF_NOBLOOD;
  if (bCorpse) res |= MF_CORPSE;
  if (bInFloat) res |= MF_INFLOAT;
  //if (bInBounce) res |= MF_INBOUNCE;
  if (bCountKill) res |= MF_COUNTKILL;
  if (bCountItem) res |= MF_COUNTITEM;
  if (bSkullFly) res |= MF_SKULLFLY;
  if (bNoDeathmatch) res |= MF_NOTDMATCH;
  if (bSpawnSoundSource) res |= MF_SPAWNSOUNDSOURCE;
  if (bFriendly) res |= MF_FRIENDLY;
  //k8:notyet:const int MF_UNMORPHED = 0x10000000;
  if (bNoLiftDrop) res |= MF_NOLIFTDROP;
  if (bStealth) res |= MF_STEALTH;
  if (bIceCorpse) res |= MF_ICECORPSE;
  return res;
}


//==========================================================================
//
//  IsBloodAllowed
//
//==========================================================================
bool IsBloodAllowed () {
  if (bNoBlood) return false;

  if (bInvisible || bInvulnerable) return false; // don't spawn blood for invulnerable things
  if (!bMonster && !bIsPlayer) return false; // only mosters and players has blood
  if (bMonster && Health >= 10_000) return false; // this looks like something stationary, skip it

  return true;
}
