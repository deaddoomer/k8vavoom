//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2021 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class EntityEx : Entity abstract;

const int
  GAME_Doom    = 0x01,
  GAME_Heretic = 0x02,
  GAME_Hexen   = 0x04,
  GAME_Strife  = 0x08,
  GAME_Raven   = GAME_Heretic|GAME_Hexen,
  GAME_Chex    = 0x10,
  GAME_Any     = 0xff;

const int MAX_RANDOMSPAWNERS_RECURSION = 32; // Should be largely more than enough...

const float ONFLOORZ   = -99999.0;
const float ONCEILINGZ = +99999.0;
const float FLOATRANDZ = +99998.0;

// original Doom code multiplies speed by friction once per game tic
// original friction value is (0xE800/65536.0) == 0.90625
// so it subtracts (Velocity*0.09375) per game tic
// now multiply that by 35, and you'll get 3.28125
const float FRICTION_NORMAL = 3.28125;
const float FRICTION_LOW    = 0.95703125;
const float FRICTION_FLY    = 2.87109375;
const float FRICTION_WATER  = 3.0;

//WARNING: sync this with C++ code!
const float MAXMOVE     = 1050.0*30; // this is rougly equal to 900 in Vanilla speed
const float MAXMOVESTEP = /*MAXMOVE*/1050.0/(35.0*2.0);
const float STOPSPEED   = 2.1875; // 0x1000/65536.0*35.0

const float BOUNCE_VAL  = 1.5;

// follow a player exlusively for 3 seconds
const int BASETHRESHOLD = 100;

const float DEFAULT_MELEERANGE   = 64.0;
// use meleerange+1 so the puff doesn't skip the flash
const float SAWRANGE     = DEFAULT_MELEERANGE+0.00001;
const float MISSILERANGE = 32.0*64.0;

const float MONS_LOOK_RANGE = 20.0*64.0;
const int MONS_LOOK_LIMIT   = 64;

// factor to scale scrolling effect into mobj-carrying properties = 3/32
// (this is so scrolling floors and objects on them can move at same speed)
const float CARRYFACTOR = (3.0*35.0/32.0);
const float CARRYSTOPSPEED = 2.0/3.0;
const float CROUCHSPEED = 1.0/12.0;
const float CROUCHSLOWDOWN = 0.5;

enum {
  BOUNCE_None,
  BOUNCE_Doom,
  BOUNCE_Heretic,
  BOUNCE_Hexen,
};

// see `GetActorProperty()` and `SetActorProperty()`
enum {
  APROP_Health        = 0, // implemented
  APROP_Speed         = 1, // implemented
  APROP_Damage        = 2, // implemented
  APROP_Alpha         = 3, // implemented
  APROP_RenderStyle   = 4, // implemented
  APROP_SeeSound      = 5, // getter partially implemented in C++ code (string conversion)
  APROP_AttackSound   = 6, // getter partially implemented in C++ code (string conversion)
  APROP_PainSound     = 7, // getter partially implemented in C++ code (string conversion)
  APROP_DeathSound    = 8, // getter partially implemented in C++ code (string conversion)
  APROP_ActiveSound   = 9, // getter partially implemented in C++ code (string conversion)
  APROP_Ambush        = 10, // implemented
  APROP_Invulnerable  = 11, // implemented
  APROP_JumpZ         = 12, // implemented
  APROP_ChaseGoal     = 13, // implemented
  APROP_Frightened    = 14, // implemented
  APROP_Gravity       = 15, // implemented
  APROP_Friendly      = 16, // implemented
  APROP_SpawnHealth   = 17, // implemented
  // only getters (nope, some of them are setters too)
  APROP_Dropped       = 18, // implemented
  APROP_Notarget      = 19, // partially implemented (read-only)
  APROP_Species       = 20, // getter partially implemented in C++ code (string conversion)
  APROP_NameTag       = 21, // getter partially implemented in C++ code (string conversion)
  APROP_Score         = 22, // implemented
  APROP_Notrigger     = 23, // implemented
  APROP_DamageFactor  = 24, // implemented
  APROP_MasterTID     = 25, // implemented
  APROP_TargetTID     = 26, // implemented
  APROP_TracerTID     = 27, // implemented
  APROP_WaterLevel    = 28, // implemented
  APROP_ScaleX        = 29, // implemented
  APROP_ScaleY        = 30, // implemented
  APROP_Dormant       = 31, // implemented
  APROP_Mass          = 32, // implemented
  APROP_Accuracy      = 33, // implemented
  APROP_Stamina       = 34, // implemented
  APROP_Height        = 35, // implemented
  APROP_Radius        = 36, // implemented
  APROP_ReactionTime  = 37, // implemented
  APROP_MeleeRange    = 38, // implemented
  APROP_ViewHeight    = 39, // implemented
  APROP_AttackZOffset = 40, // implemented
  APROP_StencilColor  = 41, // implemented
  APROP_Friction         = 42, // implemented, but i'm not sure if it is right
  APROP_DamageMultiplier = 43, // implemented
  APROP_MaxStepHeight    = 44, // implemented
  APROP_MaxDropOffHeight = 45, // implemented
  APROP_DamageType       = 46, // getter partially implemented in C++ code (string conversion)
};

// constants for ClassifyActor
enum {
  ACTOR_NONE       = 0x00000000,
  ACTOR_WORLD      = 0x00000001,
  ACTOR_PLAYER     = 0x00000002,
  ACTOR_BOT        = 0x00000004,
  ACTOR_VOODOODOLL = 0x00000008,
  ACTOR_MONSTER    = 0x00000010,
  ACTOR_ALIVE      = 0x00000020,
  ACTOR_DEAD       = 0x00000040,
  ACTOR_MISSILE    = 0x00000080,
  ACTOR_GENERIC    = 0x00000100,
};

// states
state IdleState;
state SeeState;
state MeleeState;
state MissileState;

// sounds
name SightSound;
name ActiveSound;
name AttackSound;
name PainSound;
name CrushPainSound;
name DeathSound;
name HowlSound;
name BounceSound;

// flags
bool bSpecial; // call P_SpecialThing when touched
bool bShootable; // can be hit
bool bAmbush;
bool bJustHit; // try to attack right back
bool bJustAttacked; // take at least one step before attacking
bool bSpawnCeiling; // hang from ceiling instead of floor
// movement flags
bool bPickUp; // for players to pick up items
bool bDropped; // dropped by a demon, not level spawned
bool bNoBlood; // don't bleed when shot (use puff)
bool bNoBloodDecals; // don't spawn blood decals (k8:FIXME: dunno)
bool bInFloat; // floating to a height for a move, don't auto float to target's height
bool bSkullFly; // skull in flight
bool bCountKill; // count towards intermission kill total
bool bCountItem; // count towards intermission item total
bool bWindThrust; // gets pushed around by the wind specials
bool bActivateImpact; // an MF_MISSILE mobj can activate SPAC_IMPACT
bool bActivatePushWall; // mobj can push walls
bool bActivateMCross; // can activate monster cross lines
bool bActivatePCross; // can activate projectile cross lines
bool bDormant; // thing is dormant
bool bWaterJump;
bool bNoTeleport; // does not teleport
bool bTelestomp; // mobj can stomp another
bool bCannotPush; // cannot push other pushable mobjs
bool bSmallSplash; // always use small splash
bool bNoSplash; // things that don't splash
bool bStaticLight; // static light source (set by "static_light" definition in vfxdefs)
bool bStaticLightSpawned; // set by `OnMapSpawn()`
bool bDynamicLight; // dynamic light source
bool bLeaveTrail; // leave particles trail type 1 (Rocket)
bool bLeaveTrail2; // leave particles trail type 2 (Grenade)
bool bTriggerHappy;
//bool bFloatBob; // use float bobbing z movement (moved to `Entity`)
bool bOnmobjCopyVel;
bool bNoBounceSound; // don't make sound when bouncing
bool bNoWallBounceSnd; // don't make sound when bouncing off a wall
bool bNoSplashAlert; // splashes don't alert this monster
bool bBounceSky; // bounce when hitting the sky
bool bExplodeOnSky; // explodes when hits the sky
bool bBounceWalls; // bounces off of walls
bool bBounceFloors; // bounces off of floors
bool bBounceCeilings; // bounces off of ceilings
bool bBounceOnActors; // bounces against other "non sentient" actors
bool bBounceOnAllActors; // bounces off of ALL actors
bool bBounceAutoOff; // when bouncing off a floor, if the new Z velocity is below 3.0, disable further bouncing
bool bBounceLikeHeretic; // goes into Death state when bouncing on floors or ceilings
bool bSlide; // slides against walls
bool bReflective; // reflects missiles
bool bSeekerMissile; // is a seeker (for reflection)
bool bNoExplodeFloor; // don't explode when hitting the floor
bool bIceCorpse; // a frozen corpse (for blasting)
bool bExplodeOnWater; // explode on water surfaces
bool bCanBounceWater; // bounce on water surfaces
bool bFallingFriction; // apply friction while falling
bool bNoRadiusDamage; // does not take radius damage
bool bCantAutoAim; // can't auto aim at this actor
bool bPuffOnActors; // spawn this puff when hitting actors
bool bInvulnerable; // mobj is invulnerable
bool bFriendly; // will fight on player's side
bool bRandomise; // randomise initial state time
bool bFullVolDeath; // play missile death sound at full volume
bool bExploCount; // use explosion counters
bool bSpectral; // can be killed only with Sigil
bool bDamageInvulnerable; // these inflictors aren't foiled by invulnerability
bool bSkullFlyInvulnerable; // invulnerable during skull fly attack
bool bNoDamageThrust; // does not thrust target when damaging
bool bConditionalFireDamage;
bool bNoExtremeDeath; // does never gib enemies
bool bExtremeDeath; // always gibs enemies
bool bLightning; // electrocutes victims
bool bHowlVictims; // make victims play howl sound when damaged
bool bNoGrudge;
bool bNeverTarget; // never switch target to this actor
bool bReallyNeverTarget; // never ever target this actor
bool bNoTargetSwitch; // never switches target until current one is dead
bool bNoGravKill; // doesn't set NoGravity to false when killed
bool bFaster;
bool bFastMelee;
bool bStanding; // don't walk around
bool bBoss; // mobj is a major boss
bool bNonShootable; // mobj is totally non-shootable, but still considered solid
bool bThruGhost; // missile will pass through ghosts
bool bRip; // missile rips through solid targets
bool bPushable; // can be pushed by other moving mobjs
bool bBloodlessImpact; // don't spawn blood when hitting a thing
//bool bMonster; // moved to `Entity`
bool bNoDeathmatch;
bool bTeleport; // don't cross lines or look at heights
bool bSpawnFloat; // spawn random float z
bool bNoMorph; // don't morph into chicken/pig
bool bNoBlockMonst; // can cross ML_BLOCKMONSTERS lines
bool bLookAllAround; // actor can see all around
bool bNeutral; // neutral characters (peasants and beggars)
bool bStandMustSeeTarget; // COUNTITEM 800000
bool bInCombat; // actors in combat won't talk
bool bFullVolActive; // play active sound at full volume
bool bDehackedSpecial; // old style special handling
bool bUnknown2; // 8000000
bool bPuffParticles; // puff spawns particles
bool bExplodeParticles; // use particle explosion
bool bStealth; // Andy Baker's Stealth monsters
bool bChaseGoal; // walks to goal instead of target if a valid goal is set
bool bExplosionDontHurtSelf; // for A_Explodearms
bool bNoSightCheck; // go after target without checking sight
bool bHuntPlayers; // with TIDToHate, hate players too
bool bNoHatePlayers; // ignore player attacks
bool bStrifeDamage; // missiles do 4x damage instead of 8x
bool bDontBlast; // not blasted by blast radius
bool bVisibilityPulse; // pulse visibility in and out
bool bArgsDefined; // args are already defined
bool bShadow; // actor is hard for monsters to see
bool bGhost; // actor is a ghost
bool bBossDeath; // A_FreezeDeathChunks calls A_BossDeath
bool bNoIceDeath; // don't use generic ice death
bool bDontTranslate; // don't use translation.
bool bMissileEvenMore;
bool bNoLiftDrop; // don't fall down with the lift
bool bStayMorphed; // don't unmorph
bool bCanBlast; // special cases that can be blasted
bool bShieldReflect; // centaur style shield reflection
bool bMirrorReflect; // mirror-like 360 degrees reflection
bool bAimReflect; // reflect at the original shooter
bool bDontShieldReflect; // projectile not reflected by shield reflection
bool bDeflect; // different projectile reflection style
bool bDontReflect; // projectile cannot be reflected
bool bFireResist; // actor takes half damage from fire
bool bLowSpectralResist; // actor resists full damage from first sigil projectiles
bool bDontSquash; // death ball can't squash this actor
bool bNoTeleOther; // monster is not affected by teleport other artifact
bool bDontHurtClass; // don't hurt own class with explosions
bool bDontHurtSpecies; // don't hurt own species with explosions
bool bNoDamage; // actor reacts to pain but does not take any damage
bool bDontGib; // don't crunch this corpse to gibs
bool bNoPain; // don't enter pain state
bool bPainless; // actor always inflicts painless damage
bool bForcePain; // forces target into painstate (unless it has the NOPAIN flag)
bool bCantSeek; // seeker missiles cannot home in on this actor
bool bDontSeekInvisible; // for seeker missiles: Don't home in on invisible/shadow targets
bool bPierceArmor; // damage from this actor is not protected by armor
bool bForceRadiusDmg; // override NoRadiusDmg
bool bSpawnSoundSource; // play missile's see sound on spawning object
bool bAlwaysPuff; // always show puff, even when hit nothing
bool bSynchronised; // for map spawned things don't randomise tics
bool bAlwaysFast; // always uses 'fast' attack logic
bool bNeverFast; // never uses 'fast' attack logic
bool bAlwaysRespawn; // always respawns, regardless of skill
bool bNeverRespawn; // never respawns, regardless of skill
bool bDontRip; // ripping projectiles explode when hitting this actor
bool bCanUseWalls; // can activate "use" specials
transient bool bInChase; // used to prevent recursion in A_Chase
bool bUseSpecial; // execute special when this thing is being used
bool bNoInfighting; // disable infighting for this actor
bool bBloodSplatter; // use blood splatter like in Raven games
bool bDehExplosion; // use explosion style specified using DeHackEd
bool bNoVerticalMeleeRange; // Does not check vertical distance for melee range
bool bSummonedMonster; // flag MinotaurFriend and other summoned monsters (i.e. by powerups, etc.)
bool bSeesDaggers; // actor is able to hear dagger attacks
bool bPuffGetsOwner; // [BB] sets the owner of the puff to the player who fired it
//bool bNoInteraction; // thing is completely excluded from any gameplay related checks (moved to Entity)
bool bFrightened; // monster runs away from player
bool bNoFear; // not scared of frightening players
bool bTouchy; // killough 11/98: dies when solids touch it
bool bArmed; // object is armed (for touchy objects)
bool bJumpDown; // generalization of dog behavior with dropoffs
bool bMoveWithSector; // P_ChangeSector() will still process this actor if it has MF_NOBLOCKMAP
bool bNoTrigger; // actor cannot trigger any line actions
bool bBlockedBySolidActors; // blocked by solid actors, even if not solid itself
bool bThruActors; // performs no actor<->actor collision checks
bool bThruSpecies; // actors passes through other of the same species
bool bMThruSpecies; // missile passes through actors of its shooter's species
bool bNoTeleFrag; // actor can't be telefragged
bool bNoBossRip; // for rippermissiles: don't rip through bosses
bool bScreenSeeker; // fails the IsOkayToAttack test if potential target is outside player FOV
bool bBumpSpecial; // actor executes its special when being collided (as the ST flag)
bool bMBFBounce; // doesn't dies while bouncing speed is higher than 0
bool bAvoidsDropOffs; // monster does avoid dropoffs, overrides value of compat_dropoff CVar
bool bNoTimeFreeze; // monster isn't affected by Time Freeze powerups
bool bCrashed; // means a monster that has crash state hasn't crashed and can execute Crash method
bool bDontThrust; // does not thrust target when damaged
bool bSeeInvisible; // invisibility doesn't degrade monster targeting

bool bAvoidMelee;

bool bHitTarget;
bool bHitMaster;
bool bHitTracer;
bool bHitOwner;

bool bOldRadiusDamage; // does not take z into account when doing radius damage
transient bool bFixMapthingPos; // there is no reason to save it, it is used only when spawning map things anyway

// if `true`, flying projectile will leave decals on 2-sided walls it flied through
bool bDecals2SPass;
// if `true`, flying projectile will leave decals only on 2-sided walls it flied through
bool bDecalsOnly2S;

bool bMissileHeadshotsAllowed; // allow headshots with this missile?

float NextBumpTime; // next allowed bump time

// params
float Speed;
float FastSpeed;
float FloatSpeed;

int WoundHealth;
int GibsHealth;

// damage info
array!DamageFactor DamageFactors;
float PainChance;
array!PainChanceInfo PainChances;
int PainThreshold;

float MissileChance;
float MissileMinRange;
float MissileMaxRange;

ubyte BounceType;
ubyte BounceCount;
float BounceFactor;
float WallBounceFactor;

// thing being chased/attacked (or nullptr)
// also the originator for missiles
//EntityEx Target; // moved to `Entity`
// for monster families
string Species;
// last known enemy -- killogh 2/15/98
EntityEx LastEnemy;
//EntityEx Tracer; // moved to `Entity`
// monster's goal if not chasing anything
EntityEx Goal;
// master entity
//EntityEx Master; // moved to `Entity`
// last actor this one heard
EntityEx LastHeard;

// player number last looked for
int LastLook;
// the same for actor
Entity LastLookActor;

// TID of things to hate, 0 if none
int TIDToHate;

ubyte FriendPlayer;

int MissileDamage; // for missiles
int MissilePoisonDamage;

// for nightmare respawn
mthing_t SpawnPoint;

// reaction time: if non 0, don't attack yet
int ReactionCount;
// used by player to freeze a bit after teleporting
float ReactionTime;

// if >0, the target will be chased no matter what (even if shot)
int Threshold;

// movement direction, movement generation (zig-zagging)
int MoveDir; // 0-7
int MoveCount; // when 0, select a new dir
int strafecount; // killough 9/8/98: monster strafing
int FastChaseStrafeCount;

int VisDir;

float RDFactor;

// static light parameters
// used only when spawning map things, to create static lights
// so there is no reason to save them
// (but save light offset, because it can be changed in spawner)
TVec LightOffset;
transient int LightColor;
transient float LightRadius;
// for spotlights
transient TVec LightConeDir;
transient float LightConeAngle;

// dynamic light parameters
int DLightColor;
float DLightRadius;
int ExplodeEffect;
float prev_rad;

float MeleeRange;

int Special1; // special info
int Special2; // special info
float Special1f;
float Special2f;
class!EntityEx SpecialCID;

name DamageType;

float DeathHeight;
float BurnHeight;

string StrifeName;

// identifier in conversation scripts, originaly index into mobjinfo
int ConversationID;
int CurrentSpeech; // current speech index

// actor's inventory
Inventory Inventory;

//float FloatBobPhase; // moved to Entity

// for A_ExplodeParms
int ExplosionDamage;
int ExplosionRadius;

string Obituary;
string HitObituary;

state PrevEffectState;

int MeleeDamage;
name MeleeSound;
float MissileHeight;
class!Actor MissileType;

// view offset when used as a player camera
float CameraHeight;

// customiseable blood
class!Actor BloodType;
class!Actor BloodSplatterType;
class!Actor AxeBloodType;
int BloodColor; // used for particle effects
int BloodTranslation; // forced onto blood actors and decals
bool bBloodDisableSplats; // has sense only for blood actors
bool bCopyBloodTranslation; // set in decorate with "+CopyBloodTranslation", used in blood actors to force-copy their translation (blood color)

array!DropItemInfo DropItemList;

int SkillRespawnCount;

// customiseable jump celocity
float JumpVelZ;
float JumpTime;

//float CrouchHeight;
float crouchfactor = 1.0;

// gozzo crap
bool bUseKillScripts;
bool bNoKillScripts;
bool bDontCorpse;

//int ScoreValue; // for APROP_Score; it is named "Score" now
float GenericDamageFactor = 1.0; // for APROP_DamageFactor
float GenericDamageMultiplier = 1.0; // for APROP_DamageMultiplier

float ProjectileKickback; // 0 means "don't use"

// temporary for physics z change due to stepping
transient float tmp_phys_z_change;
transient float tmp_phys_last_water_z; // used to trigger water checks
transient sector_t *tmp_phys_last_water_sector; // used to trigger water checks
transient int tmp_phys_last_floor_pic; // used to avoid excessive splashes
transient float tmp_phys_last_splash_time; // `XLevel.Time`
// this is used to skip checking for scrollers for non-moving objects
transient TVec lastScrollCheckOrigin = vector(-90000, -90000, -90000);
// for transporter slides
transient TVec tmp_transporter_velocity;

// ripper projectiles can spawn enormous blood entities, so block it for some time
// don't save this field, it doesn't matter
transient float lastRipBloodTime = -666; // XLevel.Time
// this is used to prevent excessive blood in crushers
transient int lastCrushTicTime = -666;
transient int lastCrushTicBloodTime = -666;

// so we can check it in various spawners
// there is no need to save it
// set in decorate parser
// default value is "everything"
transient int GameFilter = -1;

// moved here, so we don't have to realloc 'em again and again
transient array!(LightEffectDef *) FXLights;
transient array!(ParticleEffectDef *) FXParticles;


replication {
  // this is required for decorations, so they won't spawn dynamic lights
  reliable if (Role == ROLE_Authority && bNetInitial)
    bStaticLightSpawned;

  reliable if (Role == ROLE_Authority && bNetOwner)
    Inventory, bInvulnerable;

  // this copies blood properties
  // TODO: check for the class/flag here
  //       for now, checking for class may miss some k8gore objects
  reliable if (Role == ROLE_Authority && bNetDetach /*&&
               ((Class isa 'Blood') || (GetClassReplacee(Class) isa 'Blood'))*/)
    BloodType, BloodSplatterType, AxeBloodType,
    BloodColor, BloodTranslation, bBloodDisableSplats, bCopyBloodTranslation;
}


//===========================================================================
//
//  EngineHelperGetInventory
//
//===========================================================================
override Entity EngineHelperGetInventory () {
  return Inventory;
}


//==========================================================================
//
//  CheckSpawnGameFilter
//
//==========================================================================
static bool CheckSpawnGameFilter (class cls, GameInfo gi) {
  if (!cls) return false;
  if (!gi) return true;
  class!EntityEx e = class!EntityEx(cls);
  if (!e) return true;
  return !!(e.default.GameFilter&gi.GameFilterFlag);
}


//==========================================================================
//
//  CopyTranslations
//
//==========================================================================
override void CopyTranslations (Entity src) {
  ::CopyTranslations(src);
  EntityEx ee = EntityEx(src);
  if (ee) {
    if (ee.BloodTranslation) BloodTranslation = ee.BloodTranslation;
    if (ee.BloodColor) BloodColor = ee.BloodColor;
  }
}


//==========================================================================
//
//  CopyBloodTranslations
//
//==========================================================================
void CopyBloodTranslations (Entity src, bool copyNormalTranslation) {
  if (!src || bDontTranslate) return;
  if (copyNormalTranslation /*|| !specified_copyNormalTranslation*/) CopyTranslations(src);
  EntityEx ee = EntityEx(src);
  if (!ee) return;
  if (ee.BloodTranslation) {
    Translation = ee.BloodTranslation;
    BloodTranslation = Translation;
    if (ee.BloodColor) BloodColor = ee.BloodColor;
  } else if (ee.bCopyBloodTranslation) {
    if (ee.Translation) {
      Translation = ee.Translation;
      BloodTranslation = Translation;
    }
  }
}


//==========================================================================
//
//  CarryBloodTranslations
//
//==========================================================================
void CarryBloodTranslations (Entity src) {
  if (!src || bDontTranslate) return;
  EntityEx ee = EntityEx(src);
  if (!ee) return;
  /*
  if (ee.BloodTranslation && ee.bCopyBloodTranslation) {
    if (ee.BloodTranslation) { Translation = ee.BloodTranslation; BloodTranslation = ee.BloodTranslation; }
    if (ee.BloodColor) BloodColor = ee.BloodColor;
  }
  */
  if (ee.Translation && ee.bCopyBloodTranslation) {
    if (ee.BloodTranslation) { Translation = ee.Translation; BloodTranslation = ee.Translation; }
    if (ee.BloodColor) BloodColor = ee.BloodColor;
  }
}


//===========================================================================
//
//  eventFindTargetForACS
//
//===========================================================================
override Entity eventFindTargetForACS () {
  // player?
  if (bIsPlayer) {
    if (Player.PlayerState == PST_DEAD) return (Target ? Target : self); // target holds a killer
    // something player is aiming at
    // create direction vector
    TAVec ang = Angles;
    TVec dir;
    AngleVector(ang, dir);
    dir = Normalise(dir);
    return PickActor(default, dir, 8192);
  }
  // for other things, `Target` holds what we want
  return (Target ? Target : self);
}


//==========================================================================
//
//  VerifyTargetChain
//
//  Checks whether this actor is a missile
//  Unfortunately this was buggy in older versions of the code and many
//  released DECORATE monsters rely on this bug so it can only be fixed
//  with an optional flag
//
//  taken directly from Zandronum
//
//==========================================================================
final void VerifyTargetChain (optional bool preciseMissileCheck) {
  if (!specified_preciseMissileCheck) preciseMissileCheck = true;
  if (IsMissile(preciseMissileCheck)) return;

  EntityEx eeorigin = self;
  EntityEx eenext = eeorigin.Target;

  // eeorigin: the most recent actor that has been verified as appearing only once
  // eenext: the next actor to be verified; will be "eeorigin" in the next iteration

  // we only care when there are missiles involved
  while (eenext && eenext.IsMissile(preciseMissileCheck)) {
    EntityEx compare = self;
    // every new actor must prove not to be the first actor in the chain, or any subsequent actor
    // any actor up to and including "eeorigin" has only appeared once
    for (;;) {
      if (compare == eenext) {
        // if any of the actors from self to (inclusive) origin match the next actor,
        // self has reached/created a loop
        self.Target = none;
        return;
      }
      if (compare == eeorigin) break; // when "compare" = eeorigin, we know that the next actor is, and should be "eenext"
      compare = compare.Target;
    }

    eeorigin = eenext;
    eenext = eenext.Target;
  }
}


//===========================================================================
//
//  VerifyMasterChain
//
//  see VerifyTargetChain for detailed comments
//
//===========================================================================
final void VerifyMasterChain () {
  EntityEx eeorigin = self;
  EntityEx eenext = eeorigin.Master;
  // We always care (See "VerifyTargetChain")
  while (eenext) {
    EntityEx compare = self;
    for (;;) {
      if (compare == eenext) {
        self.Master = none;
        return;
      }
      if (compare == eeorigin) break;
      compare = compare.Master;
    }

    eeorigin = eenext;
    eenext = eenext.Master;
  }
}


//===========================================================================
//
//  eventSetPointerForACS
//
//===========================================================================
override bool eventSetPointerForACS (int assign_slot, int atid, int aptr, int flags) {
  //int count = 0;
  EntityEx tgt = none;
  foreach (EntityEx e; Level.eachTID(atid, self)) {
    e = EntityEx(e.DecorDoAAPtr('eventSetPointerForACS', aptr));
    if (!e) continue;
    tgt = e;
    if (e == self) tgt = none;
    break;
  }
  switch (assign_slot) {
    case AAPTR_TARGET:
      Target = tgt;
      if (!(flags&PTROP_UNSAFETARGET)) VerifyTargetChain();
      return !!Target;
    case AAPTR_MASTER:
      Master = tgt;
      if (!(flags&PTROP_UNSAFEMASTER)) VerifyMasterChain();
      return !!Master;
    case AAPTR_TRACER:
      Tracer = tgt;
      return !!Tracer;
  }
  return !!tgt; // oops, looks like a bug, but Zandronum does it like this
}


//===========================================================================
//
//  decoRearrangePtrGetPtr
//
//===========================================================================
final EntityEx decoRearrangePtrGetPtr (int aptr, EntityEx defval,
                  EntityEx oldTarget, EntityEx oldMaster, EntityEx oldTracer)
{
  switch (aptr) {
    case AAPTR_DEFAULT: return defval;
    case AAPTR_NULL: return none;
    case AAPTR_TARGET: return oldTarget;
    case AAPTR_MASTER: return oldMaster;
    case AAPTR_TRACER: return oldTracer;
  }
  return none;
}


//===========================================================================
//
//  A_RearrangePointers
//
//===========================================================================
[decorate] final void A_RearrangePointers (int aptrtarget, optional int aptrmaster, optional int aptrtracer, optional int flags) {
  EntityEx oldTarget = Target;
  EntityEx oldMaster = Master;
  EntityEx oldTracer = Tracer;

  if (flags&PTROP_NOSAFEGUARDS_FOUR) flags = PTROP_NOSAFEGUARDS;

  Target = decoRearrangePtrGetPtr(aptrtarget, oldTarget, oldTarget, oldMaster, oldTracer);
  if (!(flags&PTROP_UNSAFETARGET)) VerifyTargetChain();

  if (specified_aptrmaster) {
    Master = decoRearrangePtrGetPtr(aptrmaster, oldMaster, oldTarget, oldMaster, oldTracer);
    if (!(flags&PTROP_UNSAFEMASTER)) VerifyMasterChain();
  }

  if (specified_aptrtracer) {
    Tracer = decoRearrangePtrGetPtr(aptrtracer, oldTracer, oldTarget, oldMaster, oldTracer);
  }
}


//===========================================================================
//
//  A_TransferPointer
//
//===========================================================================
[decorate] final void A_TransferPointer (int aptrsource, int aptrrecipient, int aptrsourcefield, int aptrrecipientfield, optional int flags) {
  EntityEx src = EntityEx(DecorDoAAPtr('A_TransferPointer', aptrsource));
  //if (!src) return; //k8: dunno if this is right

  EntityEx dest = EntityEx(DecorDoAAPtr('A_TransferPointer', aptrrecipient));
  if (!dest) return;

  if (flags&PTROP_NOSAFEGUARDS_FOUR) flags = PTROP_NOSAFEGUARDS;

  EntityEx newval = (src ? src.decoRearrangePtrGetPtr(aptrsourcefield, src, src.Target, src.Master, src.Tracer) : none);

  switch (aptrrecipientfield) {
    case AAPTR_DEFAULT: break; // wtf?!
    case AAPTR_NULL: break; // wtf?!
    case AAPTR_TARGET:
      dest.Target = newval;
      if (!(flags&PTROP_UNSAFETARGET)) VerifyTargetChain();
      break;
    case AAPTR_MASTER:
      dest.Master = newval;
      if (!(flags&PTROP_UNSAFEMASTER)) VerifyMasterChain();
      break;
    case AAPTR_TRACER:
      dest.Tracer = newval;
      break;
  }
}


//===========================================================================
//
//  eventDoAAPtr
//
//===========================================================================
override Entity eventDoAAPtr (int ptr) {
  return DecorDoAAPtr('eventDoAAPtr', ptr);
}


//==========================================================================
//
//  DecorDoAAPtr
//
//==========================================================================
final Entity DecorDoAAPtr (name methodname, optional int ptr) {
  if (!specified_ptr || ptr == AAPTR_DEFAULT) return self;
  // category 1
  if (bIsPlayer) {
    if (ptr&AAPTR_PLAYER_GETTARGET) {
      //EntityEx targ = AimLineAttack(nullptr, Angles, 8192, noVertAutoAim:true);
      auto pex = PlayerEx(Player);
      bool noAAim = (pex ? !pex.bAutoAim : false), noAAVert = false/*true*/;
      Weapon Wpn = (pex ? pex.ReadyWeapon : none);
      if (Wpn && Wpn.IsAutoaimDisabled()) noAAim = true; //bNoAutoaim;
      noAAVert = noAAim;
      EntityEx targ = Aim(nullptr, 8192/*16*64*/, Angles.yaw, noAutoaim:noAAim, noVertAutoAim:noAAVert);
      if (targ) return targ;
      ptr |= AAPTR_NULL;
    }
    // AAPTR_PLAYER_GETCONVERSATION // no strife dialogues, so skip
  } else {
    if (ptr&AAPTR_PLAYER_GETTARGET) ptr |= AAPTR_NULL;
  }
  // category 2
  if (ptr&AAPTR_OWNER) return Owner; // k8vavoom extensions
  if (ptr&AAPTR_TARGET) return Target;
  if (ptr&AAPTR_MASTER) return Master;
  if (ptr&AAPTR_TRACER) return Tracer;
  if (ptr&AAPTR_FRIENDPLAYER) {
    if (bFriendly) {
      int fpn = FriendPlayer;
      if (fpn < 1 || fpn > MAXPLAYERS) {
        if (!Level.Game.netgame) {
          // in non-mp games, there is only one player, so consider it as a friend
          fpn = 1;
        } else if (!Level.Game.deathmatch) {
          // return first active player
          // this is not strictly right, but meh...
          foreach (int pnum; 0..MAXPLAYERS) {
            auto plr = Level.Game.Players[pnum];
            if (plr && plr.bSpawned && plr.MO) return plr.MO;
          }
        }
      }
      if (fpn > 0 && fpn <= MAXPLAYERS) {
        auto plr = Level.Game.Players[fpn-1];
        if (plr && plr.bSpawned && plr.MO) return plr.MO;
      }
    }
    ptr |= AAPTR_NULL;
  }
  if (ptr&AAPTR_LINETARGET) {
    EntityEx targ = Aim(nullptr, 2048/*16*64*/, Angles.yaw);
    if (targ) return targ;
    ptr |= AAPTR_NULL;
  }
  // category 3
  int plridx = -1;
       if (ptr&AAPTR_PLAYER1) plridx = 0;
  else if (ptr&AAPTR_PLAYER2) plridx = 1;
  else if (ptr&AAPTR_PLAYER3) plridx = 2;
  else if (ptr&AAPTR_PLAYER4) plridx = 3;
  else if (ptr&AAPTR_PLAYER5) plridx = 4;
  else if (ptr&AAPTR_PLAYER6) plridx = 5;
  else if (ptr&AAPTR_PLAYER7) plridx = 6;
  else if (ptr&AAPTR_PLAYER8) plridx = 7;
  if (plridx >= 0 && plridx < MAXPLAYERS) {
    auto plr = Level.Game.Players[plridx];
    if (plr && plr.bSpawned && plr.MO) return plr.MO;
    ptr |= AAPTR_NULL;
  }
  if (ptr&AAPTR_NULL) return none;
  FatalError("%s: unsupported ptr (0x%x)", methodname, ptr);
  return none;
}


//==========================================================================
//
//  DecorFilterCheck
//
//  returns `true` if filter passed
//
//==========================================================================
final bool DecorFilterCheck (bool invertFilter, bool invertSpecies, bool either,
                             optional name filter, optional name aspecies)
{
  if (!specified_filter && !specified_aspecies) return true;

  // 0: unknown (considered true, lol); -1: filter didn't hit; 1: filter hit
  int flt = 0, spc = 0;

  // check filters
  if (specified_filter /*&& filter*/) flt = (nameicmp(GetClassName(Class), filter) != 0 ? 1 : -1); //k8: should we check replacements or inheritance chain?
  if (specified_aspecies /*&& aspecies*/) spc = (nameicmp(GetSpecies(), aspecies) != 0 ? 1 : -1);

  // invert filters, if necessary
  if (invertFilter) flt = -flt;
  if (invertSpecies) spc = -spc;

  // process filters
  return
    either ?
      (spc >= 0 && flt >= 0) :
      (spc >= 0 || flt >= 0);
}


//==========================================================================
//
//  CalcEntityFlags
//
//  convert bool fields to `MF_XXX` flags
//
//==========================================================================
final int CalcEntityFlags () {
  int res = 0;
  if (bSpecial) res |= MF_SPECIAL;
  if (bSolid) res |= MF_SOLID;
  if (bShootable) res |= MF_SHOOTABLE;
  if (bNoSector) res |= MF_NOSECTOR;
  if (bNoBlockmap) res |= MF_NOBLOCKMAP;
  if (bAmbush) res |= MF_AMBUSH;
  if (bJustHit) res |= MF_JUSTHIT;
  if (bJustAttacked) res |= MF_JUSTATTACKED;
  if (bSpawnCeiling) res |= MF_SPAWNCEILING;
  if (bNoGravity) res |= MF_NOGRAVITY;
  if (bDropOff) res |= MF_DROPOFF;
  if (bPickUp) res |= MF_PICKUP;
  if (!bColideWithThings && !bColideWithWorld) res |= MF_NOCLIP;
  if (bInChase) res |= MF_INCHASE;
  if (bFloat) res |= MF_FLOAT;
  if (bTeleport) res |= MF_TELEPORT;
  if (bMissile) res |= MF_MISSILE;
  if (bDropped) res |= MF_DROPPED;
  if (bShadow) res |= MF_SHADOW;
  if (bNoBlood) res |= MF_NOBLOOD;
  if (bCorpse) res |= MF_CORPSE;
  if (bInFloat) res |= MF_INFLOAT;
  //if (bInBounce) res |= MF_INBOUNCE;
  if (bCountKill) res |= MF_COUNTKILL;
  if (bCountItem) res |= MF_COUNTITEM;
  if (bSkullFly) res |= MF_SKULLFLY;
  if (bNoDeathmatch) res |= MF_NOTDMATCH;
  if (bSpawnSoundSource) res |= MF_SPAWNSOUNDSOURCE;
  if (bFriendly) res |= MF_FRIENDLY;
  //k8:notyet:const int MF_UNMORPHED = 0x10000000;
  if (bNoLiftDrop) res |= MF_NOLIFTDROP;
  if (bStealth) res |= MF_STEALTH;
  if (bIceCorpse) res |= MF_ICECORPSE;
  return res;
}


//==========================================================================
//
//  IsBloodAllowed
//
//==========================================================================
bool IsBloodAllowed () {
  if (bNoBlood) return false;

  if (bInvisible || bInvulnerable) return false; // don't spawn blood for invulnerable things
  if (!bMonster && !bIsPlayer) return false; // only mosters and players has blood
  if (bMonster && Health >= 10_000) return false; // this looks like something stationary, skip it

  return true;
}


//==========================================================================
//
//  IsNormalLikeDamage
//
//  map some built-in damage types to normal
//
//==========================================================================
bool IsNormalLikeDamage (name DmgType) {
  return
    !DmgType ||
    nameicmp(DmgType, 'None') == 0 ||
    nameicmp(DmgType, 'Normal') == 0 ||
    nameicmp(DmgType, 'Bullet') == 0 ||
    nameicmp(DmgType, 'Shell') == 0 ||
    nameicmp(DmgType, 'Fist') == 0 ||
    nameicmp(DmgType, 'BerserkFist') == 0 ||
    nameicmp(DmgType, 'Chainsaw') == 0 ||
    nameicmp(DmgType, 'BDW_Bullet') == 0 ||
    nameicmp(DmgType, 'BDW_Shell') == 0;
}


//==========================================================================
//
//  FindDamageFactorInternal
//
//  `df` is "normal damage" if damage factor not found
//  returns `true` if found
//
//==========================================================================
final bool FindDamageFactorInternal (name DmgType, out DamageFactor dfres) {
  float dmgNormal = float.nan;
  bool normalNoArmor = false;
  bool normalReplace = false;
  //printdebug("%C: FindDamageFactorInternal: %s: factor=%s; replace=%s; noarmor=%B (nan=%s)", self, DmgType, dmgNormal, normalReplace, normalNoArmor, float.nan);

  // search in entity damage factors
  foreach (const ref auto df; DamageFactors) {
    //printdebug("  %C: dtype=%s; factor=%s (entity)", self, df.DamageType, df.Factor);
    if (nameicmp(df.DamageType, DmgType) == 0 ||
        (!DmgType && nameicmp(df.DamageType, 'None') == 0) ||
        (!df.DamageType && nameicmp(DmgType, 'None') == 0))
    {
      dfres = df;
      return true;
    }
    if (dmgNormal.isnan && nameicmp(df.DamageType, 'None') == 0) {
      dmgNormal = df.Factor;
      if (dmgNormal < 0) dmgNormal = 1; // this is what GZDoom does
      normalReplace = df.replaceFactor;
      normalNoArmor = df.skipArmor;
    }
  }

  // search in custom damage types
  foreach (const ref auto df; Level.Game.CustomDamageFactors) {
    //printdebug("  %C: dtype=%s; factor=%s; replace=%B; noarmor=%B (level)", self, df.DamageType, df.Factor, df.replaceFactor, df.skipArmor);
    if (nameicmp(df.DamageType, DmgType) == 0 ||
        (!DmgType && nameicmp(df.DamageType, 'None') == 0) ||
        (!df.DamageType && nameicmp(DmgType, 'None') == 0))
    {
      dfres = df;
      return true;
    }
    if (dmgNormal.isnan && nameicmp(df.DamageType, 'None') == 0) {
      dmgNormal = df.Factor;
      if (dmgNormal < 0) dmgNormal = 1; // this is what GZDoom does
      normalReplace = df.replaceFactor;
      normalNoArmor = df.skipArmor;
    }
  }

  //printdebug("%C: FindDamageFactorInternal: %s: factor=%s; replace=%s; noarmor=%B", self, DmgType, dmgNormal, normalReplace, normalNoArmor);
  dfres.Factor = dmgNormal;
  dfres.replaceFactor = normalReplace;
  dfres.skipArmor = normalNoArmor;
  return false;
}


//==========================================================================
//
//  FindDamageType
//
//  returns `defaultFactor` if no damage type found
//
//==========================================================================
final float FindDamageFactor (name DmgType, float defaultFactor, out bool replaceFactor, out bool skipArmor) {
  replaceFactor = false;
  skipArmor = false;

  //printdebug("%C: FindDamageFactor; type=%s", self, DmgType);
  if (DmgType && nameicmp(DmgType, 'Normal') == 0) DmgType = 'None';
  DamageFactor dfnormal;
  DamageFactor df;

  // try usual name
  if (FindDamageFactorInternal(DmgType, out df)) {
    //printdebug("%C:FindDamageFactor:000: dtype=%s; factor=%s; replace=%B; noarmor=%B", self, df.DamageType, df.Factor, df.replaceFactor, df.skipArmor);
    float dmgFactor = df.Factor;
    if (dmgFactor < 0) dmgFactor = 1; // this is what GZDoom does
    replaceFactor = df.replaceFactor;
    skipArmor = df.skipArmor;
    return dmgFactor;
  }

  // save normal damage type
  dfnormal = df;

  // try some mapped names
  if (nameicmp(DmgType, 'BDW_Bullet') == 0 || nameicmp(DmgType, 'Shell') == 0) {
    if (FindDamageFactorInternal('Bullet', out df)) {
      //printdebug("%C:FindDamageFactor:001: dtype=%s; factor=%s; replace=%B; noarmor=%B", self, df.DamageType, df.Factor, df.replaceFactor, df.skipArmor);
      float dmgFactor = df.Factor;
      if (dmgFactor < 0) dmgFactor = 1; // this is what GZDoom does
      replaceFactor = df.replaceFactor;
      skipArmor = df.skipArmor;
      return dmgFactor;
    }
  }

  if (nameicmp(DmgType, 'BDW_Shell') == 0) {
    if (FindDamageFactorInternal('Shell', out df) || FindDamageFactorInternal('Bullet', out df)) {
      //printdebug("%C:FindDamageFactor:002: dtype=%s; factor=%s; replace=%B; noarmor=%B", self, df.DamageType, df.Factor, df.replaceFactor, df.skipArmor);
      float dmgFactor = df.Factor;
      if (dmgFactor < 0) dmgFactor = 1; // this is what GZDoom does
      replaceFactor = df.replaceFactor;
      skipArmor = df.skipArmor;
      return dmgFactor;
    }
  }

  // map some built-in damage types to normal
  if (!dfnormal.Factor.isnan && IsNormalLikeDamage(DmgType)) {
    //printdebug("%C:FindDamageFactor:003: dtype=%s; factor=%s; replace=%B; noarmor=%B", self, df.DamageType, df.Factor, df.replaceFactor, df.skipArmor);
    float dmgFactor = dfnormal.Factor;
    if (dmgFactor < 0) dmgFactor = 1; // this is what GZDoom does
    replaceFactor = dfnormal.replaceFactor;
    skipArmor = dfnormal.skipArmor;
    return dmgFactor;
  }

  return defaultFactor;
}


//==========================================================================
//
//  FindPainChance
//
//  returns `defaultFactor` if no damage type found
//
//==========================================================================
final float FindPainChance (name DmgType, float defaultChance) {
  //printdebug("%C: FindDamageFactor; type=%s", self, DmgType);
  if (DmgType && nameicmp(DmgType, 'Normal') == 0) DmgType = 'None';
  float dmgNormal = float.nan;
  foreach (const ref auto df; PainChances) {
    if (nameicmp(df.DamageType, DmgType) == 0 ||
        (!DmgType && nameicmp(df.DamageType, 'None') == 0) ||
        (!df.DamageType && nameicmp(DmgType, 'None') == 0))
    {
      return df.Chance;
    }
    if (dmgNormal.isnan && nameicmp(df.DamageType, 'None') == 0) dmgNormal = df.Chance;
  }
  // map some built-in damage types to normal
  if (!dmgNormal.isnan && IsNormalLikeDamage(DmgType)) return dmgNormal;
  return defaultChance;
}


//==========================================================================
//
//  ChooseFromDropItemList
//
//  this is used when RandomSpawner is given as an inventory, or a weapon
//
//  can return `none`
//
//==========================================================================
static final class!EntityEx ChooseFromDropItemList (class!EntityEx origSpc, optional bool AllowReplace/*=true*/,
                                                    optional out bool error,
                                                    optional int delegate (const ref array!DropItemInfo list) Chooser)
{
  if (!origSpc) { error = true; return none; }
  if (!specified_AllowReplace) AllowReplace = true;
  //if (!class!EntityEx(allowedClass)) { error = true; return none; }

  error = false;

  //class!RandomSpawner spc = class!RandomSpawner(resCls);
  class!EntityEx spc = origSpc;
  int triesLeft = MAX_RANDOMSPAWNERS_RECURSION;
  while (spc) {
    if (!(--triesLeft)) {
      printwarn("RandomSpawner `%C` is looped; aborting.", origSpc);
      error = true;
      return none;
    }

    int len = spc.default.DropItemList.length;
    if (!len) return none;

    int i;
    if (specified_Chooser && Chooser) {
      i = Chooser(spc.default.DropItemList);
    } else {
      // default chooser

      int n = 0;
      foreach (const ref DropItemInfo di; spc.default.DropItemList) {
        //if (!di.Type) continue;
        int amn = di.Amount;
        if (amn <= 0) amn = 1;
        // this is how we can weight the list
        n += amn;
      }
      assert(n > 0);

      // then we reset the iterator to the start position...
      i = 0;
      // take a random number...
      n = GenRandomU31()%n;
      // ...and iterate in the array up to the random number chosen
      while (n > -1 && i < len) {
        int amn = spc.default.DropItemList[i].Amount;
        if (amn <= 0) amn = 1;
        n -= amn;
        if (i+1 < len && n > -1) {
          ++i;
        } else {
          n = -1;
        }
      }
    }

    if (i < 0 || i >= len) {
      printwarn("RandomSpawn in class `%C` got invalid random index", origSpc);
      error = true;
      return none;
    }

    // if we hit an invalid (empty) class, do nothing
    if (!spc.default.DropItemList[i].Type) {
      if (!spc.default.DropItemList[i].TypeName) return none;
      printwarn("RandomSpawn in class `%C` hit unknown class `%s`", origSpc, spc.default.DropItemList[i].TypeName);
      // something we don't know about
      //return class!Unknown;
      continue;
    }

    // ...and we can coose the item...
    if (Random() > spc.default.DropItemList[i].Chance) return none;

    spc = class!EntityEx(spc.default.DropItemList[i].Type);
    assert(spc);

    if (AllowReplace) {
      class!EntityEx replCls = class!EntityEx(GetClassReplacement(spc));
      if (replCls) spc = replCls;
    }

    if (!class!RandomSpawner(spc)) return /*allowedClass*/(spc);
    // loop
  }

  return none;
}


//==========================================================================
//
//  IsSpawnableClass
//
//==========================================================================
static final bool IsSpawnableClass (class cls) {
  if (!cls) return false;
  if (IsAbstractClass(cls)) return false;
  auto st = FindClassState(cls, 'Spawn');
  if (!st) return false; // an abstract base class
  if (!AreStateSpritesPresent(st)) return false; // no sprites
  return true;
}


//===========================================================================
//
//  A_BecomeK8VavoomInternalNoTickGrav
//
//  sets `bNoTickGrav` flag, uses current state frame as sprite
//  can optionally set lifetime and fadetime (after lifetime)
//  it fades out by 0.016 per step
//
//===========================================================================
[decorate] final void A_BecomeK8VavoomInternalNoTickGrav (optional float lifetime, optional float fadetime) {
  bNoTickGrav = true;
  StateTime = -1;
  LastMoveTime = (lifetime > 0 ? lifetime : -1);
  PlaneAlpha = (fadetime > 0 ? fadetime : -1);
  //printdebug("%C: becomes notick; lifetime=%s; fadetime=%s", self, lifetime, fadetime);
  bNoTickGravLifeTime = (LastMoveTime > 0 || PlaneAlpha > 0);
  // debug
  //if (bNoTickGravLifeTime) { LastMoveTime = 3; /*PlaneAlpha = 0.2;*/ }
}


//==========================================================================
//
//  ACSIsPointerEqual
//
//==========================================================================
override bool ACSIsPointerEqual (int aptr0, int aptr1, Entity src1) {
  EntityEx sex = EntityEx(self);
  if (!sex) return false;
  if (!EntityEx(src1)) return false;
  Entity e0 = sex.DecorDoAAPtr('ACSIsPointerEqual', aptr0);
  Entity e1 = EntityEx(src1).DecorDoAAPtr('ACSIsPointerEqual', aptr1);
  return (e0 == e1);
}
