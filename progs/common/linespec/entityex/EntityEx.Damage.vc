//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************


//==========================================================================
//
//  K8HS_IsGoodDamageType
//
//  return `true` if this damage type allowed for headshots
//  virtual, so mods can override this
//
//==========================================================================
bool K8HS_IsGoodDamageType (name damageType) {
  if (!damageType) return true; // normal damage
  if (nameicmp(damageType, 'Chainsaw') == 0 || !IsNormalLikeDamage(damageType)) {
    if (GetCvarB('k8HSDebug_ShowFailedDamageType')) print("DMGTYPE: %s", damageType);
    return false;
  }
  return true;
}


//==========================================================================
//
//  K8HS_IsIAmAKindOf
//
//  checks if `self` is a subclass, or a replacement
//  used to check for various insta-kill monster types
//  virtual, so mods can override this
//
//==========================================================================
bool K8HS_IsIAmAKindOf (name ClsName) {
  if (!ClsName) return false;
  if (self isa ClsName) return true;
  class xreplCls = GetClassReplacee(self.Class);
  if (xreplCls) return (xreplCls isa ClsName);
  return false;
}


//==========================================================================
//
//  K8HS_IsHeadshotsAllowed
//
//  called to check if this entity can be headshotted (or critical-shotted)
//  return `false` to completely disable headshots for this entity
//  virtual, so mods can override this
//
//==========================================================================
bool K8HS_IsHSAllowed () {
  // do not allow headshots/criticals on non-monster objects
  if (!bMonster) return false;
  return true;
}


//==========================================================================
//
//  K8HS_IsCriticalsAllowed
//
//  called to check if this entity can be critical-shotted
//  return `false` to avoid criticals on this entity
//  virtual, so mods can override this
//
//==========================================================================
bool K8HS_IsCriticalsAllowed () {
  return true;
}


//==========================================================================
//
//  K8HS_FastkillHook
//
//  return positive number to deal exact this damage to the entity
//  return zero or negative to process as usual
//  called before headshot checks
//  virtual, so mods can override this
//
//==========================================================================
int K8HS_FastkillHook () {
  if (K8HS_IsIAmAKindOf('PainElemental')) {
    if (GetCvarB('k8HSInstaKillPainElementals')) return Health+10;
  } else if (K8HS_IsIAmAKindOf('LostSoul')) {
    if (GetCvarB('k8HSInstaKillLostSouls')) return Health+10;
  }
  return 0;
}


//==========================================================================
//
//  K8HS_HeadshotFastKillHook
//
//  return positive number to deal exact this damage to the entity
//  return zero or negative to process as usual
//  called if headshot check passed
//  virtual, so mods can override this
//
//==========================================================================
int K8HS_HeadshotFastKillHook (int dodmg) {
  if (K8HS_IsIAmAKindOf('Archvile')) {
    int fastdamage = GetCvar('k8HSFastKillArchVileDamage');
    if (fastdamage > 0 && dodmg < fastdamage) {
      //Log(s:"Archvile superdamage: old=", d:dodmg, s:"; new=", d:fastdamage, s:"; health=", d:vicHealth);
      return fastdamage;
    }
  }
  return 0;
}


//==========================================================================
//
//  K8HS_CheckHeadshot
//
//  called to check if this entity headshotted
//  return `true` if headshot registered
//  virtual, so mods can override this
//
//==========================================================================
bool K8HS_CheckHeadshot (EntityEx inflictor, TVec hitpos, int damage, name damageType, bool secondary) {
  bool headshot = false;
  float hithgt = hitpos.z; //-Pos.z;
  float fromtop = Height-hithgt;

  if (Height <= 56.0) {
    // humans, archvile, cacodemon, demon, imp, lost soul, pain elemental, revenant
    headshot = (fromtop <= 14.0);
    //if (headshot && showHeadshots) print("HS56: TAN");
  } else if (Height <= 64.0) {
    // arachnotron(64)
    // bruiser(64)
    if (K8HS_IsIAmAKindOf('Arachnotron')) {
      headshot = (fromtop <= 18.0);
      //if (debugme) print("*******ARACHNO!");
    } else {
      headshot = (fromtop <= 15.0);
    }
    //if (headshot && showHeadshots) print("HS64: TAN");
  } else {
    // cyberdemon(110)
    // mastermind(100)
    // keen(72)
    headshot = (fromtop <= 20.0);
    //if (headshot && showHeadshots) print("HSBIG: TAN");
  }

  return headshot;
}


//==========================================================================
//
//  K8onBeforeLineDamage
//
//  this script will be called before hitscan line damage is done.
//  you can return new damage, or <= 0 to prevent any hitscan damage.
//  note that poisoned puffs will still inflict damage to victim.
//  also note that preventing victim from taking any damage will not
//  "awake" it.
//
//==========================================================================
int K8onBeforeLineDamage (EntityEx inflictor, TVec hitpos, int damage, name damageType, bool secondary) {
  // is it from player?
  if (!inflictor) return damage;
  if (!inflictor.bIsPlayer) return damage;
  if (!GetCvarB('k8HSEnabled')) return damage;

  if (!K8HS_IsGoodDamageType(damageType)) return damage;
  if (!K8HS_IsHSAllowed()) return damage;

  bool debugme = GetCvarB('k8HSDebug');

  if (debugme) {
    print("ME: %C; inf: %C", self, GetClassReplacee(inflictor.Class));
  }

  PlayerPawn plr = PlayerPawn(inflictor);

  //if (k8CheckBoolCVar('k8HSShowKnownDamage', debugme)) print("K8HS: damage type '%s', damage=%d", damageType, damage);

  bool fastkills = GetCvarB('k8HSFastKillAnnoyingMonsters');

  //int vicHealth = Health; // current health
  //int vicSpHealth = InitialHealth; // spawning health (i.e. full health for monsters)
  //int vicMass = Mass;
  //float vicRadius = Radius;
  //float vicHgt = Height;

  if (debugme) print("InitialHealth=%d; Health=%d", InitialHealth, Health);

  if (InitialHealth < 1 || Health < 1) return damage; // something is very wrong with this monster!

  // kill certain monsters in one shot
  int fastdamage = 0;
  if (fastkills) {
    fastdamage = K8HS_FastkillHook();
    if (fastdamage > 0) return fastdamage;
  }

  int refire = PlayerEx(plr.Player).Refire;
  // set `refire` to:
  //   -666: totally fucked
  //      0: not fucked
  //      1: slightly fucked
  //      2: more fucked
  //      3: even more fucked
  if (refire > 0) {
    //print("refire0: %s", refire);
         if (refire > 20) refire = -666; // totally fucked
    else if (refire > 16) refire = 3;
    else if (refire > 8) refire = 2;
    else {
      int rnd = P_Random();
           if (rnd > 200+(refire == 1 ? 10 : refire > 3 ? -10 : 0)) refire = -666; // totally fucked
      else if (rnd > 164) refire = 1; // slightly fucked
      else refire = 0; // not fucked
    }
    //print("refire1: %s", refire);
  }

  if (refire < 0) return damage; // totally fucked
  if (refire > 0 && P_Random() >= 255/refire) return damage; // oops
  //print("refire2: %s", refire);

  bool showHeadshots = false;
  if (debugme) {
    showHeadshots = GetCvarB('k8HSShowHeadshots');
    float hithgt = hitpos.z; //-Pos.z;
    float fromtop = Height-hithgt;
    print("  hithgt=%f; fromtop=%f", hithgt, fromtop);
  }

  bool headshot = K8HS_CheckHeadshot(inflictor, hitpos, damage, damageType, secondary);
  /*
  float hithgt = hitpos.z; //-Pos.z;
  float fromtop = Height-hithgt;
  if (debugme) print("  hithgt=%f; fromtop=%f", hithgt, fromtop);

  bool headshot = false;
  if (Height <= 56.0) {
    // humans, archvile, cacodemon, demon, imp, lost soul, pain elemental, revenant
    headshot = (fromtop <= 14.0);
    if (headshot && showHeadshots) print("HS56: TAN");
  } else if (Height <= 64.0) {
    // arachnotron(64)
    // bruiser(64)
    if (K8HS_IsIAmAKindOf('Arachnotron')) {
      headshot = (fromtop <= 18.0);
      if (debugme) print("*******ARACHNO!");
    } else {
      headshot = (fromtop <= 15.0);
    }
    if (headshot && showHeadshots) print("HS64: TAN");
  } else {
    // cyberdemon(110)
    // mastermind(100)
    // keen(72)
    headshot = (fromtop <= 20.0);
    if (headshot && showHeadshots) print("HSBIG: TAN");
  }
  */

  // precision shot is headshot near thing vertical center
  int precisionShot = 0; // 0: nope; -2: very far; -1: too far; 1: almost
  if (headshot && Radius > 0 && refire < 2) {
    //print("HITXY=(%s,%s)", hitpos.x, hitpos.y);
    float hc = fmin(fabs(hitpos.x), fabs(hitpos.y));
    float r3 = Radius/3;
         if (hc <= r3*0.7) precisionShot = 2;
    else if (hc <= r3) precisionShot = 1;
    else if (hc > r3*2.4) precisionShot = -2;
    else if (hc > r3*2) precisionShot = -1;
    //print("HC=%s; precisionShot=%s; radius=%s; r3*0.7=%s; r3=%s; r3*2=%s; r3*2.4=%s", hc, precisionShot, Radius, r3*0.7, r3, r3*2, r3*2.4);
  }

  // calc distance
  float mult = GetCvarF('k8HSDistMult');
  if (mult < 0.1) mult = 1.1;
  if (mult > 4) mult = 4;
  if (refire > 1) mult *= refire-1; // divide in half for more fucked refire

  float len = 10000;
  if (headshot) {
    //len = Distance2D(inflictor)*mult;
    len = sqrt((self.Origin.x-inflictor.Origin.x)*(self.Origin.x-inflictor.Origin.x)+(self.Origin.y-inflictor.Origin.y)*(self.Origin.y-inflictor.Origin.y));
    // 600: E1M1, from entry to top of the stairs
    if (debugme) print("K8HS: len=%f; multlen=%f", len, len*mult);
    len *= mult;
  }

  // head shot
  if (headshot) {
    if (showHeadshots) {
      //Log(s:"K8HS: Headshot! ", s:vicName, s:"; Height=", d:Height, s:"; fromtop=", d:fromtop, s:"; mass=", d:vicMass, s:"; radius=", d:Radius, s:"; len=", d:len);
      float hithgt = hitpos.z; //-Pos.z;
      float fromtop = Height-hithgt;
      print("K8HS: Headshot! %C; Height=%f; fromtop=%f; radius=%f; len=%f", Class, Height, fromtop, Radius, len);
    }
    bool allowCrits = K8HS_IsCriticalsAllowed();

    bool debugCrits = false;
    if (debugme) debugCrits = GetCvarB('k8HSDebug_Crits');

    int dodmg = damage; //*2 baron of hell and other Big Things
    int smallHealth = 50; // baron of hell and other Big Things
    int critChance = int(Random()*100);
    // decrease critical chance for refiring
    switch (refire) {
      case 1: critChance -= critChance/8; break; // slightly
      case 2: critChance -= critChance/4; break; // more
      case 3: critChance /= 2; break; // even more
    }

    //TODO: int tick = gametic;
    //int tick = k8hsLastHitTick+1;

    if (debugme) print("K8HS: len=%f; critChance=%d; hscount=%d", len, critChance, plr.k8hsCount);
    // shotgun, etc -- multiple hitscans per one tick?
    if (secondary) {
      // very rarely, shotgun can do double criticals
      ++plr.k8hsCount;
      if (plr.k8hsCount == 1) {
        // second hitscan
      } else if (plr.k8hsCount == 2) {
        // third hitscan; 1.25 damage sometimes
        critChance = 1;
        if (allowCrits && Random()*100.0 > 75.0) {
          dodmg += dodmg/4;
          if (debugCrits) print("*Critx1.25 (2); d=%d", dodmg);
        }
      } else {
        // fourth and other hitscans; 1.25 damage sometimes
        critChance = 1;
        if (allowCrits && Random()*100.0 > 80) {
          dodmg += dodmg/4;
          if (debugCrits) print("*Critx1.25 (3); d=%d", dodmg);
        }
      }
    } else {
      plr.k8hsCount = 0;
    }

    if (critChance > 13 && !GetCvarB('k8HSCriticals')) critChance = 13;

    int oldcc = critChance;
         if (len > 800) { if (critChance >= 75 && Random()*100 > 10) critChance = 13; }
    else if (len > 400) { if (critChance >= 75 && Random()*100 > 40) critChance = 13; }
    else if (len > 300) { if (critChance >= 75 && Random()*100 > 50) critChance = 13; }
    else if (len > 200) { if (critChance >= 75 && Random()*100 > 70) critChance = 13; }
    else if (len < 90) {
           if (plr.k8hsCount <= 1) critChance += 42;
      else if (plr.k8hsCount <= 2) critChance += 33;
      else if (plr.k8hsCount >= 8) critChance += 10;
      else critChance += (8-plr.k8hsCount)*9;
      if (precisionShot > 0 && plr.k8hsCount > 1) precisionShot = 0; // don't do it for secondary bullets
    }
    if (debugme) print("oldcc=%d; critChance=%d; len=%f", oldcc, critChance, len);

    if (precisionShot) {
      //print("PREC=%s; chance-before=%s", precisionShot, critChance);
           if (precisionShot > 1) critChance += 23;
      else if (precisionShot > 0) critChance += 13;
      else if (precisionShot < -1) critChance -= 23;
      else if (precisionShot < 0) critChance -= 13;
      //print("  chance-after=%s", critChance);
    }

    if (!allowCrits) critChance = 0;

    // create message
    bool showMessage = false;
    string messageText = "";
    int messageColor = CR_YELLOW;

    if (critChance >= 95) {
      dodmg *= 10;
      if (debugCrits) print("*Critx10; d=%d", dodmg);
      messageText = "CRITICAL x10!";
      messageColor = CR_YELLOW;
      showMessage = true;
    } else if (critChance >= 85) {
      dodmg *= 7;
      if (debugCrits) print("*Critx7; d=%d", dodmg);
      messageText = "CRITICAL x7!";
      messageColor = CR_ORANGE;
      showMessage = true;
    } else if (critChance >= 75) {
      dodmg *= 3;
      if (debugCrits) print("*Critx3; d=%d", dodmg);
      messageText = "CRITICAL x3!";
      messageColor = CR_RED;
      showMessage = true;
    } else if (critChance >= 55) {
      dodmg *= 2;
      if (debugCrits) print("*Critx2; d=%d", dodmg);
      messageText = "CRITICAL x2!";
      messageColor = CR_RED;
      //showMessage = true;
    } else if (critChance > 10) {
      dodmg += dodmg/2; // *1.5
      if (debugCrits) print("*Critx1.5; d=%d", dodmg);
      messageText = "CRITICAL x1.5!";
      messageColor = CR_RED;
      //showMessage = true;
    }

    if (debugCrits) print("  critChance=%d; damage=%d; dodmg=%d", critChance, damage, dodmg);

    if (InitialHealth < 100) {
      // humans, imps, ...
      //dodmg = (damage <= 10 ? damage*4 : damage*3);
      smallHealth = InitialHealth/10;
    } else if (InitialHealth < 1000) {
      // demons, cacodemons, ...
      //dodmg = (damage <= 10 ? damage*3 : damage*2);
      smallHealth = InitialHealth/10;
      if (smallHealth < 12) smallHealth = 12;
    }

    if (dodmg) {
      if (showMessage && GetCvarB('k8HSShowCriticals')) {
        inflictor.Player.ClientHudMessage(
          messageText, 'smallfont', Type:0, Id:123666,
          /*Color:*/messageColor, /*ColorName:*/"",
          x:0.5, y:0.45, HudWidth:0, HudHeight:0,
          HoldTime:1.5, Time1:0.0, Time2:0.0);
      }

      if (fastkills) {
        fastdamage = K8HS_HeadshotFastKillHook(dodmg);
        if (fastdamage > 0) {
          printdebug("%C: OLD dodmg=%s; NEW dodmg=%s", self, dodmg, fastdamage);
          dodmg = fastdamage;
        }
        /*
        if (K8HS_IsIAmAKindOf('Archvile')) {
          fastdamage = GetCvar('k8HSFastKillArchVileDamage');
          if (fastdamage > 0 && dodmg < fastdamage) {
            //Log(s:"Archvile superdamage: old=", d:dodmg, s:"; new=", d:fastdamage, s:"; health=", d:vicHealth);
            dodmg = fastdamage;
          }
        }
        */
      }
      // if we will left victim with very small health, kill it instead
      bool instakill = false;
      if (Health-dodmg <= smallHealth) dodmg = Health;
      int xdmg = dodmg;
      if (Health <= dodmg) {
        // instakill, gore (fe, 'cause +1)
        instakill = true;
        dodmg = Health+5;
        if (debugCrits) print("  INSTAKILL");
      }
      // preventing normal damage will prevent monster alerting too, heh

      // ketchup spawn
      if (instakill || headshot) {
        if (!secondary || instakill || dodmg >= Health) SpawnBloodSprayHead(damage:(instakill ? Health : dodmg), spawnBloodPool:(instakill || dodmg >= Health));

        if (instakill) {
          // so they won't gib
          Health = 1;
          dodmg = 2;
        }

        // play headkill sound
        if (dodmg >= Health && GetCvarB('k8GoreOpt_HeadshotSound')) {
          //print("HEADBANG!");
          PlaySound('k8gore/headbang', CHAN_AUTO/*CHAN_VOICE*/, Volume:default, ATTN_NORMAL, Loop:false, Local:false);
        }
      }

      return dodmg;
    }
  }

  return damage;
}


//==========================================================================
//
//  DamageEx
//
//  called by PlayerPawn from `LineAttack()`
//
//==========================================================================
void DamageEx (EntityEx inflictor, EntityEx source, int damage, name DmgType, bool NoArmor, TVec hitp, bool secondary, optional bool spawnBlood) {
  int newdmg = K8onBeforeLineDamage(inflictor, hitp, damage, DmgType, secondary);
  //print("THP(%s):(%f,%f,%f); dmg=%d; new=%d; type='%s'", (secondary ? "2" : "1"), hitp.x, hitp.y, hitp.z, damage, newdmg, DmgType);
  //print("THP:(%f,%f,%f); dmg=%d; type='%s'", hitp.x, hitp.y, hitp.z, damage, "FUCK!");
  if (!secondary) {
    //printdebug("%C: first shot; spawnBlood=%B", self, spawnBlood);
    if (!specified_spawnBlood && inflictor && inflictor.bIsPlayer) {
      auto pp = PlayerPawn(inflictor);
      if (pp) {
        spawnBlood = pp.IsPrimaryBloodSpawnAllowed(self, newdmg, DmgType);
        Damage(inflictor, source, /*damage*/newdmg, DmgType, NoArmor, spawnBlood:spawnBlood);
        return;
      }
    }
    Damage(inflictor, source, /*damage*/newdmg, DmgType, NoArmor, spawnBlood:spawnBlood!optional);
  } else {
    // secondary shots won't spawn blood
    //printdebug("%C: secondary shot; spawnBlood=%B (%B); inflictor=%C; source=%C", self, spawnBlood, specified_spawnBlood, inflictor, source);
    if (!specified_spawnBlood && inflictor && inflictor.bIsPlayer) {
      auto pp = PlayerPawn(inflictor);
      if (pp) {
        spawnBlood = pp.IsSecondaryBloodSpawnAllowed(self, newdmg, DmgType);
        //if (spawnBlood) printdebug("%C: SECONDARY BLOOD!", self);
      }
    }
    Damage(inflictor, source, /*damage*/newdmg, DmgType, NoArmor, spawnBlood:spawnBlood);
  }
}


//==========================================================================
//
//  Damage
//
//  Damages both enemies and players.
//
//  "inflictor" is the thing that caused the damage, creature or missile,
//  can be nullptr (slime, etc).
//
//  "source" is the thing to target after taking damage, creature or nullptr.
//  Source and inflictor are the same for melee attacks. Source can be nullptr
//  for slime, barrel explosions and other environmental stuff.
//
//  "forced" can be set to ignore "invulnerable" flag
//
//  "spawnBlood" can be set to spawn blood
//
//  `ignorePowerups` and `NoArmor` now does the same thing (sigh)
//
//==========================================================================
final void Damage (EntityEx inflictor, EntityEx source, int damage,
                   optional name DmgType, optional bool NoArmor, optional bool forced,
                   optional bool spawnBlood,
                   optional bool ignoreDamageFactors, optional bool ignorePowerups)
{
  if (!bShootable && !forced) return; // shouldn't happen...

  if (DmgType) {
    if (nameicmp(DmgType, 'None') == 0 || nameicmp(DmgType, 'Normal') == 0) DmgType = 'None';
  } else {
    DmgType = 'None';
  }

  if (Health <= 0) {
    if (inflictor && nameicmp(DmgType, 'Ice') == 0) return;
    if (bIceCorpse) {
      // frozen
      StateTime = 0.1;
      Velocity.x = 0.0;
      Velocity.y = 0.0;
    }
    return;
  }

  // apply damage multiplier
  if (source) {
    damage = int(float(damage)*source.GenericDamageMultiplier);
    if (damage <= 0) return;
  } else if (inflictor) {
    //k8: gozzo doesn't do this, but why not?
    damage = int(float(damage)*inflictor.GenericDamageMultiplier);
    if (damage <= 0) return;
  }

  // amplify damage with powerups
  if (source && source.bIsPlayer && damage > 0 && source.Inventory) {
    int NewDmg = damage;
    source.Inventory.AmplifyDamage(self, damage, DmgType, NewDmg);
    damage = NewDmg;
  }

  // forced blood?
  if (spawnBlood && damage > 0) {
    if (damage > 100 || forced) {
      SpawnBloodAtHeadExplosion(damage, inflictor);
    } else {
      if (inflictor) {
        SpawnBlood(Origin, damage, inflictor.Origin);
      } else {
        SpawnBlood(Origin, damage);
      }
    }
  }

  if (!forced && bInvulnerable && damage < 10000) {
    // actor is invulnerable
    if (bIsPlayer) {
      if (LineSpecialGameInfo(Level.Game).bNoDamageThrustInvulnerable) {
        // for player, no exceptions
        return;
      }
    } else if (!inflictor || !inflictor.bDamageInvulnerable) {
      return;
    }
  }

  if (inflictor && inflictor.bPierceArmor) NoArmor = true;

  // spectral targets only take damage from spectral projectiles
  if (bSpectral && !forced) {
    if (!inflictor || !inflictor.bSpectral) {
      if (MissileState) SetState(MissileState);
      return;
    }
  }

  // Andy Baker's Stealth monsters
  if (bStealth) {
    Alpha = 1.0;
    VisDir = -1;
  }

  if (bSkullFly) {
    if (bSkullFlyInvulnerable && !forced) return; // invulnerable during charge attack
    bSkullFly = false;
    Velocity = vector(0.0, 0.0, 0.0);
    if (Health > 0) SetState(SeeState);
  }

  if (bDormant && !forced) return; // invulnerable, and won't wake up

  bool isBuddha = false;
  if (bIsPlayer) {
    // Take half damage in trainer mode
    damage = int(float(damage)*Level.World.GetDamageFactor());
    isBuddha = !!(PlayerEx(Player).Cheats&PlayerEx::CF_BUDDHA);
    if (!isBuddha && !ignorePowerups && FindBuddhaPowerup()) isBuddha = true;
  }

  // special damage types
  if (inflictor) {
    damage = inflictor.DoSpecialDamage(self, source, damage);
    if (damage == -1) return;
  }

  if (nameicmp(DmgType, 'SpectralLow') == 0 && bLowSpectralResist) damage = 0;

  //k8: ignore this for `ignoreDamageFactors`?
  if (bFireResist && nameicmp(DmgType, 'Fire')) damage >>= 1;

  if (damage > 0 && !ignoreDamageFactors) {
    float realdmgfactor = GenericDamageFactor;
    if (DamageFactors || Level.Game.CustomDamageFactors) {
      bool replacefact = false;
      bool skiparmor = false;
      float dfactor = FindDamageFactor(DmgType, float.nan, out replacefact, out skiparmor);
      if (!dfactor.isnan) {
        if (!replacefact) realdmgfactor *= dfactor; else realdmgfactor = dfactor;
        if (skiparmor) NoArmor = true;
      }
    }
    //printdebug("%C: damage type %s reduction factor is %s", self, DmgType, dfactor);
    damage = int(float(damage)*realdmgfactor);
  }
  if (damage <= 0) return;

  damage = TakeSpecialDamage(inflictor, source, damage, DmgType, forced:forced!optional);
  if (damage < 0) return; // was `-1`

  //printdebug("DAMAGE: self=`%C`; damage=%d; health=%s; forced=%B; dmgtype=<%s>", self, damage, Health, forced, DmgType);
  // push the target unless using a weapon that should not inflict thrust
  if (inflictor && inflictor != self && bColideWithThings && !inflictor.bNoDamageThrust) {
    float kickback;
    if (bIsPlayer && !GetCvar('damage_thrust')) {
      kickback = 0.0;
    } else if (!source || !source.bIsPlayer) {
      kickback = LineSpecialGameInfo(Level.Game).DefaultKickBack;
    } else {
      auto wpn = PlayerEx(source.Player).ReadyWeapon;
      kickback = (wpn ? wpn.Kickback : LineSpecialGameInfo(Level.Game).DefaultKickBack);
    }
    if (kickback) {
      TVec dir;
      float thrust = kickback/8.0*float(damage)/fmax(1, Mass);
      if (thrust < 0.0 || thrust > 10.0) thrust = 10.0;
      // make fall forwards sometimes
      //k8: but not if player is cheating
      if (!bIsPlayer || (!isBuddha && !(PlayerEx(Player).Cheats&(PlayerEx::CF_BUDDHA|PlayerEx::CF_NOCLIP|PlayerEx::CF_GODMODE)))) {
        if (damage < 40 && damage > Health &&
            Origin.z-inflictor.Origin.z > 64.0 &&
            (P_Random()&1) &&
            // [RH] but only if not too fast and not flying
            thrust < 10.0 &&
            !bNoGravity)
        {
          //print("!!!!!!!!!!! damage=%s; Health=%s; distz=%s; thrust=%s; nograv=%B", damage, Health, Origin.z-inflictor.Origin.z, thrust, bNoGravity);
          Angles.yaw += 180.0;
          Angles.yaw = AngleMod360(Angles.yaw);
          thrust *= 4.0;
        }
      }
      dir = GetCenter()-inflictor.GetCenter();
      if (Length(dir) < 0.001) {
        // zero length. In this case Doom would use angle 0
        dir = vector(1.0, 0.0, 0.0);
      }
      if (source && source.bIsPlayer && source == inflictor &&
          PlayerEx(source.Player).ReadyWeapon &&
          PlayerEx(source.Player).ReadyWeapon.bStaff2Kickback)
      {
        // staff power level 2
        dir.z = 0.0;
        Velocity += 35.0*10.0*Normalise(dir);
        Velocity.z += 35.0*5.0;
      } else {
        Velocity += 35.0*thrust*Normalise(dir);
      }
    }
  }

  // player specific
  if (bIsPlayer) {
    //print("%C: dmg=%s; invul=%B", self, damage, bInvulnerable);
    if (!forced && PlayerEx(Player).CheckFriendlyFire(source, damage)) return;

    // end of game hell hack
    if ((Sector->special&SECSPEC_BASE_MASK) == SECSPEC_DamageSuperHellslimeExit && damage >= Health) {
      damage = Health-1;
    }

    // below certain threshold, ignore damage in GOD mode, or with INVUL power
    if (damage < 1000 && (bInvulnerable || (PlayerEx(Player).Cheats&PlayerEx::CF_GODMODE))) {
      return;
    }

    if (!NoArmor && !ignorePowerups && Inventory) {
      int NewDmg = damage;
      Inventory.AbsorbDamage(source, damage, DmgType, NewDmg);
      damage = NewDmg;
      if (damage <= 0) return;
    }

    if (damage >= Health && (Level.World.bSkillAutoUseHealth ||
        Level.Game.deathmatch) && !PlayerEx(Player).MorphTime)
    {
      // try to use some inventory health
      AutoUseHealth(damage-Health+1);
    }

    if (Player.Health-damage < 50 && !Level.Game.deathmatch) {
      // try to use some inventory health
      AutoUseStrifeHealth(damage-Health+1);
    }
    Player.Health -= damage; // mirror mobj health here for Dave
    if (Player.Health < 0) Player.Health = 0;
    if (Player.Health < 1 && /*(PlayerEx(Player).Cheats&PlayerEx::CF_BUDDHA)*/isBuddha) Player.Health = 1;
    PlayerEx(Player).Attacker = source;
    PlayerEx(Player).DamageFlash += float(damage)/35.0; // add damage after armor / invuln
    if (PlayerEx(Player).DamageFlash > 3.0) PlayerEx(Player).DamageFlash = 3.0; // teleport stomp does 10k points...
    // for Korax Arena
    PlayerEx(Player).Damaged(inflictor);
  }

  // do the damage
  Health -= damage;
  if (bIsPlayer && Health < 1 && /*(PlayerEx(Player).Cheats&PlayerEx::CF_BUDDHA)*/isBuddha) Health = 1;
  if (Health <= 0) {
    // death
    Special1 = damage;
    // check for special fire damage or ice damage deaths
    if (nameicmp(DmgType, 'Fire') == 0) {
      if (bIsPlayer && !PlayerEx(Player).MorphTime) {
        // check for flame death
        if (!inflictor || !inflictor.bConditionalFireDamage || (Health > -50 && damage > 25)) DamageType = 'Fire';
      } else {
        DamageType = 'Fire'; // for obituary
      }
    } else {
      DamageType = DmgType; // for obituary
    }
    if (source && source.IsServant()) {
      // minotaur's kills go to his master
      EntityEx master = source.Tracer;
      // make sure still alive and not a pointer to fighter head
      if (master && master.bIsPlayer && master.Player.MO == master) source = master;
    }
    Died(source, inflictor);
    return;
  }

  state WoundState = FindState('Wound', DmgType, false);
  if (Health <= WoundHealth && WoundState) {
    SetState(WoundState);
    return;
  }

  float PChance = FindPainChance(DmgType, PainChance);

  if (!bNoPain && !bSkullFly && damage >= PainThreshold && Random() < PChance) {
    if (inflictor && inflictor.bLightning) {
      if ((P_Random() < 96 && !inflictor.bPainless) || inflictor.bForcePain) {
        bJustHit = true; // fight back!
        if (FindState('Pain', DmgType, false)) {
          SetState(FindState('Pain', DmgType, false));
        }
      } else {
        // "electrocute" the target
        bFullBright = true;
        if (HowlSound && bMonster && P_Random() < 128 && !GetSoundPlayingInfo(self, GetSoundID(HowlSound))) {
          PlaySound(HowlSound, CHAN_VOICE);
        }
      }
    } else {
      bJustHit = true; // fight back!
      if (!inflictor || (inflictor && (!inflictor.bPainless || inflictor.bForcePain))) {
        if (FindState('Pain', DmgType, false)) {
          SetState(FindState('Pain', DmgType, false));
        }
      }
      if (inflictor && inflictor.bHowlVictims) {
        if (HowlSound && bMonster && P_Random() < 128 &&
            !GetSoundPlayingInfo(self, GetSoundID(HowlSound)))
        {
          PlaySound(HowlSound, CHAN_VOICE);
        }
      }
    }
  }

  ReactionCount = 0; // we're awake now...

  if (source) {
    if (source == Target) {
      Threshold = BASETHRESHOLD;
      if (State == IdleState && SeeState) SetState(SeeState);
    } else if (OkayToSwitchTarget(source)) {
      // Target actor is not intent on another actor,
      // so make him chase after source

      // killough 2/15/98: remember last enemy, to prevent
      // sleeping early; 2/21/98: Place priority on players
      if (!LastEnemy || (!LastEnemy.bIsPlayer && !TIDToHate) || LastEnemy.Health <= 0) {
        LastEnemy = Target; // remember last enemy - killough
      }
      Target = source;
      Threshold = BASETHRESHOLD;
      if (State == IdleState && SeeState) SetState(SeeState);
    }
  }
}


//==========================================================================
//
//  DoSpecialDamage
//
//==========================================================================
int DoSpecialDamage (EntityEx victim, EntityEx source, int damage) {
  if (victim.bIsPlayer && MissilePoisonDamage > 0) {
    victim.PoisonPlayer(source, MissilePoisonDamage);
    damage >>= 1;
  }
  return damage;
}


//==========================================================================
//
//  TakeSpecialDamage
//
//==========================================================================
int TakeSpecialDamage (EntityEx inflictor, EntityEx source, int damage, name DmgType, optional bool forced) {
  if (bNoDamage && !forced) return 0;

  // always apply damage if actor has regular death state or no death states at all
  if (FindState('Death') || !HasSpecialStates('Death')) return damage;

  // if there's no corresponding death state, actor takes no damage at all
  if (nameicmp(DmgType, 'Ice') == 0) {
    if (FindState('Death', 'Ice', true)) return damage;
    if ((bIsPlayer || bMonster) && !bNoIceDeath) return damage;
    return -1;
  }

  return (FindState('Death', DmgType) ? damage : -1);
}


//==========================================================================
//
//  OkayToSwitchTarget
//
//==========================================================================
bool OkayToSwitchTarget (EntityEx source) {
  if (source == self) return false; // don't hate self
  if (!source.bShootable) return false; // don't hate actors that cannot be hurt
  if (bNoTargetSwitch && Target) return false;
  if ((Master && source.IsA(GetClassName(Master.Class))) || // don't attack your master (or others of its type)
      (source.Master && IsA(GetClassName(source.Master.Class)))) // don't attack your minion (or those of others of your type)
  {
    if (!IsHostile(source) && // allow target switch if other is considered hostile
        (source.TID != TIDToHate || TIDToHate == 0) && // or has the tid we hate
        source.TIDToHate == TIDToHate) // or has different hate information
    {
      return false;
    }
  }
  if (source.bNeverTarget && (source.TID != TIDToHate || TIDToHate == 0) && !IsHostile(source)) return false;
  if (Threshold && !bNoGrudge) return false;
  if (IsFriend(source)) return false; // don't hate friends

  int Inf = GetInfighting();
  if (Inf < 0 && !source.bIsPlayer && !IsHostile(source)) {
    // infighting is off, so don't target it if it's not hostile
    return false;
  }

  // don't target actors that hate the same thing
  if (TIDToHate && TIDToHate == source.TIDToHate) return false;

  if (source.bIsPlayer && bNoHatePlayers) return false;

  if (Target && Target.Health > 0 && TIDToHate &&
      Target.TID == TIDToHate && Random() < 0.5 && CanSee(Target))
  {
    // don't be too quick to give up things we hate
    return false;
  }

  return true;
}


//==========================================================================
//
//  Died
//
//==========================================================================
void Died (EntityEx source, EntityEx inflictor) {
  Inventory Item;

  // calculate gibs health
  int GHealth = GibsHealth;
  if (!GHealth) {
    GHealth = int(float(-InitialHealth)*LineSpecialGameInfo(Level.Game).GibsHealthFactor);
  }

  // handle possible unmorph on death
  bool WasGibbed = (Health < GHealth);
  EntityEx RealSelf = none;
  int RealStyle = 0;
  int RealHealth = 0;
  if (MorphedDeath(RealSelf, RealStyle, RealHealth)) {
    if (!(RealStyle&MORPH_UNDOBYDEATHSAVES)) {
      if (WasGibbed) {
        int RealGibHealth = RealSelf.GibsHealth;
        if (!RealGibHealth) {
          RealGibHealth = int(float(-RealSelf.InitialHealth)*LineSpecialGameInfo(Level.Game).GibsHealthFactor);
        }
        if (RealSelf.Health >= RealGibHealth) {
          // if morphed was gibbed, so must original be (where allowed)
          RealSelf.Health = RealGibHealth -1;
        }
      }
      RealSelf.Died(source, inflictor);
    }
    return;
  }

  // notify actor's items
  for (Item = Inventory; Item;) {
    Inventory Next = Item.Inventory;
    Item.OwnerDied();
    Item = Next;
  }

  if (source) {
    // set Target to the thing that killed it
    // it's needed for Strife's special dropped items
    Target = source;
  }

  if (inflictor && inflictor.bNoExtremeDeath) {
    // prevent gibing animation
    Health = -1;
  }

  if (source && source.bIsPlayer && PlayerEx(source.Player).IsWeaponAlwaysExtremeDeath()) {
    // always extreme death
    Health = -5000;
  }

  if (bIsPlayer && Level.bDeathSlideShow) {
    // start sad finale
    PlayerEx(Player).StartDeathSlideShow();
  }

  bShootable = false;
  bFloat = false;
  bSkullFly = false;
  if (!bNoGravKill) bNoGravity = false;
  bDropOff = true;
  // gozzo does it like this:
  //   only mosters and things with raise state can become corpses
  //   k8: not that i care even a little
  if (!bDontCorpse) {
    bCorpse = true;
    bPassMobj = false;
  }

  // [JM] Fire KILL type scripts for actor. Not needed for players, since they have the "DEATH" script type.
  //printdebug("DEAD: `%C`; bNoKillScripts=%B; bUseKillScripts=%B; bForceKillScripts=%B", self, bNoKillScripts, bUseKillScripts, Level.Game.bForceKillScripts);
  if (!bIsPlayer && !bNoKillScripts && (bUseKillScripts || Level.Game.bForceKillScripts)) {
    //printdebug("calling kill script for `%C`", self);
    XLevel.StartTypedACScripts(Level::SCRIPT_Kill, 0, 0, 0, Activator:self, Always:true, RunNow:true);
  }

  float NewHeight = 0.0;
  if (nameicmp(DamageType, 'Fire') == 0) NewHeight = BurnHeight;
  if (!NewHeight) NewHeight = DeathHeight;
       if (NewHeight < 0.0) Height = 0.0;
  else if (NewHeight) Height = NewHeight;
  else Height /= 4.0;

  if (Special && (!bSpecial || bMonster)) {
    // initiate monster death actions
    auto swd = SwitchableDecoration(self);
    if (!swd || !(swd.ActivationType&SwitchableDecoration::AF_NoDeathSpecial)) {
      Level.ExecuteActionSpecial(Special, Args[0], Args[1], Args[2], Args[3], Args[4],
                                 nullptr, 0, (Level.bActivateOwnSpecial ? self : source));
    }
  }
  if (CountsAsKill()) ++Level.CurrentKills;
  if (source && source.bIsPlayer) {
    if (CountsAsKill()) {
      // count for intermission
      ++source.Player.KillCount;
    }
    PlayerEx(source.Player).KilledActor(self);
  } else if (!Level.Game.netgame && CountsAsKill()) {
    // count all monster deaths, even those caused by other monsters
    ++Level.Game.Players[0].KillCount;
  }

  if (bIsPlayer) {
    // display obituary
    PlayerEx(Player).DisplayObituary(inflictor, source, DamageType);

    XLevel.StartTypedACScripts(Level::SCRIPT_Death, 0, 0, 0, self, true, false);

    ++PlayerEx(Player).Deaths;

    // count environment kills against you
    if (!source) --Player.Frags;

    PlayerEx(Player).Killed(source, inflictor);

    bSolid = false;
    bFly = false;
    Player.PlayerState = PST_DEAD;
    PlayerEx(Player).DropWeapon();
#ifdef FIXME
    if (Player == Level.Game.Players[consoleplayer] && automapactive) {
      // don't die in auto map, switch view prior to dying
      AM_Stop();
    }
#endif
  }

  state DeathState = none;
  if (DamageType) {
    // specialised death state for this damage type (ice, etc)
    DeathState = FindState('Death', DamageType, true);
    if (nameicmp(DamageType, 'Ice') == 0 && !bNoIceDeath && (bIsPlayer || bMonster)) {
      if (FindState('Death', 'Ice', true)) {
        DeathState = FindState('Death', 'Ice', true);
      } else {
        DeathState = FindState('GenericFreezeDeath');
      }
    }
  }
  if (!DeathState) {
    // don't pass damage type unless it's a massacre damage
    if (nameicmp(DamageType, 'Massacre') != 0) DamageType = '';

    // extreme death?
    if (Health < GHealth) {
      DeathState = FindState('Death', 'Extreme', true);
      if (DeathState) SpawnBloodSprayHead(damage:InitialHealth, notDead:false, spawnBloodPool:true);
    }
    // normal death?
    if (!DeathState) DeathState = FindState('Death');
  }

  if (DeathState) {
    SetState(DeathState);
    StateTime -= Random()*0.1;
    if (StateTime < 1.0/35.0) StateTime = 1.0/35.0;
  } else {
    //if (bIsPlayer) writeln("************ DESTROYING PLAYER!");
    Destroy();
  }
}


//==========================================================================
//
//  MorphedDeath
//
//==========================================================================
bool MorphedDeath (out EntityEx Morphed, out int MorphedStyle, out int MorphedHealth) {
  // May be a morphed player
  if (bIsPlayer && PlayerEx(Player).MorphTime &&
      (PlayerEx(Player).MorphStyle&MORPH_UNDOBYDEATH) &&
      PlayerEx(Player).MO)
  {
    int RealStyle = PlayerEx(Player).MorphStyle;
    int RealHealth = Health;
    if (PlayerEx(Player).UndoPlayerMorph(PlayerEx(Player).MorphStyle&MORPH_UNDOBYDEATHFORCED, PlayerEx(Player))) {
      Morphed = EntityEx(PlayerEx(Player).MO);
      MorphedStyle = RealStyle;
      MorphedHealth = RealHealth;
      return true;
    }
    return false;
  }

  return false;
}


//==========================================================================
//
//  PoisonPlayer
//
//  Sets up all data concerning poisoning
//
//==========================================================================
final void PoisonPlayer (EntityEx poisoner, int poison) {
  if ((PlayerEx(Player).Cheats&PlayerEx::CF_GODMODE) || bInvulnerable) return;
  PlayerEx(Player).PoisonCount += poison;
  PlayerEx(Player).Poisoner = poisoner;
  PlayerEx(Player).PoisonerPlayer = (poisoner ? PlayerEx(poisoner.Player) : none);
  if (PlayerEx(Player).PoisonCount > 100) PlayerEx(Player).PoisonCount = 100;
  PlayerEx(Player).LastPoisonTime = XLevel.Time;
}


//==========================================================================
//
//  PoisonDamage
//
//  Similar to Actor::Damage
//
//==========================================================================
final void PoisonDamage (EntityEx inflictor, EntityEx source, int damage, bool playPainSound) {
  if (Health <= 0) return;
  if (bInvulnerable && damage < 10000) return; // mobj is invulnerable

  bool isBuddha = false;
  if (bIsPlayer) {
    // take half damage in trainer mode
    damage = int(float(damage)*Level.World.GetDamageFactor());
    isBuddha = !!(PlayerEx(Player).Cheats&PlayerEx::CF_BUDDHA);
    if (!isBuddha && FindBuddhaPowerup()) isBuddha = true;

    if (damage < 1000 && ((PlayerEx(Player).Cheats&PlayerEx::CF_GODMODE) || bInvulnerable)) {
      return;
    }
    if (damage >= Player.Health && (Level.World.bSkillAutoUseHealth || Level.Game.deathmatch) &&
        !PlayerEx(Player).MorphTime)
    {
      // try to use some inventory health
      AutoUseHealth(damage-Player.Health+1);
    }
    Player.Health -= damage; // mirror mobj health here for Dave
    if (Player.Health < 0) Player.Health = 0;
    if (Player.Health < 1 && /*(PlayerEx(Player).Cheats&PlayerEx::CF_BUDDHA)*/isBuddha) Player.Health = 1;
    PlayerEx(Player).Attacker = source;
  }

  // do the damage
  Health -= damage;
  if (bIsPlayer && Health < 1 && /*(PlayerEx(Player).Cheats&PlayerEx::CF_BUDDHA)*/isBuddha) Health = 1;
  if (Health <= 0) {
    // death
    Special1 = damage;
    if (bIsPlayer && inflictor && !PlayerEx(Player).MorphTime) {
      // check for flame death
      if (nameicmp(inflictor.DamageType, 'Fire') == 0 && Health > -50 && damage > 25) {
        DamageType = 'Fire'; // for obituary
      } else {
        DamageType = inflictor.DamageType; // for obituary
      }
    }
    Died(source, inflictor);
    return;
  }

  if (!(XLevel.TicTime&63) && playPainSound) SetState(FindState('Pain'));
}
