//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2022 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************

//#define VV_DEBUG_USE_LINE


//==========================================================================
//
//  Destroyed
//
//==========================================================================
override void Destroyed () {
  if (Role == ROLE_Authority) {
    //printdebug("%C:%s: entity dying...", self, self.UniqueId);
    if (Inventory) {
      //printdebug("  ...removing inventory...");
      // remove inventory
      while (Inventory) Inventory.Destroy();
      //printdebug("%C:%s: entity dying, inventory removed...", self, self.UniqueId);
    }
    //printdebug("%C:%s: entity dead.", self, self.UniqueId);
  }
  ::Destroyed();
}


/*
final bool LineAttack (TVec dir, float distance, int LADamage,
                       class!EntityEx PuffType, optional bool NoAttackGhosts,
                       optional TVec *outHitPoint, optional name DmgType,
                       optional bool secondary, optional name decalType,
                       optional int pufftid, optional bool disableRandomZ,
                       optional out EntityEx hitEntity, optional out EntityEx puffEntity)
*/

//==========================================================================
//
//  PerformVanillaLineAttack
//
//==========================================================================
final void PerformVanillaLineAttack (TVec dir, float distance, int LADamage,
                                     class!EntityEx PuffType, optional name DmgType,
                                     optional bool secondary, optional name decalType,
                                     optional bool fromDecorate)
{
  class!EntityEx pjclass = none;

  int hstype = GetCvarI('gm_vanilla_hitscan_type');
  // bit0: monsters
  // bit1: player weapons
  // bit2: various DECORATE codepointers
       if (bIsPlayer) hstype &= 0x02;
  else if (fromDecorate) hstype &= 0x04;
  else hstype &= 0x01;
  if (hstype) {
    pjclass = class!EntityEx(K8HSHitscanTracer);
    if (pjclass) pjclass = class!EntityEx(GetClassReplacement(pjclass));
  }

  if (!pjclass) {
    LineAttack(dir, distance, LADamage, PuffType, DmgType:DmgType!optional, secondary:secondary!optional, decalType:decalType!optional);
  } else {
    EntityEx pj;

    // calculate projectile origin
    TVec org = Origin;
    if (!bIsPlayer) {
      float prchgt = fmax(0.0, GetCvarF('gm_vanilla_hitproj_prcheight'));
      org.z += Height*prchgt/100.0-FloorClip;
    } else {
      org.z += CalculateMissileAttackZOfs(pjclass);
    }

    // spawn projectile mobj
    pj = Spawn(pjclass, org);
    if (!pj) return;

    // setup various projectile properties
    pj.Target = self; // originator
    pj.DecalName = pj.default.DecalName;
    pj.CarryBloodTranslations(self);
    //pj.PlayMissileSpawnSound(self);
    // setup decal, damage, damage type, and puff
    if (specified_decalType) pj.DecalName = decalType;
    if (specified_DmgType) pj.DamageType = DmgType;
    if (PuffType) {
      class!EntityEx ovc = class!EntityEx(GetClassReplacement(PuffType));
      if (ovc) PuffType = ovc;
      pj.MissilePuffOverride = PuffType;
      //printdebug("%C: MissilePuffOverride=%C", self, pj.MissilePuffOverride);
    }
    pj.MissileDamageOverride = LADamage;
    // hitscan attacks are always like this
    pj.bDoHarmSpeciesMissile = true;
    pj.bDoHarmFriendsMissile = true;
    pj.bMissileHitscan = true; // just in case
    // it can't explode, so no need to check that
    //if (!pj.CheckMissileSpawn()) return;

    dir = dir.normalise; // just in case

    // setup speed
    // do not optimise this further, because cvar access is inlined
    float spd = (bIsPlayer ? GetCvarF('gm_vanilla_hitproj_speed_player') : GetCvarF('gm_vanilla_hitproj_speed_monster'));
    //printdebug("%C: bIsPlayer=%B; pj.Speed=%s; spd=%s (%s); dir=%s (len=%s) norm:%s", self, bIsPlayer, pj.Speed, spd, spd*35.0, dir, dir.length, dir.normalise);
    if (spd.isFinite && spd > 0.0) pj.Speed = spd*35.0;

    // setup angles and speed
    // we have exact direction in all cases
    VectorAngles(dir, out pj.Angles);
    pj.Velocity = pj.Speed*dir;
    //printdebug("%C: angles: yaw=%s; pitch=%s; roll=%s; vel=%s", self, pj.Angles.yaw, pj.Angles.pitch, pj.Angles.roll, pj.Velocity);
  }
}


//==========================================================================
//
//  FixLightPosition
//
//  adjusts z, so it won't be too near to floor or ceiling
//  adjusts light xy, so it won't be inside a wall
//
//==========================================================================
void FixLightPosition (sector_t *asector, ref TVec org, optional int thingidx) {
  // people loves to put lights into the floor/ceiling, and our tracer is not happy with those
  /*if (!asector)*/ asector = XLevel.PointInSectorRender(org);
  //float gaph = CeilingZ-FloorZ;
  float z = org.z;
  float fz = GetPlanePointZ(ref asector.floor, org);
  float cz = GetPlanePointZ(ref asector.ceiling, org);
  // closed sector?
  if (fz >= cz) {
    // for closed sectors, rise the light a little for the rare case the sector will be opened later
    if (z <= fz) {
      printdebug("fixed z floor position for `%C` thing #%s (%s -> %s : %s)", self, thingidx, z, fz+2, fz);
      org.z = fz+2;
    }
  } else {
    // opened sector, move away from floor/ceiling
    //printdebug("light thing #%s: fz=%s; cz=%s; z=%s; fdist=%s, cdist=%s", thingidx, fz, cz, org.z, org.z-fz, cz-org.z);
    if (z <= fz+4) {
      float res = (cz-fz <= 8 ? (cz+fz)/2 : fz+4);
      if (specified_thingidx) printdebug("fixed z floor position for `%C` thing #%s (%s -> %s : %s)", self, thingidx, z, res, fz);
      org.z = res;
    } else if (z >= cz-4) {
      float res = (cz-fz <= 8 ? (cz+fz)/2 : cz-4);
      if (specified_thingidx) printdebug("fixed z ceiling position for `%C` thing #%s (%s -> %s : %s)", self, thingidx, z, res, cz);
      org.z = res;
    }
  }

  // check if we're inside a wall
  TVec mdir = vector(0, 0, 0);
  foreach (line_t *ldef; asector.lines) {
    // ignore two-sided walls
    if (ldef->backsector && (ldef->flags&ML_TWOSIDED)) continue;
    // check distance
    //if (PointOnPlaneSide2(org, *ldef) != 2) continue;
    float pdist = DotProduct(org, ldef.normal)-ldef.dist;
    if (fabs(pdist) >= 1.0f) continue;
    mdir = (mdir+ldef.normal)/2;
    if (specified_thingidx) printdebug("sector #%d: line #%d: light #%d in the wall!", asector-&XLevel.Sectors[0], ldef-&XLevel.Lines[0], thingidx);
  }
  if (mdir) {
    if (specified_thingidx) printdebug("sector #%d: move light #%d out of the walls with %s!", asector-&XLevel.Sectors[0], thingidx, mdir);
    org += mdir*4;
  }
}


//==========================================================================
//
//  SetOrigin2
//
//  this is used in spawners, to fix initial Z
//  pass -666 to force proper check (sorry for this hack)
//
//==========================================================================
final void SetOrigin2 (TVec aorigin, optional int properFloorCheck, optional float moreHeight) {
  UnlinkFromWorld();
  bIntrJustMoved = false; // disable movement interpolation

  Origin = aorigin;

  if (properFloorCheck != -666) {
         if (bIsPlayer) properFloorCheck = true;
    else if (!specified_properFloorCheck && bMonster) properFloorCheck = true;

    if (properFloorCheck) {
      if (aorigin.z == ONFLOORZ || aorigin.z == ONCEILINGZ) {
        properFloorCheck = false;
      }
    }
  }

  // set subsector and/or block links
  // use `CheckRelPosition()` here, we don't need to relink ourselves
  tmtrace_t tmtrace;
  GetFloorAndCeilingEx(out tmtrace, aorigin, collideWorld:false);
  float flrz = tmtrace.FloorZ;
  float ceilz = tmtrace.CeilingZ;

  //auto oldz = Origin.z;

       if (aorigin.z == ONFLOORZ) Origin.z = flrz+moreHeight;
  else if (aorigin.z == ONCEILINGZ) Origin.z = ceilz-Height-moreHeight;
  else if (aorigin.z == FLOATRANDZ) {
    float space = ceilz-Height-flrz;
    if (space > 48.0) {
      space -= 40.0;
      Origin.z = space*Random()+flrz+40.0;
    } else {
      Origin.z = flrz;
    }
  } else if (bFloatBob) {
    Origin.z = flrz+Origin.z; // artifact z passed in as height
  }

  LinkToWorld(properFloorCheck:properFloorCheck);

  // don't fix positions for manual lights
  if ((self !isa 'BaseStaticLightSource') &&
      (self !isa 'DynamicLight'))
  {
    // if we are way higher than a floor, check for 3d floors.
    // this (coincidentally) also checks if a thing fits into a gap for
    // newly spawned entities. i hope it won't break anything.
    // solid non-monsters are decorations (usually); normalize their gap without world checking
    if (!properFloorCheck && Radius > 4 && // arbitrary limit
        !bNoInteraction && !bNoBlockmap && !bNoSector &&
        Origin.z-FloorZ > 0)
    {
      GetFloorAndCeilingEx(out tmtrace, Origin, collideWorld:(bMonster || bIsPlayer || !bSolid));
      if (FloorZ < tmtrace.FloorZ && tmtrace.FloorZ <= Origin.z) {
        #ifdef K8_DEVELOPER
        // `moreHeight` specified only for map things
        if (specified_moreHeight) {
          print("FIXED z for `%C`: z=%s; flrz=%s; FloorZ=%s; newFloorZ=%s; Radius=%s", self, Origin.z, flrz, FloorZ, tmtrace.FloorZ, Radius);
        }
        #endif
        EFloor = tmtrace.EFloor;
        ECeiling = tmtrace.ECeiling;
        FloorZ = tmtrace.FloorZ;
        CeilingZ = tmtrace.CeilingZ;
        DropOffZ = tmtrace.DropOffZ;
      }
    }
  }

  VTerrainInfo *TInfo = GetActorTerrain();
  if (bFloorClip && TInfo->bLiquid && Origin.z == FloorZ) {
    FloorClip = TInfo->FootClip;
  } else {
    FloorClip = 0.0;
  }
}


//**************************************************************************
//
//  RADIUS ATTACK
//
//**************************************************************************

//==========================================================================
//
//  RadiusAttack
//
//  Source is the creature that caused the explosion at spot.
//
//  returns number of actors hurted
//
//==========================================================================
final int RadiusAttack (EntityEx Source, int BombDamage, float BombDistance,
                        bool DamageSource, optional name BombDmgType, optional bool DoDamage,
                        optional int damagedistance, optional bool thrustZ,
                        optional float fullthrustdistance, optional bool NoImpactDamage,
                        optional name onlyThisSpecie)
{
  EntityEx Other;

  if (!Level.Game.IsAuthority) return 0;

  if (!specified_thrustZ) thrustZ = DoDamage; //k8: see below
  if (!specified_DoDamage) DoDamage = true;

  if (onlyThisSpecie && nameEquCI(onlyThisSpecie, 'None')) onlyThisSpecie = '';

  EntityEx SpecieSrc = (Source ? Source : self);

  #if 0
  printdebug("%C: RadiusAttack: Source=%C; BombDamage=%s; BombDistance=%s; DamageSource=%B"~
             "; BombDmgType=%s; DoDamage=%B; damagedistance=%s; thrustZ=%B"~
             "; fullthrustdistance=%s; NoImpactDamage=%B; onlyThisSpecie=%s",
             self, Source, BombDamage, BombDistance, DamageSource,
             BombDmgType, DoDamage, damagedistance, thrustZ,
             fullthrustdistance, NoImpactDamage, onlyThisSpecie);
  #endif

  int count = 0;

  foreach RadiusThings(Other, Origin, BombDistance) {
    // vulnerable actors can be damaged by radius attacks even if not shootable
    // used to emulate MBF's vulnerability of non-missile bouncers to explosions
    if (!Other || !(Other.bShootable || Other.bVulnerable)) continue;

    // check for actors that take no damage from concussion
    if (Other.bNoRadiusDamage && !bForceRadiusDmg) continue;

    //printdebug("%C:000: Other=%C", self, Other);
    if (!DamageSource && (Other == Source || Other == self)) continue; // don't damage the source of the explosion

    //printdebug("%C:001: Other=%C", self, Other);
    if (specified_onlyThisSpecie && !nameEquCI(onlyThisSpecie, Other.GetSpecies())) continue;

    //printdebug("%C:002: Other=%C", self, Other);
    // option for monsters that fire explosive projectiles not to hurt
    // monsters of the same class with it's projectiles.
    // controlled by the bDontHurtClass and bDontHurtSpecies flags.
    // check for `Source != Other` is here because if `DamageSource` is set, species should be ignored
    #if 0
    old code
      if (Source && !Other.bIsPlayer &&
          ((Source.bDontHurtClass && Other.Class == Source.Class) ||
           (Source.bDontHurtSpecies && IsSameSpecies(Other, Source))))
      {
        continue;
      }
    #else
    if (!Other.bIsPlayer) {
      if (Source && Source != Other &&
          ((Source.bDontHurtClass && Other.Class == Source.Class) ||
           (Source.bDontHurtSpecies && IsSameSpecies(Other, Source))))
      {
        if (!Other.bDoHarmSpecies && !Other.bDoHarmFriends &&
            !bDoHarmSpeciesMissile && !bDoHarmFriendsMissile)
        {
          continue;
        }
      }
    } else {
      // shitfuck for clusterfuck
      //if (SpecieSrc) printdebug("%C(%s): Other=%C(%s); SpecieSrc=%C(%s); DmgType=%s", self, GetSpecies(), Other, Other.GetSpecies(), SpecieSrc, SpecieSrc.GetSpecies(), BombDmgType);
      if (SpecieSrc && Source != Other &&
          ((SpecieSrc.bDontHurtClass && Other.Class == self.Class) ||
           (Other.Species && SpecieSrc.bDontHurtSpecies && SpecieSrc.Species && IsSameSpecies(Other, SpecieSrc))))
      {
        //printdebug("%C:003: Other=%C", self, Other);
        if (!Other.bDoHarmSpecies && !Other.bDoHarmFriends &&
            !bDoHarmSpeciesMissile && !bDoHarmFriendsMissile)
        {
          continue;
        }
      }
    }
    #endif
    //printdebug("%C: RadiusAttack; DamageSource=%s; Source=%C; Other=%C", self, DamageSource, Source, Other);

    float dist =
      !bOldRadiusDamage ?
      fmax(0.0, Length(Other.GetCenter()-GetCenter())-Other.Radius): // 3d
      fmax(0.0, Length2D(Other.GetCenter()-GetCenter())-Other.Radius); // 2d
    //print("000: %C: dist=%s; BombDistance=%s", self, dist, BombDistance);

    if (dist >= BombDistance && int(dist) > int(BombDistance)) continue; // out of range

    if (Other.CanSeeAdv(self)) {
      float dist2;

      // OK to damage, target is in direct path
      if (!specified_damagedistance) {
        dist2 = dist;
      } else {
        dist2 = fclamp(dist-float(damagedistance), 0.0, dist);
      }

      // k8: zero damage should still push a player to make mikoveyors work
      //     actually, it deals 1 damage in vanilla, but meh, i won't bother emulating it
      float dmgfloat = ((float(BombDamage)*Other.RDFactor*(BombDistance-dist2))/BombDistance);
      int damage = int(dmgfloat);
      //print("%C: 000: %C: damage=%s; BombDamage=%s; RDFactor=%s (%s); BombDistance=%s; flt=%s", self, Other, damage, BombDamage, RDFactor, Other.RDFactor, BombDistance, dmgfloat);
      if (damage < 0) damage = 0;
      //if (damage <= 0) continue;

      if (DoDamage) {
        if (damage) {
          int dmg = Other.Damage(self, Source, damage, BombDmgType); // !0: done or absorbed
          //print("%C: got RadiusAttack from `%C`, damage=%s; dmg=%s; type=%s", self, Source, damage, dmg, BombDmgType);
          if (damage > 1 && dmg) Other.SpawnBloodAtHeadExplosion(damage, Source);
          if (damage > 0 && dmg > 0) ++count;
        }
      } else {
        // dunno, GZDoom does it like this
        if (!Other.bIsPlayer && !NoImpactDamage && !Other.bDontThrust) Other.bBlasted = true;
        //if (!bDontThrust) Other.bBlasted = true; //k8: old code
      }

      if (!bDontThrust && !Other.bIceCorpse && (!DoDamage || !bNoDamageThrust)) {
        float Thrust = dmgfloat*0.5;
        if (specified_fullthrustdistance && fullthrustdistance != 0 && dist <= fullthrustdistance) {
          Thrust = BombDamage*Other.RDFactor*0.5;
        }
        //k8: this is purely experimental, and prolly not right at all
        //    but with `10` it is more-or-less of the vanilla speed
        Thrust = fmax(/*(Other.bIsPlayer ? 10 : 0.0)*/10, Thrust);
        float VelZ = ((Other.Origin.z+(Other.Height*0.5))-Origin.z)*Thrust;
        if (Source != Other) VelZ *= 0.5; else VelZ *= 0.8;
        TVec Dir = Other.Origin-Origin;
        Dir.z = 0.0;
        if (Length2D(Dir) < 0.001) {
          // zero length. In this case Doom would use angle 0
          Dir = vector(1.0, 0.0, 0.0);
        }
        float othermass = fmax(1, Other.Mass);
        if (othermass < 10000) {
          TVec Vel = Normalise(Dir)*Thrust;
          Other.Velocity.x += (Vel.x/othermass)*35.0;
          Other.Velocity.y += (Vel.y/othermass)*35.0;
          if (thrustZ) Other.Velocity.z += (VelZ/othermass)*35.0;
          Other.Velocity = vclampscale(Other.Velocity, MAXMOVE); // just in case
        }
        //old:if (DoDamage) Other.Velocity.z += (VelZ / Other.Mass) * 35.0;
      }
    }
  }

  return count;
}


//==========================================================================
//
//  CheckTeleportMove
//
//  `IgnoreObstacles` will ignore things we cannot telestomp
//
//==========================================================================
final bool CheckTeleportMove (TVec org, bool CheckOnly, optional bool ForceTelestomp, optional bool IgnoreObstacles) {
  EntityEx Other;
  float blockdist;

  // kill anything occupying the position
  // stomp on any things contacted
  foreach RadiusThings(Other, org, Radius) {
    if (!Other.bShootable) continue;

    blockdist = Other.Radius+Radius;

    if (fabs(Other.Origin.x-org.x) >= blockdist ||
        fabs(Other.Origin.y-org.y) >= blockdist)
    {
      // didn't hit it
      //print("TELEPORT CHECK: %C (%s) didin't touch %C (%s) (blockdist=%s; dist=%s)", self, self.Radius, Other, Other.Radius, blockdist, Other.Origin.xy-org.xy);
      continue;
    }

    // don't clip against self
    if (Other == self) continue;

    //print("TELEPORT CHECK: %C (%s) possibly touch %C (%s) (blockdist=%s; dist=%s)", self, self.Radius, Other, Other.Radius, blockdist, Other.Origin.xy-org.xy);
    // z-check
    if ((bPassMobj || Other.bActLikeBridge) && !Level.CompatNoPassOver &&
        (!bDontOverlap || !Other.bDontOverlap))
    {
      if (Other.Origin.z > org.z+Height) {
        //print("  *: otherz=%s; z=%s; z+h=%s", Other.Origin.z, org.z, org.z+Height);
        continue;
      }
      if (Other.Origin.z+Other.Height < org.z) {
        //print("  *: otherz=%s; z=%s; o+h=%s", Other.Origin.z, org.z, Other.Origin.z+Height);
        continue;
      }
    }

    //print("TELEPORT CHECK: %C (%s) really touch %C (%s)", self, self.Radius, Other, Other.Radius);
    // check if allowed to stomp things
    //k8: should we reject forced telefragging if `Other` denied it?
    if (!ForceTelestomp) {
      if ((!bTelestomp && !Level.bAllowMonsterTelefrags) || Other.bNoTeleFrag) {
        if (!IgnoreObstacles) return false;
        continue;
      }
    }

    if (!CheckOnly) {
      Other.SpawnBloodAtHeadExplosion(max(Other.Health, 10000), self);
      // telefrags kills even invincible things
      Other.Damage(self, self, max(Other.Health, 10000), 'Telefrag', forced:true/*, spawnBlood:true*/);
    }
  }

  return true;
}


//==========================================================================
//
//  TeleportMove
//
//  `IgnoreObstacles` will ignore things we cannot telestomp
//
//==========================================================================
final bool TeleportMove (TVec org, optional bool ForceTelestomp, optional bool ForceProperFloorCheck, optional bool IgnoreObstacles) {
  if (!CheckTeleportMove(org, CheckOnly:false, ForceTelestomp:ForceTelestomp, IgnoreObstacles:IgnoreObstacles)) return false;

  /+
  EntityEx Other;
  float blockdist;

  // kill anything occupying the position
  // stomp on any things contacted
  foreach RadiusThings(Other, org, Radius) {
    if (!Other.bShootable) continue;

    blockdist = Other.Radius+Radius;

    if (fabs(Other.Origin.x-org.x) >= blockdist ||
        fabs(Other.Origin.y-org.y) >= blockdist)
    {
      // didn't hit it
      //print("TELEPORT CHECK: %C (%s) didin't touch %C (%s) (blockdist=%s; dist=%s)", self, self.Radius, Other, Other.Radius, blockdist, Other.Origin.xy-org.xy);
      continue;
    }

    // don't clip against self
    if (Other == self) continue;

    //print("TELEPORT CHECK: %C (%s) possibly touch %C (%s) (blockdist=%s; dist=%s)", self, self.Radius, Other, Other.Radius, blockdist, Other.Origin.xy-org.xy);
    // z-check
    if ((bPassMobj || Other.bActLikeBridge) && !Level.CompatNoPassOver &&
        (!bDontOverlap || !Other.bDontOverlap))
    {
      if (Other.Origin.z > org.z+Height) {
        //print("  *: otherz=%s; z=%s; z+h=%s", Other.Origin.z, org.z, org.z+Height);
        continue;
      }
      if (Other.Origin.z+Other.Height < org.z) {
        //print("  *: otherz=%s; z=%s; o+h=%s", Other.Origin.z, org.z, Other.Origin.z+Height);
        continue;
      }
    }

    //print("TELEPORT CHECK: %C (%s) really touch %C (%s)", self, self.Radius, Other, Other.Radius);
    // check if allowed to stomp things
    //k8: should we reject forced telefragging if `Other` denied it?
    if (!ForceTelestomp) {
      if ((/*!ForceTelestomp &&*/ !bTelestomp && !Level.bAllowMonsterTelefrags) || Other.bNoTeleFrag) {
        if (!IgnoreObstacles) return false;
        continue;
      }
    }

    Other.SpawnBloodAtHeadExplosion(max(Other.Health, 10000), self);
    // telefrags kills even invincible things
    Other.Damage(self, self, max(Other.Health, 10000), 'Telefrag', forced:true/*, spawnBlood:true*/);
  }
  +/

  // the move is ok,
  // so link the thing into its new position
  SetOrigin(org, properFloorCheck:(ForceProperFloorCheck ? -666 : 1)); //k8: really?
  if (org.z == ONFLOORZ) Origin.z = FloorZ;

  bIntrJustMoved = false; // disable movement interpolation
  return true;
}


//==========================================================================
//
//  Teleport
//
//  KeepDir also prevent velocity changes
//
//==========================================================================
final bool Teleport (TVec Dst, float angle, bool DstFog, bool SrcFog, bool KeepDir,
                     optional bool ForceTelestomp, optional bool KeepHeight)
{
  bool ResetPitch = !KeepDir;

  TVec oldOrg = Origin;

  float aboveFloor = Origin.z-FloorZ;
  // also, missiles always keep their relative height
  if (KeepHeight || Dst.z == ONFLOORZ || bMissile) {
    sector_t *DstSec = XLevel.PointInSector(Dst);
    float DstFloorZ = DstSec->floor.GetPointZClamped(Dst);
    float DstCeilZ = DstSec->floor.GetPointZClamped(Dst);
    if (bIsPlayer) {
      if ((KeepHeight || FindInventory(PowerFlight)) && aboveFloor) {
        Dst.z = DstFloorZ+aboveFloor;
        if (Dst.z+Height > DstCeilZ) Dst.z = fmax(DstFloorZ, DstCeilZ-Height);
      } else {
        Dst.z = DstFloorZ;
      }
    } else if (bMissile || KeepHeight) {
      Dst.z += aboveFloor;
      if (Dst.z+Height > DstCeilZ) Dst.z = fmax(DstFloorZ, DstCeilZ-Height);
    } else {
      Dst.z = DstFloorZ;
    }
  }

  if (!TeleportMove(Dst, ForceTelestomp!optional)) return false;

  if (bIsPlayer) {
    // crouch if we have autocrouch option, and cannot fit
    if (CeilingZ-FloorZ < Height && crouchfactor > 0.5 && PlayerPawn(self) && (PlayerPawn(self).bAutoCrouch || GetCvarB('player_force_autocrouch'))) {
      PlayerEx pex = PlayerEx(Player);
      // can we crouch at all?
      if (pex && pex.CanCrouch()) {
        float hgt = PlayerPawn(self).GetRealHeight();
        float rng = CeilingZ-FloorZ;
        if (rng < hgt && rng >= hgt*0.5) {
          // yep, can move if we'll crouch, so let's do it
          float newcrf = fclamp(rng/hgt, 0.5, 1.0);
          float savedheight = Height; //HACK! we'd better use `GetHeight()` here, but...
          Height = hgt*newcrf; // lowest possible crouch factor
          tmtrace_t tmtracetmp;
          bool oktomove = TryMoveEx(out tmtracetmp, Origin, AllowDropOff:true);
          Height = savedheight;
          if (oktomove) crouchfactor = newcrf; else Height = savedheight;
        }
      }
    }
    if (Player.MO == self) {
      Player.ViewOrg = Origin+vector(0.0, 0.0, PlayerEx(Player).ViewHeight);
      //auto pex = PlayerEx(Player);
      //if (pex) pex.lastViewOrgZForPfx = Origin.z;
      if (ResetPitch) Angles.pitch = 0.0;
    }
  }

  // spawn teleport fog at source and destination
  float fogDelta = (bMissile ? 0.0 : LineSpecialGameInfo(Level.Game).TeleFogHeight);
  if (SrcFog) Spawn(TeleportFog, oldOrg+vector(0.0, 0.0, fogDelta));
  if (DstFog) Spawn(TeleportFog, Origin+vector(20.0*cos(angle), 20.0*sin(angle), fogDelta));

  if (!KeepDir) {
    if (bIsPlayer && !FindInventory(PowerWeaponLevel2) && !FindInventory(PowerSpeed)) {
      // don't move for a bit, freeze player for about .5 sec
      ReactionTime = 0.5; // this is 18 ticks in vanilla, roughly 0.51428571428571 seconds
    }
    Angles.yaw = angle;
    if (bIsPlayer) Player.bFixAngle = true;
  }

  HandleFloorclip();

  if (!KeepDir) {
    if (bMissile) {
      float mspeed = Velocity.length2D();
      if (!mspeed.isFinite) mspeed = 0; // just in case
      float s, c;
      sincos(angle, out s, out c);
      Velocity.x = mspeed*c;
      Velocity.y = mspeed*s;
    } else {
      // no fog doesn't alter the player's momentums
      Velocity = vector(0.0, 0.0, 0.0);
    }
  }

  bIntrJustMoved = false; // disable movement interpolation
  return true;
}


//===========================================================================
//
//  MoveThing
//
//===========================================================================
override bool MoveThing (TVec Pos, bool Fog) {
  TVec OldOrg = Origin;

  UnlinkFromWorld();
  Origin = Pos;
  LinkToWorld(properFloorCheck:true); //k8: really?
  if (TestLocation()) {
    bIntrJustMoved = false; // disable movement interpolation
    if (Fog) {
      Spawn(TeleportFog, Pos+vector(0.0, 0.0, LineSpecialGameInfo(Level.Game).TeleFogHeight));
      Spawn(TeleportFog, OldOrg+vector(0.0, 0.0, LineSpecialGameInfo(Level.Game).TeleFogHeight));
    }
    return true;
  } else {
    UnlinkFromWorld();
    Origin = OldOrg;
    LinkToWorld(properFloorCheck:false);
    return false;
  }
}


//==========================================================================
//
//  TestLocation
//
//  Returns true if the mobj is not blocked by anything at its current
//  location, otherwise returns false.
//
//==========================================================================
final bool TestLocation () {
  if (!bColideWithThings && !bColideWithWorld) return true;
  if (CheckPosition(Origin)) {
    #if 0
    printdebug("%C: OK00; Sector=%s; org.z=%s; floorz=%s; height=%s (%s); ceilz=%s",
               self, Sector-&XLevel.Sectors[0],
               Origin.z, FloorZ, Height, Origin.z+Height, CeilingZ);
    #endif
    // XY is ok, now check Z
    #if 0
    if (Origin.z < FloorZ || Origin.z+Height > CeilingZ) {
      // bad Z
      return false;
    }
    #else
    //FIXME: use sector floor z instead of modified ones, otherwise some spawns may fail?
    //FIXME: for now, check step height
    if (Origin.z < FloorZ) {
      if (Origin.z < FloorZ-fmax(0.0f, MaxStepHeight-1.0f)) return false;
      if (Height > CeilingZ-FloorZ) return false;
    } else {
      if (Origin.z+Height > CeilingZ) return false;
    }
    #endif
    return true;
  }
  return false;
}


//==========================================================================
//
//  Thrust
//
//==========================================================================
final void Thrust (float angle, float move) {
  float s, c;
  sincos(angle, out s, out c);
  Velocity.x += move*c*35.0;
  Velocity.y += move*s*35.0;
  // just in case
  Velocity = vclampscale(Velocity, MAXMOVE);
}


//==========================================================================
//
//  FaceActor
//
//  returns 1 if 'source' needs to turn clockwise, or 0 if 'source' needs
//  to turn counter clockwise.
//  'delta' is set to the amount 'source' needs to turn.
//
//==========================================================================
int FaceActor (EntityEx atarget, out float delta) {
  float angle1 = Angles.yaw;
  float angle2 = atan2(atarget.Origin.y-Origin.y, atarget.Origin.x-Origin.x);
  if (angle2 > angle1) {
    float diff = AngleMod360(angle2-angle1);
    if (diff > 180.0) {
      delta = 360.0-diff;
      return 0;
    } else {
      delta = diff;
      return 1;
    }
  } else {
    float diff = AngleMod360(angle1-angle2);
    if (diff > 180.0) {
      delta = 360.0-diff;
      return 1;
    } else {
      delta = diff;
      return 0;
    }
  }
}


//==========================================================================
//
//  HeightClip
//  called from `SectorChanged()`
//
//  Takes a valid thing and adjusts the thing->FloorZ, thing->CeilingZ, and
//  possibly thing->z. This is called for all nearby monsters whenever a
//  sector changes height. If the thing doesn't fit, the z will be set to
//  the lowest value and false will be returned.
//
//==========================================================================
final bool HeightClip (optional bool skipTriggers, optional bool skipObjects) {
  tmtrace_t tmtrace;
  float OldZ = Origin.z;

  bool onfloor = (Origin.z == FloorZ);

  // fix interpolation coordinates on exit
  scope(exit) /*if (bIntrJustMoved)*/ LastMoveOrigin.z += Origin.z-OldZ; // it is harmless to fix it in any case

  // "no interaction" and "no blockmap" just moving
  if (bNoInteraction || bNoBlockmap) {
    //k8: always move?
    if (bMoveWithSector && !bNoSector) {
      // faster checking
      GetFloorAndCeiling(out tmtrace);
      // update position
      EFloor = tmtrace.EFloor;
      ECeiling = tmtrace.ECeiling;
      FloorZ = tmtrace.FloorZ;
      CeilingZ = tmtrace.CeilingZ;
      if (bStickToFloor || bStickToCeiling) {
        Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
      } else {
        if (onfloor) {
          if (bNoInteraction || !bNoGravity || Origin.z < FloorZ) {
            Origin.z = FloorZ;
          }
        } else {
          // don't adjust a floating thing unless forced to
          if (Origin.z+Height > CeilingZ) Origin.z = CeilingZ-Height;
        }
      }
    } else if (bStickToFloor || bStickToCeiling) {
      GetFloorAndCeiling(out tmtrace);
      Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
    }
    // never blocks
    return true;
  }

  // /*if (Sector->ownpobj)*/ printdebug("%C(%s) old: Floor=%s; Ceiling=%s; FloorZ=%s; CeilingZ=%s; z=%s; onfloor=%B", self, UniqueId, EFloor.splane, ECeiling.splane, FloorZ, CeilingZ, Origin.z, onfloor);

  /*bool isok =*/ CheckRelPosition(out tmtrace, Origin);//, debugDump:bIsPlayer);
  // what about stranding a monster partially off an edge?

  EFloor = tmtrace.EFloor;
  ECeiling = tmtrace.ECeiling;
  FloorZ = tmtrace.FloorZ;
  CeilingZ = tmtrace.CeilingZ;

  // /*if (Sector->ownpobj)*/ printdebug("%C(%s) new: Floor=%s; Ceiling=%s; FloorZ=%s; CeilingZ=%s; isok=%B; range=%s; height=%s; z=%s", self, UniqueId, EFloor.splane, ECeiling.splane, FloorZ, CeilingZ, isok, CeilingZ-FloorZ, Height, Origin.z);

  if (onfloor && (!bNoGravity || !bNoLiftDrop || bMoveWithSector)) {
    // walking monsters rise and fall with the floor
    if ((Origin.z-FloorZ < 9.0) || bNoGravity || !XLevel.bExtended) {
      EntityEx onmo = EntityEx(CheckOnmobj());
      // do we have something over us?
      if (bSolid && onmo && onmo.bSolid) {
        // adjust height for the thing over us
        onmo.Origin.z += FloorZ-Origin.z;
        // don't adjust a floating monster unless forced to
        if (onmo.Origin.z+onmo.Height > CeilingZ) {
          onmo.Origin.z = CeilingZ-onmo.Height;
        }
        if (CeilingZ-(FloorZ+Height) < onmo.Height) {
          // things don't fit, stop
          //printdebug("%C(%s): don't fit!", self, UniqueId);
          //if (bIsPlayer) printdebug("   DONTFIT (0)!");
          return false;
        }
      }
      //if (bIsPlayer) printdebug("   FIT (0)!");
      Origin.z = FloorZ;
    }
  } else {
    // don't adjust a floating monster unless forced to
    if (Origin.z+Height > CeilingZ) {
      Origin.z = CeilingZ-Height;
    }
  }

  if (!skipTriggers) {
    CheckFakeFloorTriggers(OldZ);

    if (CeilingZ-FloorZ < Height) {
      if (bIceCorpse && bSolid) {
        Actor(self).A_FreezeDeathChunks();
        return true;
      } else {
        // doesn't fit, stop
        //if (bIsPlayer) printdebug("   DONTFIT (1)!");
        //if (tmtrace.BlockingLine) printdebug("%C: don't fit! line=%s; fz=%s; cz=%s", self, tmtrace.BlockingLine-&XLevel.Lines[0], FloorZ, CeilingZ);
        //fixme: should non-solid objects block everything?
        return false;
      }
    }
  }

  if (bStickToFloor || bStickToCeiling) {
    Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
  }

  // move static light, if there is any
  if (/*bStaticLight &&*/ bStaticLightSpawned) {
    Level.MoveStaticLightByOwner(self, Origin+LightOffset);
  }

  // /*if (Sector->ownpobj)*/ printdebug("%C(%s) end: Floor=%s; Ceiling=%s; FloorZ=%s; CeilingZ=%s; isok=%B; range=%s; height=%s; z=%s", self, UniqueId, EFloor.splane, ECeiling.splane, FloorZ, CeilingZ, isok, CeilingZ-FloorZ, Height, Origin.z);

  return true;
}


//==========================================================================
//
//  MakeStateTimeFast
//
//==========================================================================
static final float MakeStateTimeFast (float AStateTime) {
  if (AStateTime > 0.0) {
    int fastprc = clamp(GetCvarI('gm_state_faster_percent'), 0, 100); // default is 50, 100 is "original"
    if (!fastprc) {
      // max speed: one tick
      AStateTime = fmin(AStateTime, 1.0/35.0);
    } else {
      // not lesser than one tic, tho
      AStateTime = fmax(AStateTime*cast(float)fastprc/100.0, 1.0/35.0);
    }
  }
  return AStateTime;
}


//==========================================================================
//
//  GetStateTime
//
//==========================================================================
override float GetStateTime (state AState, float AStateTime) {
  if (AState) {
    if (GetStateTicKind(AState) == StateTicKind.Random) {
      AStateTime = float(GetStateArgN(AState, 0)+trunci(Random()*(GetStateArgN(AState, 1)-GetStateArgN(AState, 0)+1)))/35.0f;
      //case StateTicKind.Normal: return AStateTime;
      //default: return AStateTime;
    }
    if (AStateTime > 0.0) {
      int fff;
      switch (Level.Game.fastparm) {
        case GameInfo::FastModeFast:
          if (IsFast()) {
            bool dochange = false;
                 if (bFaster && SeeState && StateIsInRange(AState, SeeState, none, 8)) dochange = true;
            else if (bFastMelee && MeleeState && StateIsInRange(AState, MeleeState, none, 3)) dochange = true;
            else {
              fff = GetStateSpriteFrame(AState);
              if (fff&FF_FAST) dochange = true;
            }
            if (dochange) {
              //printdebug("%C: prev state time: %s", self, AStateTime);
              AStateTime = MakeStateTimeFast(AStateTime);
              //printdebug("%C: new  state time: %s", self, AStateTime);
            }
          }
          break;
        case GameInfo::FastModeSlow:
          // slow monsters
          fff = GetStateSpriteFrame(AState);
          if (fff&FF_SLOW) AStateTime *= 2.0;
          break;
        case GameInfo::FastModeFastStates:
          // make only marked states faster
          fff = GetStateSpriteFrame(AState);
          if (fff&FF_SLOW) AStateTime = MakeStateTimeFast(AStateTime);
          break;
        case GameInfo::FastModeFastEveryState:
          // make all states faster
          if (bMonster) {
            //printdebug("%C: prev state time: %s (%s tics)", self, AStateTime, AStateTime/(1.0/35.0));
            AStateTime = MakeStateTimeFast(AStateTime);
            //printdebug("%C: new  state time: %s (%s tics)", self, AStateTime, AStateTime/(1.0/35.0));
          }
          break;
      }
    }
  }
  return AStateTime;
}


//==========================================================================
//
//  NightmareRespawn
//
//==========================================================================
final void NightmareRespawn () {
  float z;

  ++SkillRespawnCount;

  float x = SpawnPoint.x;
  float y = SpawnPoint.y;

  // somthing is occupying it's position?
  if (!CheckPosition(vector(x, y, ONFLOORZ))) return; // no respwan

  // spawn a teleport fog at old spot
  EntityEx A = SpawnEntityChecked(class!EntityEx, TeleportFog, vector(Origin.x, Origin.y, ONFLOORZ));
  if (A) {
    A.Origin.z += LineSpecialGameInfo(Level.Game).TeleFogHeight;

    // spawn a teleport fog at the new spot
    A = SpawnEntityChecked(class!EntityEx, TeleportFog, vector(x, y, ONFLOORZ));
    if (A) A.Origin.z += LineSpecialGameInfo(Level.Game).TeleFogHeight;

    // spawn the new monster

    // spawn it
    if (bSpawnCeiling) z = ONCEILINGZ; else z = ONFLOORZ;

    // inherit attributes from deceased one
    A = SpawnEntityChecked(class!EntityEx, class!EntityEx(Class), vector(x, y, z), default, default, AllowReplace:false);
    if (A) {
      Level.CopyMThing(&SpawnPoint, &A.SpawnPoint);
      A.Angles.yaw = float(45*(SpawnPoint.angle/45));

      if (SpawnPoint.options&LineSpecialLevelInfo::MTF_AMBUSH) A.bAmbush = true;
      if (SpawnPoint.options&LineSpecialLevelInfo::MTF_STANDSTILL) A.bStanding = true;

      A.ReactionCount = 18;

      // copy custom translation
      //A.Translation = Translation;
      A.CopyTranslations(self);

      A.SkillRespawnCount = SkillRespawnCount;
    }
  }

  // remove the old monster
  Destroy();
}


//==========================================================================
//
//  CheckRipLevel
//
//  `self` is ripping projectile
//
//==========================================================================
final bool CheckRipLevel (EntityEx Other) {
  if (Other.RipLevelMin > 0 && RipperLevel < Other.RipLevelMin) return false;
  if (Other.RipLevelMax > 0 && RipperLevel > Other.RipLevelMax) return false;
  return true;
}


//==========================================================================
//
//  ProcessHitFlags
//
//  returns `false` if hit something
//
//==========================================================================
final bool ProcessHitFlags (EntityEx Other, bool res, bool disableEffects) {
  if (res || disableEffects) return res; // `true` means "continue, no hit"
  if (!Other || Other == self || !bMissile) return res; //k8: only for missiles?
  if (bHitTarget) Target = Other;
  if (bHitMaster) Master = Other;
  if (bHitTracer) Tracer = Other;
  return res;
}


//==========================================================================
//
//  CheckDoBumpSpecial
//
//  returns `true` if activated
//
//==========================================================================
bool CheckDoBumpSpecial (EntityEx Other) {
  if (!Other || Other == self) return false; // can't
  // check for bBumpSpecial
  if (!bBumpSpecial) return false;
  // also, leave the bumper enough time to go away
  //print("%C: CheckDoBumpSpecial: 000: Other=%C", self, Other);
  //FIXME: broken with hubs!
  if (XLevel.Time <= NextBumpTime) return false;
  // by default, only players can activate things by bumping into them
  auto swd = SwitchableDecoration(self);
  if (!swd) return false;
  if (!Level.Game.IsAuthority) return false;
  // check if we can be hit
  if (!Other.bIsPlayer) {
    // check for switcable decorations
    if (((swd.ActivationType&SwitchableDecoration::AF_MonsterTrigger) && Other.bMonster) ||
        ((swd.ActivationType&SwitchableDecoration::AF_MissileTrigger) && Other.bMissile))
    {
      // ok
    } else {
      return false;
    }
  }
  // check for special action
  if (bUseSpecial && Special) {
    if (swd.ActivationType) printwarn("activation type for thing specials aren't implemented yet! %C:ActivationType=0x%08x", swd, swd.ActivationType);
    if (Level.ExecuteActionSpecial(swd.Special, swd.Args[0], swd.Args[1], swd.Args[2], swd.Args[3], swd.Args[4], nullptr, 0, self)) {
      if (swd.ActivationType&SwitchableDecoration::AF_ClearSpecial) { swd.Special = 0; foreach (ref auto v; swd.Args) v = 0; }
      NextBumpTime = XLevel.Time+1; // second
      return true;
    }
  }
  // do item action
  if (swd.ActivationType) {
    //print("UseThing001: SWD! self=%C; Other=%C", self, Other);
    if (swd.Activate(self)) {
      NextBumpTime = XLevel.Time+1; // second
      return true;
    }
  }
  // alas
  return false;
}


//==========================================================================
//
//  Touch
//
//  returns `false` if hit something
//
//==========================================================================
override bool Touch (Entity InOther, bool disableEffects) {
  bool solid;
  int damage;
  EntityEx Other = EntityEx(InOther);

  //if ((self isa 'DoomImpBall') && !Level.Game.IsAuthority) printdebug("%C:x00: ouid=%s; tuid=%s; muid=%s; truid=%s; org=%s; vel=%s; touchobj=%C (%s : %s); msl=%B", self, OwnerSUId, TargetSUId, MasterSUId, TracerSUId, Origin, Velocity, Other, Other.UniqueId, Other.ServerUId, bMissile);

  // ignore owner for client-side projectiles
  if (bMissile && !Level.Game.IsAuthority) {
    //printdebug("%C:x01: TargetSUId=%s; Other.ServerUId=%s", self, TargetSUId, Other.ServerUId);
    if (TargetSUId == Other.ServerUId) return true;
  }

  // hack for Zan
  // set +GHOST +NOTARGET (but *never* +PROJECTILE) and `DamageFactor "Normal", -667.0` to disable projectile blocking
  if (Other.isZanCloudHack()) {
    bool rep, sam;
    float dff = Other.FindDamageFactor(DamageType, 1.0, out rep, out sam, skipClamp:true);
    if (dff == -667.0) {
      //printdebug("%C: touched `%C`, activated Zan Hack", self, Other);
      return true;
    }
  }

  // for Korax Arena
  if (Other.IsTouched(self, disableEffects)) {
    return ProcessHitFlags(Other, !Other.bSolid && !Other.bSpecial && (!Other.bShootable || !Other.bTouchy) && !Other.bBlockedBySolidActors, disableEffects);
  }

  //k8: corpses won't block anything
  if (Other.bCorpse) return true;

  //k8: missile should hit shootable object even if it is non-solid
  if (bMissile) {
    if (!(Other.bSolid || Other.bShootable) && !Other.bSpecial && (!Other.bShootable || !Other.bTouchy) && !Other.bBlockedBySolidActors) return ProcessHitFlags(Other, true, disableEffects);
  } else {
    if (!Other.bSolid && !Other.bSpecial && (!Other.bShootable || !Other.bTouchy) && !Other.bBlockedBySolidActors) return ProcessHitFlags(Other, true, disableEffects);
  }

  if (bThruActors || Other.bThruActors) return ProcessHitFlags(Other, true, disableEffects);

  if (bThruSpecies && IsSameSpecies(Other, self)) return ProcessHitFlags(Other, true, disableEffects);

  // touchy object is alive, toucher is solid
  if (Other.bTouchy && bSolid && Other.Health > 0 &&
      // thing is an armed mine or a sentient thing
      (Other.bArmed || Other.IsSentient()) &&
      // either different classes or players
      (Other.bIsPlayer || Other.Class != Class) &&
      // or different species if DONTHARMSPECIES
      (!Other.bDontHurtSpecies || !IsSameSpecies(Other, self)) &&
      // touches vertically
      Other.Origin.z+Other.Height >= Origin.z && Origin.z+Height >= Other.Origin.z &&
      // prevents lost souls from exploding when fired by pain elementals
      (Other.Master != self && Master != Other))
  // difference with MBF: MBF hardcodes the LS/PE check and lets actors of the same species
  // but different classes trigger the touchiness, but that seems less straightforwards
  {
    if (!disableEffects) {
      bArmed = false; // Disarm
      if (Level.Game.IsAuthority) {
        Other.SpawnBloodAtHeadExplosion(Other.Health, self);
        Other.Damage(none, none, Other.Health); // kill object
      }
    }
    return ProcessHitFlags(Other, true, disableEffects);
  }

  if (!disableEffects) CheckDoBumpSpecial(Other);

  // check for skulls slamming into things
  if (bSkullFly) return ProcessHitFlags(Other, Slam(Other), disableEffects);

  // check for blasted thing running into another
  if (bBlasted && Other.bShootable) {
    if (!Other.bBoss && Other.bMonster) {
      if (!disableEffects && Level.Game.IsAuthority) {
        Other.Velocity.x += Velocity.x;
        Other.Velocity.y += Velocity.y;
        if ((Other.Velocity.x+Other.Velocity.y) > 3.0*35.0) {
          damage = (int(fmax(0, Mass))/100)+1;
          if (Other.Damage(self, self, damage)) Other.SpawnBloodAtHeadExplosion(damage, self);
          damage = (int(fmax(0, Other.Mass))/100)+1;
          if (Damage(Other, Other, damage>>2)) SpawnBloodAtHeadExplosion(damage>>2, Other);
        }
      }
      return ProcessHitFlags(Other, false, disableEffects);
    }
  }

  // missiles can hit other things
  if (bMissile) {
    // check for a non-shootable mobj
    if (Other.bNonShootable) return ProcessHitFlags(Other, true, disableEffects);
    // check for passing through a ghost
    if (Other.bGhost && bThruGhost) return ProcessHitFlags(Other, true, disableEffects);

    if (bMThruSpecies && Target && IsSameSpecies(Target, self)) return ProcessHitFlags(Other, true, disableEffects);

    if ((BounceType == BOUNCE_Doom || BounceType == BOUNCE_Hexen) && GetMissileDamage(0, 1) == 0) {
      // yet ripper rips, not bounces, even if it doesn't do any damage!
      if (Target != Other && Other.bSolid && !Other.bCorpse) {
        //ProcessHitFlags(Other, false, disableEffects);
        #if 1
        if (!bRip || Other.bDontRip || (bNoBossRip && Other.bBoss) || !CheckRipLevel(Other)) {
          // not a ripper, bounce unconditionally
          return ProcessHitFlags(Other, false, disableEffects);
        } else {
          // ripper
          if (!Other.bIsPlayer) {
            // not a player
            if (Other.bMonster) {
              // monster
              if (!Other.IsSentient()) return ProcessHitFlags(Other, false, disableEffects); /* non-sentient monster */
            } else if (!Other.bMissile) {
              // not a monster, not a missile
              // non-shootable, or invulnerable, or has no health?
              //printwarn("%C: not m/m: %C -- shootable=%B; invuln=%B; health=%s", self, Other, Other.bShootable, Other.bInvulnerable, Other.Health);
              if (!Other.bShootable || Other.bInvulnerable || Other.Health <= 0) return ProcessHitFlags(Other, false, disableEffects); // hit it!
            }
          }
        }
        #else
        // ripper missiles should be processed as normal ones
        if (!bRip || Other.bDontRip) return ProcessHitFlags(Other, (Target == Other || !Other.bSolid || Other.bCorpse), disableEffects);
        #endif
      }
    }

    switch (SpecialMissileHit(Other, disableEffects)) {
      case 0: return ProcessHitFlags(Other, false, disableEffects);
      case 1: return ProcessHitFlags(Other, true, disableEffects);
    }

    if (Target) {
      // don't hit the originator
      if (!bHitOwner && Other == Target) return ProcessHitFlags(Other, true, disableEffects); // don't missile self
      // let players missile other players
      if (!Target.bIsPlayer && !Other.bIsPlayer) {
        // both the originator and the victim aren't players
        int Inf = Target.GetInfighting();
        //if (self isa 'K8HSZombieTracer') printdebug("%C: hit from %C hit %C; Inf=%s", self, Target, Other, Inf);
        if (Inf < 0) {
          // monsters can't hurt each other, but make exception
          // depending on friendliness and hate status
          if (Target.bShootable) {
            if (!Other.bMonster) return ProcessHitFlags(Other, false, disableEffects);
            // hostile monsters can always hurt each other
            if (!Other.IsHostile(Target)) {
              // the same if the shooter hates the target
              if (!Other.TID || Target.TIDToHate != Other.TID) return ProcessHitFlags(Other, false, disableEffects);
            }
          }
        } else if (Inf == 0) {
          //printdebug("%C: TOUCH: from=%C; other=%C; inf=%d", self, Target, Other, Inf);
          // don't hurt friends
          if (!(Target.bDoHarmFriends || bDoHarmFriendsMissile) && Other.IsFriend(Target)) return ProcessHitFlags(Other, false, disableEffects);
          //printdebug("  not friends");
          // don't hurt monsters that hate the same thing as you do
          //FIXME: check `bDoHarmSpecies` flag here?
          if (Other.TIDToHate && Other.TIDToHate == Target.TIDToHate) {
            return ProcessHitFlags(Other, false, disableEffects);
          }
          //printdebug("  hates different things");
          //printdebug("  species: target is '%n', other is '%n' (bDoHarmSpecies=%B)", Target.GetSpecies(), Other.GetSpecies(), Target.bDoHarmSpecies);
          // check species only if inflictor is not allowed to hurt the same species with direct projectile damage
          if (!(Target.bDoHarmSpecies || bDoHarmSpeciesMissile) && IsSameSpecies(Target, Other)) {
            //printdebug("  same species");
            // don't hurt same species, but only if the target isn't one's hostile
            if (!Other.IsHostile(Target)) {
              //printdebug("  not hostile");
              // allow hurting monsters the shooter hates
              if (Other.TID == 0 || Target.TIDToHate != Other.TID) return ProcessHitFlags(Other, false, disableEffects);
            }
          }
          //printdebug("  pre-checks complete");
        }
      }
    }

    if (!Other.bShootable) return ProcessHitFlags(Other, !Other.bSolid, disableEffects); // didn't do any damage

    // don't hit spectres with non-sigil weapons
    if (Other.bSpectral && !bSpectral) return ProcessHitFlags(Other, true, disableEffects);

    if (bRip && !Other.bDontRip) {
      if (!disableEffects && Level.Game.IsAuthority) {
        if (CheckRipLevel(Other) && (!bNoBossRip || !Other.bBoss)) {
          damage = GetMissileDamage(3, 2);
          if (damage) {
            PlaySound('misc/ripslop', /*CHAN_BODY*/CHAN_AUTO);
            //printdebug("%C: ripper, other is %C", self, Other);
            int dmg = Other.Damage(self, Target, damage, DamageType, spawnBlood:false); // we already spawned ripper blood
            if (dmg && !Other.bNoBlood && !Other.bReflective && !Other.bInvulnerable) {
              // ok to spawn some blood
              Other.SpawnBloodRipper(damage, self);
            }
          }
          if (Other.bPushable && !bCannotPush) {
            // push thing
            Other.Velocity.x += Velocity.x/4.0;
            Other.Velocity.y += Velocity.y/4.0;
          }
        }
      }
      return ProcessHitFlags(Other, true, disableEffects);
    }

    // damage / explode
    if (!disableEffects && Level.Game.IsAuthority) {
      damage = GetMissileDamage((bStrifeDamage ? 3 : 7), 1);
      if (damage > 0 && ((bMissileHeadshotsAllowed || bMissileHitscan) || GetCvarB('k8HSAnyProjectile'))) {
        //printdebug("%C: missile with velocity %s hit `%C`", self, Velocity, Other);
        damage = Other.K8onBeforeDamage(self, Origin+vector(0, 0, Height*0.5)-Other.Origin, damage, DamageType, secondary:false);
      }
      if (damage > 0) {
        //printdebug("%C: Target=%C; Master=%C; Tracer=%C", self, Target, Master, Tracer);
        if (bBloodSplatter && !Other.bNoBlood && !Other.bReflective &&
            !Other.bInvulnerable && !Other.bDormant &&
            !bBloodlessImpact && P_Random() < 192)
        {
          TVec org = self.Origin;
          if (self.Radius > 0) org.z += self.Radius/2.0;
          Other.SpawnBloodSplatter(Origin, damage, org);
        }
        int dmg = Other.Damage(self, Target, damage, DamageType, spawnBlood:(bMissileHeadshotsAllowed || bMissileHitscan));
        if (dmg && !(bMissileHeadshotsAllowed || bMissileHitscan)) Other.SpawnBloodAtHeadExplosion(damage, self);
      }
    }
    // don't traverse any more
    return ProcessHitFlags(Other, false, disableEffects);
  }

  if (!disableEffects && Level.Game.IsAuthority) {
    if (Other.bPushable && !bCannotPush) {
      // push thing
      Other.Velocity.x += Velocity.x/4.0;
      Other.Velocity.y += Velocity.y/4.0;
    }

    solid = (Other.bSolid && Other.bColideWithThings && bSolid);

    // check for special pickup
    if (Other.bSpecial /*&& Other.Origin.z < Origin.z+Height-MaxStepHeight*/) {
      if (Other.bDehackedSpecial) {
        Other.TouchDehackedSpecial(self);
      } else {
        Other.TouchSpecial(self); // can remove thing
      }
      if (solid && (!Other || Other.IsDestroyed)) solid = false; // k8: it is no more
    }
  } else {
    solid = (Other.bSolid && Other.bColideWithThings && bSolid);
  }

  return ProcessHitFlags(Other, !solid, disableEffects);
}


//==========================================================================
//
//  IsTouched
//
//  For Korax Arena
//
//==========================================================================
bool IsTouched (Entity Toucher, bool disableEffects) {
  return false;
}


//===========================================================================
//
//  Slam
//
//===========================================================================
bool Slam (EntityEx Other) {
  bSkullFly = false;
  TVec orgVel = Velocity;
  Velocity = vector(0.0, 0.0, 0.0);
  if (Health > 0) {
    if (!bDormant) {
      int damage = GetMissileDamage(7, 1);
      int dmg = Other.Damage(self, self, damage, 'Melee');
      if (dmg) {
        // we only need it for blood direction, length doesn't matter
        Other.SpawnBloodAtHead(damage, Origin-orgVel);
      }
      SetState(SeeState ? SeeState : IdleState);
    } else {
      SetState(IdleState);
      StateTime = -1.0;
    }
  }
  return false; // stop moving
}


//==========================================================================
//
//  GetMissileDamageIntr
//
//  this can be overriden by decorate parser `Damage (expr)` property
//
//   ((random(0, 255)&Mask)+Add)*MissileDamage
//
//==========================================================================
int GetMissileDamageIntr (int Mask, int Add) {
  if (!MissileDamage) return 0;
  return ((Mask ? (P_Random()&Mask) : 0)+Add)*MissileDamage;
  //if (!Mask) return Add*MissileDamage;
  //return ((P_Random()&Mask)+Add)*MissileDamage;
}


//==========================================================================
//
//  GetMissileDamage
//
//==========================================================================
final int GetMissileDamage (int Mask, int Add) {
  if (MissileDamageOverride) return (MissileDamageOverride != int.min ? MissileDamageOverride : 0);
  // always use `MissileDamage`?
  if (!bForceUseMissileDamage) return GetMissileDamageIntr(Mask, Add);
  if (!MissileDamage) return 0;
  return ((Mask ? (P_Random()&Mask) : 0)+Add)*MissileDamage;
}


//==========================================================================
//
//  SpecialMissileHit
//
//==========================================================================
int SpecialMissileHit (EntityEx Other, bool disableEffects) {
  return -1;
}


//==========================================================================
//
//  GetSpecies
//
//==========================================================================
name GetSpecies () {
  if (Species) return Species;

  class Ret = Class;
  //  Go up in the inheritance hierarchy while there's a monster flag
  // and use the top one as species.
  if (bMonster) {
    while (class!EntityEx(GetClassParent(Ret)) &&
           class!EntityEx(GetClassParent(Ret)).default.bMonster)
    {
      Ret = GetClassParent(Ret);
    }
  }
  return (Ret ? GetClassName(Ret) : '');
}


//==========================================================================
//
//  IsSameSpecies
//
//==========================================================================
static final bool IsSameSpecies (EntityEx a, EntityEx b) {
  if (!a || !b) return false;
  if (a == b) return true;

  return (nameicmp(a.GetSpecies(), b.GetSpecies()) == 0);
}


//===========================================================================
//
//  CheckForPushSpecial
//
//===========================================================================
override void CheckForPushSpecial (line_t *line, int side) {
  if (!bNoTrigger && Level.Game.IsAuthority) {
    if (bActivatePushWall) {
      LineSpecialLevelInfo(Level).ActivateLine(line, self, side, SPAC_Push);
    } else if (bActivateImpact) {
      LineSpecialLevelInfo(Level).ActivateLine(line, (Level.bMissilesActivateImpact || !bMissile || !Target ? self : Target), side, SPAC_Impact);
    }
  }
}


//==========================================================================
//
//  BlastedHitLine
//
//==========================================================================
override void BlastedHitLine () {
  if (!Level.Game.IsAuthority) return;
  int damage = int(fmax(0, Mass))>>5;
  if (damage > 0) SpawnBloodAtHeadExplosion(damage);
  Damage(none, none, damage);
}


//==========================================================================
//
//  CrossSpecialLine
//
//==========================================================================
override void CrossSpecialLine (line_t *ld, int side) {
  if (!ld) return; //k8: just in case
  if (!Level.Game.IsAuthority) return;
  if (!bNoTrigger) {
    if (bIsPlayer) {
      LineSpecialLevelInfo(Level).ActivateLine(ld, self, side, SPAC_Cross);
    } else if (bActivateMCross) {
      LineSpecialLevelInfo(Level).ActivateLine(ld, self, side, SPAC_MCross);
    } else if (bActivatePCross) {
      LineSpecialLevelInfo(Level).ActivateLine(ld, self, side, SPAC_PCross);
    } else if (ld->special == LNSPEC_Teleport ||
               ld->special == LNSPEC_TeleportNoFog ||
               ld->special == LNSPEC_TeleportLine ||
               ld->special == LNSPEC_TeleportNoStop)
    {
      // teleport hack
      LineSpecialLevelInfo(Level).ActivateLine(ld, self, side, SPAC_MCross);
    } else {
      LineSpecialLevelInfo(Level).ActivateLine(ld, self, side, SPAC_AnyCross);
    }
  }
}


//==========================================================================
//
//  Activate
//
//==========================================================================
bool Activate (EntityEx Activator) {
  //print("*** ACTIVATING THING %C (tid=%s); bMonster=%B; bDormant=%B; Target=%C; Master=%C; Tracer=%C", self, TID, bMonster, bDormant, Target, Master, Tracer);
  if (!Level.Game.IsAuthority) return false;
  if (bMonster) {
    // Monster
    if (bDormant) {
      bDormant = false;
      StateTime = 0.1;
      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  Deactivate
//
//==========================================================================
bool Deactivate (EntityEx Activator) {
  if (!Level.Game.IsAuthority) return false;
  if (bMonster) {
    // Monster
    if (!bDormant) {
      bDormant = true;
      state S = FindState('Inactive');
      if (S) {
        SetState(S);
      } else {
        StateTime = -1.0;
      }
      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  FaceMovementDirection
//
//==========================================================================
final void FaceMovementDirection () {
  switch (MoveDir) {
    case DI_EAST: Angles.yaw = 0.0; break;
    case DI_NORTHEAST: Angles.yaw = 45.0; break;
    case DI_NORTH: Angles.yaw = 90.0; break;
    case DI_NORTHWEST: Angles.yaw = 135.0; break;
    case DI_WEST: Angles.yaw = 180.0; break;
    case DI_SOUTHWEST: Angles.yaw = 225.0; break;
    case DI_SOUTH: Angles.yaw = 270.0; break;
    case DI_SOUTHEAST: Angles.yaw = 315.0; break;
  }
}


//==========================================================================
//
//  OnDetachedFromServer
//
//  called from network code when detach is complete
//  don't do anything complex here!
//
//==========================================================================
override void OnDetachedFromServer () {
  if (Role == ROLE_Authority) {
    //printdebug("%C: OnDetachedFromServer!", self);
    state sss = FindState('NetDetachedOnClient');
    if (sss) {
      //printdebug("%C: switching state to detached", self);
      SetInitialState(sss);
    }
  } else if (Role == ROLE_SimulatedProxy) {
    //printdebug("%C: SIMULATED: OnDetachedFromServer! org=%s; vel=%s; ang=%s", self, Origin, Velocity, Angles);
  }
}


//==========================================================================
//
//  DetectStaticLightSpawn
//
//  things with one spawn frame, and one light will be converted
//  to static light sources.
//  this is what ObAddon does, for example.
//
//==========================================================================
void DetectStaticLightSpawn () {
  if (bStaticLight || TID || !State || !Sector) return;
  if (State.GetStateDuration != -1) return;
  if (bIsPlayer || /*bMonster ||*/ bInvisible /*|| bMissile*/) return;

#if 0
  if (/*bNoBlockmap || bNoInteraction ||*/ Radius <= 0 || Height <= 0 || (ScaleX == 0 && ScaleY == 0)) {
    // cannot interact with
    //if (!bNoGravity && !bNoBlockmap && !bNoInteraction) return;
  } else {
    name spn = State.GetStateSpriteName;
    if (spn && spn != 'tnt1') return;
  }
#endif

  GetStateEffects(FXLights, FXParticles);
  if (FXLights.length != 1 || FXParticles.length) return;
  auto lt = FXLights[0];
  if (lt.Radius <= 4) return;
  if ((lt.Type&DynamicLight::DLTYPE_TypeMask) != DynamicLight::DLTYPE_Point) return;
  // we need API to add "no shadow" static lights
  //if (lt.bNoShadow) return;
  // and we have it! ;-)
  if (lt.ConeAngle < 0) return;

  printdebug("%C: possible static light; scale=%s:%s; ltradius=%s; color=0x%08x; spr=<%s>; ofs=%s; conedir=%s; coneangle=%s", self, ScaleX, ScaleY, lt.Radius, lt.Color, State.GetStateSpriteName, lt.Offset, lt.ConeDir, lt.ConeAngle);

  bStaticLight = true;
  bStaticLightSpawned = true;

  LightOffset = lt.Offset;
  LightColor = lt.Color;
  LightRadius = lt.Radius;
  LightConeDir = lt.ConeDir;
  LightConeAngle = lt.ConeAngle;

  TVec lorg = Origin+lt.Offset;

  Entity ltowner = self;
  if (bNoInteraction || bNoBlockmap) {
    if (!bMoveWithSector && !bStickToFloor && !bStickToCeiling) {
      printdebug("%C:    removing object -- this is immovable static light", self);
      ltowner = none;
    }
  }

  if (!lt.ConeAngle || lt.ConeAngle >= 360 || !lt.ConeDir) {
    Level.AddStaticLightRGB(ltowner, lorg, lt.Radius, lt.Color, flags:lt.GetLightEffectLightFlags());
  } else {
    Level.AddStaticLightRGB(ltowner, lorg, lt.Radius, lt.Color, lt.ConeDir, lt.ConeAngle, flags:lt.GetLightEffectLightFlags());
  }

  if (!ltowner) Destroy();
}


//==========================================================================
//
//  OnMapSpawn
//
//==========================================================================
override void OnMapSpawn (mthing_t *mthing) {
  ::OnMapSpawn(mthing);

  /*
  #ifdef CLIENT
  if (Level.Game.IsDumbClient) printdebug("MAPSPAWN: %C (monster=%B; missile=%B) (%s)", self, bMonster, bMissile, GetClassLocationStr(Class));
  #endif
  */
  //printdebug("MAPSPAWN: %C (monster=%B; missile=%B) (%s)", self, bMonster, bMissile, GetClassLocationStr(Class));

  // k8: let's hope this will work as intended
  if (bMonster && IsFast()) ReactionCount = 0;

  LastLook = P_Random()%MAXPLAYERS;

  bCheckLineBlocking = false;
  bCheckLineBlockMonsters = false;
  if (!bNoInteraction && !bMissile) {
    bCheckLineBlocking = true;
    if (!bNoBlockMonst) bCheckLineBlockMonsters = true;
  }

  if (!IdleState) IdleState = FindState('Spawn');
  if (!SeeState) SeeState = FindState('See');
  if (!MeleeState) MeleeState = FindState('Melee');
  if (!MissileState) MissileState = FindState('Missile');

  if (Level.Game.fastparm == GameInfo::FastModeFast && FastSpeed > 0) Speed = FastSpeed;

  if (CountsAsKill()) ++Level.TotalKills;
  if (bCountItem) ++Level.TotalItems;

  // clamp some properties
  Mass = (Mass.isinf ? 10000 : fclamp(Mass, 0, 10000));
  Velocity = vclampscale(Velocity, MAXMOVE);
  Speed = (Speed.isfinite ? fclamp(Speed, -MAXMOVE, MAXMOVE) : 0.0);
  FloatSpeed = (FloatSpeed.isfinite ? fclamp(FloatSpeed, -MAXMOVE, MAXMOVE) : 0.0);

  // set the state, but do not use SetState, because action routines can't be called yet
  // if the spawnstate has an action routine, it will not be called
  if (Level.Game.IsNetServer) {
    state sss = none;
    if (Level.Game.IsListenServer) sss = FindState('SpawnInListenServer');
    if (!sss) sss = FindState('SpawnInNetServer');
    //if (sss) printdebug("%C:%s: spawn with netstate", self, UniqueId);
    SetInitialState(sss ? sss : IdleState);
  } else {
    SetInitialState(IdleState);
  }

  if (mthing) {
    if (bNoDeathmatch && Level.Game.deathmatch) {
      Destroy();
      return;
    }

    Level.CopyMThing(mthing, &SpawnPoint);

    float x = mthing->x;
    float y = mthing->y;
    float z;
         if (bSpawnCeiling) z = ONCEILINGZ;
    else if (bSpawnFloat) z = FLOATRANDZ;
    else if (bFloatBob) z = mthing->height;
    else z = ONFLOORZ;

    SetOrigin2(vector(x, y, z), moreHeight:mthing.height);
    //if (mthing.type == 9001 && mthing.tid == 1800) printwarn("*** MapSpot sector: %s; org=%s (%s:%s:%s) mh=%s", Sector-&XLevel.Sectors[0], Origin, x, y, z, mthing.height);
    //if (mthing.type == 9001 && mthing.tid == 55) printwarn("*** MapSpot sector: %s", Sector-&XLevel.Sectors[0]);
    //if (mthing-&XLevel.Things[0] == 114) printwarn("***id=%s: Sector=%s; height=%s; floorz=%s; radius=%s", UniqueId, Sector-&XLevel.Sectors[0], mthing->height, FloorZ, Radius);

    // no need to to this, it is already linked in `SetOrigin2()`
    //LinkToWorld(properFloorCheck:(bMonster || bIsPlayer));

    SetTID(mthing->tid);
    Special = mthing->special;
    if (!bArgsDefined) {
      foreach (int f; 0..5) Args[f] = mthing->args[f];
    }
    if (bFloatBob) {
      // seed random starting index for bobbing motion
      if (FloatBobPhase < 0) FloatBobPhase = Random()*256.0/35.0;
      //Special1f = mthing->height; // no need to do this, bobbing is done in renderer
    }
    if (!bSynchronised && StateTime > 0.0) StateTime = 0.1+Random()*StateTime;

    Angles.yaw = AngleMod360(float(AngleIncrements()*(mthing->angle/AngleIncrements())));
    if (mthing->bUsePitch) Angles.pitch = AngleMod360(mthing->pitch);
    if (mthing->bUseRoll) Angles.roll = AngleMod360(mthing->roll);

    if (mthing->bUseScaleX && mthing->scaleX > 0) ScaleX *= mthing->scaleX;
    if (mthing->bUseScaleY && mthing->scaleY > 0) ScaleY *= mthing->scaleY;

    if (mthing->bUseRenderStyle) RenderStyle = mthing->renderStyle;
    if (mthing->bUseRenderAlpha) Alpha = mthing->renderAlpha;
    if (mthing->bUseStencilColor) StencilColor = mthing->stencilColor|0xff_00_00_00;

    if (mthing->bUseGravity) {
      float gr = mthing->gravity;
      //printdebug("%C: thing #%d UDMF gravity is %s", self, mthing-&XLevel.Things[0], gr);
      Gravity = (gr < 0 ? -gr : Gravity*gr);
      //printdebug("%C: new thing gravity is %s", self, Gravity);
    }

    if (mthing->options&LineSpecialLevelInfo::MTF_AMBUSH) bAmbush = true;
    if (mthing->options&LineSpecialLevelInfo::MTF_STANDSTILL) bStanding = true;
    if (mthing->options&LineSpecialLevelInfo::MTF_DORMANT) Deactivate(none);
    if (mthing->options&LineSpecialLevelInfo::MTF_FRIENDLY) {
      bFriendly = true;
      // friendlies don't count as kills
      if (bCountKill) {
        bCountKill = false;
        --Level.TotalKills;
      }
    }
    if (mthing->options&LineSpecialLevelInfo::MTF_SHADOW) {
      bShadow = true;
      RenderStyle = STYLE_Translucent;
      Alpha = 0.25;
    } else if (mthing->options&LineSpecialLevelInfo::MTF_ALTSHADOW) {
      RenderStyle = STYLE_None;
    }
  } else {
    bool wasFloatBob = bFloatBob;
    //if (wasFloatBob) printdebug("%C:%s: FBOB! z=%s; nogravity=%B; special=%B", self, UniqueId, Origin.z, bNoGravity, bSpecial);
    bFloatBob = false; // so it won't be raised
         if (bSpawnCeiling) Origin.z = ONCEILINGZ;
    else if (bSpawnFloat) Origin.z = FLOATRANDZ;
    /*
    else if (bFloatBob) {
      tmtrace_t tmtrace;
      GetFloorAndCeiling(out tmtrace);
      printdebug("%C: FBOB! z=%s; floorz=%s; hgt=%s", self, Origin.z, tmtrace.FloorZ, Origin.z-tmtrace.FloorZ);
      Origin.z -= tmtrace.FloorZ;
    }
    */
    //else z = ONFLOORZ;
    SetOrigin2(Origin);
    bFloatBob = wasFloatBob;
  }

  if (mthing) DetectStaticLightSpawn();

  if (bStaticLight && mthing && !TID && !bStaticLightSpawned) {
    // fix for dehacked overrides that spawns the light inside the ceiling (for HacX)
    TVec lorg = Origin+LightOffset;
    if (bSpawnCeiling) {
      if (lorg.z > Sector.ceiling.minz-1) {
        lorg = Origin-LightOffset;
        if (lorg.z > Sector.ceiling.minz-1) {
          LightOffset.z = (Origin.z > Sector.ceiling.minz-1 ? Sector.ceiling.minz-Origin.z-1 : 0);
        } else {
          LightOffset.z = -LightOffset.z;
        }
      }
      lorg = Origin+LightOffset;
    }
    float rad = (mthing && mthing->args[0] ? float(mthing->args[0])*8.0 : LightRadius);
    if (LightConeDir && LightConeAngle > 0) {
       Level.AddStaticLightRGB(self, lorg, rad, LightColor, LightConeDir, LightConeAngle);
    } else {
       Level.AddStaticLightRGB(self, lorg, rad, LightColor);
    }
    /*
    if (LightColor == 0xffffffff) {
      Level.AddStaticLight(self, lorg, rad);
    } else {
      Level.AddStaticLightRGB(self, lorg, rad, LightColor);
    }
    */
    //printdebug("%C: spawned static light! org=%s (ofs=%s); ceiling=%s", self, lorg, LightOffset, Sector.ceiling.minz);
    //bSpawnCeiling
    bStaticLightSpawned = true;
  }

  //print("SPAWNED: %C (%B)", self, bSolid);
}


//==========================================================================
//
//  CanSeek
//
//  Checks if a seeker missile can home in on its target
//
//==========================================================================
bool CanSeek (EntityEx Targ) {
  if (Targ.bCantSeek) return false;
  if (bDontSeekInvisible && (Targ.bShadow || Targ.bGhost)) return false;
  return true;
}


//==========================================================================
//
//  SeekerMissile
//
//  the missile Tracer field must be Actor target
//  returns true if target was tracked, false if not
//
//==========================================================================
final bool SeekerMissile (float thresh, float turnMax, optional bool precise, optional bool curspeed) {
  float dist;
  float delta;
  float s, c;

  if (!Tracer) return false;
  if (!Tracer.bShootable) {
    // target died
    Tracer = none;
    return false;
  }

  int dir = FaceActor(Tracer, delta);
  if (delta > thresh) {
    delta /= 2.0;
    if (delta > turnMax) delta = turnMax;
  }
  if (dir) {
    // turn clockwise
    Angles.yaw = AngleMod360(Angles.yaw+delta);
  } else {
    // turn counter clockwise
    Angles.yaw = AngleMod360(Angles.yaw-delta);
  }

  float angle = Angles.yaw;

  //k8: is this right?
  if (!curspeed) {
    if (!precise) {
      sincos(angle, out s, out c);
      Velocity.x = Speed*c;
      Velocity.y = Speed*s;
      if (Origin.z+Height < Tracer.Origin.z ||
          Tracer.Origin.z+Tracer.Height < Origin.z)
      {
        // need to seek vertically
        dist = DistTo2(Tracer);
        dist = dist/Speed;
        if (dist < 1.0 || !dist.isfinite) dist = 1.0;
        Velocity.z = (Tracer.Origin.z+Tracer.Height/2.0-Origin.z-Height/2.0)/dist;
      }
    } else {
      // need to seek vertically
      TVec d = vector(Tracer.Origin.x-Origin.x, Tracer.Origin.y-Origin.y, 0.0);
      //dist = Length(d) > 1.0 ? Length(d) : 1.0;
      dist = fmax(1.0, Length(d));
      if (!dist.isfinite) dist = 1.0;

      // aim at a player's eyes and at the middle of the actor for everything else.
      float aimheight = Tracer.Height/2.0;
      if (Tracer.bIsPlayer) aimheight = PlayerEx(Tracer.Player).ViewHeight;
      float pitch = atan2((Tracer.Origin.z+aimheight)-(Origin.z+Height/2.0), fabs(dist));

      float ps, pc;
      sincos(angle, out s, out c);
      sincos(pitch, out ps, out pc);

      float xyscale = Speed*pc;
      Velocity.x = xyscale*c;
      Velocity.y = xyscale*s;
      Velocity.z = Speed*ps;
    }
  }

  return true;
}


//==========================================================================
//
//  PlayActiveSound
//
//==========================================================================
void PlayActiveSound () {
  if (ActiveSound) {
    PlaySound(ActiveSound, CHAN_VOICE, 1.0, (bFullVolActive ? ATTN_NONE : ATTN_NORMAL));
  }
}


//==========================================================================
//
//  eventDropItem
//
//  for ACS
//
//==========================================================================
override bool eventDropItem (name itemName, int amount, float chance) {
  if (!itemName) return false;
  class!EntityEx ee = class!EntityEx(FindClassNoCase(itemName));
  if (!ee) return false;
  DropItem(ee, amount, chance);
  return true;
}


//==========================================================================
//
//  ACSDropInventory
//
//==========================================================================
override bool ACSDropInventory (name itemName) {
  if (!itemName) return false;
  class!EntityEx ee = class!EntityEx(FindClassNoCase(itemName));
  if (!ee) return false;
  if (class!Inventory(ee)) {
    for (Inventory inv = Inventory; inv; inv = inv.Inventory) {
      if (inv.Class == ee) {
        DropInventory(inv, 1);
        return true;
      }
    }
  }
  return false;
}


//==========================================================================
//
//  DropItem
//
//==========================================================================
EntityEx DropItem (class!EntityEx type, int amount, float chance,
                   optional TVec dropofs, optional bool AllowReplace)
{
  if (Random() > chance) return none;

  float DropZ = 0.0;
  if (!Level.CompatNoTossDrops) DropZ = Height/2.0;
  if (!specified_dropofs) {
    dropofs = vector(0.0, 0.0, DropZ);
    // move it forward a little, to avoid z-fighting with a body
    TVec v = AngleYawVector(Angles.yaw);
    float fwd = 0.8+cast(float)((P_Random()&0x3f)/42.0);
    v *= fwd;
    //printdebug("offset: fwd=%s; v=%s", fwd, v);
    dropofs += v;
  }
  EntityEx A = SpawnEntityChecked(class!EntityEx, type, Origin+dropofs, AllowReplace:AllowReplace!optional);
  if (!A) return none;

  //A = Spawn(type, Origin + vector(0.0, 0.0, DropZ));
  if (A.bSpecial) A.bDropped = true; // special versions of items

  if (Inventory(A)) {
    Inventory Item = Inventory(A);
    if (amount > 0) {
      Item.Amount = amount;
    } else if (Ammo(Item)) {
      // half ammo when dropped by bad guys
      if (Ammo(Item).DropAmount) {
        Item.Amount = Ammo(Item).DropAmount;
      } else {
        Item.Amount = Item.Amount/2;
        if (Item.Amount < 1) Item.Amount = 1;
      }
    } else if (Weapon(Item)) {
      Weapon wpn = Weapon(Item);
      // the same from dropped weapons
      if (wpn.AmmoGive1 != 0) {
        wpn.AmmoGive1 = wpn.AmmoGive1/2;
        if (wpn.AmmoGive1 < 1) wpn.AmmoGive1 = 1;
      }
      if (wpn.AmmoGive2 != 0) {
        wpn.AmmoGive2 = wpn.AmmoGive2/2;
        if (wpn.AmmoGive2 < 1) wpn.AmmoGive2 = 1;
      }
    }
    if (Item.SpecialDropAction(self)) return none;
  }

  if (!Level.CompatNoTossDrops) {
    #if 0
    A.Velocity.x = (Random()-Random())*35.0;
    A.Velocity.y = (Random()-Random())*35.0;
    #else
    float speed = Random()*35.0;
    A.Velocity = AngleYawVector(Angles.yaw-55+110*Random());
    A.Velocity *= speed;
    //printdebug("%C: speed=%s; vel=%s", self, speed, A.Velocity);
    #endif
    A.Velocity.z = (5.0+Random()*4.0)*35.0;
  }

  return A;
}


//==========================================================================
//
//  NoBlockingSet
//
//==========================================================================
void NoBlockingSet () {
}


//==========================================================================
//
//  EntityPreTick
//
//  made `final` for speed
//
//==========================================================================
final void EntityPreTick (float deltaTime) {
  // reset fixed colormap for players; it will be assigned by powerup effect
  if (bIsPlayer && Player.MO == self) {
    Player.FixedColormap = 0;
    //Player.ExtraLight = 0; // nope, this could be changed by decorate actions
    Player.CShift = 0;
  }

  // handle powerup effects
  /*
  for (Inventory Item = Inventory; Item && Item.Owner == self; Item = Item.Inventory) {
    Item.DoEffect();
  }
  */

  for (Inventory Item = Inventory; Item; ) {
    Inventory invNext = Item.Inventory;
    if (Item.Owner == self) Item.DoEffect();
    Item = invNext;
  }

  if (bVisibilityPulse) {
    // pulse visibility in and out
    if (GetCvarB('fuck_stealth_monsters')) {
      Alpha = 1.0;
      VisDir = -1;
    } else {
      if (VisDir > 0) {
        Alpha += 0.75*deltaTime;
        if (Alpha > 1.0) {
          Alpha = 1.0;
          VisDir = -1;
        }
      } else {
        Alpha -= 0.75*deltaTime;
        if (Alpha <= 0.25) {
          Alpha = 0.25;
          VisDir = 1;
        }
      }
    }
  } else if (bStealth) {
    // fade a stealth monster in and out of visibility
    if (GetCvarB('fuck_stealth_monsters')) {
      Alpha = 1.0;
      VisDir = 0;
    } else if (VisDir > 0) {
      Alpha += 2.0*deltaTime;
      if (Alpha > 1.0) {
        Alpha = 1.0;
        VisDir = 0;
      }
    } else if (VisDir < 0) {
      Alpha -= 3.0*deltaTime/2.0;
      if (Alpha < 0.0) {
        Alpha = 0.0;
        VisDir = 0;
      }
    }
  }

  if (JumpTime) JumpTime = fmax(0, JumpTime-deltaTime);

  // floor decal damage
  if (!bIsPlayer && !bMonster) return;
  if (Health <= 0) return;
  if (bInvulnerable) return;
  if (LastFloorDecalDamageTic == Level.XLevel.TicTime) return;
  if (fabs(Origin.z-FloorZ) > 0.1) return;

  //printdebug("%C: checking floor decals damage... (%B)", self, bIsPlayer);
  LastFloorDecalDamageTic = Level.XLevel.TicTime;
  XLevel.CheckFloorDecalDamage(bIsPlayer, Origin, SubSector, delegate void (int damage, name damageType, int suitLeak) {
    //printdebug("%C: damage=%s; damageType=%s; suitLeak=%s; health=%s", self, damage, damageType, suitLeak, Health);
    // suit prevents damage for players (yes, even for Voodoo dolls)
    if (bIsPlayer && Player && PlayerEx(Player).IsProtectionSuitActive(suitLeak)) return;
    if (damageType) {
      Damage(none, none, damage, damageType);
    } else {
      Damage(none, none, damage);
    }
  });
}


//==========================================================================
//
//  EntityTickCheckRespawn
//
//  made `final` for speed
//
//==========================================================================
final void EntityTickCheckRespawn (float deltaTime) {
  // check for nightmare respawn
  if (!bAlwaysRespawn) {
    if (!bMonster || bDormant || bNeverRespawn) return;
    if (!LineSpecialGameInfo(Level.Game).RespawnTime) return;
    int respLimit = Level.World.GetRespawnLimit();
    if (respLimit > 0 && SkillRespawnCount >= respLimit) {
      return;
    }
  }

  // old code
  /*
  ++MoveCount;
  if (MoveCount < int(LineSpecialGameInfo(Level.Game).RespawnTime*35.0)) return;
  if (XLevel.TicTime&31) return;
  if (P_Random() > 4) return;
  */
  // new code
  //print("OMC=%s", MoveCount);
  if (MoveCount >= 0) MoveCount = -XLevel.TicTime;
  //print("MC=%s; tc=%s; delta=%s; rt=%s", MoveCount, XLevel.TicTime, XLevel.TicTime+MoveCount, int(LineSpecialGameInfo(Level.Game).RespawnTime));
  if (XLevel.TicTime+MoveCount < int(LineSpecialGameInfo(Level.Game).RespawnTime)) return;
  if (XLevel.TicTime&31) return;
  if (P_Random() > 4) return;
  MoveCount = 0;

  NightmareRespawn();
}


//==========================================================================
//
//  SimplifiedTick
//
//  called when entity doesn't need physics
//
//==========================================================================
override void SimplifiedTick (float deltaTime) {
  if (Level.bFrozen) {
    if (bIsPlayer) {
      if (!(PlayerEx(Player).Cheats&PlayerEx::CF_TIMEFREEZE)) return;
    } else {
      if (!bNoTimeFreeze) return;
    }
  }

  EntityPreTick(deltaTime);

  // state will be advanced by the normal ticker
  if (StateTime < 0.0) EntityTickCheckRespawn(deltaTime);
  /* this is done in C++ code
  else if (State) {
    if (StateTime-deltaTime <= 0) {
      TAVec lastAngles = Angles;
      TVec lastOrg = Origin;
      bIntrJustMoved = true; // teleports and force origin changes will reset it
      if (AdvanceState(deltaTime)) {
        // possibly moved, set new interpolation state
        // if mobj is not moved, the engine will take care of it
        LastMoveOrigin = lastOrg;
        LastMoveAngles = lastAngles;
        LastMoveTime = XLevel.Time;
        LastMoveDuration = StateTime;
      }
    } else {
      StateTime -= deltaTime;
    }
  }
  */
}


//==========================================================================
//
//  Tick
//
//==========================================================================
override void Tick (float deltaTime) {
  /*
  if (Level.bFrozen && ((!bIsPlayer && !bNoTimeFreeze) ||
      (bIsPlayer && !(PlayerEx(Player).Cheats&PlayerEx::CF_TIMEFREEZE))))
  {
    return;
  }
  */
  if (Level.bFrozen) {
    if (bIsPlayer) {
      if (!(PlayerEx(Player).Cheats&PlayerEx::CF_TIMEFREEZE)) return;
    } else {
      if (!bNoTimeFreeze) return;
    }
  }

  EntityPreTick(deltaTime);

  TVec lastOrg = Origin;
  bool lastInterp = bIntrJustMoved;
  float lmdur = XLevel.Time-LastMoveTime;
  if (lastInterp && (lmdur <= 0 || LastMoveDuration <= 0 || lmdur >= LastMoveDuration)) lastInterp = false;
  bIntrJustMoved = true; // teleports and force origin changes will reset it
  tmp_phys_z_change = 0;

  // physics is already interpolated
  if (!Physics(deltaTime)) return;

  // if not teleported, "just moved" flag is not reset
  if (bIntrJustMoved) {
    // if "just moved" flag was set, shift last origin by physics origin change
    if (lastInterp) {
      //if (!bIsPlayer && Origin-lastOrg) print("***DELTA %s (vel=%s)", Origin-lastOrg, Velocity);
      LastMoveOrigin += Origin-lastOrg;
      LastMoveOrigin.z -= tmp_phys_z_change;
    } else {
      if (fabs(tmp_phys_z_change) > 1) {
        bIntrJustMoved = true;
        LastMoveOrigin = Origin;
        LastMoveAngles = Angles;
        LastMoveTime = XLevel.Time;
        LastMoveDuration = 0.1; // arbitrary
        LastMoveOrigin.z -= tmp_phys_z_change;
      } else {
        bIntrJustMoved = false;
      }
    }
  } else {
    //print("%C: interpolation aborted by physics", self);
    lastInterp = false;
  }

  // cycle through states, calling action functions at transitions
  if (StateTime >= 0.0) {
    bool stateChange = (State && StateTime-deltaTime <= 0.0);
    TAVec lastAngles = Angles;
    lastOrg = Origin;
    bIntrJustMoved = true; // teleports and force origin changes will reset it
    if (!AdvanceState(deltaTime)) {
      // freed itself
      return;
    }
    // interpolation check
    if (stateChange && bIntrJustMoved) {
      /*
      if (lastInterp) {
        // this should not happen
        LastMoveDuration += StateTime;
      } else
      */
      {
        // possibly moved, set new interpolation state
        // if mobj is not moved, the engine will take care of it
        LastMoveOrigin = lastOrg;
        LastMoveAngles = lastAngles;
        LastMoveTime = XLevel.Time;
        LastMoveDuration = StateTime;
      }
    } else {
      bIntrJustMoved = lastInterp;
    }
  } else if (Level.Game.IsAuthority) {
    // endless state
    EntityTickCheckRespawn(deltaTime);
  }
}


//==========================================================================
//
//  GibEntity
//
//  crunch bodies to giblets
//  this entity may be destroyed (replaced with giblets)
//  returns `nullptr` on failure, or giblets (may return self)
//  this won't gib entities with `Health > 0`, and non-gibbing
//  note that returned entity may be already destroyed
//
//  `gibtype` is "Death" state suffix (may be '')
//
//==========================================================================
Entity GibEntity (name gibtype) {
  if (!bCorpse || bDontGib || Health > 0) return none;

  Entity res = self;
  bool CanDestroy = false;

  state stgibs = (gibtype ? FindClassState(Class, 'Death', gibtype, exact:true) : none);
  if (stgibs) {
    bDontGib = true;
    SetState(stgibs);
  } else if (!bNoBlood) {
    class c = FindClass('RealGibs');
    if (c) c = GetClassReplacement(c);
    if (c) {
      state spst = FindClassState(c, 'Spawn');
      if (!spst || !AreStateSpritesPresent(spst)) c = none;
    }

    if (c) {
      Actor Gib = SpawnEntityChecked(class!Actor, RealGibs);
      if (Gib) {
        Gib.RenderStyle = RenderStyle;
        Gib.Alpha = Alpha;
        Gib.Height = 0.0;
        Gib.Radius = 0.0;
        Gib.CopyTranslations(self);
        //k8: really?
        //if (BloodTranslation && !Gib.bDontTranslate) Gib.Translation = BloodTranslation;
        Gib.PlaySound('misc/fallingsplat', /*CHAN_BODY*/CHAN_AUTO);
        res = Gib;
        CanDestroy = true;
      } else {
        bDontGib = true;
      }
    } else {
      bDontGib = true;
    }
  }

  if (bIsPlayer) {
    bColideWithWorld = false;
    bColideWithThings = false;
    bDontGib = true;
    bInvisible = true;
  } else {
    if (CanDestroy) Destroy();
  }

  return res;
}


//==========================================================================
//
//  SectorChanged
//
//  CrushChange == -1: ignore stuck mobj
//
//  returns `false` if doesn't fit
//
//==========================================================================
override bool SectorChanged (int CrushChange, sector_t *sector) {
  // this is not used anymore
  assert(CrushChange != -666);
  /*
  if (CrushChange == -666) {
    // only fix positions for monsters (and don't touch corpses too)
    if (!bMonster && !bIsPlayer) return true;
    if (!bSolid || bCorpse) return true;
    return HeightClip(skipTriggers:true, skipObjects:true);
  }
  */

  //print("SectorChanged for %C", self);
  if (HeightClip()) return true; // it fits

  // if it stuck, and we should not ignore it...
  if (CrushChange == -1) return true; // get out!

  // crunch bodies to giblets
  if (GibEntity('SectorGibs')) return true;

  // crunch dropped items
  if (bDropped) {
    Destroy();
    return true;
  }

  // killough 11/98: kill touchy things immediately
  if (bTouchy && (bArmed || IsSentient())) {
    bArmed = false; // disarm
    SpawnBloodAtHeadExplosion(InitialHealth, none);
    Damage(none, none, InitialHealth); // kill object
    return true;
  }

  if (!bShootable) {
    // assume it is bloody gibs or something
    return true;
  }

  if (CrushChange > 0) {
    int tics = XLevel.TicTime;
    if (!(tics&3) && tics != lastCrushTicTime) {
      //printdebug("%C: CRUSH; damage=%s; tics=%s; last=%s; delta=%s; bltic=%s; bldelta=%s", self, CrushChange, tics, lastCrushTicTime, tics-lastCrushTicTime, lastCrushTicBloodTime, tics-lastCrushTicBloodTime);
      lastCrushTicTime = tics;
      bool allowBlood = (lastCrushTicBloodTime > tics || tics-lastCrushTicBloodTime > 4*6);
      if (allowBlood) lastCrushTicBloodTime = tics;
      bool oldNoBlood = bNoBlood;
      scope(exit) bNoBlood = oldNoBlood;
      if (!allowBlood) bNoBlood = true;
      Damage(none, none, CrushChange);
      if (!oldNoBlood && !allowBlood && Health <= 0) {
        bNoBlood = false;
        SpawnBloodAtHeadExplosion(CrushChange);
      }
      // spray blood in a random direction
      if (!bNoBlood && !bInvulnerable && BloodType && IsBloodAllowed()) {
        EntityEx A = SpawnEntityChecked(class!EntityEx, BloodType, Origin+vector(0.0, 0.0, Height/2.0));
        if (A) {
          A.SetBloodArgs(self, damage:CrushChange);
          A.Velocity.x = (Random()-Random())*16.0*35.0;
          A.Velocity.y = (Random()-Random())*16.0*35.0;
          //if (BloodTranslation && !A.bDontTranslate) A.Translation = BloodTranslation;
          A.CopyBloodTranslations(self, copyNormalTranslation:false);
        }
      }
      if (!bInvulnerable && CrushPainSound && !GetSoundPlayingInfo(self, GetSoundID(CrushPainSound))) {
        PlaySound(CrushPainSound, CHAN_VOICE);
      }
    }
  }

  return false; // don't fit
}


//==========================================================================
//
//  ClientTick
//
//  delta time can be zero for "interframe" ticks
//
//==========================================================================
override void ClientTick (float DeltaTime) {
  if (!DeltaTime) return;
  if (bInvisible || bNoSector) return;

  // if we're in closed door or something, skip effects
  if (CeilingZ <= FloorZ) return;

  // update bobbing
  if (bFloatBob) {
    if (FloatBobPhase < 0) FloatBobPhase = Random()*256.0/35.0;
    FloatBobPhase += DeltaTime;
  }

  // do not do any state effects if the object is too far away from the camera
  if (!CheckViewOrgDistance(Origin, GetDynLightMaxDist())) return;

  // do state effects, dynlight, and various particle trails
  DoStateEffects(DeltaTime);

  if (bDynamicLight && GetCvarI('r_sprlight_mode') <= 0) {
    // update dynamic lights
    dlight_t *dl = AllocDlight(self, Origin, radius:fmax(0, fmax(DLightPrevRadius, DLightRadius)));
    if (dl) {
      //dl->origin = Origin;
      dl->radius = (DLightPrevRadius <= DLightRadius ? DLightPrevRadius : (DLightPrevRadius-DLightRadius)*XLevel.Time);
      dl->radius += XLevel.Time*dl->decay;
      //if (dl->radius > DLightRadius) dl->radius = DLightRadius;
      dl->radius = fmin(dl->radius, DLightRadius);
      DLightPrevRadius = dl->radius;
      dl->color = DLightColor;
      dl->die = XLevel.Time+0.1;
    }
  }

  if ((bLeaveTrail || bLeaveTrail2) && GetCvarB('r_particle_trails')) {
    if (bLeaveTrail) {
      bool alt = false;
      float r = 0.0;
      int c = P_Random()>>1;
      if (P_Random() > 180) {
        r = Random()*8.0;
        alt = true;
      }
      LineSpecialLevelInfo(Level).ParticleEffect(int(DeltaTime*256.0),
        (alt ? LineSpecialLevelInfo::pt_explode : LineSpecialLevelInfo::pt_static), 0,
        Origin+vector(0.0, 0.0, fmax(0.0, Height)/2.0), 0.0, vector(16.0, 16.0, 64.0), 0.5, 2.5, 0.0,
        (alt ? RGB(255, 140, 0) : RGB(c, c, c)), 0.5, r);
    }

    if (bLeaveTrail2) {
      int c = P_Random()>>1;
      LineSpecialLevelInfo(Level).ParticleEffect(6,
          LineSpecialLevelInfo::pt_static, 0,
          vector(Origin.x-(cos(Angles.yaw)*Radius*2.0),
                 Origin.y-(sin(Angles.yaw)*Radius*2.0),
                 Origin.z-(float(int(Height)>>3*int(Velocity.z)>>16)+2.0*Height/3.0)),
          0.0, vector(32.0, 32.0, 32.0), 0.5, 10.0, 40.0, RGB(c, c, c), 0.6, 0.0);
    }
  }
}


//==========================================================================
//
//  DoStateEffects
//
//==========================================================================
final void DoStateEffects (float DeltaTime) {
  GetStateEffects(FXLights, FXParticles);

  // if we have a static light, check if there are no light effects for the current state
  if (bStaticLightSpawned && !FXLights.length) {
    // remove static light, and let dynamic lighting do the thing
    bStaticLightSpawned = false;
    Level.RemoveStaticLightByOwner(self);
  }

  if (!FXLights.length && !FXParticles.length) {
    PrevEffectState = State;
    return;
  }

  TVec Forward;
  TVec Right;
  TVec Up;

  AngleVectors(Angles, out Forward, out Right, out Up);

  if (!bStaticLightSpawned && FXLights.length && GetCvarI('r_sprlight_mode') <= 0) {
    //if (self isa 'ExplosiveBarrel') printdebug("%C: numdynlights=%s (static=%B)", self, FXLights.length, bStaticLightSpawned);
    //if (FXLights && (self isa 'HacxLongCeilingLamp')) printdebug("%C: l0ofs=%s; up=%s; org.z=%s; ceil=%s", self, FXLights[0].Offset, Up, Origin.z, Sector.ceiling.minz);
    // dynamic lights
    float LightTime;
    float max;
    // note that this is wrong, as entity can only have one dynlight attached
    //BeginEntityDlights(self); // this should forget all entity dlights, *AND* allow several dlights attached; noop for now
    //scope(exit) EndEntityDlights(self);
    // maybe it is better to allow any number of entity dlights, but reset all of them on new frame?
    // or give each dynlight an id, to allow replacing?
    // note that sprite effects can have several lights attached, and that can be changed with each new frame, so
    // i think that it will be better to use ids, and allow unreplaced lights to decay
    foreach (auto i; 0..FXLights.length) {
      LightEffectDef *L = FXLights[i];
      if (!L || L->bDisabled || L->bSubtractive) continue; // ignore disabled and invalid lights
      TVec lorg = Origin+Forward*L->Offset.x-Right*L->Offset.y+Up*L->Offset.z;
      // fix lights put into the floor or into the ceiling (why not?)
      if (/*!L->Offset.z &&*/ Sector) {
        float ffz1 = Sector.floor.GetPointZClamped(lorg);
        if (lorg.z <= ffz1) {
          // do not check ceiling here
          lorg.z = ffz1+4; // why not?
        } else {
          float fcz1 = Sector.ceiling.GetPointZClamped(lorg);
          if (lorg.z >= fcz1) lorg.z = fcz1-4; // why not?
        }
      }
      dlight_t *dl = AllocDlight(self, lorg, radius:fmax(0, fmax(DLightPrevRadius, L->Radius)), lightid:i); // pass "light id" to allow replacing
      if (!dl) continue; // alas
      //if (self isa 'HacxLongCeilingLamp') printdebug("%C: type=%s", self, L->Type);
      if (L->Type&DynamicLight::DLTYPE_Spot) {
        dl->coneDirection = L->ConeDir;
        dl->coneAngle = L->ConeAngle;
        //printdebug("%C: spotlight! dir=%s; angle=%s", self, L->ConeDir, L->ConeAngle);
      }
      //if (self isa 'ExplosiveBarrel') printdebug("%C:  dlight=%s; org=%s; lorg=%s; lrad=%s; type=%s", self, i, Origin, dl->origin, dl->radius, L->Type);
      //if (self isa 'HacxLongCeilingLamp') printdebug("%C:   lorg=%s; Origin=%s", self, dl->origin, Origin);
      //print("%C: rad: %s", self, dl->radius);
      //dl->origin = Origin + Forward * L->Offset.x - Right * L->Offset.y + Up * L->Offset.z;
      switch (L->Type&DynamicLight::DLTYPE_TypeMask) {
        case DynamicLight::DLTYPE_Point:
        //case DynamicLight::DLTYPE_Subtractive:
          //printdebug("%C: point light", self);
          dl->decay = /*XLevel.Time+*/300.0;
          dl->radius = (DLightPrevRadius <= L->Radius ? DLightPrevRadius : (DLightPrevRadius-L->Radius)*XLevel.Time);
          dl->radius += /*XLevel.Time**/dl->decay;
          //printdebug("000:%C: point light; radius=%s", self, dl->radius);
          if (dl->radius > L->Radius) dl->radius = L->Radius;
          //printdebug("001:%C: point light; radius=%s", self, dl->radius);
          dl->type = L->Type;
          break;
        case DynamicLight::DLTYPE_MuzzleFlash:
          max = (L->Radius+Random()*(L->Radius2-L->Radius));
          dl->decay = /*XLevel.Time+*/80.0;
          dl->radius = (DLightPrevRadius <= L->Radius ? DLightPrevRadius : (DLightPrevRadius-L->Radius)*XLevel.Time);
          dl->radius += /*XLevel.Time**/dl->decay;
          if (dl->radius > max) dl->radius = max;
          break;
        case DynamicLight::DLTYPE_Pulse:
          //printdebug("%C: pulse light; interval=%s; rad=(%s,%s)", self, L->Interval, L->Radius, L->Radius2);
          dl->decay = /*XLevel.Time+*/150.0;
          // avoid division by 0
          {
            float PulseCycle = (L->Interval > 0 ? L->Interval/35.0 : 1.0/35.0);
            LightTime += DeltaTime;
            if (LightTime >= PulseCycle) LightTime = 0.0;
            float Frac = (1.0+sin(360.0*LightTime/PulseCycle))*0.5;
            dl->radius = L->Radius+Frac*(L->Radius2-L->Radius);
          }
          //dl->radius *= 2.5;
          //dl->decay = 0;
          //L->Color = 0xff00ff00;
          //printdebug("000:%C: pulse light; radius=%s; LightTime=%s; PulseCycle=%s; Frac=%s", self, dl->radius, LightTime, PulseCycle, Frac);
          break;
        case DynamicLight::DLTYPE_Flicker:
          if (L->Chance < 0) {
            // from gldef
            //printdebug("%C: gldef flicker light; chance=%s (%s)", self, L->Chance, -(L->Chance+1.0));
            dl->decay = /*XLevel.Time+*/80.0;
            dl->radius = (FRandomFull() <= -(L->Chance+1.0) ? L->Radius2 : L->Radius);
            //printdebug("%C: gldef flicker light; chance=%s (%s); rad=%s", self, L->Chance, -(L->Chance+1.0), dl->radius);
          } else {
            // from entity
            dl->decay = /*XLevel.Time+*/80.0;
            dl->radius = (Random() >= L->Chance/360.0 ? L->Radius2 : L->Radius);
          }
          break;
        case DynamicLight::DLTYPE_FlickerRandom:
          LightTime += DeltaTime;
          if (LightTime > L->Interval/360.0) {
            max = (L->Radius+FRandomFull()*(L->Radius2-L->Radius));
            dl->decay = /*XLevel.Time+*/80.0;
            dl->radius = (DLightPrevRadius <= L->Radius ? DLightPrevRadius : /*(DLightPrevRadius-L->Radius)*XLevel.Time*/max);
            dl->radius += /*XLevel.Time**/dl->decay;
            if (dl->radius > max) dl->radius = max;
            LightTime = 0.0;
          }
          break;
        case DynamicLight::DLTYPE_Sector:
        //case DynamicLight::DLTYPE_SectorSubtractive:
          {
            float Scale = L->Scale*0.125;
            if (!Scale) Scale = 1.0;
            dl->radius = float(Sector->params.lightlevel)*Scale;
            if (dl->radius < 0.0) dl->radius = 0.0;
            if (dl->radius > 255.0) dl->radius = 255.0;
            //dl->type = (L->Type == DynamicLight::DLTYPE_Sector ? DynamicLight::DLTYPE_Point : DynamicLight::DLTYPE_Subtractive);
            dl->type = DynamicLight::DLTYPE_Point;
          }
          break;
      }
      dl->color = L->Color;
      dl->minlight = L->MinLight;
      // set light flags
      dl->bNoSelfShadow = L->bNoSelfShadow;
      dl->bNoShadow = L->bNoShadow;
      dl->bNoSelfLight = L->bNoSelfLight;
      dl->bNoActorLight = L->bNoActorLight;
      dl->bNoActorShadow = L->bNoActorShadow;
      dl->bNoGeoClip = L->bNoGeoClip;
      dl->bAdditive = L->bAdditive;
      //dl->bSubtractive = false; // L->bSubtractive; -- subtractive lights already rejected above
      //dl->bDisabled = false; //L->bDisabled; -- disabled lights already rejected above
      dl->die = XLevel.Time+0.1;
      DLightPrevRadius = dl->radius;
    }
  }

  if (State != PrevEffectState) {
    // particle effects
    if (FXParticles.length && GetCvarB('r_particle_effects')) {
      foreach (auto i; 0..FXParticles.length) {
        ParticleEffectDef *P = FXParticles[i];
        if (!P) continue;
        if (!Level) { print("WTF?! no level in particle effect!"); break; }
        Level.ParticleEffect(P->Count, P->Type, P->Type2,
          Origin+Forward*P->Offset.x-Right*P->Offset.y+Up*P->Offset.z,
          P->OrgRnd, P->Velocity, P->VelRnd,
          P->Accel, P->Grav, P->Color, P->Duration, P->Ramp);
      }
    }
    PrevEffectState = State;
  }
}


//==========================================================================
//
//  TouchDehackedSpecial
//
//==========================================================================
final void TouchDehackedSpecial (EntityEx Toucher) {
  if (!Toucher.bPickUp) return; // can't remove thing
  if (!Level.Game.IsAuthority) return;

  // dead thing touching
  // can happen with a sliding player corpse
  if (Toucher.Health <= 0) return;

  class!Inventory ItemType = LineSpecialLevelInfo(Level).GetDehackedItemType(self);
  if (!ItemType) return;

  Inventory Item = SpawnEntityChecked(class!Inventory, ItemType, default, default, default/*, false*/);
  if (!Item) return;

  Item.bDropped = bDropped;
  if (bDropped) {
    if (Ammo(Item)) {
      // half ammo when dropped by bad guys
      Item.Amount = Item.Amount/2;
      if (Item.Amount < 1) Item.Amount = 1;
    }
  }

  if (!Item.TryPickup(Toucher)) {
    Item.Destroy();
    return;
  }

  if (Special) {
    Level.ExecuteActionSpecial(Special, Args[0], Args[1], Args[2], Args[3], Args[4], nullptr, 0, Toucher);
    Special = 0;
  }
  if (bCountItem) {
    ++Toucher.Player.ItemCount;
    ++Level.CurrentItems;
  }

  Toucher.Player.cprint("%s", Item.GetPickupMessage());
  Toucher.PlaySound(Item.PickupSound, CHAN_ITEM);

  if (bDropped) {
    Destroy();
  } else if (!Item.ShouldStay()) {
    if (Item.ShouldRespawn()) {
      bInvisible = true;
      bSpecial = false;
      SetState(FindState('DehackedDormantPickup'));
    } else {
      Destroy();
    }
  }
  PlayerEx(Toucher.Player).BonusFlash += Inventory::BONUSADD;
  // destroy item if it wasn't added to the toucher's inventory
  if (!Item.Owner) Item.Destroy();
}


//==========================================================================
//
//  GiveBody
//
//  Returns false if the body isn't needed at all
//
//==========================================================================
final bool GiveBody (int num, optional bool asHealthBonus/*=false*/) {
  int max;

  if (bIsPlayer) {
    max = PlayerEx(Player).GetMaxHealth();
    if (asHealthBonus && num >= 0) max = min(200, max*2);
    if (num < 0) {
      // for Strife negative body sets you to the percentage of your full health
      num = max*(-num)/100;
      if (Player.Health < num) {
        Player.Health = num;
        Health = num;
        return true;
      }
    } else if (Player.Health < max) {
      Player.Health += num;
      if (Player.Health > max) Player.Health = max;
      Health = Player.Health;
      return true;
    }
  } else {
    max = InitialHealth;
    if (num < 0) {
      num = max*(-num)/100;
      if (Health < num) {
        Health = num;
        return true;
      }
    } else if (Health < max) {
      Health += num;
      if (Health > max) Health = max;
      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  RepairArmorWith
//
//  Returns false if the armor weren't repaired.
//
//==========================================================================
final bool RepairArmorWith (int amount, optional class!BasicArmorBonus armorbonustype) {
  // default armorbonustype: ArmorBonus
  printwarn("`RepairArmorWith()` is not implemeted!");
  return false;
}


//==========================================================================
//
//  SpawnPuff
//
//  to prevent decal spawning, pass 'none' as `decalType`
//  (or something else that is non-existing)
//  decalType of '' means "use default puff decal"
//
//==========================================================================
final EntityEx SpawnPuff (TVec Org, float Range, class!EntityEx PuffType,
  EntityEx HitThing, optional sector_t *sec, optional line_t *li, optional TVec realOrg,
  optional name decalType, optional int pufftid, optional bool disableRandomZ)
{
  EntityEx puff;
  if (!Level.Game.IsAuthority) return none;

  // k8: ZDoom spawns decals (and particles, i guess) only if puff exists for at least one tick
  // k8: so i moved the corresponding code down

  if (PuffType) {
    if (!disableRandomZ) Org.z += (Random()-Random())*4.0;

    puff = SpawnEntityChecked(class!EntityEx, PuffType, Org);
    if (!puff) return none; // oops

    if (pufftid) puff.SetTID(pufftid);

    // [BB] set the target of the puff to this actor
    if (puff.bPuffGetsOwner) puff.Target = Target;

    if (HitThing) {
      if (puff.bHitTarget) puff.Target = HitThing;
      if (puff.bHitMaster) puff.Master = HitThing;
      if (puff.bHitTracer) puff.Tracer = HitThing;
    }

    state st = none;
    if (HitThing) {
      //FIXME: check "thruXXX" flags here
      if (puff.bPuffOnActors && !HitThing.bNoBlood /*&& !HitThing.bInvulnerable*/) {
        st = puff.FindState('XDeath');
      }
      if (!st && Range <= DEFAULT_MELEERANGE) st = puff.MeleeState;
    } else {
      st = puff.FindState('Crash');
    }

    /*
    if (!st && !HitThing) st = puff.FindState('Crash');
    if (!st && Range <= DEFAULT_MELEERANGE) st = puff.MeleeState;
    */

    if (st) puff.SetState(st);

    if (HitThing && puff.SightSound) {
      // hit thing sound
      puff.PlaySound(puff.SightSound, CHAN_VOICE);
    } else if (puff.AttackSound) {
      puff.PlaySound(puff.AttackSound, CHAN_VOICE);
    }

    if (puff.ExplodeEffect) SendExplosion(ExplodeEffect, DLightRadius, Org);
    LineSpecialLevelInfo(Level).bPuffSpawned = true;

    //return puff;
  }

  if (puff && !puff.IsDestroyed) {
    //printdebug("%C: puff `%C`; decal=%s; passed_decal:(%B)=%s", self, puff, puff.DecalName, specified_decalType, decalType);

    if (puff.bPuffParticles && GetCvarB('r_particle_puffs')) {
      int c = P_Random()>>1;
      foreach (int i; 0..MAXPLAYERS) {
        if (!Level.Game.Players[i]) continue;
        if (!Level.Game.Players[i].bSpawned) continue;
        PlayerEx(Level.Game.Players[i]).ParticleEffect(20, LineSpecialLevelInfo::pt_static,
                 LineSpecialLevelInfo::pt_explode2, Org, 0.0, vector(32.0, 32.0, 32.0),
                 0.5, 10.0, 40.0, RGB(c, c, c), 0.8, 0.0);
      }
    }

    if (puff.bPuffNoDecals) {
      decalType = '';
    } else {
      if (puff.bPuffForceDecals) {
        decalType = puff.DecalName; // override it
      } else if (!specified_decalType || !decalType) {
        // empty `decalType` is passed from line attacks, if weapon has no decal
        decalType = puff.DecalName;
      }
      if (nameicmp(decalType, 'none') == 0) decalType = ''; // prevent error spam
    }
    /*
    if (specified_decalType) {
      if (!decalType) doDecal = false;
    } else {
      if (!PuffType || !puff.DecalName) doDecal = false;
    }*/

    //print("SpawnPuff: Range=%s; PuffType=%C; decalType=%s(%B); puffdecal=%s; doDecal=%B", Range, PuffType, decalType, specified_decalType, (PuffType ? puff.DecalName : '<none>'), doDecal);

    if (decalType) {
      name flatDName = (specified_decalType && decalType ? decalType : puff.bSeparateFlatDecal ? puff.FlatDecalName : puff.DecalName);
      if (flatDName && !nameEquCI(flatDName, 'none')) {
        if (!specified_realOrg) realOrg = Org;
        float fdrange = fmax(1.0, fabs(Height)*0.5);
        TVec forg = realOrg;
        forg.z += fdrange;
        //FIXME: caller should check if we are on the line?
        if (sec && li) {
          // check it here, because spawning exactly on the line may leak throug the closed door
          if (fabs(li.PointDistance(forg)) < 1.0) {
            forg -= li->normal*1.6; // move away slightly
          }
        }
        SpawnFlatDecal(forg, flatDName, fdrange+2.0);
      }
    }

    if (decalType && sec && li) {
      //k8:TODO: this should be strictly client-side
      if (!specified_realOrg) realOrg = Org;
      name dcname = (specified_decalType && decalType ? decalType : puff.DecalName);
      SpawnDecal(realOrg, dcname, (sec == li->frontsector ? 0 : 1), li);
    }
  }

  return puff;
}


//==========================================================================
//
//  SendExplosion
//
//==========================================================================
final void SendExplosion (int color, float rad, TVec org) {
  foreach (auto i; 0..MAXPLAYERS) {
    if (!Level.Game.Players[i]) continue;
    if (!Level.Game.Players[i].bSpawned) continue;
    PlayerEx(Level.Game.Players[i]).ClientExplosion(color, rad, org);
  }
}


//==========================================================================
//
//  AngleIncrements
//
//==========================================================================
int AngleIncrements () {
  return (bMonster ? 45 : LineSpecialGameInfo(Level.Game).NonMonsterAngleIncrements);
}


//==========================================================================
//
//  PreExplode
//
//==========================================================================
void PreExplode () {
}


//==========================================================================
//
//  GetExplodeParms
//
//==========================================================================
void GetExplodeParms (ref int damage, ref float distance, ref bool damageSelf) {
}


//==========================================================================
//
//  CheckBossDeath
//
//==========================================================================
final bool CheckBossDeath () {
  // make sure there is a player alive for victory
  int i;
  foreach (i; 0..MAXPLAYERS) {
    if (Level.Game.Players[i] && Level.Game.Players[i].bSpawned && Level.Game.Players[i].Health > 0) {
      break;
    }
  }

  if (i == MAXPLAYERS) {
    // no one left alive, so do not end game
    return false;
  }

  // scan the remaining thinkers to see if all bosses are dead
  EntityEx Other;
  foreach AllThinkers(class!EntityEx(Class), out Other) {
    if (Other != self && Other.Class == Class && Other.Health > 0) {
      // found a living boss
      return false;
    }
  }
  return true;
}


//==========================================================================
//
//  GetSpeechIndex
//
//==========================================================================
final int GetSpeechIndex (FRogueConSpeech[] List, int ID, int Num) {
  int Found = 0;
  foreach (auto i; 0..List.length) {
    if (List[i].SpeakerID == ID) {
      ++Found;
      if (Found == Num) return i+1;
    }
  }
  return 0;
}


//==========================================================================
//
//  GetSpeech
//
//==========================================================================
final int GetSpeech () {
  if (!CurrentSpeech) CurrentSpeech = 1;
  int Index = GetSpeechIndex(XLevel.LevelSpeeches, ConversationID, CurrentSpeech);
  if (Index) return Index;
  return -GetSpeechIndex(XLevel.GenericSpeeches, ConversationID, CurrentSpeech);
}


//==========================================================================
//
//  TossUpObject
//
//==========================================================================
final EntityEx TossUpObject (class!EntityEx type) {
  if (!Level.Game.IsAuthority) return none;
  float randomspeed = Random()*8.0-6.0;
  EntityEx A = SpawnEntityChecked(class!EntityEx, type, GetCenter());
  if (A) {
    float an = AngleMod360(Angles.yaw+Random()*360.0);
    A.Angles.yaw = an;
    A.Tracer = Target;
    A.Target = self;
    float sina, cosa;
    sincos(an, out sina, out cosa);
    A.Velocity.x = randomspeed*cosa*35.0;
    A.Velocity.y = randomspeed*sina*35.0;
    A.Velocity.z = (12.0+Random()/8.0)*35.0;
  }
  return A;
}


//==========================================================================
//
//  ACSRenderStyleToVavoom
//
//==========================================================================
final int ACSRenderStyleToVavoom (int rs) {
  switch (rs) {
    case 0: return STYLE_None;
    case 1: return STYLE_Normal;
    case 2: return STYLE_Fuzzy;
    case 3: return STYLE_SoulTrans;
    case 4: return STYLE_OptFuzzy;
    case 5: return STYLE_Stencil;
    case 64: return STYLE_Translucent;
    case 65: return STYLE_Add;
    case 66: return STYLE_Shaded;
    case 67: return STYLE_TranslucentStencil;
    case 68: return STYLE_Shadow;
    case 69: return STYLE_Subtract;
    case 6: return STYLE_AddStencil;
    case 7: return STYLE_AddShaded;
    default:
  }
  printwarn("%C: ACS trying to set uknown render style %d", rs);
  return STYLE_Normal;
}


//==========================================================================
//
//  ACSRenderStyleFromVavoom
//
//==========================================================================
final int ACSRenderStyleFromVavoom (int rs) {
  switch (rs) {
    case STYLE_None: return 0;
    case STYLE_Normal: return 1;
    case STYLE_Fuzzy: return 2;
    case STYLE_SoulTrans: return 3;
    case STYLE_OptFuzzy: return 4;
    case STYLE_Stencil: return 5;
    case STYLE_Translucent: return 64;
    case STYLE_Add: return 65;
    case STYLE_Shaded: return 66;
    case STYLE_TranslucentStencil: return 67;
    case STYLE_Shadow: return 68;
    case STYLE_Subtract: return 69;
    case STYLE_AddStencil: return 6;
    case STYLE_AddShaded: return 7;
    default:
  }
  return 1;
}


//==========================================================================
//
//  SetActorProperty
//
//==========================================================================
override void SetActorProperty (int Prop, int IntVal, string StrVal) {
  switch (Prop) {
    case APROP_Health: Health = IntVal; if (bIsPlayer) Player.Health = IntVal; break;
    case APROP_Speed: Speed = float(IntVal)/65536.0*35.0; if (Speed < 0) Speed = 0; break;
    case APROP_Damage: MissileDamage = IntVal; bForceUseMissileDamage = true; break; //FIXME: is this right?
    case APROP_Alpha: Alpha = fclamp(float(IntVal)/65536.0, 0.0, 1.0); break;
    case APROP_RenderStyle: RenderStyle = ACSRenderStyleToVavoom(IntVal); break;
    case APROP_Ambush: bAmbush = !!IntVal; break;
    case APROP_Invulnerable: bInvulnerable = !!IntVal; break;
    case APROP_JumpZ: if (PlayerPawn(self)) PlayerPawn(self).JumpVelZ = float(IntVal)/65536.0*35.0; break;
    case APROP_ChaseGoal: bChaseGoal = !!IntVal; break;
    case APROP_Frightened: print("Frightened property is not implemented"); break;
    case APROP_Gravity: if (IntVal < 0) IntVal = 0; Gravity = float(IntVal)/65536.0; break;
    case APROP_Friendly: bFriendly = !!IntVal; FriendPlayer = 0; break;
    case APROP_SeeSound: SightSound = name(StrVal); break;
    case APROP_AttackSound: AttackSound = name(StrVal); break;
    case APROP_PainSound: PainSound = name(StrVal); break;
    case APROP_DeathSound: DeathSound = name(StrVal); break;
    case APROP_ActiveSound: ActiveSound = name(StrVal); break;
    case APROP_SpawnHealth: if (PlayerPawn(self)) PlayerPawn(self).MaxHealth = IntVal; break;
    case APROP_Dropped: bDropped = !!IntVal; break;
    case APROP_MasterTID: if (IntVal <= 0) { Master = none; break; } Master = EntityEx(Level.FindMobjFromTID(IntVal, none)); if (Master == self) Master = none; break; //k8: allow self?
    case APROP_TargetTID: if (IntVal <= 0) { Target = none; break; } Target = EntityEx(Level.FindMobjFromTID(IntVal, none)); if (Target == self) Target = none; break; //k8: allow self?
    case APROP_TracerTID: if (IntVal <= 0) { Tracer = none; break; } Tracer = EntityEx(Level.FindMobjFromTID(IntVal, none)); if (Tracer == self) Tracer = none; break; //k8: allow self?
    //case APROP_WaterLevel: return WaterLevel;
    case APROP_ScaleX: ScaleX = float(IntVal)/65536.0; break;
    case APROP_ScaleY: ScaleY = float(IntVal)/65536.0; break;
    case APROP_Dormant: bDormant = !!IntVal; break; //k8: change state for monster?
    case APROP_Mass: Mass = clamp(IntVal, 0, 10000); break; //k8: float?
    case APROP_Height: Height = fmax(0, float(IntVal)/65536.0); break;
    case APROP_Radius: Radius = fmax(0, float(IntVal)/65536.0); break;
    case APROP_ViewHeight:
      if (bIsPlayer) PlayerEx(Player).ViewHeight = float(IntVal)/65536.0;
      //else ViewHeight = float(IntVal)*65536.0;
      break;
    case APROP_AttackZOffset:
      if (bIsPlayer) PlayerPawn(Player.MO).AttackZOffset = float(IntVal)/65536.0;
      break;
    case APROP_Notarget: break; // no, my dear mod author, you cannot do this
    case APROP_Notrigger: bNoTrigger = !!IntVal; break;
    case APROP_Score: Score = IntVal; break;
    case APROP_Accuracy: Accuracy = IntVal; break;
    case APROP_Stamina: Stamina = IntVal; break;
    case APROP_DamageFactor:
      // this fixes my fuckup with invalid `GetCVar()` ACS API
      //if (IntVal <= 64) IntVal *= 65536;
      GenericDamageFactor = fclamp(float(IntVal)/65536.0, 0, 100000);
      //printdebug("%C: dmgfactor=%s (%s)", self, GenericDamageFactor, IntVal);
      break;
    case APROP_DamageMultiplier:
      // this fixes my fuckup with invalid `GetCVar()` ACS API
      //if (IntVal <= 64) IntVal *= 65536;
      GenericDamageMultiplier = fclamp(float(IntVal)/65536.0, 0, 100000);
      //printdebug("%C: dmgmult=%s (%s)", self, GenericDamageMultiplier, IntVal);
      break;
    case APROP_MaxStepHeight: MaxStepHeight = fclamp(float(IntVal)/65536.0, 0, 8192); break;
    case APROP_MaxDropOffHeight: MaxDropoffHeight = fclamp(float(IntVal)/65536.0, 0, 8192); break;
    case APROP_Friction: Friction = fmax(float(IntVal)/65536.0, 0.0); break;
    case APROP_ReactionTime: ReactionCount = IntVal; break;
    case APROP_StencilColor: StencilColor = IntVal|0xff000000; break;
    case APROP_Species: /*printdebug("%C: SPECIE=%s", self, StrVal);*/ Species = name(StrVal); break;
    case APROP_NameTag: /*printdebug("%C: NAMETAG=%s", self, StrVal);*/ StrifeName = StrVal; break;
    case APROP_DamageType: /*printdebug("%C: DAMAGETYPE=%s", self, StrVal);*/ DamageType = name(StrVal); break;
    default: dprint("%C: SetActorProperty: unknown property %s (value is %s)", self, Prop, IntVal);
  }
}


//==========================================================================
//
//  GetActorProperty
//
//==========================================================================
override int GetActorProperty (int Prop) {
  //if (Prop == APROP_SpawnHealth) print("GetActorProperty(%C, APROP_SpawnHealth)=%s", self, self.InitialHealth);
  switch (Prop) {
    case APROP_Health: return Health;
    case APROP_Speed: return int(Speed/35.0*65536.0);
    case APROP_Damage: return GetMissileDamage(0, 1); //FIXME: is this right?
    case APROP_Alpha: return int(Alpha*65536.0);
    case APROP_RenderStyle: return ACSRenderStyleFromVavoom(RenderStyle);
    case APROP_Ambush: return bAmbush;
    case APROP_Invulnerable: return bInvulnerable;
    case APROP_JumpZ: return int(PlayerPawn(self).JumpVelZ/35.0*65536.0);
    case APROP_ChaseGoal: return bChaseGoal;
    case APROP_Frightened: return 0;
    case APROP_Gravity: return int(Gravity*65536.0);
    case APROP_Friendly: return bFriendly;
    case APROP_SpawnHealth: if (PlayerPawn(self)) return PlayerPawn(self).MaxHealth; else return self.InitialHealth;
    case APROP_Dropped: return bDropped;
    case APROP_Species: return NameToIIndex(GetSpecies()); //HACK! keep in sync with C++ code!
    case APROP_NameTag: return (StrifeName ? NameToIIndex(name(StrifeName)) : NameToIIndex(GetClassName(Class))); //HACK! keep in sync with C++ code!
    case APROP_MasterTID: return (Master ? Master.TID : 0);
    case APROP_TargetTID: return (Target ? Target.TID : 0);
    case APROP_TracerTID: return (Tracer ? Tracer.TID : 0);
    case APROP_WaterLevel: return WaterLevel;
    case APROP_ScaleX: return int(ScaleX*65536.0);
    case APROP_ScaleY: return int(ScaleY*65536.0);
    case APROP_Dormant: return bDormant;
    case APROP_Mass: return int(fmax(0, Mass));
    case APROP_Height: return int(Height*65536.0);
    case APROP_Radius: return int(Radius*65536.0);
    case APROP_MeleeRange: return int(MeleeRange*65536.0);
    case APROP_ViewHeight:
      if (bIsPlayer) return int(PlayerEx(Player).ViewHeight*65536.0);
      //return int(ViewHeight*65536.0);
      return int(Height/2.0*65536.0);
    case APROP_AttackZOffset:
      return int((bIsPlayer ? PlayerEx(Player).GetAttackZOfs : 8.0)*65536.0);
    case APROP_Notarget: return (bIsPlayer ? PlayerEx(Player).bNoTarget : 0);
    case APROP_Notrigger: return (bNoTrigger ? 1 : 0);
    case APROP_Score: return Score;
    case APROP_Accuracy: return Accuracy;
    case APROP_Stamina: return Stamina;
    case APROP_DamageFactor: return int(GenericDamageFactor*65536.0);
    case APROP_DamageMultiplier: return int(GenericDamageMultiplier*65536.0);
    case APROP_DamageType: return (!DamageType ? NameToIIndex('None') : NameToIIndex(DamageType));
    case APROP_MaxStepHeight: return int(MaxStepHeight*65536.0);
    case APROP_MaxDropOffHeight: return int(MaxDropoffHeight*65536.0);
    case APROP_Friction: return int(Friction*65536.0);
    case APROP_ReactionTime: return ReactionCount;
    case APROP_StencilColor: return StencilColor&0xffffff;
    case APROP_SeeSound: return NameToIIndex(SightSound);
    case APROP_AttackSound: return NameToIIndex(AttackSound);
    case APROP_PainSound: return NameToIIndex(PainSound);
    case APROP_DeathSound: return NameToIIndex(DeathSound);
    case APROP_ActiveSound: return NameToIIndex(ActiveSound);
  }
  dprint("%C: GetActorProperty: unknown property %d", self, Prop);
  return 0;
}


//==========================================================================
//
//  SetPlayerProperty
//
//==========================================================================
final bool SetPlayerProperty (int Prop, int Set) {
  class!Inventory InvClass = none;

  switch (Prop) {
    case PROP_FROZEN: if (Player) PlayerEx(Player).bFrozen = !!Set; return true;
    case PROP_NOTARGET: if (Player) PlayerEx(Player).bNoTarget = !!Set; return true;
    case PROP_INSTANTWEAPONSWITCH: if (Player) PlayerEx(Player).bInstantWeaponSwitch = !!Set; return true;
    case PROP_FLY: if (Player) PlayerEx(Player).bFly = !!Set; bFly = !!Set; bNoGravity = !!Set; return true;
    case PROP_TOTALLYFROZEN: if (Player) PlayerEx(Player).bTotallyFrozen = !!Set; return true;
    case PROP_INVULNERABILITY: InvClass = PowerInvulnerable; break;
    case PROP_STRENGTH: InvClass = PowerStrength; break;
    case PROP_INVISIBILITY: InvClass = PowerInvisibility; break;
    case PROP_RADIATIONSUIT: InvClass = PowerIronFeet; break;
    case PROP_ALLMAP: if (Player) { if (Set) PlayerEx(Player).AddRevealedMap(); else PlayerEx(Player).RemoveRevealedMap(); } return true;
    case PROP_INFRARED: InvClass = PowerLightAmp; break;
    case PROP_WEAPONLEVEL2: InvClass = PowerWeaponLevel2; break;
    case PROP_FLIGHT: InvClass = PowerFlight; break;
    case PROP_SPEED: InvClass = PowerSpeed; break;
    case PROP_BUDDHA: break; // no, my dear mod author, you cannot do this
    case PROP_NOWEAPONSWITCH: if (Player) PlayerEx(Player).bDisableWeaponSwitch = !!Set; return true;
    default:
      dprint("%C: SetPlayerProperty: unknown property %d", self, Prop);
      return false;
  }

  if (Set) {
    GiveInventoryType(InvClass);
  } else {
    Inventory Item = FindInventory(InvClass);
    if (Item) Item.Destroy();
  }
  return true;
}


//==========================================================================
//
//  ShouldDropItems
//
//==========================================================================
bool ShouldDropItems () {
  if (!Level.Game.IsAuthority) return false;
  return true;
}


//==========================================================================
//
//  PainShootSkull
//
//  Spawn a lost soul and launch it at the target
//
//  limitCheck:
//    <0: no limit
//     0: use default compatibility setting
//    >0: use this as a limit
//
//==========================================================================
final void PainShootSkull (class!Actor SpawnType, float angle, optional bool noattack,
                           optional bool notarget, optional int limitCheck)
{
  EntityEx mo;
  Actor newSkull;
  float prestep;
  float sina, cosa;

  if (!SpawnType) SpawnType = LostSoul;
  if (nameicmp(DamageType, 'Massacre') == 0) return;

  // fix limit checker
  if (!limitCheck) limitCheck = (Level.CompatLimitPain ? 20 : -1);

  if (limitCheck > 0) {
    // count total number of skull currently on the level
    //FIXME: decorate_A_PainAttack can override this
    int count = 0;
    foreach AllThinkers(SpawnType, mo) {
      if (mo) {
        if (++count > limitCheck) return;
      }
    }
    // if there are allready 20 skulls on the level, don't spit another one
    //if (count > 20) return;
  }

  // okay, there's place for another one
  prestep = 4.0+3.0*(Radius+SpawnType.default.Radius)/2.0;

  sincos(angle, out sina, out cosa);
  sina *= prestep;
  cosa *= prestep;

  // Check whether the Lost Soul is being fired through a 1-sided
  // wall or an impassible line, or a "monsters can't cross" line.
  // If it is, then we don't allow the spawn.
  if (CheckSides(Origin+vector(cosa, sina, 8.0))) return;

  newSkull = SpawnEntityChecked(class!Actor, SpawnType, Origin);
  if (newSkull) {
    // Check to see if the new Lost Soul's z value is above the
    // ceiling of its new sector, or below the floor. If so, kill it.
    if (newSkull.Origin.z > newSkull.CeilingZ-newSkull.Height ||
        newSkull.Origin.z < newSkull.FloorZ)
    {
      // kill it immediately
      newSkull.Damage(self, self, 10000, forced:true);
      return;
    }

    // check for movements
    if (!newSkull.TryMove(newSkull.Origin+vector(cosa, sina, 8.0), AllowDropOff:false)) {
      // kill it immediately
      newSkull.Damage(self, self, 10000, forced:true);
      return;
    }

    // spawned skulls hate same things as master
    newSkull.CopyFriendliness(self, !notarget);

    if (!noattack) newSkull.A_SkullAttack();
  }
}


//==========================================================================
//
//  AutoUseHealth
//
//==========================================================================
final void AutoUseHealth (int saveHealth) {
  int count;
  int normalhealth = 0;
  int superhealth = 0;
  array!Inventory normal;
  array!Inventory super;
  int saved = 0;

  for (Inventory inv = Inventory; inv; inv = inv.Inventory) {
    if (inv.Amount > 0 && ClassIsChildOf(inv.Class, HealthPickup)) {
      int mode = HealthPickup(inv).AutoUseMode;
      if (mode == 1) {
        normal[$] = inv;
      } else if (mode == 2) {
        super[$] = inv;
      }
    }
  }

  foreach (auto i; 0..normal.length-1) normalhealth += normal[i].Amount*normal[i].Health;
  foreach (auto i; 0..super.length-1) superhealth += super[i].Amount*super[i].Health;

  if (Level.World.bSkillAutoUseHealth && normalhealth >= saveHealth) {
    // use quartz flasks
    while (normal.length > 0 && saveHealth > 0) {
      int maxhealth = 0;
      int index = -1;

      // find the largest item in the list
      foreach (auto i; 0..normal.length-1) {
        if (normal[i].Health > maxhealth) {
          index = i;
          maxhealth = normal[i].Health;
        }
      }

      // now apply the health items, using the same logic as Heretic and Hexen
      count = (saveHealth+maxhealth-1)/maxhealth;
      foreach (auto i; 0..count) {
        saved += maxhealth;
        saveHealth -= maxhealth;
        if (!(--normal[index].Amount)) {
          // used last of a type, compact the artifact list
          normal[index].Destroy();
        }
      }
    }

    Health += saved;
  } else if (superhealth >= saveHealth) {
    // Use mystic urns
    while (super.length > 0 && saveHealth > 0) {
      int maxhealth = 0;
      int index = -1;

      // find the largest item in the list
      foreach (auto i; 0..super.length-1) {
        if (super[i].Health > maxhealth) {
          index = i;
          maxhealth = super[i].Health;
        }
      }

      // now apply the health items, using the same logic as Heretic and Hexen.
      count = (saveHealth+maxhealth-1)/maxhealth;
      foreach (auto i; 0..count) {
        saved += maxhealth;
        saveHealth -= maxhealth;
        if (!(--super[index].Amount)) {
          // used last of a type, compact the artifact list
          super[index].Destroy();
        }
      }
    }

    Health += saved;
  } else if (Level.World.bSkillAutoUseHealth && normalhealth+superhealth >= saveHealth) {
    // use mystic urns and quartz flasks
    while (normal.length > 0 && saveHealth > 0) {
      int maxhealth = 0;
      int index = -1;

      // find the largest item in the list
      foreach (auto i; 0..normal.length-1) {
        if (normal[i].Health > maxhealth) {
          index = i;
          maxhealth = normal[i].Health;
        }
      }

      // now apply the health items, using the same logic as Heretic and Hexen
      count = (saveHealth+maxhealth-1)/maxhealth;
      foreach (auto i; 0..count) {
        saved += maxhealth;
        saveHealth -= maxhealth;
        if (!(--normal[index].Amount)) {
          // used last of a type, compact the artifact list
          normal[index].Destroy();
        }
      }
    }

    Health += saved;
    if (saveHealth > 0) {
      while (super.length > 0 && saveHealth > 0) {
        int maxhealth = 0;
        int index = -1;

        // find the largest item in the list
        foreach (auto i; 0..super.length-1) {
          if (super[i].Health > maxhealth) {
            index = i;
            maxhealth = super[i].Health;
          }
        }

        // now apply the health items, using the same logic as Heretic and Hexen
        count = (saveHealth+maxhealth-1)/maxhealth;
        foreach (auto i; 0..count) {
          saved += maxhealth;
          saveHealth -= maxhealth;
          if (!(--super[index].Amount)) {
            // used last of a type, compact the artifact list
            super[index].Destroy();
          }
        }
      }

      Health += saved;
    }
  }
  Player.Health = Health;
}


//==========================================================================
//
//  AutoUseStrifeHealth
//
//==========================================================================
final void AutoUseStrifeHealth (int saveHealth) {
  array!Inventory Items;
  //int itemshealth;

  for (Inventory inv = Inventory; inv; inv = inv.Inventory) {
    if (inv && inv.Amount > 0 && ClassIsChildOf(inv.Class, HealthPickup)) {
      int mode = HealthPickup(inv).AutoUseMode;
      if (mode == 3) {
        Items[$] = inv;
      }
    }
  }

  //foreach (auto i; 0..Items.length) itemshealth += Items[i].Amount*Items[i].Health;

  while (Items.length > 0) {
    int maxhealth = 0;
    int index = -1;

    // find the largest item in the list
    foreach (auto i; 0..Items.length) {
      if (Items[i].Health > maxhealth) {
        index = i;
        maxhealth = Items[i].Amount;
      }
    }

    while (Health < 50) {
      if (!UseInventory(Items[index])) break;
    }
    if (Health >= 50) {
      Player.Health = Health;
      return;
    }

    // using all of this item was not enough so delete it and restart with the next best one
    Items[index] = none;
    if (index < Items.length) {
      for (int i = Items.length-index; i < Items.length-1; ++i) Items[i] = Items[i+1];
    }
    Items.length -= 1;
  }

  Player.Health = Health;
}


//==========================================================================
//
//  AutoUseArmor
//
//==========================================================================
final void AutoUseArmor () {
  Inventory Item = FindInventory(MetalArmor);
  if (Item) {
    // use metal armor
    Item.Use(false);
    if (!(--Item.Amount)) Item.Destroy();
  } else {
    Item = FindInventory(LeatherArmor);
    if (Item) {
      // use leather armor
      Item.Use(false);
      if (!(--Item.Amount)) Item.Destroy();
    }
  }
}


//==========================================================================
//
//  HITDICE
//
//  Most damage in HERETIC and HEXEN defined using HITDICE
//
//==========================================================================
final int HITDICE (int a) {
  return (1+(P_Random()&7))*a;
}


//==========================================================================
//
//  SpawnDirt
//
//  Dirt stuff
//
//==========================================================================
final void SpawnDirt (float aradius) {
  TVec org;
  class!EntityEx dtype;

  float angle = 360.0*Random();
  float sina, cosa;
  sincos(angle, out sina, out cosa);
  org.x = Origin.x+aradius*cosa;
  org.y = Origin.y+aradius*sina;
  org.z = Origin.z+Random()*2.0+1.0;
  switch (P_Random()%6) {
    case 0: dtype = Dirt1; break;
    case 1: dtype = Dirt2; break;
    case 2: dtype = Dirt3; break;
    case 3: dtype = Dirt4; break;
    case 4: dtype = Dirt5; break;
    case 5: dtype = Dirt6; break;
  }
  EntityEx dirt = SpawnEntityChecked(class!EntityEx, dtype, org);
  if (dirt) dirt.Velocity.z = Random()*4.0*35.0;
}


//===========================================================================
//
//  GunShot
//
//===========================================================================
final void GunShot (bool accurate, TVec dir, name DmgType, bool secondary, optional name aDecalName,
                    optional float range, optional float spreadYaw, optional float spreadPitch)
{
  if (!Level.Game.IsAuthority) return;
  if (!specified_range || range <= 0) range = MISSILERANGE;

  // make a copy of angles because inacurate shoot will modify them
  if (!accurate) {
    TAVec aimangles;
    VectorAngles(dir, out aimangles);
    if (!specified_spreadYaw) {
      aimangles.yaw = AngleMod360(aimangles.yaw+(FRandomFull()-FRandomFull())*45.0/8.0);
    } else {
      if (spreadYaw) aimangles.yaw = AngleMod360(aimangles.yaw+(FRandomFull()-FRandomFull())*spreadYaw);
    }
    if (spreadPitch) aimangles.pitch = AngleMod360(aimangles.pitch+(FRandomFull()-FRandomFull())*spreadPitch);
    AngleVector(aimangles, out dir);
  }

  int damage = 5*(P_Random()%3+1);
  //LineAttack(dir, range, damage, BulletPuff, DmgType:DmgType, secondary:secondary, decalType:aDecalName!optional);
  PerformVanillaLineAttack(dir, range, damage, BulletPuff, DmgType:DmgType, secondary:secondary, decalType:aDecalName!optional);
}


//===========================================================================
//
//  IsMissile
//
//===========================================================================
final bool IsMissile (bool Precise) {
  return bMissile || (Precise && default.bMissile);
}


//===========================================================================
//
//  FindJumpStateOfsForState
//
//===========================================================================
final state FindJumpStateOfsForState (state res, int offset) {
  if (!res) return none;
  if (offset == 0) return GetNextState(res);
  if (offset < 0) {
    // abort it, this is a bug
    printerror("Bad negative jump offset in decorate action for '%C' (%s)", self, res);
    return none;
  }
  res = GetStatePlus(res, offset, IgnoreJump:true);
  if (!res) {
    printwarn("Bad jump offset (runaway) in decorate action for '%C' (%s)", self, res);
  }
  #if 0
  else {
    printdebug("%C: ROUTING WITH `FindJumpStateOfs(%s)`! dest is %s", self, offset, res);
  }
  #endif
  return res;
}


//===========================================================================
//
//  FindJumpState
//
//  used in decorate code to resolve jump-labels-as-arguments
//  gzshit just skips jump when invalid state name provided,
//  but i don't care what gzshit does, really.
//  i'll try to spam console with invalid label name, though
//
//  decorate codegen will strip leading and trailing spaces
//
//===========================================================================
final state FindJumpState (name Label, int offset) {
  if (Label.nameEquCI('null') || Label.endsWithCI('::null')) return none;

  if (!Label || Label.nameEquCI('none') /*|| Label.nameEquCI('nil')*/ || Label.nameEquCI('empty') ||
      Label.endsWithCI('::none') /*|| Label.endsWithCI('::nil')*/ || Label.endsWithCI('::empty') ||
      Label == '::' || Label.nameEquCI('Super::'))
  {
    return FindJumpStateOfs(offset);
  }

  // in state call chain?
  if (XLevel.StateCall) {
    // `item` is the original caller, we should follow its states here
    state res = XLevel.StateCall->Item.FindState(Label);
    if (offset && res) res = FindJumpStateOfsForState(res, offset);
    if (!res) {
      printwarn("unknown item `%C` decorate label (statecall) '%s' (actor is `%C`) -- probably broken code!", XLevel.StateCall->Item, Label, self);
      if (XLevel.CallingState) printwarn("... current state: %s", XLevel.CallingState);
      if (!offset && GetCvarB('dbg_emulate_broken_gozzo_gotos')) res = GetNextState(XLevel.CallingState);
    }
    return res;
  }

  // special weapon states?
  if (bIsPlayer) {
    // weapon/muzzle flash/weapon overlays?
    if (XLevel.CallingState == Player.ViewStates[PS_WEAPON].State ||
        XLevel.CallingState == Player.ViewStates[PS_FLASH].State ||
        XLevel.CallingState == Player.ViewStates[PS_WEAPON_OVL].State ||
        XLevel.CallingState == Player.ViewStates[PS_WEAPON_OVL_BACK].State)
    {
      if (!PlayerEx(Player).ReadyWeapon) return none;
      state res = PlayerEx(Player).ReadyWeapon.FindState(Label);
      if (offset && res) res = FindJumpStateOfsForState(res, offset);
      if (!res) {
        printwarn("unknown weapon `%C` decorate label '%s' -- probably broken code!", PlayerEx(Player).ReadyWeapon, Label);
        if (XLevel.CallingState) printwarn("... current state: %s", XLevel.CallingState);
        if (!offset && GetCvarB('dbg_emulate_broken_gozzo_gotos')) res = GetNextState(XLevel.CallingState);
      }
      return res;
    }
  }

  // normal state jump
  state res = FindState(Label);
  if (offset && res) res = FindJumpStateOfsForState(res, offset);
  if (!res) {
    printwarn("unknown actor `%C` decorate label '%s' -- probably broken code!", self, Label);
    if (XLevel.CallingState) printwarn("... current state: %s", XLevel.CallingState);
    if (!offset && GetCvarB('dbg_emulate_broken_gozzo_gotos')) res = GetNextState(XLevel.CallingState);
  }

  return res;
}


//===========================================================================
//
//  FindJumpStateOfs
//
//  this is to support idiocities like `A_Jump(n, func())`
//
//===========================================================================
final state FindJumpStateOfs (int offset) {
  //printdebug("%C: ROUTING WITH `FindJumpStateOfs(%s)`!", self, offset);
  return FindJumpStateOfsForState(XLevel.CallingState, offset);
}


//===========================================================================
//
//  GetXStateTime
//
//===========================================================================
final float GetXStateTime () {
  if (XLevel.StateCall) return StateTime;
  if (bIsPlayer) {
    foreach (int xidx; 0..NUMPSPRITES) {
      if (XLevel.CallingState == Player.ViewStates[xidx].State) {
        return Player.ViewStates[xidx].StateTime;
      }
    }
  }
  return StateTime;
}


//===========================================================================
//
//  PlrSetAngleInterp
//
//===========================================================================
final void PlrSetAngleInterp (ref BasePlayer::VPlrAngleInterp ii, float prevangle, int aptr) {
  if (!bIsPlayer || Player.MO != self) return;
  PlayerEx plr = PlayerEx(Player);
  if (!plr) return;

  float stt = (!aptr ? GetXStateTime() : StateTime);
  float gtime = XLevel.NextTime;

  if (ii.Duration) {
    float dt = (gtime-ii.StartTime)/ii.Duration;
    //printdebug("%C: stt=%s; dt=%s; prev=%s", self, stt, dt, prevangle);
    if (dt < 0.0 || dt >= 1.0) {
      ii.StartTime = gtime;
      ii.Duration = (stt > 0.0 ? stt : 1.0/35.0);
      ii.Prev = prevangle;
    } else if (stt > 0.0) {
      ii.Prev += AngleDiff(ii.Prev, prevangle)*dt;
      ii.StartTime = gtime;
      ii.Duration = stt;
    }
  } else {
    ii.StartTime = gtime;
    ii.Duration = (stt > 0.0 ? stt : 1.0/35.0);
    ii.Prev = prevangle;
  }
  //printdebug("%C: time=%s : %s", self, ii.Duration, stt);
}


//===========================================================================
//
//  DoJump
//
//  mostly called from decorate actions
//
//===========================================================================
final void DoJump (state aState, optional bool affectStateCallResult) {
  if (XLevel.StateCall) {
    XLevel.StateCall->State = aState;
    // shoult state jump affect state chain results?
    if (!affectStateCallResult) XLevel.StateCall->Result = 0;
  } else {
    if (bIsPlayer) {
      bool done = false;
      foreach (int xidx; 0..NUMPSPRITES) {
        if (XLevel.CallingState == Player.ViewStates[xidx].State) {
          done = true;
          //printdebug("SetViewState #%s: %s", xidx, aState);
          PlayerEx(Player).SetViewObjectIfNone(PlayerEx(Player).ReadyWeapon);
          Player.SetViewState(xidx, aState);
          //printdebug("DONE SetViewState #%s: %s", xidx, aState);
          break;
        }
      }
      if (!done) SetState(aState);
    } else {
      SetState(aState);
    }
  }
  // state jumps should not affect state chain results
  //if (!keepChainRes && XLevel.StateCall) XLevel.StateCall->Result = false;
}


//==========================================================================
//
//  CheckForSectorActions
//
//==========================================================================
override void CheckForSectorActions (sector_t *OldSec, bool OldAboveFakeFloor, bool OldAboveFakeCeiling) {
  if (!Level.Game.IsAuthority) return;
  // check for crossing fake floor or ceiling
  if (OldSec->heightsec && Sector->heightsec && Sector->ActionList) {
    float EyeZ = (bIsPlayer ? Player.ViewOrg.z : Origin.z+Height*0.5);
    float FakeZ = Sector->heightsec->floor.GetPointZClamped(Origin);

    if (!OldAboveFakeFloor && EyeZ > FakeZ) {
      SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesSurface);
    } else if (OldAboveFakeFloor && EyeZ <= FakeZ) {
      SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesDive);
    }

    if (!Sector->heightsec->bFakeFloorOnly) {
      FakeZ = Sector->heightsec->ceiling.GetPointZClamped(Origin);
      if (!OldAboveFakeCeiling && EyeZ > FakeZ) {
        SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesSurface);
      } else if (OldAboveFakeCeiling && EyeZ <= FakeZ) {
        SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesBelowC);
      }
    }
  }

  // check for sector change triggers
  if (OldSec != Sector) {
    if (OldSec->ActionList) {
      SectorAction(OldSec->ActionList).TriggerAction(self, SectorAction::SECSPAC_Exit);
    }
    if (Sector->ActionList) {
      int Spac = SectorAction::SECSPAC_Enter;
      if (Origin.z <= Sector->floor.GetPointZClamped(Origin)) Spac |= SectorAction::SECSPAC_HitFloor;
      if (Origin.z+Height >= Sector->ceiling.GetPointZClamped(Origin)) Spac |= SectorAction::SECSPAC_HitCeiling;
      if (Sector->heightsec && Origin.z == Sector->heightsec->floor.GetPointZClamped(Origin)) Spac |= SectorAction::SECSPAC_HitFakeFloor;
      SectorAction(Sector->ActionList).TriggerAction(self, Spac);
    }
  }
}


//==========================================================================
//
//  CheckFakeFloorTriggers
//
//==========================================================================
final void CheckFakeFloorTriggers (float OldZ, optional bool OldHasViewH) {
  if (!Level.Game.IsAuthority) return;
  if (Sector && Sector->heightsec && Sector->ActionList) {
    float ViewH = (bIsPlayer ? PlayerEx(Player).ViewHeight : Height*0.5);
    float FakeZ = Sector->heightsec->floor.GetPointZClamped(Origin);

    if (OldZ > FakeZ && Origin.z <= FakeZ) {
      SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_HitFakeFloor);
      if (!Sector || !Sector->heightsec || !Sector->ActionList) return;
    }

    float EyeZ = Origin.z+ViewH;
    if (!OldHasViewH) OldZ += ViewH;

    if (OldZ <= FakeZ && EyeZ > FakeZ) {
      SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesSurface);
    } else if (OldZ > FakeZ && EyeZ <= FakeZ) {
      SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesDive);
    }
    if (!Sector || !Sector->heightsec || !Sector->ActionList) return;

    if (!Sector->heightsec->bFakeFloorOnly) {
      FakeZ = Sector->heightsec->ceiling.GetPointZClamped(Origin);
      if (OldZ <= FakeZ && EyeZ > FakeZ) {
        SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesAboveC);
      } else if (OldZ > FakeZ && EyeZ <= FakeZ) {
        SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesBelowC);
      }
    }
  }
}


//==========================================================================
//
//  UseLinesOld
//
//  Looks for special lines in front of the actor to activate
//
//==========================================================================
#if 0
final bool UseLinesOld (float UseRange, float UseThingRange, name FailSound,
                     optional bool delegate (line_t *ld) checkLineUseDg,
                     optional void delegate (line_t *ld) onLineUsedDg,
                     optional bool delegate (EntityEx th) checkThingUseDg,
                     optional void delegate (EntityEx th) onThingUsedDg)
{

  if (!Level.Game.IsAuthority) return false;

  //printdebug("%C: UseLines! thing range:%s; line range:%s", self, UseThingRange, UseRange);

  bool anythingUsed = false;
  bool action = false;
  bool hitLineOrThing = false;

  TVec useDir;
  AngleVector(Angles, out useDir);

  // check things
  TVec start = Origin;
  TVec end = start+UseThingRange*useDir.xy;

  float ehgt = fmax(0.0, Height);
  float sz0 = start.z;
  float sz1 = sz0+ehgt;

  EntityEx ee;
  intercept_t in;

  foreach PathTraverse(out in, start, end, /*PT_ADDLINES|*/PT_ADDTHINGS|PT_AIMTHINGS/*|PT_NOOPENS*/, SPF_NOBLOCKING, ML_BLOCKEVERYTHING|ML_BLOCKUSE) {
    if (in.bIsAPlane) break; // plane hit, no actor found

    // just in case
    if (in.bIsALine) {
      if (in.bIsABlockingLine) break; // blocking line hit, no actor found
      continue;
    }

    // don't use self
    if (in.Thing == self) continue;

    // check height
    if (sz0 >= in.Thing.Origin.z+in.Thing.Height || sz1 <= in.Thing.Origin.z) continue;

    // don't use self
    ee = EntityEx(in.Thing);
    if (!ee) continue;
    if (checkThingUseDg && !checkThingUseDg(ee)) continue;
    //printdebug("%C: trying to use thing %C(%s)", self, ee, ee.UniqueId);
    if (!UseThing(ee)) {
      //printdebug("%C:   used thing %C(%s)", self, ee, ee.UniqueId);
      if (!hitLineOrThing) {
        if (ee.bSolid && !ee.bCorpse && !ee.bMissile && !ee.bMonster && !ee.bInvisible) hitLineOrThing = true;
      }
      continue;
    }
    hitLineOrThing = true;
    if (onThingUsedDg) onThingUsedDg(ee);
    action = true;
    anythingUsed = true;
    break;
  }

  // check lines
  end = start+UseRange*useDir.xy;
  float pheight = Origin.z+ehgt/2.0;

  bool DoSecAct = true;
  bool FoundLine = false;
  bool buttonSuccess;
  int useType, useSide;
  line_t *ld;
  opening_t *open;

  foreach PathTraverse(out in, start, end, PT_ADDLINES|PT_NOOPENS, SPF_NOBLOCKING, ML_BLOCKEVERYTHING|ML_BLOCKUSE) {
    if (in.bIsAPlane) break; // plane hit, no actor found
    if (!in.bIsALine) continue; // just in case

    ld = in.line;
    if (!ld) continue; // just in case

    //printdebug("%C: testing line #%s (special %s)", self, ld-&XLevel.Lines[0], ld->special);

    // check 3d pobj line
    if (ld->pobject && ld->pobject->posector) {
      polyobj_t *po = ld->pobject;
      // 3d pobj, check height
      if (Origin.z+ehgt <= po->pofloor.minz || Origin.z >= po->poceiling.maxz) continue;
    }

    if (!ld->special || !(ld->SpacFlags&(SPAC_Use|SPAC_UseThrough|SPAC_UseBack))) {
      if (in.bIsABlockingLine || (ld->flags&(ML_BLOCKEVERYTHING|ML_BLOCKUSE))) {
        // gozzo does this
        open = nullptr;
      } else {
        if (ld->pobject && ld->pobject->posector) {
          open = nullptr;
        } else {
          //hitPoint = in.hitpoint; //Origin+(UseRange*in.frac)*useDir;
          open = XLevel.FindLineOpening(ld, in.hitpoint, ehgt);
        }
      }

      if (!open || open->range <= 0.0 || (ld->special && Level.CompatUseBlocking)) {
        if (checkLineUseDg && !checkLineUseDg(ld)) continue;

        DoSecAct = false;

        //printdebug("%C: trying to use blocking line #%s (special %s)", self, ld-&XLevel.Lines[0], ld->special);

        if (!ld->pobject || !ld->pobject->posector) {
          // let sector intercept the use
          if (Sector && Sector->ActionList && SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_Use)) {
            if (onLineUsedDg) onLineUsedDg(ld);
            anythingUsed = true;
            break;
          }

          sector_t *sec = (PointOnPlaneSide(Origin, *ld) == 0 ? ld->frontsector : ld->backsector);
          if (sec && sec->ActionList && SectorAction(sec->ActionList).TriggerAction(self, SectorAction::SECSPAC_UseWall)) {
            if (onLineUsedDg) onLineUsedDg(ld);
            anythingUsed = true;
            break;
          }
        }

        //!if (FailSound) PlaySound(FailSound, CHAN_VOICE);
        hitLineOrThing = true;

        // can't use through a wall
        break;
      }

      // not a special line, but keep checking
      if (FailSound && (open->top < pheight || open->bottom > pheight)) {
        //PlaySound(FailSound, CHAN_VOICE);
        hitLineOrThing = true;
      }

      if (checkLineUseDg && !checkLineUseDg(ld)) continue;
      FoundLine = true;
      continue;
    }

    // check side, set use type
    if (PointOnPlaneSide(Origin, *ld) == 1) {
      // back side
      if (!(ld->SpacFlags&SPAC_UseBack)) continue;
      //k8: gozzo doesn't check this, but we'll do
      // don't use back side unless it's a two-sided line
      if (ld->backsector != nullptr) continue;
      useType = SPAC_UseBack;
      useSide = 1;
    } else {
      // front side
      if ((ld->SpacFlags&(SPAC_UseBack|SPAC_Use|SPAC_UseThrough)) == SPAC_UseBack) continue; // can't be used from front, skip it
      if (checkLineUseDg && !checkLineUseDg(ld)) continue;
      useType = SPAC_Use;
      useSide = 0;
    }

    // check delegate callback
    if (checkLineUseDg && !checkLineUseDg(ld)) continue;

    //printdebug("%C: trying to use line #%s (special %s)", self, ld-&XLevel.Lines[0], ld->special);

    // check height here?
    hitLineOrThing = true;

    // k8: there was no check; why?
    if (LineSpecialLevelInfo(Level).ActivateLine(ld, self, useSide, useType, out buttonSuccess)) {
      if (onLineUsedDg) onLineUsedDg(ld);
      action = true;
      if (buttonSuccess) anythingUsed = true;
    }

    //WAS can't use more than one special line in a row
    //jff 3/21/98 NOW multiple use allowed with enabling line flag
    if (Level.CompatUseBlocking) {
      if (!(ld->SpacFlags&SPAC_UseThrough)) {
        DoSecAct = false;
        break;
      }
    } else if (ld->SpacFlags&SPAC_Use) {
      DoSecAct = false;
      break;
    }

    if (in.bIsABlockingLine) break;
  }

  if (DoSecAct && Sector->ActionList) {
    // let sector intercept the use
    int Spac = SectorAction::SECSPAC_Use;
    if (FoundLine) Spac |= SectorAction::SECSPAC_UseWall;
    if (SectorAction(Sector->ActionList).TriggerAction(self, Spac)) {
      anythingUsed = true;
    }
  }

  if (!anythingUsed && FailSound && hitLineOrThing) PlaySound(FailSound, CHAN_VOICE);

  return action;
}
#endif


//==========================================================================
//
//  CheckSwitchRange
//
//  check if given line switch is reachable
//  this also processes door and other non-switch activating lines too
//
//==========================================================================
final bool CheckSwitchRange (line_t *ld, int side, TVec hitpoint, ref bool failSound) {
  if (ld.sidenum[side] < 0) return false; // wtf?!
  side_t *sd = &XLevel.Sides[ld.sidenum[side]];

  float ehgt = fmax(0.0, Height);
  //float ez0 = Origin.z;
  //float ez1 = ez0+ehgt;
  // tracing started at the center of the entity
  float ez0 = hitpoint.z-ehgt*0.5;
  float ez1 = ez0+ehgt;

  // polyobjects?
  if (ld.pobject) {
    polyobj_t *po = ld.pobject;
    // 3d polyobject?
    if (po.posector) {
      // 3d pobj, check height
      if (ez1 <= po.pofloor.minz || ez0 >= po.poceiling.maxz) return false;
      return true;
    }
    // 2d polyobject is always takes the whole sector, allow it
    return true;
  }

  // not a polyobject

  // always activate one-sided wall
  if (!(ld.flags&ML_TWOSIDED)) return true;

  sector_t *fsec = (side ? ld.backsector : ld.frontsector);
  sector_t *bsec = (side ? ld.frontsector : ld.backsector);

  // always activate two-sided wall without any sector (just in case)
  if (!fsec || !bsec) return true;

  float fz0 = fsec.floor.GetPointZClamped(hitpoint);
  float fz1 = fsec.ceiling.GetPointZClamped(hitpoint);
  float bz0 = bsec.floor.GetPointZClamped(hitpoint);
  float bz1 = bsec.ceiling.GetPointZClamped(hitpoint);

  // set "can activate" flags (only possibility, not an actual reachability)
  bool canActivateTop = (sd->TopTexture > 0 && bz1 < fz1); // top texture can be activated if other sector ceiling is lower
  bool canActivateBot = (sd->BottomTexture > 0 && bz0 > fz0); // bottom texture can be activated if other sector floor is higher
  bool canActivateMid = (sd->MidTexture > 0 && bz0 < bz1); // middle texture can be activated if other sector is not closed

  bool switchMid = Level.IsSwitchTexture(sd->MidTexture);
  bool switchTop = Level.IsSwitchTexture(sd->TopTexture);
  bool switchBot = Level.IsSwitchTexture(sd->BottomTexture);

  bool doMoreChecks = true;

  // check middle switch texture
  if (switchMid) {
    // it is reachable if entity intersects with middle texture
    float mtz0, mtz1;
    if (canActivateMid && XLevel.GetMidTexturePosition(ld, side, out mtz0, out mtz1)) {
      if (ez1 >= mtz0 && ez0 <= mtz1) {
        // if other sector has 3d floors, do some more checks
        if (!bsec || bsec == fsec || !bsec.SectorHas3DFloors()) return true;
        // yes, other sector has 3d floors, perform opening check
        opening_t *open = XLevel.LineOpenings(ld, hitpoint, blockmask:default, do3dmidtex:true);
        // if we have a range that intersects with the entity, assume "reachable"
        while (open) {
          if (open.range > 0.0 && ez1 >= open.bottom && ez0 <= open.top) return true;
          open = open.next;
        }
        // 3d floor not reachable, do no more checks
        doMoreChecks = false;
      }
    }
    // middle texture is unreachable or not existent, check top and bottom switches
  } else {
    // middle texture is not a switch
    // if we have no switches at all, assume that both top and bottom textures are switches
    // this is for doors and lifts
    if (!switchTop && !switchBot) {
      switchTop = true;
      switchBot = true;
    }
  }

  if (doMoreChecks) {
    // check top/bottom switch textures
    if (canActivateTop && switchTop) {
      // check top texture reachability
      // it is reachable if entity intersects with other sector ceiling
      if (ez1 >= bz1) return true;
    }
    if (canActivateBot && switchBot) {
      // check bottom texture reachability
      // it is reachable if entity intersects with other sector floor
      if (ez0 <= bz0) return true;
    }
  }

  // can't activate
  // check if we need to produce a fail sound
  if (!failSound) {
         if (canActivateTop && ez1 >= bz1) failSound = true;
    else if (canActivateBot && ez0 <= bz0) failSound = true;
    else if (canActivateMid) {
      // check openings
      float pz0 = ez0+ehgt*0.3;
      float pz1 = ez1-ehgt*0.3;
      if (pz1 < pz0) { pz0 = ez0; pz1 = ez1; }
      // check openings to determine if we need "fail" sound
      opening_t *open = XLevel.LineOpenings(ld, hitpoint, blockmask:default, do3dmidtex:true);
      // if we have a range big enough to fit the entity, assume that the switch is unreachable
      while (open) {
        if (open.range > 0.0 && pz0 >= open.bottom && pz1 <= open.top) break;
        open = open.next;
      }
      if (!open) failSound = true;
    }
  }

  return false;
}


//==========================================================================
//
//  IsSwitchUseBlockedByLine
//
//  check if we should stop at this line
//  this is used only when "check switch range" option is on
//
//==========================================================================
final bool IsSwitchUseBlockedByLine (line_t *ld, int side, TVec hitpoint) {
  if (ld.special && Level.CompatUseBlocking) return true;

  // check if this line should block using
  // we have to do it, because opening check is not done in interceptor

  if (ld.sidenum[side] < 0) return false; // wtf?!

  float ehgt = fmax(0.0, Height);
  //float ez0 = Origin.z;
  //float ez1 = ez0+ehgt;
  // tracing started at the center of the entity
  float ez0 = hitpoint.z-ehgt*0.5;
  float ez1 = ez0+ehgt;

  float pz0 = ez0+ehgt*0.3;
  float pz1 = ez1-ehgt*0.3;
  if (pz1 < pz0) { pz0 = ez0; pz1 = ez1; }

  // polyobjects?
  if (ld.pobject) {
    polyobj_t *po = ld.pobject;
    // 3d polyobject?
    if (po.posector) {
      // 3d pobj, check height
      if (pz0 >= po.pofloor.minz && pz1 <= po.poceiling.maxz) return true;
      return false;
    }
    // 2d polyobject is always takes the whole sector
    return true;
  }

  // not a polyobject

  // always block with one-sided wall
  if (!(ld.flags&ML_TWOSIDED)) return true;

  sector_t *fsec = (side ? ld.backsector : ld.frontsector);
  sector_t *bsec = (side ? ld.frontsector : ld.backsector);

  // always block with two-sided wall without any sector (just in case)
  if (!fsec || !bsec) return true;

  // check openings
  opening_t *open = XLevel.LineOpenings(ld, hitpoint, blockmask:default, do3dmidtex:true);
  #ifdef VV_DEBUG_USE_LINE
  printdebug("====================");
  for (opening_t *op = open; op; op = op.next) {
    printdebug("  opening: range=%s; bot=%s; top=%s; ez0=%s; ez1=%s; pz0=%s; pz1=%s; orgz=(%s:%s) outside=%B", op.range, op.bottom, op.top, ez0, ez1, pz0, pz1, Origin.z, Origin.z+ehgt, (ez1 <= open.bottom || ez0 >= open.top));
  }
  printdebug("====================");
  #endif
  // should have at least one range that intersects with an entity
  while (open) {
    if (open.range > 0.0 && !(pz1 <= open.bottom || pz0 >= open.top)) return false;
    open = open.next;
  }

  // blocking
  return true;
}


//==========================================================================
//
//  UseLines
//
//  Looks for special lines in front of the actor to activate
//
//==========================================================================
final bool UseLines (float UseRange, float UseThingRange, name FailSound,
                     optional bool delegate (line_t *ld) checkLineUseDg,
                     optional void delegate (line_t *ld) onLineUsedDg,
                     optional bool delegate (EntityEx th) checkThingUseDg,
                     optional void delegate (EntityEx th) onThingUsedDg)
{

  if (!Level.Game.IsAuthority) return false;

  //printdebug("%C: UseLines! thing range:%s; line range:%s", self, UseThingRange, UseRange);

  TVec useDir;
  AngleVector(Angles, out useDir);

  UseRange = fmax(1.0, UseRange);
  UseThingRange = fmax(1.0, UseThingRange);

  // calculate max use distances for things and lines
  float maxUseRange = fmax(UseRange, UseThingRange);
  float maxThingFrac = 0.0;
  float maxLineFrac = 0.0;
  if (UseRange == UseThingRange) {
    maxThingFrac = 1.0;
    maxLineFrac = 1.0;
  } else {
    maxThingFrac = UseThingRange/maxUseRange;
    maxLineFrac = UseRange/maxUseRange;
  }

  float ehgt = fmax(0.0, Height);

  TVec start = Origin+vector(0.0, 0.0, ehgt*0.5);
  TVec end = start+maxUseRange*useDir;

  //float sz0 = start.z;
  //float sz1 = sz0+ehgt;

  float ez0 = Origin.z;
  float ez1 = ez0+ehgt;
  //float pheight = ez0+ehgt/2.0;

  //bool hitAnything = false; // set if anything useable was reached
  bool usedAnything = false; // set if anything was used (either a thing or a line)
  bool retvalue = false; // return value
  bool triedLine = false; // set if any line with special was withing a reach (used to check if we need to call sector use interception)
  bool needFailSound = false;

  bool buttonSuccess;
  int useType, useSide;
  line_t *ld;
  opening_t *open;

  EntityEx ee;
  intercept_t in;

  // 0: default
  // 1: never
  // 2: always
  int forceCheckRange = clamp(GetCvarI('g_switch_range_check_override'), 0, 2);
  if (forceCheckRange == 0) forceCheckRange = (Level.bNoCheckSwitchRange ? 1 : Level.bCheckSwitchRange ? 2 : 0);

  // do not check openings in interceptor
  foreach PathTraverse(out in, start, end, PT_ADDLINES|PT_ADDTHINGS|PT_NOOPENS, SPF_NOBLOCKING, ML_BLOCKEVERYTHING|ML_BLOCKUSE) {
    if (in.bIsAPlane) break; // plane hit, nothing to use

    if (in.bIsALine) {
      // line hit
      #ifdef VV_DEBUG_USE_LINE
      printdebug("UseLines: line #%s; frac=%s (limit=%s); special=%s; blocking=%B", in.line-&XLevel.Lines[0], in.frac, maxLineFrac, in.line.special, in.bIsABlockingLine);
      #endif
      if (in.frac > maxLineFrac) continue; // cannot reach
      ld = in.line;

      if (ld.special) triedLine = true;

      // check 3d pobj line
      if (ld.pobject && ld.pobject.posector) {
        polyobj_t *po = ld.pobject;
        // 3d pobj, check height
        if (ez1 <= po.pofloor.minz || ez0 >= po.poceiling.maxz) continue;
      }

      // check delegate callback
      if (checkLineUseDg && !checkLineUseDg(ld)) continue;

      //hitAnything = true; // something was hit

      // can use this line?
      useSide = -1; // special flag
      if (ld.special && (ld.SpacFlags&(SPAC_Use|SPAC_UseThrough|SPAC_UseBack))) {
        if (in.side == 1) {
          // back side
          if ((ld.SpacFlags&SPAC_UseBack) && ld.backsector) {
            useType = SPAC_UseBack;
            useSide = 1;
          }
        } else {
          // front side
          if ((ld.SpacFlags&(SPAC_UseBack|SPAC_Use|SPAC_UseThrough)) != SPAC_UseBack) {
            // can be used from front
            useType = SPAC_Use;
            useSide = 0;
          }
        }
      }

      if (useSide < 0) {
        #ifdef VV_DEBUG_USE_LINE
        printdebug("UseLines:   line #%s: cannot use", in.line-&XLevel.Lines[0]);
        #endif
        if (!needFailSound) {
          if (!(ld.flags&ML_TWOSIDED)) {
            needFailSound = true;
          } else {
            float pz0 = ez0+ehgt*0.3;
            float pz1 = ez1-ehgt*0.3;
            if (pz1 < pz0) {
              pz0 = ez0;
              pz1 = ez1;
            }
            // check openings to determine if we need "fail" sound
            open = XLevel.LineOpenings(ld, in.hitpoint, blockmask:default, do3dmidtex:true);
            // if we have a range big enough to fit the entity, assume that the switch is unreachable
            while (open) {
              if (open.range > 0.0 && pz0 >= open.bottom && pz1 <= open.top) break;
              open = open.next;
            }
            if (!open) needFailSound = true;
          }
        }
        // if `Level.CompatUseBlocking` is set, any special blocks further use
        if (in.bIsABlockingLine || (ld.special && Level.CompatUseBlocking)) break;
        if ((ld.flags&ML_3DMIDTEX) || // always check 3d midtex
            forceCheckRange > 1 || // always check if forced
            (forceCheckRange == 0 && (ld.flags&ML_CHECKSWITCHRANGE))) // check if default and line flag is set
        {
          if (IsSwitchUseBlockedByLine(ld, in.side, in.hitpoint)) {
            #ifdef VV_DEBUG_USE_LINE
            printdebug("UseLines:   line #%s: blocked tracing", in.line-&XLevel.Lines[0]);
            #endif
            break;
          }
        }
        continue;
      }
      #ifdef VV_DEBUG_USE_LINE
      printdebug("UseLines:   line #%s: use side %s", in.line-&XLevel.Lines[0], useSide);
      #endif

      // check switch range
      // do we need to check z range?
      // GZDoom forces this check for 3d midtex
      if ((ld.flags&ML_3DMIDTEX) || // always check 3d midtex
          forceCheckRange > 1 || // always check if forced
          (forceCheckRange == 0 && (ld.flags&ML_CHECKSWITCHRANGE))) // check if default and line flag is set
      {
        if (in.bIsABlockingLine) needFailSound = true;
        if (!CheckSwitchRange(ld, useSide, in.hitpoint, ref needFailSound)) {
          #ifdef VV_DEBUG_USE_LINE
          printdebug("UseLines:   line #%s: failed switch range check", in.line-&XLevel.Lines[0]);
          #endif
          if (in.bIsABlockingLine || IsSwitchUseBlockedByLine(ld, useSide, in.hitpoint)) {
            #ifdef VV_DEBUG_USE_LINE
            printdebug("UseLines:   line #%s: blocked tracing", in.line-&XLevel.Lines[0]);
            #endif
            break;
          }
          continue;
        }
        #ifdef VV_DEBUG_USE_LINE
        printdebug("UseLines:   line #%s: passed switch range check", in.line-&XLevel.Lines[0]);
        #endif
      }

      if (LineSpecialLevelInfo(Level).ActivateLine(ld, self, useSide, useType, out buttonSuccess)) {
        #ifdef VV_DEBUG_USE_LINE
        printdebug("UseLines:   line #%s: used (buttonSuccess=%s)", in.line-&XLevel.Lines[0], buttonSuccess);
        #endif
        if (onLineUsedDg) onLineUsedDg(ld);
        retvalue = true;
        if (buttonSuccess) usedAnything = true;
      }

      if (in.bIsABlockingLine) break;

      //WAS can't use more than one special line in a row
      //jff 3/21/98 NOW multiple use allowed with enabling line flag
      if (Level.CompatUseBlocking) {
        if (!(ld.SpacFlags&SPAC_UseThrough)) break;
      } else if (ld.SpacFlags&SPAC_Use) {
        break;
      }

      #ifdef VV_DEBUG_USE_LINE
      printdebug("UseLines:   line #%s doesn't block using", in.line-&XLevel.Lines[0]);
      #endif
    } else {
      // thing hit
      if (in.frac > maxThingFrac) continue; // cannot reach

      // don't use self
      if (in.Thing == self) continue;

      // no need to check height, because we're doing 3d trace
      // check height
      //if (sz0 >= in.Thing.Origin.z+in.Thing.Height || sz1 <= in.Thing.Origin.z) continue;

      ee = EntityEx(in.Thing);
      if (!ee) continue;
      if (checkThingUseDg && !checkThingUseDg(ee)) continue;

      //printdebug("%C: trying to use thing %C(%s)", self, ee, ee.UniqueId);
      if (!UseThing(ee)) {
        //printdebug("%C:   used thing %C(%s)", self, ee, ee.UniqueId);
        if (!needFailSound) {
          if (ee.bSolid && !ee.bCorpse && !ee.bMissile && !ee.bMonster && !ee.bInvisible) needFailSound = true;
        }
        continue;
      }

      // it is used, no need to scan further
      //hitAnything = true;
      if (onThingUsedDg) onThingUsedDg(ee);
      retvalue = true;
      usedAnything = true;
      break;
    }
  }

  // let sector intercept the use
  if (!usedAnything && Sector && Sector->ActionList) {
    //k8: dunno, this looks like absolute idiocity, but kdizd doesn't work without it
    if (/*!triedLine &&*/ SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_Use)) {
      usedAnything = true;
      retvalue = true;
    }
    if (triedLine && SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_UseWall)) {
      usedAnything = true;
      retvalue = true;
    }
  }

  //if (!usedAnything && FailSound && hitAnything) PlaySound(FailSound, CHAN_VOICE);
  if (!usedAnything && FailSound && needFailSound) PlaySound(FailSound, CHAN_VOICE);

  return retvalue;
}


//==========================================================================
//
//  UseThing
//
//  returns `true` if the thing was succesfully used
//
//==========================================================================
bool UseThing (EntityEx Other) {
  //print("%C: UseThing: 000: Other=%C; bNoInteraction=%B", self, Other, Other.bNoInteraction);
  if (Other.bNoInteraction) return false; //k8: just in case
  if (!Level.Game.IsAuthority) return false;

  //print("UseThing000: self=%C; Other=%C; Other.bUseSpecial=%s; Other.Special=%s", self, Other, Other.bUseSpecial, Other.Special);
  if (Other.bUseSpecial && Other.Special) {
    auto swd = SwitchableDecoration(Other);
    if (swd && swd.ActivationType) {
      printwarn("activation types for thing specials aren't implemented yet! %C:ActivationType=0x%08x", Other, swd.ActivationType);
    }
    if (Level.ExecuteActionSpecial(Other.Special, Other.Args[0], Other.Args[1], Other.Args[2], Other.Args[3], Other.Args[4], nullptr, 0, self)) {
      if (swd && (swd.ActivationType&SwitchableDecoration::AF_ClearSpecial)) { Other.Special = 0; foreach (ref auto v; Other.Args) v = 0; }
      return true;
    }
  }
  if (Other.bUseSpecial) {
    auto swd = SwitchableDecoration(Other);
    if (swd && swd.ActivationType) {
      //print("UseThing001: SWD! self=%C; Other=%C", self, Other);
      if (swd.Activate(self)) return true;
    }
  }
  //print("UseThing002: self=%C; Other=%C", self, Other);
  return LineSpecialLevelInfo(Level).StartConversation(self, Other);
}


//==========================================================================
//
//  IsSentient
//
//  killough 11/98:
//  Whether an object is "sentient" or not.
//  Used for environmental influences.
//
//==========================================================================
final bool IsSentient () {
  return Health > 0 && SeeState;
}


//==========================================================================
//
//  IsFast
//
//==========================================================================
final bool IsFast () {
  if (bAlwaysFast) return true;
  if (bNeverFast) return false;
  return (Level.Game.fastparm == GameInfo::FastModeFast);
}


//==========================================================================
//
//  RespawnResetFlags
//
//  reset most of the flags to the default values on respawn
//
//==========================================================================
void RespawnResetFlags () {
  //k8: restore these too
  RenderStyle = default.RenderStyle;
  Alpha = default.Alpha;
  Translation = default.Translation;
  StencilColor = default.StencilColor;
  FloorClip = default.FloorClip;
  ScaleX = default.ScaleX;
  ScaleY = default.ScaleY;


  bSolid = default.bSolid;
  bNoGravity = default.bNoGravity;
  bDropOff = default.bDropOff;
  bFloat = default.bFloat;
  bMissile = default.bMissile;
  bCorpse = default.bCorpse;
  bMonster = default.bMonster;
  bBlasted = default.bBlasted;
  bFly = default.bFly;
  bFloorClip = default.bFloorClip;
  bOnMobj = default.bOnMobj;
  bPassMobj = default.bPassMobj;
  bTelestomp = default.bTelestomp;
  bFloatBob = default.bFloatBob;
  bCantLeaveFloorpic = default.bCantLeaveFloorpic;
  bIgnoreFloorStep = default.bIgnoreFloorStep;
  bIgnoreCeilingStep = default.bIgnoreCeilingStep;
  bDontOverlap = default.bDontOverlap;
  bActLikeBridge = default.bActLikeBridge;
  bNoDropOff = default.bNoDropOff;
  bAvoidingDropoff = default.bAvoidingDropoff;

  bSpecial = default.bSpecial;
  bShootable = default.bShootable;
  bAmbush = default.bAmbush;
  bJustHit = default.bJustHit;
  bJustAttacked = default.bJustAttacked;
  bSpawnCeiling = default.bSpawnCeiling;
  bPickUp = default.bPickUp;
  bDropped = default.bDropped;
  bNoBlood = default.bNoBlood;
  bNoBloodDecals = default.bNoBloodDecals; //k8:???
  bPuffNoDecals = default.bPuffNoDecals; //k8:???
  bPuffForceDecals = default.bPuffForceDecals; //k8:???
  bInFloat = default.bInFloat;
  bSkullFly = default.bSkullFly;
  bCountKill = default.bCountKill;
  bCountItem = default.bCountItem;
  bWindThrust = default.bWindThrust;
  bActivateImpact = default.bActivateImpact;
  bActivatePushWall = default.bActivatePushWall;
  bActivateMCross = default.bActivateMCross;
  bActivatePCross = default.bActivatePCross;
  //bDormant ???
  //bWaterJump ???
  bNoTeleport = default.bNoTeleport;
  //bTelestomp ???
  bCannotPush = default.bCannotPush;
  bSmallSplash = default.bSmallSplash; //k8:???
  bNoSplash = default.bNoSplash;
  //bStaticLight ???
  //bStaticLightSpawned ???
  //bDynamicLight ???
  //bLeaveTrail ???
  //bLeaveTrail2 ???
  bTriggerHappy = default.bTriggerHappy;
  //bOnmobjCopyVel ???
  bNoBounceSound = default.bNoBounceSound;
  bNoWallBounceSnd = default.bNoWallBounceSnd;
  bNoSplashAlert = default.bNoSplashAlert; //k8:???
  bBounceSky = default.bBounceSky; //k8:???
  bExplodeOnSky = default.bExplodeOnSky;
  bBounceWalls = default.bBounceWalls; //k8:???
  bBounceFloors = default.bBounceFloors; //k8:???
  bBounceCeilings = default.bBounceCeilings; //k8:???
  bBounceOnActors = default.bBounceOnActors;
  bBounceOnAllActors = default.bBounceOnAllActors; //k8:???
  bBounceAutoOff = default.bBounceAutoOff; //k8:???
  bBounceLikeHeretic = default.bBounceLikeHeretic; //k8:???
  bDontBounceShootables = default.bDontBounceShootables; //k8:???
  bBounceUseState = default.bBounceUseState; //k8:???
  bSlide = default.bSlide;
  bReflective = default.bReflective;
  bSeekerMissile = default.bSeekerMissile;
  bNoExplodeFloor = default.bNoExplodeFloor;
  bIceCorpse = default.bIceCorpse;
  bExplodeOnWater = default.bExplodeOnWater;
  bCanBounceWater = default.bCanBounceWater;
  bFallingFriction = default.bFallingFriction; //k8:???
  bNoRadiusDamage = default.bNoRadiusDamage;
  bCantAutoAim = default.bCantAutoAim; //k8:???
  bPuffOnActors = default.bPuffOnActors;
  bInvulnerable = default.bInvulnerable;
  //bFriendly ???
  bRandomise = default.bRandomise;
  bFullVolDeath = default.bFullVolDeath;
  //bExploCount ???
  bSpectral = default.bSpectral;
  bDamageInvulnerable = default.bDamageInvulnerable;
  //bSkullFlyInvulnerable ???
  bNoDamageThrust = default.bNoDamageThrust;
  //bConditionalFireDamage ???
  bNoExtremeDeath = default.bNoExtremeDeath;
  bExtremeDeath = default.bExtremeDeath;
  //bLightning ???
  //bHowlVictims ???
  bNoGrudge = default.bNoGrudge;
  bNeverTarget = default.bNeverTarget;
  bReallyNeverTarget = default.bReallyNeverTarget;
  bNoTargetSwitch = default.bNoTargetSwitch;
  bNoGravKill = default.bNoGravKill;
  bFaster = default.bFaster;
  bFastMelee = default.bFastMelee;
  bStanding = default.bStanding;
  bBoss = default.bBoss;
  bNonShootable = default.bNonShootable;
  bThruGhost = default.bThruGhost;
  bRip = default.bRip;
  bPushable = default.bPushable;
  bBloodlessImpact = default.bBloodlessImpact;
  bNoDeathmatch = default.bNoDeathmatch;
  //bTeleport ???
  bSpawnFloat = default.bSpawnFloat;
  bNoMorph = default.bNoMorph;
  bNoBlockMonst = default.bNoBlockMonst;
  bLookAllAround = default.bLookAllAround;
  //bNeutral ???
  //bStandMustSeeTarget ???
  bInCombat = default.bInCombat;
  bFullVolActive = default.bFullVolActive;
  //bDehackedSpecial ???
  bPuffParticles = default.bPuffParticles;
  //bExplodeParticles ???
  bStealth = default.bStealth;
  bChaseGoal = default.bChaseGoal;
  //bExplosionDontHurtSelf ???
  //bNoSightCheck ???
  //bHuntPlayers ???
  //bNoHatePlayers ???
  bStrifeDamage = default.bStrifeDamage;
  bDontBlast = default.bDontBlast;
  //bVisibilityPulse ???
  //bArgsDefined ???
  bShadow = default.bShadow;
  bGhost = default.bGhost;
  bBossDeath = default.bBossDeath;
  bNoIceDeath = default.bNoIceDeath;
  bDontTranslate = default.bDontTranslate;
  bMissileEvenMore = default.bMissileEvenMore;
  bNoLiftDrop = default.bNoLiftDrop;
  bStayMorphed = default.bStayMorphed;
  bCanBlast = default.bCanBlast;
  bShieldReflect = default.bShieldReflect;
  bMirrorReflect = default.bMirrorReflect; //k8:???
  bAimReflect = default.bAimReflect; //k8:???
  bDontShieldReflect = default.bDontShieldReflect; //k8:???
  bDeflect = default.bDeflect;
  bDontReflect = default.bDontReflect;
  bFireResist = default.bFireResist;
  //bLowSpectralResist ???
  bDontSquash = default.bDontSquash;
  bNoTeleOther = default.bNoTeleOther;
  bDontHurtClass = default.bDontHurtClass; //k8:???
  bDontHurtSpecies = default.bDontHurtSpecies;
  bDoHarmSpecies = default.bDoHarmSpecies;
  bDoHarmFriends = default.bDoHarmFriends;
  bNoDamage = default.bNoDamage;
  bDontGib = default.bDontGib;
  bNoPain = default.bNoPain;
  //bPainless ???
  //bForcePain ???
  //bCantSeek ???
  //bDontSeekInvisible ???
  bPierceArmor = default.bPierceArmor;
  bForceRadiusDmg = default.bForceRadiusDmg;
  bSpawnSoundSource = default.bSpawnSoundSource;
  bAlwaysPuff = default.bAlwaysPuff;
  bSynchronised = default.bSynchronised;
  bAlwaysFast = default.bAlwaysFast;
  bNeverFast = default.bNeverFast;
  //bAlwaysRespawn ???
  //bNeverRespawn ???
  bDontRip = default.bDontRip; //k8:???
  bCanUseWalls = default.bCanUseWalls;
  bInChase = false; //k8: i think so
  //bUseSpecial ???
  //bNoInfighting ???
  //bBloodSplatter ???
  //bDehExplosion ???
  //bNoVerticalMeleeRange ???
  //bSummonedMonster ???
  //bSeesDaggers ???
  //bPuffGetsOwner ???
  //bFrightened ???
  //bNoFear ???
  //bTouchy ???
  //bArmed ???
  //bJumpDown ???
  //bMoveWithSector ???
  //bNoTrigger ???
  //bBlockedBySolidActors ???
  //bThruActors ???
  //bThruSpecies ???
  //bMThruSpecies ???
  bNoTeleFrag = default.bNoTeleFrag; //k8:???
  bNoBossRip = default.bNoBossRip; //k8:???
  //bScreenSeeker ???
  bBumpSpecial = default.bBumpSpecial; //k8:???
  bMBFBounce = default.bMBFBounce; //k8:???
  //bAvoidsDropOffs ???
  //bNoTimeFreeze ???
  //bCrashed ???
  bDontThrust = default.bDontThrust;
  //bSeeInvisible ???
  //bAvoidMelee ???
  bHitTarget = default.bHitTarget; //k8:???
  bHitMaster = default.bHitMaster; //k8:???
  bHitTracer = default.bHitTracer; //k8:???
  bHitOwner = default.bHitOwner; //k8:???
  //bOldRadiusDamage ???

  DecalName = default.DecalName;
}


//==========================================================================
//
//  CalcFakeZMovement
//
//==========================================================================
override void CalcFakeZMovement (out TVec Ret, float DeltaTime) {
  // adjust height
  Ret = Origin;
  Ret.z += Velocity.z*DeltaTime;
  if (bFloat && Target) {
    // float down towards enemy if too close
    if (!bSkullFly && !bInFloat) {
      float dist = DistTo2(Target);
      float delta = Target.Origin.z+fmax(0.0, Height)/2.0-Ret.z;
      if (delta < 0.0 && dist < -(delta*3.0)) {
        Ret.z -= FloatSpeed*DeltaTime;
      } else if (delta > 0.0 && dist < delta*3.0) {
        Ret.z += FloatSpeed*DeltaTime;
      }
    }
  }
  if (bIsPlayer && bFly && Ret.z > FloorZ /*&& (XLevel.TicTime&2)*/) {
    //FIXME: this is time-dependent, rewrite!
    //Ret.z += sin(90.0*35.0/20.0*AngleMod360(int(XLevel.TicTime)))/2.0;
    Ret.z = PlayerEx(Player).CalcFlyZ(Ret.z);
  }
}


//===========================================================================
//
//  CanRaise
//
//===========================================================================
override state CanRaise () {
  if (!bCorpse) return none; // not a monster
  if (!Level.Game.IsAuthority) return none;

  if (StateTime != -1.0) {
    // not lying still yet; check frame flag
    if (!State) return none;
    if ((GetStateSpriteFrame(State)&FF_CANRAISE) == 0) return none;
  }

  return FindState('Raise');
}


//===========================================================================
//
//  DoThingRaise
//
//  `Mage` is set to the Entity that tries to resurrect this one
//  (can be `None` for level events)
//
//  `skipCheckPosition` is *specified* for decorate code
//
//===========================================================================
bool DoThingRaise (optional bool skipCheckPosition, optional EntityEx Mage) {
  state RaiseState = CanRaise();
  if (!RaiseState) return false; // monster doesn't have a raise state

  Velocity.x = 0.0;
  Velocity.y = 0.0;
  float OldHeight = Height;
  float OldRadius = Radius;
  bool OldSolid = bSolid;
  bSolid = true;
  //FIXME: need compatibility flag
  Height = default.Height;

  if (!skipCheckPosition) {
    if (!CheckPosition(Origin)) {
      Height = OldHeight;
      Radius = OldRadius;
      bSolid = OldSolid;
      return false; // doesn't fit here
    }
  }

  PlaySound('vile/raise', /*CHAN_BODY*/CHAN_AUTO);

  SetState(RaiseState);
  bShootable = true;
  bFloat = default.bFloat;
  bNoGravity = default.bNoGravity;
  bDropOff = false;
  bSolid = true;
  if (bCorpse) {
    // relink, because corpses could have a smaller radius
    UnlinkFromWorld();
    bCorpse = false;
    LinkToWorld();
  }
  Health = InitialHealth;
  Target = none;
  LastEnemy = none;
  bCorpseFlipped = false; // unflip it

  // if it counts as kill, count it as another one
  if (CountsAsKill()) ++Level.TotalKills;
  return true;
}


//==========================================================================
//
//  GetInfighting
//
//  <0: none (except very special cases)
//   0: normal
//  >0: total infighting
//
//==========================================================================
final int GetInfighting () {
  if (Level.PerfectHatredMode&LevelInfo::PHM_INFIGHTING) return 1;
  if (bNoInfighting) return -1;
  if (Level.Infighting) return Level.Infighting;
  return GetCvar('infighting');
}


//==========================================================================
//
//  IsFriend
//
//==========================================================================
final bool IsFriend (EntityEx Other) {
  if (!Other) return false;
  if (bFriendly && Other.bFriendly) {
    return !Level.Game.deathmatch || FriendPlayer == Other.FriendPlayer ||
           FriendPlayer == 0 || Other.FriendPlayer == 0;
  }
  return false;
}


//==========================================================================
//
//  IsHostile
//
//==========================================================================
final bool IsHostile (EntityEx Other) {
  if (!Other) return false;
  // if both monsters are not friendles, hostiles depend on infighting
  if (!bFriendly && !Other.bFriendly) return false;

  if (bFriendly && Other.bFriendly) {
    return Level.Game.deathmatch && FriendPlayer != Other.FriendPlayer &&
           FriendPlayer != 0 && Other.FriendPlayer != 0;
  }
  return true;
}


//==========================================================================
//
//  ClassifyActor
//
//==========================================================================
override int ClassifyActor () {
  int Ret = 0;
  if (bIsPlayer) {
    Ret |= ACTOR_PLAYER;
    Ret |= (Player.PlayerState == PST_DEAD ? ACTOR_DEAD : ACTOR_ALIVE);
    if (Player.MO != self) Ret |= ACTOR_VOODOODOLL;
    if (Player.bIsBot) Ret |= ACTOR_BOT;
  } else if (bMonster) {
    Ret |= ACTOR_MONSTER;
    Ret |= (Health <= 0 ? ACTOR_DEAD : ACTOR_ALIVE);
  } else if (bMissile) {
    Ret |= ACTOR_MISSILE;
  } else {
    Ret |= ACTOR_GENERIC;
  }
  return Ret;
}


//==========================================================================
//
//  CountsAsKill
//
//==========================================================================
final bool CountsAsKill () {
  return (bCountKill && !bFriendly);
}


//==========================================================================
//
//  GetViewEntRenderParams
//
//==========================================================================
override void GetViewEntRenderParams (ref float OutAlpha, ref int OutRenderStyle) {
  if (Inventory) {
    Inventory.GetViewEntRenderParams(OutAlpha, OutRenderStyle);
  }
}


//==========================================================================
//
//  CopyFriendliness
//
//==========================================================================
void CopyFriendliness (EntityEx Src, bool ChangeTarget) {
  Level.TotalKills -= CountsAsKill();
  TIDToHate = Src.TIDToHate;
  LastLook = Src.LastLook;
  LastLookActor = Src.LastLookActor;
  bFriendly = Src.bFriendly;
  bNoSightCheck = Src.bNoSightCheck;
  bHuntPlayers = Src.bHuntPlayers;
  bNoHatePlayers = Src.bNoHatePlayers;
  FriendPlayer = Src.FriendPlayer;
  Level.TotalKills += CountsAsKill();
  if (ChangeTarget && Src.Target && !Src.Target.bNeverTarget && !Src.Target.bReallyNeverTarget) {
    Target = Src.Target;
    LastHeard = Src.Target;
  }
}


//==========================================================================
//
//  IsTeammate
//
//==========================================================================
bool IsTeammate (EntityEx Other) {
  return bIsPlayer && Other.bIsPlayer && Level.Game.netgame && !Level.Game.deathmatch;
}


//==========================================================================
//
//  IsNotAttackingMaster
//
//==========================================================================
bool IsNotAttackingMaster (EntityEx Other) {
  return false;
}


//==========================================================================
//
//  IsMaster
//
//==========================================================================
bool IsMaster (EntityEx Other) {
  return false;
}


//==========================================================================
//
//  IsServant
//
//==========================================================================
bool IsServant () {
  return false;
}


//==========================================================================
//
//  TouchSpecial
//
//==========================================================================
void TouchSpecial (EntityEx Toucher, optional bool noflash) {
}


//==========================================================================
//
//  CheckInventoryRestrictions
//
//  returns `false` if not allowed to pickup
//
//==========================================================================
bool CheckInventoryRestrictions (EntityEx Toucher) {
  return true;
}


//==========================================================================
//
//  checkIfTargetInLOS
//
//  workhorse for following decorate LOS checks
//
//==========================================================================
final bool checkIfTargetInLOS (optional float Fov, optional int flags, optional float distmax, optional float distclose) {
  if (distmax == 0) distmax = 8192;
  Fov = fabs(Fov);

  // according to https://zdoom.org/wiki/A_JumpIfTargetInLOS
  if ((flags&JLOSF_PROJECTILE) && !bMissile) flags &= ~JLOSF_PROJECTILE;

  EntityEx Targ;
  if (!bIsPlayer) {
    Targ = Target;
    // according to https://zdoom.org/wiki/A_JumpIfTargetInLOS
         if (flags&JLOSF_CHECKMASTER) Targ = Master;
    else if (flags&JLOSF_CHECKTRACER) Targ = Tracer;
    else if (flags&JLOSF_PROJECTILE) Targ = (bSeekerMissile ? Tracer : none);
  } else {
    // this is prolly called from weapon code, so target is what we have in player's crosshair
    //TVec Dir;
    //Targ = Aim(Dir, distmax/*16.0*64.0*/); // old code
    //k8: emulate autoaim in any case
    /*
    bool noAAim = !PlayerEx(Player).bAutoAim, noAAVert = false;
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (Wpn && Wpn.IsAutoaimDisabled()) noAAim = true; //bNoAutoaim;
    if (flags&JLOSF_NOAUTOAIM) noAAim = true;
    noAAVert = noAAim;
    */
    bool noAAim = !!(flags&JLOSF_NOAUTOAIM);
    bool noAAVert = noAAim;
    Targ = Aim(nullptr, 8192/*16*64*/, Angles.yaw, noAutoaim:noAAim, noVertAutoAim:noAAVert);
  }

  // moved here from `!bIsPlayer`
  if (!Targ) return false;

  // check target type flags before other, more expensive flags

  // combatant?
  if (flags&JLOSF_COMBATANTONLY) {
    if (!Targ.bIsPlayer && !Targ.bMonster) return false;
    if (Targ.bCorpse) return false; //k8: i added this too, as corpse is not a combatant
  }

  // dead?
  if ((flags&JLOSF_DEADNOJUMP) && Targ.Health <= 0) return false;

  // ally?
  if (flags&JLOSF_ALLYNOJUMP) {
    //FIXME: incomplete
    if (Targ == self || (bIsPlayer && Targ.bFriendly)) return false;
  }

  // check distance
  if (distclose > 0 && DistTo2(Targ) <= distclose) {
    // "close" in effect, fix flags and fov
    if (flags&JLOSF_CLOSENOJUMP) {
      // it doesn't matter what we'll do here, no jump will be taken
      return false;
    }
    if (flags&JLOSF_CLOSENOFOV) Fov = 0; // all-around vision
    if (flags&JLOSF_CLOSENOSIGHT) flags |= JLOSF_NOSIGHT;
  }

  // check sight
  if (!(flags&JLOSF_NOSIGHT)) {
    //k8: dunno, "better sight" should not be in effect here, i think
    if (flags&JLOSF_TARGETLOS) {
      if (!Targ.CanSee(self, disableBetterSight:true)) return false;
    } else {
      if (!CanSee(Targ, disableBetterSight:true)) return false;
    }
  }

  // check FOV
  if (Fov && Fov < 360.0) {
    if (flags&JLOSF_FLIPFOV) {
      // target fov
      float Ang = AngleMod180(atan2(Origin.y-Targ.Origin.y, Origin.x-Targ.Origin.x)-Targ.Angles.yaw);
      if (fabs(Ang) > Fov/2.0) return false;
    } else {
      // our fov
      float Ang = AngleMod180(atan2(Targ.Origin.y-Origin.y, Targ.Origin.x-Origin.x)-Angles.yaw);
      if (fabs(Ang) > Fov/2.0) return false;
    }
  }

  // all checks passed
  return true;
}


//==========================================================================
//
//  GetViewHeight
//
//==========================================================================
override float GetViewHeight () {
  if (bIsPlayer) {
    auto plr = PlayerEx(Player);
    if (plr) return plr.ViewHeight;
  }
  // check for camera
  foreach (auto playnum; 0..MAXPLAYERS) {
    auto plr = BasePlayer(Level.Game.Players[playnum]);
    if (!plr) continue;
    if (plr.Camera == self) return CameraHeight;
  }
  // defaults to actor half-height
  return ::GetViewHeight();
}


//==========================================================================
//
//  DaggerAlert
//
//==========================================================================
void DaggerAlert (EntityEx atarget, EntityEx emitter) {
  Entity looker;

  if (emitter.LastHeard) return;
  if (emitter.Health <= 0) return;
  if (!emitter.bMonster) return;
  if (emitter.bInCombat) return;
  emitter.bInCombat = true;

  emitter.Target = atarget;
  emitter.SetPainState('Dagger');

  for (looker = Sector->ThingList; looker; looker = looker.SNext) {
    if (looker == emitter || looker == atarget) continue;
    if (looker.Health <= 0) continue;
    EntityEx ee = EntityEx(looker);
    if (!ee) continue;
    if (!ee.bSeesDaggers) continue;
    if (!ee.bInCombat) {
      if (!looker.CanSee(atarget) && !looker.CanSee(emitter)) continue;
      ee.Target = atarget;
      looker.PlaySound(SightSound, CHAN_VOICE);
      if (ee.SeeState) looker.SetState(ee.SeeState);
      ee.bInCombat = true;
    }
  }
}


//==========================================================================
//
//  IsSectorFloorLiquid
//
//==========================================================================
static bool IsSectorFloorLiquid (sector_t *sec) {
  if (!sec) return false; // just in case
  // animated is always liquid (for now)
  if (IsAnimatedTexture(sec.floor.pic)) return true;
  // check terrain
  VTerrainInfo *ti = TerrainType(sec.floor.pic, false); // not only for player
  if (ti && ti.bLiquid) return true;
  // detect by texture name
  name fpname = GetTextureName(sec.floor.pic);
  // slime13 and further are normal floors, not liquids
  if (fpname == 'slime10' || fpname == 'slime11' || fpname == 'slime12') {
    return true;
  }
  auto tname = string(fpname);
  return
    globmatch(tname, "*water*", caseSensitive:false) ||
    globmatch(tname, "*nukage*", caseSensitive:false) ||
    globmatch(tname, "*lava*", caseSensitive:false) ||
    globmatch(tname, "*blood*", caseSensitive:false) ||
    globmatch(tname, "*slime0*", caseSensitive:false) ||
    globmatch(tname, "*slimage*", caseSensitive:false) ||
    globmatch(tname, "f_watr*", caseSensitive:false); // Strife water
}


//==========================================================================
//
//  A_DormantWakeupInternal
//
//==========================================================================
final void A_DormantWakeupInternal () {
  bInvisible = false;
  bSpecial = true;
  SetState(IdleState);

  // spawn a teleport fog at the new spot
  EntityEx A = SpawnEntityChecked(class!EntityEx, ItemFog, Origin);
  if (A && !A.IsDestroyed) A.PlaySound('misc/spawn', CHAN_ITEM);
}


// ////////////////////////////////////////////////////////////////////////// //
states {
DehackedDormantPickup:
  TNT1 A 1050
  TNT1 A -1 A_DormantWakeupInternal
  Stop
}
