//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************

//==========================================================================
//
//  Destroyed
//
//==========================================================================
override void Destroyed () {
  if (Role == ROLE_Authority) {
    //printdebug("%C:%s: entity dying...", self, self.UniqueId);
    if (Inventory) {
      //printdebug("  ...removing inventory...");
      // remove inventory
      while (Inventory) Inventory.Destroy();
      //printdebug("%C:%s: entity dying, inventory removed...", self, self.UniqueId);
    }
    //printdebug("%C:%s: entity dead.", self, self.UniqueId);
  }
  ::Destroyed();
}


//==========================================================================
//
//  FixLightFlatPosition
//
//  adjusts z, so it won't be too near to floor or ceiling
//  returns new z
//
//==========================================================================
float FixLightFlatPosition (sector_t *sector, float z, optional int thingidx) {
  // people loves to put lights into the floor/ceiling, and our tracer is not happy with those
  if (sector) {
    //float gaph = CeilingZ-FloorZ;
    float fz = GetPlanePointZ(ref sector.floor, Origin);
    float cz = GetPlanePointZ(ref sector.ceiling, Origin);
    //printdebug("light thing #%s: fz=%s; cz=%s; z=%s; fdist=%s, cdist=%s", mthing-&XLevel.Things[0], fz, cz, Origin.z, Origin.z-fz, cz-Origin.z);
    if (cz-fz >= 6) {
      if (z >= fz && z < fz+4) {
        if (specified_thingidx) printdebug("fixed z floor position for `%C` thing #%s (%s -> %s : %s)", self, thingidx, z, fz+4, fz);
        return fz+4;
      }
      if (z <= cz && z > cz-4) {
        if (specified_thingidx) printdebug("fixed z ceiling position for `%C` thing #%s (%s -> %s : %s)", self, thingidx, z, cz-4, cz);
        return cz-4;
      }
    }
  }
  return z;
}


//==========================================================================
//
//  SetOrigin2
//
//  this is used in spawners, to fix initial Z
//  pass -666 to force proper check (sorry for this hack)
//
//==========================================================================
final void SetOrigin2 (TVec origin, optional int properFloorCheck, optional float moreHeight) {
  UnlinkFromWorld();
  bIntrJustMoved = false; // disable movement interpolation

  Origin = origin;

  if (properFloorCheck != -666) {
         if (bIsPlayer) properFloorCheck = true;
    else if (!specified_properFloorCheck && bMonster) properFloorCheck = true;

    if (properFloorCheck) {
      if (origin.z == ONFLOORZ || origin.z == ONCEILINGZ) {
        properFloorCheck = false;
      }
    }
  }

  // set subsector and/or block links
  // use `CheckRelPosition()` here, we don't need to relink ourselves
  tmtrace_t tmtrace;
  GetFloorAndCeilingEx(out tmtrace, origin, collideWorld:false);
  float floorz = tmtrace.FloorZ;
  float ceilz = tmtrace.CeilingZ;

  auto oldz = Origin.z;

       if (origin.z == ONFLOORZ) Origin.z = floorz+moreHeight;
  else if (origin.z == ONCEILINGZ) Origin.z = ceilz-Height-moreHeight;
  else if (origin.z == FLOATRANDZ) {
    float space = ceilz-Height-floorz;
    if (space > 48.0) {
      space -= 40.0;
      Origin.z = space*Random()+floorz+40.0;
    } else {
      Origin.z = floorz;
    }
  } else if (bFloatBob) {
    Origin.z = floorz+Origin.z; // artifact z passed in as height
  }

  LinkToWorld(properFloorCheck:properFloorCheck);

  // don't fix positions for manual lights
  if ((self !isa 'BaseStaticLightSource') &&
      (self !isa 'DynamicLight'))
  {
    // if we are way higher than a floor, check for 3d floors.
    // this (coincidentally) also checks if a thing fits into a gap for
    // newly spawned entities. i hope it won't break anything.
    // solid non-monsters are decorations (usually); normalize their gap without world checking
    if (!properFloorCheck && Radius > 4 && // arbitrary limit
        !bNoInteraction && !bNoBlockmap && !bNoSector &&
        Origin.z-FloorZ > 0)
    {
      GetFloorAndCeilingEx(out tmtrace, Origin, collideWorld:(bMonster || bIsPlayer || !bSolid));
      if (FloorZ < tmtrace.FloorZ && tmtrace.FloorZ <= Origin.z) {
        #ifdef K8_DEVELOPER
        // `moreHeight` specified only for map things
        if (specified_moreHeight) {
          print("FIXED z for `%C`: z=%s; floorz=%s; FloorZ=%s; newFloorZ=%s; Radius=%s", self, Origin.z, floorz, FloorZ, tmtrace.FloorZ, Radius);
        }
        #endif
        EFloor = tmtrace.EFloor;
        ECeiling = tmtrace.ECeiling;
        FloorZ = tmtrace.FloorZ;
        CeilingZ = tmtrace.CeilingZ;
        DropOffZ = tmtrace.DropOffZ;
      }
    }
  }

  VTerrainInfo *TInfo = GetFloorType();
  if (bFloorClip && TInfo->bLiquid && Origin.z == FloorZ) {
    FloorClip = TInfo->FootClip;
  } else {
    FloorClip = 0.0;
  }
}


//**************************************************************************
//
//  RADIUS ATTACK
//
//**************************************************************************

//==========================================================================
//
//  RadiusAttack
//
//  Source is the creature that caused the explosion at spot.
//
//==========================================================================
final void RadiusAttack (EntityEx Source, int BombDamage, float BombDistance,
                         bool DamageSource, optional name BombDmgType, optional bool DoDamage,
                         optional int damagedistance, optional bool thrustZ,
                         optional float fullthrustdistance)
{
  EntityEx Other;

  if (!specified_thrustZ) thrustZ = DoDamage; //k8: see below
  if (!specified_DoDamage) DoDamage = true;

  EntityEx SpecieSrc = (Source ? Source : self);

  foreach RadiusThings(Other, Origin, BombDistance) {
    if (!Other || !Other.bShootable) continue;

    // check for actors that take no damage from concussion
    if (Other.bNoRadiusDamage && !bForceRadiusDmg) continue;

    if (!DamageSource && Other == Source) continue; // don't damage the source of the explosion

    // option for monsters that fire explosive projectiles not to hurt
    // monsters of the same class with it's projectiles.
    // controlled by the bDontHurtClass and bDontHurtSpecies flags.
    #if 0
    old code
      if (Source && !Other.bIsPlayer &&
          ((Source.bDontHurtClass && Other.Class == Source.Class) ||
           (Source.bDontHurtSpecies && IsSameSpecies(Other, Source))))
      {
        continue;
      }
    #else
    if (!Other.bIsPlayer) {
      if (Source &&
          ((Source.bDontHurtClass && Other.Class == Source.Class) ||
           (Source.bDontHurtSpecies && IsSameSpecies(Other, Source))))
      {
        continue;
      }
    } else {
      // shitfuck for clusterfuck (fuckin' morons!)
      //if (SpecieSrc) printdebug("%C(%s): Other=%C(%s); SpecieSrc=%C(%s); DmgType=%s", self, GetSpecies(), Other, Other.GetSpecies(), SpecieSrc, SpecieSrc.GetSpecies(), BombDmgType);
      if (SpecieSrc &&
          ((SpecieSrc.bDontHurtClass && Other.Class == self.Class) ||
           (Other.Species && SpecieSrc.bDontHurtSpecies && SpecieSrc.Species && IsSameSpecies(Other, SpecieSrc))))
      {
        continue;
      }
    }
    #endif

    float dist =
      !bOldRadiusDamage ?
      fmax(0.0, Length(Other.GetCenter()-GetCenter())-Other.Radius): // 3d
      fmax(0.0, Length2D(Other.GetCenter()-GetCenter())-Other.Radius); // 2d
    //print("000: %C: dist=%s; BombDistance=%s", self, dist, BombDistance);

    if (dist >= BombDistance && int(dist) > int(BombDistance)) continue; // out of range

    if (Other.CanSeeAdv(self)) {
      float dist2;

      // OK to damage, target is in direct path
      if (!specified_damagedistance) {
        dist2 = dist;
      } else {
        dist2 = fclamp(dist-float(damagedistance), 0.0, dist);
      }

      // k8: zero damage should still push a player to make mikoveyors work
      //     actually, it deals 1 damage in vanilla, but meh, i won't bother emulating it
      float dmgfloat = ((float(BombDamage)*RDFactor*(BombDistance-dist2))/BombDistance);
      int damage = int(dmgfloat);
      //print("000: %C: damage=%s; BombDamage=%s; RDFactor=%s; BombDistance=%s; flt=%s", Other, damage, BombDamage, RDFactor, BombDistance, dmgfloat);
      if (damage < 0) damage = 0;
      //if (damage <= 0) continue;

      if (damage > 0) {
        if (damage > 1) Other.SpawnBloodAtHeadExplosion(damage, Source);
        if (DoDamage) {
          Other.Damage(self, Source, damage, BombDmgType);
        } else {
          if (!bDontThrust) Other.bBlasted = true;
        }
      }

      if (!bDontThrust && !Other.bIceCorpse && (!DoDamage || !bNoDamageThrust)) {
        float Thrust = dmgfloat*0.5;
        if (specified_fullthrustdistance && fullthrustdistance != 0 && dist <= fullthrustdistance) {
          Thrust = BombDamage*RDFactor*0.5;
        }
        //k8: this is purely experimental, and prolly not right at all
        //    but with `10` it is more-or-less of the vanilla speed
        Thrust = fmax(/*(Other.bIsPlayer ? 10 : 0.0)*/10, Thrust);
        float VelZ = ((Other.Origin.z+(Other.Height*0.5))-Origin.z)*Thrust;
        if (Source != Other) VelZ *= 0.5; else VelZ *= 0.8;
        TVec Dir = Other.Origin-Origin;
        Dir.z = 0.0;
        if (Length2D(Dir) < 0.001) {
          // zero length. In this case Doom would use angle 0
          Dir = vector(1.0, 0.0, 0.0);
        }
        float othermass = fmax(1, Other.Mass);
        if (othermass < 10000) {
          TVec Vel = Normalise(Dir)*Thrust;
          Other.Velocity.x += (Vel.x/othermass)*35.0;
          Other.Velocity.y += (Vel.y/othermass)*35.0;
          if (thrustZ) Other.Velocity.z += (VelZ/othermass)*35.0;
          Other.Velocity = vclampscale(Other.Velocity, MAXMOVE); // just in case
        }
        //old:if (DoDamage) Other.Velocity.z += (VelZ / Other.Mass) * 35.0;
      }
    }
  }
}


//==========================================================================
//
//  TeleportMove
//
//==========================================================================
final bool TeleportMove (TVec org, optional bool ForceTelestomp, optional bool ForceProperFloorCheck) {
  EntityEx Other;
  float blockdist;

  // kill anything occupying the position
  // stomp on any things contacted
  foreach RadiusThings(Other, org, Radius) {
    if (!Other.bShootable) continue;

    blockdist = Other.Radius+Radius;

    if (fabs(Other.Origin.x-org.x) >= blockdist ||
        fabs(Other.Origin.y-org.y) >= blockdist)
    {
      // didn't hit it
      //print("TELEPORT CHECK: %C (%s) didin't touch %C (%s) (blockdist=%s; dist=%s)", self, self.Radius, Other, Other.Radius, blockdist, Other.Origin.xy-org.xy);
      continue;
    }

    // don't clip against self
    if (Other == self) continue;

    //print("TELEPORT CHECK: %C (%s) possibly touch %C (%s) (blockdist=%s; dist=%s)", self, self.Radius, Other, Other.Radius, blockdist, Other.Origin.xy-org.xy);
    // z-check
    if ((bPassMobj || Other.bActLikeBridge) && !Level.CompatNoPassOver &&
        (!bDontOverlap || !Other.bDontOverlap))
    {
      if (Other.Origin.z > org.z+Height) {
        //print("  *: otherz=%s; z=%s; z+h=%s", Other.Origin.z, org.z, org.z+Height);
        continue;
      }
      if (Other.Origin.z+Other.Height < org.z) {
        //print("  *: otherz=%s; z=%s; o+h=%s", Other.Origin.z, org.z, Other.Origin.z+Height);
        continue;
      }
    }

    //print("TELEPORT CHECK: %C (%s) really touch %C (%s)", self, self.Radius, Other, Other.Radius);
    // check if allowed to stomp things
    //k8: should we reject forced telefragging if `Other` denied it?
    if (!ForceTelestomp) {
      if ((/*!ForceTelestomp &&*/ !bTelestomp && !Level.bAllowMonsterTelefrags) || Other.bNoTeleFrag) {
        return false;
      }
    }

    Other.SpawnBloodAtHeadExplosion(max(Other.Health, 10000), self);
    // telefrags kills even invincible things
    Other.Damage(self, self, max(Other.Health, 10000), 'Telefrag', forced:true/*, spawnBlood:true*/);
  }

  // the move is ok,
  // so link the thing into its new position
  SetOrigin(org, properFloorCheck:(ForceProperFloorCheck ? -666 : 1));
  if (org.z == ONFLOORZ) Origin.z = FloorZ;

  return true;
}


//==========================================================================
//
//  Teleport
//
//==========================================================================
final bool Teleport (TVec Dst, float angle, bool DstFog, bool SrcFog, bool KeepDir, optional bool ForceTelestomp) {
  float fogDelta;
  EntityEx fog;
  bool ResetPitch = false;

  TVec oldOrg = Origin;
  float aboveFloor = Origin.z-FloorZ;
  if (Dst.z == ONFLOORZ) {
    sector_t *DstSec = XLevel.PointInSector(Dst);
    float DstFloorZ = GetPointZClamped(ref DstSec->floor, Dst);
    float DstCeilZ = GetPointZClamped(ref DstSec->floor, Dst);
    if (bIsPlayer) {
      if (FindInventory(PowerFlight) && aboveFloor) {
        Dst.z = DstFloorZ+aboveFloor;
        if (Dst.z+Height > DstCeilZ) Dst.z = DstCeilZ-Height;
      } else {
        Dst.z = DstFloorZ;
        if (!KeepDir) ResetPitch = true;
      }
    } else if (bMissile) {
      Dst.z = Dst.z+aboveFloor;
      if (Dst.z+Height > DstCeilZ) Dst.z = DstCeilZ-Height;
    } else {
      Dst.z = DstFloorZ;
    }
  }
  if (!TeleportMove(Dst, ForceTelestomp!optional)) return false;
  if (bIsPlayer && Player.MO == self) {
    Player.ViewOrg = Origin+vector(0.0, 0.0, PlayerEx(Player).ViewHeight);
    //auto pex = PlayerEx(Player);
    //if (pex) pex.lastViewOrgZForPfx = Origin.z;
    if (ResetPitch) Angles.pitch = 0.0;
  }
  // spawn teleport fog at source and destination
  fogDelta = (bMissile ? 0.0 : LineSpecialGameInfo(Level.Game).TeleFogHeight);
  if (SrcFog) Spawn(TeleportFog, oldOrg+vector(0.0, 0.0, fogDelta));
  if (DstFog) Spawn(TeleportFog, Origin+vector(20.0*cos(angle), 20.0*sin(angle), fogDelta));
  if (!KeepDir) {
    if (bIsPlayer && !FindInventory(PowerWeaponLevel2) && !FindInventory(PowerSpeed)) {
      // don't move for a bit, freeze player for about .5 sec
      ReactionTime = 0.5; // this is 18 ticks in vanilla, roughly 0.51428571428571 seconds
    }
    Angles.yaw = angle;
    if (bIsPlayer) Player.bFixAngle = true;
  }
  HandleFloorclip();
  if (bMissile) {
    float s, c;
    sincos(angle, out s, out c);
    Velocity.x = Speed*c;
    Velocity.y = Speed*s;
  } else if (!KeepDir) {
    // no fog doesn't alter the player's momentums
    Velocity = vector(0.0, 0.0, 0.0);
  }
  bIntrJustMoved = false; // disable movement interpolation
  return true;
}


//===========================================================================
//
//  MoveThing
//
//===========================================================================
override bool MoveThing (TVec Pos, bool Fog) {
  TVec OldOrg = Origin;

  UnlinkFromWorld();
  Origin = Pos;
  LinkToWorld(properFloorCheck:true); //k8: really?
  if (TestLocation()) {
    bIntrJustMoved = false; // disable movement interpolation
    if (Fog) {
      Spawn(TeleportFog, Pos+vector(0.0, 0.0, LineSpecialGameInfo(Level.Game).TeleFogHeight));
      Spawn(TeleportFog, OldOrg+vector(0.0, 0.0, LineSpecialGameInfo(Level.Game).TeleFogHeight));
    }
    return true;
  } else {
    UnlinkFromWorld();
    Origin = OldOrg;
    LinkToWorld(properFloorCheck:false);
    return false;
  }
}


//==========================================================================
//
//  TestLocation
//
//  Returns true if the mobj is not blocked by anything at its current
//  location, otherwise returns false.
//
//==========================================================================
final bool TestLocation () {
  if (!bColideWithThings && !bColideWithWorld) return true;
  if (CheckPosition(Origin)) {
    // XY is ok, now check Z
    if (Origin.z < FloorZ || Origin.z+Height > CeilingZ) {
      // bad Z
      return false;
    }
    return true;
  }
  return false;
}


//==========================================================================
//
//  Thrust
//
//==========================================================================
final void Thrust (float angle, float move) {
  float s, c;
  sincos(angle, out s, out c);
  Velocity.x += move*c*35.0;
  Velocity.y += move*s*35.0;
  // just in case
  Velocity = vclampscale(Velocity, MAXMOVE);
}


//==========================================================================
//
//  FaceActor
//
//  Returns 1 if 'source' needs to turn clockwise, or 0 if 'source' needs
// to turn counter clockwise.  'delta' is set to the amount 'source'
// needs to turn.
//
//==========================================================================
int FaceActor (EntityEx target, out float delta) {
  float angle1 = Angles.yaw;
  float angle2 = atan2(target.Origin.y-Origin.y, target.Origin.x-Origin.x);
  if (angle2 > angle1) {
    float diff = AngleMod360(angle2-angle1);
    if (diff > 180.0) {
      delta = 360.0-diff;
      return 0;
    } else {
      delta = diff;
      return 1;
    }
  } else {
    float diff = AngleMod360(angle1-angle2);
    if (diff > 180.0) {
      delta = 360.0-diff;
      return 1;
    } else {
      delta = diff;
      return 0;
    }
  }
}


//==========================================================================
//
//  HeightClip
//  called from `SectorChanged()`
//
//  Takes a valid thing and adjusts the thing->FloorZ, thing->CeilingZ, and
//  possibly thing->z. This is called for all nearby monsters whenever a
//  sector changes height. If the thing doesn't fit, the z will be set to
//  the lowest value and false will be returned.
//
//==========================================================================
final bool HeightClip (optional bool skipTriggers, optional bool skipObjects) {
  tmtrace_t tmtrace;
  float OldZ = Origin.z;
  bool onfloor = (Origin.z == FloorZ);

  // fix interpolation coordinates on exit
  scope(exit) if (bIntrJustMoved) LastMoveOrigin.z += Origin.z-OldZ;

  // "no interaction" and "no blockmap" just moving
  if (bNoInteraction || bNoBlockmap) {
    //k8: always move?
    if (bMoveWithSector && !bNoSector) {
      // faster checking
      GetFloorAndCeiling(out tmtrace);
      // update position
      EFloor = tmtrace.EFloor;
      ECeiling = tmtrace.ECeiling;
      FloorZ = tmtrace.FloorZ;
      CeilingZ = tmtrace.CeilingZ;
      if (bStickToFloor || bStickToCeiling) {
        Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
      } else {
        if (onfloor) {
          if (bNoInteraction || !bNoGravity || Origin.z < FloorZ) {
            Origin.z = FloorZ;
          }
        } else {
          // don't adjust a floating thing unless forced to
          if (Origin.z+Height > CeilingZ) Origin.z = CeilingZ-Height;
        }
      }
    } else if (bStickToFloor || bStickToCeiling) {
      GetFloorAndCeiling(out tmtrace);
      Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
    }
    // never blocks
    return true;
  }

  //if (bIsPlayer) printdebug("old: Floor=%s; Ceiling=%s; FloorZ=%s; CeilingZ=%s", EFloor.splane, ECeiling.splane, FloorZ, CeilingZ);

  bool isok = CheckRelPosition(out tmtrace, Origin);//, debugDump:bIsPlayer);
  // what about stranding a monster partially off an edge?

  EFloor = tmtrace.EFloor;
  ECeiling = tmtrace.ECeiling;
  FloorZ = tmtrace.FloorZ;
  CeilingZ = tmtrace.CeilingZ;

  //if (bIsPlayer) printdebug("new: Floor=%s; Ceiling=%s; FloorZ=%s; CeilingZ=%s; isok=%B; range=%s; height=%s", EFloor.splane, ECeiling.splane, FloorZ, CeilingZ, isok, CeilingZ-FloorZ, Height);

  if (onfloor && (!bNoGravity || !bNoLiftDrop || bMoveWithSector)) {
    // walking monsters rise and fall with the floor
    if ((Origin.z-FloorZ < 9.0) || bNoGravity || !XLevel.bExtended) {
      EntityEx onmo = EntityEx(CheckOnmobj());
      // do we have something over us?
      if (bSolid && onmo && onmo.bSolid) {
        // adjust height for the thing over us
        onmo.Origin.z += FloorZ-Origin.z;
        // don't adjust a floating monster unless forced to
        if (onmo.Origin.z+onmo.Height > CeilingZ) {
          onmo.Origin.z = CeilingZ-onmo.Height;
        }
        if (CeilingZ-(FloorZ+Height) < onmo.Height) {
          // things don't fit, stop
          //if (bIsPlayer) printdebug("   DONTFIT (0)!");
          return false;
        }
      }
      //if (bIsPlayer) printdebug("   FIT (0)!");
      Origin.z = FloorZ;
    }
  } else {
    // don't adjust a floating monster unless forced to
    if (Origin.z+Height > CeilingZ) {
      Origin.z = CeilingZ-Height;
    }
  }

  if (!skipTriggers) {
    CheckFakeFloorTriggers(OldZ);

    if (CeilingZ-FloorZ < Height) {
      if (bIceCorpse && bSolid) {
        Actor(self).A_FreezeDeathChunks();
        return true;
      } else {
        // doesn't fit, stop
        //if (bIsPlayer) printdebug("   DONTFIT (1)!");
        //if (tmtrace.BlockingLine) printdebug("%C: don't fit! line=%s; fz=%s; cz=%s", self, tmtrace.BlockingLine-&XLevel.Lines[0], FloorZ, CeilingZ);
        return false;
      }
    }
  }

  if (bStickToFloor || bStickToCeiling) {
    Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
  }

  // move static light, if there is any
  if (/*bStaticLight &&*/ bStaticLightSpawned) {
    Level.MoveStaticLightByOwner(self, Origin+LightOffset);
  }

  return true;
}


//==========================================================================
//
//  GetStateTime
//
//==========================================================================
override float GetStateTime (state AState, float AStateTime) {
  if (AState) {
    switch (GetStateTicKind(AState)) {
      //case StateTicKind.Normal: return AStateTime;
      case StateTicKind.Random: AStateTime = float(GetStateArgN(AState, 0)+trunci(Random()*(GetStateArgN(AState, 1)-GetStateArgN(AState, 0)+1)))/35.0f; break;
      //default: return AStateTime;
    }
    if (IsFast()) {
           if (bFaster && SeeState && StateIsInRange(AState, SeeState, none, 8)) AStateTime /= 2.0;
      else if (bFastMelee && MeleeState && StateIsInRange(AState, MeleeState, none, 3)) AStateTime /= 2.0;
      else {
        auto fff = GetStateSpriteFrame(AState);
        if (fff&FF_FAST) AStateTime /= 2.0;
      }
    } else if (Level.Game.fastparm == 2) {
      // slow monsters
      auto fff = GetStateSpriteFrame(AState);
      if (fff&FF_SLOW) AStateTime *= 2.0;
    }
  }
  return AStateTime;
}


//==========================================================================
//
//  NightmareRespawn
//
//==========================================================================
final void NightmareRespawn () {
  float z;

  ++SkillRespawnCount;

  float x = SpawnPoint.x;
  float y = SpawnPoint.y;

  // somthing is occupying it's position?
  if (!CheckPosition(vector(x, y, ONFLOORZ))) return; // no respwan

  // spawn a teleport fog at old spot
  EntityEx A = SpawnEntityChecked(class!EntityEx, TeleportFog, vector(Origin.x, Origin.y, ONFLOORZ));
  if (A) {
    A.Origin.z += LineSpecialGameInfo(Level.Game).TeleFogHeight;

    // spawn a teleport fog at the new spot
    A = SpawnEntityChecked(class!EntityEx, TeleportFog, vector(x, y, ONFLOORZ));
    if (A) A.Origin.z += LineSpecialGameInfo(Level.Game).TeleFogHeight;

    // spawn the new monster

    // spawn it
    if (bSpawnCeiling) z = ONCEILINGZ; else z = ONFLOORZ;

    // inherit attributes from deceased one
    A = SpawnEntityChecked(class!EntityEx, class!EntityEx(Class), vector(x, y, z), default, default, AllowReplace:false);
    if (A) {
      Level.CopyMThing(&SpawnPoint, &A.SpawnPoint);
      A.Angles.yaw = float(45*(SpawnPoint.angle/45));

      if (SpawnPoint.options&LineSpecialLevelInfo::MTF_AMBUSH) A.bAmbush = true;
      if (SpawnPoint.options&LineSpecialLevelInfo::MTF_STANDSTILL) A.bStanding = true;

      A.ReactionCount = 18;

      // copy custom translation
      //A.Translation = Translation;
      A.CopyTranslations(self);

      A.SkillRespawnCount = SkillRespawnCount;
    }
  }

  // remove the old monster
  Destroy();
}


//==========================================================================
//
//  ProcessHitFlags
//
//  returns `false` if hit something
//
//==========================================================================
final bool ProcessHitFlags (EntityEx Other, bool res) {
  if (res) return res; // `true` means "continue, no hit"
  if (!Other || Other == self || !bMissile) return res; //k8: only for missiles?
  if (bHitTarget) Target = Other;
  if (bHitMaster) Master = Other;
  if (bHitTracer) Tracer = Other;
  return res;
}


//==========================================================================
//
//  CheckDoBumpSpecial
//
//  returns `true` if activated
//
//==========================================================================
bool CheckDoBumpSpecial (EntityEx Other) {
  if (!Other || Other == self) return false; // can't
  // check for bBumpSpecial
  if (!bBumpSpecial) return false;
  // also, leave the bumper enough time to go away
  //FIXME: broken with hubs!
  if (XLevel.Time <= NextBumpTime) return false;
  // by default, only players can activate things by bumping into them
  auto swd = SwitchableDecoration(self);
  if (!swd) return false;
  // check if we can be hit
  if (!Other.bIsPlayer) {
    // check for switcable decorations
    if (((swd.ActivationType&SwitchableDecoration::AF_MonsterTrigger) && Other.bMonster) ||
        ((swd.ActivationType&SwitchableDecoration::AF_MissileTrigger) && Other.bMissile))
    {
      // ok
    } else {
      return false;
    }
  }
  // check for special action
  if (bUseSpecial && Special) {
    if (swd.ActivationType) printwarn("activation type for thing specials aren't implemented yet! %C:ActivationType=0x%08x", swd, swd.ActivationType);
    if (Level.ExecuteActionSpecial(swd.Special, swd.Args[0], swd.Args[1], swd.Args[2], swd.Args[3], swd.Args[4], nullptr, 0, self)) {
      if (swd.ActivationType&SwitchableDecoration::AF_ClearSpecial) { swd.Special = 0; foreach (ref auto v; swd.Args) v = 0; }
      NextBumpTime = XLevel.Time+1; // second
      return true;
    }
  }
  // do item action
  if (swd.ActivationType) {
    //print("UseThing001: SWD! self=%C; Other=%C", self, Other);
    if (swd.Activate(self)) {
      NextBumpTime = XLevel.Time+1; // second
      return true;
    }
  }
  // alas
  return false;
}


//==========================================================================
//
//  Touch
//
//  returns `false` if hit something
//
//==========================================================================
override bool Touch (Entity InOther) {
  bool solid;
  int damage;
  EntityEx Other = EntityEx(InOther);

  // for Korax Arena
  if (Other.IsTouched(self)) {
    return ProcessHitFlags(Other, !Other.bSolid && !Other.bSpecial && (!Other.bShootable || !Other.bTouchy) && !Other.bBlockedBySolidActors);
  }

  //k8: corpses won't block anything
  if (Other.bCorpse) return true;

  //k8: missile should hit shootable object even if it is non-solid
  if (bMissile) {
    if (!(Other.bSolid || Other.bShootable) && !Other.bSpecial && (!Other.bShootable || !Other.bTouchy) && !Other.bBlockedBySolidActors) return ProcessHitFlags(Other, true);
  } else {
    if (!Other.bSolid && !Other.bSpecial && (!Other.bShootable || !Other.bTouchy) && !Other.bBlockedBySolidActors) return ProcessHitFlags(Other, true);
  }

  if (bThruActors || Other.bThruActors) return ProcessHitFlags(Other, true);

  if (bThruSpecies && IsSameSpecies(Other, self)) return ProcessHitFlags(Other, true);

  // touchy object is alive, toucher is solid
  if (Other.bTouchy && bSolid && Other.Health > 0 &&
      // thing is an armed mine or a sentient thing
      (Other.bArmed || Other.IsSentient()) &&
      // either different classes or players
      (Other.bIsPlayer || Other.Class != Class) &&
      // or different species if DONTHARMSPECIES
      (!Other.bDontHurtSpecies || !IsSameSpecies(Other, self)) &&
      // touches vertically
      Other.Origin.z+Other.Height >= Origin.z && Origin.z+Height >= Other.Origin.z &&
      // prevents lost souls from exploding when fired by pain elementals
      (Other.Master != self && Master != Other))
  // difference with MBF: MBF hardcodes the LS/PE check and lets actors of the same species
  // but different classes trigger the touchiness, but that seems less straightforwards
  {
    bArmed = false; // Disarm
    Other.SpawnBloodAtHeadExplosion(Other.Health, self);
    Other.Damage(none, none, Other.Health); // kill object
    return ProcessHitFlags(Other, true);
  }

  CheckDoBumpSpecial(Other);

  // check for skulls slamming into things
  if (bSkullFly) return ProcessHitFlags(Other, Slam(Other));

  // check for blasted thing running into another
  if (bBlasted && Other.bShootable) {
    if (!Other.bBoss && Other.bMonster) {
      Other.Velocity.x += Velocity.x;
      Other.Velocity.y += Velocity.y;
      if ((Other.Velocity.x+Other.Velocity.y) > 3.0*35.0) {
        damage = (int(fmax(0, Mass))/100)+1;
        Other.SpawnBloodAtHeadExplosion(damage, self);
        Other.Damage(self, self, damage);
        damage = (int(fmax(0, Other.Mass))/100)+1;
        SpawnBloodAtHeadExplosion(damage>>2, Other);
        Damage(Other, Other, damage>>2);
      }
      return ProcessHitFlags(Other, false);
    }
  }

  // missiles can hit other things
  if (bMissile) {
    // check for a non-shootable mobj
    if (Other.bNonShootable) return ProcessHitFlags(Other, true);
    // check for passing through a ghost
    if (Other.bGhost && bThruGhost) return ProcessHitFlags(Other, true);

    if (bMThruSpecies && Target && IsSameSpecies(Target, self)) return ProcessHitFlags(Other, true);

    if ((BounceType == BOUNCE_Doom || BounceType == BOUNCE_Hexen) && MissileDamage == 0) {
      // yet ripper rips, not bounces, even if it doesn't do any damage!
      if (Target != Other && Other.bSolid && !Other.bCorpse) {
        //ProcessHitFlags(Other, false);
        #if 1
        if (!bRip || Other.bDontRip || (bNoBossRip && Other.bBoss)) {
          // not a ripper, bounce unconditionally
          return ProcessHitFlags(Other, false);
        } else {
          // ripper
          if (!Other.bIsPlayer) {
            // not a player
            if (Other.bMonster) {
              // monster
              if (!Other.IsSentient()) return ProcessHitFlags(Other, false); /* non-sentient monster */
            } else if (!Other.bMissile) {
              // not a monster, not a missile
              // non-shootable, or invulnerable, or has no health?
              //printwarn("%C: not m/m: %C -- shootable=%B; invuln=%B; health=%s", self, Other, Other.bShootable, Other.bInvulnerable, Other.Health);
              if (!Other.bShootable || Other.bInvulnerable || Other.Health <= 0) return ProcessHitFlags(Other, false); // hit it!
            }
          }
        }
        #else
        // ripper missiles should be processed as normal ones
        if (!bRip || Other.bDontRip) return ProcessHitFlags(Other, (Target == Other || !Other.bSolid || Other.bCorpse));
        #endif
      }
    }

    switch (SpecialMissileHit(Other)) {
      case 0: return ProcessHitFlags(Other, false);
      case 1: return ProcessHitFlags(Other, true);
    }

    if (Target) {
      // don't hit same species as originator
      if (!bHitOwner && Other == Target) return ProcessHitFlags(Other, true); // don't missile self
      // let players missile other players
      if (!Target.bIsPlayer && !Other.bIsPlayer) {
        int Inf = Target.GetInfighting();
        if (Inf < 0) {
          // monsters can't hurt each other, but make exception
          // depending on friendliness and hate status
          if (Target.bShootable) {
            if (!Other.bMonster) return ProcessHitFlags(Other, false);
            // hostile monsters can always hurt each other
            if (!Other.IsHostile(Target)) {
              // the same if the shooter hates the target
              if (!Other.TID || Target.TIDToHate != Other.TID) return ProcessHitFlags(Other, false);
            }
          }
        } else if (Inf == 0) {
          //print("TOUCH: self=%n; other=%n; inf=%d", GetClassName(Class), GetClassName(Other.Class), Inf);
          if (Other.IsFriend(Target)) return ProcessHitFlags(Other, false); // don't hurt friends
          //print("  not friends");
          if (Other.TIDToHate && Other.TIDToHate == Target.TIDToHate) {
            // don't hurt monsters that hate the same thing as you do
            return ProcessHitFlags(Other, false);
          }
          //print("  hates");
          //print("  species: target is '%n', other is '%n'", Target.GetSpecies(), Other.GetSpecies());
          //print("  species: target is '%s', other is '%s'", string(Target.GetSpecies()), string(Other.GetSpecies()));
          if (IsSameSpecies(Target, Other)) {
            // don't hurt same species, but only if the target isn't one's hostile
            if (!Other.IsHostile(Target)) {
              // allow hurting monsters the shooter hates
              if (Other.TID == 0 || Target.TIDToHate != Other.TID) return ProcessHitFlags(Other, false);
            }
          }
          //print("  different species");
        }
      }
    }

    if (!Other.bShootable) return ProcessHitFlags(Other, !Other.bSolid); // didn't do any damage

    // don't hit spectres with non-sigil weapons
    if (Other.bSpectral && !bSpectral) return ProcessHitFlags(Other, true);

    if (bRip && !Other.bDontRip) {
      if (!bNoBossRip || !Other.bBoss) {
        PlaySound('misc/ripslop', /*CHAN_BODY*/CHAN_AUTO);
        damage = GetMissileDamage(3, 2);
        if (!Other.bNoBlood && !Other.bReflective && !Other.bInvulnerable) {
          // ok to spawn some blood
          Other.SpawnBloodRipper(damage, self);
        }
        //printdebug("%C: ripper, other is %C", self, Other);
        Other.Damage(self, Target, damage, DamageType, spawnBlood:false); // we already spawned ripper blood
        if (Other.bPushable && !bCannotPush) {
          // push thing
          Other.Velocity.x += Velocity.x/4.0;
          Other.Velocity.y += Velocity.y/4.0;
        }
      }
      return ProcessHitFlags(Other, true);
    }

    // damage / explode
    damage = GetMissileDamage(bStrifeDamage ? 3 : 7, 1);
    if (damage > 0) {
      if (bBloodSplatter && !Other.bNoBlood && !Other.bReflective &&
          !Other.bInvulnerable && !Other.bDormant &&
          !bBloodlessImpact && P_Random() < 192)
      {
        TVec org = self.Origin;
        if (self.Radius > 0) org.z += self.Radius/2.0;
        Other.SpawnBloodSplatter(Origin, damage, org);
      }
      Other.SpawnBloodAtHeadExplosion(damage, self);
      Other.Damage(self, Target, damage, DamageType);
    }
    // don't traverse any more
    return ProcessHitFlags(Other, false);
  }

  if (Other.bPushable && !bCannotPush) {
    // push thing
    Other.Velocity.x += Velocity.x/4.0;
    Other.Velocity.y += Velocity.y/4.0;
  }

  solid = (Other.bSolid && Other.bColideWithThings && bSolid);

  // check for special pickup
  if (Other.bSpecial /*&& Other.Origin.z < Origin.z+Height-MaxStepHeight*/) {
    if (Other.bDehackedSpecial) {
      Other.TouchDehackedSpecial(self);
    } else {
      Other.TouchSpecial(self); // can remove thing
    }
    if (solid && (!Other || Other.IsDestroyed)) solid = false; // k8: it is no more
  }

  return ProcessHitFlags(Other, !solid);
}


//==========================================================================
//
//  IsTouched
//
//  For Korax Arena
//
//==========================================================================
bool IsTouched (Entity Toucher) {
  return false;
}


//===========================================================================
//
//  Slam
//
//===========================================================================
bool Slam (EntityEx Other) {
  bSkullFly = false;
  Velocity = vector(0.0, 0.0, 0.0);
  if (Health > 0) {
    if (!bDormant) {
      int damage = GetMissileDamage(7, 1);
      if (damage > 0) Other.SpawnBloodAtHead(damage, Origin);
      Other.Damage(self, self, damage, 'Melee');
      SetState(SeeState ? SeeState : IdleState);
    } else {
      SetState(IdleState);
      StateTime = -1.0;
    }
  }
  return false; // stop moving
}


//==========================================================================
//
//  GetMissileDamage
//
//==========================================================================
int GetMissileDamage (int Mask, int Add) {
  if (!MissileDamage) return 0;
  if (!Mask) return Add*MissileDamage;
  return ((P_Random()&Mask)+Add)*MissileDamage;
}


//==========================================================================
//
//  SpecialMissileHit
//
//==========================================================================
int SpecialMissileHit (EntityEx Other) {
  return -1;
}


//==========================================================================
//
//  GetSpecies
//
//==========================================================================
name GetSpecies () {
  if (Species) return name(Species);

  class Ret = Class;
  //  Go up in the inheritance hierarchy while there's a monster flag
  // and use the top one as species.
  if (bMonster) {
    while (class!EntityEx(GetClassParent(Ret)) &&
           class!EntityEx(GetClassParent(Ret)).default.bMonster)
    {
      Ret = GetClassParent(Ret);
    }
  }
  return GetClassName(Ret);
}


//==========================================================================
//
//  IsSameSpecies
//
//==========================================================================
static final bool IsSameSpecies (EntityEx a, EntityEx b) {
  if (!a || !b) return false;
  if (a == b) return true;

  return (nameicmp(a.GetSpecies(), b.GetSpecies()) == 0);
}


//===========================================================================
//
//  CheckForPushSpecial
//
//===========================================================================
override void CheckForPushSpecial (line_t *line, int side) {
  if (!bNoTrigger) {
    if (bActivatePushWall) {
      LineSpecialLevelInfo(Level).ActivateLine(line, self, side, SPAC_Push);
    } else if (bActivateImpact) {
      LineSpecialLevelInfo(Level).ActivateLine(line,
        Level.bMissilesActivateImpact || !bMissile || !Target ? self : Target, side, SPAC_Impact);
    }
  }
}


//==========================================================================
//
//  BlastedHitLine
//
//==========================================================================
override void BlastedHitLine () {
  int damage = int(fmax(0, Mass))>>5;
  if (damage > 0) SpawnBloodAtHeadExplosion(damage);
  Damage(none, none, damage);
}


//==========================================================================
//
//  CrossSpecialLine
//
//==========================================================================
override void CrossSpecialLine (line_t *ld, int side) {
  if (!ld) return; //k8: just in case
  if (!bNoTrigger) {
    if (bIsPlayer) {
      LineSpecialLevelInfo(Level).ActivateLine(ld, self, side, SPAC_Cross);
    } else if (bActivateMCross) {
      LineSpecialLevelInfo(Level).ActivateLine(ld, self, side, SPAC_MCross);
    } else if (bActivatePCross) {
      LineSpecialLevelInfo(Level).ActivateLine(ld, self, side, SPAC_PCross);
    } else if (ld->special == LNSPEC_Teleport ||
               ld->special == LNSPEC_TeleportNoFog ||
               ld->special == LNSPEC_TeleportLine ||
               ld->special == LNSPEC_TeleportNoStop)
    {
      // teleport hack
      LineSpecialLevelInfo(Level).ActivateLine(ld, self, side, SPAC_MCross);
    } else {
      LineSpecialLevelInfo(Level).ActivateLine(ld, self, side, SPAC_AnyCross);
    }
  }
}


//==========================================================================
//
//  Activate
//
//==========================================================================
bool Activate (EntityEx Activator) {
  //print("*** ACTIVATING THING %C (tid=%s); bMonster=%B; bDormant=%B; Target=%C; Master=%C; Tracer=%C", self, TID, bMonster, bDormant, Target, Master, Tracer);
  if (bMonster) {
    // Monster
    if (bDormant) {
      bDormant = false;
      StateTime = 0.1;
      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  Deactivate
//
//==========================================================================
bool Deactivate (EntityEx Activator) {
  if (bMonster) {
    // Monster
    if (!bDormant) {
      bDormant = true;
      state S = FindState('Inactive');
      if (S) {
        SetState(S);
      } else {
        StateTime = -1.0;
      }
      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  FaceMovementDirection
//
//==========================================================================
final void FaceMovementDirection () {
  switch (MoveDir) {
    case DI_EAST: Angles.yaw = 0.0; break;
    case DI_NORTHEAST: Angles.yaw = 45.0; break;
    case DI_NORTH: Angles.yaw = 90.0; break;
    case DI_NORTHWEST: Angles.yaw = 135.0; break;
    case DI_WEST: Angles.yaw = 180.0; break;
    case DI_SOUTHWEST: Angles.yaw = 225.0; break;
    case DI_SOUTH: Angles.yaw = 270.0; break;
    case DI_SOUTHEAST: Angles.yaw = 315.0; break;
  }
}


//==========================================================================
//
//  OnMapSpawn
//
//==========================================================================
override void OnMapSpawn (mthing_t *mthing) {
  ::OnMapSpawn(mthing);

  //printdebug("MAPSPAWN: %C (monster=%B; missile=%B) (%s)", self, bMonster, bMissile, GetClassLocationStr(Class));
  // k8: let's hope this will work as intended
  if (bMonster && IsFast()) ReactionCount = 0;

  LastLook = P_Random()%MAXPLAYERS;

  bCheckLineBlocking = false;
  bCheckLineBlockMonsters = false;
  if (!bNoInteraction && !bMissile) {
    bCheckLineBlocking = true;
    if (!bNoBlockMonst) bCheckLineBlockMonsters = true;
  }

  if (!IdleState) IdleState = FindState('Spawn');
  if (!SeeState) SeeState = FindState('See');
  if (!MeleeState) MeleeState = FindState('Melee');
  if (!MissileState) MissileState = FindState('Missile');

  if (Level.Game.fastparm == 1 && FastSpeed > 0) Speed = FastSpeed;

  if (CountsAsKill()) ++Level.TotalKills;
  if (bCountItem) ++Level.TotalItems;

  // clamp some properties
  Mass = (Mass.isinf ? 10000 : fclamp(Mass, 0, 10000));
  Velocity = vclampscale(Velocity, MAXMOVE);
  Speed = (Speed.isfinite ? fclamp(Speed, -MAXMOVE, MAXMOVE) : 0.0);
  FloatSpeed = (FloatSpeed.isfinite ? fclamp(FloatSpeed, -MAXMOVE, MAXMOVE) : 0.0);

  // set the state, but do not use SetState, because action routines can't be called yet
  // if the spawnstate has an action routine, it will not be called
  SetInitialState(IdleState);

  if (mthing) {
    if (bNoDeathmatch && Level.Game.deathmatch) {
      Destroy();
      return;
    }

    Level.CopyMThing(mthing, &SpawnPoint);

    float x = mthing->x;
    float y = mthing->y;
    float z;
         if (bSpawnCeiling) z = ONCEILINGZ;
    else if (bSpawnFloat) z = FLOATRANDZ;
    else if (bFloatBob) z = mthing->height;
    else z = ONFLOORZ;

    SetOrigin2(vector(x, y, z), moreHeight:mthing.height);
    //if (mthing.type == 9001 && mthing.tid == 55) printwarn("*** MapSpot sector: %s", Sector-&XLevel.Sectors[0]);
    //if (mthing-&XLevel.Things[0] == 114) printwarn("***id=%s: Sector=%s; height=%s; floorz=%s; radius=%s", UniqueId, Sector-&XLevel.Sectors[0], mthing->height, FloorZ, Radius);

    // no need to to this, it is already linked in `SetOrigin2()`
    //LinkToWorld(properFloorCheck:(bMonster || bIsPlayer));

    SetTID(mthing->tid);
    Special = mthing->special;
    if (!bArgsDefined) {
      Args[0] = mthing->arg1;
      Args[1] = mthing->arg2;
      Args[2] = mthing->arg3;
      Args[3] = mthing->arg4;
      Args[4] = mthing->arg5;
    }
    if (bFloatBob) {
      // seed random starting index for bobbing motion
      if (FloatBobPhase < 0) FloatBobPhase = Random()*256.0/35.0;
      //Special1f = mthing->height; // no need to do this, bobbing is done in renderer
    }
    if (!bSynchronised && StateTime > 0.0) StateTime = 0.1+Random()*StateTime;

    Angles.yaw = AngleMod360(float(AngleIncrements()*(mthing->angle/AngleIncrements())));
    Angles.pitch = AngleMod360(mthing->pitch);
    Angles.roll = AngleMod360(mthing->roll);

    if (mthing->scaleX > 0) ScaleX *= mthing->scaleX;
    if (mthing->scaleY > 0) ScaleY *= mthing->scaleY;

    if (mthing->options&LineSpecialLevelInfo::MTF_AMBUSH) bAmbush = true;
    if (mthing->options&LineSpecialLevelInfo::MTF_STANDSTILL) bStanding = true;
    if (mthing->options&LineSpecialLevelInfo::MTF_DORMANT) Deactivate(none);
    if (mthing->options&LineSpecialLevelInfo::MTF_FRIENDLY) {
      bFriendly = true;
      // friendlies don't count as kills
      if (bCountKill) {
        bCountKill = false;
        --Level.TotalKills;
      }
    }
    if (mthing->options&LineSpecialLevelInfo::MTF_SHADOW) {
      bShadow = true;
      RenderStyle = STYLE_Translucent;
      Alpha = 0.25;
    } else if (mthing->options&LineSpecialLevelInfo::MTF_ALTSHADOW) {
      RenderStyle = STYLE_None;
    }
  } else {
    bool wasFloatBob = bFloatBob;
    //if (wasFloatBob) printdebug("%C:%s: FBOB! z=%s; nogravity=%B; special=%B", self, UniqueId, Origin.z, bNoGravity, bSpecial);
    bFloatBob = false; // so it won't be raised
         if (bSpawnCeiling) Origin.z = ONCEILINGZ;
    else if (bSpawnFloat) Origin.z = FLOATRANDZ;
    /*
    else if (bFloatBob) {
      tmtrace_t tmtrace;
      GetFloorAndCeiling(out tmtrace);
      printdebug("%C: FBOB! z=%s; floorz=%s; hgt=%s", self, Origin.z, tmtrace.FloorZ, Origin.z-tmtrace.FloorZ);
      Origin.z -= tmtrace.FloorZ;
    }
    */
    //else z = ONFLOORZ;
    SetOrigin2(Origin);
    bFloatBob = wasFloatBob;
  }

  if (bStaticLight && mthing && !TID) {
    if (LightColor == 0xffffffff) {
      Level.AddStaticLight(self, Origin+LightOffset, mthing->arg1 ? float(mthing->arg1)*8.0 : LightRadius);
    } else {
      Level.AddStaticLightRGB(self, Origin+LightOffset, mthing->arg1 ? float(mthing->arg1)*8.0 : LightRadius, LightColor);
    }
    bStaticLightSpawned = true;
  }

  //print("SPAWNED: %C (%B)", self, bSolid);
}


//==========================================================================
//
//  CanSeek
//
//  Checks if a seeker missile can home in on its target
//
//==========================================================================
bool CanSeek (EntityEx Targ) {
  if (Targ.bCantSeek) return false;
  if (bDontSeekInvisible && (Targ.bShadow || Targ.bGhost)) return false;
  return true;
}


//==========================================================================
//
//  SeekerMissile
//
//  the missile Tracer field must be Actor target
//  returns true if target was tracked, false if not
//
//==========================================================================
final bool SeekerMissile (float thresh, float turnMax, optional bool precise, optional bool curspeed) {
  float dist;
  float delta;
  float s, c;

  if (!Tracer) return false;
  if (!Tracer.bShootable) {
    // target died
    Tracer = none;
    return false;
  }

  int dir = FaceActor(Tracer, delta);
  if (delta > thresh) {
    delta /= 2.0;
    if (delta > turnMax) delta = turnMax;
  }
  if (dir) {
    // turn clockwise
    Angles.yaw = AngleMod360(Angles.yaw+delta);
  } else {
    // turn counter clockwise
    Angles.yaw = AngleMod360(Angles.yaw-delta);
  }

  float angle = Angles.yaw;

  //k8: is this right?
  if (!curspeed) {
    if (!precise) {
      sincos(angle, out s, out c);
      Velocity.x = Speed*c;
      Velocity.y = Speed*s;
      if (Origin.z+Height < Tracer.Origin.z ||
          Tracer.Origin.z+Tracer.Height < Origin.z)
      {
        // need to seek vertically
        dist = DistTo2(Tracer);
        dist = dist/Speed;
        if (dist < 1.0 || !dist.isfinite) dist = 1.0;
        Velocity.z = (Tracer.Origin.z+Tracer.Height/2.0-Origin.z-Height/2.0)/dist;
      }
    } else {
      // need to seek vertically
      TVec d = vector(Tracer.Origin.x-Origin.x, Tracer.Origin.y-Origin.y, 0.0);
      //dist = Length(d) > 1.0 ? Length(d) : 1.0;
      dist = fmax(1.0, Length(d));
      if (!dist.isfinite) dist = 1.0;

      // aim at a player's eyes and at the middle of the actor for everything else.
      float aimheight = Tracer.Height/2.0;
      if (Tracer.bIsPlayer) aimheight = PlayerEx(Tracer.Player).ViewHeight;
      float pitch = atan2((Tracer.Origin.z+aimheight)-(Origin.z+Height/2.0), fabs(dist));

      float ps, pc;
      sincos(angle, out s, out c);
      sincos(pitch, out ps, out pc);

      float xyscale = Speed*pc;
      Velocity.x = xyscale*c;
      Velocity.y = xyscale*s;
      Velocity.z = Speed*ps;
    }
  }

  return true;
}


//==========================================================================
//
//  PlayActiveSound
//
//==========================================================================
void PlayActiveSound () {
  if (ActiveSound) {
    PlaySound(ActiveSound, CHAN_VOICE, 1.0, (bFullVolActive ? ATTN_NONE : ATTN_NORMAL));
  }
}


//==========================================================================
//
//  eventDropItem
//
//  for ACS
//
//==========================================================================
override bool eventDropItem (name itemName, int amount, float chance) {
  if (!itemName) return false;
  class!EntityEx ee = class!EntityEx(FindClassNoCase(itemName));
  if (!ee) return false;
  DropItem(ee, amount, chance);
  return true;
}


//==========================================================================
//
//  DropItem
//
//==========================================================================
final EntityEx DropItem (class!EntityEx type, int amount, float chance, optional TVec dropofs, optional bool AllowReplace) {
  if (Random() > chance) return none;

  float DropZ = 0.0;
  if (!Level.CompatNoTossDrops) DropZ = Height/2.0;
  if (!specified_dropofs) dropofs = vector(0.0, 0.0, DropZ);
  EntityEx A = SpawnEntityChecked(class!EntityEx, type, Origin+dropofs, AllowReplace:AllowReplace!optional);
  if (!A) return none;

  //A = Spawn(type, Origin + vector(0.0, 0.0, DropZ));
  if (A.bSpecial) A.bDropped = true; // special versions of items

  if (Inventory(A)) {
    Inventory Item = Inventory(A);
    if (amount > 0) {
      Item.Amount = amount;
    } else if (Ammo(Item)) {
      // half ammo when dropped by bad guys
      if (Ammo(Item).DropAmount) {
        Item.Amount = Ammo(Item).DropAmount;
      } else {
        Item.Amount = Item.Amount/2;
        if (Item.Amount < 1) Item.Amount = 1;
      }
    } else if (Weapon(Item)) {
      Weapon wpn = Weapon(Item);
      // the same from dropped weapons
      if (wpn.AmmoGive1 != 0) {
        wpn.AmmoGive1 = wpn.AmmoGive1/2;
        if (wpn.AmmoGive1 < 1) wpn.AmmoGive1 = 1;
      }
      if (wpn.AmmoGive2 != 0) {
        wpn.AmmoGive2 = wpn.AmmoGive2/2;
        if (wpn.AmmoGive2 < 1) wpn.AmmoGive2 = 1;
      }
    }
    if (Item.SpecialDropAction(self)) return none;
  }

  if (!Level.CompatNoTossDrops) {
    A.Velocity.x = (Random()-Random())*35.0;
    A.Velocity.y = (Random()-Random())*35.0;
    A.Velocity.z = (5.0+Random()*4.0)*35.0;
  }

  return A;
}


//==========================================================================
//
//  NoBlockingSet
//
//==========================================================================
void NoBlockingSet () {
}


//==========================================================================
//
//  Tick
//
//==========================================================================
override void Tick (float deltaTime) {
  //if (self isa PlayerPawn) print("*** PLAYERPAWN(%C): TICK!", self);

  if (bIsPlayer && GetCvarB('k8TraceDebug')) {
    auto plr = PlayerEx(Player);
    trsplat_t tr;
    TAVec ang = Angles; //vector(plr.pitch, plr.yaw, plr.roll);
    TVec dir;
    AngleVector(ang, out dir);
    bool wallHit = TraceLineEx(Origin, dir, 4096, true, &tr);
    if (wallHit) {
      print("*** WALL");
    } else if (tr.mobj) {
      print("*** thing %n: health=%d", GetClassName(tr.mobj.Class), tr.mobj.Health);
    }
  }

  Inventory Item;

  if (Level.bFrozen && ((!bIsPlayer && !bNoTimeFreeze) ||
      (bIsPlayer && !(PlayerEx(Player).Cheats&PlayerEx::CF_TIMEFREEZE))))
  {
    return;
  }

  // handle powerup effects
  for (Item = Inventory; Item && Item.Owner == self; Item = Item.Inventory) {
    Item.DoEffect();
  }

  if (bVisibilityPulse) {
    // pulse visibility in and out
    if (VisDir > 0) {
      Alpha += 0.75*deltaTime;
      if (Alpha > 1.0) {
        Alpha = 1.0;
        VisDir = -1;
      }
    } else {
      Alpha -= 0.75*deltaTime;
      if (Alpha <= 0.25) {
        Alpha = 0.25;
        VisDir = 1;
      }
    }
  } else if (bStealth) {
    // fade a stealth monster in and out of visibility
    if (GetCvarB('fuck_stealth_monsters')) {
      Alpha = 1.0;
    } else if (VisDir > 0) {
      Alpha += 2.0*deltaTime;
      if (Alpha > 1.0) {
        Alpha = 1.0;
        VisDir = 0;
      }
    } else if (VisDir < 0) {
      Alpha -= 3.0*deltaTime/2.0;
      if (Alpha < 0.0) {
        Alpha = 0.0;
        VisDir = 0;
      }
    }
  }

  if (JumpTime) JumpTime = fmax(0, JumpTime-deltaTime);

  TVec lastOrg = Origin;
  bool lastInterp = bIntrJustMoved;
  float lmdur = XLevel.Time-LastMoveTime;
  if (lastInterp && (lmdur <= 0 || LastMoveDuration <= 0 || lmdur >= LastMoveDuration)) lastInterp = false;
  bIntrJustMoved = true; // teleports and force origin changes will reset it
  tmp_phys_z_change = 0;

  // physics is already interpolated
  if (!Physics(deltaTime)) return;

  // if not teleported, "just moved" flag is not reset
  if (bIntrJustMoved) {
    // if "just moved" flag was set, shift last origin by physics origin change
    if (lastInterp) {
      //if (!bIsPlayer && Origin-lastOrg) print("***DELTA %s (vel=%s)", Origin-lastOrg, Velocity);
      LastMoveOrigin += Origin-lastOrg;
      LastMoveOrigin.z -= tmp_phys_z_change;
    } else {
      if (fabs(tmp_phys_z_change) > 1) {
        bIntrJustMoved = true;
        LastMoveOrigin = Origin;
        LastMoveAngles = Angles;
        LastMoveTime = XLevel.Time;
        LastMoveDuration = 0.1; // arbitrary
        LastMoveOrigin.z -= tmp_phys_z_change;
      } else {
        bIntrJustMoved = false;
      }
    }
  } else {
    //print("%C: interpolation aborted by physics", self);
    lastInterp = false;
  }

  // cycle through states, calling action functions at transitions
  if (StateTime != -1.0) {
    bool stateChange = (State && StateTime-deltaTime <= 0);
    TAVec lastAngles = Angles;
    lastOrg = Origin;
    bIntrJustMoved = true; // teleports and force origin changes will reset it
    //if (stateChange && (self isa 'RLFormerAssaultTrooper')) printdebug("%C: old state: %s; time=%s", self, State, StateTime);
    if (!AdvanceState(deltaTime)) {
      // freed itself
      return;
    }
    //if (stateChange && (self isa 'RLFormerAssaultTrooper')) printdebug("%C: new state: %s; time=%s", self, State, StateTime);
    // interpolation check
    if (stateChange && bIntrJustMoved) {
      /*
      if (lastInterp) {
        // this should not happen
        LastMoveDuration += StateTime;
      } else
      */
      {
        // possibly moved, set new interpolation state
        // if mobj is not moved, the engine will take care of it
        LastMoveOrigin = lastOrg;
        LastMoveAngles = lastAngles;
        LastMoveTime = XLevel.Time;
        LastMoveDuration = StateTime;
      }
    } else {
      bIntrJustMoved = lastInterp;
    }
  } else {
    // endless state

    // check for nightmare respawn
    if (!bAlwaysRespawn) {
      if (!bMonster || bDormant || bNeverRespawn) return;
      if (!LineSpecialGameInfo(Level.Game).RespawnTime) return;
      int respLimit = Level.World.GetRespawnLimit();
      if (respLimit > 0 && SkillRespawnCount >= respLimit) {
        return;
      }
    }

    // old code
    /*
    ++MoveCount;
    if (MoveCount < int(LineSpecialGameInfo(Level.Game).RespawnTime*35.0)) return;
    if (XLevel.TicTime&31) return;
    if (P_Random() > 4) return;
    */
    // new code
    //print("OMC=%s", MoveCount);
    if (MoveCount >= 0) MoveCount = -XLevel.TicTime;
    //print("MC=%s; tc=%s; delta=%s; rt=%s", MoveCount, XLevel.TicTime, XLevel.TicTime+MoveCount, int(LineSpecialGameInfo(Level.Game).RespawnTime));
    if (XLevel.TicTime+MoveCount < int(LineSpecialGameInfo(Level.Game).RespawnTime)) return;
    if (XLevel.TicTime&31) return;
    if (P_Random() > 4) return;
    MoveCount = 0;

    NightmareRespawn();
  }
}


//==========================================================================
//
//  SectorChanged
//
//  CrushChange == -666: loader fix
//  CrushChange == -1: ignore stuck mobj
//
//  returns `false` if doesn't fit
//
//==========================================================================
override bool SectorChanged (int CrushChange) {
  if (CrushChange == -666) {
    // only fix positions for monsters (and don't touch corpses too)
    if (!bMonster && !bIsPlayer) return true;
    if (!bSolid || bCorpse) return true;
    return HeightClip(skipTriggers:true, skipObjects:true);
  }

  //print("SectorChanged for %C", self);
  if (HeightClip()) return true; // it fits

  // if it stuck, and we should not ignore it...
  if (CrushChange == -1) return true; // get out!

  // crunch bodies to giblets
  if (bCorpse && !bDontGib && Health <= 0) {
    bool CanDestroy = false;
    state stgibs = FindClassState(Class, 'Death', 'SectorGibs', exact:true);
    if (stgibs) {
      bDontGib = true;
      SetState(stgibs);
    } else if (!bNoBlood) {
      class c = FindClass('RealGibs');
      if (c) c = GetClassReplacement(c);
      if (c) {
        state spst = FindClassState(c, 'Spawn');
        if (!spst || !AreStateSpritesPresent(spst)) c = none;
      }

      if (c) {
        Actor Gib = SpawnEntityChecked(class!Actor, RealGibs);
        if (Gib) {
          Gib.RenderStyle = RenderStyle;
          Gib.Alpha = Alpha;
          Gib.Height = 0.0;
          Gib.Radius = 0.0;
          Gib.CopyTranslations(self);
          //k8: really?
          //if (BloodTranslation && !Gib.bDontTranslate) Gib.Translation = BloodTranslation;
          Gib.PlaySound('misc/fallingsplat', /*CHAN_BODY*/CHAN_AUTO);
        }
        CanDestroy = true;
      } else {
        bDontGib = true;
      }
    }
    if (bIsPlayer) {
      bColideWithWorld = false;
      bColideWithThings = false;
      bDontGib = true;
      bInvisible = true;
    } else {
      if (CanDestroy) Destroy();
    }
    return true;
  }

  // crunch dropped items
  if (bDropped) {
    Destroy();
    return true;
  }

  // killough 11/98: kill touchy things immediately
  if (bTouchy && (bArmed || IsSentient())) {
    bArmed = false; // disarm
    SpawnBloodAtHeadExplosion(InitialHealth, none);
    Damage(none, none, InitialHealth); // kill object
    return true;
  }

  if (!bShootable) {
    // assume it is bloody gibs or something
    return true;
  }

  if (CrushChange > 0 && !(XLevel.TicTime&3)) {
    Damage(none, none, CrushChange);
    // spray blood in a random direction
    if (!bNoBlood && !bInvulnerable && BloodType && IsBloodAllowed()) {
      EntityEx A = SpawnEntityChecked(class!EntityEx, BloodType, Origin+vector(0.0, 0.0, Height/2.0));
      if (A) {
        A.SetBloodArgs(self, damage:CrushChange);
        A.Velocity.x = (Random()-Random())*16.0*35.0;
        A.Velocity.y = (Random()-Random())*16.0*35.0;
        //if (BloodTranslation && !A.bDontTranslate) A.Translation = BloodTranslation;
        A.CopyBloodTranslations(self, copyNormalTranslation:false);
      }
    }
    if (!bInvulnerable && CrushPainSound && !GetSoundPlayingInfo(self, GetSoundID(CrushPainSound))) {
      PlaySound(CrushPainSound, CHAN_VOICE);
    }
  }

  return false; // don't fit
}


//==========================================================================
//
//  ClientTick
//
//  delta time can be zero for "interframe" ticks
//
//==========================================================================
override void ClientTick (float DeltaTime) {
  if (bInvisible || bNoSector || !DeltaTime) return;

  // if we're in closed door or something, skip effects
  if (CeilingZ <= FloorZ) return;

  // do not do any state effects if the object is too far away from the camera
  if (!CheckViewOrgDistance(Origin, GetDynLightMaxDist())) return;

  // do state effects, dynlight, and various particle trails
  DoStateEffects(DeltaTime);

  if (bDynamicLight) {
    // update dynamic lights
    dlight_t *dl = AllocDlight(self, Origin, radius:fmax(0, fmax(prev_rad, DLightRadius)));
    if (dl) {
      //dl->origin = Origin;
      dl->radius = (prev_rad <= DLightRadius ? prev_rad : (prev_rad-DLightRadius)*XLevel.Time);
      dl->radius += XLevel.Time*dl->decay;
      //if (dl->radius > DLightRadius) dl->radius = DLightRadius;
      dl->radius = fmin(dl->radius, DLightRadius);
      prev_rad = dl->radius;
      dl->color = DLightColor;
      dl->die = XLevel.Time+0.1;
    }
  }

  if ((bLeaveTrail || bLeaveTrail2) && GetCvarB('r_particle_trails')) {
    if (bLeaveTrail) {
      bool alt = false;
      float r = 0.0;
      int c = P_Random()>>1;
      if (P_Random() > 180) {
        r = Random()*8.0;
        alt = true;
      }
      LineSpecialLevelInfo(Level).ParticleEffect(int(DeltaTime*256.0), alt ? LineSpecialLevelInfo::pt_explode : LineSpecialLevelInfo::pt_static, 0, Origin,
          0.0, vector(16.0, 16.0, 64.0), 0.5, 2.5, 0.0, alt ? RGB(255, 140, 0) : RGB(c, c, c), 0.5, r);
    }

    if (bLeaveTrail2) {
      int c = P_Random()>>1;
      LineSpecialLevelInfo(Level).ParticleEffect(6,
          LineSpecialLevelInfo::pt_static, 0, vector(Origin.x-(cos(Angles.yaw)*Radius*2.0),
          Origin.y-(sin(Angles.yaw)*Radius*2.0),
          Origin.z-(float(int(Height)>>3*int(Velocity.z)>>16)+2.0*Height/3.0)),
          0.0, vector(32.0, 32.0, 32.0), 0.5, 10.0, 40.0, RGB(c, c, c), 0.6, 0.0);
    }
  }
}


//==========================================================================
//
//  DoStateEffects
//
//==========================================================================
final void DoStateEffects (float DeltaTime) {
  array!(LightEffectDef *) Lights;
  array!(ParticleEffectDef *) Particles;

  GetStateEffects(Lights, Particles);
  if (!Lights.length && !Particles.length) return;

  TVec Forward;
  TVec Right;
  TVec Up;

  AngleVectors(Angles, out Forward, out Right, out Up);

  if (!bStaticLightSpawned) {
    //if (self isa 'ExplosiveBarrel') printdebug("%C: numdynlights=%s (static=%B)", self, Lights.length, bStaticLightSpawned);
    // dynamic lights
    float LightTime;
    float max;
    // note that this is wrong, as entity can only have one dynlight attached
    //BeginEntityDlights(self); // this should forget all entity dlights, *AND* allow several dlights attached; noop for now
    //scope(exit) EndEntityDlights(self);
    // maybe it is better to allow any number of entity dlights, but reset all of them on new frame?
    // or give each dynlight an id, to allow replacing?
    // note that sprite effects can have several lights attached, and that can be changed with each new frame, so
    // i think that it will be better to use ids, and allow unreplaced lights to decay
    foreach (auto i; 0..Lights.length) {
      LightEffectDef *L = Lights[i];
      TVec lorg = Origin+Forward*L->Offset.x-Right*L->Offset.y+Up*L->Offset.z;
      // fix lights put into the floor or into the ceiling (why not?)
      if (/*!L->Offset.z &&*/ Sector) {
        float ffz1 = Sector.floor.GetPointZClamped(lorg);
        if (lorg.z <= ffz1) {
          // do not check ceiling here
          lorg.z = ffz1+4; // why not?
        } else {
          float fcz1 = Sector.ceiling.GetPointZClamped(lorg);
          if (lorg.z >= fcz1) lorg.z = fcz1-4; // why not?
        }
      }
      dlight_t *dl = AllocDlight(self, lorg, radius:fmax(0, fmax(prev_rad, L->Radius)), lightid:i); // pass "light id" to allow replacing
      if (!dl) continue; // alas
      //if (self isa 'ExplosiveBarrel') printdebug("%C:  dlight=%s; org=%s; lorg=%s; lrad=%s; type=%s", self, i, Origin, dl->origin, dl->radius, L->Type);
      //print("%C: rad: %s", self, dl->radius);
      //dl->origin = Origin + Forward * L->Offset.x - Right * L->Offset.y + Up * L->Offset.z;
      switch (L->Type&DynamicLight::DLTYPE_TypeMask) {
        case DynamicLight::DLTYPE_Point:
        //case DynamicLight::DLTYPE_Subtractive:
          //printdebug("%C: point light", self);
          dl->decay = /*XLevel.Time+*/300.0;
          dl->radius = (prev_rad <= L->Radius ? prev_rad : (prev_rad-L->Radius)*XLevel.Time);
          dl->radius += /*XLevel.Time**/dl->decay;
          //printdebug("000:%C: point light; radius=%s", self, dl->radius);
          if (dl->radius > L->Radius) dl->radius = L->Radius;
          //printdebug("001:%C: point light; radius=%s", self, dl->radius);
          dl->type = L->Type;
          break;
        case DynamicLight::DLTYPE_MuzzleFlash:
          max = (L->Radius+Random()*(L->Radius2-L->Radius));
          dl->decay = /*XLevel.Time+*/80.0;
          dl->radius = (prev_rad <= L->Radius ? prev_rad : (prev_rad-L->Radius)*XLevel.Time);
          dl->radius += /*XLevel.Time**/dl->decay;
          if (dl->radius > max) dl->radius = max;
          break;
        case DynamicLight::DLTYPE_Pulse:
          //printdebug("%C: pulse light; interval=%s; rad=(%s,%s)", self, L->Interval, L->Radius, L->Radius2);
          dl->decay = /*XLevel.Time+*/150.0;
          // avoid division by 0
          float PulseCycle = (L->Interval > 0 ? L->Interval/35.0 : 1.0/35.0);
          LightTime += DeltaTime;
          if (LightTime >= PulseCycle) LightTime = 0.0;
          float Frac = (1.0+sin(360.0*LightTime/PulseCycle))*0.5;
          dl->radius = L->Radius+Frac*(L->Radius2-L->Radius);
          //dl->radius *= 2.5;
          //dl->decay = 0;
          //L->Color = 0xff00ff00;
          //printdebug("000:%C: pulse light; radius=%s; LightTime=%s; PulseCycle=%s; Frac=%s", self, dl->radius, LightTime, PulseCycle, Frac);
          break;
        case DynamicLight::DLTYPE_Flicker:
          if (L->Chance < 0) {
            // from gldef
            //printdebug("%C: gldef flicker light; chance=%s (%s)", self, L->Chance, -(L->Chance+1.0));
            dl->decay = /*XLevel.Time+*/80.0;
            dl->radius = (FRandomFull() <= -(L->Chance+1.0) ? L->Radius2 : L->Radius);
            //printdebug("%C: gldef flicker light; chance=%s (%s); rad=%s", self, L->Chance, -(L->Chance+1.0), dl->radius);
          } else {
            // from entity
            dl->decay = /*XLevel.Time+*/80.0;
            dl->radius = (Random() >= L->Chance/360.0 ? L->Radius2 : L->Radius);
          }
          break;
        case DynamicLight::DLTYPE_FlickerRandom:
          LightTime += DeltaTime;
          if (LightTime > L->Interval/360.0) {
            max = (L->Radius+FRandomFull()*(L->Radius2-L->Radius));
            dl->decay = /*XLevel.Time+*/80.0;
            dl->radius = (prev_rad <= L->Radius ? prev_rad : /*(prev_rad-L->Radius)*XLevel.Time*/max);
            dl->radius += /*XLevel.Time**/dl->decay;
            if (dl->radius > max) dl->radius = max;
            LightTime = 0.0;
          }
          break;
        case DynamicLight::DLTYPE_Sector:
        //case DynamicLight::DLTYPE_SectorSubtractive:
          {
            float Scale = L->Scale*0.125;
            if (!Scale) Scale = 1.0;
            dl->radius = float(Sector->params.lightlevel)*Scale;
            if (dl->radius < 0.0) dl->radius = 0.0;
            if (dl->radius > 255.0) dl->radius = 255.0;
            //dl->type = (L->Type == DynamicLight::DLTYPE_Sector ? DynamicLight::DLTYPE_Point : DynamicLight::DLTYPE_Subtractive);
            dl->type = DynamicLight::DLTYPE_Point;
          }
          break;
      }
      dl->color = L->Color;
      dl->minlight = L->MinLight;
      dl->bNoSelfShadow = !!L->NoSelfShadow;
      dl->die = XLevel.Time+0.1;
      prev_rad = dl->radius;
    }
  }

  if (State != PrevEffectState) {
    // particle effects
    if (Particles.length > 0 && GetCvarB('r_particle_effects')) {
      foreach (auto i; 0..Particles.length) {
        ParticleEffectDef *P = Particles[i];
        if (!P) continue;
        if (!Level) { print("WTF?! no level in particle effect!"); break; }
        Level.ParticleEffect(P->Count, P->Type, P->Type2,
          Origin+Forward*P->Offset.x-Right*P->Offset.y+Up*P->Offset.z,
          P->OrgRnd, P->Velocity, P->VelRnd,
          P->Accel, P->Grav, P->Color, P->Duration, P->Ramp);
      }
    }
    PrevEffectState = State;
  }
}


//==========================================================================
//
//  TouchDehackedSpecial
//
//==========================================================================
final void TouchDehackedSpecial (EntityEx Toucher) {
  if (!Toucher.bPickUp) return; // can't remove thing

  // dead thing touching
  // can happen with a sliding player corpse
  if (Toucher.Health <= 0) return;

  class!Inventory ItemType = LineSpecialLevelInfo(Level).GetDehackedItemType(self);
  if (!ItemType) return;

  Inventory Item = SpawnEntityChecked(class!Inventory, ItemType, default, default, default/*, false*/);
  if (!Item) return;

  Item.bDropped = bDropped;
  if (bDropped) {
    if (Ammo(Item)) {
      // half ammo when dropped by bad guys
      Item.Amount = Item.Amount/2;
      if (Item.Amount < 1) Item.Amount = 1;
    }
  }

  if (!Item.TryPickup(Toucher)) {
    Item.Destroy();
    return;
  }

  if (Special) {
    Level.ExecuteActionSpecial(Special, Args[0], Args[1], Args[2], Args[3], Args[4], nullptr, 0, Toucher);
    Special = 0;
  }
  if (bCountItem) {
    ++Toucher.Player.ItemCount;
    ++Level.CurrentItems;
  }

  Toucher.Player.cprint("%s", Item.GetPickupMessage());
  Toucher.PlaySound(Item.PickupSound, CHAN_ITEM);

  if (bDropped) {
    Destroy();
  } else if (!Item.ShouldStay()) {
    if (Item.ShouldRespawn()) {
      bInvisible = true;
      bSpecial = false;
      SetState(FindState('DehackedDormantPickup'));
    } else {
      Destroy();
    }
  }
  PlayerEx(Toucher.Player).BonusFlash += Inventory::BONUSADD;
  // destroy item if it wasn't added to the toucher's inventory
  if (!Item.Owner) Item.Destroy();
}


//==========================================================================
//
//  GiveBody
//
//  Returns false if the body isn't needed at all
//
//==========================================================================
final bool GiveBody (int num) {
  int max;

  if (bIsPlayer) {
    max = PlayerEx(Player).GetMaxHealth();
    if (num < 0) {
      // for Strife negative body sets you to the percentage of your full health
      num = max*(-num)/100;
      if (Player.Health < num) {
        Player.Health = num;
        Health = num;
        return true;
      }
    } else if (Player.Health < max) {
      Player.Health += num;
      if (Player.Health > max) Player.Health = max;
      Health = Player.Health;
      return true;
    }
  } else {
    max = InitialHealth;
    if (num < 0) {
      num = max*(-num)/100;
      if (Health < num) {
        Health = num;
        return true;
      }
    } else if (Health < max) {
      Health += num;
      if (Health > max) Health = max;
      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  RepairArmorWith
//
//  Returns false if the armor weren't repaired.
//
//==========================================================================
final bool RepairArmorWith (int amount, optional class!BasicArmorBonus armorbonustype) {
  // default armorbonustype: ArmorBonus
  printwarn("`RepairArmorWith()` is not implemeted!");
  return false;
}


//==========================================================================
//
//  SpawnPuff
//
//  to prevent decal spawning, pass 'none' as `decalType`
//  (or something else that is non-existing)
//  decalType of '' means "use default puff decal"
//
//==========================================================================
final EntityEx SpawnPuff (TVec Org, float Range, class!EntityEx PuffType,
  bool HitThing, optional sector_t *sec, optional line_t *li, optional TVec realOrg,
  optional name decalType, optional int pufftid, optional bool disableRandomZ)
{
  EntityEx puff;

  if (PuffType && PuffType.default.bPuffParticles && GetCvarB('r_particle_puffs')) {
    int c = P_Random()>>1;
    foreach (int i; 0..MAXPLAYERS) {
      if (!Level.Game.Players[i]) continue;
      if (!Level.Game.Players[i].bSpawned) continue;
      PlayerEx(Level.Game.Players[i]).ParticleEffect(20, LineSpecialLevelInfo::pt_static,
               LineSpecialLevelInfo::pt_explode2, Org, 0.0, vector(32.0, 32.0, 32.0),
               0.5, 10.0, 40.0, RGB(c, c, c), 0.8, 0.0);
    }
  }

  if (!decalType && PuffType) decalType = PuffType.default.DecalName;
  if (nameicmp(decalType, 'none') == 0) decalType = ''; // prevent error spam
  /*
  if (specified_decalType) {
    if (!decalType) doDecal = false;
  } else {
    if (!PuffType || !PuffType.default.DecalName) doDecal = false;
  }*/

  //print("SpawnPuff: Range=%s; PuffType=%C; decalType=%s(%B); puffdecal=%s; doDecal=%B", Range, PuffType, decalType, specified_decalType, (PuffType ? PuffType.default.DecalName : '<none>'), doDecal);

  if (decalType && sec && li) {
    //k8:TODO: this should be strictly client-side
    if (!specified_realOrg) realOrg = Org;
    if (specified_decalType && decalType) {
      SpawnDecal(realOrg, decalType, (sec == li->backsector ? 1 : 0), li);
    } else {
      SpawnDecal(realOrg, PuffType.default.DecalName, (sec == li->backsector ? 1 : 0), li);
    }
  }

  if (PuffType) {
    if (!disableRandomZ) Org.z += (Random()-Random())*4.0;

    puff = SpawnEntityChecked(class!EntityEx, PuffType, Org);
    if (!puff) return none; // oops

    if (pufftid) puff.SetTID(pufftid);

    // [BB] set the target of the puff to this actor
    if (puff.bPuffGetsOwner) puff.Target = Target;
         if (!HitThing && puff.FindState('Crash')) puff.SetState(puff.FindState('Crash'));
    else if (Range == MELEERANGE && puff.MeleeState) puff.SetState(puff.MeleeState);

    if (HitThing && puff.SightSound) {
      // hit thing sound
      puff.PlaySound(puff.SightSound, CHAN_VOICE);
    } else if (puff.AttackSound) {
      puff.PlaySound(puff.AttackSound, CHAN_VOICE);
    }

    if (puff.ExplodeEffect) SendExplosion(ExplodeEffect, DLightRadius, Org);
    LineSpecialLevelInfo(Level).bPuffSpawned = true;

    return puff;
  }

  return none;
}


//==========================================================================
//
//  SendExplosion
//
//==========================================================================
final void SendExplosion (int color, float rad, TVec org) {
  foreach (auto i; 0..MAXPLAYERS) {
    if (!Level.Game.Players[i]) continue;
    if (!Level.Game.Players[i].bSpawned) continue;
    PlayerEx(Level.Game.Players[i]).ClientExplosion(color, rad, org);
  }
}


//==========================================================================
//
//  AngleIncrements
//
//==========================================================================
int AngleIncrements () {
  return (bMonster ? 45 : LineSpecialGameInfo(Level.Game).NonMonsterAngleIncrements);
}


//==========================================================================
//
//  PreExplode
//
//==========================================================================
void PreExplode () {
}


//==========================================================================
//
//  GetExplodeParms
//
//==========================================================================
void GetExplodeParms (ref int damage, ref float distance, ref ubyte damageSelf) {
}


//==========================================================================
//
//  CheckBossDeath
//
//==========================================================================
final bool CheckBossDeath () {
  // make sure there is a player alive for victory
  int i;
  foreach (i; 0..MAXPLAYERS) {
    if (Level.Game.Players[i] && Level.Game.Players[i].bSpawned && Level.Game.Players[i].Health > 0) {
      break;
    }
  }

  if (i == MAXPLAYERS) {
    // no one left alive, so do not end game
    return false;
  }

  // scan the remaining thinkers to see if all bosses are dead
  EntityEx Other;
  foreach AllThinkers(class!EntityEx(Class), out Other) {
    if (Other != self && Other.Class == Class && Other.Health > 0) {
      // found a living boss
      return false;
    }
  }
  return true;
}


//==========================================================================
//
//  GetSpeechIndex
//
//==========================================================================
final int GetSpeechIndex (FRogueConSpeech[] List, int ID, int Num) {
  int Found = 0;
  foreach (auto i; 0..List.length) {
    if (List[i].SpeakerID == ID) {
      ++Found;
      if (Found == Num) return i+1;
    }
  }
  return 0;
}


//==========================================================================
//
//  GetSpeech
//
//==========================================================================
final int GetSpeech () {
  if (!CurrentSpeech) CurrentSpeech = 1;
  int Index = GetSpeechIndex(XLevel.LevelSpeeches, ConversationID, CurrentSpeech);
  if (Index) return Index;
  return -GetSpeechIndex(XLevel.GenericSpeeches, ConversationID, CurrentSpeech);
}


//==========================================================================
//
//  TossUpObject
//
//==========================================================================
final EntityEx TossUpObject (class!EntityEx type) {
  float randomspeed = Random()*8.0-6.0;
  EntityEx A = SpawnEntityChecked(class!EntityEx, type, GetCenter());
  if (A) {
    float an = AngleMod360(Angles.yaw+Random()*360.0);
    A.Angles.yaw = an;
    A.Tracer = Target;
    A.Target = self;
    //!A.LastPlayerSeenPosValid = false;
    float sina, cosa;
    sincos(an, out sina, out cosa);
    A.Velocity.x = randomspeed*cosa*35.0;
    A.Velocity.y = randomspeed*sina*35.0;
    A.Velocity.z = (12.0+Random()/8.0)*35.0;
  }
  return A;
}


//==========================================================================
//
//  SetActorProperty
//
//==========================================================================
override void SetActorProperty (int Prop, int IntVal, string StrVal) {
  switch (Prop) {
    case APROP_Health: Health = IntVal; if (bIsPlayer) Player.Health = IntVal; break;
    case APROP_Speed: Speed = float(IntVal)/65536.0*35.0; if (Speed < 0) Speed = 0; break;
    case APROP_Damage: MissileDamage = IntVal; break;
    case APROP_Alpha: Alpha = float(IntVal)/65536.0; break;
    case APROP_RenderStyle: RenderStyle = IntVal; break;
    case APROP_Ambush: bAmbush = !!IntVal; break;
    case APROP_Invulnerable: bInvulnerable = !!IntVal; break;
    case APROP_JumpZ: if (PlayerPawn(self)) PlayerPawn(self).JumpVelZ = float(IntVal)/65536.0*35.0; break;
    case APROP_ChaseGoal: bChaseGoal = !!IntVal; break;
    case APROP_Frightened: print("Frightened property is not implemented"); break;
    case APROP_Gravity: if (IntVal < 0) IntVal = 0; Gravity = float(IntVal)/65536.0; break;
    case APROP_Friendly: bFriendly = !!IntVal; break;
    case APROP_SeeSound: SightSound = name(StrVal); break;
    case APROP_AttackSound: AttackSound = name(StrVal); break;
    case APROP_PainSound: PainSound = name(StrVal); break;
    case APROP_DeathSound: DeathSound = name(StrVal); break;
    case APROP_ActiveSound: ActiveSound = name(StrVal); break;
    case APROP_SpawnHealth: if (PlayerPawn(self)) PlayerPawn(self).MaxHealth = IntVal; break;
    case APROP_Dropped: bDropped = !!IntVal; break;
    //case APROP_Species: return NameToIIndex(GetSpecies()); //HACK! keep in sync with C++ code!
    //case APROP_NameTag: return NameToIIndex(GetClassName(Class)); //HACK! keep in sync with C++ code!
    case APROP_MasterTID: if (IntVal <= 0) { Master = none; break; } Master = EntityEx(Level.FindMobjFromTID(IntVal, none)); if (Master == self) Master = none; break; //k8: allow self?
    case APROP_TargetTID: if (IntVal <= 0) { Target = none; break; } Target = EntityEx(Level.FindMobjFromTID(IntVal, none)); if (Target == self) Target = none; /*!!LastPlayerSeenPosValid = false;*/ break; //k8: allow self?
    case APROP_TracerTID: if (IntVal <= 0) { Tracer = none; break; } Tracer = EntityEx(Level.FindMobjFromTID(IntVal, none)); if (Tracer == self) Tracer = none; break; //k8: allow self?
    //case APROP_WaterLevel: return WaterLevel;
    case APROP_ScaleX: ScaleX = float(IntVal)/65536.0; break;
    case APROP_ScaleY: ScaleY = float(IntVal)/65536.0; break;
    case APROP_Dormant: bDormant = !!IntVal; break; //k8: change state for monster?
    case APROP_Mass: Mass = clamp(IntVal, 0, 10000); break; //k8: float?
    case APROP_Height: Height = fmax(0, float(IntVal)/65536.0); break;
    case APROP_Radius: Radius = fmax(0, float(IntVal)/65536.0); break;
    case APROP_ViewHeight:
      if (bIsPlayer) PlayerEx(Player).ViewHeight = float(IntVal)/65536.0;
      //else ViewHeight = float(IntVal)*65536.0;
      break;
    case APROP_AttackZOffset:
      if (bIsPlayer) PlayerPawn(Player.MO).AttackZOffset = float(IntVal)/65536.0;
      break;
    case APROP_Notarget: break; // no, my dear mod author, you cannot do this
    case APROP_Notrigger: bNoTrigger = !!IntVal; break;
    case APROP_Score: ScoreValue = IntVal; break;
    case APROP_DamageFactor:
      // this fixes my fuckup with invalid `GetCVar()` ACS API
      //if (IntVal <= 64) IntVal *= 65536;
      GenericDamageFactor = fclamp(float(IntVal)/65536.0, 0, 100000);
      //printdebug("%C: dmgfactor=%s (%s)", self, GenericDamageFactor, IntVal);
      break;
    case APROP_DamageMultiplier:
      // this fixes my fuckup with invalid `GetCVar()` ACS API
      //if (IntVal <= 64) IntVal *= 65536;
      GenericDamageMultiplier = fclamp(float(IntVal)/65536.0, 0, 100000);
      //printdebug("%C: dmgmult=%s (%s)", self, GenericDamageMultiplier, IntVal);
      break;
    case APROP_ReactionTime: ReactionCount = IntVal; break;
    default: dprint("%C: SetActorProperty: unknown property %d", self, Prop);
  }
}


//==========================================================================
//
//  GetActorProperty
//
//==========================================================================
override int GetActorProperty (int Prop) {
  //if (Prop == APROP_SpawnHealth) print("GetActorProperty(%C, APROP_SpawnHealth)=%s", self, self.InitialHealth);
  switch (Prop) {
    case APROP_Health: return Health;
    case APROP_Speed: return int(Speed/35.0*65536.0);
    case APROP_Damage: return MissileDamage;
    case APROP_Alpha: return int(Alpha*65536.0);
    case APROP_RenderStyle: return RenderStyle;
    case APROP_Ambush: return bAmbush;
    case APROP_Invulnerable: return bInvulnerable;
    case APROP_JumpZ: return int(PlayerPawn(self).JumpVelZ/35.0*65536.0);
    case APROP_ChaseGoal: return bChaseGoal;
    case APROP_Frightened: return 0;
    case APROP_Gravity: return int(Gravity*65536.0);
    case APROP_Friendly: return bFriendly;
    case APROP_SpawnHealth: if (PlayerPawn(self)) return PlayerPawn(self).MaxHealth; else return self.InitialHealth;
    case APROP_Dropped: return bDropped;
    case APROP_Species: return NameToIIndex(GetSpecies()); //HACK! keep in sync with C++ code!
    case APROP_NameTag: return (StrifeName ? NameToIIndex(name(StrifeName)) : NameToIIndex(GetClassName(Class))); //HACK! keep in sync with C++ code!
    case APROP_MasterTID: return (Master ? Master.TID : 0);
    case APROP_TargetTID: return (Target ? Target.TID : 0);
    case APROP_TracerTID: return (Tracer ? Tracer.TID : 0);
    case APROP_WaterLevel: return WaterLevel;
    case APROP_ScaleX: return int(ScaleX*65536.0);
    case APROP_ScaleY: return int(ScaleY*65536.0);
    case APROP_Dormant: return bDormant;
    case APROP_Mass: return int(fmax(0, Mass));
    case APROP_Height: return int(Height*65536.0);
    case APROP_Radius: return int(Radius*65536.0);
    case APROP_MeleeRange: return int(MeleeRange*65536.0);
    case APROP_ViewHeight:
      if (bIsPlayer) return int(PlayerEx(Player).ViewHeight*65536.0);
      //return int(ViewHeight*65536.0);
      return int(Height/2.0*65536.0);
    case APROP_AttackZOffset:
      return int((bIsPlayer ? PlayerEx(Player).GetAttackZOfs : 8.0)*65536.0);
    case APROP_Notarget: return (bIsPlayer ? PlayerEx(Player).bNoTarget : 0);
    case APROP_Notrigger: return (bNoTrigger ? 1 : 0);
    case APROP_Score: return ScoreValue;
    case APROP_DamageFactor: return int(GenericDamageFactor*65536.0);
    case APROP_DamageMultiplier: return int(GenericDamageMultiplier*65536.0);
    case APROP_ReactionTime: return ReactionCount;
  }
  dprint("%C: GetActorProperty: unknown property %d", self, Prop);
  return 0;
}


//==========================================================================
//
//  SetPlayerProperty
//
//==========================================================================
final bool SetPlayerProperty (int Prop, int Set) {
  class!Inventory InvClass = none;

  switch (Prop) {
    case PROP_FROZEN: PlayerEx(Player).bFrozen = !!Set; return true;
    case PROP_NOTARGET: PlayerEx(Player).bNoTarget = !!Set; return true;
    case PROP_INSTANTWEAPONSWITCH: PlayerEx(Player).bInstantWeaponSwitch = !!Set; return true;
    case PROP_FLY: PlayerEx(Player).bFly = !!Set; bFly = !!Set; bNoGravity = !!Set; return true;
    case PROP_TOTALLYFROZEN: PlayerEx(Player).bTotallyFrozen = !!Set; return true;
    case PROP_INVULNERABILITY: InvClass = PowerInvulnerable; break;
    case PROP_STRENGTH: InvClass = PowerStrength; break;
    case PROP_INVISIBILITY: InvClass = PowerInvisibility; break;
    case PROP_RADIATIONSUIT: InvClass = PowerIronFeet; break;
    case PROP_ALLMAP: if (Set) PlayerEx(Player).AddRevealedMap(); else PlayerEx(Player).RemoveRevealedMap(); return true;
    case PROP_INFRARED: InvClass = PowerLightAmp; break;
    case PROP_WEAPONLEVEL2: InvClass = PowerWeaponLevel2; break;
    case PROP_FLIGHT: InvClass = PowerFlight; break;
    case PROP_SPEED: InvClass = PowerSpeed; break;
    case PROP_BUDDHA: break; // no, my dear mod author, you cannot do this
    default:
      dprint("%C: SetPlayerProperty: unknown property %d", self, Prop);
      return false;
  }

  if (Set) {
    GiveInventoryType(InvClass);
  } else {
    Inventory Item = FindInventory(InvClass);
    if (Item) Item.Destroy();
  }
  return true;
}


//==========================================================================
//
//  ShouldDropItems
//
//==========================================================================
bool ShouldDropItems () {
  return true;
}


//==========================================================================
//
//  PainShootSkull
//
//  Spawn a lost soul and launch it at the target
//
//  limitCheck:
//    <0: no limit
//     0: use default compatibility setting
//    >0: use this as a limit
//
//==========================================================================
final void PainShootSkull (class!Actor SpawnType, float angle, optional bool noattack,
                           optional bool notarget, optional int limitCheck)
{
  EntityEx mo;
  Actor newSkull;
  float prestep;
  float sina, cosa;

  if (!SpawnType) SpawnType = LostSoul;
  if (nameicmp(DamageType, 'Massacre') == 0) return;

  // fix limit checker
  if (!limitCheck) limitCheck = (Level.CompatLimitPain ? 20 : -1);

  if (limitCheck > 0) {
    // count total number of skull currently on the level
    //FIXME: decorate_A_PainAttack can override this
    int count = 0;
    foreach AllThinkers(SpawnType, mo) {
      if (mo) {
        if (++count > limitCheck) return;
      }
    }
    // if there are allready 20 skulls on the level, don't spit another one
    //if (count > 20) return;
  }

  // okay, there's place for another one
  prestep = 4.0+3.0*(Radius+SpawnType.default.Radius)/2.0;

  sincos(angle, out sina, out cosa);
  sina *= prestep;
  cosa *= prestep;

  // Check whether the Lost Soul is being fired through a 1-sided
  // wall or an impassible line, or a "monsters can't cross" line.
  // If it is, then we don't allow the spawn.
  if (CheckSides(Origin+vector(cosa, sina, 8.0))) return;

  newSkull = SpawnEntityChecked(class!Actor, SpawnType, Origin);
  if (newSkull) {
    // Check to see if the new Lost Soul's z value is above the
    // ceiling of its new sector, or below the floor. If so, kill it.
    if (newSkull.Origin.z > newSkull.CeilingZ-newSkull.Height ||
        newSkull.Origin.z < newSkull.FloorZ)
    {
      // kill it immediately
      newSkull.Damage(self, self, 10000, forced:true);
      return;
    }

    // check for movements
    if (!newSkull.TryMove(newSkull.Origin+vector(cosa, sina, 8.0), AllowDropOff:false)) {
      // kill it immediately
      newSkull.Damage(self, self, 10000, forced:true);
      return;
    }

    // spawned skulls hate same things as master
    newSkull.CopyFriendliness(self, !notarget);

    if (!noattack) newSkull.A_SkullAttack();
  }
}


//==========================================================================
//
//  AutoUseHealth
//
//==========================================================================
final void AutoUseHealth (int saveHealth) {
  int count;
  int normalhealth = 0;
  int superhealth = 0;
  array!Inventory normal;
  array!Inventory super;
  int saved = 0;

  for (Inventory inv = Inventory; inv; inv = inv.Inventory) {
    if (inv.Amount > 0 && ClassIsChildOf(inv.Class, HealthPickup)) {
      int mode = HealthPickup(inv).AutoUseMode;
      if (mode == 1) {
        /*
        normal[normal.Num] = inv;
        normal.Num = normal.Num+1;
        */
        normal[$] = inv;
      } else if (mode == 2) {
        /*
        super[super.Num] = inv;
        super.Num = super.Num+1;
        */
        super[$] = inv;
      }
    }
  }

  foreach (auto i; 0..normal.length-1) normalhealth += normal[i].Amount*normal[i].Health;
  foreach (auto i; 0..super.length-1) superhealth += super[i].Amount*super[i].Health;

  if (Level.World.bSkillAutoUseHealth && normalhealth >= saveHealth) {
    // use quartz flasks
    while (normal.length > 0 && saveHealth > 0) {
      int maxhealth = 0;
      int index = -1;

      // find the largest item in the list
      foreach (auto i; 0..normal.length-1) {
        if (normal[i].Health > maxhealth) {
          index = i;
          maxhealth = normal[i].Health;
        }
      }

      // now apply the health items, using the same logic as Heretic and Hexen
      count = (saveHealth+maxhealth-1)/maxhealth;
      foreach (auto i; 0..count) {
        saved += maxhealth;
        saveHealth -= maxhealth;
        if (!(--normal[index].Amount)) {
          // used last of a type, compact the artifact list
          normal[index].Destroy();
        }
      }
    }

    Health += saved;
  } else if (superhealth >= saveHealth) {
    // Use mystic urns
    while (super.length > 0 && saveHealth > 0) {
      int maxhealth = 0;
      int index = -1;

      // find the largest item in the list
      foreach (auto i; 0..super.length-1) {
        if (super[i].Health > maxhealth) {
          index = i;
          maxhealth = super[i].Health;
        }
      }

      // now apply the health items, using the same logic as Heretic and Hexen.
      count = (saveHealth+maxhealth-1)/maxhealth;
      foreach (auto i; 0..count) {
        saved += maxhealth;
        saveHealth -= maxhealth;
        if (!(--super[index].Amount)) {
          // used last of a type, compact the artifact list
          super[index].Destroy();
        }
      }
    }

    Health += saved;
  } else if (Level.World.bSkillAutoUseHealth && normalhealth+superhealth >= saveHealth) {
    // use mystic urns and quartz flasks
    while (normal.length > 0 && saveHealth > 0) {
      int maxhealth = 0;
      int index = -1;

      // find the largest item in the list
      foreach (auto i; 0..normal.length-1) {
        if (normal[i].Health > maxhealth) {
          index = i;
          maxhealth = normal[i].Health;
        }
      }

      // now apply the health items, using the same logic as Heretic and Hexen
      count = (saveHealth+maxhealth-1)/maxhealth;
      foreach (auto i; 0..count) {
        saved += maxhealth;
        saveHealth -= maxhealth;
        if (!(--normal[index].Amount)) {
          // used last of a type, compact the artifact list
          normal[index].Destroy();
        }
      }
    }

    Health += saved;
    if (saveHealth > 0) {
      while (super.length > 0 && saveHealth > 0) {
        int maxhealth = 0;
        int index = -1;

        // find the largest item in the list
        foreach (auto i; 0..super.length-1) {
          if (super[i].Health > maxhealth) {
            index = i;
            maxhealth = super[i].Health;
          }
        }

        // now apply the health items, using the same logic as Heretic and Hexen
        count = (saveHealth+maxhealth-1)/maxhealth;
        foreach (auto i; 0..count) {
          saved += maxhealth;
          saveHealth -= maxhealth;
          if (!(--super[index].Amount)) {
            // used last of a type, compact the artifact list
            super[index].Destroy();
          }
        }
      }

      Health += saved;
    }
  }
  Player.Health = Health;
}


//==========================================================================
//
//  AutoUseStrifeHealth
//
//==========================================================================
final void AutoUseStrifeHealth (int saveHealth) {
  array!Inventory Items;
  int itemshealth;

  for (Inventory inv = Inventory; inv; inv = inv.Inventory) {
    if (inv && inv.Amount > 0 && ClassIsChildOf(inv.Class, HealthPickup)) {
      int mode = HealthPickup(inv).AutoUseMode;
      if (mode == 3) {
        /*
        Items.Num = Items.Num+1;
        Items[Items.Num-1] = inv;
        */
        Items[$] = inv;
      }
    }
  }

  foreach (auto i; 0..Items.length) itemshealth += Items[i].Amount*Items[i].Health;

  while (Items.length > 0) {
    int maxhealth = 0;
    int index = -1;

    // find the largest item in the list
    foreach (auto i; 0..Items.length) {
      if (Items[i].Health > maxhealth) {
        index = i;
        maxhealth = Items[i].Amount;
      }
    }

    while (Health < 50) {
      if (!UseInventory(Items[index])) break;
    }
    if (Health >= 50) {
      Player.Health = Health;
      return;
    }

    // using all of this item was not enough so delete it and restart with the next best one
    Items[index] = none;
    if (index < Items.length) {
      for (int i = Items.length-index; i < Items.length-1; ++i) Items[i] = Items[i+1];
    }
    Items.length -= 1;
  }

  Player.Health = Health;
}


//==========================================================================
//
//  AutoUseArmor
//
//==========================================================================
final void AutoUseArmor () {
  Inventory Item = FindInventory(MetalArmor);
  if (Item) {
    // use metal armor
    Item.Use(false);
    if (!(--Item.Amount)) Item.Destroy();
  } else {
    Item = FindInventory(LeatherArmor);
    if (Item) {
      // use leather armor
      Item.Use(false);
      if (!(--Item.Amount)) Item.Destroy();
    }
  }
}


//==========================================================================
//
//  HITDICE
//
//  Most damage in HERETIC and HEXEN defined using HITDICE
//
//==========================================================================
final int HITDICE (int a) {
  return (1+(P_Random()&7))*a;
}


//==========================================================================
//
//  SpawnDirt
//
//  Dirt stuff
//
//==========================================================================
final void SpawnDirt (float radius) {
  TVec org;
  class!EntityEx dtype;

  float angle = 360.0*Random();
  float sina, cosa;
  sincos(angle, out sina, out cosa);
  org.x = Origin.x+radius*cosa;
  org.y = Origin.y+radius*sina;
  org.z = Origin.z+Random()*2.0+1.0;
  switch (P_Random()%6) {
    case 0: dtype = Dirt1; break;
    case 1: dtype = Dirt2; break;
    case 2: dtype = Dirt3; break;
    case 3: dtype = Dirt4; break;
    case 4: dtype = Dirt5; break;
    case 5: dtype = Dirt6; break;
  }
  EntityEx dirt = SpawnEntityChecked(class!EntityEx, dtype, org);
  if (dirt) dirt.Velocity.z = Random()*4.0*35.0;
}


//===========================================================================
//
//  GunShot
//
//===========================================================================
final void GunShot (bool accurate, TVec dir, name DmgType, bool secondary, optional name DecalName,
                    optional float range, optional float spreadYaw, optional float spreadPitch)
{
  if (!specified_range || range <= 0) range = MISSILERANGE;

  // make a copy of angles because inacurate shoot will modify them
  if (!accurate) {
    TAVec angles;
    VectorAngles(dir, out angles);
    if (!specified_spreadYaw) {
      angles.yaw = AngleMod360(angles.yaw+(FRandomFull()-FRandomFull())*45.0/8.0);
    } else {
      if (spreadYaw) angles.yaw = AngleMod360(angles.yaw+(FRandomFull()-FRandomFull())*spreadYaw);
    }
    if (spreadPitch) angles.pitch = AngleMod360(angles.pitch+(FRandomFull()-FRandomFull())*spreadPitch);
    AngleVector(angles, out dir);
  }

  int damage = 5*(P_Random()%3+1);
  LineAttack(dir, range, damage, BulletPuff, DmgType:DmgType, secondary:secondary, decalType:DecalName!optional);
}


//===========================================================================
//
//  IsMissile
//
//===========================================================================
final bool IsMissile (bool Precise) {
  return bMissile || (Precise && default.bMissile);
}


//===========================================================================
//
//  k8CheckIfSpecialStateLabel
//
//===========================================================================
final bool k8CheckIfSpecialStateLabel (name Label) {
  if (!Label) return true; // why not?
  if (GetCvarB('_decorate_dont_warn_about_invalid_labels')) return true;
  string lbl = string(Label);
  return (stricmp(lbl, "none") == 0 || stricmp(lbl, "null") == 0 ||
          stricmp(lbl, "nil") == 0 || stricmp(lbl, "empty") == 0);
}


//===========================================================================
//
//  FindJumpState
//
//  used in decorate code to resolve jump-labels-as-arguments
//  gzshit just skips jump when invalid state name provided,
//  but i don't care what gzshit does, really.
//  i'll try to spam console with invalid label name, though
//
//===========================================================================
final state FindJumpState (name Label) {
  // in state call chain?
  if (XLevel.StateCall) {
    // `item` is the original caller, we should follow its states here
    state res = XLevel.StateCall->Item.FindState(Label);
    //printdebug("%C (item=%C); state=%s (%s)", self, XLevel.StateCall->Item, Label, res);
    if (!res && !k8CheckIfSpecialStateLabel(Label)) {
      printwarn("unknown decorate label (statecall) '%s' -- probably broken actor '%C' code! (Item=%C)", Label, self, XLevel.StateCall->Item);
      if (GetCvarB('dbg_emulate_broken_gozzo_gotos')) res = GetNextState(XLevel.CallingState);
    }
    return res;
  }

  // special weapon states?
  if (bIsPlayer) {
    // weapon?
    if (XLevel.CallingState == Player.ViewStates[PS_WEAPON].State) {
      if (!PlayerEx(Player).ReadyWeapon) return none;
      state res = PlayerEx(Player).ReadyWeapon.FindState(Label);
      if (!res && !k8CheckIfSpecialStateLabel(Label)) {
        printwarn("unknown decorate label (PS_WEAPON) '%s' -- probably broken actor '%C' code!", Label, PlayerEx(Player).ReadyWeapon);
        if (GetCvarB('dbg_emulate_broken_gozzo_gotos')) res = GetNextState(XLevel.CallingState);
      }
      return res;
    }

    // muzzle flash?
    if (XLevel.CallingState == Player.ViewStates[PS_FLASH].State) {
      if (!PlayerEx(Player).ReadyWeapon) return none;
      state res = PlayerEx(Player).ReadyWeapon.FindState(Label);
      if (!res && !k8CheckIfSpecialStateLabel(Label)) {
        printwarn("unknown decorate label (PS_FLASH) '%s' -- probably broken actor '%C' code!", Label, PlayerEx(Player).ReadyWeapon);
        if (GetCvarB('dbg_emulate_broken_gozzo_gotos')) res = GetNextState(XLevel.CallingState);
      }
      return res;
    }

    // weapon overlay?
    if (XLevel.CallingState == Player.ViewStates[PS_WEAPON_OVL].State) {
      if (!PlayerEx(Player).ReadyWeapon) return none;
      state res = PlayerEx(Player).ReadyWeapon.FindState(Label);
      if (!res && !k8CheckIfSpecialStateLabel(Label)) {
        printwarn("unknown decorate label (PS_WEAPON_OVL) '%s' -- probably broken actor '%C' code!", Label, PlayerEx(Player).ReadyWeapon);
        if (GetCvarB('dbg_emulate_broken_gozzo_gotos')) res = GetNextState(XLevel.CallingState);
      }
      return res;
    }
  }

  // normal state jump
  state res = FindState(Label);
  if (!res && !k8CheckIfSpecialStateLabel(Label)) {
    printwarn("unknown decorate label '%s' -- probably broken actor '%C' code!", Label, self);
    if (GetCvarB('dbg_emulate_broken_gozzo_gotos')) res = GetNextState(XLevel.CallingState);
  }

  return res;
}


//===========================================================================
//
//  FindJumpStateOfs
//
//  this is to support idiocities like `A_Jump(n, func())`
//
//===========================================================================
final state FindJumpStateOfs (int offset) {
  state res = XLevel.CallingState;
  if (!res) return none;
  if (offset == 0) {
    // this is fuckin' bug, but some idiots may rely on it
    printwarn("Bad zero jump offset in decorate action for '%C' (%s)", self, XLevel.CallingState);
    return GetNextState(res);
  }
  if (offset < 0) {
    // abort it, this is a bug
    printwarn("Bad negative jump offset in decorate action for '%C' (%s)", self, XLevel.CallingState);
    return none;
  }
  res = GetStatePlus(res, offset, IgnoreJump:true);
  if (!res) {
    printwarn("Bad jump offset (runaway) in decorate action for '%C' (%s)", self, XLevel.CallingState);
  }
  return res;
}


//===========================================================================
//
//  DoJump
//
//  mostly called from decorate actions
//
//===========================================================================
final void DoJump (state State, optional bool affectStateCallResult) {
  if (XLevel.StateCall) {
    XLevel.StateCall->State = State;
    // shoult state jump affect state chain results?
    if (!affectStateCallResult) XLevel.StateCall->Result = 0;
  } else if (bIsPlayer && XLevel.CallingState == Player.ViewStates[PS_WEAPON].State) {
    PlayerEx(Player).SetViewObjectIfNone(PlayerEx(Player).ReadyWeapon);
    Player.SetViewState(PS_WEAPON, State);
  } else if (bIsPlayer && XLevel.CallingState == Player.ViewStates[PS_FLASH].State) {
    PlayerEx(Player).SetViewObjectIfNone(PlayerEx(Player).ReadyWeapon);
    Player.SetViewState(PS_FLASH, State);
  } else if (bIsPlayer && XLevel.CallingState == Player.ViewStates[PS_WEAPON_OVL].State) {
    PlayerEx(Player).SetViewObjectIfNone(PlayerEx(Player).ReadyWeapon);
    Player.SetViewState(PS_WEAPON_OVL, State);
  } else {
    SetState(State);
  }
  // state jumps should not affect state chain results
  //if (!keepChainRes && XLevel.StateCall) XLevel.StateCall->Result = false;
}


//==========================================================================
//
//  CheckForSectorActions
//
//==========================================================================
override void CheckForSectorActions (sector_t *OldSec, bool OldAboveFakeFloor, bool OldAboveFakeCeiling) {
  // check for crossing fake floor or ceiling
  if (OldSec->heightsec && Sector->heightsec && Sector->ActionList) {
    float EyeZ = (bIsPlayer ? Player.ViewOrg.z : Origin.z+Height*0.5);
    float FakeZ = GetPointZClamped(ref Sector->heightsec->floor, Origin);

    if (!OldAboveFakeFloor && EyeZ > FakeZ) {
      SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesSurface);
    } else if (OldAboveFakeFloor && EyeZ <= FakeZ) {
      SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesDive);
    }

    if (!Sector->heightsec->bFakeFloorOnly) {
      FakeZ = GetPointZClamped(ref Sector->heightsec->ceiling, Origin);
      if (!OldAboveFakeCeiling && EyeZ > FakeZ) {
        SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesSurface);
      } else if (OldAboveFakeCeiling && EyeZ <= FakeZ) {
        SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesBelowC);
      }
    }
  }

  // check for sector change triggers
  if (OldSec != Sector) {
    if (OldSec->ActionList) {
      SectorAction(OldSec->ActionList).TriggerAction(self, SectorAction::SECSPAC_Exit);
    }
    if (Sector->ActionList) {
      int Spac = SectorAction::SECSPAC_Enter;
      if (Origin.z <= GetPointZClamped(ref Sector->floor, Origin)) Spac |= SectorAction::SECSPAC_HitFloor;
      if (Origin.z+Height >= GetPointZClamped(ref Sector->ceiling, Origin)) Spac |= SectorAction::SECSPAC_HitCeiling;
      if (Sector->heightsec && Origin.z == GetPointZClamped(ref Sector->heightsec->floor, Origin)) Spac |= SectorAction::SECSPAC_HitFakeFloor;
      SectorAction(Sector->ActionList).TriggerAction(self, Spac);
    }
  }
}


//==========================================================================
//
//  CheckFakeFloorTriggers
//
//==========================================================================
final void CheckFakeFloorTriggers (float OldZ, optional bool OldHasViewH) {
  if (Sector && Sector->heightsec && Sector->ActionList) {
    float ViewH = (bIsPlayer ? PlayerEx(Player).ViewHeight : Height*0.5);
    float FakeZ = GetPointZClamped(ref Sector->heightsec->floor, Origin);

    if (OldZ > FakeZ && Origin.z <= FakeZ) {
      SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_HitFakeFloor);
      if (!Sector || !Sector->heightsec || !Sector->ActionList) return;
    }

    float EyeZ = Origin.z+ViewH;
    if (!OldHasViewH) OldZ += ViewH;

    if (OldZ <= FakeZ && EyeZ > FakeZ) {
      SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesSurface);
    } else if (OldZ > FakeZ && EyeZ <= FakeZ) {
      SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesDive);
    }
    if (!Sector || !Sector->heightsec || !Sector->ActionList) return;

    if (!Sector->heightsec->bFakeFloorOnly) {
      FakeZ = GetPointZClamped(ref Sector->heightsec->ceiling, Origin);
      if (OldZ <= FakeZ && EyeZ > FakeZ) {
        SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesAboveC);
      } else if (OldZ > FakeZ && EyeZ <= FakeZ) {
        SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesBelowC);
      }
    }
  }
}


//==========================================================================
//
//  UseLines
//
//  Looks for special lines in front of the actor to activate
//
//==========================================================================
final bool UseLines (float UseRange, float UseThingRange, name FailSound,
                     optional bool delegate (line_t *ld) checkLineUseDg,
                     optional void delegate (line_t *ld) onLineUsedDg,
                     optional bool delegate (EntityEx th) checkThingUseDg,
                     optional void delegate (EntityEx th) onThingUsedDg)
{
  TVec useDir;
  intercept_t *in;
  opening_t *open;

  bool anythingUsed = false;
  bool action = false;
  bool hitLineOrThing = false;
  AngleVector(Angles, out useDir);
  float x1 = Origin.x;
  float y1 = Origin.y;

  // check things
  float x2 = x1+UseThingRange*useDir.x;
  float y2 = y1+UseThingRange*useDir.y;
  foreach PathTraverse(in, x1, y1, x2, y2, PT_ADDLINES|PT_ADDTHINGS/*|PT_EARLYOUT*/) {
    if (!in->bIsALine) {
      // check height
      if (Origin.z >= in->Thing.Origin.z+in->Thing.Height ||
          Origin.z+Height <= in->Thing.Origin.z)
      {
        continue;
      }

      // don't use self
      if (in->Thing != self) {
        EntityEx ee = EntityEx(in->Thing);
        if (!ee) continue;
        if (checkThingUseDg && !checkThingUseDg(ee)) continue;
        if (!UseThing(ee)) {
          if (!hitLineOrThing) {
            if (ee.bSolid && !ee.bCorpse && !ee.bMissile && !ee.bMonster && !ee.bInvisible) hitLineOrThing = true;
          }
          continue;
        }
        hitLineOrThing = true;
        if (onThingUsedDg) onThingUsedDg(ee);
        action = true;
        anythingUsed = true;
        break;
      }

      continue;
    }

    if (!(in->line->flags&ML_TWOSIDED)) break; // stop

    TVec hitPoint = Origin+(UseThingRange*in->frac)*useDir;
    //open = LineOpenings(in->line, hitPoint);
    //open = FindOpening(open, hitPoint.z, hitPoint.z+Height);
    open = FindLineOpening(in->line, hitPoint, Height);
    if (!open || open->range < 1.0) break; // can't use through a wall
  }

  // check lines
  x2 = x1+UseRange*useDir.x;
  y2 = y1+UseRange*useDir.y;
  bool DoSecAct = true;
  bool FoundLine = false;
  bool buttonSuccess;
  int useType, useSide;
  foreach PathTraverse(in, x1, y1, x2, y2, PT_ADDLINES) {
    line_t *line = in->line;

    if (!line->special || (!(line->SpacFlags&(SPAC_Use|SPAC_UseThrough|SPAC_UseBack)))) {
      TVec hitPoint = Origin+(UseRange*in->frac)*useDir;

      if (line->flags&(ML_BLOCKEVERYTHING|ML_BLOCKUSE)) {
        // gozzo does this
        open = nullptr;
      } else {
        //open = LineOpenings(line, hitPoint);
        //open = FindOpening(open, hitPoint.z, hitPoint.z+Height);
        open = FindLineOpening(line, hitPoint, Height);
      }

      if (!open || open->range <= 0.0 || (line->special && Level.CompatUseBlocking)) {
        if (checkLineUseDg && !checkLineUseDg(line)) continue;

        DoSecAct = false;

        // let sector intercept the use
        if (Sector && Sector->ActionList && SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_Use)) {
          if (onLineUsedDg) onLineUsedDg(line);
          anythingUsed = true;
          break;
        }

        sector_t *Sec = (PointOnPlaneSide(Origin, *line) == 0 ? line->frontsector : line->backsector);
        if (Sec && Sec->ActionList && SectorAction(Sec->ActionList).TriggerAction(self, SectorAction::SECSPAC_UseWall)) {
          if (onLineUsedDg) onLineUsedDg(line);
          anythingUsed = true;
          break;
        }

        //!if (FailSound) PlaySound(FailSound, CHAN_VOICE);
        hitLineOrThing = true;

        // can't use through a wall
        break;
      }

      // not a special line, but keep checking
      float pheight = Origin.z+Height/2.0;
      if (FailSound && (open->top < pheight || open->bottom > pheight)) {
        //PlaySound(FailSound, CHAN_VOICE);
        hitLineOrThing = true;
      }
      if (checkLineUseDg && !checkLineUseDg(line)) continue;
      FoundLine = true;
      continue;
    }

    // check side, set use type
    if (PointOnPlaneSide(Origin, *line) == 1) {
      // back side
      if (!(line->SpacFlags&SPAC_UseBack)) continue;
      //k8: gozzo doesn't check this, but we'll do
      // don't use back side unless it's a two-sided line
      if (line->backsector != nullptr) continue;
      useType = SPAC_UseBack;
      useSide = 1;
    } else {
      // front side
      if (line->SpacFlags&(SPAC_UseBack|SPAC_Use|SPAC_UseThrough) == SPAC_UseBack) continue; // can't be used from front, skip it
      if (checkLineUseDg && !checkLineUseDg(line)) continue;
      useType = SPAC_Use;
      useSide = 0;
    }
    // check delegate callback
    if (checkLineUseDg && !checkLineUseDg(line)) continue;

    // check height here?
    hitLineOrThing = true;

    // k8: there was no check; why?
    if (LineSpecialLevelInfo(Level).ActivateLine(line, self, useSide, useType, out buttonSuccess)) {
      if (onLineUsedDg) onLineUsedDg(line);
      action = true;
      if (buttonSuccess) anythingUsed = true;
    }

    //WAS can't use more than one special line in a row
    //jff 3/21/98 NOW multiple use allowed with enabling line flag
    if (Level.CompatUseBlocking) {
      if (!(line->SpacFlags&SPAC_UseThrough)) {
        DoSecAct = false;
        break;
      }
    } else if (line->SpacFlags&SPAC_Use) {
      DoSecAct = false;
      break;
    }
  }

  if (DoSecAct && Sector->ActionList) {
    // let sector intercept the use
    int Spac = SectorAction::SECSPAC_Use;
    if (FoundLine) Spac |= SectorAction::SECSPAC_UseWall;
    if (SectorAction(Sector->ActionList).TriggerAction(self, Spac)) {
      anythingUsed = true;
    }
  }

  if (!anythingUsed && FailSound && hitLineOrThing) PlaySound(FailSound, CHAN_VOICE);

  return action;
}


//==========================================================================
//
//  UseThing
//
//==========================================================================
bool UseThing (EntityEx Other) {
  if (Other.bNoInteraction) return false; //k8: just in case

  //print("UseThing000: self=%C; Other=%C; Other.bUseSpecial=%s; Other.Special=%s", self, Other, Other.bUseSpecial, Other.Special);
  if (Other.bUseSpecial && Other.Special) {
    auto swd = SwitchableDecoration(Other);
    if (swd && swd.ActivationType) {
      printwarn("activation type for thing specials aren't implemented yet! %C:ActivationType=0x%08x", Other, swd.ActivationType);
    }
    if (Level.ExecuteActionSpecial(
      Other.Special, Other.Args[0], Other.Args[1], Other.Args[2],
      Other.Args[3], Other.Args[4], nullptr, 0, self))
    {
      if (swd && (swd.ActivationType&SwitchableDecoration::AF_ClearSpecial)) { Other.Special = 0; foreach (ref auto v; Other.Args) v = 0; }
      return true;
    }
  }
  if (Other.bUseSpecial) {
    auto swd = SwitchableDecoration(Other);
    if (swd && swd.ActivationType) {
      //print("UseThing001: SWD! self=%C; Other=%C", self, Other);
      if (swd.Activate(self)) return true;
    }
  }
  //print("UseThing002: self=%C; Other=%C", self, Other);
  return LineSpecialLevelInfo(Level).StartConversation(self, Other);
}


//==========================================================================
//
//  IsSentient
//
//  killough 11/98:
//  Whether an object is "sentient" or not.
//  Used for environmental influences.
//
//==========================================================================
final bool IsSentient () {
  return Health > 0 && SeeState;
}


//==========================================================================
//
//  IsFast
//
//==========================================================================
final bool IsFast () {
  if (bAlwaysFast) return true;
  if (bNeverFast) return false;
  return (Level.Game.fastparm == 1);
}


//==========================================================================
//
//  RespawnResetFlags
//
//  Reset most of the flags to the default values on respawn.
//
//==========================================================================
void RespawnResetFlags () {
  //k8: restore these too
  RenderStyle = default.RenderStyle;
  Alpha = default.Alpha;
  Translation = default.Translation;
  StencilColor = default.StencilColor;
  FloorClip = default.FloorClip;
  ScaleX = default.ScaleX;
  ScaleY = default.ScaleY;

  bSpecial = default.bSpecial;
  bSolid = default.bSolid;
  bShootable = default.bShootable;
  bAmbush = default.bAmbush;
  bJustHit = default.bJustHit;
  bJustAttacked = default.bJustAttacked;
  bSpawnCeiling = default.bSpawnCeiling;
  bNoGravity = default.bNoGravity;
  bDropOff = default.bDropOff;
  bPickUp = default.bPickUp;
  bFloat = default.bFloat;
  bMissile = default.bMissile;
  bDropped = default.bDropped;
  bShadow = default.bShadow;
  bNoBlood = default.bNoBlood;
  bCorpse = default.bCorpse;
  bInFloat = default.bInFloat;
  bCountKill = default.bCountKill;
  bCountItem = default.bCountItem;
  bSkullFly = default.bSkullFly;
  bNoDeathmatch = default.bNoDeathmatch;
  bSpawnSoundSource = default.bSpawnSoundSource;
  bNoLiftDrop = default.bNoLiftDrop;
  bStealth = default.bStealth;
  bIceCorpse = default.bIceCorpse;

  bDontReflect = default.bDontReflect;
  bWindThrust = default.bWindThrust;
  bBlasted = default.bBlasted;
  bFly = default.bFly;
  bFloorClip = default.bFloorClip;
  bSpawnFloat = default.bSpawnFloat;
  bNoTeleport = default.bNoTeleport;
  bRip = default.bRip;
  bPushable = default.bPushable;
  bSlide = default.bSlide;
  bOnMobj = default.bOnMobj;
  bPassMobj = default.bPassMobj;
  bCannotPush = default.bCannotPush;
  bThruGhost = default.bThruGhost;
  bBoss = default.bBoss;
  bDontTranslate = default.bDontTranslate;
  bNoDamageThrust = default.bNoDamageThrust;
  bTelestomp = default.bTelestomp;
  bFloatBob = default.bFloatBob;
  bActivateImpact = default.bActivateImpact;
  bActivatePushWall = default.bActivatePushWall;
  bActivateMCross = default.bActivateMCross;
  bActivatePCross = default.bActivatePCross;
  bCantLeaveFloorpic = default.bCantLeaveFloorpic;
  bNonShootable = default.bNonShootable;
  bInvulnerable = default.bInvulnerable;
  bSeekerMissile = default.bSeekerMissile;
  bReflective = default.bReflective;

  bIgnoreFloorStep = default.bIgnoreFloorStep;
  bIgnoreCeilingStep = default.bIgnoreCeilingStep;
  bNoRadiusDamage = default.bNoRadiusDamage;
  bGhost = default.bGhost;
  bAlwaysPuff = default.bAlwaysPuff;
  bNoSplash = default.bNoSplash;
  bDontOverlap = default.bDontOverlap;
  bNoMorph = default.bNoMorph;
  bDontSquash = default.bDontSquash;
  bFullVolActive = default.bFullVolActive;
  bMonster = default.bMonster;
  bExplodeOnSky = default.bExplodeOnSky;
  bStayMorphed = default.bStayMorphed;
  bDontBlast = default.bDontBlast;
  bCanBlast = default.bCanBlast;
  bNeverTarget = default.bNeverTarget;
  bReallyNeverTarget = default.bReallyNeverTarget;
  bDontGib = default.bDontGib;
  bNoBlockMonst = default.bNoBlockMonst;
  bFullVolDeath = default.bFullVolDeath;
  bCanBounceWater = default.bCanBounceWater;
  bNoWallBounceSnd = default.bNoWallBounceSnd;
  bDamageInvulnerable = default.bDamageInvulnerable;
  bNoTeleOther = default.bNoTeleOther;
  bBloodlessImpact = default.bBloodlessImpact;
  bNoExplodeFloor = default.bNoExplodeFloor;
  bPuffOnActors = default.bPuffOnActors;

  bNoGrudge = default.bNoGrudge;
  bNoIceDeath = default.bNoIceDeath;
  bBossDeath = default.bBossDeath;
  bRandomise = default.bRandomise;
  bActLikeBridge = default.bActLikeBridge;
  bStrifeDamage = default.bStrifeDamage;
  bTriggerHappy = default.bTriggerHappy;
  bMissileEvenMore = default.bMissileEvenMore;
  bForceRadiusDmg = default.bForceRadiusDmg;
  bNoGravKill = default.bNoGravKill;
  bInCombat = default.bInCombat;
  bLookAllAround = default.bLookAllAround;
  bStanding = default.bStanding;
  bSpectral = default.bSpectral;
  bFireResist = default.bFireResist;
  bSynchronised = default.bSynchronised;
  bNoTargetSwitch = default.bNoTargetSwitch;
  bDontHurtSpecies = default.bDontHurtSpecies;
  bShieldReflect = default.bShieldReflect;
  bDeflect = default.bDeflect;
  bPuffParticles = default.bPuffParticles;
  bNoExtremeDeath = default.bNoExtremeDeath;
  bExtremeDeath = default.bExtremeDeath;
  bNoBounceSound = default.bNoBounceSound;

  bFaster = default.bFaster;
  bFastMelee = default.bFastMelee;
  bNoDropOff = default.bNoDropOff;
  bBounceOnActors = default.bBounceOnActors;
  bExplodeOnWater = default.bExplodeOnWater;
  bAvoidingDropoff = default.bAvoidingDropoff;
  bNoDamage = default.bNoDamage;
  bChaseGoal = default.bChaseGoal;
  bPierceArmor = default.bPierceArmor;
  bNoPain = default.bNoPain;
  bAlwaysFast = default.bAlwaysFast;
  bNeverFast = default.bNeverFast;
  bCanUseWalls = default.bCanUseWalls;

  bDontThrust = default.bDontThrust;

  DecalName = default.DecalName;
}


//==========================================================================
//
//  CalcFakeZMovement
//
//==========================================================================
override void CalcFakeZMovement (out TVec Ret, float DeltaTime) {
  // adjust height
  Ret = Origin;
  Ret.z += Velocity.z*DeltaTime;
  if (bFloat && Target) {
    // float down towards enemy if too close
    if (!bSkullFly && !bInFloat) {
      float dist = DistTo2(Target);
      float delta = Target.Origin.z+Height/2.0-Ret.z;
      if (delta < 0.0 && dist < -(delta*3.0)) {
        Ret.z -= FloatSpeed*DeltaTime;
      } else if (delta > 0.0 && dist < delta*3.0) {
        Ret.z += FloatSpeed*DeltaTime;
      }
    }
  }
  if (bIsPlayer && bFly && Ret.z > FloorZ /*&& (XLevel.TicTime&2)*/) {
    //FIXME: this is time-dependent, rewrite!
    //Ret.z += sin(90.0*35.0/20.0*AngleMod360(int(XLevel.TicTime)))/2.0;
    Ret.z = PlayerEx(Player).CalcFlyZ(Ret.z);
  }
}


//===========================================================================
//
//  DoThingRaise
//
//===========================================================================
final bool DoThingRaise (optional bool skipCheckPosition) {
  if (!bCorpse) return false; // not a monster

  if (StateTime != -1.0) {
    // not lying still yet; check frame flag
    if (!State) return false;
    if ((GetStateSpriteFrame(State)&FF_CANRAISE) == 0) return false;
  }

  state RaiseState = FindState('Raise');
  if (!RaiseState) return false; // monster doesn't have a raise state

  Velocity.x = 0.0;
  Velocity.y = 0.0;
  float OldHeight = Height;
  float OldRadius = Radius;
  bool OldSolid = bSolid;
  bSolid = true;
  Height = default.Height;

  if (!skipCheckPosition) {
    if (!CheckPosition(Origin)) {
      Height = OldHeight;
      Radius = OldRadius;
      bSolid = OldSolid;
      return false; // doesn't fit here
    }
  }

  PlaySound('vile/raise', /*CHAN_BODY*/CHAN_AUTO);

  SetState(RaiseState);
  bShootable = true;
  bFloat = default.bFloat;
  bNoGravity = default.bNoGravity;
  bDropOff = false;
  bSolid = true;
  bCorpse = false;
  Health = InitialHealth;
  Target = none;
  LastEnemy = none;
  //!LastPlayerSeenPosValid = false;

  // if it counts as kill, count it as another one
  if (CountsAsKill()) ++Level.TotalKills;
  return true;
}


//==========================================================================
//
//  GetInfighting
//
//==========================================================================
final int GetInfighting () {
  if (bNoInfighting) return -1;
  if (Level.Infighting) return Level.Infighting;
  return GetCvar('infighting');
}


//==========================================================================
//
//  IsFriend
//
//==========================================================================
final bool IsFriend (EntityEx Other) {
  if (!Other) return false;
  if (bFriendly && Other.bFriendly) {
    return !Level.Game.deathmatch || FriendPlayer == Other.FriendPlayer ||
           FriendPlayer == 0 || Other.FriendPlayer == 0;
  }
  return false;
}


//==========================================================================
//
//  IsHostile
//
//==========================================================================
final bool IsHostile (EntityEx Other) {
  if (!Other) return false;
  // if bot monsters are not friendles, hostiles depend on infighting.
  if (!bFriendly && !Other.bFriendly) return false;

  if (bFriendly && Other.bFriendly) {
    return Level.Game.deathmatch && FriendPlayer != Other.FriendPlayer &&
           FriendPlayer != 0 && Other.FriendPlayer != 0;
  }
  return true;
}


//==========================================================================
//
//  ClassifyActor
//
//==========================================================================
override int ClassifyActor () {
  int Ret = 0;
  if (bIsPlayer) {
    Ret |= ACTOR_PLAYER;
    Ret |= (Player.PlayerState == PST_DEAD ? ACTOR_DEAD : ACTOR_ALIVE);
    if (Player.MO != self) Ret |= ACTOR_VOODOODOLL;
    if (Player.bIsBot) Ret |= ACTOR_BOT;
  } else if (bMonster) {
    Ret |= ACTOR_MONSTER;
    Ret |= (Health <= 0 ? ACTOR_DEAD : ACTOR_ALIVE);
  } else if (bMissile) {
    Ret |= ACTOR_MISSILE;
  } else {
    Ret |= ACTOR_GENERIC;
  }
  return Ret;
}


//==========================================================================
//
//  CountsAsKill
//
//==========================================================================
final bool CountsAsKill () {
  return bCountKill && !bFriendly;
}


//==========================================================================
//
//  GetViewEntRenderParams
//
//==========================================================================
override void GetViewEntRenderParams (ref float OutAlpha, ref int OutRenderStyle) {
  if (Inventory) {
    Inventory.GetViewEntRenderParams(OutAlpha, OutRenderStyle);
  }
}


//==========================================================================
//
//  CopyFriendliness
//
//==========================================================================
void CopyFriendliness (EntityEx Src, bool ChangeTarget) {
  Level.TotalKills -= CountsAsKill();
  TIDToHate = Src.TIDToHate;
  LastLook = Src.LastLook;
  LastLookActor = Src.LastLookActor;
  bFriendly = Src.bFriendly;
  bNoSightCheck = Src.bNoSightCheck;
  bHuntPlayers = Src.bHuntPlayers;
  bNoHatePlayers = Src.bNoHatePlayers;
  FriendPlayer = Src.FriendPlayer;
  Level.TotalKills += CountsAsKill();
  if (ChangeTarget && Src.Target && !Src.Target.bNeverTarget && !Src.Target.bReallyNeverTarget) {
    Target = Src.Target;
    LastHeard = Src.Target;
    //!LastPlayerSeenPos = Src.LastPlayerSeenPos;
    //!LastPlayerSeenPosValid = Src.LastPlayerSeenPosValid;
  }
}


//==========================================================================
//
//  IsTeammate
//
//==========================================================================
bool IsTeammate (EntityEx Other) {
  return bIsPlayer && Other.bIsPlayer && Level.Game.netgame && !Level.Game.deathmatch;
}


//==========================================================================
//
//  IsNotAttackingMaster
//
//==========================================================================
bool IsNotAttackingMaster (EntityEx Other) {
  return false;
}


//==========================================================================
//
//  IsMaster
//
//==========================================================================
bool IsMaster (EntityEx Other) {
  return false;
}


//==========================================================================
//
//  IsServant
//
//==========================================================================
bool IsServant () {
  return false;
}


//==========================================================================
//
//  TouchSpecial
//
//==========================================================================
void TouchSpecial (EntityEx Toucher, optional bool noflash) {
}


//==========================================================================
//
//  checkIfTargetInLOS
//
//  workhorse for following decorate LOS checks
//
//==========================================================================
final bool checkIfTargetInLOS (optional float Fov, optional int flags, optional float distmax, optional float distclose) {
  if (distmax == 0) distmax = 8192;
  Fov = fabs(Fov);

  // according to https://zdoom.org/wiki/A_JumpIfTargetInLOS
  if ((flags&JLOSF_PROJECTILE) && !bMissile) flags &= ~JLOSF_PROJECTILE;

  EntityEx Targ;
  if (!bIsPlayer) {
    Targ = Target;
    // according to https://zdoom.org/wiki/A_JumpIfTargetInLOS
         if (flags&JLOSF_CHECKMASTER) Targ = Master;
    else if (flags&JLOSF_CHECKTRACER) Targ = Tracer;
    else if (flags&JLOSF_PROJECTILE) Targ = (bSeekerMissile ? Tracer : none);
  } else {
    // this is prolly called from weapon code, so target is what we have in player's crosshair
    TVec Dir;
    //Targ = Aim(Dir, distmax/*16.0*64.0*/); // old code
    //k8: emulate autoaim in any case
    /*
    bool noAAim = !PlayerEx(Player).bAutoAim, noAAVert = false;
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (Wpn && Wpn.IsAutoaimDisabled()) noAAim = true; //bNoAutoaim;
    if (flags&JLOSF_NOAUTOAIM) noAAim = true;
    noAAVert = noAAim;
    */
    bool noAAim = !!(flags&JLOSF_NOAUTOAIM);
    bool noAAVert = noAAim;
    Targ = Aim(nullptr, 8192/*16*64*/, Angles.yaw, noAutoaim:noAAim, noVertAutoAim:noAAVert);
  }

  // moved here from `!bIsPlayer`
  if (!Targ) return false;

  // check target type flags before other, more expensive flags

  // combatant?
  if (flags&JLOSF_COMBATANTONLY) {
    if (!Targ.bIsPlayer && !Targ.bMonster) return false;
    if (Targ.bCorpse) return false; //k8: i added this too, as corpse is not a combatant
  }

  // dead?
  if ((flags&JLOSF_DEADNOJUMP) && Targ.Health <= 0) return false;

  // ally?
  if (flags&JLOSF_ALLYNOJUMP) {
    //FIXME: incomplete
    if (Targ == self || (bIsPlayer && Targ.bFriendly)) return false;
  }

  // check distance
  if (distclose > 0 && DistTo2(Targ) <= distclose) {
    // "close" in effect, fix flags and fov
    if (flags&JLOSF_CLOSENOJUMP) {
      // it doesn't matter what we'll do here, no jump will be taken
      return false;
    }
    if (flags&JLOSF_CLOSENOFOV) Fov = 0; // all-around vision
    if (flags&JLOSF_CLOSENOSIGHT) flags |= JLOSF_NOSIGHT;
  }

  // check sight
  if (!(flags&JLOSF_NOSIGHT)) {
    //k8: dunno, "better sight" should not be in effect here, i think
    if (flags&JLOSF_TARGETLOS) {
      if (!Targ.CanSee(self, disableBetterSight:true)) return false;
    } else {
      if (!CanSee(Targ, disableBetterSight:true)) return false;
    }
  }

  // check FOV
  if (Fov && Fov < 360.0) {
    if (flags&JLOSF_FLIPFOV) {
      // target fov
      float Ang = AngleMod180(atan2(Origin.y-Targ.Origin.y, Origin.x-Targ.Origin.x)-Targ.Angles.yaw);
      if (fabs(Ang) > Fov/2.0) return false;
    } else {
      // our fov
      float Ang = AngleMod180(atan2(Targ.Origin.y-Origin.y, Targ.Origin.x-Origin.x)-Angles.yaw);
      if (fabs(Ang) > Fov/2.0) return false;
    }
  }

  // all checks passed
  return true;
}


//==========================================================================
//
//  GetViewHeight
//
//==========================================================================
override float GetViewHeight () {
  if (bIsPlayer) {
    auto plr = PlayerEx(Player);
    if (plr) return plr.ViewHeight;
  }
  // check for camera
  foreach (auto playnum; 0..MAXPLAYERS) {
    auto plr = BasePlayer(Level.Game.Players[playnum]);
    if (!plr) continue;
    if (plr.Camera == self) return CameraHeight;
  }
  // defaults to actor half-height
  return ::GetViewHeight();
}


// ////////////////////////////////////////////////////////////////////////// //
states {
DehackedDormantPickup:
  TNT1 A 1050
  TNT1 A -1
  {
    EntityEx  A;

    bInvisible = false;
    bSpecial = true;
    SetState(IdleState);

    // spawn a teleport fog at the new spot
    A = SpawnEntityChecked(class!EntityEx, ItemFog, Origin);
    if (A) A.PlaySound('misc/spawn', CHAN_ITEM);
  }
  Stop
}
