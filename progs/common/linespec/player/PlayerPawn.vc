//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class PlayerPawn : Actor abstract;

const float WALKING_SPEED = 1000;
const float RUNNING_SPEED = 2000;


enum {
  NUM_WEAPON_SLOTS = 10,
  MAX_WEAPONS_PER_SLOT = 8,
}

// default view height
float ViewHeight;

// real height without crouching; -666 means "not initialized"
float RealHeight;

// player is unable to run if health is lower than this
int RunHealth;

// movement speed modifiers
float ForwardMove1;
float ForwardMove2;
float SideMove1;
float SideMove2;

// color translation range
int TranslStart;
int TranslEnd;

// values for Hexen armor
float[5] HexenArmor;

// jump velocity
// MO `JumpVelZ` is used instead
//!float JumpVelZ;

// name displayed in menu
string DisplayName;

// for ArtiHealRadius
name HealRadiusType;

// special mode of the invulnerability powerup
name InvulnerabilityMode;

// which class filter to use
name SpawnClass;

// icon for intermission screen
name ScoreIcon;

// for morphed player classes
class!Weapon MorphWeapon;

// attack offset, relative to the centre of the player
float AttackZOffset;

// damage flash color
int DamageScreenColor;

// maximal health
int MaxHealth;

// K8 Headshots Variables
int k8hsCount;

// weapon slots
class!Weapon[(NUM_WEAPON_SLOTS+1)*MAX_WEAPONS_PER_SLOT] weaponSlotClasses;


//==========================================================================
//
//  GetWeaponInSlot
//
//==========================================================================
class!Weapon GetWeaponInSlot (int slot, int index) {
  if (slot < 0 || slot > NUM_WEAPON_SLOTS) return none;
  if (index < 0 || index >= MAX_WEAPONS_PER_SLOT) return none;
  class!Weapon wpn = weaponSlotClasses[slot*MAX_WEAPONS_PER_SLOT+index];
  if (!wpn) return none;
  class!Weapon repl = class!Weapon(GetClassReplacement(wpn));
  return (repl ? repl : wpn);
}


//==========================================================================
//
//  SetWeaponInSlot
//
//==========================================================================
void SetWeaponInSlot (int slot, int index, class!Weapon wpn) {
  if (slot < 0 || slot > NUM_WEAPON_SLOTS) return;
  if (index < 0 || index >= MAX_WEAPONS_PER_SLOT) return;
  weaponSlotClasses[slot*MAX_WEAPONS_PER_SLOT+index] = wpn;
}


//==========================================================================
//
//  FindWeaponSlot
//
//==========================================================================
bool FindWeaponSlot (class!Weapon WpnClass, out int Slot, out int Index) {
  if (WpnClass) {
    class!Weapon wpnrep = class!Weapon(GetClassReplacement(WpnClass));
    if (!wpnrep) wpnrep = WpnClass;
    foreach (auto sidx; 0..NUM_WEAPON_SLOTS) {
      foreach (auto widx; 0..MAX_WEAPONS_PER_SLOT) {
        class!Weapon swc = GetWeaponInSlot(sidx, widx);
        if (!swc) continue;
        if (swc != WpnClass) continue;
        Slot = sidx;
        Index = widx;
        return true;
      }
    }
  }
  Slot = -1;
  Index = -1;
  return false;
}


//==========================================================================
//
//  NextUsedWeaponSlot
//
//==========================================================================
void NextUsedWeaponSlot (ref int Slot, ref int Index, bool forward) {
  if (Slot < 0) Slot = 0;
  if (Index < 0) Index = (forward ? -1 : 0);
  Slot %= NUM_WEAPON_SLOTS+1;
  Index %= MAX_WEAPONS_PER_SLOT;

  foreach (auto i; 0..MAX_WEAPONS_PER_SLOT*(NUM_WEAPON_SLOTS+1)) {
    if (forward) {
      if (++Index == MAX_WEAPONS_PER_SLOT) {
        Index = 0;
        Slot = (Slot+1)%(NUM_WEAPON_SLOTS+1);
      }
    } else {
      if (--Index == -1) {
        Index = MAX_WEAPONS_PER_SLOT-1;
        Slot = (Slot+NUM_WEAPON_SLOTS)%(NUM_WEAPON_SLOTS+1); // this wraps
      }
    }
    class!Weapon wpnclass = GetWeaponInSlot(Slot, Index);
    if (wpnclass) return;
  }
}


//==========================================================================
//
//  CompareWeaponPosition
//
//==========================================================================
private final int CompareWeaponPosition (class!Weapon a, class!Weapon b) {
  if (a) {
    if (b) {
      // both a and b is here, compare positions (higher is lower ;-) -- nope
      if (a.default.Position == b.default.Position) return 0;
      //if (a.default.Position < b.default.Position) return 1;
      if (a.default.Position > b.default.Position) return 1;
      return -1;
    }
    // a is here, b is not: a is lesser
    return -1;
  }
  // a is not here
  return (b ? 1 : 0);
}


//==========================================================================
//
//  SortWeaponSlot
//
//  TODO: we have array sorting, but only for dynarrays
//
//==========================================================================
void SortWeaponSlot (int wsidx) {
  if (wsidx < 0 || wsidx > NUM_WEAPON_SLOTS) return;
  // use insertion sort to do the work
  int i = 1;
  while (i < MAX_WEAPONS_PER_SLOT) {
    int j = i;
    while (j > 0 && CompareWeaponPosition(GetWeaponInSlot(wsidx, j-1), GetWeaponInSlot(wsidx, j)) > 0) {
      class!Weapon tmp = GetWeaponInSlot(wsidx, j-1);
      SetWeaponInSlot(wsidx, j-1, GetWeaponInSlot(wsidx, j));
      SetWeaponInSlot(wsidx, j, tmp);
      --j;
    }
    ++i;
  }
}


//==========================================================================
//
//  DumpWeaponSlots
//
//==========================================================================
private final void DumpWeaponSlots () {
  dprint("=== player pawn '%C' ===", self);
  foreach (auto sidx; 0..NUM_WEAPON_SLOTS+1) {
    foreach (auto widx; 0..MAX_WEAPONS_PER_SLOT) {
      class!Weapon ww = GetWeaponInSlot(sidx, widx);
      if (ww) dprint("  slot #%d, weapon #%d: %C (priority:%d)", sidx, widx, ww, ww.default.Position);
    }
  }
}


//==========================================================================
//
//  FindAndReplaceWeaponInSlot
//
//==========================================================================
void FindAndReplaceWeaponInSlot (class!Weapon origWpn, class!Weapon newWpn) {
  if (!newWpn) return;
  int nsidx = newWpn.default.SlotNumber;
  if (nsidx < 0 || nsidx > NUM_WEAPON_SLOTS) return;

  if (origWpn == newWpn) origWpn = none;

  bool foundIt = false;

  foreach (auto wsidx; 0..NUM_WEAPON_SLOTS+1) {
    bool needToSort = false;
    int s2idx = 0;
    while (s2idx < MAX_WEAPONS_PER_SLOT) {
      class!Weapon ww = GetWeaponInSlot(wsidx, s2idx);
      if (origWpn) {
        if (ww != origWpn && ww != newWpn) { ++s2idx; continue; }
      } else {
        if (ww != newWpn) { ++s2idx; continue; }
      }
      // i found her!
      if (ww == newWpn) {
        // check if it is in a good slot
        if (wsidx == nsidx) {
          dprint("found new '%C' in slot %d at position %d", ww, wsidx, s2idx);
          ++s2idx;
          foundIt = true;
          needToSort = true;
          continue;
        }
        dprint("removing new '%C' from slot %d at position %d", ww, wsidx, s2idx);
        // nope, bad slot, remove it
      } else if (origWpn && ww == origWpn) {
        // ok
        dprint("removing old '%C' from slot %d at position %d", ww, wsidx, s2idx);
      } else {
        // wtf?!
        FatalError("something is wrong in `FindAndReplaceWeaponInSlot()`!");
      }
      // remove weapon from slot (this autoclears last slot)
      foreach (auto c; s2idx+1..MAX_WEAPONS_PER_SLOT+1) {
        //WeaponSlots[wsidx].Weapons[c-1] = WeaponSlots[wsidx].Weapons[c];
        SetWeaponInSlot(wsidx, c-1, GetWeaponInSlot(wsidx, c));
      }
      // clear last slot
      //WeaponSlots[wsidx].Weapons[MAX_WEAPONS_PER_SLOT] = none;
    }
    // sort modified slot
    if (needToSort) SortWeaponSlot(wsidx);
  }

  if (foundIt) return; // it is already there

  // insert it into slot, and sort a slot
  foreach (auto s2idx; 0..MAX_WEAPONS_PER_SLOT) {
    if (!GetWeaponInSlot(nsidx, s2idx)) {
      dprint("added new '%C' to slot %d at position %d", newWpn, nsidx, s2idx);
      SetWeaponInSlot(nsidx, s2idx, newWpn);
      break;
    }
  }

  //DumpWeaponSlots();
  SortWeaponSlot(nsidx);
  //DumpWeaponSlots();
}


//==========================================================================
//
//  InitializeWeaponSlots
//
//==========================================================================
void InitializeWeaponSlots (LineSpecialGameInfo GI) {
  dprint("*** InitializeWeaponSlots (%C) ***", self);
  DumpWeaponSlots();

  class!Weapon wcls;

  if (GI) {
    foreach (auto sidx; 0..NUM_WEAPON_SLOTS+1) {
      if (!GetWeaponInSlot(sidx, 0)) {
        foreach (auto widx; 0..MAX_WEAPONS_PER_SLOT) {
          class!Weapon wpn = GI.WeaponSlots[sidx].Weapons[widx];
          if (wpn) {
            class!Weapon repl = class!Weapon(GetClassReplacement(wpn));
            if (repl) wpn = repl;
          }
          SetWeaponInSlot(sidx, widx, wpn);
        }
      }
    }
  }

  foreach AllClasses(Weapon, wcls) {
    //if (GetClassName(wcls) == 'AssaultGun') GI.WeaponSlots[4].Weapons[0] = wcls;
    if (wcls.default.SlotNumber < 1 || wcls.default.SlotNumber >= NUM_WEAPON_SLOTS) continue;
    class!Weapon repl = class!Weapon(GetClassReplacement(wcls));
    //print("PLR: weapon '%C'; slot is %d; replacement is %C!", wcls, wcls.default.SlotNumber, repl);
    if (repl && repl != wcls) continue;
    auto st = FindClassState(wcls, 'Ready');
    if (!st) continue; // an abstract base class
    if (!AreStateSpritesPresent(st)) continue;
    //print("PLR: weapon '%C'; slot is %d; priority is %d!", wcls, wcls.default.SlotNumber, wcls.default.Position);
    repl = class!Weapon(GetClassReplacee(wcls));
    //!if (repl) print("  replacee: '%s'", GetClassName(repl));
    FindAndReplaceWeaponInSlot(repl, wcls);
  }

  //print("=== SetupDecorateWeaponSlots (%C) ===", self);
  // fix with replacements
  foreach (auto sidx; 0..NUM_WEAPON_SLOTS+1) {
    foreach (auto widx; 0..MAX_WEAPONS_PER_SLOT) {
      class!Weapon oldwpn = GetWeaponInSlot(sidx, widx);
      if (!oldwpn) continue;
      class!Weapon wpn = class!Weapon(GetClassReplacement(oldwpn));
      //print("sidx=%s; widx=%s; wpn=%C; repl=%C", sidx, widx, oldwpn, wpn);
      SetWeaponInSlot(sidx, widx, wpn);
    }
  }

  DumpWeaponSlots();
}


//==========================================================================
//
//  ShouldDropItems
//
//==========================================================================
override bool ShouldDropItems () {
  return false;
}


//==========================================================================
//
//  AddInventory
//
//==========================================================================
override void AddInventory (Inventory Item) {
  if (!Item) return; //k8: just in case
  ::AddInventory(Item);
  if (bIsPlayer && Item.bInvBar && !PlayerEx(Player).InvPtr) {
    PlayerEx(Player).InvPtr = Item;
    PlayerEx(Player).InvFirst = Item;
  }
}


//==========================================================================
//
//  RemoveInventory
//
//==========================================================================
override void RemoveInventory (Inventory Item) {
  if (!Item) return; //k8: just in case
  bool SelectNewWeap = false;
  if (bIsPlayer) {
    if (PlayerEx(Player).InvPtr == Item) {
      PlayerEx(Player).InvPtr = Item.PrevInv();
      if (!PlayerEx(Player).InvPtr) PlayerEx(Player).InvPtr = Item.NextInv();
    }
    if (PlayerEx(Player).InvFirst == Item) {
      PlayerEx(Player).InvFirst = Item.PrevInv();
      if (!PlayerEx(Player).InvFirst) PlayerEx(Player).InvFirst = Item.NextInv();
    }
    if (PlayerEx(Player).PendingWeapon == Item) PlayerEx(Player).PendingWeapon = none;
    if (PlayerEx(Player).ReadyWeapon == Item) {
      PlayerEx(Player).ReadyWeapon = none;
      PlayerEx(Player).Refire = 0;
      SelectNewWeap = true;
    }
  }

  ::RemoveInventory(Item);

  if (bIsPlayer && Item.bInvBar) PlayerEx(Player).AdjustInvFirst();

  if (SelectNewWeap && !PlayerEx(Player).PendingWeapon) {
    Weapon Best = PlayerEx(Player).BestWeapon();
    if (Best) {
      PlayerEx(Player).SetWeapon(Best);
      PlayerEx(Player).BringUpWeapon();
    }
  }
}


//==========================================================================
//
//  UseInventory
//
//==========================================================================
override bool UseInventory (Inventory Item) {
  if (!Item) return false; //k8: just in case
  // can't use anything while totally frozen
  if (PlayerEx(Player).bTotallyFrozen ||
      (Level.bFrozen &&
      !(PlayerEx(Player).Cheats & PlayerEx::CF_TIMEFREEZE)))
  {
    return false;
  }

  // found match -- try to use
  if (!::UseInventory(Item)) {
    if (!PuzzleItem(Item)) {
      // unable to use artifact, advance pointer
      PlayerEx(Player).PlayerNextArtifact();
    }
    return false;
  }

  PlaySound(Item.UseSound, /*CHAN_BODY*/CHAN_VOICE);
  PlayerEx(Player).ArtifactFlash = 4;
  return true;
}


//==========================================================================
//
//  AdjustSpeed
//
//  this clamps player speed, and applies some boosts/restrictions
//
//==========================================================================
final void AdjustSpeed (ref float forward, ref float side) {
  // when the player has less than 25 health points, he's unable to run
  if (Health < RunHealth) {
    forward = fclamp(forward, -WALKING_SPEED, WALKING_SPEED);
    side = fclamp(side, -WALKING_SPEED, WALKING_SPEED);
  }

  forward *= (forward >= -1000.0 && forward < 1000.0 ? ForwardMove1 : ForwardMove2);
  side *= (side >= -1000.0 && side < 1000.0 ? SideMove1 : SideMove2);

  if (Inventory && !PlayerEx(Player).MorphTime) {
    // adjust for a player with a speed artifact
    float SpeedFactor = Inventory.GetSpeedFactor();
    forward *= SpeedFactor;
    side *= SpeedFactor;
  }

  // when crouching, speed have to be reduced, and player is not allowed to run
  // normal speed is |1000|, running speed is |2000|
  if (crouchfactor != 1) {
    //if (forward) print("old: f=%s; s=%s; nf=%s; ns=%s", forward, side, forward*crouchfactor, side*crouchfactor);
    forward = fclamp(forward, -WALKING_SPEED, WALKING_SPEED);
    side = fclamp(side, -WALKING_SPEED, WALKING_SPEED);
    forward *= crouchfactor;
    side *= crouchfactor;
  }
}


//==========================================================================
//
//  MorphPlayerThink
//
//==========================================================================
void MorphPlayerThink () {
}


//===========================================================================
//
//  GetSigilPieces
//
//===========================================================================
override int GetSigilPieces () {
  return PlayerEx(Player).GetSigilPieces();
}


//==========================================================================
//
//  UnmorphActor
//
//==========================================================================
override int UnmorphActor (Entity Activator, int Force) {
  if (PlayerEx(Player).MorphTime) {
    return PlayerEx(Player).UndoPlayerMorph(Force, (Activator ? PlayerEx(Activator.Player) : none));
  }
  return 0;
}


//==========================================================================
//
//  GetRealHeight
//
//==========================================================================
final float GetRealHeight () {
  float res = RealHeight;
  if (res == -666) {
    res = Height;
    RealHeight = res;
  }
  return res;
}


//==========================================================================
//
//  GetHeight
//
//==========================================================================
override float GetHeight () {
  return (RealHeight == -666 ? Height : RealHeight);
}


//==========================================================================
//
//  SetHeight
//
//==========================================================================
override void SetHeight (float newvalue) {
  RealHeight = newvalue;
  Height = newvalue*crouchfactor;
}


defaultproperties {
  Health = 100;
  Radius = 16.0;
  Height = 56.0;
  PainChance = 1.0;
  Speed = 1.0;
  ReactionCount = 0;
  ViewHeight = 41.0;
  RealHeight = -666;
  ForwardMove1 = 1.0;
  ForwardMove2 = 1.0;
  SideMove1 = 1.0;
  SideMove2 = 1.0;
  JumpVelZ = 8.0 * 35.0;
  AttackZOffset = 8.0;
  DamageScreenColor = 0xffff0000;
  bSolid = true;
  bShootable = true;
  bDropOff = true;
  bPickUp = true;
  bNoDeathmatch = true;
  bFriendly = true;
  bSlide = true;
  bPassMobj = true;
  bActivatePushWall = true;
  bFloorClip = true;
  bWindThrust = true;
  bTelestomp = true;
  bNoBlockMonst = true;
  k8hsCount = 0;
}
