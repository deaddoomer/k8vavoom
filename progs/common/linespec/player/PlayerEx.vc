//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class PlayerEx : BasePlayer abstract;

// player internal flags, for cheats and debug
enum /*cheat_t*/ {
  CF_NOCLIP            = 1<<0, // No clipping, walk through barriers.
  CF_GODMODE           = 1<<1, // No damage, no health loss.
  CF_REGENERATION      = 1<<2, // Regenerate Health points.
  CF_FRIGHTENING       = 1<<3, // Scare monsters away.
  CF_DOUBLEFIRINGSPEED = 1<<4, // Player owns a double firing speed artifact
  CF_HIGHJUMP          = 1<<5, // Player owns a high jump artifact
  CF_TIMEFREEZE        = 1<<6, // Player owns a time freeze artifact
  CF_BUDDHA            = 1<<7, // Normal play, but never looses last 1% of health
};

const float USERANGE      = 64.0;
const float USETHINGRANGE = 64.0; //128.0; //k8:why so far?

const float BLINKTHRESHOLD = 4.0;

// 16 pixels of bob
const float MAXBOB = 16.0;

const int MAXHEALTH      = 100;
const int MAXMORPHHEALTH = 30;

// for screen flashing (red or bright)
float DamageFlash;
float BonusFlash;

// base height above floor for viewz
float ViewHeight;
float PrevViewHeight; // this is used in crouching cheat (and saved there)
float DeltaViewHeight; // bob/squat speed
float Bob; // bounded/scaled total momentum

// who did damage (none for floors/ceilings)
EntityEx Attacker;

float JumpTime;
TVec LocalQuakeHappening; // for each axis

TVec MoveDir;

// for damaging flats
int LastSectorDamageTic;

float HazardTime;
float LastHazardTime;

// bit flags, for cheats and debug
// see cheat_t above
int /*[checkpoint]*/ Cheats;

Weapon /*[checkpoint]*/ ReadyWeapon;
Weapon PendingWeapon; // is none if not changing

// refired shots are less accurate (this is counter)
int Refire;

float FlyHeight;

array!name RevealedMaps;

Inventory InvFirst;
Inventory InvPtr;
float InventoryTime;
int ArtifactFlash;
int InvSize;

Inventory SavedInventory;

bool onground;

bool bRevertCamera; // revert camera if player moves
bool bFrozen; // player cannot move
bool bTotallyFrozen; // player cannot do anything except press use
bool /*[checkpoint]*/ bNoTarget; // monster don't target
bool /*[checkpoint]*/ bInstantWeaponSwitch; // switch weapons instantly
bool bFly; // player is flying
bool bInventoryAlwaysOpen; // inventory bar is always open
bool bAutoAim; // auto aiming enabled? (weapon can override this)

int PoisonCount; // screen flash for poison damage
float LastPoisonTime;
EntityEx Poisoner; // none for non-player mobjs
PlayerEx PoisonerPlayer; // for KArena

int Objectives;

float MorphTime; // player is morphed into something if > 0
int MorphStyle;
class!Actor UnmorphFlash;

int Accuracy;
int Stamina;

float BlendR;
float BlendG;
float BlendB;
float BlendA;

int ChickenPeck; // chicken peck countdown

Actor Rain1; // active rain maker 1
Actor Rain2; // active rain maker 2

const int MAX_MAPS_VISITED = 100;

name MapsVisited[MAX_MAPS_VISITED];

float FOV; // current Field Of Vision
float DesiredFOV; // desired Field Of Vision

bool /*[checkpoint]*/ k8ElvenGifted; // always set to `true` in checkpoints
transient float k8BossesDetected = 666; // seconds; <0: waiting; 0: show message; >0: detected
transient float k8ElvenGiftMessageTime = 666; // seconds; <0: waiting; 0: show message; >0: detected


// Health Accumulator
// if you want to show HA info in UI, replicate those vars
int k8HealthAccum_Amount; // amount of currently accumulated health
float k8HealthAccum_LastRegenTime = -10000;
float k8HealthAccum_LastBoostTime = -10000;

bool bFlashlightOn;
transient bool bFlashlightButtonDown;
transient float k8NextSuperBulletTime;

transient subsector_t *lastSubSector;
//transient array!int subSeen; // do not bother dropping subsector info for those

transient float lastViewOrgZForPfx; // set in `CalcHeight()`, used in `PostfixViewHeight()`


//==========================================================================
//
//  ClearSubSeenInfo
//
//==========================================================================
final void ClearSubSeenInfo () {
  lastSubSector = nullptr;
  //subSeen.reset();
}


//==========================================================================
//
//  AddSeenSubsector
//
//==========================================================================
final void AddSeenSubsector () {
  if (!MO) return;
  if (!MO.SubSector) return;
  if (lastSubSector == MO.SubSector) return;
  /*
  int ssnum = MO.SubSector-&MO.XLevel.Subsectors[0];
  if (subSeen.length != MO.XLevel.Subsectors.length) {
    subSeen.length = MO.XLevel.Subsectors.length;
    foreach (ref int ss; subSeen) ss = 0;
  }
  if (subSeen[ssnum]) return;
  subSeen[ssnum] = 1;
  */
  lastSubSector = MO.SubSector;
  foreach (auto i; 0..MAXPLAYERS) {
    PlayerEx plr = PlayerEx(Level.Game.Players[i]);
    if (!plr || !plr.bIsBot) continue;
    plr.BotSendSubSectorChange(lastSubSector);
  }
}


//==========================================================================
//
//  BotDumpNodes
//
//==========================================================================
void BotDumpNodes () {
}


//==========================================================================
//
//  BotTestFindPathTo
//
//==========================================================================
void BotTestFindPathTo (TVec dest) {
}


replication {
  reliable if (!bIsClient)
    Cheats, ReadyWeapon, InvFirst, InvPtr, InventoryTime, ArtifactFlash,
    Objectives, MorphTime, Accuracy, Stamina, MapsVisited, DamageFlash,
    BonusFlash, Attacker, bFrozen, bTotallyFrozen, DesiredFOV, FOV;

  unreliable if (!bIsClient)
    ParticleEffect, ClientExplosion, ClientParticleExplosion,
    ClientSparkParticles, ClientRailTrail, DecalEffect,
    // we need this to update UI, but this is not vital info
    k8HealthAccum_Amount, k8HealthAccum_LastRegenTime, k8HealthAccum_LastBoostTime;

  reliable if (!bIsClient)
    ClientVoice, ClientSpeech, ClientFinaleType, ClientSlideshow1,
    ClientSlideshow2, SetFOV;

  reliable if (bIsClient)
    bAutoAim, bFlashlightOn;
}


#include "healthbar.vc"


//==========================================================================
//
//  ResetToDefaults
//
//  this is called on save loading, etc.
//  reset every important field to default
//
//==========================================================================
override void ResetToDefaults () {
  ::ResetToDefaults();
  ResetPlayerOnSpawn(keepPlayerState:true);
  k8HealthAccum_Amount = 0;
  //print("*** RESET ***");
  //print("k8ElvenGiftMessageTime=%s", k8ElvenGiftMessageTime);
}


//==========================================================================
//
//  eventOnSaveLoaded
//
//  this is called after savegame was loaded
//
//==========================================================================
override void eventOnSaveLoaded () {
  ::eventOnSaveLoaded();
  //print("*** LOADED ***");
  //print("k8ElvenGiftMessageTime=%s", k8ElvenGiftMessageTime);
  k8ElvenGiftMessageTime = 666; // checkpoint loads will set this, so reset it back
  // but detect bosses
  k8BossesDetected = (GetCvarB('k8ElvenDetect') ? -0.5 : 666);
}


//==========================================================================
//
//  eventOnBeforeSave
//
//==========================================================================
override void eventOnBeforeSave (bool isAutosave, bool isCheckpoint) {
  ::eventOnBeforeSave(isAutosave, isCheckpoint);
  //print("*** BEFORE SAVING (auto:%B; checkpoint:%B) ***", isAutosave, isCheckpoint);
}


//==========================================================================
//
//  eventOnAfterSave
//
//==========================================================================
override void eventOnAfterSave (bool isAutosave, bool isCheckpoint) {
  ::eventOnAfterSave(isAutosave, isCheckpoint);
  //print("*** SAVED (auto:%B; checkpoint:%B) ***", isAutosave, isCheckpoint);
}


//==========================================================================
//
//  IsCheckpointPossible
//
//  this should check player's inventory (and maybe some other things), and
//  return `true` if simple checkpoint-style save is possible
//  (i.e. loader can simply recreate player inventory and health)
//
//  for now, there is no way to inject custom data in checkpoints, so if
//  you have any, return `false` here
//
//==========================================================================
override bool IsCheckpointPossible () {
  if (!MO) return false;
  return EntityEx(MO).IsInventoryCheckpointPossible();
}


//==========================================================================
//
//  CalcFlyZ
//
//  TODO: this is time-dependent; fix it!
//
//==========================================================================
float CalcFlyZ (float currz) {
  currz += sin(90.0*35.0/20.0*AngleMod360(WorldTimer))/2.0;
  return currz;
}


//==========================================================================
//
//  QS_Save
//
//==========================================================================
override void QS_Save () {
  QS_PutInt("Health", Health);
  QS_PutInt("Cheats", Cheats);

  QS_PutInt("bNoTarget", (bNoTarget ? 1 : 0));
  QS_PutInt("bInstantWeaponSwitch", (bInstantWeaponSwitch ? 1 : 0));
  QS_PutInt("bAutoAim", (bAutoAim ? 1 : 0));

  int viscount = 0;
  foreach (auto midx; 0..MAX_MAPS_VISITED; reverse) {
    if (MapsVisited[midx]) {
      viscount = midx+1;
      break;
    }
  }

  QS_PutInt("MAX_MAPS_VISITED", viscount);
  foreach (auto midx; 0..viscount) QS_PutName(va("MapVisited.%d", midx), MapsVisited[midx]);
}


//==========================================================================
//
//  QS_Load
//
//==========================================================================
override void QS_Load () {
  Health = QS_GetInt("Health");
  MO.Health = Health;
  Cheats = QS_GetInt("Cheats");

  bNoTarget = !!QS_GetInt("bNoTarget");
  bInstantWeaponSwitch = !!QS_GetInt("bInstantWeaponSwitch");
  bAutoAim = !!QS_GetInt("bAutoAim");

  int viscount = QS_GetInt("MAX_MAPS_VISITED", 0);
  if (viscount < 0) Error("invalid number of visited maps in quicksave");
  //if (MAX_MAPS_VISITED != QS_GetInt("MAX_MAPS_VISITED")) Error("invalid number of visited maps in quicksave");
  //print("VISCOUNT=%d (%d)", viscount, MAX_MAPS_VISITED);
  foreach (auto midx; 0..viscount) {
    name mname = QS_GetName(va("MapVisited.%d", midx));
    if (midx < MAX_MAPS_VISITED) {
      MapsVisited[midx] = mname;
    } else {
      if (mname) Error("invalid number of visited maps in quicksave");
    }
  }

  foreach (auto midx; viscount..MAX_MAPS_VISITED) MapsVisited[midx] = '';

  k8ElvenGifted = true;
}


//==========================================================================
//
//  ClearEntityInventoryQS
//
//==========================================================================
/*
override void ClearEntityInventoryQS () {
  ReadyWeapon = none;
  PendingWeapon = none;
  ::ClearEntityInventoryQS();
}
*/


//==========================================================================
//
//  ResetWeaponReloadRefire
//
//==========================================================================
void ResetWeaponReloadRefire () {
  bReloadQueued = false;
  Refire = 0;
}


//==========================================================================
//
//  eventSetReadyWeapon
//
//==========================================================================
override void eventSetReadyWeapon (Entity ent, bool instant) {
  if (!MO) return;
  SetWeapon(none);
  Weapon wpn = Weapon(ent);
  for (Inventory inv = EntityEx(MO).Inventory; inv; inv = inv.Inventory) {
    if (ent == wpn) {
      SetWeapon(wpn);
      break;
    }
  }
  BringUpWeapon(instant:instant, skipSound:instant);
}


//==========================================================================
//
//  GetAttackZOfs
//
//==========================================================================
float GetAttackZOfs (optional bool missile) {
  auto plrmo = PlayerPawn(MO);
  if (!plrmo) return 8.0;
  float res = plrmo.AttackZOffset*plrmo.crouchfactor+(missile ? 0.0 : (GetCvarB('gm_fix_attack_offset') ? 4.0 : 0.0));
  //if (plrmo.crouchfactor < 1.0) res -= plrmo.RealHeight-plrmo.Height; // crouch fix
  return res;
}


//==========================================================================
//
//  ThrustPlayer
//
//  Moves the given origin along a given angle.
//
//==========================================================================
final void ThrustPlayer (float angle, float move, float deltaTime) {
  if ((!EntityEx(MO).FindInventory(PowerFlight) || MO.Origin.z <= MO.FloorZ) &&
      ((EntityEx(MO).GetFloorType()->Friction &&
        EntityEx(MO).GetFloorType()->Friction < EntityEx::FRICTION_NORMAL) ||
      (MO.Sector->special&SECSPEC_BASE_MASK) == SECSPEC_FrictionLow))
  {
    move *= LineSpecialGameInfo(Level.Game).IceMoveFactor;
  }
  float s, c;
  sincos(angle, out s, out c);
  MO.Velocity.x += move*c*deltaTime;
  MO.Velocity.y += move*s*deltaTime;
}


//==========================================================================
//
//  SanitizeViewOrgZ
//
//==========================================================================
void SanitizeViewOrgZ () {
  if (!MO) return; // just in case
  if (PlayerState != PST_DEAD && MO.Origin.z <= MO.FloorZ) ViewOrg.z -= MO.FloorClip;
  if (ViewOrg.z < MO.FloorZ+4.0) ViewOrg.z = MO.FloorZ+4.0;
  if (ViewOrg.z > MO.CeilingZ-4.0) ViewOrg.z = MO.CeilingZ-4.0;
}


//==========================================================================
//
//  ClientSetViewOrg
//
//==========================================================================
override void ClientSetViewOrg (float x, float y, float z) {
  ::ClientSetViewOrg(x, y, z);
  lastViewOrgZForPfx = (MO ? MO.Origin.z : 0);
}


//==========================================================================
//
//  PostfixViewHeight
//
//  after player thinker was called, player can be moved by lift,
//  for example. we have to "postfix" view origin to get rid of
//  "sinking into lift" effect
//
//  this is called from `SetViewPos()`, which in turn is called from
//  main world thinker
//
//==========================================================================
override void PostfixViewHeight () {
  if (!MO) return; // just in case

  float zdiff = MO.Origin.z-lastViewOrgZForPfx;
  if (!zdiff) return; // nothing to do
  lastViewOrgZForPfx = MO.Origin.z; // in case we will be called repeatedly

  ViewOrg.z += zdiff;
  SanitizeViewOrgZ();
}


//==========================================================================
//
//  CalcHeight
//
//  calculate the walking / running height adjustment
//  called from player tickers (both alive and dead)
//
//==========================================================================
void CalcHeight (float deltaTime) {
  float bob = GetCvarF('movebob');

  if (bob > 0) {
    // regular movement bobbing
    // (needs to be calculated for gun swing even if not on ground)
    if (MO.bFly && !onground) {
      Bob = 0.5;
    } else {
      if (bob > 1) bob = 1;
      Bob = MO.Velocity.x*MO.Velocity.x+MO.Velocity.y*MO.Velocity.y;
      Bob /= (1.0/bob)*35.0*35.0;
      if (Bob > MAXBOB) Bob = MAXBOB;
    }
  }

  // when crouching, bobbing have to be reduced
  if (PlayerPawn(MO)) {
    auto plrmo = PlayerPawn(MO);
    Bob *= plrmo.crouchfactor;
  }

  float angle = 180.0*35.0/10.0*Level.XLevel.Time;
  bob = Bob/2.0*sin(angle);

  // move viewheight
  if (PlayerState == PST_LIVE) {
    ViewHeight += DeltaViewHeight*deltaTime;

    float plrVH = PlayerPawn(MO).ViewHeight*PlayerPawn(MO).crouchfactor;

    if (ViewHeight > plrVH) {
      ViewHeight = plrVH;
      DeltaViewHeight = 0.0;
    }

    if (ViewHeight < plrVH/2.0) {
      ViewHeight = plrVH/2.0;
      if (DeltaViewHeight <= 0.0) DeltaViewHeight = 0.00001;
    }

    if (DeltaViewHeight) {
      DeltaViewHeight += 256.0*deltaTime;
      if (!DeltaViewHeight) DeltaViewHeight = 0.00001;
    }
  }
  ViewOrg.z = MO.Origin.z+ViewHeight+bob;
  lastViewOrgZForPfx = MO.Origin.z; // for postfixing

  SanitizeViewOrgZ();
}


//==========================================================================
//
//  CrouchMove
//
//==========================================================================
void CrouchMove (int direction) {
  scope(exit) PrevViewHeight = ViewHeight;
  auto plrmo = PlayerPawn(MO);
  if (!plrmo) return;

  float crouchspeed = direction*EntityEx::CROUCHSPEED;
  float newcrf = fclamp(plrmo.crouchfactor+crouchspeed, 0.5, 1.0);
  if (newcrf == plrmo.crouchfactor) return; // nothing to do

  // check whether the move is ok
  float savedheight = plrmo.Height; //HACK! we'd better use `GetHeight()` here, but...
  float defaultheight = plrmo.GetRealHeight; // ...this saves `Height` to `RealHeight` too
  plrmo.Height = defaultheight*newcrf; // we'd better use `SetHeight()` here
  if (!plrmo.TryMove(plrmo.Origin, false)) {
    // nope, restore player height
    plrmo.Height = savedheight;
    return;
  }

  // setup new view height, and remember current crouch factor
  // apply view height delta
  float prevVH = PrevViewHeight;
  if (prevVH == -666) prevVH = ViewHeight;
  float vhDelta = ViewHeight-prevVH;
  ViewHeight = PlayerPawn(plrmo).ViewHeight*newcrf+vhDelta;
  plrmo.crouchfactor = newcrf;

  // check for eyes going above/below fake floor due to crouching motion
  // this seems to be done in TryMove
  //FIXME
  //TODO
  //CheckFakeFloorTriggers(pos.Z + oldheight, true);
}


//==========================================================================
//
//  MovePlayer
//
//==========================================================================
final void MovePlayer (float deltaTime) {
  float forward;
  float side;
  float fly;

  // yeah, we can start crouching mid-air
  auto ohgt = MO.Height;
  CrouchMove(Buttons&BT_CROUCH ? -1 : 1);
  //print("HEIGHT: %s  %s  crf=%s; vh=%s; dvh=%s", ohgt, MO.Height, EntityEx(MO).crouchfactor, ViewHeight, PlayerPawn(MO).default.ViewHeight);

  // do not let the player control movement if not onground
  onground = (MO.Origin.z <= MO.FloorZ || EntityEx(MO).bOnMobj);

  forward = ForwardMove*5.0;
  side = SideMove*5.0;

  PlayerPawn(MO).AdjustSpeed(forward, side);

  if (!onground && !MO.bNoGravity && !MO.WaterLevel) {
    // not on ground, so we have little effect on velocity
    forward *= Level.AirControl;
    side *= Level.AirControl;
  }

  if (forward) ThrustPlayer(MO.Angles.yaw, forward, deltaTime);
  if (side) ThrustPlayer(AngleMod360(MO.Angles.yaw-90.0), side, deltaTime);

  if (forward || side) {
    SetPlayerRunState();
    if (bRevertCamera) {
      Camera = MO;
      bRevertCamera = false;
    }
  }

  fly = FlyMove/16.0;
  if (fly && (bFly || EntityEx(MO).FindInventory(PowerFlight))) {
    if (FlyMove != TOCENTRE) {
      FlyHeight = fly*2.0;
      if (!MO.bFly) {
        MO.bFly = true;
        MO.bNoGravity = true;
        if (MO.Velocity.z <= -39.0*35.0) {
          // stop falling scream
          MO.StopSound(CHAN_VOICE);
        }
      }
    } else {
      MO.bFly = false;
      MO.bNoGravity = false;
    }
  } else if (fly > 0.0) {
    UseFlyPower();
  }

  if (MO.bFly) {
    /* old code
    MO.Velocity.z = FlyHeight*35.0;
    if (FlyHeight) FlyHeight /= 2.0;
    */
    if (fabs(FlyHeight) > 0.1) {
      MO.Velocity.z = FlyHeight*35.0;
      FlyHeight /= 2.0;
      if (fabs(FlyHeight) <= 0.1) FlyHeight = 0;
    } else {
      // directional flight
      if (forward) {
        TVec vfdir;
        AngleVector(MO.Angles, out vfdir);
        vfdir.z *= forward*deltaTime;
        MO.Velocity.z += vfdir.z;
      } else {
        if (MO.Velocity.z < 0) {
          MO.Velocity.z = fmin(0, MO.Velocity.z+4);
        } else if (MO.Velocity.z > 0) {
          MO.Velocity.z = fmax(0, MO.Velocity.z-4);
        }
      }
    }
    if (Buttons&BT_JUMP && MO.Velocity.z < 160) MO.Velocity.z += 30;
    float limit = (Buttons&BT_SPEED ? 400 : 200);
    MO.Velocity.z = fclamp(MO.Velocity.z, -limit, limit);
    //print("VZ=%s; FH=%s; fvwd=%s", MO.Velocity.z, FlyHeight, vforward);
  }

  if ((Buttons&BT_JUMP) && !bFly && onground && !JumpTime) {
    MO.Velocity.z = (PlayerPawn(MO).JumpVelZ*(Cheats&CF_HIGHJUMP ? 2.0 : 1.0))*1.1;
    EntityEx(MO).bOnMobj = false;
    JumpTime = 0.5;
  }
}


//==========================================================================
//
//  CheckWaterJump
//
//==========================================================================
final void CheckWaterJump () {
  TVec start;
  TVec end;
  TVec vforward;
  TVec HitPoint;
  TVec HitNormal;

  // check for a jump-out-of-water
  AngleVector(MO.Angles, out vforward);
  start = MO.Origin;
  start.z += MO.Height*0.5+8.0;
  vforward.z = 0.0;
  vforward = Normalise(vforward);
  end = start+vforward*24.0;
  if (!Level.XLevel.TraceLine(start, end, HitPoint, HitNormal)) {
    // solid at waist
    start.z = MO.Origin.z+MO.Height;
    end = start+vforward*24.0;
    MoveDir = HitNormal*-50.0;
    if (Level.XLevel.TraceLine(start, end, HitPoint, HitNormal)) {
      // open at eye level
      EntityEx(MO).bWaterJump = true;
      MO.Velocity.z = 350.0;
      EntityEx(MO).ReactionTime = 2.0; // safety net
    }
  }
}


//==========================================================================
//
//  WaterMove
//
//==========================================================================
final void WaterMove (float deltaTime) {
  float forward;
  float side;
  TVec vforward;
  TVec vright;
  TVec vup;
  TVec wishvel;

  // do not let the player control movement if not onground
  onground = (MO.Origin.z <= MO.FloorZ) || EntityEx(MO).bOnMobj;

  AngleVectors(MO.Angles, out vforward, out vright, out vup);

  forward = ForwardMove;
  side = SideMove;

  PlayerPawn(MO).AdjustSpeed(forward, side);

  wishvel = vforward*forward+vright*side;
  float wishvz = wishvel.z;
  if (!forward && !side /*&& !cmd.upmove*/ && !(Buttons&BT_JUMP)) {
    //wishvel.z -= 60.0; // drift towards bottom
    if (MO.WaterLevel < 2) {
      wishvel.z -= 60.0; // drift towards bottom
    } else {
      wishvel.z -= 6;
    }
  }
  //else wishvel.z += cmd.upmove;

  //print("wishvel=%s; forward=%s; prevel=%s", wishvel, forward, MO.Velocity);
  MO.Velocity += 3.5*deltaTime*wishvel;

  if (forward || side) SetPlayerRunState();

  if (Buttons&BT_JUMP) {
         if (MO.WaterType == CONTENTS_WATER) MO.Velocity.z = 100.0;
    else if (MO.WaterType == CONTENTS_NUKAGE || MO.WaterType == CONTENTS_SLIME || MO.WaterType == CONTENTS_SLUDGE) MO.Velocity.z = 80.0;
    else MO.Velocity.z = 50.0;
  } else {
    if (MO.WaterLevel >= 2 && wishvel.z < 0 && wishvz == 0) {
      if (MO.Velocity.z > 0) MO.Velocity.z -= 10;
    }
    // if we are not moving forward, do not sink too fast
    if (!forward) {
      if (MO.Velocity.z < -20) MO.Velocity.z = fmin(-20, MO.Velocity.z+20);
    } else {
      float limit = (Buttons&BT_SPEED ? 140 : 140*2);
      MO.Velocity.z = fclamp(MO.Velocity.z, -limit, limit);
    }
  }

  CheckWaterJump();
}


//==========================================================================
//
//  WaterJump
//
//==========================================================================
final void WaterJump () {
  if (!EntityEx(MO).ReactionTime || !MO.WaterLevel) {
    EntityEx(MO).bWaterJump = false;
    EntityEx(MO).ReactionTime = 0.0;
  }
  MO.Velocity.x = MoveDir.x;
  MO.Velocity.y = MoveDir.y;
}


//==========================================================================
//
//  PlayerInSpecialSector
//
//  Called every tic frame that the player origin is in a special sector.
//
//==========================================================================
final void PlayerInSpecialSector (float deltaTime) {
  float speed;
  float finean;

  if (MO.Origin.z != GetPlanePointZ(ref MO.Sector->floor, MO.Origin) && !MO.WaterLevel) {
    // player is not touching the floor
    return;
  }

  if (MO.Sector->special&SECSPEC_SECRET_MASK) {
    // secret area
    ++SecretCount;
    ++Level.CurrentSecret;
    MO.Sector->special &= ~SECSPEC_SECRET_MASK;
    centreprint("You found a secret area");
    MO.PlaySound('misc/secret', CHAN_VOICE);
  }

  // search for iron feet power: any subclass will do
  Inventory IronFeet = EntityEx(MO).Inventory;
  while (IronFeet) {
    if (PowerIronFeet(IronFeet)) break;
    IronFeet = IronFeet.Inventory;
  }

  //FIXME: implement leaky suits
  name flatDamageType = '';
  int flatDamage = 0;
  int flatDamageTimeout;
  bool flatDamageExit = false;
  bool flatDamageHitFloor = false;

  if (MO.Sector->special >= SECSPEC_LightFlicker && MO.Sector->special <= 255) {
    switch (MO.Sector->special) {
      case SECSPEC_DamageHellslime:
        if (!IronFeet) {
          flatDamageType = 'Slime';
          flatDamage = 10;
          flatDamageTimeout = 32;
        }
        break;
      case SECSPEC_DamageSludge:
        if (!IronFeet) {
          flatDamageType = 'Slime';
          flatDamage = 4;
          flatDamageTimeout = 32;
        }
        break;
      case SECSPEC_DamageNukage:
        if (!IronFeet) {
          flatDamageType = 'Slime'; //FIXME
          flatDamage = 5;
          flatDamageTimeout = 32;
        }
        break;
      case SECSPEC_LightStrobeFastDamage:
      case SECSPEC_DamageSuperHellslime:
        //k8: it was `(P_Random() < 5 && P_Random() < 5)`
        if (!IronFeet || P_Random() < 5) {
          flatDamageType = 'Slime'; //FIXME
          flatDamage = 20;
          flatDamageTimeout = 32;
        }
        break;
      case SECSPEC_DamageSuperHellslimeExit:
        // EXIT SUPER DAMAGE! (for E1M8 finale)
        flatDamageType = ''; //FIXME
        flatDamage = 20;
        flatDamageTimeout = 32;
        flatDamageExit = true;
        break;
      case SECSPEC_DamageLavaWimpy:
        flatDamageType = 'Fire';
        flatDamage = 5;
        flatDamageTimeout = 16;
        flatDamageHitFloor = true;
        break;
      case SECSPEC_DamageLavaHefty:
        flatDamageType = 'Fire';
        flatDamage = 8;
        flatDamageTimeout = 16;
        flatDamageHitFloor = true;
        break;
      case SECSPEC_ScrollEastLavaDamage:
        ThrustPlayer(0.0, 1024.0, deltaTime);
        flatDamageType = 'Fire';
        flatDamage = 5;
        flatDamageTimeout = 16;
        flatDamageHitFloor = true;
        break;
      case SECSPEC_DamageHazard:
        if (!IronFeet) HazardTime += 2.0*deltaTime;
        break;
      case SECSPEC_DamageInstantDeath:
        EntityEx(MO).Damage(none, none, 999, 'InstantDeath', spawnBlood:true);
        break;
      case SECSPEC_DamageSuperHazard:
        if (!IronFeet) HazardTime += 4.0*deltaTime;
        break;
    }
  } else {
    // extended sector damage type
    switch (MO.Sector->special&SECSPEC_DAMAGE_MASK) {
      case 0x0100:
        if (!IronFeet) {
          flatDamageType = 'Fire';
          flatDamage = 5;
          flatDamageTimeout = 32;
        }
        break;
      case 0x0200:
        if (!IronFeet) {
          flatDamageType = 'Slime';
          flatDamage = 10;
          flatDamageTimeout = 32;
        }
        break;
      case 0x0300:
        if (!IronFeet || (P_Random() < 5 && P_Random() < 5)) {
          flatDamageType = 'Slime';
          flatDamage = 20;
          flatDamageTimeout = 32;
        }
        break;
    }
  }

  bool updateDamageTic = false;

  // apply flat damage
  if (flatDamage && LastSectorDamageTic < Level.XLevel.TicTime) {
    if (!(Level.XLevel.TicTime%flatDamageTimeout)) {
      auto oldCheats = Cheats;
      scope(exit) Cheats = oldCheats;
      updateDamageTic = true;
      if (flatDamageExit) Cheats &= ~CF_GODMODE;
      if (flatDamageType) {
        EntityEx(MO).Damage(none, none, flatDamage, flatDamageType);
      } else {
        EntityEx(MO).Damage(none, none, flatDamage);
      }
      if (flatDamageHitFloor) EntityEx(MO).HitFloorType();
      if (flatDamageExit && Health <= 10) Level.ExitLevel(0);
    }
  }

  // apply any customizable damage
  if (MO.Sector->Damage && LastSectorDamageTic < Level.XLevel.TicTime) {
    flatDamage = MO.Sector->Damage;
    flatDamageTimeout = 0;
    if (MO.Sector->Damage < 20) {
      if (!IronFeet) flatDamageTimeout = 32;
    } else if (MO.Sector->Damage < 50) {
      if (!IronFeet || (P_Random() < 5 && P_Random() < 5)) flatDamageTimeout = 32;
    } else {
      flatDamageTimeout = 1;
    }
    if (flatDamageTimeout && !(Level.XLevel.TicTime%flatDamageTimeout)) {
      updateDamageTic = true;
      EntityEx(MO).Damage(none, none, flatDamage);
    }
  }

  if (updateDamageTic) LastSectorDamageTic = Level.XLevel.TicTime;

  switch (MO.Sector->special&SECSPEC_BASE_MASK) {
    case SECSPEC_ScrollCurrent:
      speed = float((MO.Sector->tag-100)%10)/16.0*35.0;
      finean = float((MO.Sector->tag-100)/10)*45.0;
      MO.Velocity.x += speed*cos(finean);
      MO.Velocity.y += speed*sin(finean);
      break;
    case SECSPEC_ScrollNorthSlow:
    case SECSPEC_ScrollNorthMedium:
    case SECSPEC_ScrollNorthFast:
      ThrustPlayer(90.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollNorthSlow], deltaTime);
      break;
    case SECSPEC_ScrollEastSlow:
    case SECSPEC_ScrollEastMedium:
    case SECSPEC_ScrollEastFast:
      ThrustPlayer(0.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollEastSlow], deltaTime);
      break;
    case SECSPEC_ScrollSouthSlow:
    case SECSPEC_ScrollSouthMedium:
    case SECSPEC_ScrollSouthFast:
      ThrustPlayer(270.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollSouthSlow], deltaTime);
      break;
    case SECSPEC_ScrollWestSlow:
    case SECSPEC_ScrollWestMedium:
    case SECSPEC_ScrollWestFast:
      ThrustPlayer(180.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollWestSlow], deltaTime);
      break;
    case SECSPEC_ScrollNorthWestSlow:
    case SECSPEC_ScrollNorthWestMedium:
    case SECSPEC_ScrollNorthWestFast:
      ThrustPlayer(135.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollNorthWestSlow], deltaTime);
      break;
    case SECSPEC_ScrollNorthEastSlow:
    case SECSPEC_ScrollNorthEastMedium:
    case SECSPEC_ScrollNorthEastFast:
      ThrustPlayer(45.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollNorthEastSlow], deltaTime);
      break;
    case SECSPEC_ScrollSouthEastSlow:
    case SECSPEC_ScrollSouthEastMedium:
    case SECSPEC_ScrollSouthEastFast:
      ThrustPlayer(315.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollSouthEastSlow], deltaTime);
      break;
    case SECSPEC_ScrollSouthWestSlow:
    case SECSPEC_ScrollSouthWestMedium:
    case SECSPEC_ScrollSouthWestFast:
      ThrustPlayer(225.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollSouthWestSlow], deltaTime);
      break;
    case SECSPEC_ScrollEast5:
    case SECSPEC_ScrollEast10:
    case SECSPEC_ScrollEast25:
    case SECSPEC_ScrollEast30:
    case SECSPEC_ScrollEast35:
      ThrustPlayer(0.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollEast5], deltaTime);
      break;
    case SECSPEC_ScrollNorth5:
    case SECSPEC_ScrollNorth10:
    case SECSPEC_ScrollNorth25:
    case SECSPEC_ScrollNorth30:
    case SECSPEC_ScrollNorth35:
      ThrustPlayer(90.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollNorth5], deltaTime);
      break;
    case SECSPEC_ScrollSouth5:
    case SECSPEC_ScrollSouth10:
    case SECSPEC_ScrollSouth25:
    case SECSPEC_ScrollSouth30:
    case SECSPEC_ScrollSouth35:
      ThrustPlayer(270.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollSouth5], deltaTime);
      break;
    case SECSPEC_ScrollWest5:
    case SECSPEC_ScrollWest10:
    case SECSPEC_ScrollWest25:
    case SECSPEC_ScrollWest30:
    case SECSPEC_ScrollWest35:
      ThrustPlayer(180.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollWest5], deltaTime);
      break;
  }
}


//============================================================================
//
//  PlayerOnSpecialFlat
//
//============================================================================
final void PlayerOnSpecialFlat (VTerrainInfo *floorType) {
  if (!floorType) return;
  if (MO.Origin.z != MO.FloorZ) return; // player is not touching the floor

  if (floorType->bAllowProtection) {
    // search for iron feet power; any subclass will do
    Inventory IronFeet = EntityEx(MO).Inventory;
    while (IronFeet) {
      if (PowerIronFeet(IronFeet)) return;
      IronFeet = IronFeet.Inventory;
    }
  }

  if (floorType->DamageAmount && Level.XLevel.TicTime-LastSectorDamageTic >= floorType->DamageTimeMask+1) {
    LastSectorDamageTic = Level.XLevel.TicTime;
    EntityEx(MO).Damage(none, none, 10, 'Fire'/*, spawnBlood:true*/);
    MO.PlaySound('world/lavasizzle', CHAN_BODY);
  }
}


//==========================================================================
//
//  PlayerInContents
//
//==========================================================================
final void PlayerInContents (float deltaTime) {
  if (!MO.WaterLevel) return;

  // search for iron feet power; any subclass will do
  Inventory IronFeet = EntityEx(MO).Inventory;
  while (IronFeet) {
    if (PowerIronFeet(IronFeet)) break;
    IronFeet = IronFeet.Inventory;
  }

  name flatDamageType = '';
  int flatDamage = 0;
  int flatDamageTimeout;

  switch (MO.WaterType) {
    case CONTENTS_LAVA:
      if (!IronFeet) {
        flatDamageType = 'Fire';
        flatDamage = 10;
        flatDamageTimeout = 32;
      }
      break;
    case CONTENTS_NUKAGE:
      if (!IronFeet) {
        flatDamageType = 'Slime'; //FIXME
        flatDamage = 5;
        flatDamageTimeout = 32;
      }
      break;
    case CONTENTS_SLIME:
      if (!IronFeet) {
        flatDamageType = 'Slime';
        flatDamage = 10;
        flatDamageTimeout = 32;
      }
      break;
    case CONTENTS_HELLSLIME:
      if (!IronFeet || P_Random() < 5) {
        flatDamageType = 'Slime';
        flatDamage = 20;
        flatDamageTimeout = 32;
      }
      break;
    case CONTENTS_SLUDGE:
      if (!IronFeet) {
        flatDamageType = 'Slime'; //FIXME
        flatDamage = 4;
        flatDamageTimeout = 32;
      }
      break;
    case CONTENTS_HAZARD:
      if (!IronFeet) HazardTime += 2.0*deltaTime;
      break;
  }


  // apply flat damage
  if (flatDamage && LastSectorDamageTic < Level.XLevel.TicTime) {
    if (!(Level.XLevel.TicTime%flatDamageTimeout)) {
      if (flatDamageType) {
        EntityEx(MO).Damage(none, none, flatDamage, flatDamageType);
      } else {
        EntityEx(MO).Damage(none, none, flatDamage);
      }
      LastSectorDamageTic = Level.XLevel.TicTime;
    }
  }
}


//==========================================================================
//
//  SetPlayerRunState
//
//==========================================================================
final void SetPlayerRunState () {
  if (MO.State == EntityEx(MO).IdleState && EntityEx(MO).SeeState) {
    MO.SetState(EntityEx(MO).SeeState);
  }
}


//***************************************************************************
//
//  WEAPON UTILITES
//
//***************************************************************************

//==========================================================================
//
//  SetWeapon
//
//==========================================================================
final void SetWeapon (Weapon NewWeapon) {
  ReadyWeapon = NewWeapon;
  PendingWeapon = none;
  if (NewWeapon) {
    PSpriteSY = /*ReadyWeapon*/NewWeapon.PSpriteSY;
    MO.ModelVersion = /*ReadyWeapon*/NewWeapon.PlayerModelVersion;
  } else {
    SetViewObject(none);
    PSpriteSY = 0;
    MO.ModelVersion = 0;
  }
}


//===========================================================================
//
//  BringUpWeapon
//
//  Starts bringing the pending weapon up from the bottom of the screen.
//
//===========================================================================
final void BringUpWeapon (optional bool instant, optional bool skipSound) {
  //print("BringUpWeapon: %C (instant=%B: skipSound=%B)", ReadyWeapon, instant, skipSound);
  if (!skipSound && ReadyWeapon && ReadyWeapon.UpSound) {
    MO.PlaySound(ReadyWeapon.UpSound, CHAN_WEAPON);
  }

  if (PendingWeapon && ReadyWeapon && PendingWeapon == ReadyWeapon) {
    print("%C: RAISING ALREADY RAISED WEAPON! (0)", ReadyWeapon);
    //return;
  }

  PendingWeapon = none;
  ViewStates[PS_WEAPON].SY = (instant || bInstantWeaponSwitch ? Weapon::WEAPONTOP : Weapon::WEAPONBOTTOM);
  ResetWeaponReloadRefire();
  if (ReadyWeapon) {
    ReadyWeapon.bBobDisabled = true;
    SetViewObject(ReadyWeapon);
    //dprint("MO=%C; RW=%C; upstate=%s", MO, ReadyWeapon, ReadyWeapon.GetUpState());
    //k8: old code did "up state" anyway; this seems to be wrong
    if (instant || bInstantWeaponSwitch) {
      if (instant) {
        SetViewState(PS_WEAPON, ReadyWeapon.GetInstaReadyState());
      } else {
        SetViewState(PS_WEAPON, ReadyWeapon.GetReadyState());
      }
    } else {
      //print("BRINGING %C: curr=%s; top=%s; bot=%s", ReadyWeapon, ViewStates[PS_WEAPON].SY, Weapon::WEAPONTOP, Weapon::WEAPONBOTTOM);
      SetViewState(PS_WEAPON, ReadyWeapon.GetUpState());
    }
    //dprint("MO=%C; RW=%C", MO, ReadyWeapon);
    if (!ReadyWeapon) {
      SetViewObject(none);
      print("RAISING NONE WEAPON! (0)");
      MO.ModelVersion = 0;
      PSpriteSY = 0;
      return;
    }
    MO.ModelVersion = ReadyWeapon.PlayerModelVersion;
  } else {
    SetViewObject(none);
    MO.ModelVersion = 0;
    PSpriteSY = 0;
  }
}


//===========================================================================
//
//  DropWeapon
//
//  Player died, so put the weapon away.
//
//===========================================================================
final void DropWeapon () {
  ResetWeaponReloadRefire();
  if (ReadyWeapon) {
    SetViewObject(ReadyWeapon);
    SetViewState(PS_WEAPON, ReadyWeapon.GetDownState());
  }
}


//===========================================================================
//
//  SetupPsprites
//
//  Called at start of level for each player.
//
//===========================================================================
final void SetupPsprites () {
  // remove all psprites
  foreach (auto i; 0..NUMPSPRITES) {
    SetViewObject(none);
    SetViewState(i, none);
  }

  // spawn the gun
  BringUpWeapon();
}


//==========================================================================
//
//  MovePsprites
//
//  Called every tic by player thinking routine.
//
//==========================================================================
void MovePsprites (float deltaTime) {
  // moved here, so weapon can bob independently
  Weapon wpn = Weapon(ReadyWeapon);
  if (MO && wpn && !wpn.bDontBob && !wpn.bBobDisabled) {
    // bob the weapon based on movement speed
    float angle = AngleMod360(180.0*MO.XLevel.Time);
    ViewStates[PS_WEAPON].SX = 1.0+Bob*cos(angle);
    if (angle >= 180.0) angle -= 180.0;
    ViewStates[PS_WEAPON].SY = Weapon::WEAPONTOP+Bob*sin(angle);
  }

  AdvanceViewStates(deltaTime);
  ViewStates[PS_FLASH].SX = ViewStates[PS_WEAPON].SX;
  ViewStates[PS_FLASH].SY = ViewStates[PS_WEAPON].SY;
  ViewStates[PS_WEAPON_OVL].SX = ViewStates[PS_WEAPON].SX;
  ViewStates[PS_WEAPON_OVL].SY = ViewStates[PS_WEAPON].SY;
}


//===========================================================================
//
//  FireWeapon
//
//===========================================================================
void FireWeapon (optional state firestate) {
  bReloadQueued = false;
  if (!ReadyWeapon || !ReadyWeapon.CheckAmmo(Weapon::FIRE_Primary, true)) return;

  //print("FireWeapon: self=`%C`; MO=`%C`; PS_WEAPON=%s; ReadyWeapon=`%C`; firestate=(%B)%s; ast=%s", self, MO, PS_WEAPON, ReadyWeapon, specified_firestate, firestate, ReadyWeapon.GetAttackState(Refire));
  //print("  Refire=%s", Refire);
  //print("  MissileState=%s; SeeState=%s", EntityEx(MO).MissileState, EntityEx(MO).SeeState);

  ReadyWeapon.FireMode = Weapon::FIRE_Primary;
  if (EntityEx(MO).MissileState) MO.SetState(EntityEx(MO).MissileState);
  SetViewObject(ReadyWeapon);
  SetViewState(PS_WEAPON, (specified_firestate && firestate ? firestate : ReadyWeapon.GetAttackState(Refire)));
  if (!ReadyWeapon.bNoAlert) {
    LineSpecialLevelInfo(Level).NoiseAlert(EntityEx(MO), EntityEx(MO));
  }
}


//===========================================================================
//
//  AltFireWeapon
//
//===========================================================================
void AltFireWeapon (optional state firestate) {
  bReloadQueued = false;
  if (!ReadyWeapon || !ReadyWeapon.CheckAmmo(Weapon::FIRE_Secondary, true)) return;

  //print("AltFireWeapon: self=`%C`; MO=`%C`; PS_WEAPON=%s; ReadyWeapon=`%C`; firestate=(%B)%s; ast=%s", self, MO, PS_WEAPON, ReadyWeapon, specified_firestate, firestate, ReadyWeapon.GetAttackState(Refire));
  //print("  Refire=%s", Refire);
  //print("  MissileState=%s; SeeState=%s", EntityEx(MO).MissileState, EntityEx(MO).SeeState);

  ReadyWeapon.FireMode = Weapon::FIRE_Secondary;
  if (EntityEx(MO).MissileState) MO.SetState(EntityEx(MO).MissileState);
  SetViewObject(ReadyWeapon);
  SetViewState(PS_WEAPON, (specified_firestate && firestate ? firestate : ReadyWeapon.GetAltAttackState(Refire)));
  if (!ReadyWeapon.bNoAlert) {
    LineSpecialLevelInfo(Level).NoiseAlert(EntityEx(MO), EntityEx(MO));
  }
}


//===========================================================================
//
//  ReloadWeapon
//
//===========================================================================
void ReloadWeapon () {
  //k8: reloading weapon resets refire state
  ResetWeaponReloadRefire();
  if (ReadyWeapon) {
    state rst = ReadyWeapon.GetReloadState();
    if (!rst) return;
    SetViewObject(ReadyWeapon);
    SetViewState(PS_WEAPON, rst);
  }
}


//==========================================================================
//
//  ChangeWeapon
//
//  The actual changing of the weapon is done when the weapon psprite can
//  do it (read: not in the middle of an attack).
//
//==========================================================================
final void ChangeWeapon (int newweapon) {
  if (MorphTime) return;
  Weapon NewWpn = GetSlotChangeWeapon(newweapon);
  if (NewWpn && NewWpn != ReadyWeapon &&
      (!NewWpn.bGivenAsMorphWeapon && (!ReadyWeapon || !ReadyWeapon.bGivenAsMorphWeapon)))
  {
    bReloadQueued = false;
    PendingWeapon = NewWpn;
  }
}


//==========================================================================
//
//  PrevWeapon
//
//==========================================================================
final void PrevWeapon () {
  if (MorphTime) return;
  Weapon Wpn = GetPrevWeapon(PendingWeapon ? PendingWeapon : ReadyWeapon);
  if (Wpn && Wpn != ReadyWeapon) {
    bReloadQueued = false;
    PendingWeapon = Wpn;
  }
}


//==========================================================================
//
//  NextWeapon
//
//==========================================================================
final void NextWeapon () {
  if (MorphTime) return;
  Weapon Wpn = GetNextWeapon(PendingWeapon ? PendingWeapon : ReadyWeapon);
  if (Wpn && Wpn != ReadyWeapon) {
    bReloadQueued = false;
    PendingWeapon = Wpn;
  }
}


//==========================================================================
//
//  BestWeapon
//
//  Returns best weapon to use
//
//==========================================================================
final Weapon BestWeapon (optional class!Ammo AmmoType) {
  if (!MO) return none;
  bool Powered = !!EntityEx(MO).FindInventory(PowerWeaponLevel2);
  Weapon Best = none;
  for (Inventory Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory) {
    // must be a weapon
    Weapon Wpn = Weapon(Item);
    if (!Wpn) continue;
    // never ever select rocket lanucher
    if (Wpn.bBotProjectile) continue;
    // check if best one is better that this one
    if (Best && Wpn.SelectionOrder > Best.SelectionOrder) continue;
    // possibly limit to specific ammo type
    if (AmmoType && Wpn.AmmoType1 != AmmoType) continue;
    // check if it's for the current tome of power state
    if (Powered && Wpn.SisterWeapon && Wpn.SisterWeapon.bPoweredUp) continue;
    if (!Powered && Wpn.bPoweredUp) continue;
    // make sure it has enough ammo
    if (!Wpn.CheckAmmo(Weapon::FIRE_Either, false)) continue;
    // good one
    Best = Wpn;
  }
  return Best;
}


//==========================================================================
//
//  ChoosePowered
//
//==========================================================================
final Weapon ChoosePowered (Weapon Wpn) {
  if (!Wpn) return none;
  bool Powered = !!EntityEx(MO).FindInventory(PowerWeaponLevel2);
  if (Powered && Wpn.SisterWeapon && Wpn.SisterWeapon.bPoweredUp) {
    return Wpn.SisterWeapon;
  }
  return Wpn;
}


//==========================================================================
//
//  GetSlotChangeWeapon
//
//==========================================================================
final Weapon GetSlotChangeWeapon (int Slot) {
  if (Slot < 0 || Slot > PlayerPawn::NUM_WEAPON_SLOTS) return ReadyWeapon;
  auto pawn = PlayerPawn(MO);
  if (!pawn) return ReadyWeapon;
  //LineSpecialGameInfo GI = LineSpecialGameInfo(Level.Game);

  if (ReadyWeapon) {
    class!Weapon readyWpnClass = class!Weapon(GetClassReplacement(ReadyWeapon.Class));
    if (readyWpnClass) {
      foreach (auto i; 0..PlayerPawn::MAX_WEAPONS_PER_SLOT) {
        //print("i=%s; wpn=%C", i, GI.WeaponSlots[Slot].Weapons[i]);
        class!Weapon slotwpn = pawn.GetWeaponInSlot(Slot, i);
        if (!slotwpn) continue;
        if (slotwpn == readyWpnClass ||
            (ReadyWeapon.bPoweredUp && ReadyWeapon.SisterWeapon &&
             slotwpn == GetClassReplacement(ReadyWeapon.SisterWeapon.Class)))
        {
          foreach (int j; 0..PlayerPawn::MAX_WEAPONS_PER_SLOT) {
            int nwidx = (i+j+1)%PlayerPawn::MAX_WEAPONS_PER_SLOT;
            class!Weapon swc = pawn.GetWeaponInSlot(Slot, nwidx);
            if (!swc) continue;
            Weapon Wpn = Weapon(EntityEx(MO).FindInventory(swc));
            if (Wpn && Wpn.CheckAmmo(Weapon::FIRE_Either, false)) return ChoosePowered(Wpn);
          }
        }
      }
    }
  }

  //print("=== PLAYER '%C' wants slot %d ===", self, Slot);
  foreach (auto i; 0..PlayerPawn::MAX_WEAPONS_PER_SLOT; reverse) {
    class!Weapon slotwpn = pawn.GetWeaponInSlot(Slot, i);
    if (!slotwpn) continue;
    //if (slotwpn) print("   wpn #%d: %C", i, slotwpn);
    Weapon Wpn = Weapon(EntityEx(MO).FindInventory(slotwpn));
    if (Wpn && Wpn.CheckAmmo(Weapon::FIRE_Either, false)) return ChoosePowered(Wpn);
  }

  return ReadyWeapon;
}


//==========================================================================
//
//  CycleWeaponWithDir
//
//==========================================================================
final Weapon CycleWeaponWithDir (Weapon Current, bool forward) {
  auto pawn = PlayerPawn(MO);
  if (!pawn) return Current;

  // find current weapon slot and index
  int currSlot = -1, currIndex = -1;
  if (!pawn.FindWeaponSlot(class!Weapon(Current.Class), out currSlot, out currIndex)) {
    if (forward) {
      currSlot = 0;
      currIndex = -1;
    } else {
      currSlot = PlayerPawn::NUM_WEAPON_SLOTS;
      currIndex = PlayerPawn::MAX_WEAPONS_PER_SLOT;
    }
  }

  foreach (auto i; 0..PlayerPawn::MAX_WEAPONS_PER_SLOT*(PlayerPawn::NUM_WEAPON_SLOTS+1)) {
    if (forward) {
      if (++currIndex == PlayerPawn::MAX_WEAPONS_PER_SLOT) {
        currIndex = 0;
        currSlot = (currSlot+1)%(PlayerPawn::NUM_WEAPON_SLOTS+1);
      }
    } else {
      if (--currIndex == -1) {
        currIndex = PlayerPawn::MAX_WEAPONS_PER_SLOT-1;
        currSlot = (currSlot+PlayerPawn::NUM_WEAPON_SLOTS)%(PlayerPawn::NUM_WEAPON_SLOTS+1); // this wraps
      }
    }
    class!Weapon swc = pawn.GetWeaponInSlot(currSlot, currIndex);
    if (!swc) continue;
    if (Current && Current.Class == swc) continue;
    Weapon Wpn = Weapon(EntityEx(MO).FindInventory(swc));
    if (Wpn) {
      if (Wpn.CheckAmmo(Weapon::FIRE_Either, false)) return ChoosePowered(Wpn);
    }
  }

  return Current;
}


//==========================================================================
//
//  GetPrevWeapon
//
//==========================================================================
final Weapon GetPrevWeapon (Weapon Current) {
  return CycleWeaponWithDir(Current, forward:false);
}


//==========================================================================
//
//  GetNextWeapon
//
//==========================================================================
final Weapon GetNextWeapon (Weapon Current) {
  return CycleWeaponWithDir(Current, forward:true);
}


//==========================================================================
//
//  UsePuzzleItem
//
//  USING A PUZZLE ITEM
//
//  Returns true if the puzzle item was used on a line or a thing.
//
//==========================================================================
final bool UsePuzzleItem (int PuzzleItemType) {
  float x1, y1, x2, y2;
  TVec PuzzleUseDir;
  intercept_t* in;

  AngleVector(MO.Angles, out PuzzleUseDir);
  x1 = MO.Origin.x;
  y1 = MO.Origin.y;
  x2 = x1+USERANGE*PuzzleUseDir.x;
  y2 = y1+USERANGE*PuzzleUseDir.y;
  foreach MO.PathTraverse(in, x1, y1, x2, y2, PT_ADDLINES|PT_ADDTHINGS/*|PT_EARLYOUT*/) {
    EntityEx mobj;
    TVec hit_point;
    opening_t *open;

    if (in->bIsALine) {
      // check line
      hit_point = MO.Origin+(USERANGE*in->frac)*PuzzleUseDir;
      if (in->line->special != LNSPEC_UsePuzzleItem) {
        if (in->line->flags&(ML_BLOCKEVERYTHING|ML_BLOCKUSE)) {
          // gozzo does this
          open = nullptr;
        } else {
          open = LineOpenings(in->line, hit_point);
        }
        if (!open || open->range <= 0.0) {
          if (MO.bIsPlayer) MO.PlaySound('*puzzfail', CHAN_VOICE);
          break; // can't use through a wall
        }
        continue; // continue searching
      }
      if (PointOnPlaneSide(MO.Origin, *in->line) == 1) {
        // don't use back sides
        break;
      }
      if (PuzzleItemType != in->line->arg1) {
        // item type doesn't match
        break;
      }
      MO.XLevel.StartACS(in->line->arg2, 0, in->line->arg3,
        in->line->arg4, in->line->arg5, MO, in->line, 0, false,
        false);
      in->line->special = 0;
      return true; // stop searching
    }
    // check thing
    mobj = EntityEx(in->Thing);
    if (mobj.Special != LNSPEC_UsePuzzleItem) {
      // wrong special
      continue;
    }
    if (PuzzleItemType != mobj.Args[0]) {
      // item type doesn't match
      continue;
    }
    MO.XLevel.StartACS(mobj.Args[1], 0, mobj.Args[2], mobj.Args[3],
      mobj.Args[4], MO, nullptr, 0, false, false);
    mobj.Special = 0;
    return true; // Stop searching
  }
  return false;
}


//==========================================================================
//
//  AddRevealedMap
//
//==========================================================================
final bool AddRevealedMap () {
  bAutomapRevealed = true;
  foreach (auto i; 0..RevealedMaps.length) {
    if (RevealedMaps[i] == Level.XLevel.MapName) return false; // already revealed
  }
  RevealedMaps.Num = RevealedMaps.Num+1;
  RevealedMaps[RevealedMaps.Num-1] = Level.XLevel.MapName;
  return true;
}


//==========================================================================
//
//  RemoveRevealedMap
//
//==========================================================================
final void RemoveRevealedMap () {
  bAutomapRevealed = false;
  foreach (auto i; 0..RevealedMaps.length) {
    if (RevealedMaps[i] == Level.XLevel.MapName) {
      RevealedMaps.Remove(i);
      return;
    }
  }
}


//==========================================================================
//
//  UpdateRevealedMap
//
//==========================================================================
final void UpdateRevealedMap () {
  bAutomapRevealed = false;
  foreach (auto i; 0..RevealedMaps.length) {
    if (RevealedMaps[i] == Level.XLevel.MapName) {
      bAutomapRevealed = true;
      return;
    }
  }
}


//==========================================================================
//
//  ParticleEffect
//
//==========================================================================
void ParticleEffect (int count, int type1, int type2, TVec origin, float ornd,
                     TVec velocity, float vrnd, float acceleration, float grav,
                     int color, float duration, float ramp)
{
  Level.ParticleEffect(count, type1, type2, origin, ornd, velocity, vrnd, acceleration,
        grav, color, duration, ramp);
}


//==========================================================================
//
//  DecalEffect
//
//==========================================================================
void DecalEffect (TVec org, name dectype, int side, /*line_t *li*/int lineidx) {
  if (!dectype || lineidx < 0 || !Level.XLevel) return; // just in case
  if (!GetCvarB('r_decals_enabled')) return;
  if (lineidx >= Level.XLevel.Lines.length) return;
  Level.XLevel.AddDecal(org, dectype, side, &Level.XLevel.Lines[lineidx]);
}


//==========================================================================
//
//  ClientExplosion
//
//==========================================================================
void ClientExplosion (int color, float rad, TVec org) {
  dlight_t *dl = Level.AllocDlight(none, org, rad+150.0);
  if (dl) {
    //dl->origin = org;
    //dl->radius = rad+150.0;
    dl->color = color;
    dl->die = Level.XLevel.Time+0.5;
    dl->decay = 300.0;
  }
}


//==========================================================================
//
//  ClientParticleExplosion
//
//==========================================================================
void ClientParticleExplosion (int color, float rad, TVec org) {
  TVec porg;
  foreach (auto i; 0..512/*1024*/) {
    porg.x = org.x+((Random()*32.0)-16.0);
    porg.y = org.y+((Random()*32.0)-16.0);
    porg.z = org.z+((Random()*32.0)-16.0);
    particle_t *p = Level.NewParticle(porg);
    if (!p) break;
    p->die = Level.XLevel.Time+5.0;
    p->color = LineSpecialGameInfo.default.ramp1[0];
    p->Size = 1.0;
    p->ramp = Random()*4.0;
    if (i&1) {
      p->type = LineSpecialLevelInfo::pt_explode;
    } else {
      p->type = LineSpecialLevelInfo::pt_explode2;
    }
    p->vel.x = (Random()*512.0)-256.0;
    p->vel.y = (Random()*512.0)-256.0;
    p->vel.z = (Random()*512.0)-256.0;
    //p->accel = (Random()*512.0)-256.0;
    p->gravity = 40.0+(Random()*512.0)-256.0;
  }

  dlight_t *dl = Level.AllocDlight(none, org, rad+150.0);
  if (dl) {
    //dl->origin = org;
    //dl->radius = rad + 150.0;
    dl->color = color;
    dl->die = Level.XLevel.Time+0.5;
    dl->decay = 300.0;
  }
}


//==========================================================================
//
//  ClientSparkParticles
//
//==========================================================================
void ClientSparkParticles (int Count, TVec Org, float Angle) {
  TVec porg;
  foreach (auto i; 0..Count) {
    float an = Angle+Random()*45.0;
    float s, c;
    sincos(an, out s, out c);
    porg.x = Org.x+(Random()*15.0)*c;
    porg.y = Org.y+(Random()*15.0)*s;
    porg.z = Org.z-Random()*4.0;

    particle_t *p = Level.NewParticle(porg);
    if (!p) break;

    p->type = LineSpecialLevelInfo::pt_spark;
    p->Size = 0.5;
    p->color = Random() < 0.5 ? RGBA(255, 120, 0, 255) : RGBA(255, 170, 0, 255);
    p->die = Level.XLevel.Time+10.0/35.0;

    p->vel.x = (Random()-0.5)*2.0;
    p->vel.y = (Random()-0.5)*2.0;
    p->vel.z = (Random()-0.5)*2.0-Random ()*70.0;

    p->accel.x = (Random()-0.5)*16.0+(Random ()-0.5)*35.0;
    p->accel.y = (Random()-0.5)*16.0+(Random ()-0.5)*35.0;
    p->accel.z = (Random()-0.5)*16.0-140.0;
  }
}


//==========================================================================
//
//  AddBlend
//
//==========================================================================
final void AddBlend (out float r, out float g, out float b, out float a, int Col) {
  if (!(Col&0xff000000)) return; // no alpha
  float r1 = float((Col>>16)&0xff)/255.0;
  float g1 = float((Col>>8)&0xff)/255.0;
  float b1 = float(Col&0xff)/255.0;
  float a1 = float((Col>>24)&0xff)/255.0;
  float TmpA = fclamp(1.0-(1.0-a)*(1.0-a1), 0.0, 1.0);
  if (!TmpA) return;
  r = (r*a*(1.0-a1)+r1*a1)/TmpA;
  g = (g*a*(1.0-a1)+g1*a1)/TmpA;
  b = (b*a*(1.0-a1)+b1*a1)/TmpA;
  a = TmpA;
}


//==========================================================================
//
//  AddBlendWithAlpha
//
//  overrides blend color alpha
//
//==========================================================================
final void AddBlendWithAlpha (out float r, out float g, out float b, out float a, int Col, float alpha) {
  if (alpha <= 0) return; // no alpha
  float r1 = float((Col>>16)&0xff)/255.0;
  float g1 = float((Col>>8)&0xff)/255.0;
  float b1 = float(Col&0xff)/255.0;
  float TmpA = fclamp(1.0-(1.0-a)*(1.0-alpha), 0.0, 1.0);
  if (!TmpA) return;
  r = (r*a*(1.0-alpha)+r1*alpha)/TmpA;
  g = (g*a*(1.0-alpha)+g1*alpha)/TmpA;
  b = (b*a*(1.0-alpha)+b1*alpha)/TmpA;
  a = TmpA;
}


//==========================================================================
//
//  PaletteFlash
//
//  Sets the new palette color shift based upon the current values of
//  Player.DamageFlash and Player.BonusFlash, contents and other inventory
//  items.
//
//==========================================================================
void PaletteFlash () {
  float r = 0.0;
  float g = 0.0;
  float b = 0.0;
  float a = 0.0;

  if (MO.WaterLevel == 3) {
    switch (MO.WaterType) {
      case CONTENTS_WATER: AddBlend(r, g, b, a, RGBA(130, 80, 50, 128)); break;
      case CONTENTS_LAVA: AddBlend(r, g, b, a, RGBA(255, 80, 0, 150)); break;
      case CONTENTS_NUKAGE: AddBlend(r, g, b, a, RGBA(50, 255, 50, 150)); break;
      case CONTENTS_SLIME: AddBlend(r, g, b, a, RGBA(0, 25, 5, 150)); break;
      case CONTENTS_HELLSLIME: AddBlend(r, g, b, a, RGBA(255, 80, 0, 150)); break;
      case CONTENTS_BLOOD: AddBlend(r, g, b, a, RGBA(160, 16, 16, 150)); break;
      case CONTENTS_SLUDGE: AddBlend(r, g, b, a, RGBA(128, 160, 128, 150)); break;
      case CONTENTS_HAZARD: AddBlend(r, g, b, a, RGBA(128, 160, 128, 128)); break;
    }
  }

  if (nameicmp(EntityEx(MO).DamageType, 'Ice') == 0) {
    // Frozen player
    AddBlend(r, g, b, a, RGBA(2, 2, 255, 113));
  } else {
    if (DamageFlash) {
      int Amount = int(114.0*DamageFlash);
      if (Amount >= 228) Amount = 228;
      AddBlend(r, g, b, a, (Amount<<24)|(PlayerPawn(MO).DamageScreenColor&0x00ffffff));
    }

    if (BonusFlash) {
      int Amount = int(256.0*BonusFlash);
      if (Amount >= 128) Amount = 128;
      AddBlend(r, g, b, a, RGBA(215, 186, 68, Amount));
    }

    if (PoisonCount) {
      int Amount = PoisonCount*160/32;
      if (Amount >= 160) Amount = 160;
      AddBlend(r, g, b, a, RGBA(56, 118, 46, Amount));
    }

    //FIXME add hazard flash.
    if (HazardTime > 16.0 || int(4.0*HazardTime)&1) {
      AddBlend(r, g, b, a, RGBA(0, 255, 0, 32));
    }
  }

  // item effects
  for (Inventory Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory) {
    int Blend = Item.GetBlend();
    if (Blend) AddBlend(r, g, b, a, Blend);
  }

  // Health Accumulation Device effect
  if (MO && MO.XLevel) {
    float lvtime = MO.XLevel.Time;
    //print("lvtime=%f; k8HealthAccum_LastBoostTime=%f; k8HealthAccum_LastRegenTime=%f", lvtime, k8HealthAccum_LastBoostTime, k8HealthAccum_LastRegenTime);
    bool doRegen = true;
    if (k8HealthAccum_LastBoostTime > 0) {
      float diff = lvtime-k8HealthAccum_LastBoostTime;
      if (diff > 0 && diff < 1) {
        AddBlendWithAlpha(r, g, b, a, RGBA(255, 127, 0, 0), 0.5-diff/2.0);
        doRegen = false;
      }
    }
    if (doRegen && k8HealthAccum_LastRegenTime > 0) {
      float diff = lvtime-k8HealthAccum_LastRegenTime;
      if (diff > 0 && diff < 0.1) {
        AddBlendWithAlpha(r, g, b, a, RGBA(0, 128, 0, 0), 0.1-diff*1);
      }
    }
  }

  if (BlendA) {
    AddBlend(r, g, b, a, RGBA(int(BlendR*255.0), int(BlendG*255.0), int(BlendB*255.0), int(BlendA*255.0)));
  }

  r = fclamp(r, 0.0, 1.0);
  g = fclamp(g, 0.0, 1.0);
  b = fclamp(b, 0.0, 1.0);
  CShift = RGBA(int(r*255.0), int(g*255.0), int(b*255.0), int(a*255.0));
}


//==========================================================================
//
//  PreTravel
//
//==========================================================================
override void PreTravel () {
  ::PreTravel();
  ClearSubSeenInfo();
  SavedInventory = EntityEx(MO).Inventory;
  EntityEx(MO).Inventory = none;
  ResetACSButtons();
}


//==========================================================================
//
//  UseInventory
//
//==========================================================================
override void UseInventory (string Inv) {
  if (!Inv) return;

  if (bTotallyFrozen || (Level.bFrozen && !(Cheats&CF_TIMEFREEZE))) {
    // you can't use items if you're totally frozen
    return;
  }

  name invname = name(Inv);
  Inventory item = EntityEx(MO).FindInventory(class!Inventory(FindClassNoCase(invname)));
  if (!item) item = EntityEx(MO).FindInventory(class!Inventory(GetClassReplacement(FindClassNoCase(invname))));

  if (item) {
    // use Inventory item
    EntityEx(MO).UseInventory(item);
  }
}


//==========================================================================
//
//  CheckDoubleFiringSpeed
//
//==========================================================================
override bool CheckDoubleFiringSpeed () {
  return !!(Cheats&CF_DOUBLEFIRINGSPEED);
}


//==========================================================================
//
//  ClientSpeech
//
//==========================================================================
void ClientSpeech (EntityEx Speaker, int SpeechNum) {
  LineSpecialClientGame(ClGame).StartSpeech(Speaker, SpeechNum);
}


//==========================================================================
//
//  ClientSlideshow1
//
//==========================================================================
void ClientSlideshow1 () {
  LineSpecialClientGame(ClGame).StartConSlideshow1();
}


//==========================================================================
//
//  ClientSlideshow2
//
//==========================================================================
void ClientSlideshow2 () {
  LineSpecialClientGame(ClGame).StartConSlideshow2();
}


//==========================================================================
//
//  ClientFinaleType
//
//==========================================================================
void ClientFinaleType (int Type) {
  LineSpecialClientGame(ClGame).SetFinaleType(Type);
}


//==========================================================================
//
//  SetObjectives
//
//==========================================================================
final void SetObjectives (int NewObjectives) {
  if (!NewObjectives) return;
  // check if log text lump exists in wad file
  if (!WadLumpPresent(name(va("log%d", NewObjectives)))) return;
  Objectives = NewObjectives;
}


//==========================================================================
//
//  StrReplaceSubstitutes
//
//  replaces '%g', '%h', '%p', '%o', '%k'
//
//==========================================================================
final string StrReplaceSubstitutes (string str, EntityEx source) {
  auto ppos = str.strIndexOf("%");
  if (ppos < 0) return str;
  // we have something to process...
  //FIXME: replace with correct gender when we'll implement player genders
  bool isFemale = (MO ? (string(MO.SoundGender).strIndexOf("female", caseSensitive:false) >= 0) : false);
  //print("<>::: isFemale=%B (%s : %d)", isFemale, (MO ? MO.SoundGender : '???'), (string(MO.SoundGender).strIndexOf("female", caseSensitive:false)));
  string res;
  while (ppos >= 0 && ppos+1 < str.length) {
    res ~= str[0..ppos];
    auto nch = str[ppos+1];
    bool validMod = true;
    switch (nch) {
      // double percent, insert one
      case '%': res ~= "%"; break;
      case 'o': case 'O': res ~= PlayerName; break;
      case 'g': res ~= (isFemale ? "she" : "he"); break;
      case 'h': res ~= (isFemale ? "her" : "him"); break;
      case 'p': res ~= (isFemale ? "hers" : "his"); break;
      case 'G': res ~= (isFemale ? "She" : "He"); break;
      case 'H': res ~= (isFemale ? "Her" : "Him"); break;
      case 'P': res ~= (isFemale ? "Hers" : "His"); break;
      case 'k': case 'K':
        if (source && source.bIsPlayer && source.Player) {
          res ~= source.Player.PlayerName;
        } else if (Actor(source) && Actor(source).StrifeName) {
          res ~= Actor(source).StrifeName;
        } else if (source) {
          res ~= string(GetClassName(source.Class));
        } else {
          res ~= "unknown";
        }
        break;
      default:
        validMod = false;
    }
    if (validMod) {
      str = str[ppos+2..$];
    } else {
      res ~= "%";
      str = str[ppos+1..$];
    }
    ppos = str.strIndexOf("%");
  }
  if (str) res ~= str;
  return res;
}


//==========================================================================
//
//  DisplayObituary
//
//==========================================================================
void DisplayObituary (EntityEx inflictor, EntityEx source, name DmgType) {
  string Msg;

       if (nameicmp(DmgType, 'Suicide') == 0) Msg = "$ob_suicide"; // commited a suicide
  else if (nameicmp(DmgType, 'Falling') == 0) Msg = "$ob_falling"; // fell down
  else if (nameicmp(DmgType, 'Crush') == 0) Msg = "$ob_crush"; // crushed by the environment
  else if (nameicmp(DmgType, 'Exit') == 0) Msg = "$ob_exit"; // tried to exit when it's not allowed
  else if (nameicmp(DmgType, 'Drowning') == 0) Msg = "$ob_water"; // drowned int the water
  else if (nameicmp(DmgType, 'Slime') == 0) Msg = "$ob_slime"; // was standing in the slime
  else if (nameicmp(DmgType, 'Fire') == 0 && !source) Msg = "$ob_lava"; // was standing in the lava
  else if (source) {
    if (source.Player == self) {
      // suicide
      Msg = "$ob_killedself";
    } else if (!source.bIsPlayer) {
      // killed by monster
           if (nameicmp(DmgType, 'Telefrag') == 0) Msg = "$ob_montelefrag"; // monster telefrag
      else if (nameicmp(DmgType, 'Melee') == 0 && source.HitObituary) Msg = source.HitObituary;
      else Msg = source.Obituary;
    }
  }

  if (!Msg && source && source.bIsPlayer) {
    if (Level.Game.netgame && !Level.Game.deathmatch) {
      // killed another player in cooperative net game
      Msg = va("$ob_friendly%d", (P_Random()&3)+1); // it goes from 1 to 4, not from 0 to 3
    } else if (nameicmp(DmgType, 'Telefrag') == 0) {
      // telefrag
      Msg = "$ob_mptelefrag";
    } else if (inflictor && inflictor.Obituary) {
      // missile with it's own obituary
      Msg = inflictor.Obituary;
    } else {
      PlayerEx pex = (inflictor && inflictor.Player ? PlayerEx(inflictor.Player) : none);
      Weapon Wpn = (pex ? pex.ReadyWeapon : none);
           if (Wpn && Wpn.Obituary) Msg = Wpn.Obituary; // weapon obituary message
      else if (nameicmp(DmgType, 'BFGSplash') == 0) Msg = "$ob_mpbfg_splash"; // BFG splash damage
      else if (nameicmp(DmgType, 'Railgun') == 0) Msg = "$ob_railgun"; // railgun
      else Msg = "$ob_mpdefault"; // default multiplayer kill message
    }
  } else {
    source = EntityEx(MO);
  }

  if (!Msg) Msg = "$ob_default"; // generic death

  // look up string in language lump if necesary
  if (StrStartsWith(Msg, "$")) Msg = GetLangString(name(Msg[1..$]));

  // do replacements
  /*
  Msg = StrReplace(Msg, "%g", "he");
  Msg = StrReplace(Msg, "%h", "him");
  Msg = StrReplace(Msg, "%p", "his");
  Msg = StrReplace(Msg, "%o", PlayerName);
  Msg = StrReplace(Msg, "%k", source.Player.PlayerName);
  */
  Msg = StrReplaceSubstitutes(Msg, source);

  Level.bprint("%s", Msg);
}


//==========================================================================
//
//  ClientRailTrail
//
//==========================================================================
void ClientRailTrail (TVec From, TVec To, int Col1, int Col2, float MaxDiff) {
  float Len = Length(To-From);
  TVec Dir = Normalise(To-From);
  TAVec Ang;
  VectorAngles(Dir, out Ang);
  Ang.roll = 270.0;

  if (!Col1) Col1 = RGBA(255, 255, 255, 255);
  if (!Col2) Col2 = RGBA(0, 0, 255, 255);

  TVec Diff;
  TVec porg;
  for (float Offs = 0.0; Offs < Len; Offs += 3.0) {
    if (MaxDiff > 0.0) {
      int Rnd = P_Random();
      if (Rnd&1) {
        Diff.x += (Rnd&8 ? 1.0 : -1.0);
        Diff.x = fclamp(Diff.x, -MaxDiff, MaxDiff);
      }
      if (Rnd&2) {
        Diff.y += (Rnd&16 ? 1.0 : -1.0);
        Diff.y = fclamp(Diff.y, -MaxDiff, MaxDiff);
      }
      if (Rnd&4) {
        Diff.z += (Rnd&32 ? 1.0 : -1.0);
        Diff.z = fclamp(Diff.z , -MaxDiff, MaxDiff);
      }
    }

    porg = From+Dir*Offs+Diff;
    particle_t *p = Level.NewParticle(porg);
    if (!p) break;
    p->type = LineSpecialLevelInfo::pt_rail;
    p->Size = 0.5;
    p->color = Col1;
    p->die = Level.XLevel.Time+1.0;
    p->vel.x = (Random()-0.5)*2.0;
    p->vel.y = (Random()-0.5)*2.0;
    p->vel.z = (Random()-0.5)*2.0;
    p->accel = vector(0.0, 0.0, 0.0);

    Ang.roll += 14.0;
    TVec Forward;
    TVec Right;
    TVec Up;
    AngleVectors(Ang, out Forward, out Right, out Up);

    porg = From+Dir*Offs+Up*3.0;
    p = Level.NewParticle(porg);
    if (!p) break;
    p->type = LineSpecialLevelInfo::pt_rail;
    p->Size = 0.5;
    p->color = Col2;
    p->die = Level.XLevel.Time+1.0;
    p->vel = Up;
    p->accel = vector(0.0, 0.0, 0.0);
  }
}


//==========================================================================
//
//  ClientVoice
//
//==========================================================================
void ClientVoice (int VoiceNum) {
  LocalSound(name(va("svox/voc%d", VoiceNum)));
}


//==========================================================================
//
//  GiveAmmo
//
//  Returns false if the ammo can't be picked up at all
//
//==========================================================================
final bool GiveAmmo (class!Ammo ammo, int count) {
  int oldammo;

  if (!ammo) return false;

  Ammo AmmoItem = Ammo(EntityEx(MO).FindInventory(ammo));
  if (!AmmoItem) AmmoItem = Ammo(EntityEx(MO).FindInventory(class!Ammo(GetClassReplacement(ammo))));

  if (!AmmoItem) {
    class!Ammo repl = class!Ammo(GetClassReplacement(ammo));
    if (!repl) repl = ammo;
    AmmoItem = Level.Spawn(repl, default, default, default, false);
    AmmoItem.AttachToOwner(EntityEx(MO));
    AmmoItem.Amount = 0;
  }

  if (!count) return false;

  if (AmmoItem.Amount == AmmoItem.MaxAmount) return false;

  // extra ammo in baby mode and nightmare mode
  count = int(float(count)*Level.World.GetAmmoFactor());

  oldammo = AmmoItem.Amount;
  AmmoItem.Amount += count;
  if (AmmoItem.Amount > AmmoItem.MaxAmount) AmmoItem.Amount = AmmoItem.MaxAmount;

  if (oldammo <= 0) GotAmmo(AmmoItem);

  return true;
}


//==========================================================================
//
//  PutClientIntoServer
//
//==========================================================================
override void PutClientIntoServer () {
  ClearSubSeenInfo();
  if (bIsBot) CreateBot();
}


//==========================================================================
//
//  PerformRebornSpawn
//
//  returns non-null if no players was spawned
//
//==========================================================================
mthing_t *PerformRebornSpawn () {
  bool spawned = false;
  mthing_t *best = nullptr;
  float bestDist = float.max;
  mthing_t *bestOther = nullptr;
  float bestOtherDist = float.max;
  foreach (auto i; 0..Level.PlayerStarts.length) {
    auto sp = &Level.PlayerStarts[i];
    if (sp.type == GetPlayerNum()+1) {
      if (sp.arg1 == Level.Game.RebornPosition) {
        // i found her!
        SpawnPlayer(sp, spawned);
        spawned = true;
        continue;
      }
      if (spawned) continue;
      if (CheckSpot(sp, onlyCheck:true)) {
        float spdist = (MO ? (MO.Origin-vector(sp.x, sp.y)).length2DSquared() : bestDist);
        if (!best || spdist < bestDist) {
          best = sp;
          bestDist = spdist;
        }
      }
    } else if (!spawned) {
      // not ours, but still remember it
      if (!best && CheckSpot(sp, onlyCheck:true)) {
        float spdist = (MO ? (MO.Origin-vector(sp.x, sp.y)).length2DSquared() : bestOtherDist);
        if (!bestOther || spdist < bestOtherDist) {
          bestOther = sp;
          bestOtherDist = spdist;
        }
      }
    }
  }

  if (spawned) return nullptr;

  if (!best && !bestOther) Error("Player %d has no start spots", GetPlayerNum()+1);

  if (!best) {
    print("Player %d has no start spot for position %d, using other spot position", GetPlayerNum()+1, Level.Game.RebornPosition);
    return bestOther;
  } else {
    print("Player %d has no start spot for position %d", GetPlayerNum()+1, Level.Game.RebornPosition);
  }

  return best;
}


//==========================================================================
//
//  SpawnClient
//
//==========================================================================
override void SpawnClient () {
  bool playerWasReborn;
  EntityEx OldMO = EntityEx(MO);
  ClearSubSeenInfo();

  //print("*** SPAWN CLIENT");

  Attacker = none;
  Poisoner = none;

  AddVisitedMap(Level.XLevel.MapName);

  if (Level.Game.netgame && !Level.Game.deathmatch) {
    // cooperative net-play, retain keys and weapons
    playerWasReborn = (PlayerState == PST_REBORN || PlayerState == PST_CHEAT_REBORN);
  } else {
    playerWasReborn = (PlayerState == PST_CHEAT_REBORN);
  }

  // spawn player
  if (Level.Game.deathmatch) {
    DeathMatchSpawnPlayer();
  } else if (Level.Game.netgame || Level.bClusterHub) {
    SpawnPlayer(Level.GetPlayerStart(GetPlayerNum(), Level.Game.RebornPosition), false);
  } else if (PlayerState == PST_CHEAT_REBORN) {
    SpawnPlayer(nullptr, false);
  } else {
    mthing_t *best = PerformRebornSpawn();
    // if returned non-nullptr, it means that no good spawn position was found
    // spawn player anyway, we don't want to totally ruing a game for them
    if (best) SpawnPlayer(best, false);
  }

  /* ResetPlayerOnSpawn() should take care of this
  if (!playerWasReborn && LocalQuakeHappening) {
    print("*** RESETTING QUAKING!");
    LocalQuakeHappening = 0;
  }
  */

  // setup weapon slots
  /+
  if (Level) {
    LineSpecialGameInfo GI = LineSpecialGameInfo(Level.Game);
    if (GI) {
      /*
      foreach (auto wsidx; 0..LineSpecialGameInfo::NUM_WEAPON_SLOTS) {
        print("=== weapon slot #%d", wsidx);
        foreach (auto s2idx; 0..LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT) {
          class!Weapon ww = GI.WeaponSlots[wsidx].Weapons[s2idx];
          if (ww) print("  %d: %n (priority:%d)", s2idx, GetClassName(ww), ww.default.Position);
        }
      }
      */
      GI.InitializeWeaponSlots(class!PlayerPawn(MO.Class));
      /*
      foreach (auto wsidx; 0..LineSpecialGameInfo::NUM_WEAPON_SLOTS) {
        print("=== weapon slot #%d", wsidx);
        foreach (auto s2idx; 0..LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT) {
          class!Weapon ww = GI.WeaponSlots[wsidx].Weapons[s2idx];
          if (ww) print("  %d: %n (priority:%d)", s2idx, GetClassName(ww), ww.default.Position);
        }
      }
      */
    }
  }
  +/
  if (PlayerPawn(MO)) PlayerPawn(MO).InitializeWeaponSlots(LineSpecialGameInfo(Level.Game));

  if (Level.Game.netgame && !Level.Game.deathmatch && playerWasReborn) {
    OnNetReborn(OldMO);
  }

  // destroy all things touching players
  Actor(MO).TeleportMove(MO.Origin);

  k8BossesDetected = (GetCvarB('k8ElvenDetect') ? -0.5 : 666);

  HealthBarInit();
}


//==========================================================================
//
//  NetGameReborn
//
//  Respawn at the start
//
//==========================================================================
override void NetGameReborn () {
  EntityEx OldMO = EntityEx(MO);
  ClearSubSeenInfo();

  // remove pitch and roll angles from corpse
  MO.Angles.pitch = 0.0;
  MO.Angles.roll = 0.0;

  // first dissasociate the corpse
  MO.Player = none;
  MO.bIsPlayer = false;

  // spawn at random spot if in death match
  if (Level.Game.deathmatch) {
    k8HealthAccum_Amount = 0;
    OldMO.DestroyAllInventory();
    DeathMatchSpawnPlayer();
    return;
  }

  if (PlayerState == PST_CHEAT_REBORN) {
    PreTravel(); // this stores all required inventory in `SavedInventory`
    auto oldAccum = k8HealthAccum_Amount;
    SpawnPlayer(nullptr, false);
    k8HealthAccum_Amount = oldAccum;
  } else {
    k8HealthAccum_Amount = 0;
    bool foundSpot = false;
    auto sp = Level.GetPlayerStart(GetPlayerNum(), Level.Game.RebornPosition, failIfNotFound:false);
    if (sp && CheckSpot(sp)) {
      // appropriate player start spot is open
      SpawnPlayer(sp, false);
      foundSpot = true;
    } else {
      // try to spawn at one of the other player start spots
      // this should not fail hard if player start spot is not found, because
      // there can be more players allowed that we have spawn spots
      foreach (auto i; 0..MAXPLAYERS) {
        sp = Level.GetPlayerStart(i, Level.Game.RebornPosition, failIfNotFound:false);
        if (sp && CheckSpot(sp)) {
          print("*** FOUND OTHER PLAYER (%s) STARTING SPOT FOR PLAYER %s", i+1, GetPlayerNum()+1);
          // found an open start spot
          SpawnPlayer(sp, false);
          foundSpot = true;
          break;
        }
      }
    }

    if (!foundSpot) {
      // player's going to be inside something. too bad.
      print("*** NOT FOUND OTHER PLAYER STARTING SPOTS FOR PLAYER %s", GetPlayerNum()+1);
      sp = Level.GetPlayerStart(GetPlayerNum(), Level.Game.RebornPosition);
      CheckSpot(sp); // spawn teleport fog
      SpawnPlayer(sp, false);
    }
  }

  if (PlayerPawn(MO)) PlayerPawn(MO).InitializeWeaponSlots(LineSpecialGameInfo(Level.Game));

  OnNetReborn(OldMO);
}


//==========================================================================
//
//  DisconnectClient
//
//==========================================================================
override void DisconnectClient () {
  ClearSubSeenInfo();
  DestroyBot();
  if (MO) {
    MO.Player = none;
    MO.bIsPlayer = false;
    Actor(MO).Damage(none, none, 10000, forced:true, spawnBlood:true);
  }
  Level.bprint("%s left the game", PlayerName);
  MO.PlaySound('misc/chat', CHAN_AUTO, 1.0, ATTN_NONE);
  HealthBarDeinit();
}


//==========================================================================
//
//  DeathMatchSpawnPlayer
//
//  Spawns a player at one of the random death match spots called at level
//  load and each death
//
//==========================================================================
void DeathMatchSpawnPlayer () {
  if (!Level.DeathmatchStarts.length) Error("oops! no deathmatch starts where they should be!");

  // shuffle them
  array!int dms;
  dms.length = Level.DeathmatchStarts.length;
  foreach (int didx; 0..dms.length) dms[didx] = didx;

  // the famous Fisher-Yates shuffle
  foreach (int didx; 0..dms.length-1) {
    int swapidx = didx+roundi(FRandomFull()*(dms.length-didx-1));
    if (swapidx != didx) {
      int tmp = dms[swapidx];
      dms[swapidx] = dms[didx];
      dms[didx] = tmp;
    }
  }

  foreach (int i; dms) {
    auto sp = &Level.DeathmatchStarts[i];
    if (CheckSpot(sp)) {
      SpawnPlayer(sp, false);
      return;
    }
  }

  // no good spot, so the player will probably get stuck
  {
    auto sp = Level.GetPlayerStart(GetPlayerNum(), 0);
    CheckSpot(sp); // spawn teleport fog
    SpawnPlayer(sp, false);
  }
}


//==========================================================================
//
//  CheckSpot
//
//  Returns false if the player cannot be respawned at the given mthing_t
//  spot because something is occupying it
//
//==========================================================================
bool CheckSpot (mthing_t *mthing, optional bool onlyCheck) {
  float x;
  float y;
  sector_t *sec;
  float an;

  if (!MO) {
    // first spawn of level, before corpses
    foreach (auto i; 0..MAXPLAYERS) {
      if (Level.Game.Players[i] && Level.Game.Players[i].MO &&
          Level.Game.Players[i].MO.Origin.x == mthing->x &&
          Level.Game.Players[i].MO.Origin.y == mthing->y)
      {
        return false;
      }
    }
    return true;
  }

  x = mthing->x;
  y = mthing->y;

  {
    auto oldPassMObj = MO.bPassMobj;
    scope(exit) MO.bPassMobj = oldPassMObj;
    MO.bPassMobj = false;
    if (!MO.CheckPosition(vector(x, y, Actor::ONFLOORZ))) return false;
  }

  if (!onlyCheck) {
    if (!PlayerChunk(MO)) {
      LineSpecialLevelInfo(Level).AddPlayerCorpse(EntityEx(MO));
    }

    // spawn a teleport fog
    sec = Level.XLevel.PointInSector(vector(x, y, 0.0));
    an = float(45*(mthing->angle/45));

    Level.Spawn(TeleportFog, vector(x+20.0*cos(an), y+20.0*sin(an),
      sec->floor.TexZ+LineSpecialGameInfo(Level.Game).TeleFogHeight));
  }

  return true;
}


//==========================================================================
//
//  SetUpPlayerClass
//
//==========================================================================
void SetUpPlayerClass () {
  if (LineSpecialGameInfo(Level.Game).bRandomClass &&
      Level.Game.deathmatch && Level.Game.PlayerClasses.Num > 1)
  {
    PClass = P_Random()%Level.Game.PlayerClasses.Num;
    if (PClass == BaseClass) PClass = (PClass+1)%Level.Game.PlayerClasses.Num;
    BaseClass = PClass;
    SB_Start();
  } else {
    PClass = BaseClass;
  }
}


//==========================================================================
//
//  ResetACSButtons
//
//  reset ACS button update timers and values
//
//==========================================================================
final void ResetACSButtons () {
  AcsCurrButtonsPressed = 0;
  AcsCurrButtons = 0;
  AcsButtons = 0;
  OldButtons = 0;
  AcsNextButtonUpdate = 0;
  AcsPrevMouseX = 0;
  AcsPrevMouseY = 0;
  AcsMouseX = 0;
  AcsMouseY = 0;
}


//==========================================================================
//
//  ResetPlayerOnSpawn
//
//==========================================================================
void ResetPlayerOnSpawn (optional bool keepPlayerState) {
  if (!keepPlayerState) PlayerState = PST_LIVE;
  ClearSubSeenInfo();
  Refire = 0;
  DamageFlash = 0.0;
  BonusFlash = 0.0;
  PoisonCount = 0;
  MorphTime = 0.0;
  ExtraLight = 0;
  FixedColormap = 0;
  LastSectorDamageTic = 0;
  LastHazardTime = 0.0;
  Rain1 = none;
  Rain2 = none;

  JumpTime = 0;
  LocalQuakeHappening = vector(0, 0, 0);
  MoveDir = vector(0, 0, 0);
  HazardTime = 0;
  //Weapon ReadyWeapon;
  //Weapon PendingWeapon;  // Is none if not changing.
  //FlyHeight = 0;
  /*
  bFrozen = false; // just in case
  bTotallyFrozen = false; // just in case
  */
  bFly = false; // just in case
  PoisonCount = 0; // screen flash for poison damage
  LastPoisonTime = 0;
  Poisoner = none; // none for non-player mobjs
  PoisonerPlayer = none; // for KArena

  MorphTime = 0;  // player is morphed into something if > 0
  MorphStyle = 0;
  BlendR = 0;
  BlendG = 0;
  BlendB = 0;
  BlendA = 0;
  ChickenPeck = 0; // chicken peck countdown

  //k8: just in case
  ResetWeaponReloadRefire();

  if (GetCvarB('k8HealthAccum_Reset')) k8HealthAccum_Amount = 0;
  k8HealthAccum_LastRegenTime = -10000;
  k8HealthAccum_LastBoostTime = -10000;

  if (GetCvarB('r_allow_ambient')) bFlashlightOn = false;
  bFlashlightButtonDown = false;

  k8NextSuperBulletTime = 0;

  ResetACSButtons();

  k8BossesDetected = 666;
  k8ElvenGiftMessageTime = 666;
}


//==========================================================================
//
//  GiveDefaultDeathMatchInventory
//
//  FIXME: replacements?
//
//==========================================================================
void GiveDefaultDeathMatchInventory () {
  class!Inventory  Cls;

  // give all keys in death match mode
  foreach AllClasses(Key, Cls) {
    if (!FindClassState(Cls, 'Spawn')) continue; // abstract class
    if (!AreStateSpritesPresent(FindClassState(Cls, 'Spawn'))) continue; // from a different game
    EntityEx(MO).GiveInventoryType(Cls);
  }
}


//==========================================================================
//
//  ResetInventory
//
//==========================================================================
override void ResetInventory () {
  EntityEx PP = EntityEx(MO);
  if (!PP) return;
  while (PP.Inventory) PP.Inventory.Destroy();

  SetWeapon(none);
  BringUpWeapon(instant:true, skipSound:true);

  AddDefaultInventory();

  k8ElvenGifted = false;
  GiveElvenGifts(nullptr);
}


//==========================================================================
//
//  ResetHealth
//
//==========================================================================
override void ResetHealth () {
  EntityEx PP = EntityEx(MO);
  if (!PP) return;
  Health = GetRebornHealth();
  PP.Health = Health;
}


//==========================================================================
//
//  PreraiseWeapon
//
//==========================================================================
override void PreraiseWeapon () {
  EntityEx PP = EntityEx(MO);
  if (!PP) return;
  if (!ReadyWeapon) return;
  print("PRERAISE!");
  BringUpWeapon(instant:true, skipSound:true);
}


//==========================================================================
//
//  SpawnPlayer
//
//  Called when a player is spawned on the level. Most of the player
//  structure stays unchanged between levels.
//
//==========================================================================
void SpawnPlayer (mthing_t *mthing, bool Voodoo) {
  PlayerPawn PP;
  bool ResetInventory = false;
  bool reborned = false;
  Inventory Item;

  TVec spawnOrigin = (mthing ? vector(mthing->x, mthing->y, Actor::ONFLOORZ) : MO.Origin);
  float spawnYaw = (mthing ? float(45*(mthing->angle/45)) : MO.Angles.yaw);

  //print("*** SPAWN PLAYER");

  bool cheatReborn = false;

  //print("************SpawnPlayer: 000; Voodoo=%b; PST=%d", PlayerState);
  if (PlayerState == PST_REBORN) {
    PlayerReborn();
    ResetInventory = true;
    reborned = true;
  } else if (PlayerState == PST_CHEAT_REBORN) {
    //print("*** CHEAT REBORN ***");
    PlayerReborn();
    ResetInventory = false;
    reborned = true;
    cheatReborn = true;
  } else {
    if (Level.bResetInventory && !GetCvarB('sv_ignore_reset_inventory')) ResetInventory = true;
  }

  if (!cheatReborn && GetCvarB('sv_force_pistol_start')) ResetInventory = true;

  SetUpPlayerClass();

  float x = spawnOrigin.x;
  float y = spawnOrigin.y;
  float z = spawnOrigin.z;
  if (PClass >= Level.Game.PlayerClasses.Num) Error("Player::SpawnPlayer: Unknown class type");

  PP = Level.Spawn(class!PlayerPawn(Level.Game.PlayerClasses[PClass]), vector(x, y, z), default, default, false);
  print("spawned player with class <%C>...", PP);
  if (GetCvarS('player_default_gender')) PP.SoundGender = name(GetCvarS('player_default_gender'));
  if (mthing) PP.Origin.z += mthing->height;
  PP.LinkToWorld(properFloorCheck:true);
  PP.FriendPlayer = GetPlayerNum()+1; // players are their own friends
  ClearSubSeenInfo();

  // set color translations for player sprites
  TranslStart = PP.TranslStart;
  TranslEnd = PP.TranslEnd;
  PP.Translation = (Entity::TRANSL_Player<<Entity::TRANSL_TYPE_SHIFT)+GetPlayerNum();

  // if a voodoo doll has been spawned, take it's inventory
  if (Voodoo) PP.ObtainInventory(EntityEx(MO));

  DesiredFOV = 90.0; //float(GetCvar('FOV'));
  FOV = DesiredFOV;
  PP.Angles.yaw = spawnYaw;
  PP.Player = self;
  PP.bIsPlayer = true;
  PP.Health = Health;
  MO = PP;
  Camera = PP;
  ViewHeight = PP.ViewHeight;
  ViewOrg = MO.Origin;
  ViewOrg.z += ViewHeight;
  lastViewOrgZForPfx = MO.Origin.z;
  ViewAngles = PP.Angles;
  bFixAngle = true;

  ResetPlayerOnSpawn();

  if (!Voodoo) {
    PP.Inventory = SavedInventory;
    for (Item = PP.Inventory; Item; Item = Item.Inventory) Item.Owner = MO;
    if (ResetInventory) {
      while (PP.Inventory) PP.Inventory.Destroy();
      AddDefaultInventory();
    } else if (Level.bResetItems && !GetCvarB('sv_ignore_reset_items')) {
      Inventory inv = PP.Inventory;
      while (inv) {
        Inventory c = inv;
        inv = inv.Inventory;
        if (c.bInvBar && !c.bUndroppable) c.Destroy();
      }
    }
  }

  // set up gun psprite
  SetupPsprites();

  if (Level.Game.deathmatch && !IsCheckpointSpawn) GiveDefaultDeathMatchInventory();

  // wake up the status bar
  SB_Start();

  if (bIsBot) BotOnSpawn();

  SetClientModel();

  UpdateRevealedMap();

  if (ResetInventory) {
    if (reborned) Level.XLevel.StartTypedACScripts(Level::SCRIPT_Respawn, 0, 0, 0, MO, true, false);
    k8ElvenGifted = false;
  }

  //print("*** CHECKPOINT SPAWN: %B", IsCheckpointSpawn);
  if (!IsCheckpointSpawn) {
    GiveElvenGifts(mthing, Voodoo);
  }

  if (!reborned && !IsCheckpointSpawn) {
    if ((Level.bResetHealth && !GetCvarB('sv_ignore_reset_health')) || GetCvarB('sv_force_health_reset')) {
      Health = GetRebornHealth();
      EntityEx(MO).Health = Health;
    }
  }

  k8BossesDetected = (GetCvarB('k8ElvenDetect') ? -0.5 : 666);
}


//===========================================================================
//
//  PerformBossDetection
//
//  this is virtual, so mods can override it
//
//===========================================================================
void PerformBossDetection () {
  if (!MO) return;
  // detect bosses
  Actor act;
  int cybbieCount = 0, mindCount = 0;
  foreach MO.AllThinkers(Actor, out act) {
    class!Actor ec = class!Actor(act.Class);
    while (ec) {
      switch (GetClassName(ec)) {
        case 'Cyberdemon': ++cybbieCount; break;
        case 'SpiderMastermind': ++mindCount; break;
      }
      ec = class!Actor(GetClassParent(ec));
    }
    //if (hasCybbie && hasMind) break; // just in case
  }
  string msg;
  if (cybbieCount && mindCount) {
    if (cybbieCount > 1 && mindCount > 1) msg = va("%d Cyberdemons and %d Masterminds detected!", cybbieCount, mindCount);
    else if (cybbieCount > 1) msg = va("%d Cyberdemons and Mastermind detected!", cybbieCount);
    else if (mindCount > 1) msg = va("Cyberdemon and %d Masterminds detected!", mindCount);
    else msg = "Cyberdemon and Mastermind detected!";
  }
  else if (cybbieCount > 1) msg = va("%d Cyberdemons detected!", cybbieCount);
  else if (cybbieCount) msg = "Cyberdemon detected!";
  else if (mindCount > 1) msg = va("%d Masterminds detected!", mindCount);
  else if (mindCount) msg = "Mastermind detected!";
  if (msg) {
    print("\c[Red]*** %s ***", msg);
    ClientHudMessage(msg, 'smallfont', HUDMsgType.FadeInOut|HUDMsgFlag.ColorString/*|HUDMsgFlag.Log*/, 123669, CR_UNDEFINED, "Green",
      0.5, 0.5, 0, 0,
      2.5, 0.5, 1.0);
  }
}


//===========================================================================
//
//  ShowElvenGiftMessage
//
//  this is virtual, so mods can override it
//
//===========================================================================
void ShowElvenGiftMessage () {
  if (!MO) return;
  ClientHudMessage("ELVEN GIFT", 'smallfont', HUDMsgType.FadeInOut, 123666, CR_ORANGE, "",
    0.5, 0.45, 0, 0,
    2.0, 0.4, 0.8);
}


//===========================================================================
//
//  GiveElvenGifts
//
//  this is virtual, so mods can override it
//
//===========================================================================
void GiveElvenGifts (optional mthing_t *mthing, optional bool Voodoo, optional bool forced) {
  //print("************SpawnPlayer: gifted=%s", (k8ElvenGifted ? "tan" : "ona"));
  k8ElvenGiftMessageTime = 666;
  if (forced || GetCvarB('k8ElvenGift')) {
    if (forced) k8ElvenGifted = false;
    if (!Voodoo && !k8ElvenGifted) {
      k8ElvenGifted = true; // gifts should be given only once
      bool showMessage = false;
      if (AddElvenGift('Shotgun')) { showMessage = true; AddElvenGift('ShellBox'); }
      if (AddElvenGift('BDW_Rifle')) { showMessage = true; foreach (; 0..9) AddElvenGift('Clip'); if (ShouldRemovePistol()) RemovePistol(); }
      print("\c[Green]%s", "Elven Gifts!");
      if (showMessage) k8ElvenGiftMessageTime = -0.3;
    }
    // oops; change weapon, as voodoo doll was spawned
    if (Voodoo && k8ElvenGifted) {
      if (FindClass('BDW_Rifle') && ReadyWeapon && ReadyWeapon.bWimpyWeapon && (!PendingWeapon || PendingWeapon.bWimpyWeapon)) {
        auto rfc = FindClass('BDW_Rifle');
        for (Inventory Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory) {
          if (Item.Class == rfc) {
            if (ReadyWeapon != Weapon(Item)) {
              //PendingWeapon = Weapon(Item);
              SetWeapon(Weapon(Item));
              BringUpWeapon();
            }
            break;
          }
        }
      }
    }
  }
}


//===========================================================================
//
//  AddElvenGift
//
//===========================================================================
final bool AddElvenGift (name Klass) {
  class!Thinker th = class!Thinker(FindClass(Klass));
  if (th) {
    Actor act = Actor(Level.Spawn(th));
    if (!act) return false;
    if (Klass == 'BDW_Rifle') {
      Weapon(act).AmmoGive2 = 31;
      if (ReadyWeapon != Weapon(act)) {
        //PendingWeapon = Weapon(act);
        SetWeapon(Weapon(act));
        BringUpWeapon();
      }
    } else if (Klass == 'BDW_Shotgun' || (Klass == 'Shotgun' && FindClass('BDW_Shotgun'))) {
      Weapon(act).AmmoGive2 = 8;
    }
    act.TouchSpecial(EntityEx(MO), true);
    if (Klass == 'BDW_Rifle' && ReadyWeapon && ReadyWeapon.bWimpyWeapon && (!PendingWeapon || PendingWeapon.bWimpyWeapon)) {
      if (ReadyWeapon != Weapon(act)) {
        //PendingWeapon = Weapon(act);
        SetWeapon(Weapon(act));
        BringUpWeapon();
      }
    }
    return true;
  } else {
    return false;
  }
}


//===========================================================================
//
//  ShouldRemovePistol
//
//  this is virtual, so mods can override it
//
//===========================================================================
bool ShouldRemovePistol () {
  Inventory inv = EntityEx(MO).Inventory;
  while (inv) {
    Weapon Wpn = Weapon(inv);
    inv = inv.Inventory;
    if (Wpn) {
      class!Weapon wc = class!Weapon(Wpn.Class);
      while (wc) {
        if (GetClassName(wc) == 'BDW_Rifle') return true;
        wc = class!Weapon(GetClassParent(wc));
      }
    }
  }
  return false;
}


//===========================================================================
//
//  RemovePistol
//
//  this is virtual, so mods can override it
//
//===========================================================================
void RemovePistol () {
  Inventory inv = EntityEx(MO).Inventory;
  while (inv) {
    Weapon Wpn = Weapon(inv);
    inv = inv.Inventory;
    if (Wpn) {
      //print("WPN: %C", Wpn);
      switch (GetClassName(Wpn.Class)) {
        case 'Pistol':
        case 'PerkPistol':
          EntityEx(MO).RemoveInventory(Wpn);
          break;
      }
    }
  }
}


//===========================================================================
//
//  AddDefaultInventory
//
//===========================================================================
void AddDefaultInventory () {
  HexenArmor HArmor = Level.Spawn(HexenArmor, default, default, default, false);
  HArmor.AttachToOwner(EntityEx(MO));
  HArmor.Slots[4] = PlayerPawn(MO).HexenArmor[0];
  HArmor.SlotsIncrement[0] = PlayerPawn(MO).HexenArmor[1];
  HArmor.SlotsIncrement[1] = PlayerPawn(MO).HexenArmor[2];
  HArmor.SlotsIncrement[2] = PlayerPawn(MO).HexenArmor[3];
  HArmor.SlotsIncrement[3] = PlayerPawn(MO).HexenArmor[4];

  BasicArmor BArmor = Level.Spawn(BasicArmor, default, default, default, false);
  BArmor.Amount = 0;
  BArmor.AttachToOwner(EntityEx(MO));

  //print("AddDefaultInventory: MO=`%C`", MO);
  foreach (auto i; 0..EntityEx(MO).DropItemList.length) {
    class!Entity tp = EntityEx(MO).DropItemList[i].Type;
    class!Entity tprepl = none;
    if (tp) tprepl = class!Inventory(GetClassReplacement(tp));
    //print("  i=%d; type=`%C`(%C); name=`%s`; amount=%s; chance=%s", i, tp, tprepl, EntityEx(MO).DropItemList[i].TypeName, EntityEx(MO).DropItemList[i].Amount, EntityEx(MO).DropItemList[i].Chance);
    if (!tprepl) continue;
    Inventory Item = Inventory(Level.Spawn(tprepl, default, default, default, false));
    Item.bIgnoreSkill = true;
    int amount = EntityEx(MO).DropItemList[i].Amount;
    if (amount > 0) Item.Amount = amount; else if (amount == -666) Item.Amount = 0;
    if (Weapon(Item)) {
      // for better control empty weapon's ammo
      Weapon(Item).AmmoGive1 = 0;
      Weapon(Item).AmmoGive2 = 0;
    }
    if (!Item.TryPickup(EntityEx(MO))) {
      Item.Destroy();
    } else if (Weapon(Item) && Weapon(Item).CheckAmmo(Weapon::FIRE_Either, false)) {
      SetWeapon(Weapon(Item));
      Weapon(Item).bBobDisabled = true;
    }
  }
}


//==========================================================================
//
//  PlayerReborn
//
//  Called after a player dies almost everything is cleared and initialised
//
//==========================================================================
void PlayerReborn () {
  // clear player struct
  DoClearPlayer();

  PClass = BaseClass;

  // set initial data
  ResetPlayerOnSpawn(keepPlayerState:true);
  bUseDown = true; // don't do anything immediately
  bAttackDown = true;
  ResetWeaponReloadRefire();
  PlayerState = PST_LIVE;
  Health = GetRebornHealth();
}


//==========================================================================
//
//  DoClearPlayer
//
//==========================================================================
void DoClearPlayer () {
  ClearPlayer();
}


//==========================================================================
//
//  PlayerBeforeExitMap
//
//  Called when a player completes a level, but before going to imis.
//  Not called for intermissions.
//
//==========================================================================
override void PlayerBeforeExitMap () {
  ClearSubSeenInfo();
  if (GetCvarB('k8HealthAccum_NewMapHeal')) {
    int maxhealth = GetMaxHealth();
    int oldhealth = Health;
    if (maxhealth > 0 && oldhealth < maxhealth && k8HealthAccum_Amount > 0) {
      Health = min(oldhealth+k8HealthAccum_Amount, maxhealth);
      if (Health > oldhealth) {
        if (MO) MO.Health = Health;
        k8HealthAccum_Amount -= Health-oldhealth; // just in case
      }
    }
  }
}


//==========================================================================
//
//  PlayerExitMap
//
//  Called when a player completes a level.
//
//==========================================================================
override void PlayerExitMap (bool clusterChange) {
  ClearSubSeenInfo();
  Inventory Item;

  if (clusterChange && !Level.bClusterHub && !Level.bKeepFullInventory) {
    for (Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory) {
      if (Item.bInvBar && Item.Amount > Item.InterHubAmount) {
        Item.Amount = Item.InterHubAmount;
      }
    }
  }

  // strip all current powers
  for (Item = EntityEx(MO).Inventory; Item; ) {
    Inventory Next = Item.Inventory;
    if (Powerup(Item) && (Level.Game.deathmatch || clusterChange || !Item.bHubPower)) {
      Item.Destroy();
    }
    Item = Next;
  }

  if (clusterChange) {
    // entering new cluster
    // some items are stripped
    for (Item = EntityEx(MO).Inventory; Item; ) {
      Inventory Next = Item.Inventory;
      if (Item.bInterHubStrip /*&& Item.InterHubAmount < 1*/) {
        Item.Destroy();
      }
      Item = Next;
    }
  }

  if (MorphTime) {
    Weapon wpn = Weapon(Actor(MO).Tracer);
    if (wpn) wpn.bBobDisabled = true;
    SetWeapon(wpn); // restore weapon
    MorphTime = 0.0;
  }

  MO.Angles.pitch = 0.0;
  MO.RenderStyle = Entity::STYLE_Normal;
  MO.Alpha = 1.0;
  EntityEx(MO).bShadow = false; // cancel invisibility
  ExtraLight = 0; // cancel gun flashes
  FixedColormap = 0; // cancel ir gogles
  DamageFlash = 0.0; // no palette changes
  BonusFlash = 0.0;
  PoisonCount = 0;
  BlendR = 0.0;
  BlendG = 0.0;
  BlendB = 0.0;
  BlendA = 0.0;
  Rain1 = none;
  Rain2 = none;
  //k8: just in case
  ResetWeaponReloadRefire();
  LocalQuakeHappening = vector(0, 0, 0);
}


//==========================================================================
//
//  InventoryLeft
//
//==========================================================================
final void InventoryLeft () {
  if (!bInventoryAlwaysOpen) {
    if (!InventoryTime) {
      InventoryTime = 5.0;
      return;
    }
    InventoryTime = 5.0;
  }

  if (InvPtr) {
    Inventory Prev = InvPtr.PrevInv();
    if (Prev) {
      InvPtr = Prev;
      AdjustInvFirst();
    }
  }
}


//==========================================================================
//
//  InventoryRight
//
//==========================================================================
final void InventoryRight () {
  if (!bInventoryAlwaysOpen) {
    if (!InventoryTime) {
      InventoryTime = 5.0;
      return;
    }
    InventoryTime = 5.0;
  }

  if (InvPtr) {
    Inventory Next = InvPtr.NextInv();
    if (Next) {
      InvPtr = Next;
      AdjustInvFirst();
    }
  }
}


//==========================================================================
//
//  InventoryUse
//
//==========================================================================
final void InventoryUse () {
  // flag to denote that it's okay to use an artifact
       if (InventoryTime) InventoryTime = 0.0;
  else if (InvPtr) EntityEx(MO).UseInventory(InvPtr);
}


//==========================================================================
//
//  InventoryTick
//
//==========================================================================
final void InventoryTick (float deltaTime) {
  // turn inventory off after a certain amount of time
  if (InventoryTime) {
    InventoryTime -= deltaTime;
    if (InventoryTime <= 0.0) InventoryTime = 0.0;
  }
  if (ArtifactFlash) --ArtifactFlash;
}


//==========================================================================
//
//  AdjustInvFirst
//
//==========================================================================
final void AdjustInvFirst () {
  Inventory Item;

  if (!InvPtr) {
    InvFirst = none;
    return;
  }

  // count how many items are following the current one, also make sure
  // that first is not after this one
  int NumFollowing = 0;
  for (Item = InvPtr.NextInv(); Item; Item = Item.NextInv()) {
    ++NumFollowing;
    if (InvFirst == Item) InvFirst = InvPtr;
  }

  int FirstOffs = 0;
  for (Item = InvPtr; Item && Item != InvFirst; Item = Item.PrevInv()) ++FirstOffs;

  while (FirstOffs > InvSize) {
    InvFirst = InvFirst.NextInv();
    --FirstOffs;
  }

  while (NumFollowing+FirstOffs < InvSize && InvFirst.PrevInv()) {
    InvFirst = InvFirst.PrevInv();
    ++FirstOffs;
  }
}


//==========================================================================
//
//  InventoryThrow
//
//==========================================================================
final EntityEx InventoryThrow () {
  if (!InvPtr) return none;
  return EntityEx(MO).DropInventory(InvPtr);
}


//==========================================================================
//
//  UseFlyPower
//
//==========================================================================
final void UseFlyPower () {
  PlayerUseArtifactType(ArtiFly);
}


//==========================================================================
//
//  PlayerUseArtifactType
//
//==========================================================================
final void PlayerUseArtifactType (class!Inventory arti) {
  Inventory Item = EntityEx(MO).FindInventory(arti);
  if (Item) EntityEx(MO).UseInventory(Item);
}


//==========================================================================
//
//  PlayerNextArtifact
//
//==========================================================================
final void PlayerNextArtifact () {
  if (!InvPtr) return;
  Inventory NewPtr = InvPtr.PrevInv();
  if (!NewPtr) {
    NewPtr = InvPtr;
    while (NewPtr.NextInv()) NewPtr = NewPtr.NextInv();
  }
  InvPtr = NewPtr;
  AdjustInvFirst();
}


//==========================================================================
//
//  DeathPlayerTick
//
//  Fall on your face when dying. Decrease POV height to floor height.
//
//==========================================================================
final void DeathPlayerTick (float deltaTime) {
  ClearSubSeenInfo();
  MovePsprites(deltaTime);

  if (MO.WaterLevel > 1) MO.Velocity.z = -60.0; // drift towards bottom

  onground = (MO.Origin.z <= MO.FloorZ);

  if (PlayerChunk(MO)) {
    // flying bloody skull or flying ice chunk
    ViewHeight = 6.0;
    DeltaViewHeight = 0.0;
    //damagecount = 20;
    if (onground) {
#ifdef FIXME
      if (lookdir < 60) {
        int lookDelta = (60-lookdir)/8;
             if (lookDelta < 1 && (level->tictime&1)) lookDelta = 1;
        else if (lookDelta > 6) lookDelta = 6;
        lookdir += lookDelta;
      }
#endif
    }
  } else if (Actor(MO).DamageType != 'Ice') {
    // fall to ground (if not frozen)
    DeltaViewHeight = 0.0;
    if (ViewHeight > 6.0) ViewHeight -= 35.0*deltaTime;
    if (ViewHeight < 6.0) ViewHeight = 6.0;
#ifdef FIXME
         if (lookdir > 0) lookdir -= 6;
    else if (lookdir < 0) lookdir += 6;
    if (abs(lookdir) < 6) lookdir = 0;
#endif
  }
  CalcHeight(deltaTime);

  if (Attacker && Attacker != MO) {
    // watch killer
    float delta;
    int dir = EntityEx(MO).FaceActor(EntityEx(Attacker), delta);
    if (delta < 10.0) {
      // looking at killer, so fade damage and poison counters
      if (DamageFlash) {
        DamageFlash -= deltaTime;
        if (DamageFlash <= 0.0) DamageFlash = 0.0;
      }
      if (PoisonCount) --PoisonCount;
    }
    delta = fmin(5.0, delta/8.0);
    if (dir) {
      // turn clockwise
      MO.Angles.yaw += delta;
    } else {
      // turn counter clockwise
      MO.Angles.yaw -= delta;
    }
  } else if (DamageFlash) {
    DamageFlash -= deltaTime;
    if (DamageFlash <= 0.0) DamageFlash = 0.0;
  } else if (PoisonCount) {
    --PoisonCount;
  }

  if (CheckForRespawn(deltaTime)) {
    InvPtr = none;
    InvFirst = none;
    PlayerState = PST_REBORN;
  }
}


//==========================================================================
//
//  CheckForRespawn
//
//==========================================================================
bool CheckForRespawn (float deltaTime) {
  return !!(Buttons&BT_USE);
}


//==========================================================================
//
//  checkDoHealthAccumBoost
//
//  this should be called after health < maxhealth checked
//  k8HealthAccum_Amount should be checked and set too
//
//==========================================================================
bool checkDoHealthAccumBoost () {
  if (k8HealthAccum_Amount < 1) return false;
  // can boost?
  int boostPoints = GetCvarI('k8HealthAccum_BoostPoints');
  if (!boostPoints) return false;
  // hit boost limit?
  int boostLow = GetCvarI('k8HealthAccum_BoostLow');
  if (Health >= boostLow) return false;
  // boost cooldowned?
  float boostCooldownTime = fmax(0, GetCvarF('k8HealthAccum_BoostCooldown'));
  if (k8HealthAccum_LastBoostTime+boostCooldownTime > MO.XLevel.Time) return false;
  // calculate boost amount
  int newh = (boostPoints < 0 ? -boostPoints : Health+boostPoints);
  if (newh <= Health) return false;
  int relh = min(k8HealthAccum_Amount, newh-Health);
  if (relh < 1) return false; // just in case
  // perform health boost
  if (GetCvarB('k8HealthAccum_MessagesBoost')) {
    if (boostPoints < 0) cprint("Health boosted to %d", Health+relh); else cprint("Health boosted by %d", relh);
  }
  k8HealthAccum_LastBoostTime = MO.XLevel.Time;
  k8HealthAccum_Amount -= relh;
  Health += relh;
  MO.Health = Health; //k8: we need this for UI
  return true;
}


//==========================================================================
//
//  checkDoHealthAccumRegen
//
//  this should be called after health < maxhealth checked
//  k8HealthAccum_Amount should be checked and set too
//
//==========================================================================
bool checkDoHealthAccumRegen () {
  if (k8HealthAccum_Amount < 1) return false;
  // can regen?
  int regenPoints = GetCvarI('k8HealthAccum_RegenPoints');
  if (regenPoints < 1) return false;
  // hit regen limit?
  int maxhealth = GetMaxHealth();
  if (Health >= maxhealth) return false;
  int regenLow = GetCvarI('k8HealthAccum_RegenLow');
  if (regenLow > 0 && Health >= regenLow) return false; // player is not hurt enough
  // regen cooldowned?
  float regenRateTime = fmax(0, GetCvarF('k8HealthAccum_RegenRate'));
  /*
  print("k8HealthAccum_Amount=%s; Health=%s; rp=%s; max=%s; rate=%s; last=%s; time=%s",
    k8HealthAccum_Amount, Health, regenPoints, maxhealth, regenRateTime, k8HealthAccum_LastRegenTime, MO.XLevel.Time);
  */
  if (k8HealthAccum_LastRegenTime+regenRateTime > MO.XLevel.Time) return false;
  // check for boost cooldown too
  float boostCooldownTime = fmax(0, GetCvarF('k8HealthAccum_BoostCooldown'));
  if (k8HealthAccum_LastBoostTime+boostCooldownTime > MO.XLevel.Time) return false;
  // calculate regen amount
  int newh = Health+regenPoints;
  int relh = min(k8HealthAccum_Amount, newh-Health);
  if (relh < 1) return false; // just in case
  // perform health regen
  if (GetCvarB('k8HealthAccum_MessagesRegen')) cprint("Health regenerated by %d", relh);
  k8HealthAccum_LastRegenTime = MO.XLevel.Time;
  k8HealthAccum_Amount -= relh;
  Health += relh;
  MO.Health = Health; //k8: we need this for UI
  return true;
}


//==========================================================================
//
//  doHealthAccumHealthPickup
//
//  returns `true` if Health Accumulator (or player) consumed the item
//  must increase player's health if necessary
//  should never be called with `none`
//
//==========================================================================
bool doHealthAccumHealthPickup (Health item, EntityEx toucher) {
  if (!item) return false; // meh, just in case
  int amount = item.Amount;
  int itemhealthlimit = item.MaxAmount;
  // is this small health bonus (like bottle)?
  if (itemhealthlimit) {
    // you should be able to pick up health bonuses even at full health
    // note that health bonuses cannot be accumulated
    // increase health
    Health = min(Health+amount, itemhealthlimit);
    if (toucher) toucher.Health = Health;
    return true; // eaten
  }
  // normal health pickup
  int plrmaxhealth = GetMaxHealth();
  //print("Health=%s; maxhealth=%s; amount=%s; accum=%s; acclimit=%s; accumon=%s", Health, plrmaxhealth, amount, k8HealthAccum_Amount, GetCvarI('k8HealthAccum_Max'), GetCvarB('k8HealthAccum_Enabled'));
  // too healthy?
  if (Health >= plrmaxhealth) {
    // accumulate everything
    if (!GetCvarB('k8HealthAccum_Enabled')) return false; // Health Accumulator is not active
    int accMax = max(0, GetCvarI('k8HealthAccum_Max'));
    if (!accMax) return false; // cannot pickup
    if (k8HealthAccum_Amount >= accMax) return false; // cannot pickup
    // do full accumulation
    // (don't bother checking, player tick will check and clamp HA amount for us)
    k8HealthAccum_Amount += amount;
    if (GetCvarB('k8HealthAccum_MessagesAccumed')) cprint("Accumulated %d health.", amount);
  } else {
    // we should heal the player, and accumulate the rest (if anything)
    int newh = min(plrmaxhealth, Health+amount);
    int relh = newh-Health;
    // accumulate leftovers
    if (relh < amount && GetCvarB('k8HealthAccum_Enabled')) {
      int accMax = max(0, GetCvarI('k8HealthAccum_Max'));
      if (accMax) {
        // (don't bother checking, player tick will check and clamp HA amount for us)
        k8HealthAccum_Amount += amount-relh;
        if (GetCvarB('k8HealthAccum_MessagesAccumed')) cprint("Accumulated %d health.", amount-relh);
      }
    }
    // heal player
    Health = newh;
    if (toucher) toucher.Health = Health;
  }
  // processed
  return true;
}


//==========================================================================
//
//  PlayerTick
//
//==========================================================================
override void PlayerTick (float deltaTime) {
  bool isBot = bIsBot;

  if (isBot) {
    if (!Level.bFrozen && !(Cheats&CF_TIMEFREEZE)) BotTick(deltaTime);
  }

  /*
  if (!MO) {
    print("playertick(%C): %f", self, deltaTime);
    print("  playertick(%C): MO=%C", self, MO);
    print("  playertick(%C): MO.XLevel=%C", self, MO.XLevel);
  }
  */

  //print("***000: BUTTONS: 0x%08x; old=0x%08x", Buttons, OldButtons);

  // Health Accumulator
  if (GetCvarB('k8HealthAccum_Enabled')) {
    // do not reset accumulator when player is dead
    if (PlayerState == PST_LIVE) {
      int accMax = GetCvarI('k8HealthAccum_Max');
      int accAmount = 0;
      if (accMax > 0) {
        //k8HealthAccum_LastRegenTime = 0;
        //k8HealthAccum_LastBoostTime = 0;
        k8HealthAccum_Amount = max(0, min(k8HealthAccum_Amount, accMax)); // sanitize
        //print("k8HealthAccum_Amount=%s; bt=%s; rt=%s; lt=%s; tb=%s; tr=%s", k8HealthAccum_Amount, MO.XLevel.Time-k8HealthAccum_LastBoostTime, MO.XLevel.Time-k8HealthAccum_LastRegenTime, MO.XLevel.Time, k8HealthAccum_LastBoostTime, k8HealthAccum_LastRegenTime);
        if (!checkDoHealthAccumBoost()) checkDoHealthAccumRegen();
      } else {
        k8HealthAccum_Amount = 0;
      }
    }
  } else {
    k8HealthAccum_Amount = 0;
  }

  if (!isBot && Level.Game.netgame && !Level.Game.deathmatch) {
    if (lastSubSector != MO.SubSector) AddSeenSubsector();
  }


  if ((MO.XLevel.TicTime%(3*35) == 0) && (Cheats&CF_REGENERATION) && Health > 0) {
    if (EntityEx(MO).GiveBody(5) && !GetSoundPlayingInfo(MO, GetSoundID('*regenerate'))) {
      MO.PlaySound('*regenerate', CHAN_VOICE);
    }
  }

  if (Actor(MO).bJustAttacked) {
    ForwardMove = 100.0;
    SideMove = 0.0;
    Actor(MO).bJustAttacked = false;
  }

  // you can only press use while totally frozen
  if (bTotallyFrozen || (Level.bFrozen && !(Cheats&CF_TIMEFREEZE))) {
    Buttons &= BT_USE;
    Impulse = 0;
    ViewAngles = MO.Angles;
    ForwardMove = 0.0;
    SideMove = 0.0;
    FlyMove = 0.0;
    ResetWeaponReloadRefire(); // no reload too
  } else if (bFrozen) {
    ForwardMove = 0.0;
    SideMove = 0.0;
    FlyMove = 0.0;
  }

  WorldTimer += deltaTime;
  InventoryTick(deltaTime);

  if (PlayerState == PST_DEAD) {
    ResetWeaponReloadRefire(); // no reload
    DeathPlayerTick(deltaTime);
    return;
  }

  if (k8ElvenGiftMessageTime <= 0) {
    k8ElvenGiftMessageTime += deltaTime;
    if (k8ElvenGiftMessageTime >= 0) {
      k8ElvenGiftMessageTime = 666;
      ShowElvenGiftMessage();
    }
  }

  if (k8BossesDetected <= 0) {
    k8BossesDetected += deltaTime;
    if (k8BossesDetected >= 0) {
      k8BossesDetected = 666;
      PerformBossDetection();
    }
  }

  // queue reload
  if (Buttons&BT_RELOAD) {
    bReloadQueued = true;
  }

  // copy view angles
  if (MO == Camera) MO.Angles = ViewAngles;

  if (JumpTime) JumpTime = fmax(0.0, JumpTime-deltaTime);

  if (MorphTime) PlayerPawn(MO).MorphPlayerThink();

  // move around
  // ReactionTime is used to prevent movement for a bit after a teleport
  if (Actor(MO).ReactionTime) {
    Actor(MO).ReactionTime -= deltaTime;
    if (Actor(MO).ReactionTime <= 0.0) Actor(MO).ReactionTime = 0.0;
    if (Actor(MO).bWaterJump) WaterJump();
  } else {
    if (MO.WaterLevel > 1) WaterMove(deltaTime); else MovePlayer(deltaTime);
    if (EntityEx(MO).FindInventory(PowerSpeed) &&
        !(Level.XLevel.TicTime&1) && Length(MO.Velocity) > 12.0*35.0)
    {
      SpawnSpeedEffect();
    }
  }

  CalcHeight(deltaTime);

  if (MO.Sector && (MO.Sector->special || MO.Sector->Damage)) PlayerInSpecialSector(deltaTime);

  PlayerOnSpecialFlat(Actor(MO).GetFloorType());
  PlayerInContents(deltaTime);

  if (MO.Velocity.z <= -35.0*35.0 && MO.Velocity.z >= -40.0*35.0 &&
      !MorphTime && MO.WaterLevel == 0 &&
      !GetSoundPlayingInfo(MO, GetSoundID('*falling')))
  {
    MO.PlaySound('*falling', CHAN_VOICE);
  }

  // check for weapon change (and other impulse commands)
  if (Impulse) PlayerImpulse();

  if (Buttons&BT_SUPERBULLET) {
    float lt = MO.XLevel.Time;
    if (lt >= k8NextSuperBulletTime) {
      k8NextSuperBulletTime = lt+GetCvarF('k8SuperBulletCooldown');
      Actor(MO).FireSuperBullet();
    }
  }

  // check for use
  if (Buttons&BT_USE) {
    if (!bUseDown) {
      EntityEx(MO).UseLines(USERANGE, USETHINGRANGE, '*usefail');
      bUseDown = true;
    }
  } else {
    //if (bUseDown) print("***USE GOES UP!");
    bUseDown = false;
  }

  if (!ReadyWeapon && PendingWeapon) {
    SetWeapon(PendingWeapon);
    BringUpWeapon();
  }

  // morph counter
  if (MorphTime) {
    if (ChickenPeck) {
      // chicken attack counter
      ChickenPeck -= 3;
    }
    MorphTime -= deltaTime;
    if (MorphTime <= 0.0) {
      // attempt to undo the chicken/pig
      MorphTime = 0.0;
      UndoPlayerMorph(false, self);
    }
  }

  // cycle psprites
  MovePsprites(deltaTime);

  // counters
  if (PoisonCount && Level.XLevel.Time-LastPoisonTime >= 0.5) {
    PoisonCount -= 5;
    if (PoisonCount < 0) PoisonCount = 0;
    LastPoisonTime = Level.XLevel.Time;
    Actor(MO).PoisonDamage(Poisoner, Poisoner, 1, true);
  }

  if (DamageFlash) {
    DamageFlash -= deltaTime;
    if (DamageFlash <= 0.0) DamageFlash = 0.0;
  }

  if (BonusFlash) {
    BonusFlash -= deltaTime;
    if (BonusFlash <= 0.0) BonusFlash = 0.0;
  }

  if (HazardTime) {
    HazardTime -= deltaTime;
    if (HazardTime <= 0.0) HazardTime = 0.0;
    if (Level.XLevel.Time-LastHazardTime >= 32.0/35.0 && HazardTime > 16.0) {
      LastHazardTime = Level.XLevel.Time;
      Actor(MO).Damage(none, none, 5/*, spawnBlood:true*/);
    }
  }

  // [RH] Zoom the player's FOV
  float desired = DesiredFOV; // default player FOV
  // adjust FOV using on the currently held weapon
  if (PlayerState != PST_DEAD && // no adjustment while dead
      ReadyWeapon && // no adjustment if no weapon
      ReadyWeapon.FOVScale != 0.0) // no adjustment if the adjustment is zero
  {
    // a negative scale is used to prevent G_AddViewAngle/G_AddViewPitch
    // from scaling with the FOV scale
    desired *= fabs(ReadyWeapon.FOVScale);
  }

  if (FOV != desired) {
    if (fabs(FOV-desired) < 7.0) {
      FOV = desired;
    } else {
      float zoom = FMax(7.0, fabs(FOV-desired)*0.025);
      if (FOV > desired) FOV = FOV-zoom; else FOV = FOV+zoom;
    }
    SetFOV(int(FOV));
  }

  if (!isBot) HealthBarProcessor();

  // flashlight code
  if (Buttons&BT_FLASHLIGHT) {
    if (!bFlashlightButtonDown) {
      bFlashlightButtonDown = true;
      bFlashlightOn = !bFlashlightOn;
    }
  } else {
    bFlashlightButtonDown = false;
  }

  // flashlight test
  if (bFlashlightOn) {
    float flradius = GetCvarF('k8_flashlight_distance');
    int flcolor = GetCvarI('k8_flashlight_color')&0xff_ff_ff;
    if (flcolor && flradius > 0) {
      TVec dir;
      AngleVector(MO.Angles, out dir);
      TVec florg = MO.Origin;
      //florg.z += MO.Height*0.5-MO.FloorClip;
      //florg.z += GetAttackZOfs();
      florg.z += ViewHeight;
      dlight_t *fl = MO.AllocDlight(MO, florg, flradius, 666);
      if (fl) {
        fl.coneDirection = dir;
        fl.coneAngle = GetCvarF('k8_flashlight_angle');
        fl.color = flcolor|0xff_00_00_00;
        fl.die = MO.XLevel.Time+(2.0/35.0);
        fl.type = DynamicLight::DLTYPE_Spot;
        //fl.minlight = 64;
        fl.bNoShadow = !GetCvarB('k8_flashlight_shadows');
        fl.bPlayerLight = true;
      }
    }
  }

#ifdef SPOTLIGHT_DISCO_TEST
  {
    DebugPutRotatingSpotlight(vector(1100, -3270, 110), 100, 512, 0xff_ff_00_00, 0);

    DebugPutRotatingSpotlight(vector(990, -2990, 68), 100, 512, 0xff_00_ff_00, 1);

    DebugPutRotatingSpotlight(vector(588, -3226, 100), 100, 512, 0xff_ff_00_00, 2);
  }
#endif
}


//==========================================================================
//
//  DebugPutRotatingSpotlight
//
//==========================================================================
final void DebugPutRotatingSpotlight (TVec florg, float speed, float flradius, int color, int id) {
  TAVec ag;
  ag.yaw = AngleMod360(MO.XLevel.Time*speed);
  TVec dir;
  AngleVector(ag, out dir);
  dlight_t *fl = MO.AllocDlight(MO, florg, flradius, 669+id);
  if (!fl) return;
  fl.coneDirection = dir;
  fl.coneAngle = 42.0f;
  fl.color = color|0xff_00_00_00;
  fl.die = MO.XLevel.Time+(2.0/35.0);
  fl.type = DynamicLight::DLTYPE_Spot;
  //fl.minlight = 64;
  fl.bNoShadow = false;
  fl.bPlayerLight = true;
}


//==========================================================================
//
//  SetViewPos
//
//  called from main world thinker after all thinkers were called
//
//==========================================================================
override void SetViewPos () {
  // just in a case camera entity has been destroyed
  if (!Camera) Camera = MO;

  if (MO != Camera) {
    // don't do any height fixes if our camera is not a player pawn
    ViewOrg = Camera.Origin;
    ViewOrg.z += EntityEx(Camera).CameraHeight;
    ViewAngles = Camera.Angles;
  } else {
    // fix camera height to avoid "lift sinking" effect
    PostfixViewHeight();

    ViewOrg.x = MO.Origin.x;
    ViewOrg.y = MO.Origin.y;

    if (LocalQuakeHappening) {
      //TODO: implement A_QuakeEx flags!
      //float intensity = float(LocalQuakeHappening);
      if (LocalQuakeHappening.x) ViewOrg.x += (Random()-0.5)*(LocalQuakeHappening.x*4.0);
      if (LocalQuakeHappening.y) ViewOrg.y += (Random()-0.5)*(LocalQuakeHappening.y*4.0);
      if (LocalQuakeHappening.z) ViewOrg.z += (Random()-0.5)*(LocalQuakeHappening.z*4.0);
    }

    if (PlayerState != PST_DEAD) {
      ViewAngles = MO.Angles;
    } else {
      ViewAngles.yaw = MO.Angles.yaw;
      ViewAngles.pitch = MO.Angles.pitch;
    }

    if (MorphTime && ChickenPeck) {
      // set chicken attack view position
      float s, c;
      sincos(MO.Angles.yaw, out s, out c);
      ViewOrg.x += float(ChickenPeck)*c;
      ViewOrg.y += float(ChickenPeck)*s;
    }
  }

  PaletteFlash();

  ClientSetViewOrg(ViewOrg.x, ViewOrg.y, ViewOrg.z);

  if (Level.XLevel.Zones.length && Camera.Sector) {
    SoundEnvironment = Level.XLevel.Zones[Camera.Sector->Zone];
  } else {
    SoundEnvironment = 0;
  }

  if (!SoundEnvironment) {
    if (Camera.WaterLevel >= 3) {
      // under water
      SoundEnvironment = 0x1600;
    } else {
      // generic
      SoundEnvironment = 1;
    }
  }
}


//==========================================================================
//
//  ClientTick
//
//==========================================================================
override void ClientTick (float deltaTime) {
  bAutoAim = !!GetCvar('autoaim');
}


//==========================================================================
//
//  AdjustPlayerAngle
//
//==========================================================================
final void AdjustPlayerAngle (EntityEx AimTarget) {
  float angle;
  float difference;

  angle = atan2(AimTarget.Origin.y-MO.Origin.y, AimTarget.Origin.x-MO.Origin.x);
  difference = AngleMod180(angle-MO.Angles.yaw);
  if (fabs(difference) > 5.0) {
    MO.Angles.yaw += difference > 0.0 ? 5.0 : -5.0;
  } else {
    MO.Angles.yaw = angle;
  }
  bFixAngle = true;
}


//==========================================================================
//
//  UndoPlayerMorph
//
//==========================================================================
final bool UndoPlayerMorph (bool Force, PlayerEx Activator) {
  Actor A;

  if (EntityEx(MO).bInvulnerable && (self != Activator || !(MorphStyle&EntityEx::MORPH_WHENINVULNERABLE))) {
    // immune when invulnerable unless this is something we initiated.
    // if the WORLD is the initiator, the same player should be given
    // as the activator; WORLD initiated actions should always succeed.
    return false;
  }

  int CorrectWeapon = MorphStyle&EntityEx::MORPH_LOSEACTUALWEAPON;

  MO.UnlinkFromWorld();
  if (BaseClass >= Level.Game.PlayerClasses.Num) Error("UndoPlayerMorph: Unknown class type");

  A = Level.Spawn(class!PlayerPawn(Level.Game.PlayerClasses[BaseClass]), MO.Origin, default, default, false);
  if (!Force && !A.TestLocation()) {
    // didn't fit
    A.Destroy();
    MO.LinkToWorld(properFloorCheck:true);
    MorphTime = 2.0;
    return false;
  }
  if (GetCvarS('player_default_gender')) A.SoundGender = name(GetCvarS('player_default_gender'));

  MO.LinkToWorld(properFloorCheck:true);
  // set color translation
  A.Translation = (Entity::TRANSL_Player<<Entity::TRANSL_TYPE_SHIFT)+GetPlayerNum();
  A.Angles = MO.Angles;
  ViewHeight = PlayerPawn(A).ViewHeight;
  DeltaViewHeight = 0.0;
  A.Player = self;
  A.bIsPlayer = true;
  A.ReactionTime = 0.5;
  if (MO.bFly) {
    A.bFly = true;
    A.bNoGravity = true;
  }
  A.bShadow = EntityEx(MO).bShadow;
  A.bGhost = EntityEx(MO).bGhost;
  A.ObtainInventory(EntityEx(MO));
  if (MO.TID && (MorphStyle&EntityEx::MORPH_NEWTIDBEHAVIOUR)) A.SetTID(MO.TID);
  MorphTime = 0.0;
  MorphStyle = 0;
  Inventory Pw = EntityEx(MO).FindInventory(PowerWeaponLevel2);
  if (Pw) Pw.Destroy();
  A.Health = GetRebornHealth();
  Health = A.Health;
  PClass = BaseClass;
  Weapon OldWeapon = ReadyWeapon;
  PostMorphWeapon(Weapon(Actor(MO).Tracer));
  if (CorrectWeapon) {
    // better "lose morphed weapon" semantics
    class!Weapon MorphWeapon = PlayerPawn(MO).MorphWeapon;
    if (MorphWeapon) {
      Weapon OrigWpn = Weapon(EntityEx(MO).FindInventory(MorphWeapon));
      if (OrigWpn && OrigWpn.bGivenAsMorphWeapon) {
        // you don't get to keep your morphed weapon
        OrigWpn.Destroy();
      }
    }
  } else {
    if (OldWeapon) OldWeapon.Destroy();
  }

  Level.Spawn(UnmorphFlash ? UnmorphFlash : class!Actor(TeleportFog),
    MO.Origin+vector(20.0*cos(MO.Angles.yaw),
    20.0*sin(MO.Angles.yaw),
    LineSpecialGameInfo(Level.Game).TeleFogHeight));

  MO.SetState(MO.FindState('FreeTargMobj'));
  MO = A;
  Camera = A;
  PlayerUnmorphed();
  return true;
}


//===========================================================================
//
//  ActivateMorphWeapon
//
//===========================================================================
final void ActivateMorphWeapon () {
  class!Weapon WpnClass = PlayerPawn(MO).MorphWeapon;
  Weapon Wpn;
  if (WpnClass) {
    Wpn = Level.Spawn(WpnClass);
    Wpn.bGivenAsMorphWeapon = true;
  } else {
    // couldn't find any weapons, use the default weapon for this player (from initial inventory)
    foreach (int i; 0..EntityEx(MO).DropItemList.Num) {
      class!Entity itc = EntityEx(MO).DropItemList[i].Type;
      if (!itc) continue;
      class!Entity itcrepl = class!Entity(GetClassReplacement(itc));
      if (itcrepl) itc = itcrepl;
      Inventory Item = Inventory(Level.Spawn(itc, default, default, default, false));
      if (EntityEx(MO).DropItemList[i].Amount > 0) {
        Item.Amount = EntityEx(MO).DropItemList[i].Amount;
      }
      if (Weapon(Item)) {
        Wpn = Weapon(Item);
        WpnClass = class!Weapon(Weapon(Item).Class);
      }
    }
  }
  if (!Wpn.TryPickup(EntityEx(MO))) Wpn.Destroy();

  SetWeapon(Weapon(EntityEx(MO).FindInventory(WpnClass)));
  SetViewObject(ReadyWeapon);
  if (ReadyWeapon) {
    ReadyWeapon.bBobDisabled = true;
    SetViewState(PS_WEAPON, ReadyWeapon.GetReadyState());
  } else {
    SetViewState(PS_WEAPON, none);
  }
  ViewStates[PS_WEAPON].SY = Weapon::WEAPONTOP;
}


//===========================================================================
//
//  PostMorphWeapon
//
//===========================================================================
final void PostMorphWeapon (Weapon weapon) {
  SetWeapon(weapon);
  ViewStates[PS_WEAPON].SY = Weapon::WEAPONBOTTOM;
  SetViewObject(ReadyWeapon);
  if (ReadyWeapon) {
    ReadyWeapon.bBobDisabled = true;
    SetViewState(PS_WEAPON, ReadyWeapon.GetUpState());
  } else {
    SetViewState(PS_WEAPON, none);
  }
}


//==========================================================================
//
//  AddVisitedMap
//
//==========================================================================
final void AddVisitedMap (name Map) {
  foreach (auto i; 0..MAX_MAPS_VISITED) {
    if (MapsVisited[i] == Map) return;
    if (!MapsVisited[i]) { MapsVisited[i] = Map; return; }
  }
}


//==========================================================================
//
//  GetMaxHealth
//
//==========================================================================
int GetMaxHealth () {
  int Max = (PlayerPawn(MO).MaxHealth > 0 ? PlayerPawn(MO).MaxHealth :
    Level.CompatDehHealth ? MAXHEALTH :
    HealthBonus.default.MaxAmount/2)+Stamina;
  if (MorphTime) {
    if (MorphStyle&EntityEx::MORPH_FULLHEALTH) {
      if (!(MorphStyle&EntityEx::MORPH_ADDSTAMINA)) Max -= Stamina;
    } else {
      Max = MAXMORPHHEALTH;
      if (MorphStyle&EntityEx::MORPH_ADDSTAMINA) Max += Stamina;
    }
  }
  return Max;
}


//==========================================================================
//
//  Cheat_Jumper
//
//==========================================================================
void Cheat_Jumper () {
  Cheats ^= CF_HIGHJUMP;
  if (Cheats&CF_HIGHJUMP) cprint("High Jump Cheat is On"); else cprint("High Jump Cheat is Off");
}


//==========================================================================
//
//  Cheat_ShooterKing
//
//==========================================================================
void Cheat_ShooterKing () {
  Cheats ^= CF_DOUBLEFIRINGSPEED;
  if (Cheats&CF_DOUBLEFIRINGSPEED) cprint("Double Firing Speed Cheat is On"); else cprint("Double Firing Speed Cheat is Off");
}


//==========================================================================
//
//  Cheat_Regeneration
//
//==========================================================================
void Cheat_Regeneration () {
  Cheats ^= CF_REGENERATION;
  if (Cheats&CF_REGENERATION) cprint("Regeneration Cheat is On"); else cprint("Regeneration Cheat is Off");
}


//==========================================================================
//
//  Cheat_Regeneration
//
//==========================================================================
void Cheat_DumpInventory () {
  print("=== inventory of player (%C : %C) ===", self, self.MO);
  for (Inventory Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory) {
    print("  %C: amount=%s", Item, Item.Amount);
  }
}


//==========================================================================
//
//  Cheat_Resurrect
//
//==========================================================================
/*
void Cheat_Resurrect () {
  cprint("Not Implemented");
}
*/


//==========================================================================
//
//  Cheat_God
//
//==========================================================================
void Cheat_God () {
  Cheats ^= CF_GODMODE;
  if (Cheats&CF_GODMODE) {
    if (LineSpecialGameInfo(Level.Game).GOD_HEALTH) {
      if (MO) MO.Health = LineSpecialGameInfo(Level.Game).GOD_HEALTH;
      Health = LineSpecialGameInfo(Level.Game).GOD_HEALTH;
      cprint("Degreelessness Mode On");
    } else {
      cprint("GOD MODE ON");
    }
  } else {
    if (LineSpecialGameInfo(Level.Game).GOD_HEALTH) {
      cprint("Degreelessness Mode Off");
    } else {
      cprint("GOD MODE OFF");
    }
  }
}


//==========================================================================
//
//  Cheat_Buddha
//
//==========================================================================
void Cheat_Buddha () {
  Cheats ^= CF_BUDDHA;
  if (Cheats&CF_BUDDHA) cprint("Buddha Mode On"); else cprint("Buddha Mode Off");
}


//==========================================================================
//
//  Cheat_Summon_AC
//
//==========================================================================
void Cheat_Summon_AC (const ref array!string args, bool newArg, out array!string aclist) {
  if (args.length == 1) {
    if (!newArg) return;
  } else if (args.length == 2) {
    if (newArg) return;
  } else {
    return;
  }

  class!Actor cls;
  foreach AllClasses(Actor, out cls) {
    // skip unspawnable actors
    class!Actor ac = class!Actor(GetClassReplacement(cls));
    if (!ac || ac != cls) continue;
    // check state
    auto spwspate = FindClassState(ac, 'Spawn');
    if (!spwspate) continue;
    if (!AreStateSpritesPresent(spwspate)) continue;
    aclist[$] = string(GetClassName(ac));
  }
}


//==========================================================================
//
//  Cheat_Summon
//
//==========================================================================
void Cheat_Summon () {
  //print("SUMMON: argc=%d", Cmd_GetArgC());
  if (!MO.bIsPlayer || !Level) return;
  auto plr = PlayerEx(MO.Player);
  if (!plr) return;

  if (Cmd_GetArgC() != 2) {
    cprint("Summon: class name expected");
    return;
  }

  // find which type to spawn
  auto moClass = class!EntityEx(FindClassNoCase(name(Cmd_GetArgV(1))));
  if (!moClass) {
    // Can't find thing type
    print("Summon: unknown class '%s'", Cmd_GetArgV(1));
    return;
  }

  //writeln("summon 0: ", GetClassName(moClass));
  auto moRepl = class!EntityEx(GetClassReplacement(moClass));
  if (moRepl) moClass = moRepl;
  //writeln("summon 1: ", GetClassName(moClass));

  auto spwspate = FindClassState(moClass, 'Spawn');

  // if actor has no spawn state, we cannot summon it
  if (!spwspate) {
    print("Summon: class '%s' has no spawn state", Cmd_GetArgV(1));
    return;
  }

  // if actor has no spawn sprites, we cannot summon it
  if (!AreStateSpritesPresent(spwspate)) {
    print("Summon: class '%s' has no frames", Cmd_GetArgV(1));
    return;
  }

  //if (Level.Game.nomonsters && moClass.default.bMonster) return;

  // spawn it
  TAVec ang = MO.Angles; //vector(plr.pitch, plr.yaw, plr.roll);
  TVec dir;
  AngleVector(ang, out dir);
  TVec dst = MO.Origin+84*dir;

  // this calls `OnMapSpawn(nullptr)` for spawned item
  Level.Spawn(moClass, dst); // optional TAVec AAngles, optional mthing_t *mthing, optional bool AllowReplace
}


//==========================================================================
//
//  Cheat_RemoveAllEntities_AC
//
//==========================================================================
void Cheat_RemoveAllEntities_AC (const ref array!string args, bool newArg, out array!string aclist) {
  if (!MO) return;

  if (args.length == 1) {
    if (!newArg) return;
  } else if (args.length == 2) {
    if (newArg) return;
  } else {
    return;
  }

  dictionary!(name, bool) classmap;

  // scan level entities
  EntityEx ent;
  foreach MO.AllThinkers(EntityEx, out ent) {
    name cname = GetClassName(ent.Class);
    if (classmap.find(cname)) continue;
    if (ent.Owner) continue;
    if (ent.bIsPlayer) continue;
    classmap.put(cname, true);
    aclist[$] = string(cname);
  }
}


//==========================================================================
//
//  Cheat_RemoveAllEntities
//
//==========================================================================
void Cheat_RemoveAllEntities () {
  if (!MO.bIsPlayer || !Level) return;
  auto plr = PlayerEx(MO.Player);
  if (!plr) return;

  if (Cmd_GetArgC() != 2) {
    cprint("RemoveAllEntities: class name expected");
    return;
  }

  name wantname = name(Cmd_GetArgV(1));

  // find which type to remove
  auto moClass = class!EntityEx(FindClassNoCase(wantname));
  if (!moClass) {
    // Can't find thing type
    print("RemoveAllEntities: unknown class '%s'", Cmd_GetArgV(1));
    return;
  }

  array!EntityEx elist;

  EntityEx ent;
  foreach MO.AllThinkers(EntityEx, out ent) {
    name cname = GetClassName(ent.Class);
    if (nameicmp(cname, wantname) != 0) continue;
    if (ent.Owner) continue;
    if (ent.bIsPlayer) continue;
    elist[$] = ent;
  }

  if (elist.length == 0) {
    print("RemoveAllEntities: no entities of class '%s' found", wantname);
  } else {
    foreach (EntityEx e; elist) delete e;
    print("RemoveAllEntities: %s %s of class '%s' removed", elist.length, (elist.length != 1 ? "entities" : "entity"), wantname);
  }
}


//==========================================================================
//
//  Cheat_CountEntities_AC
//
//==========================================================================
void Cheat_CountEntities_AC (const ref array!string args, bool newArg, out array!string aclist) {
  if (!MO) return;

  if (args.length == 1) {
    if (!newArg) return;
  } else if (args.length == 2) {
    if (newArg) return;
  } else {
    return;
  }

  dictionary!(name, bool) classmap;

  // scan level entities
  EntityEx ent;
  foreach MO.AllThinkers(EntityEx, out ent) {
    name cname = GetClassName(ent.Class);
    if (classmap.find(cname)) continue;
    if (ent.Owner) continue;
    if (ent.bIsPlayer) continue;
    classmap.put(cname, true);
    aclist[$] = string(cname);
  }
}


//==========================================================================
//
//  Cheat_CountEntities
//
//==========================================================================
void Cheat_CountEntities () {
  if (!MO.bIsPlayer || !Level) return;
  auto plr = PlayerEx(MO.Player);
  if (!plr) return;

  if (Cmd_GetArgC() != 2) {
    cprint("CountEntities: class name expected");
    return;
  }

  name wantname = name(Cmd_GetArgV(1));

  // find which type to remove
  auto moClass = class!EntityEx(FindClassNoCase(wantname));
  if (!moClass) {
    // Can't find thing type
    print("CountEntities: unknown class '%s'", Cmd_GetArgV(1));
    return;
  }

  int count = 0;

  EntityEx ent;
  foreach MO.AllThinkers(EntityEx, out ent) {
    name cname = GetClassName(ent.Class);
    if (nameicmp(cname, wantname) != 0) continue;
    if (ent.Owner) continue;
    if (ent.bIsPlayer) continue;
    ++count;
  }

  if (count == 0) {
    print("CountEntities: no entities of class '%s' found", wantname);
  } else {
    print("CountEntities: %s %s of class '%s' found", count, (count != 1 ? "entities" : "entity"), wantname);
  }
}


//==========================================================================
//
//  Cheat_NoClip
//
//==========================================================================
void Cheat_NoClip () {
  Cheats ^= CF_NOCLIP;
  if (Cheats&CF_NOCLIP) {
    MO.bColideWithThings = false;
    MO.bColideWithWorld = false;
    cprint("No Clipping Mode ON");
  } else {
    MO.bColideWithThings = true;
    MO.bColideWithWorld = true;
    cprint("No Clipping Mode OFF");
  }
}


//==========================================================================
//
//  Cheat_KillAll
//
//==========================================================================
void Cheat_KillAll () {
  cprint("%d MONSTERS KILLED", LineSpecialLevelInfo(Level).P_Massacre());
}


//==========================================================================
//
//  Cheat_NoWeapons
//
//==========================================================================
void Cheat_NoWeapons () {
  if (MorphTime) return;

  // find weakest weapon
  Inventory Item;
  Weapon Weakest = none;
  for (Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory) {
    if (Weapon(Item) && (!Weakest || Weakest.SelectionOrder < Weapon(Item).SelectionOrder)) {
      Weakest = Weapon(Item);
    }
  }

  // removed all others
  for (Item = EntityEx(MO).Inventory; Item; ) {
    Inventory Next = Item.Inventory;
    if ((Weapon(Item) && Item != Weakest) || FourthWeaponHolder(Item)) {
      Item.Destroy();
    }
    Item = Next;
  }
  SetWeapon(Weakest);
  PendingWeapon = none; //Weakest;
  if (Weakest) Weakest.bBobDisabled = true;

  cprint("CHEATER-YOU DON'T DESERVE WEAPONS");
}


//==========================================================================
//
//  Cheat_Fly
//
//==========================================================================
void Cheat_Fly () {
  if (!bFly) {
    bFly = true;
    MO.bFly = true;
    MO.bNoGravity = true;
    if (MO.Origin.z <= MO.FloorZ) {
      // thrust the player in the air a bit
      FlyHeight = 10.0;
    }
    if (MO.Velocity.z <= -35.0*35.0) {
      // stop falling scream
      MO.StopSound(CHAN_VOICE);
    }
    cprint("You feel lighter");
  } else {
    if (MO.Origin.z != MO.FloorZ) {
      //FIXME: player->centreing = true;
    }
    bFly = false;
    MO.bFly = false;
    MO.bNoGravity = false;
    cprint("Gravity weights you down");
  }
}


//==========================================================================
//
//  Cheat_NoTarget
//
//==========================================================================
void Cheat_NoTarget () {
  bNoTarget = !bNoTarget;
  if (bNoTarget) {
    cprint("No Target Mode ON");
  } else {
    cprint("No Target Mode OFF");
  }
}


//==========================================================================
//
//  Cheat_Anubis
//
//==========================================================================
void Cheat_Anubis () {
  Cheats ^= CF_FRIGHTENING;
  if (Cheats&CF_FRIGHTENING) {
    cprint("\"Quake with fear!\"");
  } else {
    cprint("No more ogre armor");
  }
}


//==========================================================================
//
//  Cheat_Freeze
//
//==========================================================================
void Cheat_Freeze () {
  Cheats ^= CF_TIMEFREEZE;
  if (Cheats&CF_TIMEFREEZE) {
    cprint("Freeze mode on");
    Level.bFrozen = true;
  } else {
    cprint("Freeze mode off");
    Level.bFrozen = false;
  }
}


//==========================================================================
//
//  Cheat_WarpTo
//
//==========================================================================
void Cheat_WarpTo () {
  if (!MO.bIsPlayer || !Level || !EntityEx(MO)) return;

  if (Cmd_GetArgC() < 3 || Cmd_GetArgC() > 4) {
    cprint("WarpTo: x y [z]");
    return;
  }

  bool err;

  float x = atof(Cmd_GetArgV(1), out err);
  if (err) { cprint("WarpTo: invalid x coord (%s)", Cmd_GetArgV(1)); return; }

  float y = atof(Cmd_GetArgV(2), out err);
  if (err) { cprint("WarpTo: invalid y coord (%s)", Cmd_GetArgV(2)); return; }

  float z = EntityEx::ONFLOORZ;
  if (Cmd_GetArgC() > 3) {
    z = atof(Cmd_GetArgV(3), out err);
    if (err) { cprint("WarpTo: invalid z coord (%s)", Cmd_GetArgV(3)); return; }
  }

  if (EntityEx(MO).Teleport(vector(x, y, z), MO.Angles.yaw, DstFog:false, SrcFog:false, KeepDir:true, ForceTelestomp:true)) {
    if (Cmd_GetArgC() > 3) {
      cprint("Teleported to (%s,%s,%s)", x, y, z);
    } else {
      cprint("Teleported to (%s,%s)", x, y);
    }
  }
}


//==========================================================================
//
//  Cheat_MapHash
//
//==========================================================================
void Cheat_MapHash () {
  if (Cmd_GetArgC() > 1 && stricmp(Cmd_GetArgV(1), "sha224") == 0) {
    print("MAP SHA224: %s", Level.XLevel.MapHash);
  } else {
    print("MAP MD5: %s", Level.XLevel.MapHashMD5);
  }
}


//==========================================================================
//
//  Cheat_MapHash_AC
//
//==========================================================================
void Cheat_MapHash_AC (const ref array!string args, bool newArg, out array!string aclist) {
  if (args.length == 1) {
    if (!newArg) return;
  } else if (args.length == 2) {
    if (newArg) return;
  } else {
    return;
  }

  aclist[$] = "sha224";
}


//==========================================================================
//
//  CheckFriendlyFire
//
//  TODO
//
//==========================================================================
bool CheckFriendlyFire (EntityEx source, int damage) {
  return false;
}


//==========================================================================
//
//  IsWeaponAlwaysExtremeDeath
//
//  TODO
//
//==========================================================================
bool IsWeaponAlwaysExtremeDeath () {
  return false;
}


//==========================================================================
//
//  SetFOV
//
//  Zoom the player's FOV
//
//==========================================================================
final void SetFOV (int New_FOV) {
  SetCvar('FOV', New_FOV);
}


//==========================================================================
//
//  StartDeathSlideShow
//
//==========================================================================
void StartDeathSlideShow () {
}


//==========================================================================
//
//  GotAmmo
//
//==========================================================================
void GotAmmo (Ammo NewAmmo) {
}


//==========================================================================
//
//  Damaged
//
//==========================================================================
void Damaged (EntityEx inflictor) {
}


//==========================================================================
//
//  KilledActor
//
//==========================================================================
void KilledActor (EntityEx Victim) {
}


//==========================================================================
//
//  Killed
//
//==========================================================================
void Killed (EntityEx source, EntityEx inflictor) {
}


//==========================================================================
//
//  GetSigilPieces
//
//==========================================================================
int GetSigilPieces () {
  return 0;
}


//==========================================================================
//
//  PlayerMorphed
//
//==========================================================================
void PlayerMorphed (EntityEx OldMO) {
}


//==========================================================================
//
//  CreateBot
//
//==========================================================================
void CreateBot () {
}


//==========================================================================
//
//  OnNetReborn
//
//==========================================================================
void OnNetReborn (EntityEx OldMO) {
}


//==========================================================================
//
//  DestroyBot
//
//==========================================================================
void DestroyBot () {
}


//==========================================================================
//
//  BotOnSpawn
//
//==========================================================================
void BotOnSpawn () {
}


//==========================================================================
//
//  BotSendSubSectorChange
//
//==========================================================================
void BotSendSubSectorChange (subsector_t *ss) {
}


//==========================================================================
//
//  SetClientModel
//
//==========================================================================
void SetClientModel () {
}


//==========================================================================
//
//  GetRebornHealth
//
//==========================================================================
int GetRebornHealth () {
  return 0;
}


//==========================================================================
//
//  BotTick
//
//==========================================================================
void BotTick (float deltaTime) {
}


//==========================================================================
//
//  SpawnSpeedEffect
//
//==========================================================================
void SpawnSpeedEffect () {
}


//==========================================================================
//
//  PlayerImpulse
//
//  return `true` if impulse was eaten
//
//==========================================================================
void PlayerImpulse () {
  if (!Impulse) return;

  if (Impulse <= PlayerPawn::NUM_WEAPON_SLOTS) { ChangeWeapon(Impulse); Impulse = 0; return; }

  switch (Impulse) {
    case 13: InventoryLeft(); Impulse = 0; return;
    case 14: InventoryRight(); Impulse = 0; return;
    case 15: InventoryUse(); Impulse = 0; return;
    case 16: Actor(MO).Damage(none, none, 10000); Impulse = 0; return;
    case 17: PrevWeapon(); Impulse = 0; return;
    case 18: NextWeapon(); Impulse = 0; return;
    case 43: Actor(MO).FireSuperBullet(); Impulse = 0; return;
    case 56: bReloadQueued = true; Impulse = 0; return; // so you can use this in aliases and such
    case 142: Actor(MO).DebugCheckMidTex(); Impulse = 0; return;
    case 149: bFlashlightOn = !bFlashlightOn; Impulse = 0; return; // so you can use this in aliases and such
    case 155:
      foreach (auto pidx; 0..MAXPLAYERS) {
        PlayerEx plr = PlayerEx(Level.Game.Players[pidx]);
        if (!plr || !plr.bIsBot) continue;
        plr.BotDumpNodes();
      }
      Impulse = 0;
      return;
    case 156:
      if (MO) {
        foreach (auto pidx; 0..MAXPLAYERS) {
          PlayerEx plr = PlayerEx(Level.Game.Players[pidx]);
          if (!plr || !plr.bIsBot) continue;
          plr.BotTestFindPathTo(MO.Origin);
        }
      }
      Impulse = 0;
      return;
  }

  if (Impulse >= 200 && Impulse <= 205) {
    LineSpecialLevelInfo(Level).ConChoiceImpulse(Impulse-200); // strife does additional processing
    Impulse = 0;
    return;
  }
}


//==========================================================================
//
//  PlayerUnmorphed
//
//==========================================================================
void PlayerUnmorphed () {
}


//==========================================================================
//
//  Cheat_VScriptCommand
//
//==========================================================================
override void Cheat_VScriptCommand (ref array!string args) {
  //print("VScript Command: %s (%d)", args[0], args.length);
  if (!args.length) return;
  if (args[0] == "?") {
    print("give what [amount] -- give inventory item");
    print("take what [amount] -- take inventory item");
    print("drop what          -- drop inventory item");
    print("fire mtp [ofs]     -- fire missile");
    print("apts type          -- get armor points for type");
    return;
  }

  if (args.length < 2) return;

  if (args[0] == "fire") {
    class!Actor mt = class!Actor(GetClassReplacement(FindClassNoCase(name(args[1]))));
    if (!mt) { print("actor '%s' not found", args[1]); return; }
    float ofs = 4;
    if (args.length > 2) ofs = atof(args[2]);
    //Actor(MO).A_CustomMissile(mt, MO.Height/2, 0, AimMode:2);
    float hgt = MO.Height/2;
    TVec Offs = ofs*vector(cos(MO.Angles.yaw), sin(MO.Angles.yaw), 0.0);
    MO.Origin += Offs;
    EntityEx A = Actor(MO).SpawnMissileAngles(mt, MO.Angles.yaw, MO.Angles.pitch, hgt);
    MO.Origin -= Offs;
    return;
  }

  // find inventory class
  class!Inventory icls = class!Inventory(FindClassNoCase(name(args[1])));
  if (!icls) { print("what is '%s'?", args[1]); return; }

  int amount = 0;
  if (args.length > 2) amount = atoi(args[2]);

  Inventory invit = EntityEx(MO).FindInventory(icls);

  if (args[0] == "give") {
    if (!invit) {
      // no item in inventory, give one
      class!Inventory irepl = class!Inventory(GetClassReplacement(icls));
      if (irepl) icls = irepl;
      invit = Inventory(EntityEx(MO).Spawn(icls, default, default, default, false));
      // this shouldn't count for the item statistics
      if (invit.bCountItem) {
        invit.bCountItem = false;
        --Level.TotalItems;
      }
      auto git = invit.TryPickup(EntityEx(MO));
      if (!git) {
        delete invit;
        print("refused to get '%C'", icls);
        return;
      }
      if (amount <= 0) return;
      invit = EntityEx(MO).FindInventory(icls);
      if (!invit) return;
    }
    auto oldam = invit.Amount;
    invit.Amount = min(oldam+amount, invit.MaxAmount);
    if (invit.Amount != oldam) {
      print("you got %d of '%C'", invit.Amount-oldam, invit);
    } else {
      print("you already have maximum of '%C'", invit);
    }
    return;
  }

  if (args[0] == "take") {
    if (!invit) { print("you don't have '%C'", icls); return; }
    if (amount <= 0) amount = 1;
    auto newam = invit.Amount-amount;
    if (newam <= 0) {
      EntityEx(MO).RemoveInventory(invit);
      print("you lost '%C'", invit);
    } else {
      invit.Amount = newam;
      print("you lost %d of '%C'", amount, invit);
    }
    return;
  }

  if (args[0] == "drop") {
    if (!invit) { print("you don't have '%C'", icls); return; }
    TVec dir = vector(cos(MO.Angles.yaw), sin(MO.Angles.yaw))*64;
    dir.z = MO.Height/2;
    auto it = Inventory(EntityEx(MO).DropItem(icls, max(0, amount), 1.0, dropofs:dir));
    if (it) {
      print("dropped '%C'", icls);
      it.Velocity = vector(0, 0, 0);
      it.Amount = invit.Amount;
      it.MaxAmount = invit.MaxAmount;
      EntityEx(MO).RemoveInventory(invit);
    }
    return;
  }

  if (args[0] == "apts") {
    int pts = MO.GetArmorPointsForType(name(args[1]));
    print("points for armor type '%s': %s", args[1], pts);
    return;
  }
}


//==========================================================================
//
//  eventGetReadyWeapon
//
//==========================================================================
override Entity eventGetReadyWeapon () {
  return ReadyWeapon;
}


defaultproperties {
  InvSize = 6;
  PrevViewHeight = -666;
}
