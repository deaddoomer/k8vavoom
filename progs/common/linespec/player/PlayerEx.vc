//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
class PlayerEx : BasePlayer abstract;

// player internal flags, for cheats and debug
enum /*cheat_t*/ {
  CF_NOCLIP            = 1<<0, // No clipping, walk through barriers.
  CF_GODMODE           = 1<<1, // No damage, no health loss.
  CF_REGENERATION      = 1<<2, // Regenerate Health points.
  CF_FRIGHTENING       = 1<<3, // Scare monsters away.
  CF_DOUBLEFIRINGSPEED = 1<<4, // Player owns a double firing speed artifact
  CF_HIGHJUMP          = 1<<5, // Player owns a high jump artifact
  CF_TIMEFREEZE        = 1<<6, // Player owns a time freeze artifact
  CF_BUDDHA            = 1<<7, // Normal play, but never looses last 1% of health
};

const float USERANGE      = 64.0;
const float USETHINGRANGE = 128.0;

const float BLINKTHRESHOLD = 4.0;

// 16 pixels of bob
const float MAXBOB = 16.0;

const int MAXHEALTH      = 100;
const int MAXMORPHHEALTH = 30;

// for screen flashing (red or bright)
float DamageFlash;
float BonusFlash;

// base height above floor for viewz
float ViewHeight;
// bob/squat speed
float DeltaViewHeight;
// bounded/scaled total momentum
float Bob;

// who did damage (none for floors/ceilings)
EntityEx Attacker;

float JumpTime;
int LocalQuakeHappening;

TVec MoveDir;

float LastSectorDamageTime;

float HazardTime;
float LastHazardTime;

// bit flags, for cheats and debug
// see cheat_t above
int Cheats;

Weapon ReadyWeapon;
Weapon PendingWeapon; // is none if not changing

// refired shots are less accurate (this is counter)
int Refire;

float FlyHeight;

array!name RevealedMaps;

Inventory InvFirst;
Inventory InvPtr;
float InventoryTime;
int ArtifactFlash;
int InvSize;

Inventory SavedInventory;

bool onground;

bool bRevertCamera; // revert camera if player moves
bool bFrozen; // player cannot move
bool bTotallyFrozen; // player cannot do anything except press use
bool bNoTarget; // monster don't target
bool bInstantWeaponSwitch; // switch weapons instantly
bool bFly; // player is flying
bool bInventoryAlwaysOpen; // inventory bar is always open
bool bAutoAim; // auto aiming enabled? (weapon can override this)

int PoisonCount; // screen flash for poison damage
float LastPoisonTime;
EntityEx Poisoner; // none for non-player mobjs
PlayerEx PoisonerPlayer; // for KArena

int Objectives;

float MorphTime; // player is morphed into something if > 0
int MorphStyle;
class!Actor UnmorphFlash;

int Accuracy;
int Stamina;

float BlendR;
float BlendG;
float BlendB;
float BlendA;

int ChickenPeck; // chicken peck countdown

Actor Rain1; // active rain maker 1
Actor Rain2; // active rain maker 2

const int MAX_MAPS_VISITED = 100;

name MapsVisited[MAX_MAPS_VISITED];

float FOV; // current Field Of Vision
float DesiredFOV; // desired Field Of Vision

bool k8ElvenGifted;

// Health Accumulator
// if you want to show HA info in UI, replicate those vars
int k8HealthAccum_Amount; // amount of currently accumulated health
float k8HealthAccum_LastRegenTime = -10000;
float k8HealthAccum_LastBoostTime = -10000;


replication {
  reliable if (!bIsClient)
    Cheats, ReadyWeapon, InvFirst, InvPtr, InventoryTime, ArtifactFlash,
    Objectives, MorphTime, Accuracy, Stamina, MapsVisited, DamageFlash,
    BonusFlash, Attacker, bFrozen, bTotallyFrozen, DesiredFOV, FOV;

  unreliable if (!bIsClient)
    ParticleEffect, ClientExplosion, ClientParticleExplosion,
    ClientSparkParticles, ClientRailTrail, DecalEffect,
    // we need this to update UI, but this is not vital info
    k8HealthAccum_Amount, k8HealthAccum_LastRegenTime, k8HealthAccum_LastBoostTime;

  reliable if (!bIsClient)
    ClientVoice, ClientSpeech, ClientFinaleType, ClientSlideshow1,
    ClientSlideshow2, SetFOV;

  reliable if (bIsClient)
    bAutoAim;
}


//==========================================================================
//
//  ThrustPlayer
//
//  Moves the given origin along a given angle.
//
//==========================================================================
final void ThrustPlayer (float angle, float move, float deltaTime) {
  if ((!EntityEx(MO).FindInventory(PowerFlight) || MO.Origin.z <= MO.FloorZ) &&
      ((EntityEx(MO).GetFloorType()->Friction &&
        EntityEx(MO).GetFloorType()->Friction < EntityEx::FRICTION_NORMAL) ||
      (MO.Sector->special&SECSPEC_BASE_MASK) == SECSPEC_FrictionLow))
  {
    move *= LineSpecialGameInfo(Level.Game).IceMoveFactor;
  }
  MO.Velocity.x += move*cos(angle)*deltaTime;
  MO.Velocity.y += move*sin(angle)*deltaTime;
}


//==========================================================================
//
//  CalcHeight
//
//  Calculate the walking / running height adjustment
//
//==========================================================================
final void CalcHeight (float deltaTime) {
  float bob = GetCvarF('movebob');

  if (bob > 0) {
    // regular movement bobbing
    // (needs to be calculated for gun swing even if not on ground)
    if (MO.bFly && !onground) {
      Bob = 0.5;
    } else {
      if (bob > 1) bob = 1;
      Bob = MO.Velocity.x*MO.Velocity.x+MO.Velocity.y*MO.Velocity.y;
      Bob /= (1.0/bob)*35.0*35.0;
      if (Bob > MAXBOB) Bob = MAXBOB;
    }
  }

  float angle = 180.0*35.0/10.0*Level.XLevel.Time;
  bob = Bob/2.0*sin(angle);

  // move viewheight
  if (PlayerState == PST_LIVE) {
    ViewHeight += DeltaViewHeight*deltaTime;

    if (ViewHeight > PlayerPawn(MO).ViewHeight) {
      ViewHeight = PlayerPawn(MO).ViewHeight;
      DeltaViewHeight = 0.0;
    }

    if (ViewHeight < PlayerPawn(MO).ViewHeight/2.0) {
      ViewHeight = PlayerPawn(MO).ViewHeight/2.0;
      if (DeltaViewHeight <= 0.0) DeltaViewHeight = 0.00001;
    }

    if (DeltaViewHeight) {
      DeltaViewHeight += 256.0*deltaTime;
      if (!DeltaViewHeight) DeltaViewHeight = 0.00001;
    }
  }
  ViewOrg.z = MO.Origin.z+ViewHeight+bob;

  if (PlayerState != PST_DEAD && MO.Origin.z <= MO.FloorZ) ViewOrg.z -= MO.FloorClip;
  if (ViewOrg.z < MO.FloorZ+4.0) ViewOrg.z = MO.FloorZ+4.0;
  if (ViewOrg.z > MO.CeilingZ-4.0) ViewOrg.z = MO.CeilingZ-4.0;
}


//==========================================================================
//
//  CrouchMove
//
//==========================================================================
void CrouchMove (int direction) {
  auto plr = EntityEx(MO);
  if (!plr) return;

  //float defaultheight = FullHeight;
  float crouchspeed = direction*EntityEx::CROUCHSPEED;

  float newcrf = fclamp(plr.crouchfactor+crouchspeed, 0.5, 1.0);
  if (newcrf == plr.crouchfactor) return; // nothing to do

  // check whether the move is ok
  float savedheight = plr.Height;
  plr.Height = plr.default.Height*newcrf;
  if (!plr.TryMove(plr.Origin, false)) {
    // nope, restore player height
    plr.Height = savedheight;
    return;
  }

  // setup new view height, and remember current crouch factor
  ViewHeight = PlayerPawn(plr).default.ViewHeight*newcrf;
  plr.crouchfactor = newcrf;

  // check for eyes going above/below fake floor due to crouching motion
  // this seems to be done in TryMove
  //FIXME
  //TODO
  //CheckFakeFloorTriggers(pos.Z + oldheight, true);
}


//==========================================================================
//
//  MovePlayer
//
//==========================================================================
final void MovePlayer (float deltaTime) {
  float forward;
  float side;
  float fly;

  // do not let the player control movement if not onground
  onground = (MO.Origin.z <= MO.FloorZ || EntityEx(MO).bOnMobj);

  forward = ForwardMove*5.0;
  side = SideMove*5.0;

  PlayerPawn(MO).AdjustSpeed(forward, side);

  if (!onground && !MO.bNoGravity && !MO.WaterLevel) {
    // not on ground, so we have little effect on velocity
    forward *= Level.AirControl;
    side *= Level.AirControl;
  }

  if (forward) ThrustPlayer(MO.Angles.yaw, forward, deltaTime);
  if (side) ThrustPlayer(AngleMod360(MO.Angles.yaw-90.0), side, deltaTime);

  if (forward || side) {
    SetPlayerRunState();
    if (bRevertCamera) {
      Camera = MO;
      bRevertCamera = false;
    }
  }

  fly = FlyMove/16.0;
  if (fly && (EntityEx(MO).FindInventory(PowerFlight) || bFly)) {
    if (FlyMove != TOCENTRE) {
      FlyHeight = fly*2.0;
      if (!MO.bFly) {
        MO.bFly = true;
        MO.bNoGravity = true;
        if (MO.Velocity.z <= -39.0*35.0) {
          // stop falling scream
          MO.StopSound(CHAN_VOICE);
        }
      }
    } else {
      MO.bFly = false;
      MO.bNoGravity = false;
    }
  } else if (fly > 0.0) {
    UseFlyPower();
  }

  if (MO.bFly) {
    MO.Velocity.z = FlyHeight*35.0;
    if (FlyHeight) FlyHeight /= 2.0;
  }

  if ((Buttons&BT_JUMP) && onground && !JumpTime) {
    if (Cheats&CF_HIGHJUMP) {
      MO.Velocity.z = (PlayerPawn(MO).JumpVelZ*2.0)*1.1;
    } else {
      MO.Velocity.z = PlayerPawn(MO).JumpVelZ*1.1;
    }
    EntityEx(MO).bOnMobj = false;
    JumpTime = 0.5;
  }

  auto ohgt = MO.Height;
  CrouchMove(Buttons&BT_CROUCH ? -1 : 1);
  //print("HEIGHT: %s  %s  crf=%s; vh=%s; dvh=%s", ohgt, MO.Height, EntityEx(MO).crouchfactor, ViewHeight, PlayerPawn(MO).default.ViewHeight);
}


//==========================================================================
//
//  CheckWaterJump
//
//==========================================================================
final void CheckWaterJump () {
  TVec start;
  TVec end;
  TVec vforward;
  TVec HitPoint;
  TVec HitNormal;

  // check for a jump-out-of-water
  AngleVector(MO.Angles, out vforward);
  start = MO.Origin;
  start.z += MO.Height*0.5+8.0;
  vforward.z = 0.0;
  vforward = Normalise(vforward);
  end = start+vforward*24.0;
  if (!Level.XLevel.TraceLine(start, end, HitPoint, HitNormal)) {
    // solid at waist
    start.z = MO.Origin.z+MO.Height;
    end = start+vforward*24.0;
    MoveDir = HitNormal*-50.0;
    if (Level.XLevel.TraceLine(start, end, HitPoint, HitNormal)) {
      // open at eye level
      EntityEx(MO).bWaterJump = true;
      MO.Velocity.z = 350.0;
      EntityEx(MO).ReactionTime = 2.0; // safety net
    }
  }
}


//==========================================================================
//
//  WaterMove
//
//==========================================================================
final void WaterMove (float deltaTime) {
  float forward;
  float side;
  TVec vforward;
  TVec vright;
  TVec vup;
  TVec wishvel;

  // do not let the player control movement if not onground
  onground = (MO.Origin.z <= MO.FloorZ) || EntityEx(MO).bOnMobj;

  AngleVectors(MO.Angles, out vforward, out vright, out vup);

  forward = ForwardMove;
  side = SideMove;

  PlayerPawn(MO).AdjustSpeed(forward, side);

  wishvel = vforward*forward+vright*side;
  if (!forward && !side /*&& !cmd.upmove*/) wishvel.z -= 60.0; // drift towards bottom
  //else wishvel.z += cmd.upmove;

  MO.Velocity += 3.5*deltaTime*wishvel;

  if (forward || side) SetPlayerRunState();

  if (Buttons&BT_JUMP) {
         if (MO.WaterType == CONTENTS_WATER) MO.Velocity.z = 100.0;
    else if (MO.WaterType == CONTENTS_NUKAGE || MO.WaterType == CONTENTS_SLIME || MO.WaterType == CONTENTS_SLUDGE) MO.Velocity.z = 80.0;
    else MO.Velocity.z = 50.0;
  }
  CheckWaterJump();
}


//==========================================================================
//
//  WaterJump
//
//==========================================================================
final void WaterJump () {
  if (!EntityEx(MO).ReactionTime || !MO.WaterLevel) {
    EntityEx(MO).bWaterJump = false;
    EntityEx(MO).ReactionTime = 0.0;
  }
  MO.Velocity.x = MoveDir.x;
  MO.Velocity.y = MoveDir.y;
}


//==========================================================================
//
//  PlayerInSpecialSector
//
//  Called every tic frame that the player origin is in a special sector.
//
//==========================================================================
final void PlayerInSpecialSector (float deltaTime) {
  float speed;
  float finean;

  if (MO.Origin.z != GetPlanePointZ(ref MO.Sector->floor, MO.Origin) && !MO.WaterLevel) {
    // player is not touching the floor
    return;
  }

  if (MO.Sector->special&SECSPEC_SECRET_MASK) {
    // secret area
    ++SecretCount;
    ++Level.CurrentSecret;
    MO.Sector->special &= ~SECSPEC_SECRET_MASK;
    centreprint("You found a secret area");
    MO.PlaySound('misc/secret', CHAN_VOICE);
  }

  // search for iron feet power: any subclass will do
  Inventory IronFeet = EntityEx(MO).Inventory;
  while (IronFeet) {
    if (PowerIronFeet(IronFeet)) break;
    IronFeet = IronFeet.Inventory;
  }

  if (MO.Sector->special >= SECSPEC_LightFlicker && MO.Sector->special <= 255) {
    switch (MO.Sector->special) {
      case SECSPEC_DamageHellslime:
        if (!IronFeet && Level.XLevel.Time-LastSectorDamageTime >= 32.0/35.0) {
          LastSectorDamageTime = Level.XLevel.Time;
          EntityEx(MO).Damage(none, none, 10, 'Slime');
        }
        break;
      case SECSPEC_DamageSludge:
        if (!IronFeet && Level.XLevel.Time-LastSectorDamageTime >= 32.0/35.0) {
          LastSectorDamageTime = Level.XLevel.Time;
          EntityEx(MO).Damage(none, none, 4);
        }
        break;
      case SECSPEC_DamageNukage:
        if (!IronFeet && Level.XLevel.Time-LastSectorDamageTime >= 32.0/35.0) {
          LastSectorDamageTime = Level.XLevel.Time;
          EntityEx(MO).Damage(none, none, 5, 'Slime');
        }
        break;
      case SECSPEC_LightStrobeFastDamage:
      case SECSPEC_DamageSuperHellslime:
        if (!IronFeet || (P_Random() < 5 && P_Random() < 5)) {
          if (Level.XLevel.Time-LastSectorDamageTime >= 32.0/35.0) {
            LastSectorDamageTime = Level.XLevel.Time;
            EntityEx(MO).Damage(none, none, 20, 'Slime');
          }
        }
        break;
      case SECSPEC_DamageSuperHellslimeExit:
        // EXIT SUPER DAMAGE! (for E1M8 finale)
        Cheats &= ~CF_GODMODE;
        if (Level.XLevel.Time-LastSectorDamageTime >= 32.0/35.0) {
          LastSectorDamageTime = Level.XLevel.Time;
          EntityEx(MO).Damage(none, none, 20);
        }
        if (Health <= 10) Level.ExitLevel(0);
        break;
      case SECSPEC_DamageLavaWimpy:
        if (Level.XLevel.Time-LastSectorDamageTime >= 16.0/35.0) {
          LastSectorDamageTime = Level.XLevel.Time;
          EntityEx(MO).Damage(none, none, 5, 'Fire');
          EntityEx(MO).HitFloorType();
        }
        break;
      case SECSPEC_DamageLavaHefty:
        if (Level.XLevel.Time-LastSectorDamageTime >= 16.0/35.0) {
          LastSectorDamageTime = Level.XLevel.Time;
          EntityEx(MO).Damage(none, none, 8, 'Fire');
          EntityEx(MO).HitFloorType();
        }
        break;
      case SECSPEC_ScrollEastLavaDamage:
        ThrustPlayer(0.0, 1024.0, deltaTime);
        if (Level.XLevel.Time-LastSectorDamageTime >= 16.0/35.0) {
          LastSectorDamageTime = Level.XLevel.Time;
          EntityEx(MO).Damage(none, none, 5, 'Fire');
          EntityEx(MO).HitFloorType();
        }
        break;
      case SECSPEC_DamageHazard:
        if (!IronFeet) HazardTime += 2.0*deltaTime;
        break;
      case SECSPEC_DamageInstantDeath:
        EntityEx(MO).Damage(none, none, 999, 'InstantDeath');
        break;
      case SECSPEC_DamageSuperHazard:
        if (!IronFeet) HazardTime += 4.0*deltaTime;
        break;
    }
  } else {
    // extended sector damage type
    switch (MO.Sector->special&SECSPEC_DAMAGE_MASK) {
      case 0x0100:
        if (!IronFeet && Level.XLevel.Time-LastSectorDamageTime >= 32.0/35.0) {
          LastSectorDamageTime = Level.XLevel.Time;
          EntityEx(MO).Damage(none, none, 5, 'Fire');
        }
        break;
      case 0x0200:
        if (!IronFeet && Level.XLevel.Time-LastSectorDamageTime >= 32.0/35.0) {
          LastSectorDamageTime = Level.XLevel.Time;
          EntityEx(MO).Damage(none, none, 10, 'Slime');
        }
        break;
      case 0x0300:
        if (!IronFeet || (P_Random() < 5 && P_Random() < 5)) {
          if (Level.XLevel.Time-LastSectorDamageTime >= 32.0/35.0) {
            LastSectorDamageTime = Level.XLevel.Time;
            EntityEx(MO).Damage(none, none, 20, 'Slime');
          }
        }
        break;
    }
  }

  // apply any customizable damage
  if (MO.Sector->Damage) {
    if (MO.Sector->Damage < 20) {
      if (!IronFeet && Level.XLevel.Time-LastSectorDamageTime >= 32.0/35.0) {
        LastSectorDamageTime = Level.XLevel.Time;
        EntityEx(MO).Damage(none, none, MO.Sector->Damage);
      }
    } else if (MO.Sector->Damage < 50) {
      if (!IronFeet || (P_Random() < 5 && P_Random() < 5)) {
        if (Level.XLevel.Time-LastSectorDamageTime >= 32.0/35.0) {
          LastSectorDamageTime = Level.XLevel.Time;
          EntityEx(MO).Damage(none, none, MO.Sector->Damage);
        }
      }
    } else if (Level.XLevel.Time-LastSectorDamageTime >= 1.0/35.0) {
      LastSectorDamageTime = Level.XLevel.Time;
      EntityEx(MO).Damage(none, none, MO.Sector->Damage);
    }
  }

  switch (MO.Sector->special&SECSPEC_BASE_MASK) {
    case SECSPEC_ScrollCurrent:
      speed = float((MO.Sector->tag-100)%10)/16.0*35.0;
      finean = float((MO.Sector->tag-100)/10)*45.0;
      MO.Velocity.x += speed*cos(finean);
      MO.Velocity.y += speed*sin(finean);
      break;
    case SECSPEC_ScrollNorthSlow:
    case SECSPEC_ScrollNorthMedium:
    case SECSPEC_ScrollNorthFast:
      ThrustPlayer(90.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollNorthSlow], deltaTime);
      break;
    case SECSPEC_ScrollEastSlow:
    case SECSPEC_ScrollEastMedium:
    case SECSPEC_ScrollEastFast:
      ThrustPlayer(0.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollEastSlow], deltaTime);
      break;
    case SECSPEC_ScrollSouthSlow:
    case SECSPEC_ScrollSouthMedium:
    case SECSPEC_ScrollSouthFast:
      ThrustPlayer(270.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollSouthSlow], deltaTime);
      break;
    case SECSPEC_ScrollWestSlow:
    case SECSPEC_ScrollWestMedium:
    case SECSPEC_ScrollWestFast:
      ThrustPlayer(180.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollWestSlow], deltaTime);
      break;
    case SECSPEC_ScrollNorthWestSlow:
    case SECSPEC_ScrollNorthWestMedium:
    case SECSPEC_ScrollNorthWestFast:
      ThrustPlayer(135.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollNorthWestSlow], deltaTime);
      break;
    case SECSPEC_ScrollNorthEastSlow:
    case SECSPEC_ScrollNorthEastMedium:
    case SECSPEC_ScrollNorthEastFast:
      ThrustPlayer(45.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollNorthEastSlow], deltaTime);
      break;
    case SECSPEC_ScrollSouthEastSlow:
    case SECSPEC_ScrollSouthEastMedium:
    case SECSPEC_ScrollSouthEastFast:
      ThrustPlayer(315.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollSouthEastSlow], deltaTime);
      break;
    case SECSPEC_ScrollSouthWestSlow:
    case SECSPEC_ScrollSouthWestMedium:
    case SECSPEC_ScrollSouthWestFast:
      ThrustPlayer(225.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollSouthWestSlow], deltaTime);
      break;
    case SECSPEC_ScrollEast5:
    case SECSPEC_ScrollEast10:
    case SECSPEC_ScrollEast25:
    case SECSPEC_ScrollEast30:
    case SECSPEC_ScrollEast35:
      ThrustPlayer(0.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollEast5], deltaTime);
      break;
    case SECSPEC_ScrollNorth5:
    case SECSPEC_ScrollNorth10:
    case SECSPEC_ScrollNorth25:
    case SECSPEC_ScrollNorth30:
    case SECSPEC_ScrollNorth35:
      ThrustPlayer(90.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollNorth5], deltaTime);
      break;
    case SECSPEC_ScrollSouth5:
    case SECSPEC_ScrollSouth10:
    case SECSPEC_ScrollSouth25:
    case SECSPEC_ScrollSouth30:
    case SECSPEC_ScrollSouth35:
      ThrustPlayer(270.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollSouth5], deltaTime);
      break;
    case SECSPEC_ScrollWest5:
    case SECSPEC_ScrollWest10:
    case SECSPEC_ScrollWest25:
    case SECSPEC_ScrollWest30:
    case SECSPEC_ScrollWest35:
      ThrustPlayer(180.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollWest5], deltaTime);
      break;
  }
}


//============================================================================
//
//  PlayerOnSpecialFlat
//
//============================================================================
final void PlayerOnSpecialFlat (VTerrainInfo *floorType) {
  if (!floorType) return;
  if (MO.Origin.z != MO.FloorZ) return; // player is not touching the floor

  if (floorType->bAllowProtection) {
    // search for iron feet power; any subclass will do
    Inventory IronFeet = EntityEx(MO).Inventory;
    while (IronFeet) {
      if (PowerIronFeet(IronFeet)) return;
      IronFeet = IronFeet.Inventory;
    }
  }

  if (floorType->DamageAmount && Level.XLevel.Time-LastSectorDamageTime >= float(floorType->DamageTimeMask+1)/35.0) {
    LastSectorDamageTime = Level.XLevel.Time;
    EntityEx(MO).Damage(none, none, 10, 'Fire');
    MO.PlaySound('world/lavasizzle', CHAN_BODY);
  }
}


//==========================================================================
//
//  PlayerInContents
//
//==========================================================================
final void PlayerInContents (float deltaTime) {
  if (!MO.WaterLevel) return;

  // search for iron feet power; any subclass will do
  Inventory IronFeet = EntityEx(MO).Inventory;
  while (IronFeet) {
    if (PowerIronFeet(IronFeet)) break;
    IronFeet = IronFeet.Inventory;
  }

  switch (MO.WaterType) {
    case CONTENTS_LAVA:
      if (!IronFeet && Level.XLevel.Time-LastSectorDamageTime >= 32.0/35.0) {
        LastSectorDamageTime = Level.XLevel.Time;
        EntityEx(MO).Damage(none, none, 10, 'Fire');
      }
      break;
    case CONTENTS_NUKAGE:
      if (!IronFeet && Level.XLevel.Time-LastSectorDamageTime >= 32.0/35.0) {
        LastSectorDamageTime = Level.XLevel.Time;
        EntityEx(MO).Damage(none, none, 5);
      }
      break;
    case CONTENTS_SLIME:
      if (!IronFeet && Level.XLevel.Time-LastSectorDamageTime >= 32.0/35.0) {
        LastSectorDamageTime = Level.XLevel.Time;
        EntityEx(MO).Damage(none, none, 10);
      }
      break;
    case CONTENTS_HELLSLIME:
      if ((!IronFeet || (P_Random() < 5)) && Level.XLevel.Time-LastSectorDamageTime >= 32.0/35.0) {
        LastSectorDamageTime = Level.XLevel.Time;
        EntityEx(MO).Damage(none, none, 20);
      }
      break;
    case CONTENTS_SLUDGE:
      if (!IronFeet && Level.XLevel.Time-LastSectorDamageTime >= 32.0/35.0) {
        LastSectorDamageTime = Level.XLevel.Time;
        EntityEx(MO).Damage(none, none, 4);
      }
      break;
    case CONTENTS_HAZARD:
      if (!IronFeet) HazardTime += 2.0*deltaTime;
      break;
  }
}


//==========================================================================
//
//  SetPlayerRunState
//
//==========================================================================
final void SetPlayerRunState () {
  if (MO.State == EntityEx(MO).IdleState && EntityEx(MO).SeeState) {
    MO.SetState(EntityEx(MO).SeeState);
  }
}


//***************************************************************************
//
//  WEAPON UTILITES
//
//***************************************************************************

//==========================================================================
//
//  SetWeapon
//
//==========================================================================
final void SetWeapon (Weapon NewWeapon) {
  ReadyWeapon = NewWeapon;
  PendingWeapon = none;
  if (NewWeapon) {
    PSpriteSY = /*ReadyWeapon*/NewWeapon.PSpriteSY;
    MO.ModelVersion = /*ReadyWeapon*/NewWeapon.PlayerModelVersion;
  } else {
    PSpriteSY = 0;
    MO.ModelVersion = 0;
  }
}


//===========================================================================
//
//  BringUpWeapon
//
//  Starts bringing the pending weapon up from the bottom of the screen.
//
//===========================================================================
final void BringUpWeapon () {
  if (ReadyWeapon && ReadyWeapon.UpSound) {
    MO.PlaySound(ReadyWeapon.UpSound, CHAN_WEAPON);
  }

  PendingWeapon = none;
  ViewStates[ps_weapon].SY = (bInstantWeaponSwitch ? Weapon::WEAPONTOP : Weapon::WEAPONBOTTOM);
  Refire = 0;
  bReloadQueued = false;
  if (ReadyWeapon) {
    SetViewObject(ReadyWeapon);
    SetViewState(ps_weapon, ReadyWeapon.GetUpState());
    MO.ModelVersion = ReadyWeapon.PlayerModelVersion;
  }
}


//===========================================================================
//
//  DropWeapon
//
//  Player died, so put the weapon away.
//
//===========================================================================
final void DropWeapon () {
  Refire = 0;
  bReloadQueued = false;
  if (ReadyWeapon) {
    SetViewObject(ReadyWeapon);
    SetViewState(ps_weapon, ReadyWeapon.GetDownState());
  }
}


//===========================================================================
//
//  SetupPsprites
//
//  Called at start of level for each player.
//
//===========================================================================
final void SetupPsprites () {
  // remove all psprites
  foreach (auto i; 0..NUMPSPRITES) {
    SetViewObject(none);
    SetViewState(i, none);
  }

  // spawn the gun
  BringUpWeapon();
}


//==========================================================================
//
//  MovePsprites
//
//  Called every tic by player thinking routine.
//
//==========================================================================
void MovePsprites (float deltaTime) {
  AdvanceViewStates(deltaTime);
  ViewStates[ps_flash].SX = ViewStates[ps_weapon].SX;
  ViewStates[ps_flash].SY = ViewStates[ps_weapon].SY;
}


//===========================================================================
//
//  FireWeapon
//
//===========================================================================
void FireWeapon (optional state firestate) {
  bReloadQueued = false;
  if (!ReadyWeapon || !ReadyWeapon.CheckAmmo(Weapon::FIRE_Primary, true)) return;

  //print("FireWeapon: self=`%C`; MO=`%C`; ps_weapon=%s; ReadyWeapon=`%C`; firestate=(%B)%s; ast=%s", self, MO, ps_weapon, ReadyWeapon, specified_firestate, firestate, ReadyWeapon.GetAttackState(Refire));
  //print("  Refire=%s", Refire);
  //print("  MissileState=%s; SeeState=%s", EntityEx(MO).MissileState, EntityEx(MO).SeeState);

  ReadyWeapon.FireMode = Weapon::FIRE_Primary;
  if (EntityEx(MO).MissileState) MO.SetState(EntityEx(MO).MissileState);
  SetViewObject(ReadyWeapon);
  SetViewState(ps_weapon, (specified_firestate && firestate ? firestate : ReadyWeapon.GetAttackState(Refire)));
  if (!ReadyWeapon.bNoAlert) {
    LineSpecialLevelInfo(Level).NoiseAlert(EntityEx(MO), EntityEx(MO));
  }
}


//===========================================================================
//
//  AltFireWeapon
//
//===========================================================================
void AltFireWeapon (optional state firestate) {
  bReloadQueued = false;
  if (!ReadyWeapon || !ReadyWeapon.CheckAmmo(Weapon::FIRE_Secondary, true)) return;

  //print("AltFireWeapon: self=`%C`; MO=`%C`; ps_weapon=%s; ReadyWeapon=`%C`; firestate=(%B)%s; ast=%s", self, MO, ps_weapon, ReadyWeapon, specified_firestate, firestate, ReadyWeapon.GetAttackState(Refire));
  //print("  Refire=%s", Refire);
  //print("  MissileState=%s; SeeState=%s", EntityEx(MO).MissileState, EntityEx(MO).SeeState);

  ReadyWeapon.FireMode = Weapon::FIRE_Secondary;
  if (EntityEx(MO).MissileState) MO.SetState(EntityEx(MO).MissileState);
  SetViewObject(ReadyWeapon);
  SetViewState(ps_weapon, (specified_firestate && firestate ? firestate : ReadyWeapon.GetAltAttackState(Refire)));
  if (!ReadyWeapon.bNoAlert) {
    LineSpecialLevelInfo(Level).NoiseAlert(EntityEx(MO), EntityEx(MO));
  }
}


//===========================================================================
//
//  ReloadWeapon
//
//===========================================================================
void ReloadWeapon () {
  Refire = 0; //k8: reloading weapon resets refire state
  bReloadQueued = false;
  if (ReadyWeapon) {
    state rst = ReadyWeapon.GetReloadState();
    if (!rst) return;
    SetViewObject(ReadyWeapon);
    SetViewState(ps_weapon, rst);
  }
}


//==========================================================================
//
//  ChangeWeapon
//
//  The actual changing of the weapon is done when the weapon psprite can
//  do it (read: not in the middle of an attack).
//
//==========================================================================
final void ChangeWeapon (int newweapon) {
  if (MorphTime) return;
  Weapon NewWpn = GetSlotChangeWeapon(newweapon);
  if (NewWpn && NewWpn != ReadyWeapon &&
      (!NewWpn.bGivenAsMorphWeapon && (!ReadyWeapon || !ReadyWeapon.bGivenAsMorphWeapon)))
  {
    bReloadQueued = false;
    PendingWeapon = NewWpn;
  }
}


//==========================================================================
//
//  PrevWeapon
//
//==========================================================================
final void PrevWeapon () {
  if (MorphTime) return;
  Weapon Wpn = GetPrevWeapon(PendingWeapon ? PendingWeapon : ReadyWeapon);
  if (Wpn && Wpn != ReadyWeapon) {
    bReloadQueued = false;
    PendingWeapon = Wpn;
  }
}


//==========================================================================
//
//  NextWeapon
//
//==========================================================================
final void NextWeapon () {
  if (MorphTime) return;
  Weapon Wpn = GetNextWeapon(PendingWeapon ? PendingWeapon : ReadyWeapon);
  if (Wpn && Wpn != ReadyWeapon) {
    bReloadQueued = false;
    PendingWeapon = Wpn;
  }
}


//==========================================================================
//
//  BestWeapon
//
//  Returns best weapon to use
//
//==========================================================================
final Weapon BestWeapon (optional class!Ammo AmmoType) {
  if (!MO) return none;
  bool Powered = !!EntityEx(MO).FindInventory(PowerWeaponLevel2);
  Weapon Best = none;
  for (Inventory Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory) {
    // must be a weapon
    Weapon Wpn = Weapon(Item);
    if (!Wpn) continue;
    // check if best one is better that this one
    if (Best && Wpn.SelectionOrder > Best.SelectionOrder) continue;
    // possibly limit to specific ammo type
    if (AmmoType && Wpn.AmmoType1 != AmmoType) continue;
    // check if it's for the current tome of power state
    if (Powered && Wpn.SisterWeapon && Wpn.SisterWeapon.bPoweredUp) continue;
    if (!Powered && Wpn.bPoweredUp) continue;
    // make sure it has enough ammo
    if (!Wpn.CheckAmmo(Weapon::FIRE_Either, false)) continue;
    // good one
    Best = Wpn;
  }
  return Best;
}


//==========================================================================
//
//  ChoosePowered
//
//==========================================================================
final Weapon ChoosePowered (Weapon Wpn) {
  if (!Wpn) return none;
  bool Powered = !!EntityEx(MO).FindInventory(PowerWeaponLevel2);
  if (Powered && Wpn.SisterWeapon && Wpn.SisterWeapon.bPoweredUp) {
    return Wpn.SisterWeapon;
  }
  return Wpn;
}


//==========================================================================
//
//  GetSlotChangeWeapon
//
//==========================================================================
final Weapon GetSlotChangeWeapon (int Slot) {
  LineSpecialGameInfo GI = LineSpecialGameInfo(Level.Game);

  if (Slot < 0 || Slot > LineSpecialGameInfo::NUM_WEAPON_SLOTS) return ReadyWeapon;

  if (ReadyWeapon) {
    class!Weapon readyWpnClass = class!Weapon(GetClassReplacement(ReadyWeapon.Class));
    if (readyWpnClass) {
      foreach (auto i; 0..LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT) {
        //print("i=%s; wpn=%C", i, GI.WeaponSlots[Slot].Weapons[i]);
        class!Weapon slotwpn = GetClassReplacement(GI.WeaponSlots[Slot].Weapons[i]);
        if (!slotwpn) continue;
        if (GetClassReplacement(slotwpn) == readyWpnClass ||
            (ReadyWeapon.bPoweredUp && ReadyWeapon.SisterWeapon &&
             slotwpn == GetClassReplacement(ReadyWeapon.SisterWeapon.Class)))
        {
          for (int j = (i+LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT-1)%LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT;
               j != i;
               j = (j+LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT-1)%LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT)
          {
            class!Weapon swc = GI.WeaponSlots[Slot].Weapons[j];
            Weapon Wpn = Weapon(EntityEx(MO).FindInventory(GetClassReplacement(swc)));
            if (!Wpn) Wpn = Weapon(EntityEx(MO).FindInventory(swc));
            if (Wpn && Wpn.CheckAmmo(Weapon::FIRE_Either, false)) return ChoosePowered(Wpn);
          }
        }
      }
    }
  }

  foreach (auto i; 0..LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT; reverse) {
    class!Weapon slotwpn = GI.WeaponSlots[Slot].Weapons[i];
    Weapon Wpn = Weapon(EntityEx(MO).FindInventory(GetClassReplacement(slotwpn)));
    if (!Wpn) Wpn = Weapon(EntityEx(MO).FindInventory(slotwpn));
    if (Wpn && Wpn.CheckAmmo(Weapon::FIRE_Either, false)) return ChoosePowered(Wpn);
  }

  return ReadyWeapon;
}


//==========================================================================
//
//  GetPrevWeapon
//
//==========================================================================
final Weapon GetPrevWeapon (Weapon Current) {
  LineSpecialGameInfo GI = LineSpecialGameInfo(Level.Game);
  int Slot;
  int Index;
  int Start;

  if (Current && GI.FindWeaponSlot(class!Weapon(Current.Class), Slot, Index/*, Current.Position*/, exact:true)) {
    //print("PREVWEAPON: found slot for current weapon: slot=%d; index=%d", Slot, Index);
    Start = Slot*LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT+Index;
  } else {
    //print("PREVWEAPON: slot not found");
    Start = LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT*LineSpecialGameInfo::NUM_WEAPON_SLOTS;
  }

  foreach (auto i; 0..LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT*LineSpecialGameInfo::NUM_WEAPON_SLOTS) {
    --Start;
    if (Start < 0) break;
    Slot = (Start/LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT); //%LineSpecialGameInfo::NUM_WEAPON_SLOTS;
    Index = Start%LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT;
    class!Weapon swc = GI.WeaponSlots[Slot].Weapons[Index];
    if (!swc) continue;
    //print("PREVWEAPON:  checking weapon at (%d:%d); desired class is '%C'", Slot, Index, swc);
    if (Current && GetClassReplacement(swc) == GetClassReplacement(Current.Class)) {
      //print("PREVWEAPON:   skip current");
      continue;
    }
    Weapon Wpn = Weapon(EntityEx(MO).FindInventory(GetClassReplacement(swc)));
    if (!Wpn) Wpn = Weapon(EntityEx(MO).FindInventory(swc));
    if (Wpn) {
      //print("PREVWEAPON:   found weapon at (%d:%d); desired class is '%C', real class is '%C'", Slot, Index, swc, Wpn);
      if (Wpn.CheckAmmo(Weapon::FIRE_Either, false)) return ChoosePowered(Wpn);
    }
  }

  return Current;
}


//==========================================================================
//
//  GetNextWeapon
//
//==========================================================================
final Weapon GetNextWeapon (Weapon Current) {
  LineSpecialGameInfo GI = LineSpecialGameInfo(Level.Game);
  int Slot;
  int Index;
  int Start;

  if (Current && GI.FindWeaponSlot(class!Weapon(Current.Class), out Slot, out Index/*, Current.Position*/, exact:true)) {
    //print("NEXTWEAPON: found slot for current weapon: slot=%d; index=%d", Slot, Index);
    Start = Slot*LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT+Index;
  } else {
    //print("NEXTWEAPON: slot not found");
    Start = -1;
  }

  foreach (auto i; 0..LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT*LineSpecialGameInfo::NUM_WEAPON_SLOTS) {
    ++Start;
    //if (Start >= LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT*LineSpecialGameInfo::NUM_WEAPON_SLOTS) break;
    Slot = (Start/LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT); //%LineSpecialGameInfo::NUM_WEAPON_SLOTS;
    if (Slot >= LineSpecialGameInfo::NUM_WEAPON_SLOTS) break;
    Index = Start%LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT;
    //print("  Slot=%d; Index=%d; class=%C", Slot, Index, GI.WeaponSlots[Slot].Weapons[Index]);
    class!Weapon swc = GI.WeaponSlots[Slot].Weapons[Index];
    if (!swc) continue;
    //print("NEXTWEAPON:  checking weapon at (%d:%d); desired class is '%C'", Slot, Index, swc);
    if (Current && GetClassReplacement(swc) == GetClassReplacement(Current.Class)) {
      //print("NEXTWEAPON:   skip current");
      continue;
    }
    Weapon Wpn = Weapon(EntityEx(MO).FindInventory(GetClassReplacement(swc)));
    if (!Wpn) Wpn = Weapon(EntityEx(MO).FindInventory(swc));
    if (Wpn) {
      //print("NEXTWEAPON:   found weapon at (%d:%d); desired class is '%C', real class is '%C'", Slot, Index, swc, Wpn);
      if (Wpn.CheckAmmo(Weapon::FIRE_Either, false)) return ChoosePowered(Wpn);
    }
  }

  return Current;
}


//==========================================================================
//
//  UsePuzzleItem
//
//  USING A PUZZLE ITEM
//
//  Returns true if the puzzle item was used on a line or a thing.
//
//==========================================================================
final bool UsePuzzleItem (int PuzzleItemType) {
  float x1, y1, x2, y2;
  TVec PuzzleUseDir;
  intercept_t* in;

  AngleVector(MO.Angles, out PuzzleUseDir);
  x1 = MO.Origin.x;
  y1 = MO.Origin.y;
  x2 = x1+USERANGE*PuzzleUseDir.x;
  y2 = y1+USERANGE*PuzzleUseDir.y;
  foreach MO.PathTraverse(in, x1, y1, x2, y2, PT_ADDLINES|PT_ADDTHINGS/*|PT_EARLYOUT*/) {
    EntityEx mobj;
    TVec hit_point;
    opening_t *open;

    if (in->bIsALine) {
      // check line
      hit_point = MO.Origin+(USERANGE*in->frac)*PuzzleUseDir;
      if (in->line->special != LNSPEC_UsePuzzleItem) {
        if (in->line->flags&(ML_BLOCKEVERYTHING|ML_BLOCKUSE)) {
          // gozzo does this
          open = nullptr;
        } else {
          open = LineOpenings(in->line, hit_point);
        }
        if (!open || open->range <= 0.0) {
          if (MO.bIsPlayer) MO.PlaySound('*puzzfail', CHAN_VOICE);
          break; // can't use through a wall
        }
        continue; // continue searching
      }
      if (PointOnPlaneSide(MO.Origin, in->line) == 1) {
        // don't use back sides
        break;
      }
      if (PuzzleItemType != in->line->arg1) {
        // item type doesn't match
        break;
      }
      MO.XLevel.StartACS(in->line->arg2, 0, in->line->arg3,
        in->line->arg4, in->line->arg5, MO, in->line, 0, false,
        false);
      in->line->special = 0;
      return true; // stop searching
    }
    // check thing
    mobj = EntityEx(in->Thing);
    if (mobj.Special != LNSPEC_UsePuzzleItem) {
      // wrong special
      continue;
    }
    if (PuzzleItemType != mobj.Args[0]) {
      // item type doesn't match
      continue;
    }
    MO.XLevel.StartACS(mobj.Args[1], 0, mobj.Args[2], mobj.Args[3],
      mobj.Args[4], MO, nullptr, 0, false, false);
    mobj.Special = 0;
    return true; // Stop searching
  }
  return false;
}


//==========================================================================
//
//  AddRevealedMap
//
//==========================================================================
final bool AddRevealedMap () {
  bAutomapRevealed = true;
  foreach (auto i; 0..RevealedMaps.length) {
    if (RevealedMaps[i] == Level.XLevel.MapName) return false; // already revealed
  }
  RevealedMaps.Num = RevealedMaps.Num+1;
  RevealedMaps[RevealedMaps.Num-1] = Level.XLevel.MapName;
  return true;
}


//==========================================================================
//
//  RemoveRevealedMap
//
//==========================================================================
final void RemoveRevealedMap () {
  bAutomapRevealed = false;
  foreach (auto i; 0..RevealedMaps.length) {
    if (RevealedMaps[i] == Level.XLevel.MapName) {
      RevealedMaps.Remove(i);
      return;
    }
  }
}


//==========================================================================
//
//  UpdateRevealedMap
//
//==========================================================================
final void UpdateRevealedMap () {
  bAutomapRevealed = false;
  foreach (auto i; 0..RevealedMaps.length) {
    if (RevealedMaps[i] == Level.XLevel.MapName) {
      bAutomapRevealed = true;
      return;
    }
  }
}


//==========================================================================
//
//  ParticleEffect
//
//==========================================================================
void ParticleEffect (int count, int type1, int type2, TVec origin, float ornd,
                     TVec velocity, float vrnd, float acceleration, float grav,
                     int colour, float duration, float ramp)
{
  Level.ParticleEffect(count, type1, type2, origin, ornd, velocity, vrnd, acceleration,
        grav, colour, duration, ramp);
}


//==========================================================================
//
//  DecalEffect
//
//==========================================================================
void DecalEffect (TVec org, name dectype, int side, /*line_t *li*/int lineidx) {
  if (!dectype || lineidx < 0 || !Level.XLevel) return; // just in case
  if (!GetCvarB('r_decals_enabled')) return;
  if (lineidx >= Level.XLevel.Lines.length) return;
  Level.XLevel.AddDecal(org, dectype, side, &Level.XLevel.Lines[lineidx]);
}


//==========================================================================
//
//  ClientExplosion
//
//==========================================================================
void ClientExplosion (int colour, float rad, TVec org) {
  dlight_t *dl = Level.AllocDlight(none, org, rad+150.0);
  if (dl) {
    //dl->origin = org;
    //dl->radius = rad+150.0;
    dl->colour = colour;
    dl->die = Level.XLevel.Time+0.5;
    dl->decay = 300.0;
  }
}


//==========================================================================
//
//  ClientParticleExplosion
//
//==========================================================================
void ClientParticleExplosion (int colour, float rad, TVec org) {
  foreach (auto i; 0..1024) {
    particle_t *p = Level.NewParticle();
    if (!p) break;
    p->die = Level.XLevel.Time+5.0;
    p->colour = LineSpecialGameInfo.default.ramp1[0];
    p->Size = 1.0;
    p->ramp = Random()*4.0;
    if (i&1) {
      p->type = LineSpecialLevelInfo::pt_explode;
    } else {
      p->type = LineSpecialLevelInfo::pt_explode2;
    }
    p->org.x = org.x+((Random()*32.0)-16.0);
    p->org.y = org.y+((Random()*32.0)-16.0);
    p->org.z = org.z+((Random()*32.0)-16.0);
    p->vel.x = (Random()*512.0)-256.0;
    p->vel.y = (Random()*512.0)-256.0;
    p->vel.z = (Random()*512.0)-256.0;
    //p->accel = (Random()*512.0)-256.0;
    p->gravity = 40.0+(Random()*512.0)-256.0;
  }

  dlight_t *dl = Level.AllocDlight(none, org, rad+150.0);
  if (dl) {
    //dl->origin = org;
    //dl->radius = rad + 150.0;
    dl->colour = colour;
    dl->die = Level.XLevel.Time+0.5;
    dl->decay = 300.0;
  }
}


//==========================================================================
//
//  ClientSparkParticles
//
//==========================================================================
void ClientSparkParticles (int Count, TVec Org, float Angle) {
  foreach (auto i; 0..Count) {
    particle_t *p = Level.NewParticle();
    if (!p) break;

    p->type = LineSpecialLevelInfo::pt_spark;
    p->Size = 0.5;
    p->colour = Random() < 0.5 ? RGBA(255, 120, 0, 255) : RGBA(255, 170, 0, 255);
    p->die = Level.XLevel.Time+10.0/35.0;

    float an = Angle+Random()*45.0;
    p->org.x = Org.x+(Random ()*15.0)*cos(an);
    p->org.y = Org.y+(Random ()*15.0)*sin(an);
    p->org.z = Org.z-Random ()*4.0;

    p->vel.x = (Random()-0.5)*2.0;
    p->vel.y = (Random()-0.5)*2.0;
    p->vel.z = (Random()-0.5)*2.0-Random ()*70.0;

    p->accel.x = (Random()-0.5)*16.0+(Random ()-0.5)*35.0;
    p->accel.y = (Random()-0.5)*16.0+(Random ()-0.5)*35.0;
    p->accel.z = (Random()-0.5)*16.0-140.0;
  }
}


//==========================================================================
//
//  AddBlend
//
//==========================================================================
final void AddBlend (out float r, out float g, out float b, out float a, int Col) {
  if (!(Col&0xff000000)) return; // no alpha
  float r1 = float((Col>>16)&0xff)/255.0;
  float g1 = float((Col>>8)&0xff)/255.0;
  float b1 = float(Col&0xff)/255.0;
  float a1 = float((Col>>24)&0xff)/255.0;
  float TmpA = fclamp(1.0-(1.0-a)*(1.0-a1), 0.0, 1.0);
  if (!TmpA) return;
  r = (r*a*(1.0-a1)+r1*a1)/TmpA;
  g = (g*a*(1.0-a1)+g1*a1)/TmpA;
  b = (b*a*(1.0-a1)+b1*a1)/TmpA;
  a = TmpA;
}


//==========================================================================
//
//  AddBlendWithAlpha
//
//  overrides blend color alpha
//
//==========================================================================
final void AddBlendWithAlpha (out float r, out float g, out float b, out float a, int Col, float alpha) {
  if (alpha <= 0) return; // no alpha
  float r1 = float((Col>>16)&0xff)/255.0;
  float g1 = float((Col>>8)&0xff)/255.0;
  float b1 = float(Col&0xff)/255.0;
  float TmpA = fclamp(1.0-(1.0-a)*(1.0-alpha), 0.0, 1.0);
  if (!TmpA) return;
  r = (r*a*(1.0-alpha)+r1*alpha)/TmpA;
  g = (g*a*(1.0-alpha)+g1*alpha)/TmpA;
  b = (b*a*(1.0-alpha)+b1*alpha)/TmpA;
  a = TmpA;
}


//==========================================================================
//
//  PaletteFlash
//
//  Sets the new palette colour shift based upon the current values of
//  Player.DamageFlash and Player.BonusFlash, contents and other inventory
//  items.
//
//==========================================================================
void PaletteFlash () {
  float r = 0.0;
  float g = 0.0;
  float b = 0.0;
  float a = 0.0;

  if (MO.WaterLevel == 3) {
    switch (MO.WaterType) {
      case CONTENTS_WATER: AddBlend(r, g, b, a, RGBA(130, 80, 50, 128)); break;
      case CONTENTS_LAVA: AddBlend(r, g, b, a, RGBA(255, 80, 0, 150)); break;
      case CONTENTS_NUKAGE: AddBlend(r, g, b, a, RGBA(50, 255, 50, 150)); break;
      case CONTENTS_SLIME: AddBlend(r, g, b, a, RGBA(0, 25, 5, 150)); break;
      case CONTENTS_HELLSLIME: AddBlend(r, g, b, a, RGBA(255, 80, 0, 150)); break;
      case CONTENTS_BLOOD: AddBlend(r, g, b, a, RGBA(160, 16, 16, 150)); break;
      case CONTENTS_SLUDGE: AddBlend(r, g, b, a, RGBA(128, 160, 128, 150)); break;
      case CONTENTS_HAZARD: AddBlend(r, g, b, a, RGBA(128, 160, 128, 128)); break;
    }
  }

  if (EntityEx(MO).DamageType == 'Ice') {
    // Frozen player
    AddBlend(r, g, b, a, RGBA(2, 2, 255, 113));
  } else {
    if (DamageFlash) {
      int Amount = int(114.0*DamageFlash);
      if (Amount >= 228) Amount = 228;
      AddBlend(r, g, b, a, (Amount<<24)|(PlayerPawn(MO).DamageScreenColour&0x00ffffff));
    }

    if (BonusFlash) {
      int Amount = int(256.0*BonusFlash);
      if (Amount >= 128) Amount = 128;
      AddBlend(r, g, b, a, RGBA(215, 186, 68, Amount));
    }

    if (PoisonCount) {
      int Amount = PoisonCount*160/32;
      if (Amount >= 160) Amount = 160;
      AddBlend(r, g, b, a, RGBA(56, 118, 46, Amount));
    }

    //FIXME add hazard flash.
    if (HazardTime > 16.0 || int(4.0*HazardTime)&1) {
      AddBlend(r, g, b, a, RGBA(0, 255, 0, 32));
    }
  }

  // item effects
  for (Inventory Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory) {
    int Blend = Item.GetBlend();
    if (Blend) AddBlend(r, g, b, a, Blend);
  }

  // Health Accumulation Device effect
  if (MO && MO.XLevel) {
    float lvtime = MO.XLevel.Time;
    //print("lvtime=%f; k8HealthAccum_LastBoostTime=%f; k8HealthAccum_LastRegenTime=%f", lvtime, k8HealthAccum_LastBoostTime, k8HealthAccum_LastRegenTime);
    bool doRegen = true;
    if (k8HealthAccum_LastBoostTime > 0) {
      float diff = lvtime-k8HealthAccum_LastBoostTime;
      if (diff > 0 && diff < 1) {
        AddBlendWithAlpha(r, g, b, a, RGBA(255, 127, 0, 0), 0.5-diff/2.0);
        doRegen = false;
      }
    }
    if (doRegen && k8HealthAccum_LastRegenTime > 0) {
      float diff = lvtime-k8HealthAccum_LastRegenTime;
      if (diff > 0 && diff < 0.1) {
        AddBlendWithAlpha(r, g, b, a, RGBA(0, 128, 0, 0), 0.1-diff*1);
      }
    }
  }

  if (BlendA) {
    AddBlend(r, g, b, a, RGBA(int(BlendR*255.0), int(BlendG*255.0), int(BlendB*255.0), int(BlendA*255.0)));
  }

  r = fclamp(r, 0.0, 1.0);
  g = fclamp(g, 0.0, 1.0);
  b = fclamp(b, 0.0, 1.0);
  CShift = RGBA(int(r*255.0), int(g*255.0), int(b*255.0), int(a*255.0));
}


//==========================================================================
//
//  PreTravel
//
//==========================================================================
override void PreTravel () {
  SavedInventory = EntityEx(MO).Inventory;
  EntityEx(MO).Inventory = none;
}


//==========================================================================
//
//  UseInventory
//
//==========================================================================
override void UseInventory (string Inv) {
  if (!Inv) return;

  if (bTotallyFrozen || (Level.bFrozen && !(Cheats&CF_TIMEFREEZE))) {
    // you can't use items if you're totally frozen
    return;
  }

  name invname = name(Inv);
  Inventory item = EntityEx(MO).FindInventory(class!Inventory(FindClassNoCase(invname)));
  if (!item) item = EntityEx(MO).FindInventory(class!Inventory(GetClassReplacement(FindClassNoCase(invname))));

  if (item) {
    // use Inventory item
    EntityEx(MO).UseInventory(item);
  }
}


//==========================================================================
//
//  CheckDoubleFiringSpeed
//
//==========================================================================
override bool CheckDoubleFiringSpeed () {
  return !!(Cheats&CF_DOUBLEFIRINGSPEED);
}


//==========================================================================
//
//  ClientSpeech
//
//==========================================================================
void ClientSpeech (EntityEx Speaker, int SpeechNum) {
  LineSpecialClientGame(ClGame).StartSpeech(Speaker, SpeechNum);
}


//==========================================================================
//
//  ClientSlideshow1
//
//==========================================================================
void ClientSlideshow1 () {
  LineSpecialClientGame(ClGame).StartConSlideshow1();
}


//==========================================================================
//
//  ClientSlideshow2
//
//==========================================================================
void ClientSlideshow2 () {
  LineSpecialClientGame(ClGame).StartConSlideshow2();
}


//==========================================================================
//
//  ClientFinaleType
//
//==========================================================================
void ClientFinaleType (int Type) {
  LineSpecialClientGame(ClGame).SetFinaleType(Type);
}


//==========================================================================
//
//  SetObjectives
//
//==========================================================================
final void SetObjectives (int NewObjectives) {
  if (!NewObjectives) return;
  // check if log text lump exists in wad file
  if (!WadLumpPresent(StrToName(va("log%d", NewObjectives)))) return;
  Objectives = NewObjectives;
}


//==========================================================================
//
//  DisplayObituary
//
//==========================================================================
void DisplayObituary (EntityEx inflictor, EntityEx source, name DmgType) {
  string Msg;

       if (DmgType == 'Suicide') Msg = "$ob_suicide"; // commited a suicide
  else if (DmgType == 'Falling') Msg = "$ob_falling"; // fell down
  else if (DmgType == 'Crush') Msg = "$ob_crush"; // crushed by the environment
  else if (DmgType == 'Exit') Msg = "$ob_exit"; // tried to exit when it's not allowed
  else if (DmgType == 'Drowning') Msg = "$ob_water"; // drowned int the water
  else if (DmgType == 'Slime') Msg = "$ob_slime"; // was standing in the slime
  else if (DmgType == 'Fire' && !source) Msg = "$ob_lava"; // was standing in the lava
  else if (source) {
    if (source.Player == self) {
      // suicide
      Msg = "$ob_killedself";
    } else if (!source.bIsPlayer) {
      // killed by monster
           if (DmgType == 'Telefrag') Msg = "$ob_montelefrag"; // monster telefrag
      else if (DmgType == 'Melee' && source.HitObituary) Msg = source.HitObituary;
      else Msg = source.Obituary;
    }
  }

  if (!Msg && source && source.bIsPlayer) {
    if (Level.Game.netgame && !Level.Game.deathmatch) {
      // killed another player in cooperative net game
      Msg = va("$ob_friendly%d", P_Random()&3);
    } else if (DmgType == 'Telefrag') {
      // telefrag
      Msg = "$ob_mptelefrag";
    } else if (inflictor && inflictor.Obituary) {
      // missile with it's own obituary
      Msg = inflictor.Obituary;
    } else {
      Weapon Wpn = PlayerEx(inflictor.Player).ReadyWeapon;
           if (Wpn && Wpn.Obituary) Msg = Wpn.Obituary; // weapon obituary message
      else if (DmgType == 'BFGSplash') Msg = "$ob_mpbfg_splash"; // BFG splash damage
      else if (DmgType == 'Railgun') Msg = "$ob_railgun"; // railgun
      else Msg = "$ob_mpdefault"; // default multiplayer kill message
    }
  } else {
    source = EntityEx(MO);
  }

  if (!Msg) Msg = "$ob_default"; // generic death

  // look up string in language lump is necesary
  if (StrStartsWith(Msg, "$")) Msg = GetLangString(name(Msg[1..$]));

  // do replacements
  Msg = StrReplace(Msg, "%g", "he");
  Msg = StrReplace(Msg, "%h", "him");
  Msg = StrReplace(Msg, "%p", "his");
  Msg = StrReplace(Msg, "%o", PlayerName);
  Msg = StrReplace(Msg, "%k", source.Player.PlayerName);

  Level.bprint("%s", Msg);
}


//==========================================================================
//
//  ClientRailTrail
//
//==========================================================================
void ClientRailTrail (TVec From, TVec To, int Col1, int Col2, float MaxDiff) {
  float Len = Length(To-From);
  TVec Dir = Normalise(To-From);
  TAVec Ang;
  VectorAngles(Dir, out Ang);
  Ang.roll = 270.0;

  if (!Col1) Col1 = RGBA(255, 255, 255, 255);
  if (!Col2) Col2 = RGBA(0, 0, 255, 255);

  TVec Diff;
  float Offs;
  for (Offs = 0.0; Offs < Len; Offs += 3.0) {
    if (MaxDiff > 0.0) {
      int Rnd = P_Random();
      if (Rnd&1) {
        Diff.x += (Rnd&8 ? 1.0 : -1.0);
        Diff.x = fclamp(Diff.x, -MaxDiff, MaxDiff);
      }
      if (Rnd&2) {
        Diff.y += (Rnd&16 ? 1.0 : -1.0);
        Diff.y = fclamp(Diff.y, -MaxDiff, MaxDiff);
      }
      if (Rnd&4) {
        Diff.z += (Rnd&32 ? 1.0 : -1.0);
        Diff.z = fclamp(Diff.z , -MaxDiff, MaxDiff);
      }
    }

    particle_t *p = Level.NewParticle();
    if (!p) break;

    p->type = LineSpecialLevelInfo::pt_rail;
    p->Size = 0.5;
    p->colour = Col1;
    p->die = Level.XLevel.Time+1.0;
    p->org = From+Dir*Offs+Diff;
    p->vel.x = (Random()-0.5)*2.0;
    p->vel.y = (Random()-0.5)*2.0;
    p->vel.z = (Random()-0.5)*2.0;
    p->accel = vector(0.0, 0.0, 0.0);

    Ang.roll += 14.0;
    TVec Forward;
    TVec Right;
    TVec Up;
    AngleVectors(Ang, out Forward, out Right, out Up);

    p = Level.NewParticle();
    if (!p) break;
    p->type = LineSpecialLevelInfo::pt_rail;
    p->Size = 0.5;
    p->colour = Col2;
    p->die = Level.XLevel.Time+1.0;
    p->org = From+Dir*Offs+Up*3.0;
    p->vel = Up;
    p->accel = vector(0.0, 0.0, 0.0);
  }
}


//==========================================================================
//
//  ClientVoice
//
//==========================================================================
void ClientVoice (int VoiceNum) {
  LocalSound(StrToName(va("svox/voc%d", VoiceNum)));
}


//==========================================================================
//
//  GiveAmmo
//
//  Returns false if the ammo can't be picked up at all
//
//==========================================================================
final bool GiveAmmo (class!Ammo ammo, int count) {
  int oldammo;

  if (!ammo) return false;

  Ammo AmmoItem = Ammo(EntityEx(MO).FindInventory(ammo));
  if (!AmmoItem) AmmoItem = Ammo(EntityEx(MO).FindInventory(GetClassReplacement(ammo)));

  if (!AmmoItem) {
    AmmoItem = Level.Spawn(GetClassReplacement(ammo), default, default, default, false);
    AmmoItem.AttachToOwner(EntityEx(MO));
    AmmoItem.Amount = 0;
  }

  if (!count) return false;

  if (AmmoItem.Amount == AmmoItem.MaxAmount) return false;

  // extra ammo in baby mode and nightmare mode
  count = int(float(count)*Level.World.SkillAmmoFactor);

  oldammo = AmmoItem.Amount;
  AmmoItem.Amount += count;
  if (AmmoItem.Amount > AmmoItem.MaxAmount) AmmoItem.Amount = AmmoItem.MaxAmount;

  if (oldammo <= 0) GotAmmo(AmmoItem);

  return true;
}


//==========================================================================
//
//  PutClientIntoServer
//
//==========================================================================
override void PutClientIntoServer () {
  if (bIsBot) CreateBot();
}


//==========================================================================
//
//  SpawnClient
//
//==========================================================================
override void SpawnClient () {
  bool playerWasReborn;
  EntityEx OldMO = EntityEx(MO);

  // setup weapon slots
  if (Level) {
    LineSpecialGameInfo GI = LineSpecialGameInfo(Level.Game);
    if (GI) {
      /*
      foreach (auto wsidx; 0..LineSpecialGameInfo::NUM_WEAPON_SLOTS) {
        print("=== weapon slot #%d", wsidx);
        foreach (auto s2idx; 0..LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT) {
          class!Weapon ww = GI.WeaponSlots[wsidx].Weapons[s2idx];
          if (ww) print("  %d: %n (priority:%d)", s2idx, GetClassName(ww), ww.default.Position);
        }
      }
      */
      GI.InitializeWeaponSlots();
      /*
      foreach (auto wsidx; 0..LineSpecialGameInfo::NUM_WEAPON_SLOTS) {
        print("=== weapon slot #%d", wsidx);
        foreach (auto s2idx; 0..LineSpecialGameInfo::MAX_WEAPONS_PER_SLOT) {
          class!Weapon ww = GI.WeaponSlots[wsidx].Weapons[s2idx];
          if (ww) print("  %d: %n (priority:%d)", s2idx, GetClassName(ww), ww.default.Position);
        }
      }
      */
    }
  }


  Attacker = none;
  Poisoner = none;

  AddVisitedMap(Level.XLevel.MapName);

  if (Level.Game.netgame && !Level.Game.deathmatch) {
    // cooperative net-play, retain keys and weapons
    playerWasReborn = (PlayerState == PST_REBORN);
  }

  // spawn player
  if (Level.Game.deathmatch) {
    DeathMatchSpawnPlayer();
  } else if (Level.Game.netgame || Level.bClusterHub) {
    SpawnPlayer(Level.GetPlayerStart(GetPlayerNum(), Level.Game.RebornPosition), false);
  } else {
    mthing_t *Best = nullptr;
    bool Spawned = false;
    foreach (auto i; 0..Level.PlayerStarts.length) {
      if (Level.PlayerStarts[i].type != GetPlayerNum()+1) continue;
      if (Level.PlayerStarts[i].arg1 == Level.Game.RebornPosition) {
        SpawnPlayer(&Level.PlayerStarts[i], Spawned);
        Spawned = true;
        continue;
      }
      if (!Best) Best = &Level.PlayerStarts[i];
    }
    if (!Spawned) {
      if (!Best) Error("Player %d has no start spots", GetPlayerNum()+1);
      print("Player %d has no start spot for position %d", GetPlayerNum()+1, Level.Game.RebornPosition);
      SpawnPlayer(Best, false);
    }
  }

  /* ResetPlayerOnSpawn() should take care of this
  if (!playerWasReborn && LocalQuakeHappening) {
    print("*** RESETTING QUAKING!");
    LocalQuakeHappening = 0;
  }
  */

  if (Level.Game.netgame && !Level.Game.deathmatch && playerWasReborn) {
    OnNetReborn(OldMO);
  }

  // destroy all things touching players
  Actor(MO).TeleportMove(MO.Origin);
}


//==========================================================================
//
//  NetGameReborn
//
//  Respawn at the start
//
//==========================================================================
override void NetGameReborn () {
  EntityEx OldMO = EntityEx(MO);

  // remove pitch and roll angles from corpse
  MO.Angles.pitch = 0.0;
  MO.Angles.roll = 0.0;

  // first dissasociate the corpse
  MO.Player = none;
  MO.bIsPlayer = false;

  // spawn at random spot if in death match
  if (Level.Game.deathmatch) {
    OldMO.DestroyAllInventory();
    DeathMatchSpawnPlayer();
    return;
  }

  bool foundSpot = false;
  if (CheckSpot(Level.GetPlayerStart(GetPlayerNum(), Level.Game.RebornPosition))) {
    // appropriate player start spot is open
    SpawnPlayer(Level.GetPlayerStart(GetPlayerNum(), Level.Game.RebornPosition), false);
    foundSpot = true;
  } else {
    // try to spawn at one of the other player start spots
    foreach (auto i; 0..MAXPLAYERS) {
      if (CheckSpot(Level.GetPlayerStart(i, Level.Game.RebornPosition))) {
        // found an open start spot
        SpawnPlayer(Level.GetPlayerStart(i, Level.Game.RebornPosition), false);
        foundSpot = true;
        break;
      }
    }
  }

  if (!foundSpot) {
    // player's going to be inside something. too bad.
    SpawnPlayer(Level.GetPlayerStart(GetPlayerNum(), Level.Game.RebornPosition), false);
  }

  OnNetReborn(OldMO);
}


//==========================================================================
//
//  DisconnectClient
//
//==========================================================================
override void DisconnectClient () {
  DestroyBot();
  if (MO) {
    MO.Player = none;
    MO.bIsPlayer = false;
    Actor(MO).Damage(none, none, 10000);
  }
  Level.bprint("%s left the game\n", PlayerName);
  MO.PlaySound('misc/chat', CHAN_AUTO, 1.0, ATTN_NONE);
}


//==========================================================================
//
//  DeathMatchSpawnPlayer
//
//  Spawns a player at one of the random death match spots called at level
//  load and each death
//
//==========================================================================
void DeathMatchSpawnPlayer () {
  if (!Level.DeathmatchStarts.length) Error("oops! no deathmatch starts where they should be!");

  foreach (auto j; 0..20) {
    int i = P_Random()%Level.DeathmatchStarts.length;
    if (CheckSpot(&Level.DeathmatchStarts[i])) {
      SpawnPlayer(&Level.DeathmatchStarts[i], false);
      return;
    }
  }

  // no good spot, so the player will probably get stuck
  SpawnPlayer(Level.GetPlayerStart(GetPlayerNum(), 0), false);
}


//==========================================================================
//
//  CheckSpot
//
//  Returns false if the player cannot be respawned at the given mthing_t
//  spot because something is occupying it
//
//==========================================================================
bool CheckSpot (mthing_t *mthing) {
  float x;
  float y;
  sector_t *sec;
  float an;

  if (!MO) {
    // first spawn of level, before corpses
    foreach (auto i; 0..MAXPLAYERS) {
      if (Level.Game.Players[i] && Level.Game.Players[i].MO &&
          Level.Game.Players[i].MO.Origin.x == mthing->x &&
          Level.Game.Players[i].MO.Origin.y == mthing->y)
      {
        return false;
      }
    }
    return true;
  }

  x = mthing->x;
  y = mthing->y;

  MO.bPassMobj = false;
  if (!MO.CheckPosition(vector(x, y, Actor::ONFLOORZ))) {
    MO.bPassMobj = true;
    return false;
  }
  MO.bPassMobj = true;

  if (!PlayerChunk(MO)) {
    LineSpecialLevelInfo(Level).AddPlayerCorpse(EntityEx(MO));
  }

  // spawn a teleport fog
  sec = Level.XLevel.PointInSector(vector(x, y, 0.0));
  an = float(45*(mthing->angle/45));

  Level.Spawn(TeleportFog, vector(x+20.0*cos(an), y+20.0*sin(an),
    sec->floor.TexZ+LineSpecialGameInfo(Level.Game).TeleFogHeight));

  return true;
}


//==========================================================================
//
//  SetUpPlayerClass
//
//==========================================================================
void SetUpPlayerClass () {
  if (LineSpecialGameInfo(Level.Game).bRandomClass &&
      Level.Game.deathmatch && Level.Game.PlayerClasses.Num > 1)
  {
    PClass = P_Random()%Level.Game.PlayerClasses.Num;
    if (PClass == BaseClass) PClass = (PClass+1)%Level.Game.PlayerClasses.Num;
    BaseClass = PClass;
    SB_Start();
  } else {
    PClass = BaseClass;
  }
}


//==========================================================================
//
//  ResetPlayerOnSpawn
//
//==========================================================================
void ResetPlayerOnSpawn () {
  PlayerState = PST_LIVE;
  Refire = 0;
  DamageFlash = 0.0;
  BonusFlash = 0.0;
  PoisonCount = 0;
  MorphTime = 0.0;
  ExtraLight = 0;
  FixedColourmap = 0;
  LastSectorDamageTime = 0.0;
  LastHazardTime = 0.0;
  Rain1 = none;
  Rain2 = none;

  JumpTime = 0;
  LocalQuakeHappening = 0;
  MoveDir = vector(0, 0, 0);
  HazardTime = 0;
  //Weapon ReadyWeapon;
  //Weapon PendingWeapon;  // Is none if not changing.
  //FlyHeight = 0;
  /*
  bFrozen = false; // just in case
  bTotallyFrozen = false; // just in case
  */
  bFly = false; // just in case
  PoisonCount = 0; // screen flash for poison damage
  LastPoisonTime = 0;
  Poisoner = none; // none for non-player mobjs
  PoisonerPlayer = none; // for KArena

  MorphTime = 0;  // player is morphed into something if > 0
  MorphStyle = 0;
  BlendR = 0;
  BlendG = 0;
  BlendB = 0;
  BlendA = 0;
  ChickenPeck = 0; // chicken peck countdown

  //k8: just in case
  bReloadQueued = false;
  Refire = 0;
}


//==========================================================================
//
//  GiveDefaultDeathMatchInventory
//
//  FIXME: replacements?
//
//==========================================================================
void GiveDefaultDeathMatchInventory () {
  class!Inventory  Cls;

  // give all keys in death match mode
  foreach AllClasses(Key, Cls) {
    if (!FindClassState(Cls, 'Spawn')) continue; // abstract class
    if (!AreStateSpritesPresent(FindClassState(Cls, 'Spawn'))) continue; // from a different game
    EntityEx(MO).GiveInventoryType(Cls);
  }
}


//==========================================================================
//
//  SpawnPlayer
//
//  Called when a player is spawned on the level. Most of the player
//  structure stays unchanged between levels.
//
//==========================================================================
void SpawnPlayer (mthing_t *mthing, bool Voodoo) {
  PlayerPawn PP;
  bool ResetInventory = false;
  Inventory Item;

  //print("************SpawnPlayer: 000; Voodoo=%b; PST=%d", PlayerState);
  if (PlayerState == PST_REBORN) {
    PlayerReborn();
    ResetInventory = true;
  }

  SetUpPlayerClass();

  float x = mthing->x;
  float y = mthing->y;
  float z = Actor::ONFLOORZ;
  if (PClass >= Level.Game.PlayerClasses.Num) Error("Player::SpawnPlayer : Unknown class type");

  PP = Level.Spawn(class!PlayerPawn(Level.Game.PlayerClasses[PClass]), vector(x, y, z), default, default, false);
  print("spawned player with class <%C>...", PP);
  PP.Origin.z += mthing->height;
  PP.LinkToWorld();
  PP.FriendPlayer = GetPlayerNum()+1; // players are their own friends

  // set colour translations for player sprites
  TranslStart = PP.TranslStart;
  TranslEnd = PP.TranslEnd;
  PP.Translation = (Entity::TRANSL_Player<<Entity::TRANSL_TYPE_SHIFT)+GetPlayerNum();

  // if a voodoo doll has been spawned, take it's inventory
  if (Voodoo) PP.ObtainInventory(EntityEx(MO));

  DesiredFOV = 90.0; //itof(GetCvar('FOV'));
  FOV = DesiredFOV;
  PP.Angles.yaw = float(45*(mthing->angle/45));
  PP.Player = self;
  PP.bIsPlayer = true;
  PP.Health = Health;
  MO = PP;
  Camera = PP;
  ViewHeight = PP.ViewHeight;
  ViewOrg = MO.Origin;
  ViewOrg.z += ViewHeight;
  ViewAngles = PP.Angles;
  bFixAngle = true;

  ResetPlayerOnSpawn();

  if (!Voodoo) {
    PP.Inventory = SavedInventory;
    for (Item = PP.Inventory; Item; Item = Item.Inventory) Item.Owner = MO;
    if (ResetInventory) {
      while (PP.Inventory) PP.Inventory.Destroy();
      AddDefaultInventory();
    }
  }

  // set up gun psprite
  SetupPsprites();

  if (Level.Game.deathmatch) GiveDefaultDeathMatchInventory();

  // wake up the status bar
  SB_Start();

  if (bIsBot) BotOnSpawn();

  SetClientModel();

  UpdateRevealedMap();

  if (ResetInventory) {
    Level.XLevel.StartTypedACScripts(Level::SCRIPT_Respawn, 0, 0, 0, MO, true, false);
    k8ElvenGifted = false;
  }

  // elven gifts
  //print("************SpawnPlayer: gifted=%s", (k8ElvenGifted ? "tan" : "ona"));
  if (GetCvarB('k8ElvenGift')) {
    if (!Voodoo && !k8ElvenGifted) {
      k8ElvenGifted = true; // gifts should be given only once
      if (AddElvenGift('Shotgun')) AddElvenGift('ShellBox');
      if (AddElvenGift('BDW_Rifle')) { int f; for (f = 9; f > 0; --f) AddElvenGift('Clip'); }
      ClientHudMessage("ELVEN GIFT", 'smallfont', 0, 123666, CR_ORANGE, "",
        0.5, 0.45, 0, 0,
        2.5, 0.0, 0.0);
    }
    // oops; change weapon, as voodoo doll was spawned
    if (Voodoo && k8ElvenGifted) {
      if (FindClass('BDW_Rifle') && ReadyWeapon && ReadyWeapon.bWimpyWeapon && (!PendingWeapon || PendingWeapon.bWimpyWeapon)) {
        auto rfc = FindClass('BDW_Rifle');
        for (Item = PP.Inventory; Item; Item = Item.Inventory) {
          if (Item.Class == rfc) { PendingWeapon = Weapon(Item); break; }
        }
      }
      ClientHudMessage("ELVEN GIFT", 'smallfont', 0, 123666, CR_ORANGE, "",
        0.5, 0.45, 0, 0,
        2.5, 0.0, 0.0);
    }
  }
}


//===========================================================================
//
// AddElvenGift
//
//===========================================================================
final bool AddElvenGift (name Klass) {
  class!Thinker th = class!Thinker(FindClass(Klass));
  if (th) {
    Actor act = Actor(Level.Spawn(th));
    if (!act) return false;
    if (Klass == 'BDW_Rifle') {
      Weapon(act).AmmoGive2 = 31;
      PendingWeapon = Weapon(act);
    } else if (Klass == 'BDW_Shotgun' || (Klass == 'Shotgun' && FindClass('BDW_Shotgun'))) {
      Weapon(act).AmmoGive2 = 8;
    }
    act.TouchSpecial(EntityEx(MO), true);
    if (Klass == 'BDW_Rifle' && ReadyWeapon && ReadyWeapon.bWimpyWeapon && (!PendingWeapon || PendingWeapon.bWimpyWeapon)) {
      PendingWeapon = Weapon(act);
    }
    return true;
  } else {
    return false;
  }
}


//===========================================================================
//
//  AddDefaultInventory
//
//===========================================================================
void AddDefaultInventory () {
  HexenArmor HArmor = Level.Spawn(HexenArmor, default, default, default, false);
  HArmor.AttachToOwner(EntityEx(MO));
  HArmor.Slots[4] = PlayerPawn(MO).HexenArmor[0];
  HArmor.SlotsIncrement[0] = PlayerPawn(MO).HexenArmor[1];
  HArmor.SlotsIncrement[1] = PlayerPawn(MO).HexenArmor[2];
  HArmor.SlotsIncrement[2] = PlayerPawn(MO).HexenArmor[3];
  HArmor.SlotsIncrement[3] = PlayerPawn(MO).HexenArmor[4];

  BasicArmor BArmor = Level.Spawn(BasicArmor, default, default, default, false);
  BArmor.Amount = 0;
  BArmor.AttachToOwner(EntityEx(MO));

  //print("AddDefaultInventory: MO=`%C`", MO);
  foreach (auto i; 0..EntityEx(MO).DropItemList.length) {
    class!Entity tp = EntityEx(MO).DropItemList[i].Type;
    class!Entity tprepl = none;
    if (tp) tprepl = class!Entity(GetClassReplacement(tp));
    //print("  i=%d; type=`%C`(%C); name=`%s`; amount=%s; chance=%s", i, tp, tprepl, EntityEx(MO).DropItemList[i].TypeName, EntityEx(MO).DropItemList[i].Amount, EntityEx(MO).DropItemList[i].Chance);
    if (!tp) continue;
    Inventory Item = Inventory(Level.Spawn(tprepl, default, default, default, false));
    Item.bIgnoreSkill = true;
    if (EntityEx(MO).DropItemList[i].Amount > 0) Item.Amount = EntityEx(MO).DropItemList[i].Amount;
    if (Weapon(Item)) {
      // for better control empty weapon's ammo
      Weapon(Item).AmmoGive1 = 0;
      Weapon(Item).AmmoGive2 = 0;
    }
    if (!Item.TryPickup(EntityEx(MO))) {
      Item.Destroy();
    } else if (Weapon(Item) && Weapon(Item).CheckAmmo(Weapon::FIRE_Either, false)) {
      SetWeapon(Weapon(Item));
    }
  }
}


//==========================================================================
//
//  PlayerReborn
//
//  Called after a player dies almost everything is cleared and initialised
//
//==========================================================================
void PlayerReborn () {
  // clear player struct
  DoClearPlayer();

  PClass = BaseClass;

  // set initial data
  bUseDown = true; // don't do anything immediately
  bAttackDown = true;
  bReloadQueued = false;
  Refire = 0;
  PlayerState = PST_LIVE;
  Health = GetRebornHealth();
  LocalQuakeHappening = 0;
}


//==========================================================================
//
//  DoClearPlayer
//
//==========================================================================
void DoClearPlayer () {
  ClearPlayer();
}


//==========================================================================
//
//  PlayerBeforeExitMap
//
//  Called when a player completes a level, but before going to imis.
//  Not called for intermissions.
//
//==========================================================================
override void PlayerBeforeExitMap () {
}


//==========================================================================
//
//  PlayerExitMap
//
//  Called when a player completes a level.
//
//==========================================================================
override void PlayerExitMap (bool clusterChange) {
  Inventory Item;

  if (clusterChange && !Level.bClusterHub && !Level.bKeepFullInventory) {
    for (Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory) {
      if (Item.bInvBar && Item.Amount > Item.InterHubAmount) {
        Item.Amount = Item.InterHubAmount;
      }
    }
  }

  // strip all current powers
  for (Item = EntityEx(MO).Inventory; Item; ) {
    Inventory Next = Item.Inventory;
    if (Powerup(Item) && (Level.Game.deathmatch || clusterChange || !Item.bHubPower)) {
      Item.Destroy();
    }
    Item = Next;
  }

  if (clusterChange) {
    // entering new cluster
    // some items are stripped
    for (Item = EntityEx(MO).Inventory; Item; ) {
      Inventory Next = Item.Inventory;
      if (Item.bInterHubStrip /*&& Item.InterHubAmount < 1*/) {
        Item.Destroy();
      }
      Item = Next;
    }
  }

  if (MorphTime) {
    SetWeapon(Weapon(Actor(MO).Tracer)); // restore weapon
    MorphTime = 0.0;
  }

  MO.Angles.pitch = 0.0;
  MO.RenderStyle = Entity::STYLE_Normal;
  MO.Alpha = 1.0;
  EntityEx(MO).bShadow = false; // cancel invisibility
  ExtraLight = 0;     // cancel gun flashes
  FixedColourmap = 0;   // cancel ir gogles
  DamageFlash = 0.0;    // no palette changes
  BonusFlash = 0.0;
  PoisonCount = 0;
  BlendR = 0.0;
  BlendG = 0.0;
  BlendB = 0.0;
  BlendA = 0.0;
  Rain1 = none;
  Rain2 = none;
  //k8: just in case
  bReloadQueued = false;
  Refire = 0;
  LocalQuakeHappening = 0;
}


//==========================================================================
//
//  InventoryLeft
//
//==========================================================================
final void InventoryLeft () {
  if (!bInventoryAlwaysOpen) {
    if (!InventoryTime) {
      InventoryTime = 5.0;
      return;
    }
    InventoryTime = 5.0;
  }

  if (InvPtr) {
    Inventory Prev = InvPtr.PrevInv();
    if (Prev) {
      InvPtr = Prev;
      AdjustInvFirst();
    }
  }
}


//==========================================================================
//
//  InventoryRight
//
//==========================================================================
final void InventoryRight () {
  if (!bInventoryAlwaysOpen) {
    if (!InventoryTime) {
      InventoryTime = 5.0;
      return;
    }
    InventoryTime = 5.0;
  }

  if (InvPtr) {
    Inventory Next = InvPtr.NextInv();
    if (Next) {
      InvPtr = Next;
      AdjustInvFirst();
    }
  }
}


//==========================================================================
//
//  InventoryUse
//
//==========================================================================
final void InventoryUse () {
  // flag to denote that it's okay to use an artifact
       if (InventoryTime) InventoryTime = 0.0;
  else if (InvPtr) EntityEx(MO).UseInventory(InvPtr);
}


//==========================================================================
//
//  InventoryTick
//
//==========================================================================
final void InventoryTick (float deltaTime) {
  // turn inventory off after a certain amount of time
  if (InventoryTime) {
    InventoryTime -= deltaTime;
    if (InventoryTime <= 0.0) InventoryTime = 0.0;
  }
  if (ArtifactFlash) --ArtifactFlash;
}


//==========================================================================
//
//  AdjustInvFirst
//
//==========================================================================
final void AdjustInvFirst () {
  Inventory Item;

  if (!InvPtr) {
    InvFirst = none;
    return;
  }

  // count how many items are following the current one, also make sure
  // that first is not after this one
  int NumFollowing = 0;
  for (Item = InvPtr.NextInv(); Item; Item = Item.NextInv()) {
    ++NumFollowing;
    if (InvFirst == Item) InvFirst = InvPtr;
  }

  int FirstOffs = 0;
  for (Item = InvPtr; Item && Item != InvFirst; Item = Item.PrevInv()) ++FirstOffs;

  while (FirstOffs > InvSize) {
    InvFirst = InvFirst.NextInv();
    --FirstOffs;
  }

  while (NumFollowing+FirstOffs < InvSize && InvFirst.PrevInv()) {
    InvFirst = InvFirst.PrevInv();
    ++FirstOffs;
  }
}


//==========================================================================
//
//  InventoryThrow
//
//==========================================================================
final EntityEx InventoryThrow () {
  if (!InvPtr) return none;
  return EntityEx(MO).DropInventory(InvPtr);
}


//==========================================================================
//
//  UseFlyPower
//
//==========================================================================
final void UseFlyPower () {
  PlayerUseArtifactType(ArtiFly);
}


//==========================================================================
//
//  PlayerUseArtifactType
//
//==========================================================================
final void PlayerUseArtifactType (class!Inventory arti) {
  Inventory Item = EntityEx(MO).FindInventory(arti);
  if (Item) EntityEx(MO).UseInventory(Item);
}


//==========================================================================
//
//  PlayerNextArtifact
//
//==========================================================================
final void PlayerNextArtifact () {
  if (!InvPtr) return;
  Inventory NewPtr = InvPtr.PrevInv();
  if (!NewPtr) {
    NewPtr = InvPtr;
    while (NewPtr.NextInv()) NewPtr = NewPtr.NextInv();
  }
  InvPtr = NewPtr;
  AdjustInvFirst();
}


//==========================================================================
//
//  DeathPlayerTick
//
//  Fall on your face when dying. Decrease POV height to floor height.
//
//==========================================================================
final void DeathPlayerTick (float deltaTime) {
  MovePsprites(deltaTime);

  if (MO.WaterLevel > 1) MO.Velocity.z = -60.0; // drift towards bottom

  onground = (MO.Origin.z <= MO.FloorZ);

  if (PlayerChunk(MO)) {
    // flying bloody skull or flying ice chunk
    ViewHeight = 6.0;
    DeltaViewHeight = 0.0;
    //damagecount = 20;
    if (onground) {
#ifdef FIXME
      if (lookdir < 60) {
        int lookDelta = (60-lookdir)/8;
             if (lookDelta < 1 && (level->tictime&1)) lookDelta = 1;
        else if (lookDelta > 6) lookDelta = 6;
        lookdir += lookDelta;
      }
#endif
    }
  } else if (Actor(MO).DamageType != 'Ice') {
    // fall to ground (if not frozen)
    DeltaViewHeight = 0.0;
    if (ViewHeight > 6.0) ViewHeight -= 35.0*deltaTime;
    if (ViewHeight < 6.0) ViewHeight = 6.0;
#ifdef FIXME
         if (lookdir > 0) lookdir -= 6;
    else if (lookdir < 0) lookdir += 6;
    if (abs(lookdir) < 6) lookdir = 0;
#endif
  }
  CalcHeight(deltaTime);

  if (Attacker && Attacker != MO) {
    // watch killer
    float delta;
    int dir = EntityEx(MO).FaceActor(EntityEx(Attacker), delta);
    if (delta < 10.0) {
      // looking at killer, so fade damage and poison counters
      if (DamageFlash) {
        DamageFlash -= deltaTime;
        if (DamageFlash <= 0.0) DamageFlash = 0.0;
      }
      if (PoisonCount) --PoisonCount;
    }
    delta = fmin(5.0, delta/8.0);
    if (dir) {
      // turn clockwise
      MO.Angles.yaw += delta;
    } else {
      // turn counter clockwise
      MO.Angles.yaw -= delta;
    }
  } else if (DamageFlash) {
    DamageFlash -= deltaTime;
    if (DamageFlash <= 0.0) DamageFlash = 0.0;
  } else if (PoisonCount) {
    --PoisonCount;
  }

  if (CheckForRespawn(deltaTime)) {
    InvPtr = none;
    InvFirst = none;
    PlayerState = PST_REBORN;
  }
}


//==========================================================================
//
//  CheckForRespawn
//
//==========================================================================
bool CheckForRespawn (float deltaTime) {
  return !!(Buttons&BT_USE);
}


//==========================================================================
//
//  checkDoHealthAccumBoost
//
//  this should be called after health < maxhealth checked
//  k8HealthAccum_Amount should be checked and set too
//
//==========================================================================
bool checkDoHealthAccumBoost () {
  if (k8HealthAccum_Amount < 1) return false;
  // can boost?
  int boostPoints = GetCvarI('k8HealthAccum_BoostPoints');
  if (!boostPoints) return false;
  // hit boost limit?
  int boostLow = GetCvarI('k8HealthAccum_BoostLow');
  if (Health >= boostLow) return false;
  // boost cooldowned?
  float boostCooldownTime = fmax(0, GetCvarF('k8HealthAccum_BoostCooldown'));
  if (k8HealthAccum_LastBoostTime+boostCooldownTime > MO.XLevel.Time) return false;
  // calculate boost amount
  int newh = (boostPoints < 0 ? -boostPoints : Health+boostPoints);
  if (newh <= Health) return false;
  int relh = min(k8HealthAccum_Amount, newh-Health);
  if (relh < 1) return false; // just in case
  // perform health boost
  if (GetCvarB('k8HealthAccum_MessagesBoost')) {
    if (boostPoints < 0) cprint("Health boosted to %d", Health+relh); else cprint("Health boosted by %d", relh);
  }
  k8HealthAccum_LastBoostTime = MO.XLevel.Time;
  k8HealthAccum_Amount -= relh;
  Health += relh;
  MO.Health = Health; //k8: we need this for UI
  return true;
}


//==========================================================================
//
//  checkDoHealthAccumRegen
//
//  this should be called after health < maxhealth checked
//  k8HealthAccum_Amount should be checked and set too
//
//==========================================================================
bool checkDoHealthAccumRegen () {
  if (k8HealthAccum_Amount < 1) return false;
  // can regen?
  int regenPoints = GetCvarI('k8HealthAccum_RegenPoints');
  if (regenPoints < 1) return false;
  // hit regen limit?
  int maxhealth = GetMaxHealth();
  if (Health >= maxhealth) return false;
  int regenLow = GetCvarI('k8HealthAccum_RegenLow');
  if (regenLow > 0 && Health >= regenLow) return false; // player is not hurt enough
  // regen cooldowned?
  float regenRateTime = fmax(0, GetCvarF('k8HealthAccum_RegenRate'));
  /*
  print("k8HealthAccum_Amount=%s; Health=%s; rp=%s; max=%s; rate=%s; last=%s; time=%s",
    k8HealthAccum_Amount, Health, regenPoints, maxhealth, regenRateTime, k8HealthAccum_LastRegenTime, MO.XLevel.Time);
  */
  if (k8HealthAccum_LastRegenTime+regenRateTime > MO.XLevel.Time) return false;
  // check for boost cooldown too
  float boostCooldownTime = fmax(0, GetCvarF('k8HealthAccum_BoostCooldown'));
  if (k8HealthAccum_LastBoostTime+boostCooldownTime > MO.XLevel.Time) return false;
  // calculate regen amount
  int newh = Health+regenPoints;
  int relh = min(k8HealthAccum_Amount, newh-Health);
  if (relh < 1) return false; // just in case
  // perform health regen
  if (GetCvarB('k8HealthAccum_MessagesRegen')) cprint("Health regenerated by %d", relh);
  k8HealthAccum_LastRegenTime = MO.XLevel.Time;
  k8HealthAccum_Amount -= relh;
  Health += relh;
  MO.Health = Health; //k8: we need this for UI
  return true;
}


//==========================================================================
//
//  doHealthAccumHealthPickup
//
//  returns `true` if Health Accumulator (or player) consumed the item
//  must increase player's health if necessary
//  should never be called with `none`
//
//==========================================================================
bool doHealthAccumHealthPickup (Health item, EntityEx toucher) {
  if (!item) return false; // meh, just in case
  int amount = item.Amount;
  int itemhealthlimit = item.MaxAmount;
  // is this small health bonus (like bottle)?
  if (itemhealthlimit) {
    // you should be able to pick up health bonuses even at full health
    // note that health bonuses cannot be accumulated
    // increare health
    Health = min(Health+amount, itemhealthlimit);
    if (toucher) toucher.Health = Health;
    return true; // eaten
  }
  // normal health pickup
  int plrmaxhealth = GetMaxHealth();
  //print("Health=%s; maxhealth=%s; amount=%s; accum=%s; acclimit=%s; accumon=%s", Health, plrmaxhealth, amount, k8HealthAccum_Amount, GetCvarI('k8HealthAccum_Max'), GetCvarB('k8HealthAccum_Enabled'));
  // too healthy?
  if (Health >= plrmaxhealth) {
    // accumulate everything
    if (!GetCvarB('k8HealthAccum_Enabled')) return false; // Health Accumulator is not active
    int accMax = max(0, GetCvarI('k8HealthAccum_Max'));
    if (!accMax) return false; // cannot pickup
    if (k8HealthAccum_Amount >= accMax) return false; // cannot pickup
    // do full accumulation
    // (don't bother checking, player tick will check and clamp HA amount for us)
    k8HealthAccum_Amount += amount;
    if (GetCvarB('k8HealthAccum_MessagesAccumed')) cprint("Accumulated %d health.", amount);
  } else {
    // we should heal the player, and accumulate the rest (if anything)
    int newh = min(plrmaxhealth, Health+amount);
    int relh = newh-Health;
    // accumulate leftovers
    if (relh < amount && GetCvarB('k8HealthAccum_Enabled')) {
      int accMax = max(0, GetCvarI('k8HealthAccum_Max'));
      if (accMax) {
        // (don't bother checking, player tick will check and clamp HA amount for us)
        k8HealthAccum_Amount += amount-relh;
        if (GetCvarB('k8HealthAccum_MessagesAccumed')) cprint("Accumulated %d health.", amount-relh);
      }
    }
    // heal player
    Health = newh;
    if (toucher) toucher.Health = Health;
  }
  // processed
  return true;
}


//==========================================================================
//
//  PlayerTick
//
//==========================================================================
override void PlayerTick (float deltaTime) {
  if (bIsBot) {
    if (Level.bFrozen && !(Cheats&CF_TIMEFREEZE)) BotTick(deltaTime);
  }

  /*
  if (!MO) {
    print("playertick(%C): %f", self, deltaTime);
    print("  playertick(%C): MO=%C", self, MO);
    print("  playertick(%C): MO.XLevel=%C", self, MO.XLevel);
  }
  */

  //print("***000: BUTTONS: 0x%08x; old=0x%08x", Buttons, OldButtons);

  // Health Accumulator
  if (/*!(Cheats&CF_TIMEFREEZE) &&*/ GetCvarB('k8HealthAccum_Enabled')) {
    int accMax = GetCvarI('k8HealthAccum_Max');
    int accAmount = 0;
    if (accMax > 0) {
      //k8HealthAccum_LastRegenTime = 0;
      //k8HealthAccum_LastBoostTime = 0;
      k8HealthAccum_Amount = max(0, min(k8HealthAccum_Amount, accMax)); // sanitize
      //print("k8HealthAccum_Amount=%s; bt=%s; rt=%s; lt=%s; tb=%s; tr=%s", k8HealthAccum_Amount, MO.XLevel.Time-k8HealthAccum_LastBoostTime, MO.XLevel.Time-k8HealthAccum_LastRegenTime, MO.XLevel.Time, k8HealthAccum_LastBoostTime, k8HealthAccum_LastRegenTime);
      if (!checkDoHealthAccumBoost()) checkDoHealthAccumRegen();
    } else {
      k8HealthAccum_Amount = 0;
    }
  } else {
    k8HealthAccum_Amount = 0;
  }


  if ((MO.XLevel.TicTime%(3*35) == 0) && (Cheats& CF_REGENERATION) && Health > 0) {
    if (EntityEx(MO).GiveBody(5) && !GetSoundPlayingInfo(MO, GetSoundID('*regenerate'))) {
      MO.PlaySound('*regenerate', CHAN_VOICE);
    }
  }

  if (Actor(MO).bJustAttacked) {
    ForwardMove = 100.0;
    SideMove = 0.0;
    Actor(MO).bJustAttacked = false;
  }

  // you can only press use while totally frozen
  if (bTotallyFrozen || (Level.bFrozen && !(Cheats&CF_TIMEFREEZE))) {
    Buttons &= BT_USE;
    Impulse = 0;
    ViewAngles = MO.Angles;
    ForwardMove = 0.0;
    SideMove = 0.0;
    FlyMove = 0.0;
  } else if (bFrozen) {
    ForwardMove = 0.0;
    SideMove = 0.0;
    FlyMove = 0.0;
  }

  WorldTimer += deltaTime;
  InventoryTick(deltaTime);

  if (PlayerState == PST_DEAD) {
    DeathPlayerTick(deltaTime);
    return;
  }

  // copy view angles
  if (MO == Camera) MO.Angles = ViewAngles;

  if (JumpTime) {
    JumpTime = fmax(0.0, JumpTime-deltaTime);
  }

  if (MorphTime) PlayerPawn(MO).MorphPlayerThink();

  // move around
  // ReactionTime is used to prevent movement for a bit after a teleport
  if (Actor(MO).ReactionTime) {
    Actor(MO).ReactionTime -= deltaTime;
    if (Actor(MO).ReactionTime <= 0.0) Actor(MO).ReactionTime = 0.0;
    if (Actor(MO).bWaterJump) WaterJump();
  } else {
    if (MO.WaterLevel > 1) WaterMove(deltaTime); else MovePlayer(deltaTime);
    if (EntityEx(MO).FindInventory(PowerSpeed) &&
        !(Level.XLevel.TicTime&1) && Length(MO.Velocity) > 12.0*35.0)
    {
      SpawnSpeedEffect();
    }
  }

  CalcHeight(deltaTime);

  if (MO.Sector->special || MO.Sector->Damage) PlayerInSpecialSector(deltaTime);

  PlayerOnSpecialFlat(Actor(MO).GetFloorType());
  PlayerInContents(deltaTime);

  if (MO.Velocity.z <= -35.0*35.0 && MO.Velocity.z >= -40.0*35.0 &&
      !MorphTime && MO.WaterLevel == 0 &&
      !GetSoundPlayingInfo(MO, GetSoundID('*falling')))
  {
    MO.PlaySound('*falling', CHAN_VOICE);
  }

  // check for weapon change (and other impulse commands)
  if (Impulse) PlayerImpulse();

  // check for use
  if (Buttons&BT_USE) {
    if (!bUseDown) {
      EntityEx(MO).UseLines(USERANGE, USETHINGRANGE, '*usefail');
      bUseDown = true;
    }
  } else {
    //if (bUseDown) print("***USE GOES UP!");
    bUseDown = false;
  }

  if (!ReadyWeapon && PendingWeapon) {
    SetWeapon(PendingWeapon);
    BringUpWeapon();
  }

  // morph counter
  if (MorphTime) {
    if (ChickenPeck) {
      // chicken attack counter
      ChickenPeck -= 3;
    }
    MorphTime -= deltaTime;
    if (MorphTime <= 0.0) {
      // attempt to undo the chicken/pig
      MorphTime = 0.0;
      UndoPlayerMorph(false, self);
    }
  }

  // cycle psprites
  MovePsprites(deltaTime);

  // counters
  if (PoisonCount && Level.XLevel.Time-LastPoisonTime >= 0.5) {
    PoisonCount -= 5;
    if (PoisonCount < 0) PoisonCount = 0;
    LastPoisonTime = Level.XLevel.Time;
    Actor(MO).PoisonDamage(Poisoner, Poisoner, 1, true);
  }

  if (DamageFlash) {
    DamageFlash -= deltaTime;
    if (DamageFlash <= 0.0) DamageFlash = 0.0;
  }

  if (BonusFlash) {
    BonusFlash -= deltaTime;
    if (BonusFlash <= 0.0) BonusFlash = 0.0;
  }

  if (HazardTime) {
    HazardTime -= deltaTime;
    if (HazardTime <= 0.0) HazardTime = 0.0;
    if (Level.XLevel.Time-LastHazardTime >= 32.0/35.0 && HazardTime > 16.0) {
      LastHazardTime = Level.XLevel.Time;
      Actor(MO).Damage(none, none, 5);
    }
  }

  // [RH] Zoom the player's FOV
  float desired = DesiredFOV; // default player FOV
  // adjust FOV using on the currently held weapon
  if (PlayerState != PST_DEAD && // no adjustment while dead
      ReadyWeapon && // no adjustment if no weapon
      ReadyWeapon.FOVScale != 0.0) // no adjustment if the adjustment is zero
  {
    // a negative scale is used to prevent G_AddViewAngle/G_AddViewPitch
    // from scaling with the FOV scale
    desired *= fabs(ReadyWeapon.FOVScale);
  }

  if (FOV != desired) {
    if (fabs(FOV-desired) < 7.0) {
      FOV = desired;
    } else {
      float zoom = FMax(7.0, fabs(FOV-desired)*0.025);
      if (FOV > desired) FOV = FOV-zoom; else FOV = FOV+zoom;
    }
    SetFOV(int(FOV));
  }
}


//==========================================================================
//
//  SetViewPos
//
//==========================================================================
final override void SetViewPos () {
  // just in a case camera entity has been destroyed
  if (!Camera) Camera = MO;

  if (MO != Camera) {
    ViewOrg = Camera.Origin;
    ViewOrg.z += EntityEx(Camera).CameraHeight;
    ViewAngles = Camera.Angles;
  } else {
    ViewOrg.x = MO.Origin.x;
    ViewOrg.y = MO.Origin.y;

    if (LocalQuakeHappening) {
      float intensity = float(LocalQuakeHappening);
      ViewOrg.x += (Random()-0.5)*(intensity*4.0);
      ViewOrg.y += (Random()-0.5)*(intensity*4.0);
    }

    if (PlayerState != PST_DEAD) {
      ViewAngles = MO.Angles;
    } else {
      ViewAngles.yaw = MO.Angles.yaw;
      ViewAngles.pitch = MO.Angles.pitch;
    }

    if (MorphTime && ChickenPeck) {
      // set chicken attack view position
      ViewOrg.x += float(ChickenPeck)*cos(MO.Angles.yaw);
      ViewOrg.y += float(ChickenPeck)*sin(MO.Angles.yaw);
    }
  }

  PaletteFlash();

  ClientSetViewOrg(ViewOrg.x, ViewOrg.y, ViewOrg.z);

  if (Level.XLevel.Zones.length && Camera.Sector) {
    SoundEnvironment = Level.XLevel.Zones[Camera.Sector->Zone];
  } else {
    SoundEnvironment = 0;
  }

  if (!SoundEnvironment) {
    if (Camera.WaterLevel >= 3) {
      // under water
      SoundEnvironment = 0x1600;
    } else {
      // generic
      SoundEnvironment = 1;
    }
  }
}


//==========================================================================
//
//  ClientTick
//
//==========================================================================
override void ClientTick (float deltaTime) {
  bAutoAim = !!GetCvar('autoaim');
}


//==========================================================================
//
//  AdjustPlayerAngle
//
//==========================================================================
final void AdjustPlayerAngle (EntityEx AimTarget) {
  float angle;
  float difference;

  angle = atan2(AimTarget.Origin.y-MO.Origin.y, AimTarget.Origin.x-MO.Origin.x);
  difference = AngleMod180(angle-MO.Angles.yaw);
  if (fabs(difference) > 5.0) {
    MO.Angles.yaw += difference > 0.0 ? 5.0 : -5.0;
  } else {
    MO.Angles.yaw = angle;
  }
  bFixAngle = true;
}


//==========================================================================
//
//  UndoPlayerMorph
//
//==========================================================================
final bool UndoPlayerMorph (bool Force, PlayerEx Activator) {
  Actor A;

  if (EntityEx(MO).bInvulnerable && (self != Activator || !(MorphStyle&EntityEx::MORPH_WHENINVULNERABLE))) {
    // immune when invulnerable unless this is something we initiated.
    // if the WORLD is the initiator, the same player should be given
    // as the activator; WORLD initiated actions should always succeed.
    return false;
  }

  int CorrectWeapon = MorphStyle&EntityEx::MORPH_LOSEACTUALWEAPON;

  MO.UnlinkFromWorld();
  if (BaseClass >= Level.Game.PlayerClasses.Num) Error("UndoPlayerMorph: Unknown class type");

  A = Level.Spawn(class!PlayerPawn(Level.Game.PlayerClasses[BaseClass]), MO.Origin, default, default, false);
  if (!Force && !A.TestLocation()) {
    // didn't fit
    A.Destroy();
    MO.LinkToWorld();
    MorphTime = 2.0;
    return false;
  }

  MO.LinkToWorld();
  // set colour translation
  A.Translation = (Entity::TRANSL_Player<<Entity::TRANSL_TYPE_SHIFT)+GetPlayerNum();
  A.Angles = MO.Angles;
  ViewHeight = PlayerPawn(A).ViewHeight;
  DeltaViewHeight = 0.0;
  A.Player = self;
  A.bIsPlayer = true;
  A.ReactionTime = 0.5;
  if (MO.bFly) {
    A.bFly = true;
    A.bNoGravity = true;
  }
  A.bShadow = EntityEx(MO).bShadow;
  A.bGhost = EntityEx(MO).bGhost;
  A.ObtainInventory(EntityEx(MO));
  if (MO.TID && (MorphStyle&EntityEx::MORPH_NEWTIDBEHAVIOUR)) A.SetTID(MO.TID);
  MorphTime = 0.0;
  MorphStyle = 0;
  Inventory Pw = EntityEx(MO).FindInventory(PowerWeaponLevel2);
  if (Pw) Pw.Destroy();
  A.Health = GetRebornHealth();
  Health = A.Health;
  PClass = BaseClass;
  Weapon OldWeapon = ReadyWeapon;
  PostMorphWeapon(Weapon(Actor(MO).Tracer));
  if (CorrectWeapon) {
    // better "lose morphed weapon" semantics
    class!Weapon MorphWeapon = PlayerPawn(MO).MorphWeapon;
    if (MorphWeapon) {
      Weapon OrigWpn = Weapon(EntityEx(MO).FindInventory(MorphWeapon));
      if (OrigWpn && OrigWpn.bGivenAsMorphWeapon) {
        // you don't get to keep your morphed weapon
        OrigWpn.Destroy();
      }
    }
  } else {
    if (OldWeapon) OldWeapon.Destroy();
  }

  Level.Spawn(UnmorphFlash ? UnmorphFlash : class!Actor(TeleportFog),
    MO.Origin+vector(20.0*cos(MO.Angles.yaw),
    20.0*sin(MO.Angles.yaw),
    LineSpecialGameInfo(Level.Game).TeleFogHeight));

  MO.SetState(MO.FindState('FreeTargMobj'));
  MO = A;
  Camera = A;
  PlayerUnmorphed();
  return true;
}


//===========================================================================
//
//  ActivateMorphWeapon
//
//===========================================================================
final void ActivateMorphWeapon () {
  class!Weapon WpnClass = PlayerPawn(MO).MorphWeapon;
  Weapon Wpn;
  if (WpnClass) {
    Wpn = Level.Spawn(WpnClass);
    Wpn.bGivenAsMorphWeapon = true;
  } else {
    // couldn't find any weapons, use the default weapon for this player (from initial inventory)
    foreach (int i; 0..EntityEx(MO).DropItemList.Num) {
      Inventory Item = Inventory(Level.Spawn(GetClassReplacement(EntityEx(MO).DropItemList[i].Type), default, default, default, false));
      if (EntityEx(MO).DropItemList[i].Amount > 0) {
        Item.Amount = EntityEx(MO).DropItemList[i].Amount;
      }
      if (Weapon(Item)) {
        Wpn = Weapon(Item);
        WpnClass = class!Weapon(Weapon(Item).Class);
      }
    }
  }
  if (!Wpn.TryPickup(EntityEx(MO))) Wpn.Destroy();

  SetWeapon(Weapon(EntityEx(MO).FindInventory(WpnClass)));
  SetViewObject(ReadyWeapon);
  if (ReadyWeapon) {
    SetViewState(ps_weapon, ReadyWeapon.GetReadyState());
  } else {
    SetViewState(ps_weapon, none);
  }
  ViewStates[ps_weapon].SY = Weapon::WEAPONTOP;
}


//===========================================================================
//
//  PostMorphWeapon
//
//===========================================================================
final void PostMorphWeapon (Weapon weapon) {
  SetWeapon(weapon);
  ViewStates[ps_weapon].SY = Weapon::WEAPONBOTTOM;
  SetViewObject(ReadyWeapon);
  if (ReadyWeapon) {
    SetViewState(ps_weapon, ReadyWeapon.GetUpState());
  } else {
    SetViewState(ps_weapon, none);
  }
}


//==========================================================================
//
//  AddVisitedMap
//
//==========================================================================
final void AddVisitedMap (name Map) {
  foreach (auto i; 0..MAX_MAPS_VISITED) {
    if (MapsVisited[i] == Map) return;
    if (!MapsVisited[i]) { MapsVisited[i] = Map; return; }
  }
}


//==========================================================================
//
//  GetMaxHealth
//
//==========================================================================
int GetMaxHealth () {
  int Max = (PlayerPawn(MO).MaxHealth > 0 ? PlayerPawn(MO).MaxHealth :
    Level.CompatDehHealth ? MAXHEALTH :
    HealthBonus.default.MaxAmount/2)+Stamina;
  if (MorphTime) {
    if (MorphStyle&EntityEx::MORPH_FULLHEALTH) {
      if (!(MorphStyle&EntityEx::MORPH_ADDSTAMINA)) Max -= Stamina;
    } else {
      Max = MAXMORPHHEALTH;
      if (MorphStyle&EntityEx::MORPH_ADDSTAMINA) Max += Stamina;
    }
  }
  return Max;
}


//==========================================================================
//
//  Cheat_Jumper
//
//==========================================================================
override void Cheat_Jumper () {
  Cheats ^= CF_HIGHJUMP;
  if (Cheats&CF_HIGHJUMP) cprint("High Jump Cheat is On"); else cprint("High Jump Cheat is Off");
}


//==========================================================================
//
//  Cheat_ShooterKing
//
//==========================================================================
override void Cheat_ShooterKing () {
  Cheats ^= CF_DOUBLEFIRINGSPEED;
  if (Cheats&CF_DOUBLEFIRINGSPEED) cprint("Double Firing Speed Cheat is On"); else cprint("Double Firing Speed Cheat is Off");
}


//==========================================================================
//
//  Cheat_Regeneration
//
//==========================================================================
override void Cheat_Regeneration () {
  Cheats ^= CF_REGENERATION;
  if (Cheats&CF_REGENERATION) cprint("Regeneration Cheat is On"); else cprint("Regeneration Cheat is Off");
}


//==========================================================================
//
//  Cheat_Regeneration
//
//==========================================================================
override void Cheat_DumpInventory () {
  print("=== inventory of player (%C : %C) ===", self, self.MO);
  for (Inventory Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory) {
    print("  %C: amount=%s", Item, Item.Amount);
  }
}


//==========================================================================
//
//  Cheat_God
//
//==========================================================================
override void Cheat_God () {
  Cheats ^= CF_GODMODE;
  if (Cheats&CF_GODMODE) {
    if (LineSpecialGameInfo(Level.Game).GOD_HEALTH) {
      if (MO) MO.Health = LineSpecialGameInfo(Level.Game).GOD_HEALTH;
      Health = LineSpecialGameInfo(Level.Game).GOD_HEALTH;
      cprint("Degreelessness Mode On");
    } else {
      cprint("GOD MODE ON");
    }
  } else {
    if (LineSpecialGameInfo(Level.Game).GOD_HEALTH) {
      cprint("Degreelessness Mode Off");
    } else {
      cprint("GOD MODE OFF");
    }
  }
}


//==========================================================================
//
//  Cheat_Buddha
//
//==========================================================================
override void Cheat_Buddha () {
  Cheats ^= CF_BUDDHA;
  if (Cheats&CF_BUDDHA) cprint("Buddha Mode On"); else cprint("Buddha Mode Off");
}


//==========================================================================
//
//  Cheat_Summon
//
//==========================================================================
override void Cheat_Summon () {
  //print("SUMMON: argc=%d", Cmd_GetArgC());
  if (!MO.bIsPlayer || !Level) return;
  auto plr = PlayerEx(MO.Player);
  if (!plr) return;

  if (Cmd_GetArgC() != 2) {
    cprint("Summon: class name expected");
    return;
  }

  // find which type to spawn
  auto moClass = class!EntityEx(FindClassLowerCase(name(Cmd_GetArgV(1))));
  if (!moClass) {
    // Can't find thing type
    print("Summon: unknown class '%s'", Cmd_GetArgV(1));
    return;
  }

  //writeln("summon 0: ", GetClassName(moClass));
  moClass = GetClassReplacement(moClass);
  //writeln("summon 1: ", GetClassName(moClass));

  auto spwspate = FindClassState(moClass, 'Spawn');

  // if actor has no spawn state, we cannot summon it
  if (!spwspate) {
    print("Summon: class '%s' has no spawn state", Cmd_GetArgV(1));
    return;
  }

  // if actor has no spawn sprites, we cannot summon it
  if (!AreStateSpritesPresent(spwspate)) {
    print("Summon: class '%s' has no frames", Cmd_GetArgV(1));
    return;
  }

  //if (Level.Game.nomonsters && moClass.default.bMonster) return;

  // spawn it
  TAVec ang = MO.Angles; //vector(plr.pitch, plr.yaw, plr.roll);
  TVec dir;
  AngleVector(ang, out dir);
  TVec dst = MO.Origin+84*dir;
  Level.Spawn(moClass, dst); // optional TAVec AAngles, optional mthing_t *mthing, optional bool AllowReplace
}


//==========================================================================
//
//  Cheat_NoClip
//
//==========================================================================
override void Cheat_NoClip () {
  Cheats ^= CF_NOCLIP;
  if (Cheats&CF_NOCLIP) {
    MO.bColideWithThings = false;
    MO.bColideWithWorld = false;
    cprint("No Clipping Mode ON");
  } else {
    MO.bColideWithThings = true;
    MO.bColideWithWorld = true;
    cprint("No Clipping Mode OFF");
  }
}


//==========================================================================
//
//  Cheat_KillAll
//
//==========================================================================
override void Cheat_KillAll () {
  cprint("%d MONSTERS KILLED", LineSpecialLevelInfo(Level).P_Massacre());
}


//==========================================================================
//
//  Cheat_NoWeapons
//
//==========================================================================
override void Cheat_NoWeapons () {
  if (MorphTime) return;

  // find weakest weapon
  Inventory Item;
  Weapon Weakest = none;
  for (Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory) {
    if (Weapon(Item) && (!Weakest || Weakest.SelectionOrder < Weapon(Item).SelectionOrder)) {
      Weakest = Weapon(Item);
    }
  }

  // removed all others
  for (Item = EntityEx(MO).Inventory; Item; ) {
    Inventory Next = Item.Inventory;
    if ((Weapon(Item) && Item != Weakest) || FourthWeaponHolder(Item)) {
      Item.Destroy();
    }
    Item = Next;
  }
  SetWeapon(Weakest);
  PendingWeapon = Weakest;

  cprint("CHEATER-YOU DON'T DESERVE WEAPONS");
}


//==========================================================================
//
//  Cheat_Fly
//
//==========================================================================
override void Cheat_Fly () {
  if (!bFly) {
    bFly = true;
    MO.bFly = true;
    MO.bNoGravity = true;
    if (MO.Origin.z <= MO.FloorZ) {
      // thrust the player in the air a bit
      FlyHeight = 10.0;
    }
    if (MO.Velocity.z <= -35.0*35.0) {
      // stop falling scream
      MO.StopSound(CHAN_VOICE);
    }
    cprint("You feel lighter");
  } else {
    if (MO.Origin.z != MO.FloorZ) {
      //FIXME: player->centreing = true;
    }
    bFly = false;
    MO.bFly = false;
    MO.bNoGravity = false;
    cprint("Gravity weights you down");
  }
}


//==========================================================================
//
//  Cheat_NoTarget
//
//==========================================================================
override void Cheat_NoTarget () {
  bNoTarget = !bNoTarget;
  if (bNoTarget) {
    cprint("No Target Mode ON");
  } else {
    cprint("No Target Mode OFF");
  }
}


//==========================================================================
//
//  Cheat_Anubis
//
//==========================================================================
override void Cheat_Anubis () {
  Cheats ^= CF_FRIGHTENING;
  if (Cheats&CF_FRIGHTENING) {
    cprint("\"Quake with fear!\"");
  } else {
    cprint("No more ogre armor");
  }
}


//==========================================================================
//
//  Cheat_Freeze
//
//==========================================================================
override void Cheat_Freeze () {
  Cheats ^= CF_TIMEFREEZE;
  if (Cheats&CF_TIMEFREEZE) {
    cprint("Freeze mode on");
    Level.bFrozen = true;
  } else {
    cprint("Freeze mode off");
    Level.bFrozen = false;
  }
}


//==========================================================================
//
//  CheckFriendlyFire
//
//  TODO
//
//==========================================================================
bool CheckFriendlyFire (EntityEx source, int damage) {
  return false;
}


//==========================================================================
//
//  IsWeaponAlwaysExtremeDeath
//
//  TODO
//
//==========================================================================
bool IsWeaponAlwaysExtremeDeath () {
  return false;
}


//==========================================================================
//
//  SetFOV
//
//  Zoom the player's FOV
//
//==========================================================================
final void SetFOV (int New_FOV) {
  SetCvar('FOV', New_FOV);
}


//==========================================================================
//
//  StartDeathSlideShow
//
//==========================================================================
void StartDeathSlideShow () {
}


//==========================================================================
//
//  GotAmmo
//
//==========================================================================
void GotAmmo (Ammo NewAmmo) {
}


//==========================================================================
//
//  Damaged
//
//==========================================================================
void Damaged (EntityEx inflictor) {
}


//==========================================================================
//
//  KilledActor
//
//==========================================================================
void KilledActor (EntityEx Victim) {
}


//==========================================================================
//
//  Killed
//
//==========================================================================
void Killed (EntityEx source, EntityEx inflictor) {
}


//==========================================================================
//
//  GetSigilPieces
//
//==========================================================================
int GetSigilPieces () {
  return 0;
}


//==========================================================================
//
//  PlayerMorphed
//
//==========================================================================
void PlayerMorphed (EntityEx OldMO) {
}


//==========================================================================
//
//  CreateBot
//
//==========================================================================
void CreateBot () {
}


//==========================================================================
//
//  OnNetReborn
//
//==========================================================================
void OnNetReborn (EntityEx OldMO) {
}


//==========================================================================
//
//  DestroyBot
//
//==========================================================================
void DestroyBot () {
}


//==========================================================================
//
//  BotOnSpawn
//
//==========================================================================
void BotOnSpawn () {
}


//==========================================================================
//
//  SetClientModel
//
//==========================================================================
void SetClientModel () {
}


//==========================================================================
//
//  GetRebornHealth
//
//==========================================================================
int GetRebornHealth () {
  return 0;
}


//==========================================================================
//
//  BotTick
//
//==========================================================================
void BotTick (float deltaTime) {
}


//==========================================================================
//
//  SpawnSpeedEffect
//
//==========================================================================
void SpawnSpeedEffect () {
}


//==========================================================================
//
//  PlayerImpulse
//
//==========================================================================
void PlayerImpulse () {
}


//==========================================================================
//
//  PlayerUnmorphed
//
//==========================================================================
void PlayerUnmorphed () {
}


//==========================================================================
//
//  Cheat_VScriptCommand
//
//==========================================================================
override void Cheat_VScriptCommand (ref array!string args) {
  //print("VScript Command: %s (%d)", args[0], args.length);
  if (!args.length) return;
  if (args[0] == "?") {
    print("give what [amount] -- give inventory item");
    print("take what [amount] -- take inventory item");
    print("drop what          -- drop inventory item");
    print("fire mtp [ofs]     -- fire missile");
    return;
  }

  if (args.length < 2) return;

  if (args[0] == "fire") {
    class!Actor mt = class!Actor(GetClassReplacement(FindClassNoCase(name(args[1]))));
    if (!mt) { print("actor '%s' not found", args[1]); return; }
    float ofs = 4;
    if (args.length > 2) ofs = atof(args[2]);
    //Actor(MO).A_CustomMissile(mt, MO.Height/2, 0, AimMode:2);
    float hgt = MO.Height/2;
    TVec Offs = ofs*vector(cos(MO.Angles.yaw), sin(MO.Angles.yaw), 0.0);
    MO.Origin += Offs;
    EntityEx A = Actor(MO).SpawnMissileAngles(mt, MO.Angles.yaw, MO.Angles.pitch, hgt);
    MO.Origin -= Offs;
    return;
  }

  // find inventory class
  class!Inventory icls = class!Inventory(FindClassNoCase(name(args[1])));
  if (!icls) { print("what is '%s'?", args[1]); return; }

  int amount = 0;
  if (args.length > 2) amount = atoi(args[2]);

  Inventory invit = EntityEx(MO).FindInventory(icls);

  if (args[0] == "give") {
    if (!invit) {
      // no item in inventory, give one
      invit = Inventory(EntityEx(MO).Spawn(GetClassReplacement(icls), default, default, default, false));
      // this shouldn't count for the item statistics
      if (invit.bCountItem) {
        invit.bCountItem = false;
        --Level.TotalItems;
      }
      auto git = invit.TryPickup(EntityEx(MO));
      if (!git) {
        delete invit;
        print("refused to get '%C'", icls);
        return;
      }
      if (amount <= 0) return;
      invit = EntityEx(MO).FindInventory(GetClassReplacement(icls));
      if (!invit) return;
    }
    auto oldam = invit.Amount;
    invit.Amount = min(oldam+amount, invit.MaxAmount);
    if (invit.Amount != oldam) {
      print("you got %d of '%C'", invit.Amount-oldam, invit);
    } else {
      print("you already have maximum of '%C'", invit);
    }
    return;
  }

  if (args[0] == "take") {
    if (!invit) { print("you don't have '%C'", icls); return; }
    if (amount <= 0) amount = 1;
    auto newam = invit.Amount-amount;
    if (newam <= 0) {
      EntityEx(MO).RemoveInventory(invit);
      print("you lost '%C'", invit);
    } else {
      invit.Amount = newam;
      print("you lost %d of '%C'", amount, invit);
    }
    return;
  }

  if (args[0] == "drop") {
    if (!invit) { print("you don't have '%C'", icls); return; }
    TVec dir = vector(cos(MO.Angles.yaw), sin(MO.Angles.yaw))*64;
    dir.z = MO.Height/2;
    auto it = Inventory(EntityEx(MO).DropItem(icls, max(0, amount), 1.0, dropofs:dir));
    if (it) {
      print("dropped '%C'", icls);
      it.Velocity = vector(0, 0, 0);
      it.Amount = invit.Amount;
      it.MaxAmount = invit.MaxAmount;
      EntityEx(MO).RemoveInventory(invit);
    }
    return;
  }
}


//==========================================================================
//
//  eventGetReadyWeapon
//
//==========================================================================
override Entity eventGetReadyWeapon () {
  return ReadyWeapon;
}


defaultproperties {
  InvSize = 6;
}
