//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2021 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//#define SPOTLIGHT_DISCO_TEST
//#define SPOTLIGHT_DISCO_CROWN_TEST

class PlayerEx : BasePlayer abstract;

// player internal flags, for cheats and debug
bitenum {
  CF_NOCLIP, // No clipping, walk through barriers.
  CF_GODMODE, // No damage, no health loss.
  CF_REGENERATION, // Regenerate Health points.
  CF_FRIGHTENING, // Scare monsters away.
  CF_DOUBLEFIRINGSPEED, // Player owns a double firing speed artifact
  CF_HIGHJUMP, // Player owns a high jump artifact
  CF_TIMEFREEZE, // Player owns a time freeze artifact
  CF_BUDDHA, // Normal play, but never looses last 1% of health
};

enum FlashlightLightId = 3_669_666;

const float BLINKTHRESHOLD = 4.0;

// 16 pixels of bob
const float MAXBOB = 16.0;

const int MAXHEALTH      = 100;
const int MAXMORPHHEALTH = 30;

// for screen flashing (red or bright)
float DamageFlash;
float BonusFlash;
name DamageFlashType;
transient int DamageFlashBlend; // for advdamage indicator

// base height above floor for viewz
float ViewHeight;
float PrevViewHeight; // this is used in crouching cheat (and saved there)
float DeltaViewHeight; // bob/squat speed
float Bob; // bounded/scaled total momentum

// who did damage (none for floors/ceilings)
EntityEx Attacker;

float JumpTime;
TVec LocalQuakeHappening; // for each axis

// for damaging flats: don't apply damage more than once per tick
// this is last tick when sector damage was applied
int LastSectorDamageTic;

float HazardTime;
float LastHazardTime;

// bit flags, for cheats and debug
// see cheat_t above
int /*[checkpoint]*/ Cheats;

Weapon /*[checkpoint]*/ ReadyWeapon;
Weapon PendingWeapon; // is none if not changing

// refired shots are less accurate (this is counter)
int Refire;

float FlyHeight;

array!name RevealedMaps;

Inventory InvFirst;
Inventory InvPtr;
float InventoryTime;
int ArtifactFlash;
int InvSize;

Inventory SavedInventory;

bool onground;

bool bRevertCamera; // revert camera if player moves
bool bFrozen; // player cannot move
bool bTotallyFrozen; // player cannot do anything except press use
bool /*[checkpoint]*/ bNoTarget; // monster don't target
bool /*[checkpoint]*/ bInstantWeaponSwitch; // switch weapons instantly
bool bFly; // player is flying
bool bInventoryAlwaysOpen; // inventory bar is always open
bool bAutoAim; // auto aiming enabled? (weapon can override this)
// used in ammo king ammo amount getter
bool bHasBackpack;
// for PROP_NOWEAPONSWITCH
bool bDisableWeaponSwitch;
// used to force crouching from entity physics
// reset in player ticker, or on player reborn
// value is game tick when it should be reset, or 0 for inactive
transient int bForceCrouchingDown;

// button down flags, etc.
transient bool bReloadQueued; // true if "reload" was pressed
transient bool bReloadDown; // `true` if button was down last tic
transient bool bZoomDown; // `true` if button was down last tic
transient bool bAltAttackDown; // `true` if button was down last tic
transient bool bButton5Down; // `true` if button was down last tic
transient bool bButton6Down; // `true` if button was down last tic
transient bool bButton7Down; // `true` if button was down last tic
transient bool bButton8Down; // `true` if button was down last tic

int PoisonCount; // screen flash for poison damage
float LastPoisonTime;
EntityEx Poisoner; // none for non-player mobjs
PlayerEx PoisonerPlayer; // for KArena

int Objectives;

float MorphTime; // player is morphed into something if > 0
int MorphStyle;
class!Actor UnmorphFlash;

// moved to entity
/*
int Accuracy;
int Stamina;
*/

float BlendR;
float BlendG;
float BlendB;
float BlendA;

int ChickenPeck; // chicken peck countdown

Actor Rain1; // active rain maker 1
Actor Rain2; // active rain maker 2

const int MAX_MAPS_VISITED = 100;

name MapsVisited[MAX_MAPS_VISITED];

float FOV; // current Field Of Vision
float DesiredFOV; // desired Field Of Vision

ubyte LastWaterLevel;


bool /*[checkpoint]*/ k8ElvenGifted; // always set to `true` in checkpoints
transient float k8BossesDetected = 666; // seconds; <0: waiting; 0: show message; >0: detected
transient float k8ElvenGiftMessageTime = 666; // seconds; <0: waiting; 0: show message; >0: detected


// Health Accumulator
// if you want to show HA info in UI, replicate those vars
int k8HealthAccum_Amount; // amount of currently accumulated health
float k8HealthAccum_LastRegenTime = -10000;
float k8HealthAccum_LastBoostTime = -10000;

// this is used in network games; no need to save it
//transient bool k8HealthAccum_Enabled_NWClient;

bool bFlashlightOn;
transient bool bFlashlightButtonDown;
transient float k8NextSuperBulletTime;

transient subsector_t *lastSubSector;
//transient array!int subSeen; // do not bother dropping subsector info for those

transient float lastViewOrgZForPfx; // set in `CalcHeight()`, used in `PostfixViewHeight()`
transient float lastViewOrgVH;
transient sector_t *lastViewOrgZSector;

// meh, let it cheat a little
transient int LastRegenTicTime = 0;


// used in `SetupSectorFlatDamage()` and friends
struct SectorDamageInfo {
  name flatDamageType;
  int flatDamage;
  int flatDamageTimeout;
  int flatDamageLeaky; // byte, probability
  bool flatDamageExit;
  bool flatDamageHitFloor;
}


#include "PlayerEx.cheats.vc"


//==========================================================================
//
//  EngineHelperGetSavedInventory
//
//==========================================================================
override Entity EngineHelperGetSavedInventory () {
  return SavedInventory;
}


//==========================================================================
//
//  ClearSubSeenInfo
//
//==========================================================================
final void ClearSubSeenInfo () {
  lastSubSector = nullptr;
  //subSeen.reset();
}


//==========================================================================
//
//  AddSeenSubsector
//
//==========================================================================
final void AddSeenSubsector () {
  if (!MO) return;
  if (!MO.SubSector) return;
  if (lastSubSector == MO.SubSector) return;
  /*
  int ssnum = MO.SubSector-&MO.XLevel.Subsectors[0];
  if (subSeen.length != MO.XLevel.Subsectors.length) {
    subSeen.length = MO.XLevel.Subsectors.length;
    foreach (ref int ss; subSeen) ss = 0;
  }
  if (subSeen[ssnum]) return;
  subSeen[ssnum] = 1;
  */
  lastSubSector = MO.SubSector;
  foreach (auto i; 0..MAXPLAYERS) {
    PlayerEx plr = PlayerEx(Level.Game.Players[i]);
    if (!plr || !plr.bIsBot) continue;
    plr.BotSendSubSectorChange(lastSubSector);
  }
}


//==========================================================================
//
//  BotDumpNodes
//
//==========================================================================
void BotDumpNodes () {
}


//==========================================================================
//
//  BotTestFindPathTo
//
//==========================================================================
void BotTestFindPathTo (TVec dest) {
}


replication {
  reliable if (!bIsClient)
    Cheats, ReadyWeapon, InvFirst, InvPtr, InventoryTime, ArtifactFlash,
    Objectives, MorphTime/*, Accuracy, Stamina*/, MapsVisited, DamageFlash, DamageFlashType,
    BonusFlash, Attacker, bFrozen, bTotallyFrozen,/* DesiredFOV, FOV,*/
    bReloadQueued, bReloadDown, bZoomDown, bAltAttackDown,
    bButton5Down, bButton6Down, bButton7Down, bButton8Down,
    bFlashlightOn;

  unreliable if (!bIsClient)
    ParticleEffect, ClientExplosion, ClientParticleExplosion,
    ClientSparkParticles, ClientRailTrail, DecalEffect,
    // we need this to update UI, but this is not vital info
    /*k8HealthAccum_Enabled_NWClient,*/ k8HealthAccum_Amount;

  reliable if (!bIsClient)
    ClientVoice, ClientSpeech, ClientFinaleType, ClientSlideshow1,
    ClientSlideshow2;

  // from client to server
  reliable if (bIsClient)
    bAutoAim;
}


//==========================================================================
//
//  GetUseRanges
//
//==========================================================================
void GetUseRanges (out float ur, out float utr) {
  PlayerPawn pwn = PlayerPawn(MO);
  if (pwn) {
    //printdebug("%C: GetUseRanges: ur=%s; utr=%s", self, pwn.UseRange, pwn.UseThingRange);
    ur = fmax(1.0f, pwn.UseRange);
    utr = fmax(1.0f, pwn.UseThingRange);
  } else {
    ur = PlayerPawn::DEFAULT_USERANGE;
    utr = PlayerPawn::DEFAULT_USETHINGRANGE;
  }
}


#include "PlayerEx.healthbar.vc"


//==========================================================================
//
//  FixCheatFlags
//
//  fix various cheat flags
//
//==========================================================================
void FixCheatFlags () {
  Level.bFrozen = !!(Cheats&CF_TIMEFREEZE);
  if (MO) {
    if (Cheats&CF_GODMODE) {
      if (LineSpecialGameInfo(Level.Game).GOD_HEALTH) {
        if (MO) MO.Health = LineSpecialGameInfo(Level.Game).GOD_HEALTH;
        Health = LineSpecialGameInfo(Level.Game).GOD_HEALTH;
      }
    }
    if (Cheats&CF_NOCLIP) {
      MO.bColideWithThings = !(Cheats&CF_NOCLIP);
      MO.bColideWithWorld = !(Cheats&CF_NOCLIP);
    }
  }
}


//==========================================================================
//
//  ResetToDefaults
//
//  this is called on save loading, etc.
//  reset every important field to default
//
//==========================================================================
override void ResetToDefaults () {
  ::ResetToDefaults();
  ResetPlayerOnSpawn(keepPlayerState:true);
  k8HealthAccum_Amount = 0;
  //print("*** RESET ***");
  //print("k8ElvenGiftMessageTime=%s", k8ElvenGiftMessageTime);
}


//==========================================================================
//
//  eventOnSaveLoaded
//
//  this is called after savegame was loaded
//
//==========================================================================
override void eventOnSaveLoaded () {
  ::eventOnSaveLoaded();
  //print("*** LOADED ***");
  //print("k8ElvenGiftMessageTime=%s", k8ElvenGiftMessageTime);
  k8ElvenGiftMessageTime = 666; // checkpoint loads will set this, so reset it back
  // but detect bosses
  k8BossesDetected = (GetCvarB('k8ElvenDetect') ? -0.5 : 666);
}


//==========================================================================
//
//  eventOnBeforeSave
//
//==========================================================================
override void eventOnBeforeSave (bool isAutosave, bool isCheckpoint) {
  ::eventOnBeforeSave(isAutosave, isCheckpoint);
  //print("*** BEFORE SAVING (auto:%B; checkpoint:%B) ***", isAutosave, isCheckpoint);
}


//==========================================================================
//
//  eventOnAfterSave
//
//==========================================================================
override void eventOnAfterSave (bool isAutosave, bool isCheckpoint) {
  ::eventOnAfterSave(isAutosave, isCheckpoint);
  //print("*** SAVED (auto:%B; checkpoint:%B) ***", isAutosave, isCheckpoint);
}


//==========================================================================
//
//  IsCheckpointPossible
//
//  this should check player's inventory (and maybe some other things), and
//  return `true` if simple checkpoint-style save is possible
//  (i.e. loader can simply recreate player inventory and health)
//
//  for now, there is no way to inject custom data in checkpoints, so if
//  you have any, return `false` here
//
//==========================================================================
override bool IsCheckpointPossible () {
  if (!MO) return false;
  return EntityEx(MO).IsInventoryCheckpointPossible();
}


//==========================================================================
//
//  CalcFlyZ
//
//  TODO: this is time-dependent; fix it!
//
//==========================================================================
float CalcFlyZ (float currz) {
  currz += sin(90.0*35.0/20.0*AngleMod360(WorldTimer))/2.0;
  return currz;
}


//==========================================================================
//
//  QS_Save
//
//==========================================================================
override void QS_Save () {
  QS_PutInt("Health", Health);
  QS_PutInt("Cheats", Cheats);

  QS_PutInt("bNoTarget", (bNoTarget ? 1 : 0));
  QS_PutInt("bInstantWeaponSwitch", (bInstantWeaponSwitch ? 1 : 0));
  QS_PutInt("bAutoAim", (bAutoAim ? 1 : 0));

  int viscount = 0;
  foreach (auto midx; 0..MAX_MAPS_VISITED; reverse) {
    if (MapsVisited[midx]) {
      viscount = midx+1;
      break;
    }
  }

  QS_PutInt("MAX_MAPS_VISITED", viscount);
  foreach (auto midx; 0..viscount) QS_PutName(va("MapVisited.%d", midx), MapsVisited[midx]);
}


//==========================================================================
//
//  QS_Load
//
//==========================================================================
override void QS_Load () {
  Health = QS_GetInt("Health");
  MO.Health = Health;
  Cheats = QS_GetInt("Cheats");

  FixCheatFlags();

  bNoTarget = !!QS_GetInt("bNoTarget");
  bInstantWeaponSwitch = !!QS_GetInt("bInstantWeaponSwitch");
  bAutoAim = !!QS_GetInt("bAutoAim");

  int viscount = QS_GetInt("MAX_MAPS_VISITED", 0);
  if (viscount < 0) Error("invalid number of visited maps in quicksave");
  //if (MAX_MAPS_VISITED != QS_GetInt("MAX_MAPS_VISITED")) Error("invalid number of visited maps in quicksave");
  //print("VISCOUNT=%d (%d)", viscount, MAX_MAPS_VISITED);
  foreach (auto midx; 0..viscount) {
    name mname = QS_GetName(va("MapVisited.%d", midx));
    if (midx < MAX_MAPS_VISITED) {
      MapsVisited[midx] = mname;
    } else {
      if (mname) Error("invalid number of visited maps in quicksave");
    }
  }

  foreach (auto midx; viscount..MAX_MAPS_VISITED) MapsVisited[midx] = '';

  k8ElvenGifted = true;
}


//==========================================================================
//
//  ClearEntityInventoryQS
//
//==========================================================================
/*
override void ClearEntityInventoryQS () {
  ReadyWeapon = none;
  PendingWeapon = none;
  ::ClearEntityInventoryQS();
}
*/


//==========================================================================
//
//  ResetWeaponReloadRefire
//
//==========================================================================
void ResetWeaponReloadRefire () {
  bReloadQueued = false;
  Refire = 0;
}


//==========================================================================
//
//  eventSetPendingWeapon
//
//==========================================================================
override bool eventSetPendingWeapon (Entity ent) {
  if (!MO) return false;
  Weapon wpn = Weapon(ent);
  if (!wpn) return false;
  for (Inventory inv = EntityEx(MO).Inventory; inv; inv = inv.Inventory) {
    if (ent == wpn) {
      PendingWeapon = wpn;
      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  eventSetReadyWeapon
//
//  currently this is used only in checkpoint loader, hence such logic
//  (no checks for the same weapon, and such)
//
//==========================================================================
override void eventSetReadyWeapon (Entity ent, bool instant) {
  if (!MO) return;
  SetWeapon(none);
  Weapon wpn = Weapon(ent);
  for (Inventory inv = EntityEx(MO).Inventory; inv; inv = inv.Inventory) {
    if (ent == wpn) {
      SetWeapon(wpn);
      break;
    }
  }
  BringUpWeapon(instant:instant, skipSound:instant);
}


//==========================================================================
//
//  eventIsReadyWeaponByName
//
//==========================================================================
override bool eventIsReadyWeaponByName (string classname, bool allowReplace) {
  if (!classname || !ReadyWeapon) return false;
  // try direct
  auto wpnClass = class!Weapon(FindClassNoCaseStr(classname));
  if (!wpnClass) return false;
  if (wpnClass == ReadyWeapon.Class) return true;
  // try replacement
  if (allowReplace) {
    // replacement
    auto wpnRepl = class!Weapon(GetClassReplacement(wpnClass));
    if (wpnRepl && wpnRepl != wpnClass && wpnRepl == ReadyWeapon.Class) return true;
    // replacee
    auto wpnSrc = class!Weapon(GetClassReplacee(ReadyWeapon.Class));
    if (wpnSrc && stricmp(string(GetClassName(wpnSrc)), classname) == 0) return true;
    // superclass chain
    wpnClass = class!Weapon(ReadyWeapon.Class);
    while (wpnClass) {
      if (stricmp(string(GetClassName(wpnClass)), classname) == 0) return true;
      wpnClass = class!Weapon(GetClassParent(wpnClass));
    }
  }
  // not found
  return false;
}


//==========================================================================
//
//  eventFindInventoryWeapon
//
//==========================================================================
override Entity eventFindInventoryWeapon (string classname, bool allowReplace) {
  if (!classname) return none;
  if (!MO) return none;
  // try direct
  auto wpnClass = class!Weapon(FindClassNoCaseStr(classname));
  if (!wpnClass) return none;
  for (Inventory inv = EntityEx(MO).Inventory; inv; inv = inv.Inventory) {
    if (inv.Class == wpnClass) return Weapon(inv);
  }
  // try replacements
  if (allowReplace) {
    // replacement
    auto wpnRepl = class!Weapon(GetClassReplacement(wpnClass));
    if (wpnRepl && wpnRepl != wpnClass) {
      for (Inventory inv = EntityEx(MO).Inventory; inv; inv = inv.Inventory) {
        if (inv.Class == wpnRepl) return Weapon(inv);
      }
    }
  }
  // not found
  return none;
}


//==========================================================================
//
//  GetAttackZOfs
//
//==========================================================================
float GetAttackZOfs () {
  auto plrmo = PlayerPawn(MO);
  if (!plrmo) return 8.0;
  return plrmo.AttackZOffset*plrmo.crouchfactor;
}


//==========================================================================
//
//  ThrustPlayer
//
//  Moves the given origin along a given angle.
//
//==========================================================================
final void ThrustPlayer (float angle, float move, float deltaTime) {
  if ((!EntityEx(MO).FindInventory(PowerFlight) || MO.Origin.z <= MO.FloorZ) &&
      ((EntityEx(MO).GetFloorType()->Friction &&
        EntityEx(MO).GetFloorType()->Friction < EntityEx::FRICTION_NORMAL) ||
      (MO.Sector->special&SECSPEC_BASE_MASK) == SECSPEC_FrictionLow))
  {
    move *= LineSpecialGameInfo(Level.Game).IceMoveFactor;
  }
  float s, c;
  sincos(angle, out s, out c);
  MO.Velocity.x += move*c*deltaTime;
  MO.Velocity.y += move*s*deltaTime;
}


//==========================================================================
//
//  SanitizeViewOrgZ
//
//==========================================================================
void SanitizeViewOrgZ () {
  if (!MO) return; // just in case
  if (PlayerState != PST_DEAD && MO.bFloorClip && MO.Origin.z <= MO.FloorZ) ViewOrg.z -= MO.FloorClip;
  if (ViewOrg.z < MO.FloorZ+3.0) ViewOrg.z = MO.FloorZ+3.0;
  if (ViewOrg.z > MO.CeilingZ-3.0) ViewOrg.z = MO.CeilingZ-3.0;
}


//==========================================================================
//
//  SaveViewOrgFixInfo
//
//==========================================================================
void SaveViewOrgFixInfo () {
  if (MO) {
    lastViewOrgZForPfx = MO.Origin.z;
    lastViewOrgZSector = MO.Sector;
    lastViewOrgVH = ViewHeight;
  } else {
    lastViewOrgZSector = nullptr;
  }
}


//==========================================================================
//
//  ClientSetViewOrg
//
//==========================================================================
override void ClientSetViewOrg (TVec neworg) {
  ::ClientSetViewOrg(neworg);
  SaveViewOrgFixInfo();
}


//==========================================================================
//
//  PostfixViewHeight
//
//  after player thinker was called, player can be moved by a lift,
//  for example. we have to "postfix" view origin to get rid of
//  "sinking into lift" effect.
//
//  this is called from `SetViewPos()`, which in turn is called from
//  main world thinker.
//
//==========================================================================
override void PostfixViewHeight () {
  if (!MO) return; // just in case
  if (!lastViewOrgZSector) return;
  if (lastViewOrgZSector != MO.Sector) return;
  if (lastViewOrgVH != ViewHeight) return;

  float zdiff = MO.Origin.z-lastViewOrgZForPfx;
  if (!zdiff) return; // nothing to do
  lastViewOrgZSector = nullptr; // in case we will be called repeatedly

  // fix flashlight origin, so it won't jerk on lifts
  if (bFlashlightOn) MO.ShiftDlightHeight(FlashlightLightId, zdiff);

  ViewOrg.z += zdiff;
  //SanitizeViewOrgZ();
}


//==========================================================================
//
//  CalcHeight
//
//  calculate the walking / running height adjustment
//  called from player tickers (both alive and dead)
//
//==========================================================================
void CalcHeight (float deltaTime) {
  float mvbobbob = GetCvarF('movebob');

  if (mvbobbob > 0) {
    // regular movement bobbing
    // (needs to be calculated for gun swing even if not on ground)
    if (MO.bFly && !onground) {
      Bob = 0.5;
    } else {
      if (mvbobbob > 1) mvbobbob = 1;
      Bob = MO.Velocity.x*MO.Velocity.x+MO.Velocity.y*MO.Velocity.y;
      Bob /= (1.0/mvbobbob)*35.0*35.0;
      if (Bob > MAXBOB) Bob = MAXBOB;
    }
  }

  // when crouching, bobbing have to be reduced
  if (PlayerPawn(MO)) {
    auto plrmo = PlayerPawn(MO);
    Bob *= plrmo.crouchfactor;
  }

  float angle = 180.0*35.0/10.0*Level.XLevel.Time;
  mvbobbob = Bob/2.0*sin(angle);

  // move viewheight
  if (PlayerState == PST_LIVE) {
    ViewHeight += DeltaViewHeight*deltaTime;

    float plrVH = PlayerPawn(MO).GetPawnViewHeight*PlayerPawn(MO).crouchfactor;

    if (ViewHeight > plrVH) {
      ViewHeight = plrVH;
      DeltaViewHeight = 0.0;
    }

    if (ViewHeight < plrVH/2.0) {
      ViewHeight = plrVH/2.0;
      if (DeltaViewHeight <= 0.0) DeltaViewHeight = 0.00001;
    }

    if (DeltaViewHeight) {
      DeltaViewHeight += 256.0*deltaTime;
      if (!DeltaViewHeight) DeltaViewHeight = 0.00001;
    }
  }
  ViewOrg.z = MO.Origin.z+ViewHeight+mvbobbob;
  SaveViewOrgFixInfo();

  SanitizeViewOrgZ();
}


//==========================================================================
//
//  SetNewCrouchFactor
//
//==========================================================================
void SetNewCrouchFactor (float newcrf) {
  auto plrmo = PlayerPawn(MO);
  if (!plrmo) return;

  //scope(exit) PrevViewHeight = ViewHeight;

  // check whether the move is ok
  float savedheight = plrmo.Height; //HACK! we'd better use `GetHeight()` here, but...
  float defaultheight = plrmo.GetRealHeight; // ...this saves `Height` to `RealHeight` too
  plrmo.Height = defaultheight*newcrf; // we'd better use `SetHeight()` here
  if (!plrmo.TryMove(plrmo.Origin, AllowDropOff:false)) {
    // nope, restore player height
    plrmo.Height = savedheight;
    return;
  }

  // setup new view height, and remember current crouch factor
  // apply view height delta
  float prevVH = PrevViewHeight;
  if (prevVH == -666) prevVH = ViewHeight;
  float vhDelta = ViewHeight-prevVH;
  ViewHeight = PlayerPawn(plrmo).GetPawnViewHeight*newcrf+vhDelta;
  plrmo.crouchfactor = newcrf;
  PrevViewHeight = ViewHeight;

  // check for eyes going above/below fake floor due to crouching motion
  // this seems to be done in TryMove
  //FIXME
  //TODO
  //CheckFakeFloorTriggers(pos.Z + oldheight, true);
}


//==========================================================================
//
//  CrouchMove
//
//==========================================================================
void CrouchMove (float deltaTime, int direction) {
  auto plrmo = PlayerPawn(MO);
  if (!plrmo) return;

  float crouchspeed = (bForceCrouchingDown && direction > 0 ? -EntityEx::CROUCHSPEED : direction*EntityEx::CROUCHSPEED)*deltaTime;
  float newcrf = fclamp(plrmo.crouchfactor+crouchspeed, 0.5, 1.0);
  if (newcrf == plrmo.crouchfactor) return; // nothing to do
  //if (bForceCrouchingDown) printdebug("FORCED CROUCH! old=%s; new=%s; cspeed=%s", plrmo.crouchfactor, newcrf, crouchspeed);
  //else if (newcrf != 1.0f) printdebug("CROUCH(dir=%s)! old=%s; new=%s; cspeed=%s", direction, plrmo.crouchfactor, newcrf, crouchspeed);

  SetNewCrouchFactor(newcrf);
}


//==========================================================================
//
//  CanCrouch
//
//==========================================================================
final bool CanCrouch () {
  if (!IsCrouchEnabled()) return false;
  return (!bFly || MO.Origin.z <= MO.FloorZ);
}


//==========================================================================
//
//  IsCrouchButtonCrouch
//
//==========================================================================
final bool IsCrouchButtonCrouch () {
  if (!IsCrouchEnabled()) return false;
  if (Buttons&BT_CROUCH) {
    return (!bFly || MO.Origin.z <= MO.FloorZ);
  }
  return false;
}


//==========================================================================
//
//  MovePlayer
//
//==========================================================================
void MovePlayer (float deltaTime) {
  float forward;
  float side;
  float fly;

  // yeah, we can start crouching mid-air
  //auto ohgt = MO.Height;
  //printdebug("%C: MovePlayer; dt=%s; bForceCrouchingDown=%s", self, deltaTime, bForceCrouchingDown);
  CrouchMove(deltaTime, (IsCrouchButtonCrouch() ? -1 : 1));
  //print("HEIGHT: %s  %s  crf=%s; vh=%s; dvh=%s", ohgt, MO.Height, EntityEx(MO).crouchfactor, ViewHeight, PlayerPawn(MO).default.ViewHeight);

  // do not let the player control movement if not onground
  onground = (MO.Origin.z <= MO.FloorZ || EntityEx(MO).bOnMobj);

  //if (Buttons&BT_JUMP) printdebug("%C: onground=%s; JumpTime=%s", self, onground, JumpTime);

  /*
  if (spGetNormalZ(MO.EFloor) != 1.0) printdebug("%C: slope onground=%s", self, onground);

  // for slopes
  if (!onground && spGetNormalZ(MO.EFloor) != 1.0 && MO.Origin.z <= spGetPointZ(MO.EFloor, MO.Origin)) {
    printdebug("%C: on a slope!", self);
    onground = true;
  }
  */

  forward = ForwardMove*5.0;
  side = SideMove*5.0;

  PlayerPawn(MO).AdjustSpeed(forward, side);

  if (!onground && !MO.bNoGravity && !MO.WaterLevel) {
    // not on ground, so we have little effect on velocity
    forward *= Level.AirControl;
    side *= Level.AirControl;
  }

  if (forward) ThrustPlayer(MO.Angles.yaw, forward, deltaTime);
  if (side) ThrustPlayer(AngleMod360(MO.Angles.yaw-90.0), side, deltaTime);

  if (forward || side) {
    SetPlayerRunState();
    if (bRevertCamera) {
      Camera = MO;
      bRevertCamera = false;
    }
  }

  fly = FlyMove/16.0;
  if (fly && (bFly || EntityEx(MO).FindInventory(PowerFlight))) {
    if (FlyMove != TOCENTRE) {
      FlyHeight = fly*2.0;
      if (!MO.bFly) {
        MO.bFly = true;
        MO.bNoGravity = true;
        if (MO.Velocity.z <= -39.0*35.0) {
          // stop falling scream
          MO.StopSound(CHAN_VOICE);
        }
      }
    } else {
      MO.bFly = false;
      MO.bNoGravity = false;
    }
  } else if (fly > 0.0) {
    UseFlyPower();
  }

  if (MO.bFly) {
    /* old code
    MO.Velocity.z = FlyHeight*35.0;
    if (FlyHeight) FlyHeight /= 2.0;
    */
    if (fabs(FlyHeight) > 0.1) {
      MO.Velocity.z = FlyHeight*35.0;
      FlyHeight /= 2.0;
      if (fabs(FlyHeight) <= 0.1) FlyHeight = 0;
    } else {
      // directional flight
      if (forward) {
        TVec vfdir;
        AngleVector(MO.Angles, out vfdir);
        vfdir.z *= forward*deltaTime;
        MO.Velocity.z += vfdir.z;
      } else {
        if (MO.Velocity.z < 0) {
          MO.Velocity.z = fmin(0, MO.Velocity.z+4);
        } else if (MO.Velocity.z > 0) {
          MO.Velocity.z = fmax(0, MO.Velocity.z-4);
        }
      }
    }
    if ((Buttons&BT_JUMP) && MO.Velocity.z < 160) MO.Velocity.z += 30;
    if ((Buttons&BT_CROUCH) && MO.Velocity.z > -160) MO.Velocity.z -= 30;
    // sanitize
    float limit = ((Buttons&BT_SPEED) && IsRunEnabled() ? 400 : 200);
    MO.Velocity.z = fclamp(MO.Velocity.z, -limit, limit);
    //print("VZ=%s; FH=%s; fvwd=%s", MO.Velocity.z, FlyHeight, vforward);
  }

  if ((Buttons&BT_JUMP) && !bFly && onground && !JumpTime && IsJumpEnabled()) {
    MO.Velocity.z = (PlayerPawn(MO).JumpVelZ*(Cheats&CF_HIGHJUMP ? 2.0 : 1.0))*1.1;
    EntityEx(MO).bOnMobj = false;
    JumpTime = 0.5;
    MO.PlaySound('*jump', CHAN_VOICE);
  }
}


//==========================================================================
//
//  CheckWaterJump
//
//  check for a jump-out-of-water
//
//==========================================================================
void CheckWaterJump (optional bool asStep) {
  if (EntityEx(MO).bWaterJump && EntityEx(MO).ReactionTime > 0) return;

  //TVec vforward, vright;
  //AngleVectors(MO.Angles, out vforward, out vright, out vup);
  //TVec fwdvel = vforward.xy;
  //vforward = (vforward*ForwardMove+vright*SideMove).Normalise;
  //vforward.z = 0.0;
  //vforward = Normalise(vforward);

  TVec vforward = (AngleYawVector(MO.Angles.yaw)*ForwardMove+YawVectorRight(MO.Angles.yaw)*SideMove).Normalise;

  TVec start = MO.Origin;
  start.z += (!asStep ? MO.Height*0.5+8.0 : MO.MaxStepHeight);
  TVec end = start+vforward*24.0;

  VLevel::linetrace_t tm;
  if (!Level.XLevel.BSPTraceLineEx(start, end, out trace:tm, noBlockFlags:SPF_NOBLOCKING|SPF_PLAYER)) {
    // solid at waist
    start.z = MO.Origin.z+MO.Height;
    end = start+vforward*24.0;
    //MoveDir = HitNormal*(-50.0);
    if (Level.XLevel.BSPTraceLine(start, end, noBlockFlags:SPF_NOBLOCKING|SPF_PLAYER)) {
      // open at eye level
      //printdebug("%C: vel=%s : %s -- %s", self, MO.Velocity, MO.Velocity.xy.length, vforward);
      EntityEx(MO).bWaterJump = true;
      MO.Velocity.z = 350.0;
      // add some horizontal velocity
      float hlen = MO.Velocity.xy.length;
      if (hlen < 40) {
        MO.Velocity += vforward*(60-hlen);
        //printdebug("%C: vel=%s : %s", self, MO.Velocity, MO.Velocity.xy.length);
      } else if (hlen > 70) {
        MO.Velocity -= vforward*(hlen-60);
        //printdebug("%C: vel=%s : %s", self, MO.Velocity, MO.Velocity.xy.length);
      }
      // try to move slightly away from hitline, to make a better jump
      if (tm.HitLine) {
        //printdebug("%C: water line=%s (%s); dist=%s", self, tm.HitLine-&Level.XLevel.Lines[0], tm.HitLine.normal, PlanePointDistance(ref *tm.HitLine, MO.Origin));
        float wdist = PlanePointDistance(ref *tm.HitLine, MO.Origin);
        if (wdist > 0 && wdist < 24) {
          float mdist = 24-wdist;
          if (MO.Radius-4 >= mdist) {
            //printdebug("%C:000: water line=%s (%s); wdist=%s; mdist=%s; org=%s", self, tm.HitLine-&Level.XLevel.Lines[0], tm.HitLine.normal, wdist, mdist, MO.Origin);
            MO.TryMove(MO.Origin+tm.HitLine.normal*mdist, AllowDropOff:false);
            //printdebug("%C:001: water line=%s (%s); wdist=%s; mdist=%s; org=%s; newdist=%s", self, tm.HitLine-&Level.XLevel.Lines[0], tm.HitLine.normal, wdist, mdist, MO.Origin, PlanePointDistance(ref *tm.HitLine, MO.Origin));
          }
        }
      }
      //MoveDir = fwdvel*ForwardMove;
      EntityEx(MO).ReactionTime = 2.0; // safety net
      MO.PlaySound('*jump', CHAN_VOICE); //FIXME
    }
  }
}


//==========================================================================
//
//  WaterMove
//
//  this is called if WaterLevel is > 1
//
//  water levels:
//    0: not submerged at all (e.g. standing on solid ground or on shallow TERRAIN-based water)
//    1: less than half submerged ("ankle deep")
//    2: at least half submerged ("waist deep")
//    3: entirely submerged (completely underwater)
//
//==========================================================================
void WaterMove (float deltaTime) {
  float forward;
  float side;
  TVec vforward;
  TVec vright;
  TVec vup;
  TVec wishvel;

  auto lastwtlevel = LastWaterLevel;
  LastWaterLevel = MO.WaterLevel;

  // if we just fell into water, and we have too big vertical velocity, clamp it
  if (lastwtlevel != MO.WaterLevel) {
    //print("***WATER: prev=%s; curr=%s; velz=%s", LastWaterLevel, MO.WaterLevel, MO.Velocity.z);
    if (!lastwtlevel && MO.Velocity.z < -20) {
      MO.Velocity.z = fmax(MO.Velocity.z, MO.Velocity.z+(MO.WaterLevel < 3 ? 100 : 100));
      if (MO.Velocity.z >= -20) LastWaterLevel = 0; // repeat it
    }
  }
  //else print("**WZ=%s", MO.Velocity.z);

  AngleVectors(MO.Angles, out vforward, out vright, out vup);

  forward = ForwardMove;
  side = SideMove;

  PlayerPawn(MO).AdjustSpeed(forward, side);

  wishvel = vforward*forward+vright*side;
  //print("wishvel=%s; waterlevel=%s", wishvel, LastWaterLevel);
  float wishvz = wishvel.z;
  if (!forward && !side /*&& !cmd.upmove*/ && !(Buttons&BT_JUMP)) {
    //wishvel.z -= 60.0; // drift towards bottom
    //wishvel.z -= (MO.WaterLevel < 2 ? 60 : 6);
    wishvel.z -= 6;
  }
  // prevent bunny-hopping while hovering on water
  if (LastWaterLevel < 2) {
    wishvz = 0;
    wishvel.z = 0;
    MO.Velocity.z = fmin(0, MO.Velocity.z);
  }
  //else wishvel.z += cmd.upmove;

  //print("wishvel=%s; forward=%s; prevel=%s", wishvel, forward, MO.Velocity);
  MO.Velocity += 3.5*deltaTime*wishvel;

  if (forward || side) SetPlayerRunState();

  bool doCrouchMove = true;
  bool doNormalJump = false;
  if (Buttons&BT_JUMP) {
    // jump if standing on a floor
    if (LastWaterLevel < 3 && !bFly && MO.Origin.z <= MO.FloorZ) {
      doNormalJump = true;
    } else if (LastWaterLevel >= 3) {
           if (MO.WaterType == CONTENTS_WATER) MO.Velocity.z = 100.0;
      else if (MO.WaterType == CONTENTS_NUKAGE || MO.WaterType == CONTENTS_SLIME || MO.WaterType == CONTENTS_SLUDGE) MO.Velocity.z = 80.0;
      else MO.Velocity.z = 50.0;
    }
  } else if (Buttons&BT_CROUCH) {
    // crouching means "sink" while in water
    if ((LastWaterLevel >= 2 || bFly) && MO.Origin.z > MO.FloorZ) {
           if (MO.WaterType == CONTENTS_WATER) MO.Velocity.z = -100.0/1.5;
      else if (MO.WaterType == CONTENTS_NUKAGE || MO.WaterType == CONTENTS_SLIME || MO.WaterType == CONTENTS_SLUDGE) MO.Velocity.z = -80.0/1.5;
      else MO.Velocity.z = -50.0/1.5;
    } else if (MO.Origin.z <= MO.FloorZ) {
      // normal crouch
      doCrouchMove = false;
      CrouchMove(deltaTime, (IsCrouchButtonCrouch() ? -1 : 1));
    }
  } else {
    if (MO.WaterLevel >= 2 && wishvel.z < 0 && wishvz == 0) {
      if (MO.Velocity.z > 0) MO.Velocity.z -= 10;
    }
    // if we are not moving vertically, do not sink too fast
    if (/*!forward*/!wishvz) {
      if (MO.Velocity.z < -20) MO.Velocity.z = fmin(-20, MO.Velocity.z+20);
    } else {
      float limit = ((Buttons&BT_SPEED) && IsRunEnabled() ? 140 : 140*2);
      MO.Velocity.z = fclamp(MO.Velocity.z, -limit, limit);
    }
  }

  // stand up
  if (doCrouchMove) CrouchMove(deltaTime, 1);

  CheckWaterJump();

  // do real jump here, but only if we aren't jumping out of water
  if (doNormalJump && !EntityEx(MO).bWaterJump) {
    MO.Velocity.z = (PlayerPawn(MO).JumpVelZ*(Cheats&CF_HIGHJUMP ? 2.0 : 1.0))*1.1;
    EntityEx(MO).bOnMobj = false;
    //JumpTime = 0.5;
  }
}


//==========================================================================
//
//  WaterJump
//
//==========================================================================
void WaterJump () {
  if (!EntityEx(MO).ReactionTime || !MO.WaterLevel) {
    EntityEx(MO).bWaterJump = false;
    EntityEx(MO).ReactionTime = 0.0;
  }
  /*
  TVec xdir = MoveDir;
  /+k8 added
  if (!xdir) return;
  printdebug("WATERJUMP: 000: vel=%s; dir=%s; xdir=%s; vl2d=%s; xdl2d=%s (%s)", MO.Velocity, MoveDir, xdir, MO.Velocity.length2D, xdir.length2D, xdir.length2D/8);
  if (MO.Velocity.length2D >= xdir.length2D/8) {
    MoveDir = vector(0, 0, 0);
    return;
  }
  printdebug("WATERJUMP: 001: vel=%s; dir=%s; xdir=%s", MO.Velocity, MoveDir, xdir);
  +/
  MO.Velocity.x = xdir.x;
  MO.Velocity.y = xdir.y;
  */
}


//==========================================================================
//
//  ProcessSectorScroll
//
//==========================================================================
void ProcessSectorScroll (float deltaTime, EntityEx ent, sector_t *sec) {
  float speed;
  float finean;

  switch (sec->special&SECSPEC_BASE_MASK) {
    case SECSPEC_ScrollCurrent:
      speed = float((sec->sectorTag-100)%10)/16.0*35.0;
      finean = float((sec->sectorTag-100)/10)*45.0;
      ent.Velocity.x += speed*cos(finean);
      ent.Velocity.y += speed*sin(finean);
      break;
    case SECSPEC_ScrollNorthSlow:
    case SECSPEC_ScrollNorthMedium:
    case SECSPEC_ScrollNorthFast:
      ThrustPlayer(90.0, LineSpecialGameInfo(Level.Game).pushTab[(sec->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollNorthSlow], deltaTime);
      break;
    case SECSPEC_ScrollEastSlow:
    case SECSPEC_ScrollEastMedium:
    case SECSPEC_ScrollEastFast:
      ThrustPlayer(0.0, LineSpecialGameInfo(Level.Game).pushTab[(sec->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollEastSlow], deltaTime);
      break;
    case SECSPEC_ScrollSouthSlow:
    case SECSPEC_ScrollSouthMedium:
    case SECSPEC_ScrollSouthFast:
      ThrustPlayer(270.0, LineSpecialGameInfo(Level.Game).pushTab[(sec->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollSouthSlow], deltaTime);
      break;
    case SECSPEC_ScrollWestSlow:
    case SECSPEC_ScrollWestMedium:
    case SECSPEC_ScrollWestFast:
      ThrustPlayer(180.0, LineSpecialGameInfo(Level.Game).pushTab[(sec->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollWestSlow], deltaTime);
      break;
    case SECSPEC_ScrollNorthWestSlow:
    case SECSPEC_ScrollNorthWestMedium:
    case SECSPEC_ScrollNorthWestFast:
      ThrustPlayer(135.0, LineSpecialGameInfo(Level.Game).pushTab[(sec->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollNorthWestSlow], deltaTime);
      break;
    case SECSPEC_ScrollNorthEastSlow:
    case SECSPEC_ScrollNorthEastMedium:
    case SECSPEC_ScrollNorthEastFast:
      ThrustPlayer(45.0, LineSpecialGameInfo(Level.Game).pushTab[(sec->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollNorthEastSlow], deltaTime);
      break;
    case SECSPEC_ScrollSouthEastSlow:
    case SECSPEC_ScrollSouthEastMedium:
    case SECSPEC_ScrollSouthEastFast:
      ThrustPlayer(315.0, LineSpecialGameInfo(Level.Game).pushTab[(sec->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollSouthEastSlow], deltaTime);
      break;
    case SECSPEC_ScrollSouthWestSlow:
    case SECSPEC_ScrollSouthWestMedium:
    case SECSPEC_ScrollSouthWestFast:
      ThrustPlayer(225.0, LineSpecialGameInfo(Level.Game).pushTab[(sec->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollSouthWestSlow], deltaTime);
      break;
    case SECSPEC_ScrollEast5:
    case SECSPEC_ScrollEast10:
    case SECSPEC_ScrollEast25:
    case SECSPEC_ScrollEast30:
    case SECSPEC_ScrollEast35:
      ThrustPlayer(0.0, LineSpecialGameInfo(Level.Game).pushTab[(sec->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollEast5], deltaTime);
      break;
    case SECSPEC_ScrollNorth5:
    case SECSPEC_ScrollNorth10:
    case SECSPEC_ScrollNorth25:
    case SECSPEC_ScrollNorth30:
    case SECSPEC_ScrollNorth35:
      ThrustPlayer(90.0, LineSpecialGameInfo(Level.Game).pushTab[(sec->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollNorth5], deltaTime);
      break;
    case SECSPEC_ScrollSouth5:
    case SECSPEC_ScrollSouth10:
    case SECSPEC_ScrollSouth25:
    case SECSPEC_ScrollSouth30:
    case SECSPEC_ScrollSouth35:
      ThrustPlayer(270.0, LineSpecialGameInfo(Level.Game).pushTab[(sec->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollSouth5], deltaTime);
      break;
    case SECSPEC_ScrollWest5:
    case SECSPEC_ScrollWest10:
    case SECSPEC_ScrollWest25:
    case SECSPEC_ScrollWest30:
    case SECSPEC_ScrollWest35:
      ThrustPlayer(180.0, LineSpecialGameInfo(Level.Game).pushTab[(sec->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollWest5], deltaTime);
      break;
  }
}


//==========================================================================
//
//  PlayerProcessScrollSectors
//
//  Called every tic frame
//
//==========================================================================
void PlayerProcessScrollSectors (float deltaTime) {
  // process scroll sectors anyway (because we may slightly touch one of them)
  for (msecnode_t *mnode = EntityEx(MO).TouchingSectorList; mnode; mnode = mnode.TNext) {
    sector_t *sec = mnode.Sector;
    if (sec->special&SECSPEC_BASE_MASK) {
      if (MO.Origin.z == GetPointZClamped(ref sec->floor, MO.Origin)) {
        ProcessSectorScroll(deltaTime, EntityEx(MO), sec);
      }
    }
  }
}


//==========================================================================
//
//  FindProtectionSuit
//
//==========================================================================
Inventory FindProtectionSuit () {
  // search for iron feet power: any subclass will do
  Inventory IronFeet = EntityEx(MO).Inventory;
  while (IronFeet) {
    if (PowerIronFeet(IronFeet)) break;
    IronFeet = IronFeet.Inventory;
  }
  return IronFeet;
}


//==========================================================================
//
//  IsProtectionSuitActive
//
//  `leakChance` is byte; 0 means "always active", >255 means "never active"
//
//==========================================================================
bool IsProtectionSuitActive (int leakChance) {
  if (leakChance > 255) return false; // never active
  if (leakChance > 0 && P_Random() < leakChance) {
    //if (FindProtectionSuit()) printdebug("SUIT LEAKS! chance=%s", leakChance);
    return false; // suit leaks
  }
  // check if we actually have a suit
  return !!FindProtectionSuit();
}


//==========================================================================
//
//  InitSectorDamageInfo
//
//==========================================================================
void InitSectorDamageInfo (ref SectorDamageInfo pdi) {
  pdi.flatDamageType = '';
  pdi.flatDamage = 0;
  pdi.flatDamageTimeout = 0;
  pdi.flatDamageLeaky = 0;
  pdi.flatDamageExit = false;
  pdi.flatDamageHitFloor = false;
}


//==========================================================================
//
//  SetupSectorUDMFDamage
//
//==========================================================================
void SetupSectorUDMFDamage (float deltaTime, EntityEx ent, sector_t *sec, ref SectorDamageInfo pdi) {
  if (sec.Damage) {
    pdi.flatDamage = sec.Damage;
    pdi.flatDamageType = sec.DamageType;
    pdi.flatDamageTimeout = max(1, (sec.DamageInterval ? sec.DamageInterval : 32)); // 0 is "default 32"
    pdi.flatDamageLeaky = max(0, (sec.DamageLeaky ? sec.DamageLeaky : 5)); // 0 is "default 5"
    if (pdi.flatDamageType.nameEquCI('Exit')) {
      // EXIT SUPER DAMAGE! (for E1M8 finale)
      pdi.flatDamageType = ''; //FIXME
      pdi.flatDamageExit = true;
    }
    //printdebug("sector #%d: damage=%s; interval=%s; leak=%s; type=%s", sec-&Level.XLevel.Sectors[0], sec.Damage, sec.DamageInterval, sec.DamageLeaky, sec.DamageType);
    //printdebug("  pdi: flatDamage=%s; flatDamageType=%s; flatDamageTimeout=%s; flatDamageLeaky=%s; flatDamageExit=%B", pdi.flatDamage, pdi.flatDamageType, pdi.flatDamageTimeout, pdi.flatDamageLeaky, pdi.flatDamageExit);
  }
}


//==========================================================================
//
//  SetupSectorFlatDamage
//
//==========================================================================
void SetupSectorFlatDamage (float deltaTime, EntityEx ent, sector_t *sec, ref SectorDamageInfo pdi) {
  if (sec->special >= SECSPEC_LightFlicker && sec->special <= 255) {
    switch (sec->special) {
      case SECSPEC_DamageHellslime:
        pdi.flatDamageType = 'Slime';
        pdi.flatDamage = 10;
        pdi.flatDamageTimeout = 32;
        pdi.flatDamageLeaky = 5; // default leakage value
        break;
      case SECSPEC_DamageSludge:
        pdi.flatDamageType = 'Slime';
        pdi.flatDamage = 4;
        pdi.flatDamageTimeout = 32;
        pdi.flatDamageLeaky = 5; // default leakage value
        break;
      case SECSPEC_DamageNukage:
        pdi.flatDamageType = 'Slime'; //FIXME
        pdi.flatDamage = 5;
        pdi.flatDamageTimeout = 32;
        pdi.flatDamageLeaky = 5; // default leakage value
        break;
      case SECSPEC_LightStrobeFastDamage:
      case SECSPEC_DamageSuperHellslime:
        pdi.flatDamageType = 'Slime'; //FIXME
        pdi.flatDamage = 20;
        pdi.flatDamageTimeout = 32;
        pdi.flatDamageLeaky = 5; // default leakage value
        break;
      case SECSPEC_DamageSuperHellslimeExit:
        // EXIT SUPER DAMAGE! (for E1M8 finale)
        pdi.flatDamageType = ''; //FIXME
        pdi.flatDamage = 20;
        pdi.flatDamageTimeout = 32;
        pdi.flatDamageExit = true;
        pdi.flatDamageLeaky = 5; // default leakage value
        break;
      case SECSPEC_DamageLavaWimpy:
        pdi.flatDamageType = 'Fire';
        pdi.flatDamage = 5;
        pdi.flatDamageTimeout = 16;
        pdi.flatDamageHitFloor = true;
        pdi.flatDamageLeaky = 5; // default leakage value
        break;
      case SECSPEC_DamageLavaHefty:
        pdi.flatDamageType = 'Fire';
        pdi.flatDamage = 8;
        pdi.flatDamageTimeout = 16;
        pdi.flatDamageHitFloor = true;
        pdi.flatDamageLeaky = 5; // default leakage value
        break;
      case SECSPEC_ScrollEastLavaDamage:
        ThrustPlayer(0.0, 1024.0, deltaTime);
        pdi.flatDamageType = 'Fire';
        pdi.flatDamage = 5;
        pdi.flatDamageTimeout = 16;
        pdi.flatDamageHitFloor = true;
        pdi.flatDamageLeaky = 5; // default leakage value
        break;
      case SECSPEC_DamageHazard:
        // hack: leaky suit
        if (!IsProtectionSuitActive(5)) HazardTime += 2.0*deltaTime;
        break;
      case SECSPEC_DamageInstantDeath:
        ent.Damage(none, none, 999, 'InstantDeath', spawnBlood:true);
        break;
      case SECSPEC_DamageSuperHazard:
        // hack: leaky suit
        if (!IsProtectionSuitActive(5)) HazardTime += 4.0*deltaTime;
        break;
    }
  } else {
    // extended sector damage type
    switch (sec->special&SECSPEC_DAMAGE_MASK) {
      case 0x0100:
        pdi.flatDamageType = 'Fire';
        pdi.flatDamage = 5;
        pdi.flatDamageTimeout = 32;
        pdi.flatDamageLeaky = 5; // default leakage value
        break;
      case 0x0200:
        pdi.flatDamageType = 'Slime';
        pdi.flatDamage = 10;
        pdi.flatDamageTimeout = 32;
        pdi.flatDamageLeaky = 5; // default leakage value
        break;
      case 0x0300:
        pdi.flatDamageType = 'Slime';
        pdi.flatDamage = 20;
        pdi.flatDamageTimeout = 32;
        pdi.flatDamageLeaky = 5; // default leakage value
        break;
    }
  }
}


//==========================================================================
//
//  ApplySectorDamageInfo
//
//  performs no excessive checks
//  i.e. `LastSectorDamageTic` or height should be checked by a caller
//
//==========================================================================
void ApplySectorDamageInfo (float deltaTime, EntityEx ent, sector_t *sec, ref SectorDamageInfo pdi) {
  // any damage at all?
  if (!pdi.flatDamage) return;
  // is damage timeout ok?
  if (pdi.flatDamageTimeout < 1) pdi.flatDamageTimeout = 1; // prevent divides by zero
  if (Level.XLevel.TicTime%pdi.flatDamageTimeout) return;
  // suit prevents damage, but not special effects
  if (!IsProtectionSuitActive(pdi.flatDamageLeaky)) {
    auto oldCheats = Cheats;
    scope(exit) Cheats = oldCheats;
    if (pdi.flatDamageExit) Cheats &= ~CF_GODMODE;
    if (pdi.flatDamageType) {
      ent.Damage(none, none, pdi.flatDamage, pdi.flatDamageType);
    } else {
      ent.Damage(none, none, pdi.flatDamage);
    }
  }
  if (pdi.flatDamageHitFloor) ent.HitFloorType();
  if (pdi.flatDamageExit && Health <= 10) Level.ExitLevel(0);
}


//==========================================================================
//
//  ApplySectorDamage
//
//  caller should check if it is ok to call this (i.e. last damage tick)
//
//==========================================================================
void ApplySectorDamage (float deltaTime, EntityEx ent, sector_t *sec) {
  SectorDamageInfo pdi;

  // flat damage
  InitSectorDamageInfo(ref pdi);
  SetupSectorFlatDamage(deltaTime, ent, sec, ref pdi);
  if (pdi.flatDamage) ApplySectorDamageInfo(deltaTime, ent, sec, ref pdi);

  // UDMF sector damage
  if (sec->Damage) {
    //printdebug("sector #%d: damage=%s; interval=%s; leak=%s; type=%s", sec-&Level.XLevel.Sectors[0], sec.Damage, sec.DamageInterval, sec.DamageLeaky, sec.DamageType);
    InitSectorDamageInfo(ref pdi);
    SetupSectorUDMFDamage(deltaTime, ent, sec, ref pdi);
    if (pdi.flatDamage) ApplySectorDamageInfo(deltaTime, ent, sec, ref pdi);
  }
}


//==========================================================================
//
//  PlayerInSpecialSector
//
//==========================================================================
void PlayerInSpecialSector (float deltaTime) {
  // it doesn't matter if we're touching the floor or not for secret sectors
  if (MO.Sector->special&SECSPEC_SECRET_MASK) {
    // secret area
    ++SecretCount;
    ++Level.CurrentSecret;
    MO.Sector->special &= ~SECSPEC_SECRET_MASK;
    if (GetCvarB('show_secret_message')) centerprint("You found a secret area");
    if (GetCvarB('play_secret_sound')) MO.PlaySound('misc/secret', /*CHAN_VOICE*/CHAN_AUTO);
  }

  // do not apply damage continuously on the same tick
  if (LastSectorDamageTic < Level.XLevel.TicTime) {
    // this correctly processes 3d floors
    sector_t *swimmable;
    sector_t *tsec = EntityEx(MO).GetTouchedFloorSectorEx(out swimmable);
    if (tsec) ApplySectorDamage(deltaTime, EntityEx(MO), tsec);
    if (swimmable) ApplySectorDamage(deltaTime, EntityEx(MO), swimmable);

    /*
    if (MO.Origin.z != GetPointZClamped(ref MO.Sector->floor, MO.Origin) && !MO.WaterLevel) {
      // player is (possibly) not touching the floor
      tsec = EntityEx(MO).GetTouchedFloorSector();
      if (!tsec) return;
      printdebug("%C: orgz=%s; fz=%s; 3dfloor", self, MO.Origin.z, MO.FloorZ);
    }
    */
  }
}


//============================================================================
//
//  PlayerOnSpecialFlat
//
//  Called every tic frame.
//
//============================================================================
void PlayerOnSpecialFlat (VTerrainInfo *floorType) {
  if (!floorType) return;
  if (MO.Origin.z != MO.FloorZ) return; // player is not touching the floor

  if (!floorType->DamageAmount) return;
  if (!(Level.XLevel.TicTime&floorType->DamageTimeMask)) return; // is this condition right?

  // apply protection suit (leaky)
  if (floorType->bAllowProtection && IsProtectionSuitActive(5)) return;

  EntityEx(MO).Damage(none, none, floorType->DamageAmount, floorType->DamageType/*, spawnBlood:true*/);
  //FIXME: use `DamageAmount` here?
  //EntityEx(MO).Damage(none, none, 10, 'Fire'/*, spawnBlood:true*/);
  //MO.PlaySound('world/lavasizzle', CHAN_BODY);
}


//==========================================================================
//
//  PlayerInContents
//
//  Called every tic frame.
//
//==========================================================================
void PlayerInContents (float deltaTime) {
  if (!MO.WaterLevel) return;

  name flatDamageType = '';
  int flatDamage = 0;
  int flatDamageTimeout;

  switch (MO.WaterType) {
    case CONTENTS_LAVA:
      flatDamageType = 'Fire';
      flatDamage = 10;
      flatDamageTimeout = 32;
      break;
    case CONTENTS_NUKAGE:
      flatDamageType = 'Slime'; //FIXME
      flatDamage = 5;
      flatDamageTimeout = 32;
      break;
    case CONTENTS_SLIME:
      flatDamageType = 'Slime';
      flatDamage = 10;
      flatDamageTimeout = 32;
      break;
    case CONTENTS_HELLSLIME:
      flatDamageType = 'Slime';
      flatDamage = 20;
      flatDamageTimeout = 32;
      break;
    case CONTENTS_SLUDGE:
      flatDamageType = 'Slime'; //FIXME
      flatDamage = 4;
      flatDamageTimeout = 32;
      break;
    case CONTENTS_HAZARD:
      // apply protection suit (leaky)
      if (!IsProtectionSuitActive(5)) HazardTime += 2.0*deltaTime;
      return;
  }

  // apply flat damage?
  if (!flatDamage) return;
  // check timeout
  if (Level.XLevel.TicTime%flatDamageTimeout) return;
  // apply protection suit (leaky)
  if (IsProtectionSuitActive(5)) return;

  if (flatDamageType) {
    EntityEx(MO).Damage(none, none, flatDamage, flatDamageType);
  } else {
    EntityEx(MO).Damage(none, none, flatDamage);
  }
}


//==========================================================================
//
//  SetPlayerRunState
//
//==========================================================================
void SetPlayerRunState () {
  EntityEx mobj = EntityEx(MO);
  if (!mobj) return;
  if (mobj.SeeState && /*mobj.State == mobj.IdleState*/StateIsInSequence(mobj.State, mobj.IdleState)) {
    //printdebug("%C: going to see state %s from %s", mobj, mobj.IdleState, mobj.State);
    mobj.SetState(mobj.SeeState);
  }
  /*
  else {
    printdebug("%C: CANNOT go to see state %s", mobj, mobj.State);
  }
  */
}


//***************************************************************************
//
//  WEAPON UTILITES
//
//***************************************************************************

//==========================================================================
//
//  SetWeapon
//
//==========================================================================
void SetWeapon (Weapon NewWeapon) {
  ReadyWeapon = NewWeapon;
  PendingWeapon = none;
  if (NewWeapon) {
    PSpriteSY = NewWeapon.PSpriteSY;
    MO.ModelVersion = NewWeapon.PlayerModelVersion;
  } else {
    PSpriteSY = 0;
    MO.ModelVersion = 0;
    SetViewObject(none);
    SetViewState(PS_WEAPON, none);
  }
}


//===========================================================================
//
//  BringUpWeapon
//
//  Starts bringing the pending weapon up from the bottom of the screen.
//
//===========================================================================
void BringUpWeapon (optional bool instant, optional bool skipSound) {
  //print("BringUpWeapon: %C (instant=%B: skipSound=%B)", ReadyWeapon, instant, skipSound);
  if (!skipSound && ReadyWeapon && ReadyWeapon.UpSound) {
    MO.PlaySound(ReadyWeapon.UpSound, CHAN_WEAPON);
  }

  if (PendingWeapon && PendingWeapon == ReadyWeapon) {
    printwarn("%C: RAISING ALREADY RAISED WEAPON! (0)", ReadyWeapon);
    //return;
  }

  PendingWeapon = none;
  SetViewStateOffsets(0, (instant || bInstantWeaponSwitch ? Weapon::WEAPONTOP : Weapon::WEAPONBOTTOM));
  ResetWeaponReloadRefire();
  // block firing for "no autofire" weapons
  bAttackDown = true;
  bAltAttackDown = true;
  if (ReadyWeapon) {
    ReadyWeapon.bBobDisabled = true;
    SetViewObject(ReadyWeapon);
    //dprint("MO=%C; RW=%C; upstate=%s", MO, ReadyWeapon, ReadyWeapon.GetUpState());
    //k8: old code did "up state" anyway; this seems to be wrong
    if (instant || bInstantWeaponSwitch) {
      if (instant) {
        SetViewState(PS_WEAPON, ReadyWeapon.GetInstaReadyState());
      } else {
        SetViewState(PS_WEAPON, ReadyWeapon.GetReadyState());
      }
    } else {
      //print("BRINGING %C: curr=%s; top=%s; bot=%s", ReadyWeapon, ViewStateSY, Weapon::WEAPONTOP, Weapon::WEAPONBOTTOM);
      SetViewState(PS_WEAPON, ReadyWeapon.GetUpState());
    }
    //dprint("MO=%C; RW=%C", MO, ReadyWeapon);
    if (!ReadyWeapon) {
      SetViewObject(none);
      print("RAISING NONE WEAPON! (0)");
      MO.ModelVersion = 0;
      PSpriteSY = 0;
      return;
    }
    MO.ModelVersion = ReadyWeapon.PlayerModelVersion;
  } else {
    SetViewObject(none);
    MO.ModelVersion = 0;
    PSpriteSY = 0;
  }
}


//===========================================================================
//
//  DropWeapon
//
//  Player died, so put the weapon away.
//
//===========================================================================
void DropWeapon () {
  ResetWeaponReloadRefire();
  ResetWeaponActionFlags();
  if (ReadyWeapon) {
    printdebug("%C: bringing weapon %C down: %s", self, ReadyWeapon, ReadyWeapon.GetDownState());
    SetViewObject(ReadyWeapon);
    SetViewState(PS_WEAPON, ReadyWeapon.GetDownState());
  }
}


//===========================================================================
//
//  SetupPsprites
//
//  Called at start of level for each player.
//
//===========================================================================
void SetupPsprites () {
  // remove all psprites
  foreach (auto i; 0..NUMPSPRITES) {
    SetViewObject(none);
    SetViewState(i, none);
  }

  // spawn the gun
  BringUpWeapon();
}


//==========================================================================
//
//  ProcessWeaponActions
//
//==========================================================================
void ProcessWeaponActions () {
  if (PendingWeapon == ReadyWeapon) PendingWeapon = none;

  if (!MO || MO.Health <= 0 || PlayerState != PST_LIVE) {
    ResetWeaponReloadRefire();
    ResetWeaponActionFlags();
    return;
  }

  #if 0
  if (bWeaponAllowSwitch ||
      bWeaponAllowPrimaryFire ||
      bWeaponAllowAltFire ||
      bWeaponAllowReload ||
      bWeaponAllowZoom)
  {
    printdebug("%C: bWeaponAllowSwitch=%B", self, bWeaponAllowSwitch);
    printdebug("%C: bWeaponAllowPrimaryFire=%B", self, bWeaponAllowPrimaryFire);
    printdebug("%C: bWeaponAllowAltFire=%B", self, bWeaponAllowAltFire);
    printdebug("%C: bWeaponAllowReload=%B", self, bWeaponAllowReload);
    printdebug("%C: bWeaponAllowZoom=%B", self, bWeaponAllowZoom);
  }
  #endif

  if (bWeaponAllowSwitch) {
    if (PendingWeapon && !bDisableWeaponSwitch) {
      ResetWeaponReloadRefire();
      ResetWeaponActionFlags();
      if (ReadyWeapon) {
        ReadyWeapon.bBobDisabled = true;
        SetViewObject(ReadyWeapon);
        SetViewState(PS_WEAPON, ReadyWeapon.GetDownState());
      } else if (PendingWeapon) {
        SetWeapon(PendingWeapon);
        BringUpWeapon();
      }
      return;
    }
  }

  Weapon Wpn = ReadyWeapon;
  if (!Wpn) {
    ResetWeaponReloadRefire();
    ResetWeaponActionFlags();
    bWeaponAllowSwitch = true;
    ResetPlayerFiringState();
    return;
  }

  if (!bWeaponWasWeaponReady) return;
  bWeaponWasWeaponReady = false;

  bool oldNoBob = Wpn.bBobDisabled;

  if (bWeaponAllowPrimaryFire && (Buttons&BT_ATTACK) && (!bAttackDown || !Wpn.bNoAutoFire) && Wpn.FindState('Fire')) {
    bAttackDown = true;
    Wpn.bBobDisabled = true;
    if (FireWeapon()) return;
    Wpn.bBobDisabled = oldNoBob;
  }

  if (bWeaponAllowAltFire && (Buttons&BT_ALT_ATTACK) && (!bAltAttackDown || !Wpn.bNoAutoFire) && Wpn.FindState('AltFire')) {
    bAltAttackDown = true;
    Wpn.bBobDisabled = true;
    if (AltFireWeapon()) return;
    Wpn.bBobDisabled = oldNoBob;
  }

  // cannot fire
  ResetPlayerFiringState();
  Refire = 0;

  if (bWeaponAllowReload && ((Buttons&BT_RELOAD) || bReloadQueued)) {
    // `bReloadQueued` will be reset by `ReloadWeapon()`
    Wpn.bBobDisabled = true;
    if (ReloadWeapon()) return;
    Wpn.bBobDisabled = oldNoBob;
  }

  if (bWeaponAllowZoom && (Buttons&BT_ZOOM) && !bZoomDown && Wpn.GetZoomState()) {
    bZoomDown = true;
    Wpn.bBobDisabled = true;
    if (ZoomWeapon()) return;
    Wpn.bBobDisabled = oldNoBob;
  }

  if (bWeaponAllowUser1 && (Buttons&BT_BUTTON_5) && !bButton5Down && Wpn.FindState('User1')) {
    bButton5Down = true;
    Wpn.bBobDisabled = true;
    if (WeaponUserAction(1)) return;
    Wpn.bBobDisabled = oldNoBob;
  }

  if (bWeaponAllowUser2 && (Buttons&BT_BUTTON_6) && !bButton6Down && Wpn.FindState('User2')) {
    bButton6Down = true;
    Wpn.bBobDisabled = true;
    if (WeaponUserAction(2)) return;
    Wpn.bBobDisabled = oldNoBob;
  }

  if (bWeaponAllowUser3 && (Buttons&BT_BUTTON_7) && !bButton7Down && Wpn.FindState('User3')) {
    bButton7Down = true;
    Wpn.bBobDisabled = true;
    if (WeaponUserAction(3)) return;
    Wpn.bBobDisabled = oldNoBob;
  }

  if (bWeaponAllowUser4 && (Buttons&BT_BUTTON_8) && !bButton8Down && Wpn.FindState('User4')) {
    bButton8Down = true;
    Wpn.bBobDisabled = true;
    if (WeaponUserAction(4)) return;
    Wpn.bBobDisabled = oldNoBob;
  }
}


//==========================================================================
//
//  MovePsprites
//
//  Called every tic by player thinking routine.
//
//==========================================================================
void MovePsprites (float deltaTime) {
  // moved here, so weapon can bob independently
  Weapon wpn = Weapon(ReadyWeapon);

  float newBobX = 0.0, newBobY = 0.0;

  //printdebug("%C: ReadyWeapon=%C; PendingWeapon=%C", self, ReadyWeapon, PendingWeapon);
  SetViewObject(ReadyWeapon);
  AdvanceViewStates(deltaTime);
  ProcessWeaponActions();

  wpn = Weapon(ReadyWeapon);

  if (PlayerState == PST_LIVE) {
    if (!ReadyWeapon) {
      if (wpn) printwarn("PLAYER: ReadyWeapon `%C` died, PendingWeapon is `%C`", wpn, PendingWeapon);
      bWeaponAllowSwitch = true;
    } else {
      if (!ViewStates[PS_WEAPON].State) {
        if (wpn) printwarn("PLAYER: ReadyWeapon %C (%C) removed itself, PendingWeapon is %C", ReadyWeapon, wpn, PendingWeapon);
        ReadyWeapon = none;
        SetViewStateOffsets(0, 0);
        bWeaponAllowSwitch = true;
      } else if (ViewStates[PS_WEAPON].StateTime < 0) {
        // this is totally wrong, because it cannot call `A_WeaponReady()`, and weapon switching is impossible
        //printwarn("PLAYER: ReadyWeapon %C (%C) put itself into endless state", ReadyWeapon, wpn, PendingWeapon);
        //ReadyWeapon = none;
        //SetViewStateOffsets(0, 0);
        bWeaponAllowSwitch = true;
      }
    }
  }

  if (MO && wpn && !wpn.bDontBob && !wpn.bBobDisabled) {
    // bob the weapon based on movement speed
    float mvbobbob = fmin(GetCvarF('weaponbob'), 1.0);
    if (mvbobbob > 0) {
      // regular movement bobbing (and don't allow too big bobbing too)
      float wbob = fclamp(MO.Velocity.x*MO.Velocity.x+MO.Velocity.y*MO.Velocity.y, -370492.0/2.5, +370492.0/2.5);
      //if (wbob) printdebug("wbob=%s", wbob);
      /*
      if (wbob < 300) {
        float dx = ViewStateBobOfsX;
        float dy = ViewStateBobOfsY;
        float move = 4.0*deltaTime;
        float mx = (dx < 0 ? fmin(dx+move, 0.0) : fmax(dx-move, 0.0));
        float my = (dy < 0 ? fmin(dy+move, 0.0) : fmax(dy-move, 0.0));
        if (dx || dy) printdebug("dx=%s; dy=%s; mx=%s; my=%s", dx, dy, mx, my);
        dx = (fabs(dx) <= 0.01 ? 0 : mx);
        dy = (fabs(dy) <= 0.01 ? 0 : my);
        ViewStateBobOfsX = dx;
        ViewStateBobOfsY = dy;
      } else
      */
      {
        wbob /= (3.0/mvbobbob)*35.0*35.0;
        if (wbob > MAXBOB) wbob = MAXBOB;
        float angle = AngleMod360(180.0*MO.XLevel.Time);
        newBobX = /*1.0+*/wbob*cos(angle); //k8: why it did `1.0+` here?
        if (angle >= 180.0) angle -= 180.0;
        newBobY = wbob*sin(angle);
      }
    }
    /*
    float wbob = Bob*fclamp(GetCvarF('weaponbob'), 0.0, 1.0);
    float angle = AngleMod360(180.0*MO.XLevel.Time);
    ViewStateSX = 1.0+wbob*cos(angle);
    if (angle >= 180.0) angle -= 180.0;
    ViewStateSY = Weapon::WEAPONTOP+wbob*sin(angle);
    */
  }

  ViewStateBobOfsX = newBobX;
  ViewStateBobOfsY = newBobY;
}


//==========================================================================
//
//  SetPlayerWeaponState
//
//  changes player state (animation)
//  if `newstate` is `none`, set idle state if we're in attacking one
//  never use to set idle state!
//
//==========================================================================
void SetPlayerWeaponState (state newstate) {
  // get player out of attack state
  EntityEx ee = EntityEx(MO);
  if (!ee) return;
  if (newstate) {
    if (newstate != ee.IdleState) ee.SetState(newstate);
  } else {
    if (!ee.IdleState) return;
    if ((ee.MissileState && StateIsInSequence(ee.State, ee.MissileState)) ||
        (ee.MeleeState && StateIsInSequence(ee.State, ee.MeleeState)))
    {
      ee.SetState(ee.IdleState);
    }
  }
}


//==========================================================================
//
//  ResetPlayerFiringState
//
//==========================================================================
void ResetPlayerFiringState () {
  // get player out of attack state
  EntityEx ee = EntityEx(MO);
  if (!ee) return;
  if (!ee.IdleState) return;
  if ((ee.MissileState && StateIsInSequence(ee.State, ee.MissileState)) ||
      (ee.MeleeState && StateIsInSequence(ee.State, ee.MeleeState)))
  {
    //printdebug("%C: setting idle state", self);
    ee.SetState(ee.IdleState);
  } else {
    state st = ee.FindState('Melee', 'Crouch', Exact:true);
    if (st && StateIsInSequence(ee.State, st)) { ee.SetState(ee.IdleState); return; }
    st = ee.FindState('Missile', 'Crouch', Exact:true);
    if (st && StateIsInSequence(ee.State, st)) { ee.SetState(ee.IdleState); return; }
  }
}


//===========================================================================
//
//  CommonFireWeapon
//
//  `firetype` is `Weapon::FIRE_Primary` or `Weapon::FIRE_Secondary`
//
//  returns `true` if weapon state was changed
//
//===========================================================================
bool CommonFireWeapon (int firetype, state firestate) {
  bReloadQueued = false;
  if (!firestate) return false; // just in case
  assert(firetype == Weapon::FIRE_Primary || firetype == Weapon::FIRE_Secondary);
  if (!ReadyWeapon || !ReadyWeapon.CheckAmmo(firetype, AutoSwitch:true)) return false;
  ReadyWeapon.FireMode = firetype;
  EntityEx ee = EntityEx(MO);
  if (ee) {
    state st;
    if (ee.crouchfactor < 1) {
      // try crouch states
      if (ReadyWeapon.bBotMelee) st = ee.FindState('Melee', 'Crouch', Exact:true);
      if (!st) st = ee.FindState('Missile', 'Crouch', Exact:true);
    }
    if (!st) {
      if (ReadyWeapon.bBotMelee) st = ee.MeleeState;
      if (!st) st = ee.MissileState;
    }
    if (st && !StateIsInSequence(ee.State, st)) {
      //printdebug("%C: setting attack state %s", self, st);
      ee.SetState(st);
    }
  }
  SetViewObject(ReadyWeapon);
  SetViewState(PS_WEAPON, firestate);
  if (ReadyWeapon && !ReadyWeapon.bNoAlert) {
    LineSpecialLevelInfo(Level).NoiseAlert(EntityEx(MO), EntityEx(MO));
  }
  return true;
}


//===========================================================================
//
//  FireWeapon
//
//===========================================================================
bool FireWeapon (optional state firestate) {
  if (!ReadyWeapon) return false;
  if (!firestate) firestate = ReadyWeapon.GetAttackState(Refire);
  return CommonFireWeapon(Weapon::FIRE_Primary, firestate);
}


//===========================================================================
//
//  AltFireWeapon
//
//===========================================================================
bool AltFireWeapon (optional state firestate) {
  if (!ReadyWeapon) return false;
  if (!firestate) firestate = ReadyWeapon.GetAltAttackState(Refire);
  return CommonFireWeapon(Weapon::FIRE_Secondary, firestate);
}


//===========================================================================
//
//  ReloadWeapon
//
//  returns `true` if weapon state was changed
//
//===========================================================================
bool ReloadWeapon () {
  //k8: reloading weapon resets refire state
  ResetWeaponReloadRefire();
  if (ReadyWeapon) {
    state rst = ReadyWeapon.GetReloadState();
    if (!rst) return false;
    //printdebug("reloading %C: state is %s", ReadyWeapon, rst);
    // set player pawn to reloading state, if there is any, or into idle one
    SetPlayerWeaponState(MO.FindState('Reload'));
    SetViewObject(ReadyWeapon);
    SetViewState(PS_WEAPON, rst);
    //printdebug("reloading %C: SET state is %s", ReadyWeapon, rst);
    return true;
  }
  return false;
}


//===========================================================================
//
//  ZoomWeapon
//
//  returns `true` if weapon state was changed
//
//===========================================================================
bool ZoomWeapon () {
  //k8: zooming weapon resets refire state
  ResetWeaponReloadRefire();
  if (ReadyWeapon) {
    state zst = ReadyWeapon.GetZoomState();
    if (!zst) return false;
    SetPlayerWeaponState(MO.FindState('Zoom'));
    SetViewObject(ReadyWeapon);
    SetViewState(PS_WEAPON, zst);
    return true;
  }
  return false;
}


//===========================================================================
//
//  WeaponUserAction
//
//  returns `true` if weapon state was changed
//
//===========================================================================
bool WeaponUserAction (int actnum) {
  if (actnum < 1 || actnum > 4) return false;
  ResetWeaponReloadRefire();
  if (ReadyWeapon) {
    name stname;
    switch (actnum) {
      case 1: stname = 'User1'; break;
      case 2: stname = 'User2'; break;
      case 3: stname = 'User3'; break;
      case 4: stname = 'User4'; break;
    }
    state zst = ReadyWeapon.FindState(stname);
    if (!zst) return false;
    SetPlayerWeaponState(MO.FindState(stname));
    SetViewObject(ReadyWeapon);
    SetViewState(PS_WEAPON, zst);
    return true;
  }
  return false;
}


//==========================================================================
//
//  SetPendingWeapon
//
//==========================================================================
void SetPendingWeapon (Weapon NewWpn) {
  if (!NewWpn) return;
  if (MorphTime) return;
  if (NewWpn == ReadyWeapon) return;
  // do not select morph weapon, do not change morph weapon
  if (NewWpn.bGivenAsMorphWeapon || (ReadyWeapon && ReadyWeapon.bGivenAsMorphWeapon)) return;
  bReloadQueued = false;
  bReloadDown = false;
  PendingWeapon = NewWpn;
}


//==========================================================================
//
//  ChangeWeapon
//
//  The actual changing of the weapon is done when the weapon psprite can
//  do it (read: not in the middle of an attack).
//
//==========================================================================
void ChangeWeapon (int slot) {
  SetPendingWeapon(GetSlotChangeWeapon(slot));
}


//==========================================================================
//
//  PrevWeapon
//
//==========================================================================
void PrevWeapon () {
  SetPendingWeapon(GetPrevWeapon(PendingWeapon ? PendingWeapon : ReadyWeapon));
}


//==========================================================================
//
//  NextWeapon
//
//==========================================================================
void NextWeapon () {
  SetPendingWeapon(GetNextWeapon(PendingWeapon ? PendingWeapon : ReadyWeapon));
}


//==========================================================================
//
//  BestWeapon
//
//  Returns best weapon to use
//
//==========================================================================
Weapon BestWeapon (optional class!Ammo AmmoType) {
  if (!MO) return none;
  bool Powered = !!EntityEx(MO).FindInventory(PowerWeaponLevel2);
  Weapon Best = none;
  for (Inventory Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory) {
    // must be a weapon
    Weapon Wpn = Weapon(Item);
    if (!Wpn) continue;
    // never ever select rocket lanucher
    if (Wpn.bBotProjectile) continue;
    // no selection order -- skip it
    if (Wpn.SelectionOrder < 1) continue;
    // check if best one is better that this one
    if (Best && Wpn.SelectionOrder > Best.SelectionOrder) continue;
    // possibly limit to specific ammo type
    if (AmmoType && Wpn.AmmoType1 != AmmoType) continue;
    // check if it's for the current tome of power state
    if (Powered && Wpn.SisterWeapon && Wpn.SisterWeapon.bPoweredUp) continue;
    if (!Powered && Wpn.bPoweredUp) continue;
    // make sure it has enough ammo
    if (!Wpn.CheckAmmo(Weapon::FIRE_Either, AutoSwitch:false)) continue;
    // good one
    Best = Wpn;
  }
  return Best;
}


//==========================================================================
//
//  ChoosePowered
//
//==========================================================================
Weapon ChoosePowered (Weapon Wpn) {
  if (!Wpn) return none;
  bool Powered = !!EntityEx(MO).FindInventory(PowerWeaponLevel2);
  if (Powered && Wpn.SisterWeapon && Wpn.SisterWeapon.bPoweredUp) {
    return Wpn.SisterWeapon;
  }
  return Wpn;
}


//==========================================================================
//
//  GetSlotChangeWeapon
//
//==========================================================================
Weapon GetSlotChangeWeapon (int slot) {
  auto pawn = PlayerPawn(MO);
  if (!pawn) return ReadyWeapon;

  if (slot < 1 || slot > pawn.GetNumberOfSlots()) return ReadyWeapon;
  --slot;

  // note that slot selection goes from the last weapon to the first weapon
  int slotsize = pawn.GetSlotSize(slot);
  if (!slotsize) return ReadyWeapon; // this slot is empty, nothing to do

  // find ready weapon position in slot (if any)
  int cwidx = slotsize;
  if (ReadyWeapon) {
    class!Weapon readyWpnClass = class!Weapon(ReadyWeapon.Class);
    if (readyWpnClass) {
      foreach (auto i; 0..slotsize; reverse) {
        class!Weapon slotwpn = pawn.GetWeaponInSlot(slot, i);
        if (!slotwpn) continue;
        if (slotwpn == readyWpnClass ||
            (ReadyWeapon.bPoweredUp && ReadyWeapon.SisterWeapon &&
             slotwpn == ReadyWeapon.SisterWeapon.Class))
        {
          // i found her!
          cwidx = i;
          break;
        }
      }
    }
  }

  // now cycle through the slot
  foreach (auto i; 0..slotsize) {
    // step back
    if ((--cwidx) < 0) cwidx = slotsize-1;
    // get weapon in slot position
    class!Weapon slotwpn = pawn.GetWeaponInSlot(slot, cwidx);
    if (!slotwpn) continue;
    // check if we have it in our inventory
    Weapon Wpn = Weapon(EntityEx(MO).FindInventory(slotwpn, disableReplacement:true));
    // check if it has ammo
    if (Wpn && Wpn.CheckAmmo(Weapon::FIRE_Either, AutoSwitch:false)) return ChoosePowered(Wpn);
  }

  return ReadyWeapon;
}


//==========================================================================
//
//  CycleWeaponWithDir
//
//==========================================================================
Weapon CycleWeaponWithDir (Weapon Current, bool forward) {
  auto pawn = PlayerPawn(MO);
  if (!pawn) return Current;
  if (!pawn.GetNumberOfSlots()) return Current; // just in case

  // find current weapon slot and index
  int currSlot, currIndex;
  if (!Current || !pawn.FindWeaponSlot(class!Weapon(Current.Class), out currSlot, out currIndex/*, debug:true*/)) {
    currSlot = 0;
    currIndex = (forward ? pawn.GetSlotSize(currSlot) : -1);
  }

  //printdebug("st(fwd=%B): s=%s; i=%s; current=%C", forward, currSlot, currIndex, Current);
  //if (Current) printdebug("  CW=%C; Wpn.SelectionOrder=%s", Current, Current.SelectionOrder);
  // now cycle
  int smax = pawn.GetNumberOfSlots();
  bool allowExtraSlot = (currSlot >= PlayerPawn::NUM_WEAPON_SLOTS || (smax > PlayerPawn::NUM_WEAPON_SLOTS && GetCvarB('wp_cycle_special_slot')));
  if (!allowExtraSlot) smax = PlayerPawn::NUM_WEAPON_SLOTS;
  foreach (auto sidx; 0..smax) {
    foreach (auto widx; 0..pawn.GetSlotSize(sidx)) {
      // move to the next weapon in slot
      if (forward) pawn.IncrementWeaponIndex(ref currSlot, ref currIndex, allowExtraSlot); else pawn.DecrementWeaponIndex(ref currSlot, ref currIndex, allowExtraSlot);
      class!Weapon swc = pawn.GetWeaponInSlot(currSlot, currIndex);
      //printdebug("  000: st(fwd=%B): s=%s; i=%s; sidx=%s; widx=%s; wpn=%C", forward, currSlot, currIndex, sidx, widx, swc);
      if (!swc) continue;
      if (Current && Current.Class == swc) continue;
      Weapon Wpn = Weapon(EntityEx(MO).FindInventory(swc, disableReplacement:true));
      if (!Wpn) continue;
      //printdebug("  001: st(fwd=%B): s=%s; i=%s; sidx=%s; widx=%s; wpn=%C", forward, currSlot, currIndex, sidx, widx, Wpn);
      if (Wpn.CheckAmmo(Weapon::FIRE_Either, AutoSwitch:false)) {
        //printdebug("  002: st(fwd=%B): s=%s; i=%s; sidx=%s; widx=%s; wpn=%C (%C)", forward, currSlot, currIndex, sidx, widx, Wpn, ChoosePowered(Wpn));
        return ChoosePowered(Wpn);
      }
    }
  }

  return Current;
}


//==========================================================================
//
//  GetPrevWeapon
//
//==========================================================================
Weapon GetPrevWeapon (Weapon Current) {
  return CycleWeaponWithDir(Current, forward:false);
}


//==========================================================================
//
//  GetNextWeapon
//
//==========================================================================
Weapon GetNextWeapon (Weapon Current) {
  return CycleWeaponWithDir(Current, forward:true);
}


//==========================================================================
//
//  UsePuzzleItem
//
//  USING A PUZZLE ITEM
//
//  Returns true if the puzzle item was used on a line or a thing.
//
//==========================================================================
bool UsePuzzleItem (int PuzzleItemType) {
  TVec PuzzleUseDir;
  intercept_t* in;

  float ur, utr;
  GetUseRanges(out ur, out utr);

  AngleVector(MO.Angles, out PuzzleUseDir);
  float x1 = MO.Origin.x;
  float y1 = MO.Origin.y;
  float x2 = x1+/*DEFAULT_USERANGE*/ur*PuzzleUseDir.x;
  float y2 = y1+/*DEFAULT_USERANGE*/ur*PuzzleUseDir.y;
  foreach MO.PathTraverse(in, x1, y1, x2, y2, PT_ADDLINES|PT_ADDTHINGS/*|PT_EARLYOUT*/) {
    EntityEx mobj;
    TVec hit_point;
    opening_t *open;

    if (in->bIsALine) {
      // check line
      hit_point = MO.Origin+(/*DEFAULT_USERANGE*/ur*in->frac)*PuzzleUseDir;
      if (in->line->special != LNSPEC_UsePuzzleItem) {
        if (in->line->flags&(ML_BLOCKEVERYTHING|ML_BLOCKUSE)) {
          // gozzo does this
          open = nullptr;
        } else {
          open = LineOpenings(in->line, hit_point);
        }
        if (!open || open->range <= 0.0) {
          if (MO.bIsPlayer) MO.PlaySound('*puzzfail', CHAN_VOICE);
          break; // can't use through a wall
        }
        continue; // continue searching
      }
      if (PointOnPlaneSide(MO.Origin, *in->line) == 1) {
        // don't use back sides
        break;
      }
      if (PuzzleItemType != in->line->arg1) {
        // item type doesn't match
        break;
      }
      MO.XLevel.StartACS(in->line->arg2, 0, in->line->arg3,
        in->line->arg4, in->line->arg5, MO, in->line, 0, false,
        false);
      in->line->special = 0;
      return true; // stop searching
    }
    // check thing
    mobj = EntityEx(in->Thing);
    if (mobj.Special != LNSPEC_UsePuzzleItem) {
      // wrong special
      continue;
    }
    if (PuzzleItemType != mobj.Args[0]) {
      // item type doesn't match
      continue;
    }
    MO.XLevel.StartACS(mobj.Args[1], 0, mobj.Args[2], mobj.Args[3],
      mobj.Args[4], MO, nullptr, 0, false, false);
    mobj.Special = 0;
    return true; // Stop searching
  }
  return false;
}


//==========================================================================
//
//  AddRevealedMap
//
//==========================================================================
bool AddRevealedMap () {
  bAutomapRevealed = true;
  foreach (auto i; 0..RevealedMaps.length) {
    if (RevealedMaps[i] == Level.XLevel.MapName) return false; // already revealed
  }
  RevealedMaps.length = RevealedMaps.length+1;
  RevealedMaps[RevealedMaps.length-1] = Level.XLevel.MapName;
  return true;
}


//==========================================================================
//
//  RemoveRevealedMap
//
//==========================================================================
void RemoveRevealedMap () {
  bAutomapRevealed = false;
  foreach (auto i; 0..RevealedMaps.length) {
    if (RevealedMaps[i] == Level.XLevel.MapName) {
      RevealedMaps.Remove(i);
      return;
    }
  }
}


//==========================================================================
//
//  UpdateRevealedMap
//
//==========================================================================
void UpdateRevealedMap () {
  bAutomapRevealed = false;
  foreach (auto i; 0..RevealedMaps.length) {
    if (RevealedMaps[i] == Level.XLevel.MapName) {
      bAutomapRevealed = true;
      return;
    }
  }
}


//==========================================================================
//
//  ParticleEffect
//
//==========================================================================
void ParticleEffect (int count, int type1, int type2, TVec origin, float ornd,
                     TVec velocity, float vrnd, float acceleration, float grav,
                     int clr, float duration, float ramp)
{
  Level.ParticleEffect(count, type1, type2, origin, ornd, velocity, vrnd, acceleration,
        grav, clr, duration, ramp);
}


//==========================================================================
//
//  DecalEffect
//
//==========================================================================
void DecalEffect (TVec org, name dectype, int side, /*line_t *li*/int lineidx, int translation) {
  if (!dectype || lineidx < 0 || !Level.XLevel) return; // just in case
  if (lineidx >= Level.XLevel.Lines.length) return;
  Level.XLevel.AddDecal(org, dectype, side, &Level.XLevel.Lines[lineidx], translation);
}


//==========================================================================
//
//  ClientExplosion
//
//==========================================================================
void ClientExplosion (int clr, float rad, TVec org) {
  dlight_t *dl = Level.AllocDlight(none, org, rad+150.0);
  if (dl) {
    //dl->origin = org;
    //dl->radius = rad+150.0;
    dl->color = clr;
    dl->die = Level.XLevel.Time+0.5;
    dl->decay = 300.0;
  }
}


//==========================================================================
//
//  ClientParticleExplosion
//
//==========================================================================
void ClientParticleExplosion (int clr, float rad, TVec org) {
  TVec porg;
  foreach (auto i; 0..512/*1024*/) {
    porg.x = org.x+((Random()*32.0)-16.0);
    porg.y = org.y+((Random()*32.0)-16.0);
    porg.z = org.z+((Random()*32.0)-16.0);
    particle_t *p = Level.NewParticle(porg);
    if (!p) break;
    p->die = Level.XLevel.Time+5.0;
    p->color = LineSpecialGameInfo.default.ramp1[0];
    p->Size = 1.0;
    p->ramp = Random()*4.0;
    if (i&1) {
      p->type = LineSpecialLevelInfo::pt_explode;
    } else {
      p->type = LineSpecialLevelInfo::pt_explode2;
    }
    p->vel.x = (Random()*512.0)-256.0;
    p->vel.y = (Random()*512.0)-256.0;
    p->vel.z = (Random()*512.0)-256.0;
    //p->accel = (Random()*512.0)-256.0;
    p->gravity = 40.0+(Random()*512.0)-256.0;
  }

  dlight_t *dl = Level.AllocDlight(none, org, rad+150.0);
  if (dl) {
    //dl->origin = org;
    //dl->radius = rad + 150.0;
    dl->color = clr;
    dl->die = Level.XLevel.Time+0.5;
    dl->decay = 300.0;
  }
}


//==========================================================================
//
//  ClientSparkParticles
//
//==========================================================================
void ClientSparkParticles (int Count, TVec Org, float Angle) {
  TVec porg;
  foreach (auto i; 0..Count) {
    float an = Angle+Random()*45.0;
    float s, c;
    sincos(an, out s, out c);
    porg.x = Org.x+(Random()*15.0)*c;
    porg.y = Org.y+(Random()*15.0)*s;
    porg.z = Org.z-Random()*4.0;

    particle_t *p = Level.NewParticle(porg);
    if (!p) break;

    p->type = LineSpecialLevelInfo::pt_spark;
    p->Size = 0.5;
    p->color = Random() < 0.5 ? RGBA(255, 120, 0, 255) : RGBA(255, 170, 0, 255);
    p->die = Level.XLevel.Time+10.0/35.0;

    p->vel.x = (Random()-0.5)*2.0;
    p->vel.y = (Random()-0.5)*2.0;
    p->vel.z = (Random()-0.5)*2.0-Random ()*70.0;

    p->accel.x = (Random()-0.5)*16.0+(Random ()-0.5)*35.0;
    p->accel.y = (Random()-0.5)*16.0+(Random ()-0.5)*35.0;
    p->accel.z = (Random()-0.5)*16.0-140.0;
  }
}


//==========================================================================
//
//  AddBlend
//
//==========================================================================
final void AddBlend (ref float r, ref float g, ref float b, ref float a, int Col) {
  if (!(Col&0xff000000)) return; // no alpha
  float r1 = float((Col>>16)&0xff)/255.0;
  float g1 = float((Col>>8)&0xff)/255.0;
  float b1 = float(Col&0xff)/255.0;
  float a1 = float((Col>>24)&0xff)/255.0;
  float TmpA = fclamp(1.0-(1.0-a)*(1.0-a1), 0.0, 1.0);
  if (!TmpA) return;
  r = (r*a*(1.0-a1)+r1*a1)/TmpA;
  g = (g*a*(1.0-a1)+g1*a1)/TmpA;
  b = (b*a*(1.0-a1)+b1*a1)/TmpA;
  a = TmpA;
}


//==========================================================================
//
//  AddBlendWithAlpha
//
//  overrides blend color alpha
//
//==========================================================================
final void AddBlendWithAlpha (ref float r, ref float g, ref float b, ref float a, int Col, float alpha) {
  if (alpha <= 0) return; // no alpha
  float r1 = float((Col>>16)&0xff)/255.0;
  float g1 = float((Col>>8)&0xff)/255.0;
  float b1 = float(Col&0xff)/255.0;
  float TmpA = fclamp(1.0-(1.0-a)*(1.0-alpha), 0.0, 1.0);
  if (!TmpA) return;
  r = (r*a*(1.0-alpha)+r1*alpha)/TmpA;
  g = (g*a*(1.0-alpha)+g1*alpha)/TmpA;
  b = (b*a*(1.0-alpha)+b1*alpha)/TmpA;
  a = TmpA;
}


//==========================================================================
//
//  PaletteFlash
//
//  Sets the new palette color shift based upon the current values of
//  Player.DamageFlash and Player.BonusFlash, contents and other inventory
//  items.
//
//==========================================================================
void PaletteFlash () {
  float r = 0.0;
  float g = 0.0;
  float b = 0.0;
  float a = 0.0;

  if (MO.WaterLevel == 3) {
    switch (MO.WaterType) {
      case CONTENTS_WATER: AddBlend(r, g, b, a, RGBA(130, 80, 50, 128)); break;
      case CONTENTS_LAVA: AddBlend(r, g, b, a, RGBA(255, 80, 0, 150)); break;
      case CONTENTS_NUKAGE: AddBlend(r, g, b, a, RGBA(50, 255, 50, 150)); break;
      case CONTENTS_SLIME: AddBlend(r, g, b, a, RGBA(0, 25, 5, 150)); break;
      case CONTENTS_HELLSLIME: AddBlend(r, g, b, a, RGBA(255, 80, 0, 150)); break;
      case CONTENTS_BLOOD: AddBlend(r, g, b, a, RGBA(160, 16, 16, 150)); break;
      case CONTENTS_SLUDGE: AddBlend(r, g, b, a, RGBA(128, 160, 128, 150)); break;
      case CONTENTS_HAZARD: AddBlend(r, g, b, a, RGBA(128, 160, 128, 128)); break;
    }
  }

  DamageFlashBlend = 0;
  if (nameicmp(EntityEx(MO).DamageType, 'Ice') == 0) {
    // Frozen player
    AddBlend(r, g, b, a, RGBA(2, 2, 255, 113));
  } else {
    if (DamageFlash < 0) DamageFlash = 0;
    if (DamageFlash) {
      auto pawn = PlayerPawn(MO);
      int dmgColor = pawn.DamageScreenColor;
      float dmgIntensity = 1.0;

      name dmgType = DamageFlashType;
      if (dmgType && !nameEquCI(dmgType, 'None')) {
        foreach (auto ref dmg; pawn.DamageColors) {
          if (nameEquCI(dmgType, dmg.Type)) {
            //printdebug("%C: found damage record! Type=%s", self, dmg.Type);
            dmgColor = dmg.Color;
            dmgIntensity = fclamp(dmg.Intensity, 0.0, 1.0)*2.0;
            break;
          }
          //printdebug("%C: skipped damage record with type=%s, int=%s, clr=0x%08x (%s)", self, dmg.Type, dmg.Intensity, dmg.Color, dmgType);
        }
      }
      /*
      else {
        printdebug("%C: damage without a type", self);
      }
      */

      float maxent = fmin(GetCvarF('k8DamageFlashMaxIntensity'), 1.0)*255.0;
      if (maxent <= 0.0) maxent = 255.0; // cheaters must be punished! ;-)
      int Amount = int(fclamp(114.0*DamageFlash*dmgIntensity, 0, maxent));
      //printdebug("%C: maxent=%s; DamageFlash=%s; dmgIntensity=%s; amount=%s (%s)", self, maxent, DamageFlash, dmgIntensity, int(114.0*DamageFlash*dmgIntensity), Amount);
      //if (Amount >= 228) Amount = 228;
      if (Amount > 0) AddBlend(r, g, b, a, (Amount<<24)|(dmgColor&0x00ffffff));
      DamageFlashBlend = Amount;
    }

    if (BonusFlash) {
      float maxBonusFlashTime = GetCvarF('k8BonusFlashMaxTime');
      if (maxBonusFlashTime > 0) BonusFlash = fmin(BonusFlash, maxBonusFlashTime);
      if (BonusFlash > 0) {
        int Amount = int(256.0*BonusFlash);
        if (Amount >= 128) Amount = 128;
        AddBlend(r, g, b, a, RGBA(215, 186, 68, Amount));
      } else {
        BonusFlash = 0;
      }
    }

    if (PoisonCount) {
      int Amount = PoisonCount*160/32;
      if (Amount >= 160) Amount = 160;
      AddBlend(r, g, b, a, RGBA(56, 118, 46, Amount));
    }

    //FIXME add hazard flash.
    if (HazardTime > 16.0 || (int(4.0*HazardTime)&1)) {
      AddBlend(r, g, b, a, RGBA(0, 255, 0, 32));
    }
  }

  // item effects
  for (Inventory Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory) {
    int Blend = Item.GetBlend();
    if (Blend) AddBlend(r, g, b, a, Blend);
  }

  // Health Accumulation Device effect
  if (MO && MO.XLevel) {
    float lvtime = MO.XLevel.Time;
    //print("lvtime=%f; k8HealthAccum_LastBoostTime=%f; k8HealthAccum_LastRegenTime=%f", lvtime, k8HealthAccum_LastBoostTime, k8HealthAccum_LastRegenTime);
    bool doRegen = true;
    if (k8HealthAccum_LastBoostTime > 0) {
      float diff = lvtime-k8HealthAccum_LastBoostTime;
      if (diff > 0 && diff < 1) {
        AddBlendWithAlpha(r, g, b, a, RGBA(255, 127, 0, 0), 0.5-diff/2.0);
        doRegen = false;
      }
    }
    if (doRegen && k8HealthAccum_LastRegenTime > 0) {
      float diff = lvtime-k8HealthAccum_LastRegenTime;
      if (diff > 0 && diff < 0.1) {
        AddBlendWithAlpha(r, g, b, a, RGBA(0, 128, 0, 0), 0.1-diff*1);
      }
    }
  }

  if (BlendA) {
    AddBlend(r, g, b, a, RGBA(int(BlendR*255.0), int(BlendG*255.0), int(BlendB*255.0), int(BlendA*255.0)));
  }

  r = fclamp(r, 0.0, 1.0);
  g = fclamp(g, 0.0, 1.0);
  b = fclamp(b, 0.0, 1.0);
  CShift = RGBA(int(r*255.0), int(g*255.0), int(b*255.0), int(a*255.0));
}


//==========================================================================
//
//  PreTravel
//
//==========================================================================
override void PreTravel () {
  ::PreTravel();
  ClearSubSeenInfo();
  if (MO) {
    // remove all powerups that cannot survive map teleports
    /* nope, this is done in `PlayerExitMap()`
    auto inv = EntityEx(MO).Inventory;
    while (inv) {
      Powerup pw = Powerup(inv);
      inv = inv.Inventory;
      if (pw && !pw.bSurvivesMapTeleport) {
        printdebug("*** removed powerup '%C'", pw);
        pw.EndEffect();
        delete pw;
      }
    }
    */
    //WARNING! don't set `Owner` to none here, because `SV_MapTeleport()` checks it!
    SavedInventory = EntityEx(MO).Inventory;
    EntityEx(MO).Inventory = none;
    /*
    printdebug("%C: PreTravel inventory:", self);
    for (auto inv = SavedInventory; inv; inv = inv.Inventory) {
      printdebug("  %C: owner=%C(%s); MO=%C(%s)", inv, inv.Owner, (inv.Owner ? inv.Owner.UniqueId : 0), MO, MO.UniqueId);
      //inv.Owner = none; // crash if somebody will try to remove something
    }
    */
  } else {
    //printdebug("%C: PreTravel inventory: CLEARED!", self);
    SavedInventory = none; // just in case
  }
  ResetACSButtons();
}


//==========================================================================
//
//  UseInventory
//
//==========================================================================
override void UseInventory (string Inv) {
  if (!Inv) return;

  if (bTotallyFrozen || (Level.bFrozen && !(Cheats&CF_TIMEFREEZE))) {
    // you can't use items if you're totally frozen
    return;
  }

  class!Inventory invCls = class!Inventory(FindClassNoCaseStr(Inv));
  if (!invCls) return;

  Inventory item = EntityEx(MO).FindInventory(invCls, disableReplacement:true);
  if (!item) item = EntityEx(MO).FindInventory(class!Inventory(GetClassReplacement(invCls)), disableReplacement:true);

  if (item) {
    // use Inventory item
    EntityEx(MO).UseInventory(item);
  }
}


//==========================================================================
//
//  CheckDoubleFiringSpeed
//
//==========================================================================
override bool CheckDoubleFiringSpeed () {
  return !!(Cheats&CF_DOUBLEFIRINGSPEED);
}


//==========================================================================
//
//  ClientSpeech
//
//==========================================================================
void ClientSpeech (EntityEx Speaker, int SpeechNum) {
  LineSpecialClientGame(ClGame).StartSpeech(Speaker, SpeechNum);
}


//==========================================================================
//
//  ClientSlideshow1
//
//==========================================================================
void ClientSlideshow1 () {
  LineSpecialClientGame(ClGame).StartConSlideshow1();
}


//==========================================================================
//
//  ClientSlideshow2
//
//==========================================================================
void ClientSlideshow2 () {
  LineSpecialClientGame(ClGame).StartConSlideshow2();
}


//==========================================================================
//
//  ClientFinaleType
//
//==========================================================================
void ClientFinaleType (int Type) {
  LineSpecialClientGame(ClGame).SetFinaleType(Type);
}


//==========================================================================
//
//  SetObjectives
//
//==========================================================================
void SetObjectives (int NewObjectives) {
  if (!NewObjectives) return;
  // check if log text lump exists in wad file
  if (!WadLumpPresent(name(va("log%d", NewObjectives)))) return;
  Objectives = NewObjectives;
}


//==========================================================================
//
//  StrReplaceSubstitutes
//
//  replaces '%g', '%h', '%p', '%o', '%k'
//
//==========================================================================
string StrReplaceSubstitutes (string str, EntityEx source) {
  auto ppos = str.strIndexOf("%");
  if (ppos < 0) return str;
  // we have something to process...
  //FIXME: replace with correct gender when we'll implement player genders
  bool isFemale = (MO ? (string(MO.SoundGender).strIndexOf("female", caseSensitive:false) >= 0) : false);
  //print("<>::: isFemale=%B (%s : %d)", isFemale, (MO ? MO.SoundGender : '???'), (string(MO.SoundGender).strIndexOf("female", caseSensitive:false)));
  string res;
  while (ppos >= 0 && ppos+1 < str.length) {
    res ~= str[0..ppos];
    auto nch = str[ppos+1];
    bool validMod = true;
    switch (nch) {
      // double percent, insert one
      case '%': res ~= "%"; break;
      case 'o': case 'O': res ~= PlayerName; break;
      case 'g': res ~= (isFemale ? "she" : "he"); break;
      case 'h': res ~= (isFemale ? "her" : "him"); break;
      case 'p': res ~= (isFemale ? "hers" : "his"); break;
      case 'G': res ~= (isFemale ? "She" : "He"); break;
      case 'H': res ~= (isFemale ? "Her" : "Him"); break;
      case 'P': res ~= (isFemale ? "Hers" : "His"); break;
      case 'k': case 'K':
        if (source && source.bIsPlayer && source.Player) {
          res ~= source.Player.PlayerName;
        } else if (Actor(source) && Actor(source).StrifeName) {
          res ~= Actor(source).StrifeName;
        } else if (source) {
          res ~= string(GetClassName(source.Class));
        } else {
          res ~= "unknown";
        }
        break;
      default:
        validMod = false;
    }
    if (validMod) {
      str = str[ppos+2..$];
    } else {
      res ~= "%";
      str = str[ppos+1..$];
    }
    ppos = str.strIndexOf("%");
  }
  if (str) res ~= str;
  return res;
}


//==========================================================================
//
//  DisplayObituary
//
//==========================================================================
void DisplayObituary (EntityEx inflictor, EntityEx source, name DmgType) {
  string Msg;

       if (nameicmp(DmgType, 'Suicide') == 0) Msg = "$ob_suicide"; // commited a suicide
  else if (nameicmp(DmgType, 'Falling') == 0) Msg = "$ob_falling"; // fell down
  else if (nameicmp(DmgType, 'Crush') == 0) Msg = "$ob_crush"; // crushed by the environment
  else if (nameicmp(DmgType, 'Exit') == 0) Msg = "$ob_exit"; // tried to exit when it's not allowed
  else if (nameicmp(DmgType, 'Drowning') == 0) Msg = "$ob_water"; // drowned int the water
  else if (nameicmp(DmgType, 'Slime') == 0) Msg = "$ob_slime"; // was standing in the slime
  else if (nameicmp(DmgType, 'Fire') == 0 && !source) Msg = "$ob_lava"; // was standing in the lava
  else if (source) {
    if (source.Player == self) {
      // suicide
      Msg = "$ob_killedself";
    } else if (!source.bIsPlayer) {
      // killed by monster
           if (nameicmp(DmgType, 'Telefrag') == 0) Msg = "$ob_montelefrag"; // monster telefrag
      else if (nameicmp(DmgType, 'Melee') == 0 && source.HitObituary) Msg = source.HitObituary;
      else Msg = source.Obituary;
    }
  }

  if (!Msg && source && source.bIsPlayer) {
    if (Level.Game.netgame && !Level.Game.deathmatch) {
      // killed another player in cooperative net game
      Msg = va("$ob_friendly%d", (P_Random()&3)+1); // it goes from 1 to 4, not from 0 to 3
    } else if (nameicmp(DmgType, 'Telefrag') == 0) {
      // telefrag
      Msg = "$ob_mptelefrag";
    } else if (inflictor && inflictor.Obituary) {
      // missile with it's own obituary
      Msg = inflictor.Obituary;
    } else {
      PlayerEx pex = (inflictor && inflictor.Player ? PlayerEx(inflictor.Player) : none);
      Weapon Wpn = (pex ? pex.ReadyWeapon : none);
           if (Wpn && Wpn.Obituary) Msg = Wpn.Obituary; // weapon obituary message
      else if (nameicmp(DmgType, 'BFGSplash') == 0) Msg = "$ob_mpbfg_splash"; // BFG splash damage
      else if (nameicmp(DmgType, 'Railgun') == 0) Msg = "$ob_railgun"; // railgun
      else Msg = "$ob_mpdefault"; // default multiplayer kill message
    }
  } else {
    source = EntityEx(MO);
  }

  if (!Msg) Msg = "$ob_default"; // generic death

  // look up string in language lump if necesary
  Msg = TranslateString(Msg);

  // do replacements
  Msg = StrReplaceSubstitutes(Msg, source);

  Level.bprint("%s", Msg);
}


//==========================================================================
//
//  ClientRailTrail
//
//==========================================================================
void ClientRailTrail (TVec From, TVec To, optional int Col1, optional int Col2, float MaxDiff) {
  if (!specified_Col1) Col1 = RGBA(255, 255, 255, 255);
  if (!specified_Col2) Col2 = RGBA(0, 0, 255, 255);

  if (!Col1 && !Col2) return;

  float Len = Length(To-From);
  TVec Dir = Normalise(To-From);
  TAVec Ang;
  VectorAngles(Dir, out Ang);
  Ang.roll = 270.0;

  TVec Diff;
  for (float Offs = 0.0; Offs < Len; Offs += 3.0) {
    if (MaxDiff > 0.0) {
      int Rnd = P_Random();
      if (Rnd&1) {
        Diff.x += (Rnd&8 ? 1.0 : -1.0);
        Diff.x = fclamp(Diff.x, -MaxDiff, MaxDiff);
      }
      if (Rnd&2) {
        Diff.y += (Rnd&16 ? 1.0 : -1.0);
        Diff.y = fclamp(Diff.y, -MaxDiff, MaxDiff);
      }
      if (Rnd&4) {
        Diff.z += (Rnd&32 ? 1.0 : -1.0);
        Diff.z = fclamp(Diff.z , -MaxDiff, MaxDiff);
      }
    }

    if (Col1) {
      TVec porg = From+Dir*Offs+Diff;
      particle_t *p = Level.NewParticle(porg);
      if (!p) break; // cannot spawn any more particles, no sense in further tries
      p->type = LineSpecialLevelInfo::pt_rail;
      p->Size = 0.5;
      p->color = Col1;
      p->die = Level.XLevel.Time+1.0;
      p->vel.x = (Random()-0.5)*2.0;
      p->vel.y = (Random()-0.5)*2.0;
      p->vel.z = (Random()-0.5)*2.0;
      p->accel = vector(0.0, 0.0, 0.0);
    }

    Ang.roll += 14.0;

    if (Col2) {
      TVec Forward;
      TVec Right;
      TVec Up;
      AngleVectors(Ang, out Forward, out Right, out Up);

      TVec porg = From+Dir*Offs+Up*3.0;
      particle_t *p = Level.NewParticle(porg);
      if (!p) break; // cannot spawn any more particles, no sense in further tries
      p->type = LineSpecialLevelInfo::pt_rail;
      p->Size = 0.5;
      p->color = Col2;
      p->die = Level.XLevel.Time+1.0;
      p->vel = Up;
      p->accel = vector(0.0, 0.0, 0.0);
    }
  }
}


//==========================================================================
//
//  ClientVoice
//
//==========================================================================
void ClientVoice (int VoiceNum) {
  LocalSound(name(va("svox/voc%d", VoiceNum)));
}


//==========================================================================
//
//  GiveAmmo
//
//  Returns false if the ammo can't be picked up at all
//
//==========================================================================
bool GiveAmmo (class!Ammo ammo, int count) {
  int oldammo;

  if (!ammo) return false;

  Ammo AmmoItem = Ammo(EntityEx(MO).FindInventory(ammo));
  //if (!AmmoItem) AmmoItem = Ammo(EntityEx(MO).FindInventory(class!Ammo(GetClassReplacement(ammo))));

  if (!AmmoItem) {
    class!Ammo repl = class!Ammo(GetClassReplacement(ammo));
    if (!repl) repl = ammo;
    AmmoItem = Level.SpawnEntityChecked(class!Ammo, repl, default, default, default, AllowReplace:false);
    if (!AmmoItem) return false;
    AmmoItem.AttachToOwner(EntityEx(MO));
    AmmoItem.Amount = 0;
  }

  if (!count) return false;

  int maxam = AmmoItem./*MaxAmount*/k8GetAmmoKingMax();
  if (AmmoItem.Amount == maxam) return false;

  // extra ammo in baby mode and nightmare mode
  count = max(0, int(float(count)*Level.World.GetAmmoFactor()));

  oldammo = AmmoItem.Amount;
  //AmmoItem.Amount += count;
  //if (AmmoItem.Amount > AmmoItem.MaxAmount) AmmoItem.Amount = AmmoItem.MaxAmount;
  AmmoItem.Amount = min(AmmoItem.Amount+count, maxam);

  if (oldammo <= 0) GotAmmo(AmmoItem);

  return true;
}


//==========================================================================
//
//  PutClientIntoServer
//
//==========================================================================
override void PutClientIntoServer () {
  ClearSubSeenInfo();
  if (bIsBot) CreateBot();
}


//==========================================================================
//
//  PerformRebornSpawn
//
//  returns non-null if no players was spawned
//
//==========================================================================
mthing_t *PerformRebornSpawn () {
  bool spawned = false;
  mthing_t *best = nullptr;
  float bestDist = float.max;
  mthing_t *bestOther = nullptr;
  float bestOtherDist = float.max;
  foreach (auto i; 0..Level.PlayerStarts.length) {
    auto sp = &Level.PlayerStarts[i];
    if (sp.type == GetPlayerNum()+1) {
      if (sp.args[0] == Level.Game.RebornPosition) {
        // i found her!
        SpawnPlayer(sp, spawned);
        spawned = true;
        continue;
      }
      if (spawned) continue;
      if (CheckSpot(sp, onlyCheck:true)) {
        float spdist = (MO ? (MO.Origin-vector(sp.x, sp.y)).length2DSquared() : bestDist);
        if (!best || spdist < bestDist) {
          best = sp;
          bestDist = spdist;
        }
      }
    } else if (!spawned) {
      // not ours, but still remember it
      if (!best && CheckSpot(sp, onlyCheck:true)) {
        float spdist = (MO ? (MO.Origin-vector(sp.x, sp.y)).length2DSquared() : bestOtherDist);
        if (!bestOther || spdist < bestOtherDist) {
          bestOther = sp;
          bestOtherDist = spdist;
        }
      }
    }
  }

  if (spawned) return nullptr;

  if (!best && !bestOther) Error("Player %d has no start spots", GetPlayerNum()+1);

  if (!best) {
    print("Player %d has no start spot for position %d, using other spot position", GetPlayerNum()+1, Level.Game.RebornPosition);
    return bestOther;
  } else {
    print("Player %d has no start spot for position %d", GetPlayerNum()+1, Level.Game.RebornPosition);
  }

  return best;
}


//==========================================================================
//
//  InitWeaponSlots
//
//  used by dumb client to setup weapon slots
//
//==========================================================================
override void InitWeaponSlots () {
  if (PlayerPawn(MO)) PlayerPawn(MO).InitializeWeaponSlots(/*LineSpecialGameInfo(Level.Game)*/);
}


//==========================================================================
//
//  SpawnClient
//
//==========================================================================
override void SpawnClient () {
  bool playerWasReborn;
  EntityEx OldMO = EntityEx(MO);
  ClearSubSeenInfo();

  //printdebug("*** SPAWN CLIENT");

  Attacker = none;
  Poisoner = none;

  AddVisitedMap(Level.XLevel.MapName);

  if (Level.Game.netgame && !Level.Game.deathmatch) {
    // cooperative net-play, retain keys and weapons
    playerWasReborn = (PlayerState == PST_REBORN || PlayerState == PST_CHEAT_REBORN);
  } else {
    playerWasReborn = (PlayerState == PST_CHEAT_REBORN);
  }

  // spawn player
  if (Level.Game.deathmatch) {
    DeathMatchSpawnPlayer();
  } else if (Level.Game.netgame || Level.bClusterHub) {
    SpawnPlayer(Level.GetPlayerStart(GetPlayerNum(), Level.Game.RebornPosition), false);
  } else if (PlayerState == PST_CHEAT_REBORN) {
    SpawnPlayer(nullptr, false);
  } else {
    mthing_t *best = PerformRebornSpawn();
    // if returned non-nullptr, it means that no good spawn position was found
    // spawn player anyway, we don't want to totally ruin the game for them
    if (best) SpawnPlayer(best, false);
  }

  /* ResetPlayerOnSpawn() should take care of this
  if (!playerWasReborn && LocalQuakeHappening) {
    print("*** RESETTING QUAKING!");
    LocalQuakeHappening = 0;
  }
  */

  // setup weapon slots
  //printdebug("*** SPAWN CLIENT: MO=%C (%C)", MO, PlayerPawn(MO));
  if (PlayerPawn(MO)) PlayerPawn(MO).InitializeWeaponSlots(/*LineSpecialGameInfo(Level.Game)*/);

  // coop
  if (Level.Game.netgame && !Level.Game.deathmatch) {
    if (playerWasReborn) OnNetReborn(OldMO); else OnNetSpawn(OldMO);
  }

  // destroy all things touching players
  Actor(MO).TeleportMove(MO.Origin);

  k8BossesDetected = (GetCvarB('k8ElvenDetect') ? -0.5 : 666);

  HealthBarInit();
}


//==========================================================================
//
//  NetGameReborn
//
//  Respawn at the start
//
//==========================================================================
override void NetGameReborn () {
  EntityEx OldMO = EntityEx(MO);
  ClearSubSeenInfo();

  // remove pitch and roll angles from corpse
  MO.Angles.pitch = 0.0;
  MO.Angles.roll = 0.0;

  // first dissasociate the corpse
  MO.Player = none;
  MO.bIsPlayer = false;

  LastRegenTicTime = 0;

  // spawn at random spot if in death match
  if (Level.Game.deathmatch) {
    k8HealthAccum_Amount = 0;
    OldMO.DestroyAllInventory();
    DeathMatchSpawnPlayer();
    return;
  }

  if (PlayerState == PST_CHEAT_REBORN) {
    PreTravel(); // this stores all required inventory in `SavedInventory`
    auto oldAccum = k8HealthAccum_Amount;
    SpawnPlayer(nullptr, false);
    k8HealthAccum_Amount = oldAccum;
  } else {
    k8HealthAccum_Amount = 0;
    bool foundSpot = false;
    auto sp = Level.GetPlayerStart(GetPlayerNum(), Level.Game.RebornPosition, failIfNotFound:false);
    if (sp && CheckSpot(sp)) {
      // appropriate player start spot is open
      SpawnPlayer(sp, false);
      foundSpot = true;
    } else {
      // try to spawn at one of the other player start spots
      // this should not fail hard if player start spot is not found, because
      // there can be more players allowed that we have spawn spots
      foreach (auto i; 0..MAXPLAYERS) {
        sp = Level.GetPlayerStart(i, Level.Game.RebornPosition, failIfNotFound:false);
        if (sp && CheckSpot(sp)) {
          print("*** FOUND OTHER PLAYER (%s) STARTING SPOT FOR PLAYER %s", i+1, GetPlayerNum()+1);
          // found an open start spot
          SpawnPlayer(sp, false);
          foundSpot = true;
          break;
        }
      }
    }

    if (!foundSpot) {
      // player's going to be inside something. too bad.
      print("*** NOT FOUND OTHER PLAYER STARTING SPOTS FOR PLAYER %s", GetPlayerNum()+1);
      sp = Level.GetPlayerStart(GetPlayerNum(), Level.Game.RebornPosition);
      CheckSpot(sp); // spawn teleport fog
      SpawnPlayer(sp, false);
    }
  }

  if (PlayerPawn(MO)) PlayerPawn(MO).InitializeWeaponSlots(/*LineSpecialGameInfo(Level.Game)*/);

  OnNetReborn(OldMO);
}


//==========================================================================
//
//  DisconnectClient
//
//==========================================================================
override void DisconnectClient () {
  ClearSubSeenInfo();
  DestroyBot();
  if (MO) {
    MO.Player = none;
    MO.bIsPlayer = false;
    Actor(MO).Damage(none, none, 10000, forced:true, spawnBlood:true);
  }
  Level.bprint("%s left the game", PlayerName);
  MO.PlaySound('misc/chat', CHAN_AUTO, 1.0, ATTN_NONE);
  HealthBarDeinit();
}


//==========================================================================
//
//  DeathMatchSpawnPlayer
//
//  Spawns a player at one of the random death match spots called at level
//  load and each death
//
//==========================================================================
void DeathMatchSpawnPlayer () {
  if (!Level.DeathmatchStarts.length) Error("oops! no deathmatch starts where they should be!");

  // shuffle them
  array!int dms;
  dms.length = Level.DeathmatchStarts.length;
  foreach (int didx; 0..dms.length) dms[didx] = didx;

  // the famous Fisher-Yates shuffle
  foreach (int didx; 0..dms.length-1) {
    int swapidx = didx+roundi(FRandomFull()*(dms.length-didx-1));
    if (swapidx != didx) {
      int tmp = dms[swapidx];
      dms[swapidx] = dms[didx];
      dms[didx] = tmp;
    }
  }

  foreach (int i; dms) {
    auto sp = &Level.DeathmatchStarts[i];
    if (CheckSpot(sp)) {
      SpawnPlayer(sp, false);
      return;
    }
  }

  // no good spot, so the player will probably get stuck
  {
    auto sp = Level.GetPlayerStart(GetPlayerNum(), 0);
    CheckSpot(sp); // spawn teleport fog
    SpawnPlayer(sp, false);
  }
}


//==========================================================================
//
//  eventAfterUnarchiveThinkers
//
//==========================================================================
override void eventAfterUnarchiveThinkers () {
  //printwarn("player `%C`: after unarchive...", self);
  // setup weapon slots
  if (PlayerPawn(MO)) PlayerPawn(MO).InitializeWeaponSlots(/*LineSpecialGameInfo(Level.Game)*/);
}


//==========================================================================
//
//  CheckSpot
//
//  Returns false if the player cannot be respawned at the given mthing_t
//  spot because something is occupying it
//
//==========================================================================
bool CheckSpot (mthing_t *mthing, optional bool onlyCheck) {
  float x;
  float y;
  sector_t *sec;
  float an;

  if (!MO) {
    // first spawn of level, before corpses
    foreach (auto i; 0..MAXPLAYERS) {
      if (Level.Game.Players[i] && Level.Game.Players[i].MO &&
          Level.Game.Players[i].MO.Origin.x == mthing->x &&
          Level.Game.Players[i].MO.Origin.y == mthing->y)
      {
        return false;
      }
    }
    return true;
  }

  x = mthing->x;
  y = mthing->y;

  {
    auto oldPassMObj = MO.bPassMobj;
    scope(exit) MO.bPassMobj = oldPassMObj;
    MO.bPassMobj = false;
    if (!MO.CheckPosition(vector(x, y, Actor::ONFLOORZ))) return false;
  }

  if (!onlyCheck) {
    if (!PlayerChunk(MO)) {
      LineSpecialLevelInfo(Level).AddPlayerCorpse(EntityEx(MO));
    }

    // spawn a teleport fog
    sec = Level.XLevel.PointInSector(vector(x, y, 0.0));
    an = float(45*(mthing->angle/45));

    Level.Spawn(TeleportFog, vector(x+20.0*cos(an), y+20.0*sin(an),
      sec->floor.TexZ+LineSpecialGameInfo(Level.Game).TeleFogHeight));
  }

  return true;
}


//==========================================================================
//
//  SetupPlayerClass
//
//==========================================================================
void SetupPlayerClass () {
  if (LineSpecialGameInfo(Level.Game).bRandomClass &&
      Level.Game.deathmatch && Level.Game.PlayerClasses.length > 1)
  {
    PClass = P_Random()%Level.Game.PlayerClasses.length;
    if (PClass == BaseClass) PClass = (PClass+1)%Level.Game.PlayerClasses.length;
    BaseClass = PClass;
    SB_Start();
  } else {
    PClass = BaseClass;
  }
}


//==========================================================================
//
//  ResetACSButtons
//
//  reset ACS button update timers and values
//
//==========================================================================
void ResetACSButtons () {
  AcsCurrButtonsPressed = 0;
  AcsCurrButtons = 0;
  AcsButtons = 0;
  OldButtons = 0;
  AcsNextButtonUpdate = 0;
  AcsPrevMouseX = 0;
  AcsPrevMouseY = 0;
  AcsMouseX = 0;
  AcsMouseY = 0;
}


//==========================================================================
//
//  ResetRenderStyles
//
//==========================================================================
void ResetRenderStyles () {
  FixedColormap = 0;
  ExtraLight = 0;
  CShift = 0;
}


//==========================================================================
//
//  ResetPlayerOnSpawn
//
//==========================================================================
void ResetPlayerOnSpawn (optional bool keepPlayerState) {
  if (!keepPlayerState) PlayerState = PST_LIVE;
  ClearSubSeenInfo();
  Refire = 0;
  DamageFlash = 0.0;
  DamageFlashType = '';
  BonusFlash = 0.0;
  PoisonCount = 0;
  MorphTime = 0.0;
  ExtraLight = 0;
  FixedColormap = 0;
  LastSectorDamageTic = 0;
  LastHazardTime = 0.0;
  Rain1 = none;
  Rain2 = none;

  JumpTime = 0;
  LocalQuakeHappening = vector(0, 0, 0);
  //MoveDir = vector(0, 0, 0);
  HazardTime = 0;
  //Weapon ReadyWeapon;
  //Weapon PendingWeapon;  // Is none if not changing.
  //FlyHeight = 0;
  /*
  bFrozen = false; // just in case
  bTotallyFrozen = false; // just in case
  */
  bFly = false; // just in case
  PoisonCount = 0; // screen flash for poison damage
  LastPoisonTime = 0;
  Poisoner = none; // none for non-player mobjs
  PoisonerPlayer = none; // for KArena

  MorphTime = 0;  // player is morphed into something if > 0
  MorphStyle = 0;
  BlendR = 0;
  BlendG = 0;
  BlendB = 0;
  BlendA = 0;
  ChickenPeck = 0; // chicken peck countdown

  //k8: just in case
  ResetWeaponReloadRefire();
  ResetWeaponActionFlags();
  bDisableWeaponSwitch = false;
  bForceCrouchingDown = 0;

  if (GetCvarB('k8HealthAccum_Reset')) k8HealthAccum_Amount = 0;
  k8HealthAccum_LastRegenTime = -10000;
  k8HealthAccum_LastBoostTime = -10000;

  if (GetCvarB('r_allow_ambient')) bFlashlightOn = false;
  bFlashlightButtonDown = false;

  k8NextSuperBulletTime = 0;
  LastRegenTicTime = 0;

  ResetAttackers();

  ResetACSButtons();

  k8BossesDetected = 666;
  k8ElvenGiftMessageTime = 666;

  Cheats &= ~(CF_NOCLIP|CF_TIMEFREEZE);

  // reset zoom
  FOV = DesiredFOV;
  ClientFOV(0);

  ResetRenderStyles();
}


//==========================================================================
//
//  GiveDefaultDeathMatchInventory
//
//  FIXME: replacements?
//
//==========================================================================
void GiveDefaultDeathMatchInventory () {
  class!Inventory Cls;
  // give all keys in death match mode
  foreach AllClasses(Key, Cls) {
    if (!FindClassState(Cls, 'Spawn')) continue; // abstract class
    if (!AreStateSpritesPresent(FindClassState(Cls, 'Spawn'))) continue; // from a different game
    EntityEx(MO).GiveInventoryType(Cls);
  }
}


//==========================================================================
//
//  ResetInventory
//
//==========================================================================
override void ResetInventory () {
  EntityEx PP = EntityEx(MO);
  if (!PP) return;
  while (PP.Inventory) PP.Inventory.Destroy();

  ResetRenderStyles();

  SetWeapon(none);
  BringUpWeapon(instant:true, skipSound:true);

  AddDefaultInventory();

  k8ElvenGifted = false;
  GiveElvenGifts(nullptr);
}


//==========================================================================
//
//  RemoveKeysVerbose
//
//==========================================================================
override void RemoveKeysVerbose (optional bool verbose) {
  EntityEx PP = EntityEx(MO);
  if (!PP) return;
  if (!specified_verbose) verbose = true;

  //bool again = true;
  int count = 0;
  class!Inventory Cls;
  foreach AllClasses(Key, Cls) {
    class!Key repl = class!Key(GetClassReplacement(Cls));
    if (repl && repl != Cls) continue;
    if (!EntityEx.IsSpawnableClass(Cls)) continue;
    auto inv = PP.FindInventory(Cls, disableReplacement:true);
    if (inv) {
      //again = true;
      if (verbose) print("removed key '%C'", inv);
      PP.RemoveInventory(inv);
      delete inv;
      ++count;
    }
  }
  if (verbose && count > 0) cprint("Removed %s key%s!", count, (count != 1 ? "s" : ""));
}


//==========================================================================
//
//  ResetHealth
//
//==========================================================================
override void ResetHealth () {
  EntityEx PP = EntityEx(MO);
  if (!PP) return;
  Health = GetRebornHealth();
  PP.Health = Health;
}


//==========================================================================
//
//  PreraiseWeapon
//
//==========================================================================
override void PreraiseWeapon () {
  EntityEx PP = EntityEx(MO);
  if (!PP) return;
  if (!ReadyWeapon) return;
  print("PRERAISE!");
  BringUpWeapon(instant:true, skipSound:true);
}


//==========================================================================
//
//  SpawnPlayer
//
//  Called when a player is spawned on the level. Most of the player
//  structure stays unchanged between levels.
//
//==========================================================================
void SpawnPlayer (mthing_t *mthing, bool Voodoo) {
  PlayerPawn PP;
  bool ResetInventory = false;
  bool reborned = false;
  Inventory Item;

  TVec spawnOrigin = (mthing ? vector(mthing->x, mthing->y, Actor::ONFLOORZ) : MO.Origin);
  float spawnYaw = (mthing ? float(45*(mthing->angle/45)) : MO.Angles.yaw);

  //print("*** SPAWN PLAYER");

  bool cheatReborn = false;

  //printdebug("************SpawnPlayer:%C: 000; Voodoo=%B; PST=%s (SVI=%C)", self, Voodoo, PlayerState, SavedInventory);
  if (PlayerState == PST_REBORN) {
    //printdebug("  normal reborn (SVI=%C)", SavedInventory);
    PlayerReborn();
    ResetInventory = true;
    reborned = true;
  } else if (PlayerState == PST_CHEAT_REBORN) {
    //print("*** CHEAT REBORN ***");
    PlayerReborn();
    ResetInventory = false;
    reborned = true;
    cheatReborn = true;
  } else {
    if (Level.bResetInventory && !GetCvarB('sv_ignore_reset_inventory')) ResetInventory = true;
  }

  if (!cheatReborn && GetCvarB('sv_force_pistol_start')) ResetInventory = true;

  SetupPlayerClass();

  float x = spawnOrigin.x;
  float y = spawnOrigin.y;
  float z = spawnOrigin.z;
  if (PClass >= Level.Game.PlayerClasses.length) Error("Player::SpawnPlayer: Unknown class type (class=%s; max=%s)", PClass, Level.Game.PlayerClasses.length-1);

  PP = Level.SpawnEntityChecked(class!PlayerPawn, class!PlayerPawn(Level.Game.PlayerClasses[PClass]), vector(x, y, z), default, default, AllowReplace:false);
  if (!PP) Error("Player::SpawnPlayer: cannot spawn `%C` (it is prolly not a player pawn)", Level.Game.PlayerClasses[PClass]);
  printdebug("spawned player with class <%C>", PP);
  PP.InitializeWeaponSlots();
  //print("falling damage: normal=%B; old=%B; strife=%B", Level.bFallingDamage, Level.bOldFallingDamage, Level.bStrifeFallingDamage);
  if (GetCvarS('player_default_gender')) PP.SoundGender = name(GetCvarS('player_default_gender'));
  if (mthing) PP.Origin.z += mthing->height;
  PP.LinkToWorld(properFloorCheck:true);
  PP.FriendPlayer = GetPlayerNum()+1; // players are their own friends
  ClearSubSeenInfo();

  // set color translations for player sprites
  TranslStart = PP.TranslStart;
  TranslEnd = PP.TranslEnd;
  PP.Translation = (Entity::TRANSL_Player<<Entity::TRANSL_TYPE_SHIFT)+GetPlayerNum();

  // if a voodoo doll has been spawned, take it's inventory
  if (Voodoo) {
    //printdebug("  moving inventory to the Voodoo Doll from MO (SVI=%C)", SavedInventory);
    PP.ObtainInventory(EntityEx(MO));
  }

  DesiredFOV = 90.0; //float(GetCvar('FOV'));
  FOV = DesiredFOV;
  PP.Angles.yaw = spawnYaw;
  PP.Player = self;
  PP.bIsPlayer = true;
  PP.Health = Health;
  MO = PP;
  Camera = PP;
  ViewHeight = PP.GetPawnViewHeight;
  ViewOrg = MO.Origin;
  ViewOrg.z += ViewHeight;
  SaveViewOrgFixInfo();
  ViewAngles = PP.Angles;
  bFixAngle = true;
  ResetRenderStyles();

  ResetPlayerOnSpawn();

  if (!Voodoo) {
    PP.Inventory = SavedInventory;
    for (Item = PP.Inventory; Item; Item = Item.Inventory) Item.Owner = MO;
    //printdebug("%C: PostTravel inventory (%C:%s):", self, PP, PP.UniqueId);
    //for (auto inv = PP.Inventory; inv; inv = inv.Inventory) printdebug("  %C: owner=%C(%s); MO=%C(%s)", inv, inv.Owner, (inv.Owner ? inv.Owner.UniqueId : 0), MO, MO.UniqueId);
    if (ResetInventory) {
      //printdebug("%C: ResetInventory!", self);
      //while (PP.Inventory) PP.Inventory.Destroy();
      //FIXME!!!
      // for some reason, bot inventory sometimes refusing to go; wtf?!
      auto pinv = PP.Inventory;
      while (pinv) {
        auto pnext = pinv.Inventory;
        //printdebug("%C: going to destroy inventory item '%C' (owner=%C %B) (inv=%C; next=%C)", PP, pinv, pinv.Owner, (pinv.Owner == PP), PP.Inventory, pnext);
        delete pinv;
        if (PP.Inventory != pnext) printdebug("%C: inventory item '%C' refused to go (owner=%C %B)", PP, PP.Inventory, PP.Inventory.Owner, (PP.Inventory.Owner == PP));
        pinv = pnext;
      }
      PP.Inventory = none;
      AddDefaultInventory();
    } else if (Level.bResetItems && !GetCvarB('sv_ignore_reset_items')) {
      //printdebug("*** %C: cleaning up inventory...", self);
      Inventory inv = PP.Inventory;
      while (inv) {
        Inventory c = inv;
        inv = inv.Inventory;
        //if (c.bInvBar && !c.bUndroppable) c.Destroy();
        //printdebug("*** %C:   %C(power=%s): bInvBar=%B; bPersistentPower=%B; bUndroppable=%B", self, c, (Powerup(c) ? "tan" : "ona"), c.bPersistentPower, c.bUndroppable);
        if (!c.bInvBar) continue;
        if (Powerup(c)) {
          if (c.bPersistentPower) continue;
        } else {
          if (c.bUndroppable) continue;
        }
        c.Destroy();
      }
    }
  }

  // set up gun psprite
  SetupPsprites();

  if (Level.Game.deathmatch && !IsCheckpointSpawn) GiveDefaultDeathMatchInventory();

  // wake up the status bar
  SB_Start();

  if (bIsBot) BotOnSpawn();

  SetClientModel();

  UpdateRevealedMap();

  if (ResetInventory) {
    if (reborned) Level.XLevel.StartTypedACScripts(VLevel::SCRIPT_Respawn, 0, 0, 0, MO, true, false);
    k8ElvenGifted = false;
  }

  //print("*** CHECKPOINT SPAWN: %B", IsCheckpointSpawn);
  if (!IsCheckpointSpawn) {
    GiveElvenGifts(mthing, Voodoo);
  }

  if (!reborned && !IsCheckpointSpawn) {
    if ((Level.bResetHealth && !GetCvarB('sv_ignore_reset_health')) || GetCvarB('sv_force_health_reset')) {
      Health = GetRebornHealth();
      EntityEx(MO).Health = Health;
    }
  }

  k8BossesDetected = (GetCvarB('k8ElvenDetect') ? -0.5 : 666);
}


//===========================================================================
//
//  PerformBossDetection
//
//  this is virtual, so mods can override it
//
//===========================================================================
void PerformBossDetection () {
  if (!MO) return;
  // detect bosses
  Actor act;
  int cybbieCount = 0, mindCount = 0;
  foreach MO.AllThinkers(Actor, out act) {
    if (!act.bMonster || act.bCorpse || act.Health <= 0) continue;
    class!Actor ec = class!Actor(act.Class);
    while (ec) {
      switch (GetClassName(ec)) {
        case 'Cyberdemon': ++cybbieCount; break;
        case 'SpiderMastermind': ++mindCount; break;
      }
      ec = class!Actor(GetClassParent(ec));
    }
    //if (hasCybbie && hasMind) break; // just in case
  }
  string msg;
  if (cybbieCount && mindCount) {
    if (cybbieCount > 1 && mindCount > 1) msg = va("%d Cyberdemons and %d Masterminds detected!", cybbieCount, mindCount);
    else if (cybbieCount > 1) msg = va("%d Cyberdemons and Mastermind detected!", cybbieCount);
    else if (mindCount > 1) msg = va("Cyberdemon and %d Masterminds detected!", mindCount);
    else msg = "Cyberdemon and Mastermind detected!";
  }
  else if (cybbieCount > 1) msg = va("%d Cyberdemons detected!", cybbieCount);
  else if (cybbieCount) msg = "Cyberdemon detected!";
  else if (mindCount > 1) msg = va("%d Masterminds detected!", mindCount);
  else if (mindCount) msg = "Mastermind detected!";
  if (msg) {
    print("\c[Red]*** %s ***", msg);
    ClientHudMessage(msg, 'smallfont', HUDMsgType.FadeInOut|HUDMsgFlag.ColorString/*|HUDMsgFlag.Log*/, 123669, CR_UNDEFINED, "Green",
      0.5, 0.56, 0, 0,
      2.5, 0.5, 1.0,
      1.0);
  }
}


//===========================================================================
//
//  ShowElvenGiftMessage
//
//  this is virtual, so mods can override it
//
//===========================================================================
void ShowElvenGiftMessage () {
  if (!MO) return;
  ClientHudMessage("ELVEN GIFT", 'smallfont', HUDMsgType.FadeInOut, 123666, CR_ORANGE, "",
    0.5, 0.45, 0, 0,
    2.0, 0.4, 0.8,
    1.0);
}


//===========================================================================
//
//  GiveElvenGifts
//
//  this is virtual, so mods can override it
//
//===========================================================================
void GiveElvenGifts (optional mthing_t *mthing, optional bool Voodoo, optional bool forced) {
  // do not do this on a titlemap
  if (nameicmp(Level.XLevel.MapName, 'titlemap') == 0) return;

  //print("************SpawnPlayer: gifted=%s", (k8ElvenGifted ? "tan" : "ona"));
  k8ElvenGiftMessageTime = 666;
  if (forced || GetCvarB('k8ElvenGift')) {
    if (forced) k8ElvenGifted = false;
    if (!Voodoo && !k8ElvenGifted) {
      k8ElvenGifted = true; // gifts should be given only once
      bool showMessage = false;
      if (AddElvenGift('Shotgun')) { showMessage = true; AddElvenGift('ShellBox'); }
      if (AddElvenGift('BDW_Rifle')) { showMessage = true; foreach (; 0..9) AddElvenGift('Clip'); if (ShouldRemovePistol()) RemovePistol(); }
      print("\c[Green]%s", "Elven Gifts!");
      if (showMessage) k8ElvenGiftMessageTime = -0.3;
    }
    // oops; change weapon, as voodoo doll was spawned
    if (Voodoo && k8ElvenGifted) {
      if (FindClass('BDW_Rifle') && ReadyWeapon && ReadyWeapon.bWimpyWeapon && (!PendingWeapon || PendingWeapon.bWimpyWeapon)) {
        auto rfc = FindClass('BDW_Rifle');
        for (Inventory Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory) {
          if (Item.Class == rfc) {
            if (ReadyWeapon != Weapon(Item)) {
              //PendingWeapon = Weapon(Item);
              SetWeapon(Weapon(Item));
              BringUpWeapon();
            }
            break;
          }
        }
      }
    }
  }
}


//===========================================================================
//
//  AddElvenGift
//
//===========================================================================
bool AddElvenGift (name Klass) {
  class!Actor th = class!Actor(FindClass(Klass));
  if (th) {
    Actor act = Actor(Level.Spawn(th));
    if (!act) return false;
    Weapon wpn = Weapon(act);
    int fixAmmoGive = -1;
    if (Klass == 'BDW_Rifle') {
      wpn.AmmoGive2 = 31;
      if (ReadyWeapon != wpn) {
        //PendingWeapon = wpn;
        SetWeapon(wpn);
        BringUpWeapon();
      }
    } else if (Klass == 'BDW_Shotgun' || (Klass == 'Shotgun' && FindClass('BDW_Shotgun'))) {
      wpn.AmmoGive2 = 8;
    } else if (Klass == 'FragfireGun' || (Klass == 'Shotgun' && FindClass('FragfireGun'))) {
      //TODO: check ammo type? let's hope nobody else has FragfireGun like that
      if (wpn.AmmoGive1 == 0 && wpn.AmmoGive2 == 40) {
        fixAmmoGive = 80;
      }
    }
    int oldAmmoGive = (wpn ? wpn.AmmoGive1 : 0);
    if (wpn && fixAmmoGive >= 0) wpn.AmmoGive1 = fixAmmoGive;
    act.TouchSpecial(EntityEx(MO), true);
    if (wpn) wpn.AmmoGive1 = oldAmmoGive;
    if (wpn && Klass == 'BDW_Rifle' && ReadyWeapon && ReadyWeapon.bWimpyWeapon && (!PendingWeapon || PendingWeapon.bWimpyWeapon)) {
      if (ReadyWeapon != wpn) {
        //PendingWeapon = wpn;
        SetWeapon(wpn);
        BringUpWeapon();
      }
    }
    return true;
  } else {
    return false;
  }
}


//===========================================================================
//
//  ShouldRemovePistol
//
//  this is virtual, so mods can override it
//
//===========================================================================
bool ShouldRemovePistol () {
  Inventory inv = EntityEx(MO).Inventory;
  while (inv) {
    Weapon Wpn = Weapon(inv);
    inv = inv.Inventory;
    if (Wpn) {
      class!Weapon wc = class!Weapon(Wpn.Class);
      while (wc) {
        if (GetClassName(wc) == 'BDW_Rifle') return true;
        wc = class!Weapon(GetClassParent(wc));
      }
    }
  }
  return false;
}


//===========================================================================
//
//  RemovePistol
//
//  this is virtual, so mods can override it
//
//===========================================================================
void RemovePistol () {
  Inventory inv = EntityEx(MO).Inventory;
  while (inv) {
    Weapon Wpn = Weapon(inv);
    inv = inv.Inventory;
    if (Wpn) {
      //print("WPN: %C", Wpn);
      switch (GetClassName(Wpn.Class)) {
        case 'Pistol':
        case 'PerkPistol':
          EntityEx(MO).RemoveInventory(Wpn);
          delete Wpn;
          break;
      }
    }
  }
}


//===========================================================================
//
//  AddDefaultInventory
//
//===========================================================================
void AddDefaultInventory () {
  HexenArmor HArmor = Level.SpawnEntityChecked(class!HexenArmor, HexenArmor, default, default, default, AllowReplace:false);
  if (HArmor) {
    HArmor.AttachToOwner(EntityEx(MO));
    HArmor.Slots[4] = PlayerPawn(MO).HexenArmor[0];
    HArmor.SlotsIncrement[0] = PlayerPawn(MO).HexenArmor[1];
    HArmor.SlotsIncrement[1] = PlayerPawn(MO).HexenArmor[2];
    HArmor.SlotsIncrement[2] = PlayerPawn(MO).HexenArmor[3];
    HArmor.SlotsIncrement[3] = PlayerPawn(MO).HexenArmor[4];
  }

  BasicArmor BArmor = Level.SpawnEntityChecked(class!BasicArmor, BasicArmor, default, default, default, AllowReplace:false);
  if (BArmor) {
    BArmor.Amount = 0;
    BArmor.AttachToOwner(EntityEx(MO));
  }

  //print("AddDefaultInventory: MO=`%C`", MO);
  foreach (auto i; 0..EntityEx(MO).DropItemList.length) {
    class!EntityEx tp = class!EntityEx(EntityEx(MO).DropItemList[i].Type);
    class!EntityEx tprepl = none;
    if (tp) tprepl = class!Inventory(GetClassReplacement(tp));
    //printdebug("  i=%d; type=`%C`(%C); name=`%s`; amount=%s; chance=%s", i, tp, tprepl, EntityEx(MO).DropItemList[i].TypeName, EntityEx(MO).DropItemList[i].Amount, EntityEx(MO).DropItemList[i].Chance);
    if (!tprepl) continue;
    //printdebug("  i=%d; type=`%C`(%C); name=`%s`; amount=%s; chance=%s", i, tp, tprepl, EntityEx(MO).DropItemList[i].TypeName, EntityEx(MO).DropItemList[i].Amount, EntityEx(MO).DropItemList[i].Chance);
    Inventory Item = Inventory(Level.Spawn(tprepl, default, default, default, AllowReplace:false));
    if (Item) {
      Item.bIgnoreSkill = true;
      int amount = EntityEx(MO).DropItemList[i].Amount;
      if (amount > 0) Item.Amount = amount; else if (amount == -666) Item.Amount = 0;
      if (Weapon(Item)) {
        // for better control empty weapon's ammo
        Weapon(Item).AmmoGive1 = 0;
        Weapon(Item).AmmoGive2 = 0;
      }
      if (!Item.TryPickup(EntityEx(MO))) {
        Item.Destroy();
      } else if (Weapon(Item) && Weapon(Item).CheckAmmo(Weapon::FIRE_Either, AutoSwitch:false)) {
        SetWeapon(Weapon(Item));
        Weapon(Item).bBobDisabled = true;
      }
    }
  }
}


//==========================================================================
//
//  PlayerReborn
//
//  Called after a player dies almost everything is cleared and initialised
//
//==========================================================================
void PlayerReborn () {
  // clear player struct
  DoClearPlayer();

  PClass = BaseClass;

  // set initial data
  ResetPlayerOnSpawn(keepPlayerState:true);
  bUseDown = true; // don't do anything immediately
  bAttackDown = true;
  bAltAttackDown = false;
  bReloadQueued = false;
  bReloadDown = false;
  bZoomDown = false;
  bButton5Down = false;
  bButton6Down = false;
  bButton7Down = false;
  bButton8Down = false;
  ResetWeaponReloadRefire();
  ResetWeaponActionFlags();
  PlayerState = PST_LIVE;
  Health = GetRebornHealth();
}


//==========================================================================
//
//  DoClearPlayer
//
//==========================================================================
void DoClearPlayer () {
  ClearPlayer();
}


//==========================================================================
//
//  PlayerBeforeExitMap
//
//  Called when a player completes a level, but before going to imis.
//  Not called for intermissions.
//
//==========================================================================
override void PlayerBeforeExitMap () {
  ClearSubSeenInfo();
  if (GetCvarB('k8HealthAccum_NewMapHeal')) {
    int healthmax = GetMaxHealth();
    int oldhealth = Health;
    if (healthmax > 0 && oldhealth < healthmax && k8HealthAccum_Amount > 0) {
      Health = min(oldhealth+k8HealthAccum_Amount, healthmax);
      if (Health > oldhealth) {
        if (MO) MO.Health = Health;
        k8HealthAccum_Amount -= Health-oldhealth; // just in case
      }
    }
  }
}


//==========================================================================
//
//  PlayerExitMap
//
//  Called when a player completes a level.
//
//==========================================================================
override void PlayerExitMap (bool clusterChange) {
  ClearSubSeenInfo();

  //printdebug("%C: *** exiting map *** (clusterChange=%B)", self, clusterChange);

  // moved between hubs, clamp inventory amount
  if (clusterChange && !Level.bClusterHub && !Level.bKeepFullInventory) {
    for (Inventory Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory) {
      if (Item.bInvBar && Item.Amount > Item.InterHubAmount) {
        //printdebug("%C: clamping inventory item `%C` from %s to %s", self, Item, Item.Amount, Item.InterHubAmount);
        Item.Amount = Item.InterHubAmount;
      }
    }
  }

  // strip all non-persistent powers
  for (Inventory Item = EntityEx(MO).Inventory; Item; ) {
    Inventory Next = Item.Inventory;
    if (Powerup(Item)) {
      if (Level.Game.deathmatch || (!Item.bPersistentPower && (clusterChange || !Item.bHubPower))) {
        //printdebug("%C: removing powerup `%C`", self, Item);
        Item.Destroy();
      }
    }
    Item = Next;
  }

  if (clusterChange) {
    // entering new cluster
    // some items are stripped
    for (Inventory Item = EntityEx(MO).Inventory; Item; ) {
      Inventory Next = Item.Inventory;
      if (Item.bInterHubStrip /*&& Item.InterHubAmount < 1*/) {
        //printdebug("%C: removing item `%C` due to `bInterHubStrip`", self, Item);
        Item.Destroy();
      }
      Item = Next;
    }
  }

  if (MorphTime) {
    Weapon wpn = Weapon(Actor(MO).Tracer);
    if (wpn) wpn.bBobDisabled = true;
    SetWeapon(wpn); // restore weapon
    MorphTime = 0.0;
  }

  MO.Angles.pitch = 0.0;
  MO.RenderStyle = Entity::STYLE_Normal;
  MO.Alpha = 1.0;
  EntityEx(MO).bShadow = false; // cancel invisibility
  ExtraLight = 0; // cancel gun flashes
  FixedColormap = 0; // cancel ir gogles
  DamageFlash = 0.0; // no palette changes
  DamageFlashType = '';
  BonusFlash = 0.0;
  PoisonCount = 0;
  BlendR = 0.0;
  BlendG = 0.0;
  BlendB = 0.0;
  BlendA = 0.0;
  Rain1 = none;
  Rain2 = none;
  //k8: just in case
  ResetWeaponReloadRefire();
  ResetWeaponActionFlags();
  //bDisableWeaponSwitch = false;
  bForceCrouchingDown = 0;
  LocalQuakeHappening = vector(0, 0, 0);
}


//==========================================================================
//
//  InventoryLeft
//
//==========================================================================
void InventoryLeft () {
  if (!bInventoryAlwaysOpen) {
    if (!InventoryTime) {
      InventoryTime = 5.0;
      return;
    }
    InventoryTime = 5.0;
  }

  if (InvPtr) {
    Inventory Prev = InvPtr.PrevInv();
    if (Prev) {
      InvPtr = Prev;
      AdjustInvFirst();
    }
  }
}


//==========================================================================
//
//  InventoryRight
//
//==========================================================================
void InventoryRight () {
  if (!bInventoryAlwaysOpen) {
    if (!InventoryTime) {
      InventoryTime = 5.0;
      return;
    }
    InventoryTime = 5.0;
  }

  if (InvPtr) {
    Inventory Next = InvPtr.NextInv();
    if (Next) {
      InvPtr = Next;
      AdjustInvFirst();
    }
  }
}


//==========================================================================
//
//  InventoryUse
//
//==========================================================================
void InventoryUse () {
  // flag to denote that it's okay to use an artifact
       if (InventoryTime) InventoryTime = 0.0;
  else if (InvPtr) EntityEx(MO).UseInventory(InvPtr);
}


//==========================================================================
//
//  InventoryTick
//
//==========================================================================
void InventoryTick (float deltaTime) {
  // turn inventory off after a certain amount of time
  if (InventoryTime) {
    InventoryTime -= deltaTime;
    if (InventoryTime <= 0.0) InventoryTime = 0.0;
  }
  if (ArtifactFlash) --ArtifactFlash;
}


//==========================================================================
//
//  AdjustInvFirst
//
//==========================================================================
void AdjustInvFirst () {
  Inventory Item;

  if (!InvPtr) {
    InvFirst = none;
    return;
  }

  // count how many items are following the current one, also make sure
  // that first is not after this one
  int NumFollowing = 0;
  for (Item = InvPtr.NextInv(); Item; Item = Item.NextInv()) {
    ++NumFollowing;
    if (InvFirst == Item) InvFirst = InvPtr;
  }

  int FirstOffs = 0;
  for (Item = InvPtr; Item && Item != InvFirst; Item = Item.PrevInv()) ++FirstOffs;

  while (FirstOffs > InvSize) {
    InvFirst = InvFirst.NextInv();
    --FirstOffs;
  }

  while (NumFollowing+FirstOffs < InvSize && InvFirst.PrevInv()) {
    InvFirst = InvFirst.PrevInv();
    ++FirstOffs;
  }
}


//==========================================================================
//
//  InventoryThrow
//
//==========================================================================
EntityEx InventoryThrow () {
  if (!InvPtr) return none;
  return EntityEx(MO).DropInventory(InvPtr);
}


//==========================================================================
//
//  UseFlyPower
//
//==========================================================================
void UseFlyPower () {
  PlayerUseArtifactType(ArtiFly);
}


//==========================================================================
//
//  PlayerUseArtifactType
//
//==========================================================================
void PlayerUseArtifactType (class!Inventory arti) {
  Inventory Item = EntityEx(MO).FindInventory(arti);
  if (Item) EntityEx(MO).UseInventory(Item);
}


//==========================================================================
//
//  PlayerNextArtifact
//
//==========================================================================
void PlayerNextArtifact () {
  if (!InvPtr) return;
  Inventory NewPtr = InvPtr.PrevInv();
  if (!NewPtr) {
    NewPtr = InvPtr;
    while (NewPtr.NextInv()) NewPtr = NewPtr.NextInv();
  }
  InvPtr = NewPtr;
  AdjustInvFirst();
}


//==========================================================================
//
//  DeathPlayerTick
//
//  Fall on your face when dying. Decrease POV height to floor height.
//
//==========================================================================
void DeathPlayerTick (float deltaTime) {
  scope(exit) LastWaterLevel = (MO ? MO.WaterLevel : 0);

  // just in case
  k8HealthAccum_LastRegenTime = 0;
  k8HealthAccum_LastBoostTime = 0;
  ResetWeaponReloadRefire();
  ResetWeaponActionFlags();
  bDisableWeaponSwitch = false;
  bForceCrouchingDown = 0;

  ClearSubSeenInfo();
  MovePsprites(deltaTime);

  if (MO.WaterLevel > 1) MO.Velocity.z = -60.0; // drift towards bottom

  onground = (MO.Origin.z <= MO.FloorZ);

  if (PlayerChunk(MO)) {
    // flying bloody skull or flying ice chunk
    ViewHeight = 6.0;
    DeltaViewHeight = 0.0;
    //damagecount = 20;
    if (onground) {
#ifdef FIXME
      if (lookdir < 60) {
        int lookDelta = (60-lookdir)/8;
             if (lookDelta < 1 && (level->tictime&1)) lookDelta = 1;
        else if (lookDelta > 6) lookDelta = 6;
        lookdir += lookDelta;
      }
#endif
    }
  } else if (nameicmp(Actor(MO).DamageType, 'Ice') != 0) {
    // fall to ground (if not frozen)
    DeltaViewHeight = 0.0;
    if (ViewHeight > 6.0) ViewHeight -= 35.0*deltaTime;
    if (ViewHeight < 6.0) ViewHeight = 6.0;
#ifdef FIXME
         if (lookdir > 0) lookdir -= 6;
    else if (lookdir < 0) lookdir += 6;
    if (abs(lookdir) < 6) lookdir = 0;
#endif
  }
  CalcHeight(deltaTime);

  if (Attacker && Attacker != MO) {
    // watch killer
    float delta;
    int dir = EntityEx(MO).FaceActor(EntityEx(Attacker), delta);
    if (delta < 10.0) {
      // looking at killer, so fade damage and poison counters
      if (DamageFlash) {
        DamageFlash -= deltaTime;
        if (DamageFlash <= 0.0) DamageFlash = 0.0;
      }
      if (PoisonCount) --PoisonCount;
    }
    delta = fmin(5.0, delta/8.0);
    if (dir) {
      // turn clockwise
      MO.Angles.yaw += delta;
    } else {
      // turn counter clockwise
      MO.Angles.yaw -= delta;
    }
  } else if (DamageFlash) {
    DamageFlash -= deltaTime;
    if (DamageFlash <= 0.0) DamageFlash = 0.0;
  } else if (PoisonCount) {
    --PoisonCount;
  }

  if (CheckForRespawn(deltaTime)) {
    InvPtr = none;
    InvFirst = none;
    PlayerState = PST_REBORN;
  }
}


//==========================================================================
//
//  CheckForRespawn
//
//==========================================================================
bool CheckForRespawn (float deltaTime) {
  return !!(Buttons&BT_USE);
}


//==========================================================================
//
//  checkDoHealthAccumBoost
//
//  this should be called after health < maxhealth checked
//  k8HealthAccum_Amount should be checked and set too
//
//==========================================================================
bool checkDoHealthAccumBoost () {
  if (k8HealthAccum_Amount < 1 || Health < 1) return false;
  // can boost?
  int boostPoints = GetCvarI('k8HealthAccum_BoostPoints');
  if (!boostPoints) return false;
  // hit boost limit?
  int boostLow = GetCvarI('k8HealthAccum_BoostLow');
  if (Health >= boostLow) return false;
  // boost cooldowned?
  float boostCooldownTime = fmax(0, GetCvarF('k8HealthAccum_BoostCooldown'));
  if (k8HealthAccum_LastBoostTime+boostCooldownTime > MO.XLevel.Time) return false;
  // calculate boost amount
  int newh = (boostPoints < 0 ? -boostPoints : Health+boostPoints);
  if (newh <= Health) return false;
  int relh = min(k8HealthAccum_Amount, newh-Health);
  if (relh < 1) return false; // just in case
  // perform health boost
  if (GetCvarB('k8HealthAccum_MessagesBoost')) {
    if (boostPoints < 0) cprint("Health boosted to %d", Health+relh); else cprint("Health boosted by %d", relh);
  }
  k8HealthAccum_LastBoostTime = MO.XLevel.Time;
  k8HealthAccum_Amount -= relh;
  Health += relh;
  MO.Health = Health; //k8: we need this for UI
  return true;
}


//==========================================================================
//
//  checkDoHealthAccumRegen
//
//  this should be called after health < maxhealth checked
//  k8HealthAccum_Amount should be checked and set too
//
//==========================================================================
bool checkDoHealthAccumRegen () {
  if (k8HealthAccum_Amount < 1 || Health < 1) return false;
  // can regen?
  int regenPoints = GetCvarI('k8HealthAccum_RegenPoints');
  if (regenPoints < 1) return false;
  // hit regen limit?
  int healthmax = GetMaxHealth();
  if (Health >= healthmax) return false;
  int regenLow = GetCvarI('k8HealthAccum_RegenLow');
  if (regenLow > 0 && Health >= regenLow) return false; // player is not hurt enough
  // regen cooldowned?
  float regenRateTime = fmax(0, GetCvarF('k8HealthAccum_RegenRate'));
  /*
  print("k8HealthAccum_Amount=%s; Health=%s; rp=%s; max=%s; rate=%s; last=%s; time=%s",
    k8HealthAccum_Amount, Health, regenPoints, healthmax, regenRateTime, k8HealthAccum_LastRegenTime, MO.XLevel.Time);
  */
  if (k8HealthAccum_LastRegenTime+regenRateTime > MO.XLevel.Time) return false;
  // check for boost cooldown too
  float boostCooldownTime = fmax(0, GetCvarF('k8HealthAccum_BoostCooldown'));
  if (k8HealthAccum_LastBoostTime+boostCooldownTime > MO.XLevel.Time) return false;
  // calculate regen amount
  int newh = Health+regenPoints;
  int relh = min(k8HealthAccum_Amount, newh-Health);
  if (relh < 1) return false; // just in case
  // perform health regen
  if (GetCvarB('k8HealthAccum_MessagesRegen')) cprint("Health regenerated by %d", relh);
  k8HealthAccum_LastRegenTime = MO.XLevel.Time;
  k8HealthAccum_Amount -= relh;
  Health += relh;
  MO.Health = Health; //k8: we need this for UI
  return true;
}


//==========================================================================
//
//  doHealthAccumHealthPickup
//
//  returns `true` if Health Accumulator (or player) consumed the item
//  must increase player's health if necessary
//  should never be called with `none`
//
//==========================================================================
bool doHealthAccumHealthPickup (Health item, EntityEx toucher) {
  if (!item) return false; // meh, just in case
  int amount = item.Amount;
  int itemhealthlimit = item.MaxAmount;
  // is this small health bonus (like bottle)?
  if (itemhealthlimit) {
    // you should be able to pick up health bonuses even at full health
    // note that health bonuses cannot be accumulated
    // also, don't do anything if current health is higher than the limit
    //printdebug("%C: Health=%s; itemhealthlimit=%s; always=%B", item, Health, itemhealthlimit, item.bAlwaysPickup);
    if (Health >= itemhealthlimit) return item.bAlwaysPickup; // eat if it should be always eaten
    // increase health
    Health = min(Health+amount, itemhealthlimit);
    if (toucher) toucher.Health = Health;
    return true; // eaten
  }
  // normal health pickup
  int plrmaxhealth = GetMaxHealth();
  //print("Health=%s; healthmax=%s; amount=%s; accum=%s; acclimit=%s; accumon=%s", Health, plrmaxhealth, amount, k8HealthAccum_Amount, GetCvarI('k8HealthAccum_Max'), GetCvarB('k8HealthAccum_Enabled'));
  // too healthy?
  if (Health >= plrmaxhealth) {
    // accumulate everything
    if (!GetCvarB('k8HealthAccum_Enabled')) return false; // Health Accumulator is not active
    int accMax = max(0, GetCvarI('k8HealthAccum_Max'));
    if (!accMax) return false; // cannot pickup
    if (k8HealthAccum_Amount >= accMax) return false; // cannot pickup
    // do full accumulation
    // (don't bother checking, player tick will check and clamp HA amount for us)
    k8HealthAccum_Amount += amount;
    if (GetCvarB('k8HealthAccum_MessagesAccumed')) cprint("Accumulated %d health.", amount);
  } else {
    // we should heal the player, and accumulate the rest (if anything)
    int newh = min(plrmaxhealth, Health+amount);
    int relh = newh-Health;
    // accumulate leftovers
    if (relh < amount && GetCvarB('k8HealthAccum_Enabled')) {
      int accMax = max(0, GetCvarI('k8HealthAccum_Max'));
      if (accMax) {
        // (don't bother checking, player tick will check and clamp HA amount for us)
        k8HealthAccum_Amount += amount-relh;
        if (GetCvarB('k8HealthAccum_MessagesAccumed')) cprint("Accumulated %d health.", amount-relh);
      }
    }
    // heal player
    Health = newh;
    if (toucher) toucher.Health = Health;
  }
  // processed
  return true;
}


//==========================================================================
//
//  SimulatedPlayerTick
//
//==========================================================================
void SimulatedPlayerTick (float deltaTime) {
  assert(bAutonomousProxy); // just in case
  assert(!bIsBot); // the thing that should not be

  if (PlayerState == PST_DEAD) return;

  // copy view angles
  if (MO == Camera) MO.Angles = ViewAngles;

  // you can only press use while totally frozen
  if (bTotallyFrozen || (Level.bFrozen && !(Cheats&CF_TIMEFREEZE))) return;

  // move around
  // ReactionTime is used to prevent movement for a bit after a teleport (or water jump)
  if (Actor(MO).ReactionTime) {
    Actor(MO).ReactionTime -= deltaTime;
    if (Actor(MO).ReactionTime <= 0.0) Actor(MO).ReactionTime = 0.0;
    if (Actor(MO).bWaterJump) WaterJump();
  } else {
    if (MO.WaterLevel > 1) {
      WaterMove(deltaTime);
    } else {
      LastWaterLevel = 0; // yes, zero
      MovePlayer(deltaTime);
      // allow to jump out of the water if we aren't submerged too deep
      if (MO.WaterLevel) CheckWaterJump(asStep:true);
    }
  }

  //printdebug("%C:000: vh=%s; movh=%s", self, ViewHeight, PlayerPawn(MO).ViewHeight);
  CalcHeight(deltaTime);
  //printdebug("%C:001: vh=%s; movh=%s", self, ViewHeight, PlayerPawn(MO).ViewHeight);

  if (MO.Sector) {
    PlayerProcessScrollSectors(deltaTime);
    //if (MO.Sector->special || MO.Sector->Damage) PlayerInSpecialSector(deltaTime);
  }

  /*
  if (MO.Velocity.z <= -35.0*35.0 && MO.Velocity.z >= -40.0*35.0 &&
      !MorphTime && MO.WaterLevel == 0 &&
      !GetSoundPlayingInfo(MO, GetSoundID('*falling')))
  {
    MO.PlaySound('*falling', CHAN_VOICE);
  }
  */
}


//==========================================================================
//
//  PlayerTick
//
//==========================================================================
override void PlayerTick (float deltaTime) {
  if (!MO) return;

  if (bIsClient) { SimulatedPlayerTick(deltaTime); return; }

  LastDeltaTime = deltaTime;

  // update current world tick for server
  // advance it, because it will be like that when sent
  GameTime = MO.XLevel.Time+deltaTime;

  bool isBot = bIsBot;

  if (isBot) {
    if (!Level.bFrozen && !(Cheats&CF_TIMEFREEZE)) BotTick(deltaTime);
  }

  //printdebug("PlayerTick(%C): Health=%s; MO.Health=%s", self, Health, MO.Health);

  if (!isBot && Level.Game.netgame && !Level.Game.deathmatch) {
    if (lastSubSector != MO.SubSector) AddSeenSubsector();
  }

  // health regeneration powerup
  if (MO.XLevel.TicTime%(3*35) == 0 && Health > 0 && LastRegenTicTime != MO.XLevel.TicTime) {
    LastRegenTicTime = MO.XLevel.TicTime;
    PowerRegeneration rgp = EntityEx(MO).FindRegenerationPowerup();
    if (rgp) {
      rgp.Regenerate(EntityEx(MO));
    } else if (Cheats&CF_REGENERATION) {
      if (EntityEx(MO).GiveBody(5) && !GetSoundPlayingInfo(MO, GetSoundID('*regenerate'))) {
        MO.PlaySound('*regenerate', /*CHAN_VOICE*/CHAN_BODY);
      }
    }
  }

  if (Actor(MO).bJustAttacked) {
    ForwardMove = 100.0;
    SideMove = 0.0;
    Actor(MO).bJustAttacked = false;
  }

  // you can only press use while totally frozen
  if (bTotallyFrozen || (Level.bFrozen && !(Cheats&CF_TIMEFREEZE))) {
    Buttons &= BT_USE;
    Impulse = 0;
    ViewAngles = MO.Angles;
    ForwardMove = 0.0;
    SideMove = 0.0;
    FlyMove = 0.0;
    ResetWeaponReloadRefire(); // no reload too
    ResetWeaponActionFlags();
  } else if (bFrozen) {
    ForwardMove = 0.0;
    SideMove = 0.0;
    FlyMove = 0.0;
  }

  WorldTimer += deltaTime;
  InventoryTick(deltaTime);

  if (PlayerState == PST_DEAD) {
    DeathPlayerTick(deltaTime);
    return;
  }

  // Health Accumulator
  if (GetCvarB('k8HealthAccum_Enabled')) {
    // do not reset accumulator when player is dead
    if (PlayerState == PST_LIVE) {
      int accMax = GetCvarI('k8HealthAccum_Max');
      //int accAmount = 0;
      if (accMax > 0) {
        //k8HealthAccum_LastRegenTime = 0;
        //k8HealthAccum_LastBoostTime = 0;
        k8HealthAccum_Amount = max(0, min(k8HealthAccum_Amount, accMax)); // sanitize
        //print("k8HealthAccum_Amount=%s; bt=%s; rt=%s; lt=%s; tb=%s; tr=%s", k8HealthAccum_Amount, MO.XLevel.Time-k8HealthAccum_LastBoostTime, MO.XLevel.Time-k8HealthAccum_LastRegenTime, MO.XLevel.Time, k8HealthAccum_LastBoostTime, k8HealthAccum_LastRegenTime);
        if (!checkDoHealthAccumBoost()) checkDoHealthAccumRegen();
      } else {
        k8HealthAccum_Amount = 0;
      }
    }
  } else {
    k8HealthAccum_Amount = 0;
  }

  if (k8ElvenGiftMessageTime <= 0) {
    k8ElvenGiftMessageTime += deltaTime;
    if (k8ElvenGiftMessageTime >= 0) {
      k8ElvenGiftMessageTime = 666;
      ShowElvenGiftMessage();
    }
  }

  if (k8BossesDetected <= 0) {
    k8BossesDetected += deltaTime;
    if (k8BossesDetected >= 0) {
      k8BossesDetected = 666;
      PerformBossDetection();
    }
  }

  // process buttons (reset "down" flags)
  if (Buttons&BT_RELOAD) {
    // set "reload queued" only if the button was released and pressed again
    if (!bReloadDown) bReloadQueued = true;
    bReloadDown = true;
  } else {
    bReloadDown = false;
  }

  if (!(Buttons&BT_ATTACK)) bAttackDown = false;
  if (!(Buttons&BT_ALT_ATTACK)) bAltAttackDown = false;
  if (!(Buttons&BT_ZOOM)) bZoomDown = false;
  if (!(Buttons&BT_BUTTON_5)) bButton5Down = false;
  if (!(Buttons&BT_BUTTON_6)) bButton6Down = false;
  if (!(Buttons&BT_BUTTON_7)) bButton7Down = false;
  if (!(Buttons&BT_BUTTON_8)) bButton8Down = false;

  // copy view angles
  if (MO == Camera) MO.Angles = ViewAngles;

  if (JumpTime) JumpTime = fmax(0.0, JumpTime-deltaTime);

  if (MorphTime) PlayerPawn(MO).MorphPlayerThink();

  // move around
  // ReactionTime is used to prevent movement for a bit after a teleport (or water jump)
  if (Actor(MO).ReactionTime) {
    Actor(MO).ReactionTime -= deltaTime;
    if (Actor(MO).ReactionTime <= 0.0) Actor(MO).ReactionTime = 0.0;
    if (Actor(MO).bWaterJump) WaterJump();
  } else {
    if (MO.WaterLevel > 1) {
      WaterMove(deltaTime);
    } else {
      LastWaterLevel = 0; // yes, zero
      MovePlayer(deltaTime);
      // allow to jump out of the water if we aren't submerged too deep
      if (MO.WaterLevel) CheckWaterJump(asStep:true);
    }
    if (EntityEx(MO).FindInventory(PowerSpeed) &&
        !(Level.XLevel.TicTime&1) && Length(MO.Velocity) > 12.0*35.0)
    {
      SpawnSpeedEffect();
    }
  }

  CalcHeight(deltaTime);

  if (MO.Sector) {
    PlayerProcessScrollSectors(deltaTime);
    if (MO.Sector->special || MO.Sector->Damage || SectorHas3DFloors(MO.Sector)) PlayerInSpecialSector(deltaTime);
  }

  // do not apply effects continuously on the same tick
  if (LastSectorDamageTic != Level.XLevel.TicTime) {
    PlayerOnSpecialFlat(Actor(MO).GetFloorType());
    PlayerInContents(deltaTime);
    LastSectorDamageTic = Level.XLevel.TicTime;
  }

  if (MO.Velocity.z <= -35.0*35.0 && MO.Velocity.z >= -40.0*35.0 &&
      !MorphTime && MO.WaterLevel == 0 &&
      !GetSoundPlayingInfo(MO, GetSoundID('*falling')))
  {
    MO.PlaySound('*falling', CHAN_VOICE);
  }

  // check for weapon change (and other impulse commands)
  if (Impulse) PlayerImpulse();

  if (Buttons&BT_SUPERBULLET) {
    float lt = MO.XLevel.Time;
    if (lt >= k8NextSuperBulletTime) {
      k8NextSuperBulletTime = lt+GetCvarF('k8SuperBulletCooldown');
      Actor(MO).FireSuperBullet();
    }
  }

  // check for use
  if (Buttons&BT_USE) {
    if (!bUseDown) {
      float ur, utr;
      GetUseRanges(out ur, out utr);
      EntityEx(MO).UseLines(/*DEFAULT_USERANGE*/ur, /*DEFAULT_USETHINGRANGE*/utr, '*usefail');
      bUseDown = true;
    }
  } else {
    //if (bUseDown) print("***USE GOES UP!");
    bUseDown = false;
  }

  /* done in `MovePsprites()`
  if (!ReadyWeapon && PendingWeapon && !bDisableWeaponSwitch && bWeaponAllowSwitch) {
    SetWeapon(PendingWeapon);
    BringUpWeapon();
  }
  */

  // morph counter
  if (MorphTime) {
    if (ChickenPeck) {
      // chicken attack counter
      ChickenPeck -= 3;
    }
    MorphTime -= deltaTime;
    if (MorphTime <= 0.0) {
      // attempt to undo the chicken/pig
      MorphTime = 0.0;
      UndoPlayerMorph(false, self);
    }
  }

  // cycle psprites
  MovePsprites(deltaTime);

  // counters
  if (PoisonCount && Level.XLevel.Time-LastPoisonTime >= 0.5) {
    PoisonCount -= 5;
    if (PoisonCount < 0) PoisonCount = 0;
    LastPoisonTime = Level.XLevel.Time;
    Actor(MO).PoisonDamage(Poisoner, Poisoner, 1, true);
  }

  if (DamageFlash) {
    DamageFlash -= deltaTime;
    if (DamageFlash <= 0.0) DamageFlash = 0.0;
  }

  if (BonusFlash) {
    BonusFlash -= deltaTime;
    if (BonusFlash <= 0.0) BonusFlash = 0.0;
  }

  if (HazardTime) {
    HazardTime -= deltaTime;
    if (HazardTime <= 0.0) HazardTime = 0.0;
    if (Level.XLevel.Time-LastHazardTime >= 32.0/35.0 && HazardTime > 16.0) {
      LastHazardTime = Level.XLevel.Time;
      Actor(MO).Damage(none, none, 5/*, spawnBlood:true*/);
    }
  }

  // [RH] Zoom the player's FOV
  float desired = DesiredFOV; // default player FOV
  // adjust FOV using on the currently held weapon
  if (PlayerState != PST_DEAD && // no adjustment while dead
      ReadyWeapon && // no adjustment if no weapon
      ReadyWeapon.FOVScale != 0.0) // no adjustment if the adjustment is zero
  {
    // a negative scale is used to prevent G_AddViewAngle/G_AddViewPitch
    // from scaling with the FOV scale
    desired *= fabs(ReadyWeapon.FOVScale);
  }

  if (FOV != desired) {
    if (fabs(FOV-desired) < 7.0) {
      FOV = desired;
    } else {
      float zoom = FMax(7.0, fabs(FOV-desired)*0.025);
      if (FOV > desired) FOV = FOV-zoom; else FOV = FOV+zoom;
    }
    if (int(FOV) == int(DesiredFOV)) {
      ClientFOV(0);
    } else {
      ClientFOV(FOV);
    }
  }

  if (!isBot) HealthBarProcessor();

  // flashlight code
  if (Buttons&BT_FLASHLIGHT) {
    if (!bFlashlightButtonDown) {
      bFlashlightButtonDown = true;
      bFlashlightOn = !bFlashlightOn;
    }
  } else {
    bFlashlightButtonDown = false;
  }

  //ProcessFlashligh(); // nope, it is done in `ClientTick()`

  if (bForceCrouchingDown && bForceCrouchingDown <= Level.XLevel.TicTime) {
    //printdebug("%C: crouch reset!", self);
    bForceCrouchingDown = 0;
  }
}


//==========================================================================
//
//  ProcessFlashligh
//
//==========================================================================
void ProcessFlashligh () {
  if (!bFlashlightOn || !MO) return;
  float flradius = GetCvarF('k8_flashlight_distance');
  int flcolor = GetCvarI('k8_flashlight_color')&0xff_ff_ff;
  if (flcolor && flradius > 0) {
    TVec dir;
    TVec florg;
    if (bIsClient) {
      // network client
      florg = ViewOrg;
      AngleVector(ViewAngles, out dir);
    } else {
      AngleVector(MO.Angles, out dir);
      florg = MO.Origin;
      //florg.z += MO.Height*0.5-MO.FloorClip;
      //florg.z += GetAttackZOfs();
      florg.z += ViewHeight;
    }
    dlight_t *fl = MO.AllocDlight(MO, florg, flradius, FlashlightLightId);
    if (fl) {
      fl.coneDirection = dir;
      fl.coneAngle = GetCvarF('k8_flashlight_angle');
      fl.color = flcolor|0xff_00_00_00;
      fl.die = MO.XLevel.Time+(2.0/35.0);
      fl.type = DynamicLight::DLTYPE_Spot;
      //fl.minlight = 64;
      fl.bNoShadow = !GetCvarB('k8_flashlight_shadows');
      fl.bPlayerLight = true;
    }
  }
}


//==========================================================================
//
//  SetViewPos
//
//  called from main world thinker after all thinkers were called
//
//==========================================================================
override void SetViewPos () {
  // just in a case camera entity has been destroyed
  if (!Camera) Camera = MO;

  if (MO != Camera) {
    // don't do any height fixes if our camera is not a player pawn
    ViewOrg = Camera.Origin;
    ViewOrg.z += EntityEx(Camera).CameraHeight;
    ViewAngles = Camera.Angles;
  } else {
    // fix camera height to avoid "lift sinking" effect
    PostfixViewHeight();

    ViewOrg.x = MO.Origin.x;
    ViewOrg.y = MO.Origin.y;

    if (LocalQuakeHappening) {
      //TODO: implement A_QuakeEx flags!
      //float intensity = float(LocalQuakeHappening);
      if (LocalQuakeHappening.x) ViewOrg.x += (Random()-0.5)*(LocalQuakeHappening.x*4.0);
      if (LocalQuakeHappening.y) ViewOrg.y += (Random()-0.5)*(LocalQuakeHappening.y*4.0);
      if (LocalQuakeHappening.z) ViewOrg.z += (Random()-0.5)*(LocalQuakeHappening.z*4.0);
    }

    if (PlayerState != PST_DEAD) {
      ViewAngles = MO.Angles;
    } else {
      ViewAngles.yaw = MO.Angles.yaw;
      ViewAngles.pitch = MO.Angles.pitch;
    }

    if (MorphTime && ChickenPeck) {
      // set chicken attack view position
      float s, c;
      sincos(MO.Angles.yaw, out s, out c);
      ViewOrg.x += float(ChickenPeck)*c;
      ViewOrg.y += float(ChickenPeck)*s;
    }
  }

  PaletteFlash();

  ClientSetViewOrg(ViewOrg);

  if (Level.XLevel.Zones.length && Camera.Sector) {
    SoundEnvironment = Level.XLevel.Zones[Camera.Sector->Zone];
  } else {
    SoundEnvironment = 0;
  }

  if (!SoundEnvironment) {
    if (Camera.WaterLevel >= 3) {
      // under water
      SoundEnvironment = 0x1600;
    } else {
      // generic
      SoundEnvironment = 1;
    }
  }
}


//==========================================================================
//
//  DebugPutRotatingSpotlight
//
//==========================================================================
final void DebugPutRotatingSpotlight (TVec florg, float speed, float flradius, int clr, int id) {
  TAVec ag;
  ag.yaw = AngleMod360(MO.XLevel.Time*speed);
  TVec dir;
  AngleVector(ag, out dir);
  dlight_t *fl = MO.AllocDlight(MO, florg, flradius, 669+id);
  if (!fl) return;
  fl.coneDirection = dir;
  fl.coneAngle = 42.0f;
  fl.color = clr|0xff_00_00_00;
  fl.die = MO.XLevel.Time+(2.0/35.0);
  fl.type = DynamicLight::DLTYPE_Spot;
  //fl.minlight = 64;
  fl.bNoShadow = false;
  fl.bPlayerLight = true; // so it won't be rejected
}


//==========================================================================
//
//  DebugPutRotatingSpotlightHead
//
//==========================================================================
final void DebugPutRotatingSpotlightHead (TVec florg, float speed, float flradius, int clr, int id) {
  TAVec ag;
  ag.yaw = AngleMod360(MO.XLevel.Time*speed+id*120);
  TVec dir;
  AngleVector(ag, out dir);
  florg += dir*8;
  dlight_t *fl = MO.AllocDlight(MO, florg, flradius, 669+id);
  if (!fl) return;
  fl.coneDirection = dir;
  fl.coneAngle = 42.0f;
  fl.color = clr|0xff_00_00_00;
  fl.die = MO.XLevel.Time+(2.0/35.0);
  fl.type = DynamicLight::DLTYPE_Spot;
  //fl.minlight = 64;
  fl.bNoShadow = false;
  fl.bPlayerLight = true; // so it won't be rejected
}


//==========================================================================
//
//  ClientTick
//
//==========================================================================
override void ClientTick (float deltaTime) {
  bAutoAim = !!GetCvar('autoaim');
  //printdebug("%C: flashlight=%B", self, bFlashlightOn);
  //if (MO) printdebug("%C: va=%s; %C: a=%s", self, ViewAngles, MO, MO.Angles);
  ProcessFlashligh();
#ifdef SPOTLIGHT_DISCO_TEST
  DebugPutRotatingSpotlight(vector(1100, -3270, 110), 100, 512, 0xff_ff_00_00, 0);
  DebugPutRotatingSpotlight(vector(990, -2990, 68), 100, 512, 0xff_00_ff_00, 1);
  DebugPutRotatingSpotlight(vector(588, -3226, 100), 100, 512, 0xff_ff_00_00, 2);
#endif
#ifdef SPOTLIGHT_DISCO_CROWN_TEST
  if (MO) {
    DebugPutRotatingSpotlightHead(MO.Origin+vector(0, 0, MO.Height+32), 100, 512, 0xff_ff_00_00, 0);
    DebugPutRotatingSpotlightHead(MO.Origin+vector(0, 0, MO.Height+32), 100, 512, 0xff_00_ff_00, 1);
    DebugPutRotatingSpotlightHead(MO.Origin+vector(0, 0, MO.Height+32), 100, 512, 0xff_ff_00_00, 2);
  }
#endif
  ::ClientTick(deltaTime);
}


//==========================================================================
//
//  AdjustPlayerAngle
//
//==========================================================================
void AdjustPlayerAngle (EntityEx AimTarget) {
  float angle;
  float difference;

  angle = atan2(AimTarget.Origin.y-MO.Origin.y, AimTarget.Origin.x-MO.Origin.x);
  difference = AngleMod180(angle-MO.Angles.yaw);
  if (fabs(difference) > 5.0) {
    MO.Angles.yaw += difference > 0.0 ? 5.0 : -5.0;
  } else {
    MO.Angles.yaw = angle;
  }
  bFixAngle = true;
}


//==========================================================================
//
//  UndoPlayerMorph
//
//==========================================================================
bool UndoPlayerMorph (bool Force, PlayerEx Activator) {
  Actor A;

  if (EntityEx(MO).bInvulnerable && (self != Activator || !(MorphStyle&EntityEx::MORPH_WHENINVULNERABLE))) {
    // immune when invulnerable unless this is something we initiated.
    // if the WORLD is the initiator, the same player should be given
    // as the activator; WORLD initiated actions should always succeed.
    return false;
  }

  int CorrectWeapon = MorphStyle&EntityEx::MORPH_LOSEACTUALWEAPON;

  MO.UnlinkFromWorld();
  if (BaseClass >= Level.Game.PlayerClasses.length) Error("UndoPlayerMorph: Unknown class type");

  A = Level.SpawnEntityChecked(class!PlayerPawn, class!PlayerPawn(Level.Game.PlayerClasses[BaseClass]), MO.Origin, default, default, AllowReplace:false);
  if (!A) Error("UndoPlayerMorph: class `%C` is prolly not a player pawn", Level.Game.PlayerClasses[BaseClass]);
  if (!Force && !A.TestLocation()) {
    // didn't fit
    A.Destroy();
    MO.LinkToWorld(properFloorCheck:true);
    MorphTime = 2.0;
    return false;
  }
  if (GetCvarS('player_default_gender')) A.SoundGender = name(GetCvarS('player_default_gender'));

  MO.LinkToWorld(properFloorCheck:true);
  // set color translation
  A.Translation = (Entity::TRANSL_Player<<Entity::TRANSL_TYPE_SHIFT)+GetPlayerNum();
  A.Angles = MO.Angles;
  ViewHeight = PlayerPawn(A).GetPawnViewHeight;
  DeltaViewHeight = 0.0;
  A.Player = self;
  A.bIsPlayer = true;
  A.ReactionTime = 0.5;
  if (MO.bFly) {
    A.bFly = true;
    A.bNoGravity = true;
  }
  A.bShadow = EntityEx(MO).bShadow;
  A.bGhost = EntityEx(MO).bGhost;
  A.ObtainInventory(EntityEx(MO));
  if (MO.TID && (MorphStyle&EntityEx::MORPH_NEWTIDBEHAVIOUR)) A.SetTID(MO.TID);
  MorphTime = 0.0;
  MorphStyle = 0;
  Inventory Pw = EntityEx(MO).FindInventory(PowerWeaponLevel2);
  if (Pw) Pw.Destroy();
  A.Health = GetRebornHealth();
  Health = A.Health;
  PClass = BaseClass;
  Weapon OldWeapon = ReadyWeapon;
  PostMorphWeapon(Weapon(Actor(MO).Tracer));
  if (CorrectWeapon) {
    // better "lose morphed weapon" semantics
    class!Weapon MorphWeapon = PlayerPawn(MO).MorphWeapon;
    if (MorphWeapon) {
      Weapon OrigWpn = Weapon(EntityEx(MO).FindInventory(MorphWeapon));
      if (OrigWpn && OrigWpn.bGivenAsMorphWeapon) {
        // you don't get to keep your morphed weapon
        OrigWpn.Destroy();
      }
    }
  } else {
    if (OldWeapon) OldWeapon.Destroy();
  }

  Level.Spawn(UnmorphFlash ? UnmorphFlash : class!Actor(TeleportFog),
    MO.Origin+vector(20.0*cos(MO.Angles.yaw),
    20.0*sin(MO.Angles.yaw),
    LineSpecialGameInfo(Level.Game).TeleFogHeight));

  MO.SetState(MO.FindState('FreeTargMobj'));
  MO = A;
  Camera = A;
  PlayerUnmorphed();
  return true;
}


//===========================================================================
//
//  ActivateMorphWeapon
//
//===========================================================================
void ActivateMorphWeapon () {
  class!Weapon WpnClass = PlayerPawn(MO).MorphWeapon;
  Weapon Wpn;
  if (WpnClass) {
    Wpn = Level.SpawnEntityChecked(class!Weapon, WpnClass);
    if (Wpn) Wpn.bGivenAsMorphWeapon = true;
  } else {
    // couldn't find any weapons, use the default weapon for this player (from initial inventory)
    foreach (int i; 0..EntityEx(MO).DropItemList.length) {
      class!EntityEx itc = class!EntityEx(EntityEx(MO).DropItemList[i].Type);
      if (!itc) continue;
      class!EntityEx itcrepl = class!EntityEx(GetClassReplacement(itc));
      if (itcrepl) itc = itcrepl;
      Inventory Item = Level.SpawnEntityChecked(class!Inventory, itc, default, default, default, AllowReplace:false);
      if (Item) {
        if (EntityEx(MO).DropItemList[i].Amount > 0) {
          Item.Amount = EntityEx(MO).DropItemList[i].Amount;
        }
        if (Weapon(Item)) {
          Wpn = Weapon(Item);
          WpnClass = class!Weapon(Weapon(Item).Class);
          break;
        }
        delete Item;
      }
    }
  }
  if (Wpn && !Wpn.TryPickup(EntityEx(MO))) delete Wpn;

  if (WpnClass) {
    SetWeapon(Weapon(EntityEx(MO).FindInventory(WpnClass)));
  } else {
    SetWeapon(none);
  }
  SetViewObject(ReadyWeapon);
  if (ReadyWeapon) {
    ReadyWeapon.bBobDisabled = true;
    SetViewState(PS_WEAPON, ReadyWeapon.GetReadyState());
  } else {
    SetViewState(PS_WEAPON, none);
  }
  SetViewStateOffsets(0, Weapon::WEAPONTOP);
}


//===========================================================================
//
//  PostMorphWeapon
//
//===========================================================================
void PostMorphWeapon (Weapon weapon) {
  SetWeapon(weapon);
  SetViewStateOffsets(0, Weapon::WEAPONBOTTOM);
  SetViewObject(ReadyWeapon);
  if (ReadyWeapon) {
    ReadyWeapon.bBobDisabled = true;
    SetViewState(PS_WEAPON, ReadyWeapon.GetUpState());
  } else {
    SetViewState(PS_WEAPON, none);
  }
}


//==========================================================================
//
//  AddVisitedMap
//
//==========================================================================
void AddVisitedMap (name Map) {
  foreach (auto i; 0..MAX_MAPS_VISITED) {
    if (MapsVisited[i] == Map) return;
    if (!MapsVisited[i]) { MapsVisited[i] = Map; return; }
  }
}


//==========================================================================
//
//  GetMaxHealth
//
//==========================================================================
int GetMaxHealth () {
  int Max = (PlayerPawn(MO) && PlayerPawn(MO).MaxHealth > 0 ? PlayerPawn(MO).MaxHealth :
    Level.CompatDehHealth ? MAXHEALTH :
    HealthBonus.default.MaxAmount/2)+(MO ? MO.Stamina : 0);
  if (MorphTime) {
    if (MorphStyle&EntityEx::MORPH_FULLHEALTH) {
      if (!(MorphStyle&EntityEx::MORPH_ADDSTAMINA)) Max -= (MO ? MO.Stamina : 0);
    } else {
      Max = MAXMORPHHEALTH;
      if (MorphStyle&EntityEx::MORPH_ADDSTAMINA) Max += (MO ? MO.Stamina : 0);
    }
  }
  return Max;
}


//==========================================================================
//
//  CheckFriendlyFire
//
//  TODO
//
//==========================================================================
bool CheckFriendlyFire (EntityEx source, int damage) {
  return false;
}


//==========================================================================
//
//  IsWeaponAlwaysExtremeDeath
//
//  TODO
//
//==========================================================================
bool IsWeaponAlwaysExtremeDeath () {
  return false;
}


//==========================================================================
//
//  StartDeathSlideShow
//
//==========================================================================
void StartDeathSlideShow () {
}


//==========================================================================
//
//  GotAmmo
//
//==========================================================================
void GotAmmo (Ammo NewAmmo) {
}


//==========================================================================
//
//  Damaged
//
//==========================================================================
void Damaged (EntityEx inflictor) {
}


//==========================================================================
//
//  KilledActor
//
//==========================================================================
void KilledActor (EntityEx Victim) {
}


//==========================================================================
//
//  Killed
//
//==========================================================================
void Killed (EntityEx source, EntityEx inflictor) {
}


//==========================================================================
//
//  GetSigilPieces
//
//==========================================================================
int GetSigilPieces () {
  return 0;
}


//==========================================================================
//
//  PlayerMorphed
//
//==========================================================================
void PlayerMorphed (EntityEx OldMO) {
  // so we can select weapons
  if (PlayerPawn(MO)) PlayerPawn(MO).InitializeWeaponSlots();
}


//==========================================================================
//
//  PlayerUnmorphed
//
//==========================================================================
void PlayerUnmorphed () {
  // so we can select weapons
  if (PlayerPawn(MO)) PlayerPawn(MO).InitializeWeaponSlots();
}


//==========================================================================
//
//  CreateBot
//
//==========================================================================
void CreateBot () {
}


//==========================================================================
//
//  CoopGetAllSharedKeys
//
//==========================================================================
void CoopGetAllSharedKeys () {
  if (!MO) return;
  if (!GetCvarB('sv_coop_share_keys')) return;
  // share all all keys
  foreach (auto playnum; 0..MAXPLAYERS) {
    auto pl = PlayerEx(Level.Game.Players[playnum]);
    if (!pl || !pl.bSpawned || !pl.MO || pl.MO == MO || pl == self) continue;
    for (auto inv = EntityEx(pl.MO).Inventory; inv; inv = inv.Inventory) {
      if (!class!Key(inv.Class)) continue;
      bool found = false;
      for (auto myinv = EntityEx(MO).Inventory; myinv; myinv = myinv.Inventory) {
        if (myinv.Class == inv.Class) {
          found = true;
          break;
        }
      }
      if (found) continue;
      printdebug("%C: autoadding to the player #%d", inv, playnum);
      EntityEx pmo = EntityEx(MO);
      // must create a copy
      Inventory Copy = pmo.SpawnEntityChecked(class!Inventory, class!Inventory(inv.Class), pmo.Origin, pmo.Angles, default, AllowReplace:false);
      assert(Copy);
      Copy.Amount = inv.Amount;
      Copy.MaxAmount = inv.MaxAmount;
      Copy.bTransferInventory = inv.bTransferInventory;
      Copy.AttachToOwner(pmo);
      printdebug("%C: autoadded to the player #%d", inv, playnum);
    }
  }
}


//==========================================================================
//
//  OnNetSpawn
//
//==========================================================================
void OnNetSpawn (EntityEx OldMO) {
  // give all keys other players have to this one when in coop
  if (!Level.Game.netgame || Level.Game.deathmatch) return;
  CoopGetAllSharedKeys();
}


//==========================================================================
//
//  OnNetReborn
//
//==========================================================================
void OnNetReborn (EntityEx OldMO) {
  // restore keys and weapons when reborn in co-op
  if (!Level.Game.netgame || Level.Game.deathmatch) return;
  if (!OldMO) {
    CoopGetAllSharedKeys();
    return;
  }
  //printdebug("%C: transfer weapons...", self);
  for (auto inv = OldMO.Inventory; inv; ) {
    //printdebug("%C:  inv=%C", self, inv);
    Inventory next = inv.Inventory;
    if (Weapon(inv)) {
      if (GetCvarB('sv_coop_keep_weapons')) inv.AttachToOwner(EntityEx(MO));
      //printdebug("%C:  inv=%C: WEAPON TRANSFER", self, inv);
    } else if (FourthWeaponHolder(inv) || Key(inv)) {
      //printdebug("%C:  inv=%C: KEY TRANSFER", self, inv);
      inv.AttachToOwner(EntityEx(MO));
    }
    inv = next;
  }
  OldMO.DestroyAllInventory();
}


//==========================================================================
//
//  DestroyBot
//
//==========================================================================
void DestroyBot () {
}


//==========================================================================
//
//  BotOnSpawn
//
//==========================================================================
void BotOnSpawn () {
}


//==========================================================================
//
//  BotSendSubSectorChange
//
//==========================================================================
void BotSendSubSectorChange (subsector_t *ss) {
}


//==========================================================================
//
//  SetClientModel
//
//==========================================================================
void SetClientModel () {
}


//==========================================================================
//
//  GetRebornHealth
//
//==========================================================================
int GetRebornHealth () {
  return 0;
}


//==========================================================================
//
//  BotTick
//
//==========================================================================
void BotTick (float deltaTime) {
}


//==========================================================================
//
//  SpawnSpeedEffect
//
//==========================================================================
void SpawnSpeedEffect () {
}


//==========================================================================
//
//  PlayerImpulse
//
//  return `true` if impulse was eaten
//
//==========================================================================
void PlayerImpulse () {
  if (!Impulse) return;

  // weapon slot 11 is used for weapons without explicit slot
  if (Impulse <= PlayerPawn::NUM_WEAPON_SLOTS) { ChangeWeapon(Impulse); Impulse = 0; return; }

  switch (Impulse) {
    //^C test:case 222: for (;;) { /*print("boo");*/ } return;
    case 13: InventoryLeft(); Impulse = 0; return;
    case 14: InventoryRight(); Impulse = 0; return;
    case 15: InventoryUse(); Impulse = 0; return;
    case 16: Actor(MO).Damage(none, none, 10000); Impulse = 0; return;
    case 17: PrevWeapon(); Impulse = 0; return;
    case 18: NextWeapon(); Impulse = 0; return;
    case 43: Actor(MO).FireSuperBullet(); Impulse = 0; return;
    case 48: ChangeWeapon(11); Impulse = 0; return; // weapons without explicit slot
    case 56: bReloadQueued = true; Impulse = 0; return; // so you can use this in aliases and such
    case 142: Actor(MO).DebugCheckMidTex(); Impulse = 0; return;
    case 149: bFlashlightOn = !bFlashlightOn; Impulse = 0; return; // so you can use this in aliases and such
    case 155:
      foreach (auto pidx; 0..MAXPLAYERS) {
        PlayerEx plr = PlayerEx(Level.Game.Players[pidx]);
        if (!plr || !plr.bIsBot) continue;
        plr.BotDumpNodes();
      }
      Impulse = 0;
      return;
    case 156:
      if (MO) {
        foreach (auto pidx; 0..MAXPLAYERS) {
          PlayerEx plr = PlayerEx(Level.Game.Players[pidx]);
          if (!plr || !plr.bIsBot) continue;
          plr.BotTestFindPathTo(MO.Origin);
        }
      }
      Impulse = 0;
      return;
  }

  if (Impulse >= 200 && Impulse <= 205) {
    LineSpecialLevelInfo(Level).ConChoiceImpulse(Impulse-200); // strife does additional processing
    Impulse = 0;
    return;
  }
}


//==========================================================================
//
//  eventGetReadyWeapon
//
//==========================================================================
override Entity eventGetReadyWeapon () {
  return ReadyWeapon;
}


//==========================================================================
//
//  GetCurrentArmor
//
//==========================================================================
BasicArmor GetCurrentArmor () {
  if (!MO) return none;
  return BasicArmor(EntityEx(MO).FindInventory(BasicArmor, disableReplacement:true));
}


//==========================================================================
//
//  GetCurrentArmorClassName
//
//==========================================================================
override string GetCurrentArmorClassName () {
  auto armor = GetCurrentArmor();
  return (armor ? string(armor.GetArmorName()) : "None");
}


//k8: basically, this is wrong, because

//==========================================================================
//
//  GetCurrentArmorSaveAmount
//
//==========================================================================
override int GetCurrentArmorSaveAmount () {
  auto armor = GetCurrentArmor();
  return (armor ? armor.Amount : 0);
}


//==========================================================================
//
//  GetCurrentArmorSavePercent
//
//==========================================================================
override float GetCurrentArmorSavePercent () {
  auto armor = GetCurrentArmor();
  return (armor ? armor.SavePercent : 0);
}


//==========================================================================
//
//  GetCurrentArmorMaxAbsorb
//
//==========================================================================
override int GetCurrentArmorMaxAbsorb () {
  // this is for HexenArmor, and it is not implemented yet
  return 0;
}


//==========================================================================
//
//  GetCurrentArmorFullAbsorb
//
//==========================================================================
override int GetCurrentArmorFullAbsorb () {
  // this is for HexenArmor, and it is not implemented yet
  return 0;
}


//==========================================================================
//
//  GetCurrentArmorActualSaveAmount
//
//==========================================================================
override int GetCurrentArmorActualSaveAmount () {
  auto armor = GetCurrentArmor();
  if (!armor) return 0;
  auto bonus = BasicArmorBonus(armor);
  if (bonus) return bonus.SaveAmount;
  auto pickup = BasicArmorPickup(armor);
  if (pickup) return pickup.SaveAmount;
  // i don't know what is it
  return 0;
}


//==========================================================================
//
//  GetCurrentArmorActualSaveAmount
//
//==========================================================================
bool IsWeaponFromSlot11 (class!Weapon wpn) {
  if (!wpn) return true; // why not?

  auto pawn = PlayerPawn(MO);
  if (!pawn) return true;

  //printdebug("checking weapon '%C' for slot 11...", wpn);

  // slots are numbered from zero
  int slotsize = pawn.GetSlotSize(10);
  if (!slotsize) return false; // this slot is empty, nothing to do
  //printdebug("slot 11 has %s weapons...", slotsize);

  foreach (auto i; 0..slotsize) {
    class!Weapon slotwpn = pawn.GetWeaponInSlot(10, i);
    //printdebug("  weapon #%d: '%C'", i, slotwpn);
    if (!slotwpn) continue;
    if (slotwpn == wpn) return true;
  }

  return false;
}


//==========================================================================
//
//  CheatHelper_AllWeapons
//
//==========================================================================
void CheatHelper_AllWeapons (bool full) {
  bool gotit = false;
  class!Weapon WpnCls;
  foreach AllClasses(Weapon, out WpnCls) {
    if (WpnCls.default.bCheatNotWeapon) continue;
    class!Weapon repl = class!Weapon(GetClassReplacement(WpnCls));
    if (repl && repl != WpnCls) continue;
    // check if it is valid
    if (!EntityEx.CheckSpawnGameFilter(WpnCls, Level.Game)) continue;
    if (!Weapon.IsUsableWeaponClass(WpnCls)) continue;
    // check if already have it
    if (EntityEx(MO).FindInventory(WpnCls, disableReplacement:true)) continue;
    // check for slot 11
    if (!full) {
      if (IsWeaponFromSlot11(WpnCls)) continue;
      /*
      auto pawn = PlayerPawn(MO);
      if (!pawn) continue;
      int slot, widx;
      if (!pawn.FindWeaponSlot(WpnCls, out slot, out widx)) continue;
      */
    }
    //Weapon Wpn = Weapon(Level.Spawn(WpnCls, default, default, default, AllowReplace:false));
    Weapon Wpn = EntityEx.SpawnWeaponType(Level, WpnCls, disableReplace:true);
    Wpn.AmmoGive1 = 0;
    Wpn.AmmoGive2 = 0;
    if (!Wpn.TryPickup(EntityEx(MO))) {
      Wpn.Destroy();
    } else {
      print("CHEAT: got '%C'!", WpnCls);
      gotit = true;
    }
  }
  if (gotit) cprint("You got weapons!");
}


//==========================================================================
//
//  CheatHelper_GiveAmmoClass
//
//==========================================================================
bool CheatHelper_GiveAmmoClass (class!Ammo acls, optional bool verbose) {
  if (!acls) return false;

  Ammo AmmoItem = EntityEx.SpawnAmmoType(Level, acls);
  if (!AmmoItem) {
    if (verbose) printwarn("failed to spawn ammo '%C'", acls);
    return false;
  }
  if (verbose) printdebug("spawned ammo '%C' for ammo class '%C'", AmmoItem, acls);

  bool res = false;
  Inventory invAmmo = EntityEx(MO).FindInventory(acls);
  if (invAmmo && Ammo(invAmmo)) {
    delete AmmoItem;
    AmmoItem = Ammo(invAmmo);
    assert(AmmoItem);
  } else {
    assert(Ammo(AmmoItem));
    if (!AmmoItem.TryPickup(EntityEx(MO))) {
      AmmoItem.Destroy();
      AmmoItem = none;
    } else {
      res = true;
    }
  }

  if (Ammo(AmmoItem)) {
    auto spwspate = FindClassState(AmmoItem.Class, 'Spawn');
    if (spwspate && AreStateSpritesPresent(spwspate)) {
      AmmoItem.Amount = Ammo(AmmoItem).k8GetAmmoKingMax();
    } else {
      bool hasBackpack = false;
      if (AmmoItem.Owner && AmmoItem.Owner.bIsPlayer) {
        PlayerEx plr = PlayerEx(AmmoItem.Owner.Player);
        hasBackpack = (plr && plr.bHasBackpack);
      }
      if (verbose) printdebug("unpickable ammo '%C', AmmoKing ignored", AmmoItem);
      int am = Ammo(AmmoItem).MaxAmount;
      if (hasBackpack) am = max(am, Ammo(AmmoItem).BackpackMaxAmount);
      AmmoItem.Amount = am;
    }
    res = true;
  }

  return res;
}


//==========================================================================
//
//  CheatHelper_AllAmmo
//
//  if `full` is `false`, give ammo only for weapons in hands
//
//==========================================================================
void CheatHelper_AllAmmo (bool full, optional bool current) {
  bool gotit = false;

  if (current) {
    Weapon wpn = ReadyWeapon;
    if (!wpn) return;
    if (wpn.AmmoType1) {
      if (CheatHelper_GiveAmmoClass(wpn.AmmoType1, verbose:true)) gotit = true;
    }
    if (wpn.AmmoType2 && wpn.AmmoType2 != wpn.AmmoType1) {
      if (CheatHelper_GiveAmmoClass(wpn.AmmoType2, verbose:true)) gotit = true;
    }
  } else if (full) {
    // all ammo
    class!Ammo Cls;
    foreach AllClasses(Ammo, out Cls) {
      // only direct descendants
      if (GetClassParent(Cls) != Ammo) continue;
      if (!EntityEx.CheckSpawnGameFilter(Cls, Level.Game)) continue;
      if (CheatHelper_GiveAmmoClass(class!Ammo(Cls))) gotit = true;
    }
  } else {
    // only for weapons in hands
    auto pawn = PlayerPawn(MO);
    if (!pawn) return;

    array!(class!Ammo) ammoList;

    // check all weapon slots
    /*
    foreach (auto slot; 0..pawn.GetNumberOfSlots()) {
      int slotsize = pawn.GetSlotSize(slot);
      if (!slotsize) continue;
      foreach (auto i; 0..slotsize; reverse) {
        class!Weapon slotwpn = pawn.GetWeaponInSlot(slot, i);
        if (!slotwpn) continue;
      }
    }
    */

    // collect possible ammo
    for (Inventory inv = pawn.Inventory; inv; inv = inv.Inventory) {
      auto wpn = Weapon(inv);
      if (!wpn) continue;
      foreach (int atidx; 0..2) {
        class!Ammo acls = (atidx ? wpn.AmmoType2 : wpn.AmmoType1);
        if (!acls) continue;
        int xidx = 0;
        for (; xidx < ammoList.length; ++xidx) if (ammoList[xidx] == acls) break;
        if (xidx >= ammoList.length) ammoList[$] = acls;
      }
    }

    // now give collected ammo
    foreach (class!Ammo acls; ammoList) {
      //if (!EntityEx.CheckSpawnGameFilter(acls, Level.Game)) continue; // just in case?
      if (CheatHelper_GiveAmmoClass(acls, verbose:true)) gotit = true;
    }
  }

  if (gotit) cprint("You got ammo!");
}


//==========================================================================
//
//  CheatHelper_AllKeys
//
//==========================================================================
void CheatHelper_AllKeys () {
  bool gotit = false;
  class!Key Cls;
  foreach AllClasses(Key, out Cls) {
    class!Key repl = class!Key(GetClassReplacement(Cls));
    if (repl && repl != Cls) continue;
    if (!EntityEx.CheckSpawnGameFilter(Cls, Level.Game)) continue;
    if (!EntityEx.IsSpawnableClass(Cls)) continue;
    if (EntityEx(MO).FindInventory(Cls, disableReplacement:true)) continue;
    EntityEx(MO).GiveInventoryType(Cls, disableReplace:true);
    gotit = true;
  }
  if (gotit) cprint("You got keys!");
}


// can be overriden in user mods
void AdjustForwardMove (ref float speed, ref float moveWalk, ref float moveRun) {}
void AdjustSideMove (ref float speed, ref float moveWalk, ref float moveRun) {}


defaultproperties {
  InvSize = 6;
  PrevViewHeight = -666;
}
