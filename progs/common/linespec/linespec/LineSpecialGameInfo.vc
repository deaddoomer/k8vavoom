//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2021 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class LineSpecialGameInfo : GameInfo;

const int MaxWeaponSlots = 10; // 10 is valid!
const int MaxWeaponsInSlot = 8;


// thing types that are handled durign set-up of a level
const int
  FLOOR_SLOPE_TYPE = 1500,
  CEILING_SLOPE_TYPE = 1501,

  FLOOR_VERTEX_HEIGHT_TYPE = 1504,
  CEILING_VERTEX_HEIGHT_TYPE = 1505,

  PO_ANCHOR_TYPE_HEXEN = 3000,
  PO_SPAWN_TYPE_HEXEN = 3001,
  PO_SPAWNCRUSH_TYPE_HEXEN = 3002,

  PO_ANCHOR_TYPE = 9300,
  PO_SPAWN_TYPE = 9301,
  PO_SPAWNCRUSH_TYPE = 9302,
  PO_SPAWNHURT_TYPE = 9303,

  SLOPE_FLOOR_POINT_LINE_TYPE = 9500,
  SLOPE_CEILING_POINT_LINE_TYPE = 9501,
  SET_FLOOR_SLOPE_TYPE = 9502,
  SET_CEILING_SLOPE_TYPE = 9503,
  COPY_FLOOR_PLANE_TYPE = 9510,
  COPY_CEILING_PLANE_TYPE = 9511;


float[9] contents_alpha;

bool bUseHexenPolyobjTypes;
// -- Flags for actor behavior --
bool bNoClipIgnoreFloor; // in Doom non-clipping missiles doesn't explode when hitting the floor, in other games they do
bool bNoDamageThrustInvulnerable; // don't do damage thrust to the invulnerable players
bool bNightmareFastChase; // monsters move faster in nightmare mode
bool bRavenStylePickupRespawn; // use pickup respawn effects like in Raven's games
bool bAlwaysSwitchNewWeapon; // always to switch to a newly picked up weapon
bool bBloodRandomiseTime; // randomise blood's initial state time
bool bBloodSpray; // enter blood's spray state
bool bRipperBloodNoGravity; // ripper blood has no gravity
bool bDehacked;

bool bRespawnItems;
bool bRespawnBigItems;
bool bWeaponsStay;
bool bRandomClass;

float[3] windTab;
float[5] pushTab;

int[9] opposite;
int[4] diags;
float[8] xspeed;
float[8] yspeed;

float TeleFogHeight;
name TeleportFogState;

float DefaultKickBack;

int NonMonsterAngleIncrements;

int InvDefaultMaxAmount;

float IceMoveFactor;
float GibsHealthFactor;

int[16] ramp1;
int[16] ramp2;

float RespawnTime;

int GOD_HEALTH;

int DehExplosionStyle;
float DehExplosionAlpha;


// this is used for default, and for keyconf slots
struct WeaponSlot {
  class!Weapon[MaxWeaponsInSlot] Weapons;
};

protected transient WeaponSlot WeaponSlots[MaxWeaponSlots+1];


// this is used for gameinfo slots
enum WSlotSrc {
  KEYCONF,
  GAMEINFO,
}

struct WeaponSlotRec {
  class!Weapon wcls;
  WSlotSrc src;
}

struct WSlotEntry {
  array!WeaponSlotRec weapons;
}

transient WSlotEntry kkWeaponSlots[MaxWeaponSlots];
transient int kkWeaponSlotCopy[MaxWeaponSlots]; // if set to false, this slot was inited from keyconf


//==========================================================================
//
//  Init
//
//==========================================================================
override void Init () {
  CreateCvarStr('player_default_gender', "male", "Default player gender?", CVAR_ARCHIVE|CVAR_PREINIT); // preinit, so we can change it from command line

  CreateCvarBool('gm_death_infighting', true, "Should monsters start infighting when player dies?", CVAR_ARCHIVE);
  CreateCvarInt('dbg_perfect_hatred', 0, "Make monsters hate everything around? (bitflags, use 13 for most fun)", 0);

  CreateCvarBool('gm_fix_attack_offset', true, "Make player shots go through crosshair (gameplay changer)?", CVAR_ARCHIVE);
  CreateCvarBool('gm_fix_projectile_attack_offset', true, "Make player projectile shots go (roughly) through crosshair (gameplay changer)?", CVAR_ARCHIVE);
  CreateCvarBool('gm_doomguy_eye_camera', false, "Move view camera to DoomGuy eyes (this works only for standard DoomGuy height)?", CVAR_ARCHIVE);

  CreateCvarBool('zdoom_blood_hack', false, "Use ZDoom blood spawn hack (different starting frame depending on damage)?", CVAR_ARCHIVE);
  CreateCvarFloat('blood_ripper_delay', 0.5, "Ripper projectile blood spawn timeout, in seconds.", CVAR_ARCHIVE);

  CreateCvarBool('show_secret_message', true, "Show 'you found a secret area' message?", CVAR_ARCHIVE);
  CreateCvarBool('play_secret_sound', true, "Play 'you found a secret area' sound (misc/secret)?", CVAR_ARCHIVE);

  CreateCvarFloat('movebob', 0.1, "Player camera bobbing.", CVAR_ARCHIVE); // doom default is "0.25"
  CreateCvarFloat('weaponbob', 0.24, "Player weapon bobbing (relative to camera).", CVAR_ARCHIVE);

  CreateCvarBool('menu_quit_prompt', true, "Show quit prompt on menu quit?", CVAR_ARCHIVE);

  CreateCvarBool('monster_backing', false, "Should monsters back away from melee attacker?", CVAR_ARCHIVE);
  CreateCvarBool('r_addrocketexplosion', false, "Use additive visuals for explosions?", CVAR_ARCHIVE);
  CreateCvarBool('plr_allow_damage_thrust', true, "Can the player be knocked back when damaged?", CVAR_ARCHIVE); // prevrel was 0
  CreateCvarBool('autoaim', true, "Should weapons autoaim?", CVAR_ARCHIVE);
  CreateCvarBool('k8HitscanAutoAim', false, "Enable autoaim for hitscan weapon?", CVAR_ARCHIVE); // prevrel was 1
  CreateCvarBool('monster_dropoff', false, "Should monsters try to move away if hanging over dropoff?", CVAR_ARCHIVE); // prevrel was 0
  // this one is only used in Hexen for now, but it could come in handy for other games if needed
  CreateCvarBool('alternate_monster_attacks', false, "Alternate monster attacks in Hexen?", CVAR_ARCHIVE);
  CreateCvarBool('wpn_autoswitch', IsReleaseMode, "Should we autoswitch to new weapon?", CVAR_ARCHIVE);

  CreateCvarBool('r_flip_corpses', false, "Randomly flip corpses?", CVAR_ARCHIVE);

  // debug headshots?
  CreateCvarBool('k8HSDebug', false, "Show headshots debug messages?", 0);
  CreateCvarBool('k8HSDebug_ShowFailedDamageType', false, "Show skipped damage types?", 0);

  // show headshots calculation? (doesn't matter if debug is off)
  CreateCvarBool('k8HSShowHeadshots', true, "Show headshots calculation debug?", 0);

  // show criticals calculation? (doesn't matter if debug is off)
  CreateCvarBool('k8HSDebug_Crits', true, "Show headshots criticals debug?", 0);

  // enable headshots?
  CreateCvarBool('k8HSEnabled', true, "Is headshots enabled?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  // distance multiplier (the more -- the less headshot chance on big distances)
  CreateCvarFloat('k8HSDistMult', 1.1, "Headshots distance multiplier (the more -- the less headshot chance on big distances)", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  // announce critical messages
  CreateCvarBool('k8HSShowCriticals', true, "Announce critical shots?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  // disable criticals?
  CreateCvarBool('k8HSCriticals', true, "Enable critical shots?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);

  // allow headshots from all projectiles?
  CreateCvarBool('k8HSAnyProjectile', false, "Enable headshots from any projectile?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);

  // fastkill/instakill some annoying monsters?
  CreateCvarBool('k8HSFastKillAnnoyingMonsters', IsDeveloperVersion, "Fastkill some annoying monsters?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  // instakill Pain Elementals?
  CreateCvarBool('k8HSInstaKillPainElementals', IsDeveloperVersion, "Instakill Pain Elementals?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  // instakill Lost Souls?
  CreateCvarBool('k8HSInstaKillLostSouls', IsDeveloperVersion, "Instakill Lost Souls?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  // how mush damage should be inflicted to Arch-Vile?
  CreateCvarInt('k8HSFastKillArchVileDamage', /*120*/230, "Amount of damage dealt for fast-killing ArchViles.", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);

  CreateCvarBool('k8HSHeadKillBloodSpray', true, "Do bloodspray on instakill/headshot?", CVAR_ARCHIVE);
  CreateCvarInt('k8HSHeadKillBloodCount', 3, "How much blood to spray on instakill/headshot?", CVAR_ARCHIVE);
  CreateCvarBool('k8HSHeadKillBloodPool', false, "Spawn blood pool on instakill/headkill?", CVAR_ARCHIVE);

  CreateCvarBool('k8AmmoKing', IsDeveloperVersion, "Enable Ammo King mode?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarBool('k8AmmoKing_AllowBackpack', false, "Enable backpack effect in Ammo King mode?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarInt('k8AmmoKing_MaxShells_Normal', 200, "Maximum shells in ammo king, no headshots.", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarInt('k8AmmoKing_MaxShells_HS', 100, "Maximum shells in ammo king, with headshots.", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarInt('k8AmmoKing_MaxBullets_Normal', 666, "Maximum bullets in ammo king mode, no headshots.", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarInt('k8AmmoKing_MaxBullets_HS', 200, "Maximum bullets in ammo king mode, with headshots.", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarInt('k8AmmoKing_MaxRockets', 150, "Maximum rockets in ammo king mode.", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarInt('k8AmmoKing_MaxCells', 666, "Maximum rockets in ammo king mode.", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarInt('k8AmmoKing_MaxOther', 400, "Maximum other ammo in ammo king mode.", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);

  CreateCvarBool('k8ElvenGift', IsDeveloperVersion, "Start game with some Elven Gifts?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarBool('k8ElvenDetect', IsDeveloperVersion, "Perform Elven Senses Detection?", CVAR_ARCHIVE);

  CreateCvarBool('k8ElvenPaineless', IsDeveloperVersion, "Disable Pain Elemental attacks?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);

  CreateCvarBool('k8BerserkSwitch', IsReleaseMode, "Switch to fist when Berserker Pack taken.", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarStr('k8BerserkTint', (IsReleaseMode ? "" : "#100"), "Berserk powerup tint color.", CVAR_ARCHIVE);

  // moved to the engine code
  //CreateCvar('k8ColormapInverse', "0", "Inverse colormap replacement (0: original inverse; 1: black-and-white; 2: gold; 3: green; 4: red)", CVAR_ARCHIVE);
  //CreateCvar('k8ColormapLightAmp', "0", "LightAmp colormap replacement (0: original; 1: black-and-white; 2: gold; 3: green; 4: red)", CVAR_ARCHIVE);
  CreateCvarInt('k8ColormapBerserk', (IsReleaseMode ? 0 : 5), "Berserk replacement colormap (0: original; 1: black-and-white; 2: gold; 3: green; 4: red; 5: inverse).", CVAR_ARCHIVE);
  CreateCvarInt('k8ColormapEnviSuit', 0, "EnviroSuit replacement colormap (0: original; 1: black-and-white; 2: gold; 3: green; 4: red; 5: inverse).", CVAR_ARCHIVE);

  CreateCvarBool('k8StealthFist', true, "Should fist attack alert monsters only when some monster was injured?.", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarBool('k8StealthChainsaw', true, "Should chainsaw attack alert monsters only when some monster was hit?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);

  CreateCvarFloat('k8BonusFlashMaxTime', 0.4, "Maximum bonus flash time, in sectonds (<=0 is unlimited; one bonus is 0.2).", CVAR_ARCHIVE);

  CreateCvarBool('k8TraceDebug', false, "Line trace debug mode", 0);

  CreateCvarBool('r_particle_effects', true, "Enable particle effects?", CVAR_ARCHIVE);
  CreateCvarBool('r_particle_puffs', true, "Enable particle sparks?", CVAR_ARCHIVE);
  CreateCvarBool('r_particle_blood', false, "Enable particle blood?", CVAR_ARCHIVE);
  CreateCvarBool('r_particle_trails', true, "Enable particle trails?", CVAR_ARCHIVE);

  CreateCvarBool('r_statusbar_draw', true, "Draw statusbar?", CVAR_ARCHIVE);

  CreateCvarBool('r_hud_draw_fs_ammo', true, "Draw ammo counts on fullscreen HUD?", CVAR_ARCHIVE);
  CreateCvarBool('r_hud_draw_fs_face', true, "Draw Doomguy face on fullscreen HUD?", CVAR_ARCHIVE);
  CreateCvarBool('r_hud_fs_face_centered', false, "Draw Doomguy face in FS HUD center?", CVAR_ARCHIVE);
  CreateCvarBool('r_hud_draw_fs_powerup_timers', true, "Draw timers for powerups in FS HUD?", CVAR_ARCHIVE);

  CreateCvarBool('r_hud_draw_weapon_name', true, "Draw weapon name on fullscreen HUD?", CVAR_ARCHIVE);
  CreateCvarFloat('r_hud_weapon_name_fadeout_time', 1.4, "Weapon name fadeout time on fullscreen HUD.", CVAR_ARCHIVE);
  CreateCvarInt('r_hud_weapon_name_color', 5, "Weapon name color on fullscreen HUD.", CVAR_ARCHIVE);

  CreateCvarBool('fuck_stealth_monsters', false, "Turn all fuckin' stealth monsters to normal ones?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);

  CreateCvarInt('vid_renderer', 1, "Tell some idiotic mod authors that we're GZDoom in OpenGL mode (1).", 0);

  CreateCvarBool('k8HealthAccum_Enabled', IsDeveloperVersion, "Enable Health Accumulation?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarBool('k8HealthAccum_Reset', true, "Reset accumulated health on level transition?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarBool('k8HealthAccum_NewMapHeal', true, "Heal with accumulated health on level transition?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarInt('k8HealthAccum_Max', 666, "How much health Accumulator can hold?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarInt('k8HealthAccum_RegenLow', 70, "When health goes below this, Accummulator will start regenerating your health (0 means always).", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarInt('k8HealthAccum_RegenRate', 2, "Seconds between regenerating health.", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarInt('k8HealthAccum_RegenPoints', 1, "How much health points should be regenerated in one step?", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarInt('k8HealthAccum_BoostLow', 25, "When health goes below this, Accummulator will boost your health.", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarInt('k8HealthAccum_BoostPoints', -90, "Boost by this number of health points (positive), or up to the given health (negative).", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  CreateCvarInt('k8HealthAccum_BoostCooldown', 30, "Health boost cooldown, in seconds.", CVAR_ARCHIVE/*|CVAR_SERVERINFO*/);
  //TODO: make this network-aware
  CreateCvarBool('k8HealthAccum_MessagesRegen', false, "Report health regeneration.", CVAR_ARCHIVE);
  CreateCvarBool('k8HealthAccum_MessagesBoost', true, "Report health boost.", CVAR_ARCHIVE);
  CreateCvarBool('k8HealthAccum_MessagesAccumed', false, "Report health accumulation.", CVAR_ARCHIVE);

  //CreateCvarBool('hud_scale_messages', true, "Rescale HUD messages, so message font is less distorted?", CVAR_ARCHIVE);

  CreateCvarBool('k8HealthBar', false, "Allow healthbar?", CVAR_ARCHIVE);
  CreateCvarFloat('k8HealthBarAlpha', 0.6, "Healthbar opacity.", CVAR_ARCHIVE);
  CreateCvarBool('k8HealthBarOnlyMonsters', true, "Ignore non-monsters?", CVAR_ARCHIVE);
  CreateCvarBool('k8HealthBarShowAll', false, "Show any object (useful for debugging)?", CVAR_ARCHIVE);
  CreateCvarBool('k8HealthBarShowClassName', false, "Show class name instead of tag (useful for debugging)?", CVAR_ARCHIVE);

  CreateCvarBool('blood_widespread', false, "Throw blood splats on full 360 degrees circle?", CVAR_ARCHIVE);

  CreateCvarBool('k8_flashlight_shadows', false, "Do shadow casting from player flashlight?", CVAR_ARCHIVE);
  CreateCvarFloat('k8_flashlight_distance', 768, "Flashlight distance.", CVAR_ARCHIVE);
  CreateCvarStr('k8_flashlight_color', "0xcfcf50", "Flashlight color.", CVAR_ARCHIVE);
  CreateCvarFloat('k8_flashlight_angle', 20, "Flashlight cone angle.", CVAR_ARCHIVE);

  CreateCvarFloat('k8SuperBulletCooldown', 0.15, "SuperBullet cooldown time, in seconds.", CVAR_ARCHIVE);


  CreateCvarBool('dbg_blood_disable_entities', false, "Disable spawning of blood entities?", 0/*CVAR_ARCHIVE*/);

  CreateCvarBool('wp_cycle_special_slot', false, "Should weapon cycling use slot 11 too?", CVAR_ARCHIVE);


  CreateCvarBool('bot_disable_ai', false, "Disable bot AI (for debugging)?", 0/*CVAR_ARCHIVE*/);

  CreateCvarBool('bot_ignore_humans', false, "Should bots ignore human players?", 0/*CVAR_ARCHIVE*/);
  CreateCvarBool('bot_developer_messages_roam', false, "Show some bot developer messages?", 0/*CVAR_ARCHIVE*/);
  CreateCvarBool('bot_developer_messages_checkpos', false, "Show some bot developer messages?", 0/*CVAR_ARCHIVE*/);
  CreateCvarBool('bot_developer_messages_items', false, "Show some bot developer messages?", 0/*CVAR_ARCHIVE*/);
  CreateCvarBool('bot_developer_messages_attack', false, "Show some bot developer messages?", 0/*CVAR_ARCHIVE*/);
  CreateCvarBool('bot_developer_messages_path', false, "Show some bot developer messages?", 0/*CVAR_ARCHIVE*/);
  CreateCvarBool('bot_developer_messages_crumbs', false, "Show some bot developer messages?", 0/*CVAR_ARCHIVE*/);
  CreateCvarBool('bot_developer_messages_planpath', false, "Show some bot developer messages?", 0/*CVAR_ARCHIVE*/);

  CreateCvarBool('bot_run_to_subsector_center', true, "Should bots run to subsector center?", 0/*CVAR_ARCHIVE*/);

  CreateCvarBool('bot_no_run', false, "Disable bot running?", 0/*CVAR_ARCHIVE*/);
  CreateCvarBool('bot_no_jump', false, "Disable bot jumping?", 0/*CVAR_ARCHIVE*/);
  CreateCvarBool('bot_always_headshots', false, "Should bot always try do to a headshot?", 0/*CVAR_ARCHIVE*/);


  CreateCvarBool('trans_debug_log', false, "Show translation debug log?", CVAR_ARCHIVE);

  CreateCvarBool('dbg_disable_multiplayer', false, "Disable multiplayer menu?", 0/*CVAR_ARCHIVE*/);

  // gozzo bug workaround
  CreateCvarBool('__gz_afall_drops', false, "Should `A_Fall()` drop items?", CVAR_ARCHIVE);

  // some coop options
  CreateCvarBool('sv_coop_dm_things', false, "Do not spawn DM things in coop (reload level after change)?", CVAR_ARCHIVE);
  CreateCvarBool('sv_coop_share_keys', true, "Share picked up keys betwee all players in coop game?", CVAR_ARCHIVE);
  CreateCvarBool('sv_coop_keep_weapons', true, "Keep weapons on coop reborn?", CVAR_ARCHIVE);

  CreateCvarBool('warn_a_weaponready_recurse', false, "Show warnings if `A_WeaponReady()` called more than once per tic?", CVAR_ARCHIVE);

  foreach (ref auto b; kkWeaponSlotCopy) b = true;

  ::Init(); // parse cvarinfo and such
}


//==========================================================================
//
//  CreateWorldInfo
//
//==========================================================================
override WorldInfo CreateWorldInfo () {
  return WorldInfo(SpawnObject(WorldInfoEx));
}


//==========================================================================
//
//  SetSkill
//
//==========================================================================
void SetSkill (int NewSkill) {
  WorldInfo.SetSkill(NewSkill);
  fastparm = 0;
  int fmon = GetCvar('g_fast_monsters_override');
  if (!fmon) fmon = GetCvar('g_fast_monsters');
  if (fmon) {
    switch (fmon) {
      case 1: fastparm = 1; break;
      case 2: fastparm = 2; break;
    }
  } else {
         if (WorldInfo.bSkillFastMonsters) fastparm = 1;
    else if (WorldInfo.bSkillSlowMonsters) fastparm = 2;
  }
  RespawnTime = WorldInfo.SkillRespawnTime;
  if (!RespawnTime && GetCvar('RespawnMonsters')) RespawnTime = 12.0/35.0;
  int rst = GetCvarI('g_monsters_respawn_override');
       if (rst > 0) RespawnTime = rst;
  else if (rst < 0) RespawnTime = 0;
  //print("*********** skill: %s; fastparm: %s; fmon: %s; respawn=%s", NewSkill, fastparm, fmon, RespawnTime);
}


//==========================================================================
//
//  MakeSlope
//
//==========================================================================
final void MakeSlope (Level InLevel, mthing_t *mthing, bool IsCeiling) {
  TVec v1, v2;
  TVec p1, p2, p3;
  sec_plane_t *plane;

  sector_t *sec = InLevel.PointInSector(vector(mthing->x, mthing->y, 0.0));
  foreach (auto i; 0..sec.lines.length) {
    line_t *line = sec->lines[i];
    if (mthing->tid == line->arg1) {
      if (!IsCeiling) {
        plane = &sec->floor;
        p1 = vector(line->v1->x, line->v1->y, plane->minz);
        p2 = vector(line->v2->x, line->v2->y, plane->minz);
      } else {
        plane = &sec->ceiling;
        p1 = vector(line->v1->x, line->v1->y, plane->maxz);
        p2 = vector(line->v2->x, line->v2->y, plane->maxz);
      }
      p3 = vector(mthing->x, mthing->y, mthing->height);
      if (PointOnPlaneSide(p3, *line) == IsCeiling) {
        v1 = p2-p3;
        v2 = p1-p3;
      } else {
        v1 = p1-p3;
        v2 = p2-p3;
      }
      plane->normal = Normalise(CrossProduct(v1, v2));
           if (!IsCeiling && plane->normal.z <= 0.0) Error("Floor with normal.z <= 0.0");
      else if (IsCeiling && plane->normal.z >= 0.0) Error("Ceiling with normal.z >= 0.0");
      plane->dist = DotProduct(plane->normal, p3);
      return;
    }
  }
}


//===========================================================================
//
//  SlopeLineToPoint
//
//===========================================================================
final void SlopeLineToPoint (Level InLevel, mthing_t *mthing, bool IsCeiling) {
  sec_plane_t *plane;
  TVec p1, p2;
  TVec v1, v2;
  TVec cross;

  sector_t *sec = InLevel.PointInSector(vector(mthing->x, mthing->y, 0.0));
  if (!IsCeiling) {
    plane = &sec->floor;
  } else {
    plane = &sec->ceiling;
  }
  p1 = vector(mthing->x, mthing->y, 0.0);
  p1.z = GetPlanePointZ(ref *plane, p1)+mthing->height;

  foreach (auto i; 0..InLevel.Lines.length) {
    line_t *line = &InLevel.Lines[i];
    if (!IsLineTagEqual(line, mthing->args[1-1])) continue;

    sec = (PointOnPlaneSide(p1, *line) == 0 ? line->frontsector : line->backsector);
    if (sec == nullptr) continue;
    if (!IsCeiling) {
      plane = &sec->floor;
    } else {
      plane = &sec->ceiling;
    }

    p2 = *line->v1;
    p2.z = GetPlanePointZ(ref *plane, p2);
    v1 = (*line->v2)-(*line->v1);
    v1.z = GetPlanePointZ(ref *plane, *line->v2)-p2.z;
    v2 = p1-(*line->v1);
    v2.z = p1.z-p2.z;

    cross = CrossProduct(v1, v2);
    float len = Length(cross);
    if (!len) {
      printwarn("slope thing at (%d,%d) lies directly on its target line.", mthing->x, mthing->y);
      return;
    }
    cross = cross/len;
    // fix backward normals
    if ((cross.z < 0.0 && !IsCeiling) || (cross.z > 0.0 && IsCeiling)) cross = -cross;

    plane->normal = cross;
    plane->dist = DotProduct(plane->normal, p1);
  }
}


//===========================================================================
//
//  SetSlope
//
//===========================================================================
final void SetSlope (Level InLevel, mthing_t *mthing, bool IsCeiling) {
  TVec p1;
  sec_plane_t *plane;
  float xyang;
  float zang;
  TVec norm;

  sector_t *sec = InLevel.PointInSector(vector(mthing->x, mthing->y, 0.0));
  if (!sec) FatalError("point (%f,%f) is not in level", mthing->x, mthing->y);
  if (!IsCeiling) {
    plane = &sec->floor;
    //if (plane.normal.z == 0) FatalError("SetSlope: invalid floor in sector #%d (%v)", calcSecIdx(InLevel, sec), plane.normal);
    //print("SetSlope; sector %d (floor); %s; plane.dist=%f; plane.normal=%v", calcSecIdx(InLevel, sec), plane, plane.dist, plane.normal);
  } else {
    plane = &sec->ceiling;
    //if (plane.normal.z == 0) FatalError("SetSlope: invalid ceiling in sector #%d (%v)", calcSecIdx(InLevel, sec), plane.normal);
    //print("SetSlope; sector %d (ceiling); %s; plane.dist=%f; plane.normal=%v", calcSecIdx(InLevel, sec), plane, plane.dist, plane.normal);
  }
  p1 = vector(mthing->x, mthing->y, 0.0);
  p1.z = GetPlanePointZ(ref *plane, p1)+mthing->height;

       if (mthing->args[1-1] >= 180) zang = 179.0;
  else if (mthing->args[1-1] <= 0) zang = 1.0;
  else zang = float(mthing->args[1-1]);

  if (IsCeiling) zang += 180.0;

  xyang = float(mthing->angle);

  norm.x = cos(zang)*cos(xyang);
  norm.y = cos(zang)*sin(xyang);
  norm.z = sin(zang);
  norm = Normalise(norm);
  plane->normal = norm;
  plane->dist = DotProduct(plane->normal, p1);

  // fix missing top/bottom textures, so there won't be empty cracks
  if (GetCvarB('ldr_fix_slope_cracks')) {
    //int snum = 1;
    foreach (auto lidx, line_t *ln; sec.lines) {
      foreach (int snum; 0..2) {
        if (ln.sidenum[snum] >= 0) {
          side_t *sd = &InLevel.Sides[ln.sidenum[snum]];
          // floor
          if (!IsCeiling && sd.BottomTexture <= 0) {
            //print("F-FUUUUUUUU! (%s:%s) %s", lidx, snum, sec.floor.pic);
            sd.BottomTexture = sec.floor.pic;
          }
          // ceiling
          if (IsCeiling && sd.TopTexture <= 0) {
            //print("C-FUUUUUUUU! (%s:%s) %s", lidx, snum, sec.floor.pic);
            sd.TopTexture = sec.floor.pic;
          }
        }
      }
    }
  }
}


//==========================================================================
//
//  SetVertexHeights
//
//==========================================================================
final bool SetVertexHeights (Level InLevel, int ThingID) {
  bool ret = false;

  // clean all
  foreach (auto i; 0..InLevel.Vertexes.length) InLevel.Vertexes[i].z = 0.1;

  foreach (auto j; 0..InLevel.Things.length) {
    mthing_t *mthing = &InLevel.Things[j];
    if (mthing->type == ThingID) {
      foreach (auto i; 0..InLevel.Vertexes.length) {
        if (InLevel.Vertexes[i].x == mthing->x &&
            InLevel.Vertexes[i].y == mthing->y)
        {
          InLevel.Vertexes[i].z = mthing->height;
          ret = true;
        }
      }
      mthing->type = 0;
    }
  }

  return ret;
}


//==========================================================================
//
//  CleanVertexHeights
//
//==========================================================================
final void CleanVertexHeights (Level InLevel) {
  foreach (auto i; 0..InLevel.Vertexes.length) InLevel.Vertexes[i].z = 0.0;
}


//==========================================================================
//
//  MakeVertexFloorHeights
//
//==========================================================================
final void MakeVertexFloorHeights (Level InLevel) {
  TVec p1, p2, p3;
  TVec v1, v2;

  if (!SetVertexHeights(InLevel, FLOOR_VERTEX_HEIGHT_TYPE)) return;

  foreach (auto i; 0..InLevel.Sectors.length) {
    sector_t *sec = &InLevel.Sectors[i];
    if (sec.lines.length != 3) continue;
    p1 = *sec->lines[0]->v1;
    p2 = *sec->lines[0]->v2;
    if (sec->lines[1]->v1 == sec->lines[0]->v1 ||
        sec->lines[1]->v1 == sec->lines[0]->v2)
    {
      p3 = *sec->lines[1]->v2;
    } else {
      p3 = *sec->lines[1]->v1;
    }
    if (p1.z == 0.1 && p2.z == 0.1 && p3.z == 0.1) continue;
    if (p1.z == 0.1) p1.z = sec->floor.TexZ;
    if (p2.z == 0.1) p2.z = sec->floor.TexZ;
    if (p3.z == 0.1) p3.z = sec->floor.TexZ;
    if (PointOnPlaneSide(p3, *sec->lines[0]) == 0) {
      v1 = p2-p3;
      v2 = p1-p3;
    } else {
      v1 = p1-p3;
      v2 = p2-p3;
    }
    sec->floor.normal = Normalise(CrossProduct(v1, v2));
    if (sec->floor.normal.z <= 0.0) Error("Floor with normal.z <= 0.0");
    sec->floor.dist = DotProduct(sec->floor.normal, p3);
  }
}


//==========================================================================
//
//  MakeVertexCeilingHeights
//
//==========================================================================
final void MakeVertexCeilingHeights (Level InLevel) {
  TVec p1, p2, p3;
  TVec v1, v2;

  if (!SetVertexHeights(InLevel, CEILING_VERTEX_HEIGHT_TYPE)) return;

  foreach (auto i; 0..InLevel.Sectors.length) {
    sector_t *sec = &InLevel.Sectors[i];
    if (sec.lines.length != 3) continue;
    p1 = *sec->lines[0]->v1;
    p2 = *sec->lines[0]->v2;
    if (sec->lines[1]->v1 == sec->lines[0]->v1 ||
        sec->lines[1]->v1 == sec->lines[0]->v2)
    {
      p3 = *sec->lines[1]->v2;
    } else {
      p3 = *sec->lines[1]->v1;
    }
    if (p1.z == 0.1 && p2.z == 0.1 && p3.z == 0.1) continue;
    if (p1.z == 0.1) p1.z = sec->ceiling.TexZ;
    if (p2.z == 0.1) p2.z = sec->ceiling.TexZ;
    if (p3.z == 0.1) p3.z = sec->ceiling.TexZ;
    if (PointOnPlaneSide(p3, *sec->lines[0]) == 0) {
      v1 = p1-p3;
      v2 = p2-p3;
    } else {
      v1 = p2-p3;
      v2 = p1-p3;
    }
    sec->ceiling.normal = Normalise(CrossProduct(v1, v2));
    if (sec->ceiling.normal.z >= 0.0) Error("Ceiling with normal.z >= 0.0");
    sec->ceiling.dist = DotProduct(sec->ceiling.normal, p3);
  }
}


//==========================================================================
//
//  AlignPlane
//
//  Set slopes for sectors, based on line specials
//
//  Aligns the floor or ceiling of a sector to the corresponding plane
//  on the other side of the reference line. (By definition, line must be
//  two-sided.)
//
//  If which == 0, sets floor.
//  If which == 1, sets ceiling.
//
//==========================================================================
final void AlignPlane (Level InLevel, sector_t *sec, line_t *line, int which, int lineidx) {
  if (line->backsector == nullptr) return;

  // find furthest vertex from the reference line
  // it, along with the two ends of the line will define the plane
  TVec *refvert = sec.lines[0].v1;
  float bestdist = -1;
  foreach (auto i; 0..sec.lines.length) {
    foreach (auto vidx; 0..2) {
      TVec *vert = (!vidx ? sec.lines[i].v1 : sec.lines[i].v2);
      float dist = fabs(DotProduct(*vert, line.normal)-line.dist);
      //TVec dir = (*line->v2)-(*line->v1);
      //float dist = fabs((line.v1.y-vert.y)*dir.x-(line.v1.x-vert.x)*dir.y);
      if (dist > bestdist) { bestdist = dist; refvert = vert; }
    }
  }

  sector_t *refsec = (line.frontsector == sec ? line.backsector : line.frontsector);

  sec_plane_t *srcplane = (which == 0 ? &sec.floor : &sec.ceiling);
  float srcheight = (which == 0 ? sec.floor.TexZ : sec.ceiling.TexZ);
  float destheight = (which == 0 ? refsec.floor.TexZ : refsec.ceiling.TexZ);

  TVec p = *line.v1;
  p.z = destheight;

  TVec v1 = (*line.v2)-(*line.v1);
  v1.z = 0;

  TVec v2 = (*refvert)-(*line.v1);
  v2.z = srcheight-destheight;

  TVec cross = Normalise(CrossProduct(v1, v2));

  // fix backward normals
  if ((which == 0 && cross.z < 0) || (which == 1 && cross.z > 0)) cross = -cross;

  srcplane.normal = cross;
  srcplane.dist = DotProduct(cross, p);

  // fix missing top/bottom textures, so there won't be empty cracks
  if (GetCvarB('ldr_fix_slope_cracks')) {
    //int snum = (line.frontsector == sec ? 0 : 1);
    //int snum = 1;
    foreach (auto lidx, line_t *ln; sec.lines) {
      foreach (int snum; 0..2) {
        if (ln.sidenum[snum] >= 0) {
          side_t *sd = &InLevel.Sides[ln.sidenum[snum]];
          // floor
          if (which == 0 && sd.BottomTexture <= 0) {
            //print("F-FUUUUUUUU! (%s:%s) %s", lidx, snum, sec.floor.pic);
            sd.BottomTexture = sec.floor.pic;
          }
          // ceiling
          if (which != 0 && sd.TopTexture <= 0) {
            //print("C-FUUUUUUUU! (%s:%s) %s", lidx, snum, sec.floor.pic);
            sd.TopTexture = sec.floor.pic;
          }
        }
      }
    }
  }
}


//==========================================================================
//
//  SetSlopes
//
//==========================================================================
final void SetSlopes (Level InLevel) {
  foreach (auto i; 0..InLevel.Lines.length) {
    line_t *line = &InLevel.Lines[i];
    if (line.special == LNSPEC_PlaneAlign) {
      line.special = 0;
      line.lineTag = InLevel.Lines[i].arg3;
      if (line.backsector) {
        // args[0] is for floor, args[1] is for ceiling
        //
        // As a special case, if args[1] is 0,
        // then args[0], bits 2-3 are for ceiling.
        foreach (auto s; 0..2) {
          int bits = (s == 0 ? line.arg1 : line.arg2)&3;
          //if (s == 1 && bits == 0) bits = (InLevel.Lines[i].arg1 >> 2) & 3;
          if (s == 1 && !line.arg2) bits = (line.arg1>>2)&3;
          switch (bits) {
            case 1: // align front side to back
              AlignPlane(InLevel, line.frontsector, line, s, i);
              break;
            case 2:
              // align back side to front
              AlignPlane(InLevel, line.backsector, line, s, i);
              break;
          }
        }
      }
    }
  }
}


//==========================================================================
//
//  ProcessCopySlopes
//
//==========================================================================
final void ProcessCopySlopes (Level InLevel) {
  foreach (auto i; 0..InLevel.Lines.length) {
    line_t *line = &InLevel.Lines[i];
    if (line.special == LNSPEC_PlaneCopy) {
      line.special = 0;
      CopyPlaneBetweenTaggedSectors(InLevel, line.frontsector, line.arg1, IsCeiling:false); // front floor
      CopyPlaneBetweenTaggedSectors(InLevel, line.frontsector, line.arg2, IsCeiling:true); // front ceiling
      CopyPlaneBetweenTaggedSectors(InLevel, line.backsector, line.arg3, IsCeiling:false); // back floor
      CopyPlaneBetweenTaggedSectors(InLevel, line.backsector, line.arg4, IsCeiling:true); // back ceiling
      // share
      int share = line.arg5&3;
      if (share && share != 3) {
        if (share&1) CopyPlaneBetweenSectors(InLevel, line.backsector, line.frontsector, IsCeiling:false); // front floor to back floor
        if (share&2) CopyPlaneBetweenSectors(InLevel, line.frontsector, line.backsector, IsCeiling:false); // back floor to front floor
      }
      share = (line.arg5>>2)&3;
      if (share && share != 3) {
        if (share&1) CopyPlaneBetweenSectors(InLevel, line.backsector, line.frontsector, IsCeiling:true); // front ceiling to back ceiling
        if (share&2) CopyPlaneBetweenSectors(InLevel, line.frontsector, line.backsector, IsCeiling:true); // back ceiling to front ceiling
      }
    }
  }
}


//===========================================================================
//
//  CopyPlaneBetweenSectors
//
//===========================================================================
final void CopyPlaneBetweenSectors (Level InLevel, sector_t *dst, sector_t *src, bool IsCeiling) {
  if (!src || !dst || src == dst) return; // just in case
  if (!IsCeiling) {
    dst->floor.normal = src->floor.normal;
    dst->floor.dist = src->floor.dist;
  } else {
    dst->ceiling.normal = src->ceiling.normal;
    dst->ceiling.dist = src->ceiling.dist;
  }
}


//===========================================================================
//
//  CopyPlaneBetweenTaggedSectors
//
//===========================================================================
final void CopyPlaneBetweenTaggedSectors (Level InLevel, sector_t *dst, int srctag, bool IsCeiling) {
  if (srctag <= 0 || !dst) return; // just in case
  sector_t *sector;
  if (InLevel.FindSectorFromTag(out sector, srctag) < 0) return; // no source sector
  CopyPlaneBetweenSectors(InLevel, sector, dst, IsCeiling);
}


//===========================================================================
//
//  CopyPlaneWithThing
//
//===========================================================================
final void CopyPlaneWithThing (Level InLevel, mthing_t *mthing, bool IsCeiling) {
  sector_t *dst = InLevel.PointInSector(vector(mthing->x, mthing->y, 0.0));
  sector_t *src;
  if (InLevel.FindSectorFromTag(out src, mthing->args[1-1]) < 0) return; // no source sector
  if (!IsCeiling) {
    dst->floor.normal = src->floor.normal;
    dst->floor.dist = src->floor.dist;
  } else {
    dst->ceiling.normal = src->ceiling.normal;
    dst->ceiling.dist = src->ceiling.dist;
  }
}


//==========================================================================
//
//  SpawnExtraFloors
//
//==========================================================================
final void SpawnExtraFloors (Level InLevel, line_t *line) {
  int tag = line->arg1+(line->arg1&8 ? 0 : line->arg5);
  foreach (auto j; 0..InLevel.Sectors.length) {
    if (IsSectorTagEqual(&InLevel.Sectors[j], tag)) {
      InLevel.AddExtraFloor(line, &InLevel.Sectors[j]);
    }
  }
}


//==========================================================================
//
//  MakeWaterContents
//
//==========================================================================
final void MakeWaterContents (Level InLevel, line_t *line) {
  int contents = CONTENTS_WATER;
  sector_t *sec = line->frontsector;
  sec.params.contents = contents;
  sec.floor.Alpha = contents_alpha[contents];
  sec.ceiling.Alpha = contents_alpha[contents];
  sec.ceiling.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
  sec.floor.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
}


//==========================================================================
//
//  MakeSolidContents
//
//==========================================================================
final void MakeSolidContents (Level InLevel, line_t *line) {
  int contents = CONTENTS_EMPTY;
  sector_t *sec = line->frontsector;
  sec.params.contents = contents;
  sec.floor.Alpha = contents_alpha[contents];
  sec.ceiling.Alpha = contents_alpha[contents];
  //sec.ceiling.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
  //sec.floor.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
}


//==========================================================================
//
//  MakeNonSolidContents
//
//==========================================================================
final void MakeNonSolidContents (Level InLevel, line_t *line) {
  int contents = CONTENTS_EMPTY;
  sector_t *sec = line->frontsector;
  sec.params.contents = contents;
  sec.floor.Alpha = contents_alpha[contents];
  sec.ceiling.Alpha = contents_alpha[contents];
  sec.ceiling.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
  sec.floor.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
}


//==========================================================================
//
//  MakeContents
//
//==========================================================================
final void MakeContents (line_t *line) {
  if (!line->arg1 && !line->arg2 && !line->arg3) {
    //MakeWaterContents(line);
    int contents = CONTENTS_WATER;
    sector_t *sec = line->frontsector;
    sec.params.contents = contents;
    if (sec.floor.dist == -sec.ceiling.dist) {
      sec.floor.Alpha = contents_alpha[contents];
      sec.ceiling.Alpha = contents_alpha[contents];
      sec.ceiling.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
      sec.floor.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
    }
  } else {
    sector_t *sec = line->frontsector;
    sec.params.contents = line->arg1;

    sec.floor.Alpha = (100.0-float(line->arg2))/100.0;
    sec.ceiling.Alpha = (100.0-float(line->arg2))/100.0;

    sec.ceiling.flags = line->arg3;
    sec.floor.flags = line->arg3;
  }
}


//==========================================================================
//
//  MakeHeightSec
//
//  killough 3/7/98:
//  support for drawn heights coming from different sector
//
//==========================================================================
void MakeHeightSec (Level InLevel, line_t *line) {
  sector_t *sec = line->frontsector;
  sec.bTransferSource = true;
  //if (line->arg2&1) sec.bAlwaysFakeHeights = true;//TODO
  if (line->arg2&2) sec.bFakeFloorOnly = true;
  if (line->arg2&4) sec.bClipFakePlanes = true;
  if (line->arg2&8) sec.bUnderWater = true;
  if (line->arg2&16) sec.bIgnoreHeightSec = true;
  if (line->arg2&32) sec.bNoFakeLight = true;
  sector_t *ss2;
  for (int hidx = InLevel.FindSectorFromTag(out ss2, line->arg1); hidx >= 0; hidx = InLevel.FindSectorFromTag(out ss2, line->arg1, hidx)) {
    //ss2.heightsec = sec; // done in `SetHeightSector`
    InLevel.SetHeightSector(ss2, sec, line->arg2);
  }
}


//==========================================================================
//
//  SetSectorFriction
//
//==========================================================================
void SetSectorFriction (Level InLevel, int tag, int amount, bool alterFlag) {
  int OldMoveFactor;

  // an amount of 100 should result in a friction of ORIG_FRICTION (0xE800)
  int OldFriction = (0x1EB8*amount)/0x80+0xD001;

  // killough 8/28/98: prevent odd situations
  if (OldFriction > 0x10000) OldFriction = 0x10000;
  if (OldFriction < 0) OldFriction = 0;

  // the following check might seem odd. At the time of movement,
  // the move distance is multiplied by 'friction/0x10000', so a
  // higher friction value actually means 'less friction'

  // [RH] Twiddled these values so that momentum on ice (with
  //    friction 0xf900) is the same as in Heretic/Hexen
  if (OldFriction >= 0xe800) {
    // ice
    //movefactor = ((0x10092-friction)*(0x70))/0x158;
    OldMoveFactor = ((0x10092-OldFriction)*1024)/4352+568;
  } else {
    OldMoveFactor = ((OldFriction-0xDB34)*(0xA))/0x80;
  }

  // killough 8/28/98: prevent odd situations
  if (OldMoveFactor < 32) OldMoveFactor = 32;

  float Friction = (1.0-float(OldFriction)/float(0x10000))*35.0;
  float MoveFactor = float(OldMoveFactor)/float(0x10000);

  sector_t *fricsec;
  for (int hidx = InLevel.FindSectorFromTag(out fricsec, tag); hidx >= 0; hidx = InLevel.FindSectorFromTag(out fricsec, tag, hidx)) {
    // killough 8/28/98:
    //
    // Instead of spawning thinkers, which are slow and expensive,
    // modify the sector's own friction values. Friction should be
    // a property of sectors, not objects which reside inside them.
    // Original code scanned every object in every friction sector
    // on every tic, adjusting its friction, putting unnecessary
    // drag on CPU. New code adjusts friction of sector only once
    // at level startup, and then uses this friction value.

    fricsec.Friction = Friction;
    fricsec.MoveFactor = MoveFactor;
    if (alterFlag) {
      // when used inside a script, the sectors' friction flags can be enabled and disabled at will
      if (OldFriction == 0xe800) {
        fricsec.special &= ~SECSPEC_FRICTION_MASK;
      } else {
        fricsec.special |= SECSPEC_FRICTION_MASK;
      }
    }
  }
}


//==========================================================================
//
//  StaticInit
//
//==========================================================================
void StaticInit (Level InLevel, line_t *line) {
  float Grav;
  int Dmg;
  sector_t *sec;

  //if (!line->arg1) return; // zero sector tag sux -- nope, Boom maps are actively using this
  switch (line->arg2) {
    case 0:
      Grav = Length((*line->v2)-(*line->v1))/100.0;
      for (int hidx = InLevel.FindSectorFromTag(out sec, line->arg1); hidx >= 0; hidx = InLevel.FindSectorFromTag(out sec, line->arg1, hidx)) {
        sec.Gravity = Grav;
      }
      break;
    /* this is processed in level setup
    case 1:
      // sets the light or fog color in a sector
      // an RRGGBB hex format color used as an upper texture name will set the light color; a lower texture will set the fog color
      print("StaticInit(1): upper=%s; lower=%s", InLevel.Sides[line.sidenum[0]].TopTexture, InLevel.Sides[line.sidenum[0]].BottomTexture);
      for (int hidx = InLevel.FindSectorFromTag(out sec, line->arg1); hidx >= 0; hidx = InLevel.FindSectorFromTag(out sec, line->arg1, hidx)) {
      }
      break;
    */
    case 2:
      Dmg = int(Length((*line->v2)-(*line->v1)));
      for (int hidx = InLevel.FindSectorFromTag(out sec, line->arg1); hidx >= 0; hidx = InLevel.FindSectorFromTag(out sec, line->arg1, hidx)) {
        sec.Damage = Dmg;
        sec.DamageType = ''; // default
        sec.DamageInterval = 0;
        sec.DamageLeaky = 0;
      }
      break;
    //case 3: // defines a sector link with line IDs instead of tags, as in Eternity
    case 255:
      // uses the line's upper texture as the sky in any tagged sectors (that is, the sky flat
      // will be replaced with that texture instead of the sky indicated in MAPINFO).
      // if flip is set to 1, the texture will be flipped, as is normal behavior for Doom skies.
      // offsets and scrolling of the texture are transferred to the sky as well.
      // scrolling, however, is only at a tiny fraction of the wall texture's scrolling speed.
      // this corresponds to the MBF sky transfer linetypes (271 and 272).
      // Note: the line's lower texture, if set and of the same dimensions as the upper texture, will be used during lightning flashes.
      //printdebug("::: SKYTRANSFER: texid=%s (%s); tag=%s", line->sidenum[0], GetTextureName(InLevel.Sides[line->sidenum[0]].TopTexture), line->arg1);
      for (int hidx = InLevel.FindSectorFromTag(out sec, line->arg1); hidx >= 0; hidx = InLevel.FindSectorFromTag(out sec, line->arg1, hidx)) {
        //sec.Sky = (line->sidenum[0]+1)|SKY_FROM_SIDE;
        int snum = line->sidenum[0];
        if (snum >= 0 && snum < InLevel.Sides.length) {
          //printdebug("::: SKYTRANSFER: %s (%s), sector %s", line->sidenum[0], GetTextureName(InLevel.Sides[line->sidenum[0]].TopTexture), sec-&InLevel.Sectors[0]);
          //sec.Sky = (InLevel.Sides[snum].TopTexture)|SKY_FROM_SIDE;
          sec.Sky = (line->sidenum[0]+1)|SKY_FROM_SIDE;
        }
      }
      break;
  }
}


//==========================================================================
//
//  SpawnWorld
//
//==========================================================================
override void SpawnWorld (Level InLevel) {
  int length;
  //int SecNum;
  float alpha;

  // set up tagged lines
  if (!InLevel.bTextMap) {
    foreach (auto i; 0..InLevel.Lines.length) {
      line_t *line = &InLevel.Lines[i];
      switch (line->special) {
        case LNSPEC_LineSetIdentification:
          line->special = 0;
          line->lineTag = line->arg1+(line->arg5<<8);
          line->flags |= line->arg2<<16;
          break;
        case LNSPEC_LineTranslucent:
          line->lineTag = line->arg1;
          line->flags |= line->arg4<<16;
          break;
        case LNSPEC_TeleportLine:
        case LNSPEC_ScrollTextureModel:
          line->lineTag = line->arg1;
          break;
        case LNSPEC_PolyStartLine:
          line->lineTag = line->arg4;
          break;
        case LNSPEC_PolyExplicitLine:
          line->lineTag = line->arg5;
          break;
        case LNSPEC_StaticInit:
          if (line->arg2 == 3) line->lineTag = line->arg1;
          break;
      }
    }
  }

  // spawn slopes
  SetSlopes(InLevel);

  // order:
  //  pass:
  //   FLOOR_SLOPE_TYPE
  //   CEILING_SLOPE_TYPE
  //   SLOPE_FLOOR_POINT_LINE_TYPE
  //   SLOPE_CEILING_POINT_LINE_TYPE
  //   SET_FLOOR_SLOPE_TYPE
  //   SET_CEILING_SLOPE_TYPE
  //  pass:
  //   COPY_FLOOR_PLANE_TYPE
  //   COPY_CEILING_PLANE_TYPE
  //  pass:
  //   FLOOR_VERTEX_HEIGHT_TYPE
  //   CEILING_VERTEX_HEIGHT_TYPE

  foreach (auto i; 0..InLevel.Things.length) {
    mthing_t *mthing = &InLevel.Things[i];
    switch (mthing->type) {
      case FLOOR_SLOPE_TYPE:
        //print("SLOPE: FLOOR_SLOPE_TYPE");
        MakeSlope(InLevel, mthing, false);
        mthing->type = 0;
        break;
      case CEILING_SLOPE_TYPE:
        //print("SLOPE: CEILING_SLOPE_TYPE");
        MakeSlope(InLevel, mthing, true);
        mthing->type = 0;
        break;
      case SLOPE_FLOOR_POINT_LINE_TYPE:
        //print("SLOPE: SLOPE_FLOOR_POINT_LINE_TYPE");
        SlopeLineToPoint(InLevel, mthing, false);
        mthing->type = 0;
        break;
      case SLOPE_CEILING_POINT_LINE_TYPE:
        //print("SLOPE: SLOPE_CEILING_POINT_LINE_TYPE");
        SlopeLineToPoint(InLevel, mthing, true);
        mthing->type = 0;
        break;
      case SET_FLOOR_SLOPE_TYPE:
        //print("SLOPE: SET_FLOOR_SLOPE_TYPE");
        SetSlope(InLevel, mthing, false);
        mthing->type = 0;
        break;
      case SET_CEILING_SLOPE_TYPE:
        //print("SLOPE: SET_CEILING_SLOPE_TYPE");
        SetSlope(InLevel, mthing, true);
        mthing->type = 0;
        break;
      }
  }

  foreach (auto i; 0..InLevel.Things.length) {
    mthing_t *mthing = &InLevel.Things[i];
    if (mthing->type == COPY_FLOOR_PLANE_TYPE ||
        mthing->type == COPY_CEILING_PLANE_TYPE)
    {
      CopyPlaneWithThing(InLevel, mthing, mthing->type&1);
      mthing->type = 0;
    }
  }

  MakeVertexFloorHeights(InLevel);
  MakeVertexCeilingHeights(InLevel);
  CleanVertexHeights(InLevel);

  ProcessCopySlopes(InLevel);

  // set up 3D floors, transfers of light, etc.
  foreach (auto i; 0..InLevel.Lines.length) {
    line_t *line = &InLevel.Lines[i];
    switch (line->special) {
      // Sector_Set3dFloor(tag, type, flags, alpha, hi-tag/line ID)
      case LNSPEC_SectorSet3dFloor:
        //print("********************** %s", line->oplist.length);
        //if (line->arg2) print("*** 3D FLOOR OF TYPE %s (tag=%s; flags=0x%04x; alpha=%s; hitag=%s)", line->arg2, line->arg1, line->arg3, line->arg4, line->arg5);
        switch (line->arg2&3) {
          case 1:
            //print("SOLID FLOOR!");
            MakeSolidContents(InLevel, line);
            break;
          case 2:
            //print("SWIMMABLE FLOOR!");
            MakeWaterContents(InLevel, line);
            break;
          case 3:
            //print("NON-SOLID FLOOR!");
            MakeNonSolidContents(InLevel, line);
            break;
        }
        // flags
        if (line->arg2 != 0) {
          sector_t *sec = line->frontsector;
          // invert sight?
          if (line->arg2&16) {
            sec.ceiling.flags ^= SPF_NOBLOCKSIGHT;
            sec.floor.flags ^= SPF_NOBLOCKSIGHT;
          }
          // invert shootability?
          if (line->arg2&32) {
            sec.ceiling.flags ^= SPF_NOBLOCKSHOOT;
            sec.floor.flags ^= SPF_NOBLOCKSHOOT;
          }
          // set line tag
          if (line->arg2&8) line->lineTag = line->arg5;
          if (line->arg4 < 255) {
            float secalpha = clamp(line->arg4, 0, 255)/255.0;
            sec.floor.Alpha = secalpha;
            sec.ceiling.Alpha = secalpha;
          }
        }
        SpawnExtraFloors(InLevel, line);
        line->special = 0;
        break;
      case LNSPEC_Contents:
        MakeContents(line);
        line->special = 0;
        break;
      case LNSPEC_TransferFloorLight:
        {
          sector_t *sec;
          for (int hidx = InLevel.FindSectorFromTag(out sec, line->arg1);
               hidx >= 0;
               hidx = InLevel.FindSectorFromTag(out sec, line->arg1, hidx))
          {
            InLevel.SetFloorLightSector(sec, line->frontsector);
          }
        }
        line->special = 0;
        line->frontsector->bTransferSource = true;
        break;
      case LNSPEC_TransferCeilingLight:
        {
          sector_t *sec;
          for (int hidx = InLevel.FindSectorFromTag(out sec, line->arg1);
               hidx >= 0;
               hidx = InLevel.FindSectorFromTag(out sec, line->arg1, hidx))
          {
            InLevel.SetCeilingLightSector(sec, line->frontsector);
          }
        }
        line->special = 0;
        line->frontsector->bTransferSource = true;
        break;
      case LNSPEC_SectorSetFriction:
        if (line->arg2) {
          // allow setting friction amount from parameter
          length = line->arg2 <= 200 ? line->arg2 : 200;
        } else {
          length = int(Length((*line->v2)-(*line->v1)));
        }
        SetSectorFriction(InLevel, line->arg1, length, false);
        line->special = 0;
        break;
      case LNSPEC_TransferHeights:
        //if (line->arg2) print("transferheights: flags=0x%02x", line->arg2);
        MakeHeightSec(InLevel, line);
        line->special = 0;
        break;
      case LNSPEC_StaticInit:
        StaticInit(InLevel, line);
        line->special = 0;
        break;
    }
  }

  // initialise initial friction values
  foreach (auto i; 0..InLevel.Sectors.length) {
    InLevel.Sectors[i].Friction = EntityEx::FRICTION_NORMAL;
    // handle Sky2 sector special
    if (InLevel.Sectors[i].special == SECSPEC_Sky2) {
      InLevel.Sectors[i].Sky = SKY_FROM_SIDE;
    }
  }

  // process translucent lines
  foreach (auto i; 0..InLevel.Lines.length) {
    line_t *line = &InLevel.Lines[i];
    switch (line->special) {
      case LNSPEC_LineTranslucent:
        alpha = fclamp(float(line->arg2)/255.0, 0, 255);
        if (line->arg1) {
          foreach (auto j; 0..InLevel.Lines.length) {
            if (IsLineTagEqual(&InLevel.Lines[j], line->arg1)) {
              InLevel.Lines[j].alpha = alpha;
              if (line->arg3 == 1) InLevel.Lines[j].flags |= ML_ADDITIVE;
            }
          }
        } else {
          line->alpha = alpha;
          if (line->arg3 == 1) line->flags |= ML_ADDITIVE;
        }
        line->special = 0;
        break;
      case LNSPEC_GlassBreak:
        if (line->arg2 != 255) line->alpha = fclamp(float(line->arg2)/255.0, 0, 255);
        break;
    }
  }

  // spawn polyobjects
  foreach (auto i; 0..InLevel.Things.length) {
    mthing_t *mthing = &InLevel.Things[i];
    switch (mthing->type) {
      case PO_SPAWN_TYPE_HEXEN:
      case PO_SPAWNCRUSH_TYPE_HEXEN:
        if (!bUseHexenPolyobjTypes) break;
        goto case; //k8: is it right???
      case PO_SPAWN_TYPE:
      case PO_SPAWNCRUSH_TYPE:
      case PO_SPAWNHURT_TYPE:
        // Polyobj StartSpot Pt.
        InLevel.SpawnPolyobj(mthing->x, mthing->y, int(mthing->angle),
          mthing->type == PO_SPAWNCRUSH_TYPE_HEXEN ||
          mthing->type == PO_SPAWNCRUSH_TYPE ||
          mthing->type == PO_SPAWNHURT_TYPE,
          mthing->type == PO_SPAWNHURT_TYPE);
        mthing->type = 0;
        break;
      case PO_ANCHOR_TYPE_HEXEN:
        if (!bUseHexenPolyobjTypes) break;
        goto case; //k8: is it right???
      case PO_ANCHOR_TYPE:
        // Polyobj Anchor Pt.
        InLevel.AddPolyAnchorPoint(mthing->x, mthing->y, int(mthing->angle));
        mthing->type = 0;
        break;
    }
  }
}


//==========================================================================
//
//  GetDefaultWeaponSlotCount
//
//==========================================================================
final int GetDefaultWeaponSlotCount () {
  // slot 0 is unused
  return MaxWeaponSlots;
}


//==========================================================================
//
//  GetDefaultMaxWeaponsInSlot
//
//==========================================================================
final int GetDefaultMaxWeaponsInSlot (int slot) {
  return MaxWeaponsInSlot;
}


//==========================================================================
//
//  GetDefaultWeaponInSlot
//
//==========================================================================
final class!Weapon GetDefaultWeaponInSlot (int slot, int index) {
  ++slot;
  if (slot < 1 || slot > MaxWeaponSlots) return none;
  if (index < 0 || index >= MaxWeaponsInSlot) return none;
  return WeaponSlots[slot].Weapons[index];
}


//==========================================================================
//
//  KeyconfPrepareSlot
//
//==========================================================================
private final void KeyconfPrepareSlot (int slot, WSlotSrc src) {
  if (slot < 0 || slot >= kkWeaponSlotCopy.length) return;
  if (!kkWeaponSlotCopy[slot]) return;
  kkWeaponSlotCopy[slot] = false;
  if (kkWeaponSlots[slot].weapons.length) {
    printwarn("*** AddSlotDefault: internal error!");
    kkWeaponSlots[slot].weapons.clear();
  }
  foreach (auto widx; 0..MaxWeaponsInSlot) {
    class!Weapon wcls = WeaponSlots[slot].Weapons[widx];
    if (wcls) {
      class!Weapon repl = class!Weapon(GetClassReplacement(wcls));
      if (repl) wcls = repl;
    }
    auto wi = kkWeaponSlots[slot].weapons.alloc();
    wi.wcls = wcls;
    wi.src = src;
  }
}


//==========================================================================
//
//  AddKeyconfCompactSlots
//
//==========================================================================
private final void AddKeyconfCompactSlots () {
  foreach (int sidx; 0..kkWeaponSlots.length) {
    int dest = 0;
    foreach (int widx; 0..kkWeaponSlots[sidx].weapons.length) {
      class!Weapon swc = kkWeaponSlots[sidx].weapons[widx].wcls;
      if (swc) {
        if (widx != dest) kkWeaponSlots[sidx].weapons[dest] = kkWeaponSlots[sidx].weapons[widx];
        ++dest;
      }
    }
    kkWeaponSlots[sidx].weapons.length = dest;
  }
}


//==========================================================================
//
//  AddKeyconfWeaponToSlot
//
//==========================================================================
private final bool AddKeyconfWeaponToSlot (int Slot, class!Weapon wcls, WSlotSrc src) {
  if (!wcls) return false;
  --Slot;
  if (Slot < 0 || Slot >= kkWeaponSlots.length) return false;

  // remove from all slots
  foreach (int sidx; 0..kkWeaponSlots.length) {
    foreach (ref auto wi; kkWeaponSlots[sidx].weapons) {
      if (wi.wcls == wcls) wi.wcls = none;
    }
  }
  AddKeyconfCompactSlots(); // compact slots

  // add
  auto wi = kkWeaponSlots[Slot].weapons.alloc();
  wi.wcls = wcls;
  wi.src = src;
  return true;
}


//==========================================================================
//
//  CmdWeaponSection
//
//==========================================================================
override void CmdWeaponSection (string Section) {
  if (!Section) {
    print("Usage: WeaponSection <section name>");
    return;
  }
  // unused right now
}


//==========================================================================
//
//  CmdSetSlot
//
//==========================================================================
override void CmdSetSlot (ref array!string Args, bool asKeyconf) {
  if (Args.length < 2) {
    print("Usage: SetSlot <slot> <weapon> ...");
    return;
  }

  // get slot number
  bool err;
  int Slot = atoi(Args[1], out err);
  if (err || Slot < 0 || Slot > MaxWeaponSlots) {
    printwarn("Bad weapon slot number '%s'", Args[1]);
    return;
  }

  // slot '0' means '10'
  if (Slot == 0) Slot = 10;

  // clear slot
  kkWeaponSlots[Slot-1].weapons.clear();
  kkWeaponSlotCopy[Slot-1] = false;

  if (Args.length == 2) {
    print("Slot %s cleared", Slot);
  } else {
    foreach (auto i; 2..Args.length) {
      // standardize class name here, since I've found people writing in all types of mixed cases...
      class!Weapon Cls = class!Weapon(FindClassNoCaseStr(Args[i]));
      if (!Cls) {
        printwarn("`%s` is not a weapon", Args[i]);
      } else {
        if (!AddKeyconfWeaponToSlot(Slot, Cls, (asKeyconf ? WSlotSrc.KEYCONF : WSlotSrc.GAMEINFO))) {
          printwarn("Couldn't add `%s` to slot `%s`", Args[i], Slot);
        }
      }
    }
  }
}


//==========================================================================
//
//  CmdAddSlotDefault
//
//==========================================================================
override void CmdAddSlotDefault (ref array!string Args, bool asKeyconf) {
  if (Args.length != 3) {
    print("Usage: AddSlotDefault <slot> <weapon>");
    return;
  }

  // get slot number
  bool err;
  int Slot = atoi(Args[1], out err);
  if (err || Slot < 0 || Slot > MaxWeaponSlots) {
    printwarn("Bad weapon slot number '%s'", Args[1]);
    return;
  }

  // slot '0' means '10'
  if (Slot == 0) Slot = 10;

  // standardize class name here, since I've found people writing in all types of mixed cases...
  class!Weapon Cls = class!Weapon(FindClassNoCaseStr(Args[2]));
  if (!Cls) {
    printwarn("`%s` is not a weapon", Args[2]);
    return;
  }

  KeyconfPrepareSlot(Slot-1, (asKeyconf ? WSlotSrc.KEYCONF : WSlotSrc.GAMEINFO));
  if (!AddKeyconfWeaponToSlot(Slot, Cls, (asKeyconf ? WSlotSrc.KEYCONF : WSlotSrc.GAMEINFO))) {
    printwarn("Couldn't add `%s` to slot `%s`", Args[2], Slot);
  }
}


defaultproperties {
  contents_alpha[CONTENTS_EMPTY] = 1.0;
  contents_alpha[CONTENTS_WATER] = 0.5;
  contents_alpha[CONTENTS_LAVA] = 0.8;
  contents_alpha[CONTENTS_NUKAGE] = 0.6;
  contents_alpha[CONTENTS_SLIME] = 0.55;
  contents_alpha[CONTENTS_HELLSLIME] = 0.7;
  contents_alpha[CONTENTS_BLOOD] = 0.85;
  contents_alpha[CONTENTS_SLUDGE] = 0.7;
  contents_alpha[CONTENTS_HAZARD] = 0.7;


  windTab[0] =  5.0/32.0;
  windTab[1] = 10.0/32.0;
  windTab[2] = 25.0/32.0;

  pushTab[0] =  5.0*35.0*35.0/32.0;
  pushTab[1] = 10.0*35.0*35.0/32.0;
  pushTab[2] = 25.0*35.0*35.0/32.0;
  pushTab[3] = 30.0*35.0*35.0/32.0;
  pushTab[4] = 35.0*35.0*35.0/32.0;

  opposite[0] = DI_WEST;
  opposite[1] = DI_SOUTHWEST;
  opposite[2] = DI_SOUTH;
  opposite[3] = DI_SOUTHEAST;
  opposite[4] = DI_EAST;
  opposite[5] = DI_NORTHEAST;
  opposite[6] = DI_NORTH;
  opposite[7] = DI_NORTHWEST;
  opposite[8] = DI_NODIR;

  diags[0] = DI_NORTHWEST;
  diags[1] = DI_NORTHEAST;
  diags[2] = DI_SOUTHWEST;
  diags[3] = DI_SOUTHEAST;

  xspeed[0] = 1.0;
  xspeed[1] = 0.7171630859;
  xspeed[2] = 0.0;
  xspeed[3] = -0.7171630859;
  xspeed[4] = -1.0;
  xspeed[5] = -0.7171630859;
  xspeed[6] = 0.0;
  xspeed[7] = 0.7171630859;

  yspeed[0] = 0.0;
  yspeed[1] = 0.7171630859;
  yspeed[2] = 1.0;
  yspeed[3] = 0.7171630859;
  yspeed[4] = 0.0;
  yspeed[5] = -0.7171630859;
  yspeed[6] = -1.0;
  yspeed[7] = -0.7171630859;

  ramp1[0] = 0xfffff31b; ramp1[1] = 0xefdfab27; ramp1[2] = 0xdfbf772f; ramp1[3] = 0xcf9f4f33;
  ramp1[4] = 0xbf7f3b2b; ramp1[5] = 0xaf632f1f; ramp1[6] = 0x9f4b2313; ramp1[7] = 0x8f2f170b;
  ramp1[8] = 0x7f7f3b2b; ramp1[9] = 0x6f632f1f; ramp1[10] = 0x5f4b2313; ramp1[11] = 0x4f2f170b;
  ramp1[12] = 0x3f7f3b2b; ramp1[13] = 0x2f632f1f; ramp1[14] = 0x1f4b2313; ramp1[15] = 0x0f2f170b;
  ramp2[0] = 0xfffff31b; ramp2[1] = 0xefefcb1f; ramp2[2] = 0xdfdfab27; ramp2[3] = 0xcfcf8f2b;
  ramp2[4] = 0xbfbf772f; ramp2[5] = 0xafaf632f; ramp2[6] = 0x9f8f4333; ramp2[7] = 0x8f733723;
  ramp2[8] = 0x7fbf772f; ramp2[9] = 0x6faf632f; ramp2[10] = 0x5f8f4333; ramp2[11] = 0x4f733723;
  ramp2[12] = 0x3fbf772f; ramp2[13] = 0x2faf632f; ramp2[14] = 0x1f8f4333; ramp2[15] = 0x0f733723;

  NonMonsterAngleIncrements = 45;
  InvDefaultMaxAmount = 25;
  IceMoveFactor = 0.5;
  GibsHealthFactor = 0.5;
  DehExplosionStyle = 255;
  DehExplosionAlpha = 0.666;
}
