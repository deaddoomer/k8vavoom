//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class LineSpecialGameInfo : GameInfo;

// thing types that are handled durign set-up of a level
const int
  FLOOR_SLOPE_TYPE = 1500,
  CEILING_SLOPE_TYPE = 1501,

  FLOOR_VERTEX_HEIGHT_TYPE = 1504,
  CEILING_VERTEX_HEIGHT_TYPE = 1505,

  PO_ANCHOR_TYPE_HEXEN = 3000,
  PO_SPAWN_TYPE_HEXEN = 3001,
  PO_SPAWNCRUSH_TYPE_HEXEN = 3002,

  PO_ANCHOR_TYPE = 9300,
  PO_SPAWN_TYPE = 9301,
  PO_SPAWNCRUSH_TYPE = 9302,
  PO_SPAWNHURT_TYPE = 9303,

  SLOPE_FLOOR_POINT_LINE_TYPE = 9500,
  SLOPE_CEILING_POINT_LINE_TYPE = 9501,
  SET_FLOOR_SLOPE_TYPE = 9502,
  SET_CEILING_SLOPE_TYPE = 9503,
  COPY_FLOOR_PLANE_TYPE = 9510,
  COPY_CEILING_PLANE_TYPE = 9511;


float[9] contents_alpha;

bool bUseHexenPolyobjTypes;
// -- Flags for actor behavior --
bool bNoClipIgnoreFloor; // in Doom non-clipping missiles doesn't explode when hitting the floor, in other games they do
bool bNoDamageThrustInvulnerable; // don't do damage thrust to the invulnerable players
bool bNightmareFastChase; // monsters move faster in nightmare mode
bool bRavenStylePickupRespawn; // use pickup respawn effects like in Raven's games
bool bAlwaysSwitchNewWeapon; // always to switch to a newly picked up weapon
bool bBloodRandomiseTime; // randomise blood's initial state time
bool bBloodSpray; // enter blood's spray state
bool bRipperBloodNoGravity; // ripper blood has no gravity
bool bDehacked;

bool bRespawnItems;
bool bRespawnBigItems;
bool bWeaponsStay;
bool bRandomClass;

float[3] windTab;
float[5] pushTab;

int[9] opposite;
int[4] diags;
float[8] xspeed;
float[8] yspeed;

float TeleFogHeight;
name TeleportFogState;

float DefaultKickBack;

int NonMonsterAngleIncrements;

int InvDefaultMaxAmount;

float IceMoveFactor;
float GibsHealthFactor;

int[16] ramp1;
int[16] ramp2;

float RespawnTime;

int GOD_HEALTH;

int DehExplosionStyle;
float DehExplosionAlpha;


struct WeaponSlot {
  class!Weapon[PlayerPawn::MAX_WEAPONS_PER_SLOT] Weapons;
};

WeaponSlot WeaponSlots[PlayerPawn::NUM_WEAPON_SLOTS+1];


//==========================================================================
//
//  Init
//
//==========================================================================
override void Init () {
  CreateCvar('player_default_gender', "male", "Default player gender?", CVAR_ARCHIVE|CVAR_PREINIT); // preinit, so we can change it from command line

  CreateCvar('gm_death_infighting', "1", "Should monsters start infighting when player dies?", CVAR_ARCHIVE);

  CreateCvar('gm_fix_attack_offset', "1", "Make shots go into crosshair (gameplay changer)?", CVAR_ARCHIVE);

  CreateCvar('zdoom_blood_hack', "0", "Use ZDoom blood spawn hack (different starting frame depending on damage)?", CVAR_ARCHIVE);

  CreateCvar('movebob', "0.1", "Player movement bobbing.", CVAR_ARCHIVE); // doom default is "0.25"

  CreateCvar('menu_quit_prompt', "1", "Show quit prompt on menu quit?", CVAR_ARCHIVE);

  CreateCvar('monster_backing', "0", "Should monsters back away from melee attacker?", CVAR_ARCHIVE);
  CreateCvar('addrocketexplosion', "0", "Use additive visuals for explosions?", CVAR_ARCHIVE);
  //CreateCvar('damage_thrust', (IsReleaseMode ? "0" : "1"), "Should big damage do kickbacks?", CVAR_ARCHIVE);
  CreateCvar('damage_thrust', "1", "Should big damage do kickbacks?", CVAR_ARCHIVE); // prevrel was 0
  CreateCvar('autoaim', "1", "Should weapons autoaim?", CVAR_ARCHIVE);
  CreateCvar('k8HitscanAutoAim', "0", "Enable autoaim for hitscan weapon?", CVAR_ARCHIVE); // prevrel was 1
  CreateCvar('monster_dropoff', "1", "Should monsters move away from dropoffs?", CVAR_ARCHIVE); // prevrel was 0
  // this one is only used in Hexen for now, but it could come in handy for other games if needed
  CreateCvar('alternate_monster_attacks', "0", "Alternate monster attacks in Hexen?", CVAR_ARCHIVE);
  CreateCvar('wpn_autoswitch', (IsReleaseMode ? "1" : "0"), "Should we autoswitch to new weapon?", CVAR_ARCHIVE);

  // debug headshots?
  CreateCvar('k8HSDebug', "0", "Show headshots debug messages?", 0);
  CreateCvar('k8HSDebug_ShowFailedDamageType', "0", "Show skipped damage types?", 0);

  // show headshots calculation? (doesn't matter if debug is off)
  CreateCvar('k8HSShowHeadshots', "1", "Show headshots calculation debug?", 0);

  // show criticals calculation? (doesn't matter if debug is off)
  CreateCvar('k8HSDebug_Crits', "1", "Show headshows criticals debug?", 0);

  // enable headshots?
  CreateCvar('k8HSEnabled', "1", "Is headshots enabled?", CVAR_ARCHIVE|CVAR_SERVERINFO);
  // distance multiplier (the more -- the less headshot chance on big distances)
  CreateCvar('k8HSDistMult', "1.1", "Headshots distance multiplier (the more -- the less headshot chance on big distances)", CVAR_ARCHIVE|CVAR_SERVERINFO);
  // announce critical messages
  CreateCvar('k8HSShowCriticals', "1", "Announce critical shots?", CVAR_ARCHIVE|CVAR_SERVERINFO);
  // disable criticals?
  CreateCvar('k8HSCriticals', "1", "Enable critical shots?", CVAR_ARCHIVE|CVAR_SERVERINFO);

  CreateCvar('k8HSAllowEmptyDamageType', "1", "Allow empty damage type for headshots/crits?", CVAR_ARCHIVE|CVAR_SERVERINFO);

  // fastkill/instakill some annoying monsters?
  CreateCvar('k8HSFastKillAnnoyingMonsters', (IsReleaseMode ? "0" : "1"), "Fastkill some annoying monsters?", CVAR_ARCHIVE|CVAR_SERVERINFO);
  // instakill Pain Elementals?
  CreateCvar('k8HSInstaKillPainElementals', (IsReleaseMode ? "0" : "1"), "Instakill Pain Elementals?", CVAR_ARCHIVE|CVAR_SERVERINFO);
  // instakill Lost Souls?
  CreateCvar('k8HSInstaKillLostSouls', (IsReleaseMode ? "0" : "1"), "Instakill Lost Souls?", CVAR_ARCHIVE|CVAR_SERVERINFO);
  // how mush damage should be inflicted to Arch-Vile?
  CreateCvar('k8HSFastKillArchVileDamage', "120", "Amount of damage dealt for fast-killing ArchViles.", CVAR_ARCHIVE|CVAR_SERVERINFO);

  CreateCvar('k8HSHeadKillBloodSpray', "1", "Do bloodspray on instakill/headshot?", CVAR_ARCHIVE);
  CreateCvar('k8HSHeadKillBloodCount', "5", "How much blood to spray on instakill/headshot?", CVAR_ARCHIVE);
  CreateCvar('k8HSHeadKillBloodPool', "1", "Spawn blood pool on instakill/headkill?", CVAR_ARCHIVE);

  CreateCvar('k8AmmoKing', (IsReleaseMode ? "0" : "1"), "Enable Ammo King mode?", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8AmmoKing_AllowBackpack', "0", "Enable backpack effect in Ammo King mode?", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8AmmoKing_MaxShells_Normal', "200", "Maximum shells in ammo king, no headshots.", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8AmmoKing_MaxShells_HS', "100", "Maximum shells in ammo king, with headshots.", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8AmmoKing_MaxBullets_Normal', "666", "Maximum bullets in ammo king mode, no headshots.", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8AmmoKing_MaxBullets_HS', "200", "Maximum bullets in ammo king mode, with headshots.", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8AmmoKing_MaxRockets', "150", "Maximum rockets in ammo king mode.", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8AmmoKing_MaxCells', "666", "Maximum rockets in ammo king mode.", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8AmmoKing_MaxOther', "400", "Maximum rockets in ammo king mode.", CVAR_ARCHIVE|CVAR_SERVERINFO);

  CreateCvar('k8ElvenGift', (IsReleaseMode ? "0" : "1"), "Start game with some Elven Gifts?", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8ElvenDetect', (IsReleaseMode ? "0" : "1"), "Perform Elven Senses Detection?", CVAR_ARCHIVE);

  CreateCvar('k8ElvenPaineless', (IsReleaseMode ? "0" : "1"), "Disable Pain Elemental attacks?", CVAR_ARCHIVE|CVAR_SERVERINFO);

  CreateCvar('k8BerserkSwitch', (IsReleaseMode ? "1" : "0"), "Switch to fist when Berserker Pack taken.", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8BerserkTint', "", "Berserk powerup tint color..", CVAR_ARCHIVE);

  CreateCvar('k8BonusFlashMaxTime', "0", "Maximum bonus flash time, in sectonds (<=0 is unlimited; one bonus is 0.2).", CVAR_ARCHIVE);

  CreateCvar('k8TraceDebug', "0", "Line trace debug mode", 0);

  CreateCvar('r_particle_effects', "1", "Enable particle effects?", CVAR_ARCHIVE);
  CreateCvar('r_particle_puffs', "1", "Enable particle sparks?", CVAR_ARCHIVE);
  CreateCvar('r_particle_blood', "1", "Enable particle blood?", CVAR_ARCHIVE);
  CreateCvar('r_particle_trails', "1", "Enable particle trails?", CVAR_ARCHIVE);

  CreateCvar('r_statusbar_draw', "1", "Draw statusbar?", CVAR_ARCHIVE);

  CreateCvar('r_hud_draw_fs_ammo', "1", "Draw ammo counts on fullscreen HUD?", CVAR_ARCHIVE);
  CreateCvar('r_hud_draw_fs_face', "1", "Draw Doomguy face on fullscreen HUD?", CVAR_ARCHIVE);

  CreateCvar('fuck_stealth_monsters', "0", "Turn all fuckin' stealth monsters to normal ones?", CVAR_ARCHIVE|CVAR_SERVERINFO);

  CreateCvar('vid_renderer', "1", "Tell some idiotic mod authors that we're GZDoom in OpenGL mode (1).", 0);

  CreateCvar('k8HealthAccum_Enabled', "0", "Enable Health Accumulation?", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8HealthAccum_Reset', "1", "Reset accumulated health on level transition?", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8HealthAccum_NewMapHeal', "1", "Heal with accumulated health on level transition?", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8HealthAccum_Max', "666", "How much health Accumulator can hold?", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8HealthAccum_RegenLow', "70", "When health goes below this, Accummulator will start regenerating your health (0 means always).", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8HealthAccum_RegenRate', "2", "Seconds between regenerating health.", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8HealthAccum_RegenPoints', "1", "How much health points should be regenerated in one step?", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8HealthAccum_BoostLow', "10", "When health goes below this, Accummulator will boost your health.", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8HealthAccum_BoostPoints', "-80", "Boost by this number of health points (positive), or up to the given health (negative).", CVAR_ARCHIVE|CVAR_SERVERINFO);
  CreateCvar('k8HealthAccum_BoostCooldown', "30", "Health boost cooldown, in seconds.", CVAR_ARCHIVE|CVAR_SERVERINFO);
  //TODO: make this network-aware
  CreateCvar('k8HealthAccum_MessagesRegen', "0", "Report health regeneration.", CVAR_ARCHIVE);
  CreateCvar('k8HealthAccum_MessagesBoost', "1", "Report health boost.", CVAR_ARCHIVE);
  CreateCvar('k8HealthAccum_MessagesAccumed', "0", "Report health accumulation.", CVAR_ARCHIVE);

  CreateCvar('hud_scale_messages', "1", "Rescale HUD messages, so message font is less distorted?", CVAR_ARCHIVE);

  CreateCvar('ldr_fix_slope_cracks', "1", "Try to fix empty cracks near sloped floors?", CVAR_ARCHIVE);

  CreateCvar('k8HealthBar', "0", "Allow healthbar?", CVAR_ARCHIVE);
  CreateCvar('k8HealthBarAlpha', "0.6", "Healthbar opacity.", CVAR_ARCHIVE);
  CreateCvar('k8HealthBarOnlyMonsters', "1", "Ignore non-monsters?", CVAR_ARCHIVE);

  CreateCvar('blood_widespread', "0", "Throw blood splats on full 360 degrees circle?", CVAR_ARCHIVE);

  CreateCvar('k8_flashlight_shadows', "0", "Do shadow casting from player flashlight?", CVAR_ARCHIVE);
  CreateCvar('k8_flashlight_distance', "768", "Flashlight distance.", CVAR_ARCHIVE);
  CreateCvar('k8_flashlight_color', "0xcfcf50", "Flashlight color.", CVAR_ARCHIVE);
  CreateCvar('k8_flashlight_angle', "20", "Flashlight cone angle.", CVAR_ARCHIVE);

  CreateCvar('k8SuperBulletCooldown', "0.15", "SuperBullet cooldown time, in seconds.", CVAR_ARCHIVE);



  CreateCvar('bot_ignore_humans', "0", "Should bots ignore human players?", 0/*CVAR_ARCHIVE*/);
  CreateCvar('bot_developer_messages_roam', "0", "Show some bot developer messages?", 0/*CVAR_ARCHIVE*/);
  CreateCvar('bot_developer_messages_checkpos', "0", "Show some bot developer messages?", 0/*CVAR_ARCHIVE*/);
  CreateCvar('bot_developer_messages_items', "0", "Show some bot developer messages?", 0/*CVAR_ARCHIVE*/);
  CreateCvar('bot_developer_messages_attack', "0", "Show some bot developer messages?", 0/*CVAR_ARCHIVE*/);
  CreateCvar('bot_developer_messages_path', "0", "Show some bot developer messages?", 0/*CVAR_ARCHIVE*/);
  CreateCvar('bot_developer_messages_crumbs', "0", "Show some bot developer messages?", 0/*CVAR_ARCHIVE*/);
  CreateCvar('bot_developer_messages_planpath', "0", "Show some bot developer messages?", 0/*CVAR_ARCHIVE*/);

  CreateCvar('bot_run_to_subsector_center', "1", "Show some bot developer messages?", 0/*CVAR_ARCHIVE*/);

  CreateCvar('bot_no_run', "0", "Disable bot running?", 0/*CVAR_ARCHIVE*/);
  CreateCvar('bot_no_jump', "0", "Disable bot jumping?", 0/*CVAR_ARCHIVE*/);
  CreateCvar('bot_always_headshots', "0", "Should bot always try do to a headshot?", 0/*CVAR_ARCHIVE*/);


  CreateCvar('trans_debug_log', "0", "Show translation debug log?", CVAR_ARCHIVE);


  ::Init(); // parse cvarinfo and such
}


//==========================================================================
//
//  CreateWorldInfo
//
//==========================================================================
override WorldInfo CreateWorldInfo () {
  return WorldInfo(SpawnObject(WorldInfoEx));
}


//==========================================================================
//
//  SetSkill
//
//==========================================================================
void SetSkill (int NewSkill) {
  WorldInfo.SetSkill(NewSkill);
  fastparm = 0;
  int fmon = GetCvar('g_fast_monsters_override');
  if (!fmon) fmon = GetCvar('g_fast_monsters');
  if (fmon) {
    switch (fmon) {
      case 1: fastparm = 1; break;
      case 2: fastparm = 2; break;
    }
  } else {
         if (WorldInfo.bSkillFastMonsters) fastparm = 1;
    else if (WorldInfo.bSkillSlowMonsters) fastparm = 2;
  }
  RespawnTime = WorldInfo.SkillRespawnTime;
  if (!RespawnTime && GetCvar('RespawnMonsters')) RespawnTime = 12.0/35.0;
  int rst = GetCvarI('g_monsters_respawn_override');
       if (rst > 0) RespawnTime = rst;
  else if (rst < 0) RespawnTime = 0;
  //print("*********** skill: %s; fastparm: %s; fmon: %s; respawn=%s", NewSkill, fastparm, fmon, RespawnTime);
}


//==========================================================================
//
//  MakeSlope
//
//==========================================================================
final void MakeSlope (Level InLevel, mthing_t *mthing, bool IsCeiling) {
  TVec v1, v2;
  TVec p1, p2, p3;
  sec_plane_t *plane;

  sector_t *sec = InLevel.PointInSector(vector(mthing->x, mthing->y, 0.0));
  foreach (auto i; 0..sec.lines.length) {
    line_t *line = sec->lines[i];
    if (mthing->tid == line->arg1) {
      if (!IsCeiling) {
        plane = &sec->floor;
        p1 = vector(line->v1->x, line->v1->y, plane->minz);
        p2 = vector(line->v2->x, line->v2->y, plane->minz);
      } else {
        plane = &sec->ceiling;
        p1 = vector(line->v1->x, line->v1->y, plane->maxz);
        p2 = vector(line->v2->x, line->v2->y, plane->maxz);
      }
      p3 = vector(mthing->x, mthing->y, mthing->height);
      if (PointOnPlaneSide(p3, *line) == IsCeiling) {
        v1 = p2-p3;
        v2 = p1-p3;
      } else {
        v1 = p1-p3;
        v2 = p2-p3;
      }
      plane->normal = Normalise(CrossProduct(v1, v2));
           if (!IsCeiling && plane->normal.z <= 0.0) Error("Floor with normal.z <= 0.0");
      else if (IsCeiling && plane->normal.z >= 0.0) Error("Ceiling with normal.z >= 0.0");
      plane->dist = DotProduct(plane->normal, p3);
      return;
    }
  }
}


//===========================================================================
//
//  SlopeLineToPoint
//
//===========================================================================
final void SlopeLineToPoint (Level InLevel, mthing_t *mthing, bool IsCeiling) {
  sec_plane_t *plane;
  TVec p1, p2;
  TVec v1, v2;
  TVec cross;

  sector_t *sec = InLevel.PointInSector(vector(mthing->x, mthing->y, 0.0));
  if (!IsCeiling) {
    plane = &sec->floor;
  } else {
    plane = &sec->ceiling;
  }
  p1 = vector(mthing->x, mthing->y, 0.0);
  p1.z = GetPlanePointZ(ref *plane, p1)+mthing->height;

  foreach (auto i; 0..InLevel.Lines.length) {
    line_t *line = &InLevel.Lines[i];
    if (!IsLineTagEqual(line, mthing->arg1)) continue;

    sec = (PointOnPlaneSide(p1, *line) == 0 ? line->frontsector : line->backsector);
    if (sec == nullptr) continue;
    if (!IsCeiling) {
      plane = &sec->floor;
    } else {
      plane = &sec->ceiling;
    }

    p2 = *line->v1;
    p2.z = GetPlanePointZ(ref *plane, p2);
    v1 = (*line->v2)-(*line->v1);
    v1.z = GetPlanePointZ(ref *plane, *line->v2)-p2.z;
    v2 = p1-(*line->v1);
    v2.z = p1.z-p2.z;

    cross = CrossProduct(v1, v2);
    float len = Length(cross);
    if (!len) {
      printwarn("slope thing at (%d,%d) lies directly on its target line.", mthing->x, mthing->y);
      return;
    }
    cross = cross/len;
    // fix backward normals
    if ((cross.z < 0.0 && !IsCeiling) || (cross.z > 0.0 && IsCeiling)) cross = -cross;

    plane->normal = cross;
    plane->dist = DotProduct(plane->normal, p1);
  }
}


//===========================================================================
//
//  SetSlope
//
//===========================================================================
final void SetSlope (Level InLevel, mthing_t *mthing, bool IsCeiling) {
  TVec p1;
  sec_plane_t *plane;
  float xyang;
  float zang;
  TVec norm;

  sector_t *sec = InLevel.PointInSector(vector(mthing->x, mthing->y, 0.0));
  if (!sec) FatalError("point (%f,%f) is not in level", mthing->x, mthing->y);
  if (!IsCeiling) {
    plane = &sec->floor;
    //if (plane.normal.z == 0) FatalError("SetSlope: invalid floor in sector #%d (%v)", calcSecIdx(InLevel, sec), plane.normal);
    //print("SetSlope; sector %d (floor); %s; plane.dist=%f; plane.normal=%v", calcSecIdx(InLevel, sec), plane, plane.dist, plane.normal);
  } else {
    plane = &sec->ceiling;
    //if (plane.normal.z == 0) FatalError("SetSlope: invalid ceiling in sector #%d (%v)", calcSecIdx(InLevel, sec), plane.normal);
    //print("SetSlope; sector %d (ceiling); %s; plane.dist=%f; plane.normal=%v", calcSecIdx(InLevel, sec), plane, plane.dist, plane.normal);
  }
  p1 = vector(mthing->x, mthing->y, 0.0);
  p1.z = GetPlanePointZ(ref *plane, p1)+mthing->height;

       if (mthing->arg1 >= 180) zang = 179.0;
  else if (mthing->arg1 <= 0) zang = 1.0;
  else zang = float(mthing->arg1);

  if (IsCeiling) zang += 180.0;

  xyang = float(mthing->angle);

  norm.x = cos(zang)*cos(xyang);
  norm.y = cos(zang)*sin(xyang);
  norm.z = sin(zang);
  norm = Normalise(norm);
  plane->normal = norm;
  plane->dist = DotProduct(plane->normal, p1);

  // fix missing top/bottom textures, so there won't be empty cracks
  if (GetCvarB('ldr_fix_slope_cracks')) {
    //int snum = 1;
    foreach (auto lidx, line_t *ln; sec.lines) {
      foreach (int snum; 0..2) {
        if (ln.sidenum[snum] >= 0) {
          side_t *sd = &InLevel.Sides[ln.sidenum[snum]];
          // floor
          if (!IsCeiling && sd.BottomTexture <= 0) {
            //print("F-FUUUUUUUU! (%s:%s) %s", lidx, snum, sec.floor.pic);
            sd.BottomTexture = sec.floor.pic;
          }
          // ceiling
          if (IsCeiling && sd.TopTexture <= 0) {
            //print("C-FUUUUUUUU! (%s:%s) %s", lidx, snum, sec.floor.pic);
            sd.TopTexture = sec.floor.pic;
          }
        }
      }
    }
  }
}


//==========================================================================
//
//  SetVertexHeights
//
//==========================================================================
final bool SetVertexHeights (Level InLevel, int ThingID) {
  bool ret = false;

  // clean all
  foreach (auto i; 0..InLevel.Vertexes.length) InLevel.Vertexes[i].z = 0.1;

  foreach (auto j; 0..InLevel.Things.length) {
    mthing_t *mthing = &InLevel.Things[j];
    if (mthing->type == ThingID) {
      foreach (auto i; 0..InLevel.Vertexes.length) {
        if (InLevel.Vertexes[i].x == mthing->x &&
            InLevel.Vertexes[i].y == mthing->y)
        {
          InLevel.Vertexes[i].z = mthing->height;
          ret = true;
        }
      }
      mthing->type = 0;
    }
  }

  return ret;
}


//==========================================================================
//
//  CleanVertexHeights
//
//==========================================================================
final void CleanVertexHeights (Level InLevel) {
  foreach (auto i; 0..InLevel.Vertexes.length) InLevel.Vertexes[i].z = 0.0;
}


//==========================================================================
//
//  MakeVertexFloorHeights
//
//==========================================================================
final void MakeVertexFloorHeights (Level InLevel) {
  TVec p1, p2, p3;
  TVec v1, v2;

  if (!SetVertexHeights(InLevel, FLOOR_VERTEX_HEIGHT_TYPE)) return;

  foreach (auto i; 0..InLevel.Sectors.length) {
    sector_t *sec = &InLevel.Sectors[i];
    if (sec.lines.length != 3) continue;
    p1 = *sec->lines[0]->v1;
    p2 = *sec->lines[0]->v2;
    if (sec->lines[1]->v1 == sec->lines[0]->v1 ||
        sec->lines[1]->v1 == sec->lines[0]->v2)
    {
      p3 = *sec->lines[1]->v2;
    } else {
      p3 = *sec->lines[1]->v1;
    }
    if (p1.z == 0.1 && p2.z == 0.1 && p3.z == 0.1) continue;
    if (p1.z == 0.1) p1.z = sec->floor.TexZ;
    if (p2.z == 0.1) p2.z = sec->floor.TexZ;
    if (p3.z == 0.1) p3.z = sec->floor.TexZ;
    if (PointOnPlaneSide(p3, *sec->lines[0]) == 0) {
      v1 = p2-p3;
      v2 = p1-p3;
    } else {
      v1 = p1-p3;
      v2 = p2-p3;
    }
    sec->floor.normal = Normalise(CrossProduct(v1, v2));
    if (sec->floor.normal.z <= 0.0) Error("Floor with normal.z <= 0.0");
    sec->floor.dist = DotProduct(sec->floor.normal, p3);
  }
}


//==========================================================================
//
//  MakeVertexCeilingHeights
//
//==========================================================================
final void MakeVertexCeilingHeights (Level InLevel) {
  TVec p1, p2, p3;
  TVec v1, v2;

  if (!SetVertexHeights(InLevel, CEILING_VERTEX_HEIGHT_TYPE)) return;

  foreach (auto i; 0..InLevel.Sectors.length) {
    sector_t *sec = &InLevel.Sectors[i];
    if (sec.lines.length != 3) continue;
    p1 = *sec->lines[0]->v1;
    p2 = *sec->lines[0]->v2;
    if (sec->lines[1]->v1 == sec->lines[0]->v1 ||
        sec->lines[1]->v1 == sec->lines[0]->v2)
    {
      p3 = *sec->lines[1]->v2;
    } else {
      p3 = *sec->lines[1]->v1;
    }
    if (p1.z == 0.1 && p2.z == 0.1 && p3.z == 0.1) continue;
    if (p1.z == 0.1) p1.z = sec->ceiling.TexZ;
    if (p2.z == 0.1) p2.z = sec->ceiling.TexZ;
    if (p3.z == 0.1) p3.z = sec->ceiling.TexZ;
    if (PointOnPlaneSide(p3, *sec->lines[0]) == 0) {
      v1 = p1-p3;
      v2 = p2-p3;
    } else {
      v1 = p2-p3;
      v2 = p1-p3;
    }
    sec->ceiling.normal = Normalise(CrossProduct(v1, v2));
    if (sec->ceiling.normal.z >= 0.0) Error("Ceiling with normal.z >= 0.0");
    sec->ceiling.dist = DotProduct(sec->ceiling.normal, p3);
  }
}


//==========================================================================
//
//  AlignPlane
//
//  Set slopes for sectors, based on line specials
//
//  Aligns the floor or ceiling of a sector to the corresponding plane
//  on the other side of the reference line. (By definition, line must be
//  two-sided.)
//
//  If which == 0, sets floor.
//  If which == 1, sets ceiling.
//
//==========================================================================
final void AlignPlane (Level InLevel, sector_t *sec, line_t *line, int which, int lineidx) {
  if (line->backsector == nullptr) return;

  // find furthest vertex from the reference line
  // it, along with the two ends of the line will define the plane
  TVec *refvert = sec.lines[0].v1;
  float bestdist = -1;
  foreach (auto i; 0..sec.lines.length) {
    foreach (auto vidx; 0..2) {
      TVec *vert = (!vidx ? sec.lines[i].v1 : sec.lines[i].v2);
      float dist = fabs(DotProduct(*vert, line.normal)-line.dist);
      //TVec dir = (*line->v2)-(*line->v1);
      //float dist = fabs((line.v1.y-vert.y)*dir.x-(line.v1.x-vert.x)*dir.y);
      if (dist > bestdist) { bestdist = dist; refvert = vert; }
    }
  }

  sector_t *refsec = (line.frontsector == sec ? line.backsector : line.frontsector);

  sec_plane_t *srcplane = (which == 0 ? &sec.floor : &sec.ceiling);
  float srcheight = (which == 0 ? sec.floor.TexZ : sec.ceiling.TexZ);
  float destheight = (which == 0 ? refsec.floor.TexZ : refsec.ceiling.TexZ);

  TVec p = *line.v1;
  p.z = destheight;

  TVec v1 = (*line.v2)-(*line.v1);
  v1.z = 0;

  TVec v2 = (*refvert)-(*line.v1);
  v2.z = srcheight-destheight;

  TVec cross = Normalise(CrossProduct(v1, v2));

  // fix backward normals
  if ((which == 0 && cross.z < 0) || (which == 1 && cross.z > 0)) cross = -cross;

  srcplane.normal = cross;
  srcplane.dist = DotProduct(cross, p);

  // fix missing top/bottom textures, so there won't be empty cracks
  if (GetCvarB('ldr_fix_slope_cracks')) {
    //int snum = (line.frontsector == sec ? 0 : 1);
    //int snum = 1;
    foreach (auto lidx, line_t *ln; sec.lines) {
      foreach (int snum; 0..2) {
        if (ln.sidenum[snum] >= 0) {
          side_t *sd = &InLevel.Sides[ln.sidenum[snum]];
          // floor
          if (which == 0 && sd.BottomTexture <= 0) {
            //print("F-FUUUUUUUU! (%s:%s) %s", lidx, snum, sec.floor.pic);
            sd.BottomTexture = sec.floor.pic;
          }
          // ceiling
          if (which != 0 && sd.TopTexture <= 0) {
            //print("C-FUUUUUUUU! (%s:%s) %s", lidx, snum, sec.floor.pic);
            sd.TopTexture = sec.floor.pic;
          }
        }
      }
    }
  }
}


//==========================================================================
//
//  SetSlopes
//
//==========================================================================
final void SetSlopes (Level InLevel) {
  foreach (auto i; 0..InLevel.Lines.length) {
    line_t *line = &InLevel.Lines[i];
    if (line.special == LNSPEC_PlaneAlign) {
      line.special = 0;
      line.lineTag = InLevel.Lines[i].arg3;
      if (line.backsector) {
        // args[0] is for floor, args[1] is for ceiling
        //
        // As a special case, if args[1] is 0,
        // then args[0], bits 2-3 are for ceiling.
        foreach (auto s; 0..2) {
          int bits = (s == 0 ? line.arg1 : line.arg2)&3;
          //if (s == 1 && bits == 0) bits = (InLevel.Lines[i].arg1 >> 2) & 3;
          if (s == 1 && !line.arg2) bits = (line.arg1>>2)&3;
          switch (bits) {
            case 1: // align front side to back
              AlignPlane(InLevel, line.frontsector, line, s, i);
              break;
            case 2:
              // align back side to front
              AlignPlane(InLevel, line.backsector, line, s, i);
              break;
          }
        }
      }
    }
  }
}


//==========================================================================
//
//  ProcessCopySlopes
//
//==========================================================================
final void ProcessCopySlopes (Level InLevel) {
  foreach (auto i; 0..InLevel.Lines.length) {
    line_t *line = &InLevel.Lines[i];
    if (line.special == LNSPEC_PlaneCopy) {
      line.special = 0;
      CopyPlaneBetweenTaggedSectors(InLevel, line.frontsector, line.arg1, IsCeiling:false); // front floor
      CopyPlaneBetweenTaggedSectors(InLevel, line.frontsector, line.arg2, IsCeiling:true); // front ceiling
      CopyPlaneBetweenTaggedSectors(InLevel, line.backsector, line.arg3, IsCeiling:false); // back floor
      CopyPlaneBetweenTaggedSectors(InLevel, line.backsector, line.arg4, IsCeiling:true); // back ceiling
      // share
      int share = line.arg5&3;
      if (share && share != 3) {
        if (share&1) CopyPlaneBetweenSectors(InLevel, line.backsector, line.frontsector, IsCeiling:false); // front floor to back floor
        if (share&2) CopyPlaneBetweenSectors(InLevel, line.frontsector, line.backsector, IsCeiling:false); // back floor to front floor
      }
      share = (line.arg5>>2)&3;
      if (share && share != 3) {
        if (share&1) CopyPlaneBetweenSectors(InLevel, line.backsector, line.frontsector, IsCeiling:true); // front ceiling to back ceiling
        if (share&2) CopyPlaneBetweenSectors(InLevel, line.frontsector, line.backsector, IsCeiling:true); // back ceiling to front ceiling
      }
    }
  }
}


//===========================================================================
//
//  CopyPlaneBetweenSectors
//
//===========================================================================
final void CopyPlaneBetweenSectors (Level InLevel, sector_t *dst, sector_t *src, bool IsCeiling) {
  if (!src || !dst || src == dst) return; // just in case
  if (!IsCeiling) {
    dst->floor.normal = src->floor.normal;
    dst->floor.dist = src->floor.dist;
  } else {
    dst->ceiling.normal = src->ceiling.normal;
    dst->ceiling.dist = src->ceiling.dist;
  }
}


//===========================================================================
//
//  CopyPlaneBetweenTaggedSectors
//
//===========================================================================
final void CopyPlaneBetweenTaggedSectors (Level InLevel, sector_t *dst, int srctag, bool IsCeiling) {
  if (srctag <= 0 || !dst) return; // just in case
  sector_t *sector;
  if (InLevel.FindSectorFromTag(out sector, srctag) < 0) return; // no source sector
  CopyPlaneBetweenSectors(InLevel, sector, dst, IsCeiling);
}


//===========================================================================
//
//  CopyPlaneWithThing
//
//===========================================================================
final void CopyPlaneWithThing (Level InLevel, mthing_t *mthing, bool IsCeiling) {
  sector_t *dst = InLevel.PointInSector(vector(mthing->x, mthing->y, 0.0));
  sector_t *src;
  if (InLevel.FindSectorFromTag(out src, mthing->arg1) < 0) return; // no source sector
  if (!IsCeiling) {
    dst->floor.normal = src->floor.normal;
    dst->floor.dist = src->floor.dist;
  } else {
    dst->ceiling.normal = src->ceiling.normal;
    dst->ceiling.dist = src->ceiling.dist;
  }
}


//==========================================================================
//
//  SpawnExtraFloors
//
//==========================================================================
final void SpawnExtraFloors (Level InLevel, line_t *line) {
  int tag = line->arg1+(line->arg1&8 ? 0 : line->arg5);
  foreach (auto j; 0..InLevel.Sectors.length) {
    if (IsSectorTagEqual(&InLevel.Sectors[j], tag)) {
      InLevel.AddExtraFloor(line, &InLevel.Sectors[j]);
    }
  }
}


//==========================================================================
//
//  MakeWaterContents
//
//==========================================================================
final void MakeWaterContents (Level InLevel, line_t *line) {
  int contents = CONTENTS_WATER;
  sector_t *sec = line->frontsector;
  sec.params.contents = contents;
  sec.floor.Alpha = contents_alpha[contents];
  sec.ceiling.Alpha = contents_alpha[contents];
  sec.ceiling.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
  sec.floor.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
}


//==========================================================================
//
//  MakeSolidContents
//
//==========================================================================
final void MakeSolidContents (Level InLevel, line_t *line) {
  int contents = CONTENTS_EMPTY;
  sector_t *sec = line->frontsector;
  sec.params.contents = contents;
  sec.floor.Alpha = contents_alpha[contents];
  sec.ceiling.Alpha = contents_alpha[contents];
  //sec.ceiling.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
  //sec.floor.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
}


//==========================================================================
//
//  MakeNonSolidContents
//
//==========================================================================
final void MakeNonSolidContents (Level InLevel, line_t *line) {
  int contents = CONTENTS_EMPTY;
  sector_t *sec = line->frontsector;
  sec.params.contents = contents;
  sec.floor.Alpha = contents_alpha[contents];
  sec.ceiling.Alpha = contents_alpha[contents];
  sec.ceiling.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
  sec.floor.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
}


//==========================================================================
//
//  MakeContents
//
//==========================================================================
final void MakeContents (line_t *line) {
  if (!line->arg1 && !line->arg2 && !line->arg3) {
    //MakeWaterContents(line);
    int contents = CONTENTS_WATER;
    sector_t *sec = line->frontsector;
    sec.params.contents = contents;
    if (sec.floor.dist == -sec.ceiling.dist) {
      sec.floor.Alpha = contents_alpha[contents];
      sec.ceiling.Alpha = contents_alpha[contents];
      sec.ceiling.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
      sec.floor.flags |= SPF_NOBLOCKING|SPF_NOBLOCKSIGHT|SPF_NOBLOCKSHOOT;
    }
  } else {
    sector_t *sec = line->frontsector;
    sec.params.contents = line->arg1;

    sec.floor.Alpha = (100.0-float(line->arg2))/100.0;
    sec.ceiling.Alpha = (100.0-float(line->arg2))/100.0;

    sec.ceiling.flags = line->arg3;
    sec.floor.flags = line->arg3;
  }
}


//==========================================================================
//
//  MakeHeightSec
//
//  killough 3/7/98:
//  support for drawn heights coming from different sector
//
//==========================================================================
void MakeHeightSec (Level InLevel, line_t *line) {
  sector_t *sec = line->frontsector;
  sec.bTransferSource = true;
  if (line->arg2&2) sec.bFakeFloorOnly = true;
  if (line->arg2&4) sec.bClipFakePlanes = true;
  if (line->arg2&8) sec.bUnderWater = true;
  if (line->arg2&16) sec.bIgnoreHeightSec = true;
  if (line->arg2&32) sec.bNoFakeLight = true;
  sector_t *ss2;
  for (int hidx = InLevel.FindSectorFromTag(out ss2, line->arg1); hidx >= 0; hidx = InLevel.FindSectorFromTag(out ss2, line->arg1, hidx)) {
    ss2.heightsec = sec;
    InLevel.SetHeightSector(ss2, sec, line->arg2);
  }
}


//==========================================================================
//
//  SetSectorFriction
//
//==========================================================================
void SetSectorFriction (Level InLevel, int tag, int amount, bool alterFlag) {
  int OldMoveFactor;

  // an amount of 100 should result in a friction of ORIG_FRICTION (0xE800)
  int OldFriction = (0x1EB8*amount)/0x80+0xD001;

  // killough 8/28/98: prevent odd situations
  if (OldFriction > 0x10000) OldFriction = 0x10000;
  if (OldFriction < 0) OldFriction = 0;

  // the following check might seem odd. At the time of movement,
  // the move distance is multiplied by 'friction/0x10000', so a
  // higher friction value actually means 'less friction'

  // [RH] Twiddled these values so that momentum on ice (with
  //    friction 0xf900) is the same as in Heretic/Hexen
  if (OldFriction >= 0xe800) {
    // ice
    //movefactor = ((0x10092-friction)*(0x70))/0x158;
    OldMoveFactor = ((0x10092-OldFriction)*1024)/4352+568;
  } else {
    OldMoveFactor = ((OldFriction-0xDB34)*(0xA))/0x80;
  }

  // killough 8/28/98: prevent odd situations
  if (OldMoveFactor < 32) OldMoveFactor = 32;

  float Friction = (1.0-float(OldFriction)/float(0x10000))*35.0;
  float MoveFactor = float(OldMoveFactor)/float(0x10000);

  sector_t *fricsec;
  for (int hidx = InLevel.FindSectorFromTag(out fricsec, tag); hidx >= 0; hidx = InLevel.FindSectorFromTag(out fricsec, tag, hidx)) {
    // killough 8/28/98:
    //
    // Instead of spawning thinkers, which are slow and expensive,
    // modify the sector's own friction values. Friction should be
    // a property of sectors, not objects which reside inside them.
    // Original code scanned every object in every friction sector
    // on every tic, adjusting its friction, putting unnecessary
    // drag on CPU. New code adjusts friction of sector only once
    // at level startup, and then uses this friction value.

    fricsec.Friction = Friction;
    fricsec.MoveFactor = MoveFactor;
    if (alterFlag) {
      // when used inside a script, the sectors' friction flags can be enabled and disabled at will
      if (OldFriction == 0xe800) {
        fricsec.special &= ~SECSPEC_FRICTION_MASK;
      } else {
        fricsec.special |= SECSPEC_FRICTION_MASK;
      }
    }
  }
}


//==========================================================================
//
//  StaticInit
//
//==========================================================================
void StaticInit (Level InLevel, line_t *line) {
  float Grav;
  int Dmg;
  sector_t *sec;

  if (!line->arg1) return; // zero sector tag sux
  switch (line->arg2) {
    case 0:
      Grav = Length((*line->v2)-(*line->v1))/100.0;
      for (int hidx = InLevel.FindSectorFromTag(out sec, line->arg1); hidx >= 0; hidx = InLevel.FindSectorFromTag(out sec, line->arg1, hidx)) {
        sec.Gravity = Grav;
      }
      break;
    /* this is processed in level setup
    case 1:
      // sets the light or fog color in a sector
      // an RRGGBB hex format color used as an upper texture name will set the light color; a lower texture will set the fog color
      print("StaticInit(1): upper=%s; lower=%s", InLevel.Sides[line.sidenum[0]].TopTexture, InLevel.Sides[line.sidenum[0]].BottomTexture);
      for (int hidx = InLevel.FindSectorFromTag(out sec, line->arg1); hidx >= 0; hidx = InLevel.FindSectorFromTag(out sec, line->arg1, hidx)) {
      }
      break;
    */
    case 2:
      Dmg = int(Length((*line->v2)-(*line->v1)));
      for (int hidx = InLevel.FindSectorFromTag(out sec, line->arg1); hidx >= 0; hidx = InLevel.FindSectorFromTag(out sec, line->arg1, hidx)) {
        sec.Damage = Dmg;
      }
      break;
    //case 3: // defines a sector link with line IDs instead of tags, as in Eternity
    case 255:
      // uses the line's upper texture as the sky in any tagged sectors (that is, the sky flat
      // will be replaced with that texture instead of the sky indicated in MAPINFO).
      // if flip is set to 1, the texture will be flipped, as is normal behavior for Doom skies.
      // offsets and scrolling of the texture are transferred to the sky as well.
      // scrolling, however, is only at a tiny fraction of the wall texture's scrolling speed.
      // this corresponds to the MBF sky transfer linetypes (271 and 272).
      // Note: the line's lower texture, if set and of the same dimensions as the upper texture, will be used during lightning flashes.
      for (int hidx = InLevel.FindSectorFromTag(out sec, line->arg1); hidx >= 0; hidx = InLevel.FindSectorFromTag(out sec, line->arg1, hidx)) {
        sec.Sky = (line->sidenum[0]+1)|SKY_FROM_SIDE;
      }
      break;
  }
}


//==========================================================================
//
//  SpawnWorld
//
//==========================================================================
override void SpawnWorld (Level InLevel) {
  int length;
  int SecNum;
  float alpha;

  // set up tagged lines
  if (!InLevel.bTextMap) {
    foreach (auto i; 0..InLevel.Lines.length) {
      line_t *line = &InLevel.Lines[i];
      switch (line->special) {
        case LNSPEC_LineSetIdentification:
          line->special = 0;
          line->lineTag = line->arg1+(line->arg5<<8);
          line->flags |= line->arg2<<16;
          break;
        case LNSPEC_LineTranslucent:
          line->lineTag = line->arg1;
          line->flags |= line->arg4<<16;
          break;
        case LNSPEC_TeleportLine:
        case LNSPEC_ScrollTextureModel:
          line->lineTag = line->arg1;
          break;
        case LNSPEC_PolyStartLine:
          line->lineTag = line->arg4;
          break;
        case LNSPEC_PolyExplicitLine:
          line->lineTag = line->arg5;
          break;
        case LNSPEC_StaticInit:
          if (line->arg2 == 3) line->lineTag = line->arg1;
          break;
      }
    }
  }

  // spawn slopes
  SetSlopes(InLevel);

  // order:
  //  pass:
  //   FLOOR_SLOPE_TYPE
  //   CEILING_SLOPE_TYPE
  //   SLOPE_FLOOR_POINT_LINE_TYPE
  //   SLOPE_CEILING_POINT_LINE_TYPE
  //   SET_FLOOR_SLOPE_TYPE
  //   SET_CEILING_SLOPE_TYPE
  //  pass:
  //   COPY_FLOOR_PLANE_TYPE
  //   COPY_CEILING_PLANE_TYPE
  //  pass:
  //   FLOOR_VERTEX_HEIGHT_TYPE
  //   CEILING_VERTEX_HEIGHT_TYPE

  foreach (auto i; 0..InLevel.Things.length) {
    mthing_t *mthing = &InLevel.Things[i];
    switch (mthing->type) {
      case FLOOR_SLOPE_TYPE:
        //print("SLOPE: FLOOR_SLOPE_TYPE");
        MakeSlope(InLevel, mthing, false);
        mthing->type = 0;
        break;
      case CEILING_SLOPE_TYPE:
        //print("SLOPE: CEILING_SLOPE_TYPE");
        MakeSlope(InLevel, mthing, true);
        mthing->type = 0;
        break;
      case SLOPE_FLOOR_POINT_LINE_TYPE:
        //print("SLOPE: SLOPE_FLOOR_POINT_LINE_TYPE");
        SlopeLineToPoint(InLevel, mthing, false);
        mthing->type = 0;
        break;
      case SLOPE_CEILING_POINT_LINE_TYPE:
        //print("SLOPE: SLOPE_CEILING_POINT_LINE_TYPE");
        SlopeLineToPoint(InLevel, mthing, true);
        mthing->type = 0;
        break;
      case SET_FLOOR_SLOPE_TYPE:
        //print("SLOPE: SET_FLOOR_SLOPE_TYPE");
        SetSlope(InLevel, mthing, false);
        mthing->type = 0;
        break;
      case SET_CEILING_SLOPE_TYPE:
        //print("SLOPE: SET_CEILING_SLOPE_TYPE");
        SetSlope(InLevel, mthing, true);
        mthing->type = 0;
        break;
      }
  }

  foreach (auto i; 0..InLevel.Things.length) {
    mthing_t *mthing = &InLevel.Things[i];
    if (mthing->type == COPY_FLOOR_PLANE_TYPE ||
        mthing->type == COPY_CEILING_PLANE_TYPE)
    {
      CopyPlaneWithThing(InLevel, mthing, mthing->type&1);
      mthing->type = 0;
    }
  }

  MakeVertexFloorHeights(InLevel);
  MakeVertexCeilingHeights(InLevel);
  CleanVertexHeights(InLevel);

  ProcessCopySlopes(InLevel);

  // set up 3D floors, transfers of light, etc.
  foreach (auto i; 0..InLevel.Lines.length) {
    line_t *line = &InLevel.Lines[i];
    switch (line->special) {
      // Sector_Set3dFloor(tag, type, flags, alpha, hi-tag/line ID)
      case LNSPEC_SectorSet3dFloor:
        //print("********************** %s", line->oplist.length);
        //if (line->arg2) print("*** 3D FLOOR OF TYPE %s (tag=%s; flags=0x%04x; alpha=%s; hitag=%s)", line->arg2, line->arg1, line->arg3, line->arg4, line->arg5);
        switch (line->arg2&3) {
          case 1:
            //print("SOLID FLOOR!");
            MakeSolidContents(InLevel, line);
            break;
          case 2:
            //print("SWIMMABLE FLOOR!");
            MakeWaterContents(InLevel, line);
            break;
          case 3:
            //print("NON-SOLID FLOOR!");
            MakeNonSolidContents(InLevel, line);
            break;
        }
        // flags
        if (line->arg2 != 0) {
          sector_t *sec = line->frontsector;
          // invert sight?
          if (line->arg2&16) {
            sec.ceiling.flags ^= SPF_NOBLOCKSIGHT;
            sec.floor.flags ^= SPF_NOBLOCKSIGHT;
          }
          // invert shootability?
          if (line->arg2&32) {
            sec.ceiling.flags ^= SPF_NOBLOCKSHOOT;
            sec.floor.flags ^= SPF_NOBLOCKSHOOT;
          }
          // set line tag
          if (line->arg2&8) line->lineTag = line->arg5;
          if (line->arg4 < 255) {
            float secalpha = clamp(line->arg4, 0, 255)/255.0;
            sec.floor.Alpha = secalpha;
            sec.ceiling.Alpha = secalpha;
          }
        }
        SpawnExtraFloors(InLevel, line);
        line->special = 0;
        break;
      case LNSPEC_Contents:
        MakeContents(line);
        line->special = 0;
        break;
      case LNSPEC_TransferFloorLight:
        {
          sector_t *sec;
          for (int hidx = InLevel.FindSectorFromTag(out sec, line->arg1);
               hidx >= 0;
               hidx = InLevel.FindSectorFromTag(out sec, line->arg1, hidx))
          {
            InLevel.SetFloorLightSector(sec, line->frontsector);
          }
        }
        line->special = 0;
        line->frontsector->bTransferSource = true;
        break;
      case LNSPEC_TransferCeilingLight:
        {
          sector_t *sec;
          for (int hidx = InLevel.FindSectorFromTag(out sec, line->arg1);
               hidx >= 0;
               hidx = InLevel.FindSectorFromTag(out sec, line->arg1, hidx))
          {
            InLevel.SetCeilingLightSector(sec, line->frontsector);
          }
        }
        line->special = 0;
        line->frontsector->bTransferSource = true;
        break;
      case LNSPEC_SectorSetFriction:
        if (line->arg2) {
          // allow setting friction amount from parameter
          length = line->arg2 <= 200 ? line->arg2 : 200;
        } else {
          length = int(Length((*line->v2)-(*line->v1)));
        }
        SetSectorFriction(InLevel, line->arg1, length, false);
        line->special = 0;
        break;
      case LNSPEC_TransferHeights:
        //if (line->arg2) print("transferheights: flags=0x%02x", line->arg2);
        MakeHeightSec(InLevel, line);
        line->special = 0;
        break;
      case LNSPEC_StaticInit:
        StaticInit(InLevel, line);
        line->special = 0;
        break;
    }
  }

  // initialise initial friction values
  foreach (auto i; 0..InLevel.Sectors.length) {
    InLevel.Sectors[i].Friction = EntityEx::FRICTION_NORMAL;
    // handle Sky2 sector special
    if (InLevel.Sectors[i].special == SECSPEC_Sky2) {
      InLevel.Sectors[i].Sky = SKY_FROM_SIDE;
    }
  }

  // process translucent lines
  foreach (auto i; 0..InLevel.Lines.length) {
    line_t *line = &InLevel.Lines[i];
    switch (line->special) {
      case LNSPEC_LineTranslucent:
        alpha = fclamp(float(line->arg2)/255.0, 0, 255);
        if (line->arg1) {
          foreach (auto j; 0..InLevel.Lines.length) {
            if (IsLineTagEqual(&InLevel.Lines[j], line->arg1)) {
              InLevel.Lines[j].alpha = alpha;
              if (line->arg3 == 1) InLevel.Lines[j].flags |= ML_ADDITIVE;
            }
          }
        } else {
          line->alpha = alpha;
          if (line->arg3 == 1) line->flags |= ML_ADDITIVE;
        }
        line->special = 0;
        break;
      case LNSPEC_GlassBreak:
        if (line->arg2 != 255) line->alpha = fclamp(float(line->arg2)/255.0, 0, 255);
        break;
    }
  }

  // spawn polyobjects
  foreach (auto i; 0..InLevel.Things.length) {
    mthing_t *mthing = &InLevel.Things[i];
    switch (mthing->type) {
      case PO_SPAWN_TYPE_HEXEN:
      case PO_SPAWNCRUSH_TYPE_HEXEN:
        if (!bUseHexenPolyobjTypes) break;
        goto case; //k8: is it right???
      case PO_SPAWN_TYPE:
      case PO_SPAWNCRUSH_TYPE:
      case PO_SPAWNHURT_TYPE:
        // Polyobj StartSpot Pt.
        InLevel.SpawnPolyobj(mthing->x, mthing->y, mthing->angle,
          mthing->type == PO_SPAWNCRUSH_TYPE_HEXEN ||
          mthing->type == PO_SPAWNCRUSH_TYPE ||
          mthing->type == PO_SPAWNHURT_TYPE,
          mthing->type == PO_SPAWNHURT_TYPE);
        mthing->type = 0;
        break;
      case PO_ANCHOR_TYPE_HEXEN:
        if (!bUseHexenPolyobjTypes) break;
        goto case; //k8: is it right???
      case PO_ANCHOR_TYPE:
        // Polyobj Anchor Pt.
        InLevel.AddPolyAnchorPoint(mthing->x, mthing->y, mthing->angle);
        mthing->type = 0;
        break;
    }
  }
}


//==========================================================================
//
//  FindWeaponSlot
//
//==========================================================================
private final bool FindWeaponSlot (class!Weapon WpnClass, out int Slot, out int Index, optional int Position, bool exact) {
  if (WpnClass) {
    class!Weapon wpnrep = class!Weapon(GetClassReplacement(WpnClass));
    if (!wpnrep) wpnrep = WpnClass;
    foreach (auto i; 0..PlayerPawn::NUM_WEAPON_SLOTS) {
      foreach (auto j; 0..PlayerPawn::MAX_WEAPONS_PER_SLOT) {
        class!Weapon swc = WeaponSlots[i].Weapons[j];
        if (!swc) continue;
        if (swc != WpnClass) {
          if (exact) continue;
          class!Weapon swcrep = class!Weapon(GetClassReplacement(swc));
          if (!swcrep) swcrep = swc;
          if (swcrep != WpnClass && swc != wpnrep && swcrep != wpnrep) continue;
        }
        //print("***FOUND '%C' as '%C' (exact:%B) at (%d:%d) (Position(%B)=%d)", WpnClass, swc, exact, i, j, specified_Position, Position);
        Slot = i;
        // assign weapon position, if it's already set
        Index = clamp((Position ? Position : j), 0, PlayerPawn::MAX_WEAPONS_PER_SLOT-1);
        return true;
      }
    }
  }
  Slot = -1;
  Index = -1;
  return false;
}


//==========================================================================
//
//  AddWeaponToSlot
//
//==========================================================================
bool AddWeaponToSlot (int Slot, class!Weapon WeaponClass) {
  if (!WeaponClass) return false;
  foreach (auto i; 0..PlayerPawn::MAX_WEAPONS_PER_SLOT) {
    class!Weapon swc = WeaponSlots[Slot].Weapons[i];
    if (swc) {
      if (swc == WeaponClass || GetClassReplacement(swc) == GetClassReplacement(WeaponClass)) {
        // already there
        return true;
      }
    }
  }
  foreach (auto i; 0..PlayerPawn::MAX_WEAPONS_PER_SLOT) {
    if (!WeaponSlots[Slot].Weapons[i]) {
      class!Weapon wwrepl = class!Weapon(GetClassReplacement(WeaponClass));
      if (!wwrepl) wwrepl = WeaponClass;
      WeaponSlots[Slot].Weapons[i] = wwrepl;
      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  CmdWeaponSection
//
//==========================================================================
override void CmdWeaponSection (string Section) {
  if (!Section) {
    print("Usage: WeaponSection <section name>");
    return;
  }
  // unused right now
}


//==========================================================================
//
//  CmdSetSlot
//
//==========================================================================
override void CmdSetSlot (ref array!string Args) {
  if (Args.Num < 2) {
    print("Usage: SetSlot <slot> <weapon> ...");
    return;
  }

  // get slot number
  bool err;
  int Slot = atoi(Args[1], out err);
  if (err || Slot < 0 || Slot >= PlayerPawn::NUM_WEAPON_SLOTS) {
    print("Bad weapon slot number");
    return;
  }

  // slot '0' means '10'
  if (Slot == 0) Slot = 10;

  // clear slot
  foreach (auto i; 0..PlayerPawn::MAX_WEAPONS_PER_SLOT) WeaponSlots[Slot].Weapons[i] = none;

  if (Args.Num == 2) {
    print("Slot cleared");
  } else {
    foreach (auto i; 2..Args.length) {
      // standarize class name here, since I've found people writing in all types of mixed cases...
      class!Weapon Cls = class!Weapon(FindClassNoCase(name(Args[i])));
      if (!Cls) {
        print("`%s` is not a weapon", Args[i]);
      } else if (!AddWeaponToSlot(Slot, Cls)) {
        print("Couldn't add `%s` to slot `%d`", Args[i], Slot);
      }
    }
  }
}


//==========================================================================
//
//  CmdAddSlotDefault
//
//==========================================================================
override void CmdAddSlotDefault (ref array!string Args) {
  if (Args.Num != 3) {
    print("Usage: AddSlotDefault <slot> <weapon>");
    return;
  }

  // get slot number
  bool err;
  int Slot = atoi(Args[1], out err);
  if (err || Slot < 0 || Slot >= PlayerPawn::NUM_WEAPON_SLOTS) {
    print("Bad weapon slot number");
    return;
  }

  // slot '0' means '10'
  if (Slot == 0) Slot = 10;

  // standarize class name here, since I've found people writing in all types of mixed cases...
  class!Weapon Cls = class!Weapon(FindClassNoCase(name(Args[2])));
  if (!Cls) {
    print("`%s` is not a weapon", Args[2]);
    return;
  }

  int TmpSlot;
  int TmpIndex;
  if (!FindWeaponSlot(Cls, TmpSlot, TmpIndex, exact:false)) {
    if (!AddWeaponToSlot(Slot, Cls)) {
      print("Couldn\'t add `%s` to slot `%d`", Args[2], Slot);
    }
  }
}


defaultproperties {
  contents_alpha[CONTENTS_EMPTY] = 1.0;
  contents_alpha[CONTENTS_WATER] = 0.5;
  contents_alpha[CONTENTS_LAVA] = 0.8;
  contents_alpha[CONTENTS_NUKAGE] = 0.6;
  contents_alpha[CONTENTS_SLIME] = 0.55;
  contents_alpha[CONTENTS_HELLSLIME] = 0.7;
  contents_alpha[CONTENTS_BLOOD] = 0.85;
  contents_alpha[CONTENTS_SLUDGE] = 0.7;
  contents_alpha[CONTENTS_HAZARD] = 0.7;


  windTab[0] = 5.0/32.0;
  windTab[1] = 10.0/32.0;
  windTab[2] = 25.0/32.0;

  pushTab[0] = 5.0*35.0*35.0/32.0;
  pushTab[1] = 10.0*35.0*35.0/32.0;
  pushTab[2] = 25.0*35.0*35.0/32.0;
  pushTab[3] = 30.0*35.0*35.0/32.0;
  pushTab[4] = 35.0*35.0*35.0/32.0;

  opposite[0] = DI_WEST;
  opposite[1] = DI_SOUTHWEST;
  opposite[2] = DI_SOUTH;
  opposite[3] = DI_SOUTHEAST;
  opposite[4] = DI_EAST;
  opposite[5] = DI_NORTHEAST;
  opposite[6] = DI_NORTH;
  opposite[7] = DI_NORTHWEST;
  opposite[8] = DI_NODIR;

  diags[0] = DI_NORTHWEST;
  diags[1] = DI_NORTHEAST;
  diags[2] = DI_SOUTHWEST;
  diags[3] = DI_SOUTHEAST;

  xspeed[0] = 1.0;
  xspeed[1] = 0.7171630859;
  xspeed[2] = 0.0;
  xspeed[3] = -0.7171630859;
  xspeed[4] = -1.0;
  xspeed[5] = -0.7171630859;
  xspeed[6] = 0.0;
  xspeed[7] = 0.7171630859;

  yspeed[0] = 0.0;
  yspeed[1] = 0.7171630859;
  yspeed[2] = 1.0;
  yspeed[3] = 0.7171630859;
  yspeed[4] = 0.0;
  yspeed[5] = -0.7171630859;
  yspeed[6] = -1.0;
  yspeed[7] = -0.7171630859;

  ramp1[0] = 0xfffff31b; ramp1[1] = 0xefdfab27; ramp1[2] = 0xdfbf772f; ramp1[3] = 0xcf9f4f33;
  ramp1[4] = 0xbf7f3b2b; ramp1[5] = 0xaf632f1f; ramp1[6] = 0x9f4b2313; ramp1[7] = 0x8f2f170b;
  ramp1[8] = 0x7f7f3b2b; ramp1[9] = 0x6f632f1f; ramp1[10] = 0x5f4b2313; ramp1[11] = 0x4f2f170b;
  ramp1[12] = 0x3f7f3b2b; ramp1[13] = 0x2f632f1f; ramp1[14] = 0x1f4b2313; ramp1[15] = 0x0f2f170b;
  ramp2[0] = 0xfffff31b; ramp2[1] = 0xefefcb1f; ramp2[2] = 0xdfdfab27; ramp2[3] = 0xcfcf8f2b;
  ramp2[4] = 0xbfbf772f; ramp2[5] = 0xafaf632f; ramp2[6] = 0x9f8f4333; ramp2[7] = 0x8f733723;
  ramp2[8] = 0x7fbf772f; ramp2[9] = 0x6faf632f; ramp2[10] = 0x5f8f4333; ramp2[11] = 0x4f733723;
  ramp2[12] = 0x3fbf772f; ramp2[13] = 0x2faf632f; ramp2[14] = 0x1f8f4333; ramp2[15] = 0x0f733723;

  NonMonsterAngleIncrements = 45;
  InvDefaultMaxAmount = 25;
  IceMoveFactor = 0.5;
  GibsHealthFactor = 0.5;
  DehExplosionStyle = 255;
  DehExplosionAlpha = 0.666;
}
