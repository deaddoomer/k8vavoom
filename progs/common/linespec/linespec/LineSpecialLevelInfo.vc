//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2021 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class LineSpecialLevelInfo : LevelInfo;

const int
  STROBEBRIGHT = 5,
  FASTDARK     = 15,
  SLOWDARK     = 35;

// map things flags
// WARNING! keep in sync with C++ code!
const int
  // vanilla flags
  MTF_AMBUSH                = 0x0008, // deaf monsters/do not react to sound
  MTF_UNTRANSLATED_MP       = 0x0010,
  // Boom
  MTF_UNTRANSLATED_NO_DM    = 0x0020,
  MTF_UNTRANSLATED_NO_COOP  = 0x0040,
  // MBF
  MTF_UNTRANSLATED_FRIENDLY = 0x0080,

  MTF_DORMANT     = 0x0010, // the thing is dormant
  MTF_GSINGLE     = 0x0100, // appearing in game modes
  MTF_GCOOP       = 0x0200,
  MTF_GDEATHMATCH = 0x0400,
  MTF_SHADOW      = 0x0800,
  MTF_ALTSHADOW   = 0x1000,
  MTF_FRIENDLY    = 0x2000,
  MTF_STANDSTILL  = 0x4000,

  MTF2_CLASS_BASE = 0x000010000,
  MTF2_CLASS_MASK = 0x0ffff0000,
  MTF2_FIGHTER    = 0x000010000, // thing appearing in player classes
  MTF2_CLERIC     = 0x000020000,
  MTF2_MAGE       = 0x000040000;


bitenum {
  BLOCKF_CREATURES, // (1): Blocks walking things (players and enemies)
  BLOCKF_MONSTERS, // (2): Blocks monsters (but not players)
  BLOCKF_PLAYERS, // (4): Blocks players
  BLOCKF_FLOATERS, // (8): Blocks floating creatures
  BLOCKF_PROJECTILES, // (16): Blocks projectiles
  BLOCKF_EVERYTHING, // (32): Blocks all of the above
  BLOCKF_RAILING, // (64): Emulates Strife's railing behavior (blocks actors under 32 units of the line)
  BLOCKF_USE, // (128): Blocks switches from being used across the line
  BLOCKF_SIGHT, // (256): Blocks monster line of sight
  BLOCKF_HITSCAN, // (512): Blocks hitscan attacks
  BLOCKF_SOUND, // (1024): Blocks sound
}

// for 3d pobj `moveflags`
const int POBJ_MOVE_NORMAL = 0;
bitenum {
  POBJ_MOVE_OVERRIDE,
  POBJ_MOVE_NOLINK,
}


static final int ConvertLineBlockingFlags (int Arg2) {
  int setFlags = 0;
  if (Arg2&BLOCKF_CREATURES) setFlags |= ML_BLOCKING;
  if (Arg2&BLOCKF_MONSTERS) setFlags |= ML_BLOCKMONSTERS;
  if (Arg2&BLOCKF_PLAYERS) setFlags |= ML_BLOCKPLAYERS;
  if (Arg2&BLOCKF_FLOATERS) setFlags |= ML_BLOCK_FLOATERS;
  if (Arg2&BLOCKF_PROJECTILES) setFlags |= ML_BLOCKPROJECTILE;
  if (Arg2&BLOCKF_EVERYTHING) setFlags |= ML_BLOCKEVERYTHING;
  if (Arg2&BLOCKF_RAILING) setFlags |= ML_RAILING;
  if (Arg2&BLOCKF_USE) setFlags |= ML_BLOCKUSE;
  if (Arg2&BLOCKF_SIGHT) setFlags |= ML_BLOCKSIGHT;
  if (Arg2&BLOCKF_HITSCAN) setFlags |= ML_BLOCKHITSCAN;
  if (Arg2&ML_SOUNDBLOCK) setFlags |= ML_SOUNDBLOCK;
  return setFlags;
}


enum {
  pt_static,
  pt_explode,
  pt_explode2,
  pt_ice_chunk,
  pt_rail,
  pt_fountain,
  pt_spark,
  pt_fading,
};

// flags for SectorDamage
const int DAMAGE_PLAYERS = 1;
const int DAMAGE_NONPLAYERS = 2;
const int DAMAGE_IN_AIR = 4;
const int DAMAGE_SUBCLASSES_PROTECT = 8;

const int DEFAULT_BODYQUESIZE = 32;
const int DEFAULT_CORPSEQUEUESIZE = 64;

const int
  SECF_SILENT           = 1,
  SECF_NOFALLINGDAMAGE  = 2;

name DefaultDoorSound;
name DefaultCeilingSound;
name DefaultSilentCeilingSound;
name DefaultFloorSound;
name DefaultFloorAltSound;
name DefaultStairStepSound;
name DefaultPlatformSound;

bool bTeleportNewMapBothSides;
bool bCheckStrifeStartSpots;
bool bDefaultStopOnCrush;

bool bPuffSpawned;

int ExtPlayersBase;
string Lock103Message;

EntityEx CurrentSpeaker;
EntityEx CurrentSpeakingTo;
float OldSpeakerAngle;
int CurrentSpeechIndex;
bool ConversationSlideshow;

EntityEx[DEFAULT_BODYQUESIZE] bodyque;
int BodyQueSize;
int bodyqueslot;

// corpse queue for monsters
EntityEx[DEFAULT_CORPSEQUEUESIZE] corpseQueue;
int CorpseQueSize;
int corpseQueueSlot;


//==========================================================================
//
//  ClampSideOffsets
//
//==========================================================================
final void ClampSideOffsets (side_t *Side) {
  if (Side->Top.TextureOffset > 32767.0 || Side->Top.TextureOffset < -32768.0) Side->Top.TextureOffset = 0.0;
  if (Side->Bot.TextureOffset > 32767.0 || Side->Bot.TextureOffset < -32768.0) Side->Bot.TextureOffset = 0.0;
  if (Side->Mid.TextureOffset > 32767.0 || Side->Mid.TextureOffset < -32768.0) Side->Mid.TextureOffset = 0.0;
  if (Side->Top.RowOffset > 32767.0 || Side->Top.RowOffset < -32768.0) Side->Top.RowOffset = 0.0;
  if (Side->Bot.RowOffset > 32767.0 || Side->Bot.RowOffset < -32768.0) Side->Bot.RowOffset = 0.0;
  if (Side->Mid.RowOffset > 32767.0 || Side->Mid.RowOffset < -32768.0) Side->Mid.RowOffset = 0.0;
}


//==========================================================================
//
//  ClampSecPlaneOffsets
//
//==========================================================================
final void ClampSecPlaneOffsets (sec_plane_t *Plane) {
  if (Plane->xoffs > 32767.0 || Plane->xoffs < -32768.0) Plane->xoffs = 0.0;
  if (Plane->yoffs > 32767.0 || Plane->yoffs < -32768.0) Plane->yoffs = 0.0;
}


//==========================================================================
//
//  SpawnSpecials
//
//==========================================================================
override void SpawnSpecials () {
  ::SpawnSpecials();

  sector_t *sector;
  int i;

  if (Level.bLightning) {
    LightningThinker Lightning = SpawnThinker(LightningThinker);
    Lightning.Init();
  }

  // init special sectors
  foreach (i; 0..XLevel.Sectors.length) {
    sector = &XLevel.Sectors[i];
    if (!sector->special) continue;
    if (sector->special&SECSPEC_SECRET_MASK) ++TotalSecret; // secret sector
    switch (sector->special&SECSPEC_BASE_MASK) {
      case SECSPEC_LightPhased: // phased light
        // hardcoded base, use sector->lightlevel as the index
        SpawnPhasedLight(sector, 80, -1);
        sector->special &= ~SECSPEC_BASE_MASK;
        break;
      case SECSPEC_LightSequenceStart: // phased light sequence start
        SpawnLightSequence(sector, 1.0);
        sector->special &= ~SECSPEC_BASE_MASK;
        break;
        // specials 3 & 4 are used by the phased light sequences
      case SECSPEC_LightFlicker:
        SpawnLightFlash(sector);
        sector->special &= ~SECSPEC_BASE_MASK;
        break;
      case SECSPEC_LightStrobeFast:
        SpawnStrobeFlash(sector, FASTDARK, STROBEBRIGHT, 0);
        sector->special &= ~SECSPEC_BASE_MASK;
        break;
      case SECSPEC_LightStrobeSlow:
        SpawnStrobeFlash(sector, SLOWDARK, STROBEBRIGHT, 0);
        sector->special &= ~SECSPEC_BASE_MASK;
        break;
      case SECSPEC_LightStrobeFastDamage:
        SpawnStrobeFlash(sector, FASTDARK, STROBEBRIGHT, 0);
        break;
      case SECSPEC_LightGlow:
        SpawnGlowingLight(sector);
        sector->special &= ~SECSPEC_BASE_MASK;
        break;
      case SECSPEC_DoorCloseIn30:
        SpawnDoorCloseIn30(sector);
        break;
      case SECSPEC_LightSyncStrobeSlow:
        SpawnStrobeFlash(sector, SLOWDARK, STROBEBRIGHT, 1);
        sector->special &= ~SECSPEC_BASE_MASK;
        break;
      case SECSPEC_LightSyncStrobeFast:
        SpawnStrobeFlash(sector, FASTDARK, STROBEBRIGHT, 1);
        sector->special &= ~SECSPEC_BASE_MASK;
        break;
      case SECSPEC_DoorRaiseIn5Minutes:
        SpawnDoorRaiseIn5Mins(sector);
        break;
      case SECSPEC_LightFireFlicker:
        SpawnFireFlicker(sector);
        sector->special &= ~SECSPEC_BASE_MASK;
        break;
      case SECSPEC_ScrollEastLavaDamage:
        SpawnScrollingFloor(sector, -1, 0, 3);
        break;
      case SECSPEC_ScrollNorthSlow:
      case SECSPEC_ScrollNorthMedium:
      case SECSPEC_ScrollNorthFast:
        SpawnScrollingFloor(sector, 0, 1, (sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollNorthSlow);
        break;
      case SECSPEC_ScrollEastSlow:
      case SECSPEC_ScrollEastMedium:
      case SECSPEC_ScrollEastFast:
        SpawnScrollingFloor(sector, -1, 0, (sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollEastSlow);
        break;
      case SECSPEC_ScrollSouthSlow:
      case SECSPEC_ScrollSouthMedium:
      case SECSPEC_ScrollSouthFast:
        SpawnScrollingFloor(sector, 0, -1, (sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollSouthSlow);
        break;
      case SECSPEC_ScrollWestSlow:
      case SECSPEC_ScrollWestMedium:
      case SECSPEC_ScrollWestFast:
        SpawnScrollingFloor(sector, 1, 0, (sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollWestSlow);
        break;
      case SECSPEC_ScrollNorthWestSlow:
      case SECSPEC_ScrollNorthWestMedium:
      case SECSPEC_ScrollNorthWestFast:
        SpawnScrollingFloor(sector, 1, 1, (sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollNorthWestSlow);
        break;
      case SECSPEC_ScrollNorthEastSlow:
      case SECSPEC_ScrollNorthEastMedium:
      case SECSPEC_ScrollNorthEastFast:
        SpawnScrollingFloor(sector, -1, 1, (sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollNorthEastSlow);
        break;
      case SECSPEC_ScrollSouthEastSlow:
      case SECSPEC_ScrollSouthEastMedium:
      case SECSPEC_ScrollSouthEastFast:
        SpawnScrollingFloor(sector, -1, -1, (sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollSouthEastSlow);
        break;
      case SECSPEC_ScrollSouthWestSlow:
      case SECSPEC_ScrollSouthWestMedium:
      case SECSPEC_ScrollSouthWestFast:
        SpawnScrollingFloor(sector, 1, -1, (sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollSouthWestSlow);
        break;
      case SECSPEC_ScrollEast5:
      case SECSPEC_ScrollEast10:
      case SECSPEC_ScrollEast25:
      case SECSPEC_ScrollEast30:
      case SECSPEC_ScrollEast35:
        SpawnScrollingFloor(sector, -1, 0, (sector->special&SECSPEC_BASE_MASK)-SECSPEC_ScrollEast5);
        break;
    }
  }

  // init line effects
  foreach (i; 0..XLevel.Lines.length) {
    line_t *line = &XLevel.Lines[i];
    if (!line.special) continue;
    bool notinteresting = false;
    switch (line.special) {
      case LNSPEC_ScrollTextureLeft:
        SpawnWallScroller(line, 1, 0);
        line.special = 0;
        line.flags |= ML_NODECAL;
        break;
      case LNSPEC_ScrollTextureRight:
        SpawnWallScroller(line, -1, 0);
        line.special = 0;
        line.flags |= ML_NODECAL;
        break;
      case LNSPEC_ScrollTextureUp:
        SpawnWallScroller(line, 0, 1);
        line.special = 0;
        line.flags |= ML_NODECAL;
        break;
      case LNSPEC_ScrollTextureDown:
        SpawnWallScroller(line, 0, -1);
        line.special = 0;
        line.flags |= ML_NODECAL;
        break;
      case LNSPEC_ScrollTextureBoth:
        SpawnTextureBothScroller(line);
        line.special = 0;
        line.flags |= ML_NODECAL;
        break;
      case LNSPEC_ScrollTextureModel:
        SpawnScrollTextureModel(line);
        line.special = 0;
        line.flags |= ML_NODECAL;
        break;
      case LNSPEC_ScrollFloor:
        SpawnScrollFloor(line);
        line.special = 0;
        notinteresting = true;
        break;
      case LNSPEC_ScrollCeiling:
        SpawnScrollCeiling(line);
        line.special = 0;
        notinteresting = true;
        break;
      case LNSPEC_ScrollTextureOffsets:
        SpawnWallOffsetsScroller(line);
        line.special = 0;
        line.flags |= ML_NODECAL;
        break;
      case LNSPEC_TransferWallLight:
        SpawnTransferWallLight(line);
        line.special = 0;
        notinteresting = true;
        break;
    }
    // FIXME: if this line has special, and it has midtex, and it is a closed sector, then move midtex to toptex
    //        found in some Boom maps like Icarus
    //        i should write a proper fix for this!
    if (!line.special && !notinteresting && line.sidenum[0] >= 0 && line.sidenum[1] >= 0) {
      // ok, it is two-sided; check for closed sector
      bool frontClosed = (line.frontsector.floor.normal.z == 1 && line.frontsector.ceiling.normal.z == -1 &&
                          line.frontsector.floor.minz == line.frontsector.ceiling.minz);
      bool backClosed = (line.backsector.floor.normal.z == 1 && line.backsector.ceiling.normal.z == -1 &&
                         line.backsector.floor.minz == line.backsector.ceiling.minz);
      if (frontClosed != backClosed && (frontClosed || backClosed)) {
        // ok, some sector is closed, check if we need to transfer texture
        int sdidx = (backClosed ? 0 : 1);
        side_t *fside = &XLevel.Sides[line.sidenum[sdidx]];
        if (!fside.TopTexture && fside.MidTexture && !fside.BottomTexture) {
          //print("ldef #%s: toptex=%s; csn=%s; midtex=%s; bottex=%s", line-&XLevel.Lines[0], fside.TopTexture, sdidx, fside.MidTexture, fside.BottomTexture);
          fside.TopTexture = fside.MidTexture;
          fside.Top = fside.Mid;
          fside.MidTexture = 0;
          // remove ceiling sky texture, if any
          sector_t *bsec = (backClosed ? line.backsector : line.frontsector);
          if (bsec.ceiling.pic == Level.Game.skyflatnum) bsec.ceiling.pic = bsec.floor.pic;
        }
      }
    }
  }

  SpawnPushers();
}


//==========================================================================
//
//  ActivateLine
//
//==========================================================================
/*final*/ bool ActivateLine (line_t *Line, EntityEx A, int Side, int ActivationType, optional out bool buttonSuccess) {
  int lineActivation;
  bool repeat;
  //bool buttonSuccess;
  bool changeBack;

  if (!CheckActivation(ActivationType, Line, Side, A)) return false;

  lineActivation = Line->SpacFlags;
  repeat = Line->flags&ML_REPEAT_SPECIAL;
  buttonSuccess = ExecuteActionSpecial(Line->special, Line->arg1, Line->arg2, Line->arg3, Line->arg4, Line->arg5, Line, Side, A);
  changeBack = (Line->special == LNSPEC_GlassBreak && (Line->flags&ML_TWOSIDED) && buttonSuccess);
  if ((lineActivation&(SPAC_Use|SPAC_Impact|SPAC_UseThrough)) && buttonSuccess) {
    ubyte Quest;
    ChangeSwitchTexture(Line->sidenum[0], repeat,
      (Line->special == LNSPEC_ExitNormal ||
       Line->special == LNSPEC_ExitSecret ||
       Line->special == LNSPEC_TeleportNewMap ||
       Line->special == LNSPEC_TeleportEndGame
       ? 'switches/exitbutn' : 'switches/normbutn'), Quest);
  }
  if (changeBack) XLevel.Sides[Line->sidenum[1]].MidTexture = XLevel.Sides[Line->sidenum[0]].MidTexture;
  if (!repeat && buttonSuccess) Line->special = 0; // clear the special on non-retriggerable lines
  return true;
}


//==========================================================================
//
//  CheckActivation
//
//==========================================================================
/*final*/ bool CheckActivation (int activationType, line_t *line, int Side, EntityEx A) {
  if ((line->flags&ML_FIRSTSIDEONLY) && Side == 1) return false;

  int lineActivation = line->SpacFlags;
  if (lineActivation&SPAC_UseThrough) {
    lineActivation |= SPAC_Use;
  } else if (line->special == LNSPEC_Teleport &&
             (lineActivation&SPAC_Cross) && activationType == SPAC_PCross &&
             A && A.bMissile)
  {
    // let missiles use regular player teleports
    lineActivation |= SPAC_PCross;
  }

  // BOOM's generalized line types that allow monster use can actually be activated by anything except projectiles
  if (lineActivation&SPAC_AnyCross) lineActivation |= SPAC_Cross|SPAC_MCross;
  if (!(lineActivation&activationType)) {
    if (activationType == SPAC_Use && (lineActivation&SPAC_MUse) && !A.bIsPlayer && A.bCanUseWalls) return true;
    if (activationType == SPAC_Push && (lineActivation&SPAC_MPush) && !A.bIsPlayer && A.bActivatePushWall) return true;
    if (activationType != SPAC_MCross || !(lineActivation&SPAC_Cross)) return false;
  }

  if (line.locknumber && !CheckLock(A, line.locknumber, door:true)) return false;

  if (A && !A.bIsPlayer && !A.bMissile &&
      !(line->flags&ML_MONSTERSCANACTIVATE) &&
      (activationType != SPAC_MCross || !(lineActivation&SPAC_MCross)))
  {
    // with lax monster activation monsters can activate several line
    // specials even when not marked as monster activateable
    // this is the default for non-Hexen maps in Hexen format
    if (!Level.bLaxMonsterActivation) return false;

    if ((activationType == SPAC_Use || activationType == SPAC_Push) && (line->flags&ML_SECRET)) return false; // never open secret doors

    bool noway = true;
    switch (activationType) {
      case SPAC_MCross:
        if (!(lineActivation&SPAC_MCross)) {
          switch (line->special) {
            case LNSPEC_DoorRaise:
              if (line->arg2 >= 64) break;
              goto case; //k8: is it right???
            case LNSPEC_PlatDownWaitUpStay:
            case LNSPEC_Teleport:
            case LNSPEC_TeleportNoFog:
            case LNSPEC_TeleportNoStop:
            case LNSPEC_PlatDownWaitUpStayLip:
            case LNSPEC_TeleportLine:
              noway = false;
          }
        } else {
          noway = false;
        }
        break;
      case SPAC_Use:
      case SPAC_Push:
        switch (line->special) {
          case LNSPEC_DoorRaise:
            if (line->arg1 == 0 && line->arg2 < 64) noway = false;
            break;
          case LNSPEC_Teleport:
          case LNSPEC_TeleportNoFog:
          case LNSPEC_TeleportNoStop:
            noway = false;
        }
        break;
      default:
        noway = false;
        break;
    }
    return !noway;
  }
  if (activationType == SPAC_MCross && !(lineActivation&SPAC_MCross) && !(line->flags&ML_MONSTERSCANACTIVATE)) return false;
  return true;
}


//==========================================================================
//
//  ExecuteActionSpecial
//
//==========================================================================
override int ExecuteActionSpecial (int Special, int Arg1, int Arg2, int Arg3,
                                   int Arg4, int Arg5, line_t *Line, int Side, Entity E)
{
  EntityEx A = EntityEx(E);
  int buttonSuccess = false;
  switch (Special) {
    case LNSPEC_PolyStartLine:
      break;
    case LNSPEC_PolyRotateLeft:
      buttonSuccess = EV_RotatePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5, 1, false);
      break;
    case LNSPEC_PolyRotateRight:
      buttonSuccess = EV_RotatePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5, -1, false);
      break;
    case LNSPEC_PolyMove:
      buttonSuccess = EV_MovePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5, false, false);
      break;
    case LNSPEC_PolyExplicitLine: // Only used in initialization
      break;
    case LNSPEC_PolyMoveTimes8:
      buttonSuccess = EV_MovePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5, true, false);
      break;
    case LNSPEC_PolyDoorSwing:
      buttonSuccess = EV_OpenPolyDoor(Line, Arg1, Arg2, Arg3, Arg4, Arg5, PolyobjDoor::PODOOR_SWING);
      break;
    case LNSPEC_PolyDoorSlide:
      buttonSuccess = EV_OpenPolyDoor(Line, Arg1, Arg2, Arg3, Arg4, Arg5, PolyobjDoor::PODOOR_SLIDE);
      break;
    case LNSPEC_DoorClose:
      buttonSuccess = EV_DoDoor(Arg1, Arg2, Arg3, Arg4, Arg5, VerticalDoor::DOOREV_Close, Line, A);
      break;
    case LNSPEC_DoorOpen:
      buttonSuccess = EV_DoDoor(Arg1, Arg2, Arg3, Arg4, Arg5, VerticalDoor::DOOREV_Open, Line, A);
      break;
    case LNSPEC_DoorRaise:
      buttonSuccess = EV_DoDoor(Arg1, Arg2, Arg3, Arg4, Arg5, VerticalDoor::DOOREV_Raise, Line, A);
      break;
    case LNSPEC_DoorLockedRaise:
      if (CheckLock(A, Arg4, true)) buttonSuccess = EV_DoDoor(Arg1, Arg2, Arg3, Arg4, Arg5, VerticalDoor::DOOREV_RaiseLocked, Line, A);
      break;
    case LNSPEC_DoorAnimated:
      buttonSuccess = EV_TextureChangeDoor(Arg1, Arg2, Arg3, Arg4, Arg5, Line, A);
      break;
    case LNSPEC_Autosave:
      AutoSave();
      buttonSuccess = true;
      break;
    case LNSPEC_ThingRaise:
      buttonSuccess = EV_ThingRaise(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_StartConversation:
      buttonSuccess = EV_StartConversation(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_ThingStop:
      buttonSuccess = EV_ThingStop(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_FloorLowerByValue:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_LowerByValue, Line);
      break;
    case LNSPEC_FloorLowerToLowest:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_LowerToLowest, Line);
      break;
    case LNSPEC_FloorLowerToNearest:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_LowerToNearest, Line);
      break;
    case LNSPEC_FloorRaiseByValue:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_RaiseByValue, Line);
      break;
    case LNSPEC_FloorRaiseToHighest:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_RaiseToHighest, Line);
      break;
    case LNSPEC_FloorRaiseToNearest:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_RaiseToNearest, Line);
      break;
    case LNSPEC_StairsBuildDownNormal:
      buttonSuccess = EV_BuildStairs(Arg1, Arg2, Arg3, Arg4, Arg5, StairStepMover::STAIRSEV_DownNormal);
      break;
    case LNSPEC_StairsBuildUpNormal:
      buttonSuccess = EV_BuildStairs(Arg1, Arg2, Arg3, Arg4, Arg5, StairStepMover::STAIRSEV_UpNormal);
      break;
    case LNSPEC_FloorRaiseAndCrush:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_RaiseAndCrush, Line);
      break;
    case LNSPEC_PillarBuild:  // (no crushing)
      buttonSuccess = EV_BuildPillar(Arg1, Arg2, Arg3, Arg4, Arg5, false);
      break;
    case LNSPEC_PillarOpen:
      buttonSuccess = EV_OpenPillar(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_StairsBuildDownSync:
      buttonSuccess = EV_BuildStairs(Arg1, Arg2, Arg3, Arg4, Arg5, StairStepMover::STAIRSEV_DownSync);
      break;
    case LNSPEC_StairsBuildUpSync:
      buttonSuccess = EV_BuildStairs(Arg1, Arg2, Arg3, Arg4, Arg5, StairStepMover::STAIRSEV_UpSync);
      break;
    case LNSPEC_ForceField:
      buttonSuccess = EV_ForceField(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_ClearForceField:
      buttonSuccess = EV_RemoveForceField(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_FloorRaiseByValueTimes8:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_RaiseByValueTimes8, Line);
      break;
    case LNSPEC_FloorLowerByValueTimes8:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_LowerByValueTimes8, Line);
      break;
    case LNSPEC_FloorMoveToValue:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_MoveToValue, Line);
      break;
    case LNSPEC_CeilingWaggle:
      buttonSuccess = EV_StartCeilingWaggle(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_TeleportZombieChanger:
      if (Side == 0) {
        // only teleport when crossing the front side of a line
        buttonSuccess = EV_Teleport(Arg1, Arg2, Arg3, Arg4, Arg5, A, Line, fog:true);
        if (A) A.SetPainState();
      }
      break;
    case LNSPEC_CeilingLowerByValue:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_LowerByValue, Line);
      break;
    case LNSPEC_CeilingRaiseByValue:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_RaiseByValue, Line);
      break;
    case LNSPEC_CeilingCrushAndRaise:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_CrushAndRaise, Line);
      break;
    case LNSPEC_CeilingLowerAndCrush:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_LowerAndCrush, Line);
      break;
    case LNSPEC_CeilingCrushStop:
      buttonSuccess = EV_CeilingCrushStop(Line, Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_CeilingCrushRaiseAndStay:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_CrushRaiseAndStay, Line);
      break;
    case LNSPEC_FloorCrushStop:
      buttonSuccess = EV_FloorCrushStop(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_CeilingMoveToValue:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_MoveToValue, Line);
      break;
    case LNSPEC_GlassBreak:
      buttonSuccess = EV_GlassBreak(Arg1, Arg2, Arg3, Arg4, Arg5, Line, A);
      break;
    case LNSPEC_ScrollWall:
      buttonSuccess = EV_ScrollWall(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_LineSetTextureOffset:
      buttonSuccess = EV_LineSetTextureOffset(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_SectorChangeFlags:
      buttonSuccess = EV_SectorChangeFlags(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_PlatPerpetualRaise:
      buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5, Platform::PLATEV_PerpetualRaise, Line);
      break;
    case LNSPEC_PlatStop:
      buttonSuccess = EV_StopPlat(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_PlatDownWaitUpStay:
      buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5, Platform::PLATEV_DownWaitUpStay, Line);
      break;
    case LNSPEC_PlatDownByValueWaitUpStay:
      buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5, Platform::PLATEV_DownByValueWaitUpStay, Line);
      break;
    case LNSPEC_PlatUpWaitDownStay:
      buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5, Platform::PLATEV_UpWaitDownStay, Line);
      break;
    case LNSPEC_PlatUpByValueWaitDownStay:
      buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5, Platform::PLATEV_UpByValueWaitDownStay, Line);
      break;
    case LNSPEC_FloorLowerTimes8Instant:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_LowerTimes8Instant, Line);
      break;
    case LNSPEC_FloorRaiseTimes8Instant:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_RaiseTimes8Instant, Line);
      break;
    case LNSPEC_FloorMoveToValueTimes8:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_MoveToValueTimes8, Line);
      break;
    case LNSPEC_CeilingMoveToValueTimes8:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_MoveToValueTimes8, Line);
      break;
    case LNSPEC_Teleport:
      if (Side == 0) {
        // only teleport when crossing the front side of a line
        buttonSuccess = EV_Teleport(Arg1, Arg2, Arg3, Arg4, Arg5, A, Line, fog:true);
      }
      break;
    case LNSPEC_TeleportNoFog:
      if (Side == 0) {
        // only teleport when crossing the front side of a line
        buttonSuccess = EV_Teleport(Arg1, Arg2, Arg3, Arg4, Arg5, A, Line, fog:false);
      }
      break;
    case LNSPEC_TeleportNoStop:
      if (Side == 0) {
        // only teleport when crossing the front side of a line
        buttonSuccess = EV_Teleport(Arg1, Arg2, Arg3, Arg4, Arg5, A, Line, fog:true, keepMomentum:true, Special:Special);
      }
      break;
    case LNSPEC_ThrustThing:
      if (A && !Side) {
        // only thrust on side 0
        if (Arg2) A.Thrust(float(Arg1)*(90.0/64.0), float(Arg2));
        buttonSuccess = 1;
      }
      break;
    case LNSPEC_DamageThing:
      if (A) {
        if (Arg1) {
          A.Damage(none, none, Arg1, ModToDamageType(Arg2), spawnBlood:true);
        } else {
          // if arg1 is zero, then guarantee a kill
          A.Damage(none, none, 10000, ModToDamageType(Arg2), forced:true, spawnBlood:true);
        }
      }
      buttonSuccess = 1;
      break;
    case LNSPEC_TeleportNewMap:
      if (Side == 0 || bTeleportNewMapBothSides) {
        // only teleport when crossing the front side of a line
        // players must be alive to teleport
        if (!(A && A.bIsPlayer && A.Player.PlayerState == PST_DEAD)) {
          Completed(Arg1, Arg2, Arg3);
          buttonSuccess = true;
        }
      }
      break;
    case LNSPEC_TeleportEndGame:
      if (Side == 0) {
        // only teleport when crossing the front side of a line
        // players must be alive to teleport
        if (!(A && A.bIsPlayer && A.Player.PlayerState == PST_DEAD)) {
          buttonSuccess = true;
          if (Game.deathmatch) {
            // winning in deathmatch just goes back to map 1
            Completed(1, 0, 0);
          } else {
            // passing -1, -1 to G_Completed() starts the finale
            Completed(-1, -1, 0);
          }
        }
      }
      break;
    case LNSPEC_TeleportOther:
      buttonSuccess = EV_TeleportOther(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_TeleportGroup:
      buttonSuccess = EV_TeleportGroup(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_TeleportSector:
      buttonSuccess = EV_TeleportSector(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_ACSExecute:
      buttonSuccess = XLevel.StartACS(Arg1, Arg2, Arg3, Arg4, Arg5, A, Line, Side, false, false);
      break;
    case LNSPEC_ACSSuspend:
      buttonSuccess = XLevel.SuspendACS(Arg1, Arg2);
      break;
    case LNSPEC_ACSTerminate:
      buttonSuccess = XLevel.TerminateACS(Arg1, Arg2);
      break;
    case LNSPEC_ACSLockedExecute:
      if (CheckLock(A, Arg5, false)) buttonSuccess = XLevel.StartACS(Arg1, Arg2, Arg3, Arg4, 0, A, Line, Side, false, false);
      break;
    case LNSPEC_ACSExecuteWithResult:
      buttonSuccess = XLevel.StartACS(Arg1, 0, Arg2, Arg3, Arg4, A, Line, Side, true, true);
      break;
    case LNSPEC_ACSLockedExecuteDoor:
      if (CheckLock(A, Arg5, true)) buttonSuccess = XLevel.StartACS(Arg1, Arg2, Arg3, Arg4, 0, A, Line, Side, false, false);
      break;

    case LNSPEC_PolyobjStop:
      buttonSuccess = EV_StopPoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5, 1, false);
      break;

    case LNSPEC_PolyobjMoveToSpot:
      buttonSuccess = EV_MovePolyToSpot(Line, Arg1, Arg2, Arg3, Arg4, Arg5, 1, false);
      break;
    case LNSPEC_PolyobjMoveToSpotOverride:
      buttonSuccess = EV_MovePolyToSpot(Line, Arg1, Arg2, Arg3, Arg4, Arg5, 1, true);
      break;

    case LNSPEC_PolyRotateLeftOverride:
      buttonSuccess = EV_RotatePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5, 1, true);
      break;
    case LNSPEC_PolyRotateRightOverride:
      buttonSuccess = EV_RotatePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5, -1, true);
      break;
    case LNSPEC_PolyMoveOverride:
      buttonSuccess = EV_MovePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5, false, true);
      break;
    case LNSPEC_PolyMoveTimes8Override:
      buttonSuccess = EV_MovePoly(Line, Arg1, Arg2, Arg3, Arg4, Arg5, true, true);
      break;
    case LNSPEC_PillarBuildCrush:
      buttonSuccess = EV_BuildPillar(Arg1, Arg2, Arg3, Arg4, Arg5, true);
      break;
    case LNSPEC_FloorAndCeilingLowerByValue:
      buttonSuccess = EV_DoElevator(Arg1, Arg2, Arg3, Arg4, Arg5, Elevator::ELEVEV_Lower, Line);
      break;
    case LNSPEC_FloorAndCeilingRaiseByValue:
      buttonSuccess = EV_DoElevator(Arg1, Arg2, Arg3, Arg4, Arg5, Elevator::ELEVEV_Raise, Line);
      break;
    case LNSPEC_LightForceLightning:
      buttonSuccess = true;
      ForceLightning(Arg1);
      break;
    case LNSPEC_LightRaiseByValue:
      buttonSuccess = EV_LightRaiseByValue(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_LightLowerByValue:
      buttonSuccess = EV_LightLowerByValue(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_LightChangeToValue:
      buttonSuccess = EV_LightChangeToValue(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_LightFade:
      buttonSuccess = EV_SpawnLight(Arg1, Arg2, Arg3, Arg4, Arg5, LightEffect::LIGHTEV_Fade);
      break;
    case LNSPEC_LightGlow:
      buttonSuccess = EV_SpawnLight(Arg1, Arg2, Arg3, Arg4, Arg5, LightEffect::LIGHTEV_Glow);
      break;
    case LNSPEC_LightFlicker:
      buttonSuccess = EV_SpawnLight(Arg1, Arg2, Arg3, Arg4, Arg5, LightEffect::LIGHTEV_Flicker);
      break;
    case LNSPEC_LightStrobe:
      buttonSuccess = EV_SpawnLight(Arg1, Arg2, Arg3, Arg4, Arg5, LightEffect::LIGHTEV_Strobe);
      break;
    case LNSPEC_LightStop:
      buttonSuccess = EV_LightStop(Arg1);
      break;
    case LNSPEC_ThingDamage:
      buttonSuccess = EV_ThingDamage(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_QuakeTremor:
      buttonSuccess = A_LocalQuake(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_ThingMove:
      buttonSuccess = EV_ThingMove(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_ThingSetSpecial:
      buttonSuccess = EV_ThingSetSpecial(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_ThrustThingZ:
      buttonSuccess = EV_ThrustThingZ(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_UsePuzzleItem:
      buttonSuccess = EV_LineSearchForPuzzleItem(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_ThingActivate:
      buttonSuccess = EV_ThingActivate(Arg1, A);
      break;
    case LNSPEC_ThingDeactivate:
      buttonSuccess = EV_ThingDeactivate(Arg1, A);
      break;
    case LNSPEC_ThingRemove:
      buttonSuccess = EV_ThingRemove(Arg1, A);
      break;
    case LNSPEC_ThingDestroy:
      buttonSuccess = EV_ThingDestroy(Arg1, Arg2, A);
      break;
    case LNSPEC_ThingProjectile:
      buttonSuccess = EV_ThingProjectile(Arg1, Arg2, Arg3, Arg4, Arg5, 0, 0, '', A);
      break;
    case LNSPEC_ThingSpawn:
      buttonSuccess = EV_ThingSpawn(Arg1, Arg2, Arg3, Arg4, Arg5, true, false, A);
      break;
    case LNSPEC_ThingProjectileGravity:
      buttonSuccess = EV_ThingProjectile(Arg1, Arg2, Arg3, Arg4, Arg5, 1, 0, '', A);
      break;
    case LNSPEC_ThingSpawnNoFog:
      buttonSuccess = EV_ThingSpawn(Arg1, Arg2, Arg3, Arg4, Arg5, false, false, A);
      break;
    case LNSPEC_FloorWaggle:
      buttonSuccess = EV_StartFloorWaggle(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_ThingSpawnFacing:
      buttonSuccess = EV_ThingSpawn(Arg1, Arg2, 0, Arg4, Arg5, !Arg3, true, A);
      break;
    case LNSPEC_SectorSoundChange:
      buttonSuccess = EV_SectorSoundChange(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_SectorSetPlaneReflection:
      buttonSuccess = EV_SectorSetPlaneReflection(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_CeilingGenericCrush2:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_GenericCrush2, Line);
      break;
    case LNSPEC_SectorSetCeilingScale2:
      buttonSuccess = EV_SectorSetCeilingScale2(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_SectorSetFloorScale2:
      buttonSuccess = EV_SectorSetFloorScale2(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_PlaneUpNearestWaitDownStay:
      buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5, Platform::PLATEV_UpNearestWaitDownStay, Line);
      break;
    case LNSPEC_NoiseAlert:
      buttonSuccess = EV_NoiseAlert(A, Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_SendToCommunicator:
      buttonSuccess = EV_SendToCommunicator(A, Arg1, Arg2, Arg3, Arg4, Arg5, Side);
      break;
    case LNSPEC_ThingProjectileIntercept:
      buttonSuccess = EV_ThingProjectileIntercept(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_ThingChangeTID:
      buttonSuccess = EV_ThingChangeTID(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_ThingHate:
      buttonSuccess = EV_ThingHate(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_ThingProjectileAimed:
      buttonSuccess = EV_ThingProjectileAimed(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_ChangeSkill:
      LineSpecialGameInfo(Game).SetSkill(Arg1);
      buttonSuccess = true;
      break;
    case LNSPEC_ThingSetTranslation:
      buttonSuccess = EV_ThingSetTranslation(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_LineAlignCeiling:
      buttonSuccess = EV_LineAlignCeiling(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_LineAlignFloor:
      buttonSuccess = EV_LineAlignFloor(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_SectorSetRotation:
      buttonSuccess = EV_SectorSetRotation(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_SectorSetCeilingPanning:
      buttonSuccess = EV_SectorSetCeilingPanning(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_SectorSetFloorPanning:
      buttonSuccess = EV_SectorSetFloorPanning(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_SectorSetCeilingScale:
      buttonSuccess = EV_SectorSetCeilingScale(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_SectorSetFloorScale:
      buttonSuccess = EV_SectorSetFloorScale(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_SetPlayerProperty:
      buttonSuccess = EV_SetPlayerProperty(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_CeilingLowerToHighestFloor:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_LowerToHighestFloor, Line);
      break;
    case LNSPEC_CeilingLowerInstant:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_LowerTimes8Instant, Line);
      break;
    case LNSPEC_CeilingRaiseInstant:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_RaiseTimes8Instant, Line);
      break;
    case LNSPEC_CeilingCrushRaiseAndStayA:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_CrushRaiseAndStayA, Line);
      break;
    case LNSPEC_CeilingCrushAndRaiseA:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_CrushAndRaiseA, Line);
      break;
    case LNSPEC_CeilingCrushAndRaiseSilentA:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_CrushAndRaiseSilA, Line);
      break;
    case LNSPEC_CeilingRaiseByValueTimes8:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_RaiseByValueTimes8, Line);
      break;
    case LNSPEC_CeilingLowerByValueTimes8:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_LowerByValueTimes8, Line);
      break;
    case LNSPEC_FloorGeneric:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_Generic, Line);
      break;
    case LNSPEC_CeilingGeneric:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_Generic, Line);
      break;
    case LNSPEC_DoorGeneric:
      buttonSuccess = EV_GenericDoor(Arg1, Arg2, Arg3, Arg4, Arg5, Line, A);
      break;
    case LNSPEC_PlatGeneric:
      buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5, Platform::PLATEV_Generic, Line);
      break;
    case LNSPEC_StairsGeneric:
      buttonSuccess = EV_BuildStairsOld(Arg1, Arg2, Arg3, Arg4, Arg5, true, Line);
      break;
    case LNSPEC_CeilingGenericCrush:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_GenericCrush, Line);
      break;
    case LNSPEC_PlatDownWaitUpStayLip:
      buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5, Platform::PLATEV_DownWaitUpStayLip, Line);
      break;
    case LNSPEC_PlatPerpetualRaiseLip:
      buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5, Platform::PLATEV_PerpetualRaiseLip, Line);
      break;
    case LNSPEC_LineTranslucent:
      buttonSuccess = EV_LineTranslucent(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_SectorSetColor:
      buttonSuccess = EV_SectorSetColor(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_SectorSetFade:
      buttonSuccess = EV_SectorSetFade(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_SectorSetDamage: // tag, amount, mod, interval,leaky
      buttonSuccess = EV_SectorSetDamage(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_TeleportLine:
      buttonSuccess = EV_SilentLineTeleport(Line, Side, A, Arg2, Arg3);
      break;
    case LNSPEC_SectorSetGravity:
      buttonSuccess = EV_SectorSetGravity(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_StairsBuildUpDoom:
      buttonSuccess = EV_BuildStairsOld(Arg1, Arg2, Arg3, Arg4, Arg5, false, Line);
      break;
    case LNSPEC_SectorSetWind:
      buttonSuccess = AdjustPusher(Arg1, Arg2, Arg3, Arg4, Arg5, Line, Pusher::PUSHER_Wind);
      break;
    case LNSPEC_SectorSetFriction:
      buttonSuccess = EV_SectorSetFriction(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_SectorSetCurrent:
      buttonSuccess = AdjustPusher(Arg1, Arg2, Arg3, Arg4, Arg5, Line, Pusher::PUSHER_Current);
      break;
    case LNSPEC_ScrollTextureBoth:
      buttonSuccess = EV_ScrollTextureBoth(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_ScrollFloor:
      buttonSuccess = EV_ScrollFloor(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_ScrollCeiling:
      buttonSuccess = EV_ScrollCeiling(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_ACSExecuteAlways:
      //print("LNSPEC_ACSExecuteAlways: number=%d; map=%d; arg1=%d; arg2=%d; arg3=%d", Arg1, Arg2, Arg3, Arg4, Arg5);
      buttonSuccess = XLevel.StartACS(Arg1, Arg2, Arg3, Arg4, Arg5, A, Line, Side, true, false);
      break;
    case LNSPEC_FloorRaiseToNearestChange:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_RaiseToNearestChange, Line);
      break;
    case LNSPEC_ThingSetGoal:
      buttonSuccess = EV_ThingSetGoal(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_FloorRaiseByValueChangeTex:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_RaiseByValueChange2, Line);
      break;
    case LNSPEC_PlatToggle:
      buttonSuccess = EV_DoPlat(Arg1, Arg2, Arg3, Arg4, Arg5, Platform::PLATEV_Toggle, Line);
      break;
    case LNSPEC_LightStrobeDoom:
      buttonSuccess = EV_StartLightStrobing(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_LightMinNeighbor:
      buttonSuccess = EV_TurnTagLightsOff(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_LightMaxNeighbor:
      buttonSuccess = EV_TagLightTurnOn(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_FloorTransferTrigger:
      buttonSuccess = EV_FloorTransferTrigger(Arg1, Arg2, Arg3, Arg4, Arg5, Line);
      break;
    case LNSPEC_FloorTransferNumeric:
      buttonSuccess = EV_FloorTransferNumeric(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_ChangeCamera:
      buttonSuccess = EV_ChangeCamera(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_FloorRaiseToLowestCeiling:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_RaiseToLowestCeiling, Line);
      break;
    case LNSPEC_FloorRaiseByValueChange:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_RaiseByValueChange, Line);
      break;
    case LNSPEC_FloorRaiseByTexture:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_RaiseByTexture, Line);
      break;
    case LNSPEC_FloorLowerToLowestChange:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_LowerToLowestChange, Line);
      break;
    case LNSPEC_FloorLowerToHighest:
      buttonSuccess = EV_DoFloor(Arg1, Arg2, Arg3, Arg4, Arg5, FloorMover::FLOOREV_LowerToHighest, Line);
      break;
    case LNSPEC_ExitNormal:
      buttonSuccess = true;
      ExitLevel(Arg1);
      break;
    case LNSPEC_ExitSecret:
      buttonSuccess = true;
      SecretExitLevel(Arg1);
      break;
    case LNSPEC_ElevatorRaiseToNearest:
      buttonSuccess = EV_DoElevator(Arg1, Arg2, Arg3, Arg4, Arg5, Elevator::ELEVEV_Up, Line);
      break;
    case LNSPEC_ElevatorMoveToFloor:
      buttonSuccess = EV_DoElevator(Arg1, Arg2, Arg3, Arg4, Arg5, Elevator::ELEVEV_Current, Line);
      break;
    case LNSPEC_ElevatorLowerToNearest:
      buttonSuccess = EV_DoElevator(Arg1, Arg2, Arg3, Arg4, Arg5, Elevator::ELEVEV_Down, Line);
      break;
    case LNSPEC_HealThing:
      buttonSuccess = EV_HealThing(Arg1, Arg2, Arg3, Arg4, Arg5, A);
      break;
    case LNSPEC_DoorCloseWaitOpen:
      buttonSuccess = EV_DoDoor(Arg1, Arg2, Arg3, Arg4, Arg5, VerticalDoor::DOOREV_CloseWaitOpen, Line, A);
      break;
    case LNSPEC_FloorDonut:
      buttonSuccess = EV_DoDonut(Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
    case LNSPEC_FloorAndCeilingLowerRaise: // Arg4=1998: emulate boom bug
      //if (Arg4 == 1998) printdebug("BOOM: LNSPEC_FloorAndCeilingLowerRaise: tag=%s", Arg1);
      buttonSuccess = EV_DoCeiling(Arg1, Arg3, 0, 0, 0, CeilingMover::CEILEV_RaiseToHighest, Line);
      if (Arg4 == 1998) {
        if (!buttonSuccess) {
          //print("   XXX: buttonSuccess=%s (FLOOR!)", buttonSuccess);
          buttonSuccess = EV_DoFloor(Arg1, Arg2, 0, 0, 0, FloorMover::FLOOREV_LowerToLowest, Line);
        }
      } else {
        buttonSuccess |= EV_DoFloor(Arg1, Arg2, 0, 0, 0, FloorMover::FLOOREV_LowerToLowest, Line);
      }
      break;
    case LNSPEC_CeilingRaiseToNearest:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_RaiseToNearest, Line);
      break;
    case LNSPEC_CeilingLowerToLowest:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_LowerToLowest, Line);
      break;
    case LNSPEC_CeilingLowerToFloor:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_LowerToFloor, Line);
      break;
    case LNSPEC_CeilingCrushRaiseAndStaySilentA:
      buttonSuccess = EV_DoCeiling(Arg1, Arg2, Arg3, Arg4, Arg5, CeilingMover::CEILEV_CrushRaiseAndStaySilA, Line);
      break;
    case LNSPEC_ExtraFloorLightOnly:
      print("Unknown action special %d aka 'ExtraFloor_LightOnly' (tag=%d; type=%d) not implemented", Special, Arg1, Arg2);
      break;
    case LNSPEC_LineSetBlocking:
      {
        //print("LNSPEC_LineSetBlocking: (%d, 0x%04x, 0x%04x)", Arg1, Arg2, Arg3);
        int setFlags = ConvertLineBlockingFlags(Arg2), clearFlags = ~ConvertLineBlockingFlags(Arg3);
        int searcher = -1;
        for (line_t *ldef = XLevel.FindLine(Arg1, &searcher); ldef; ldef = XLevel.FindLine(Arg1, &searcher)) {
          ldef->flags |= setFlags;
          ldef->flags &= clearFlags;
        }
        buttonSuccess = true;
      }
      break;
    // Sector_SetLink (controltag, tag, surface, movetype)
    case LNSPEC_SectorSetLink:
      if (Arg1 == 0) {
        print("LNSPEC_SectorSetLink: (controltag=%d, tag=%d, surface=%d, movetype=%d)", Arg1, Arg2, Arg3, Arg4);
      } else {
        XLevel.SectorSetLink(Arg1, Arg2, Arg3, Arg4);
      }
      buttonSuccess = true;
      break;
    // Line specials only processed during level initialization
    // LNSPEC_ScrollTextureLeft:
    // LNSPEC_ScrollTextureRight:
    // LNSPEC_ScrollTextureUp:
    // LNSPEC_ScrollTextureDown:
    // LNSPEC_LineSetIdentification:
    // LNSPEC_3DFloor:
    // LNSPEC_Contents:
    // LNSPEC_PlaneAlign:
    // LNSPEC_PlaneCopy:
    // LNSPEC_TransferHeights:
    // LNSPEC_ScrollTextureModel:
    // LNSPEC_ScrollTextureOffsets:
    // LNSPEC_PointPushSetForce:

    case LNSPEC_SectorSetPortal:
      printwarn("this level uses sector portals; this is not supported by k8vavoom!");
      break;
    case LNSPEC_LineSetPortal:
      printwarn("this level uses line portals; this is not supported by k8vavoom!");
      break;

    case LNSPEC_SectorSetFloorGlow:
    case LNSPEC_SectorSetCeilingGlow:
      buttonSuccess = EV_SectorSetGlow((Special == LNSPEC_SectorSetCeilingGlow), Arg1, Arg2, Arg3, Arg4, Arg5);
      break;

    default:
      // log everything else to know what needs to be implemented
      print("Unknown action special %d(%d, %d, %d, %d, %d)", Special, Arg1, Arg2, Arg3, Arg4, Arg5);
      break;
  }
  return buttonSuccess;
}


//==========================================================================
//
//  StartPlaneWatcher
//
//==========================================================================
override void StartPlaneWatcher (Entity it, line_t *line, int lineSide,
  bool ceiling, int tag, int height, int special, int arg0, int arg1,
  int arg2, int arg3, int arg4)
{
  PlaneWatcher PW = SpawnThinker(PlaneWatcher);
  if (PW && !PW.IsDestroyed) PW.Start(it, line, lineSide, ceiling, tag, height, special, arg0, arg1, arg2, arg3, arg4);
}


//**************************************************************************
//
//  Doors
//
//**************************************************************************

//==========================================================================
//
//  EV_DoDoor
//
//  Move a door up/down
//
//==========================================================================
/*final*/ int EV_DoDoor (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type,
                         line_t *Line, Entity Thing, optional bool delayOctics)
{
  sector_t *sec;
  VerticalDoor Door;
  int RetCode = false;

  if (!Arg1) {
    if (!Line) return false;

    // make sure it's a two-sided line
    if (Line->sidenum[1] < 0) return false;

    // if the sector has an active thinker, use it
    sec = XLevel.Sides[Line->sidenum[1]].Sector;
    if (!sec->lines.length) return false;
    if (sec->CeilingData) {
      Door = VerticalDoor(sec->CeilingData);
      if (Door) return Door.ReUse(Type, Line, Thing);
      return false;
    }

    // new door thinker
    Door = SpawnThinker(VerticalDoor);
    if (Door && !Door.IsDestroyed) {
      Door.Init(sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type, delayOctics!optional);
      RetCode = true;
    }
  } else {
    for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0; hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx)) {
      if (sec->CeilingData || !sec->lines.length) continue;
      // add new door thinker
      Door = SpawnThinker(VerticalDoor);
      if (Door && !Door.IsDestroyed) {
        Door.Init(sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type, delayOctics!optional);
        RetCode = true;
      }
    }
  }

  return RetCode;
}


//==========================================================================
//
//  EV_GenericDoor
//
//  Boom's generic doors.
//
//==========================================================================
/*final*/ int EV_GenericDoor (int dtag, int speed, int kind, int delay, int lock, line_t *Line, Entity Thing) {
  int Tag;
  int LightTag;

  // check for locked door
  if (lock && !CheckLock(Thing, lock, true)) return false;

  // check for Boom's local door light special
  if (kind&128) {
    Tag = 0;
    LightTag = dtag;
  } else {
    Tag = dtag;
    LightTag = 0;
  }

  switch (kind&127) {
    case 0: return EV_DoDoor(Tag, speed, delay, LightTag, 0, VerticalDoor::DOOREV_Raise, Line, Thing, delayOctics:true);
    case 1: return EV_DoDoor(Tag, speed, LightTag, 0, 0, VerticalDoor::DOOREV_Open, Line, Thing);
    case 2: return EV_DoDoor(Tag, speed, delay, LightTag, 0, VerticalDoor::DOOREV_CloseWaitOpen, Line, Thing);
    case 3: return EV_DoDoor(Tag, speed, LightTag, 0, 0, VerticalDoor::DOOREV_Close, Line, Thing, delayOctics:true);
  }

  return false;
}


//==========================================================================
//
//  SpawnDoorCloseIn30
//
//  Spawn a door that closes after 30 seconds
//
//==========================================================================
/*final*/ void SpawnDoorCloseIn30 (sector_t *sec) {
  VerticalDoor Door = SpawnThinker(VerticalDoor);
  if (Door && !Door.IsDestroyed) {
    Door.InitCloseIn30(sec);
    sec->special = 0;
  }
}


//==========================================================================
//
//  SpawnDoorRaiseIn5Mins
//
//  Spawn a door that opens after 5 minutes
//
//==========================================================================
/*final*/ void SpawnDoorRaiseIn5Mins (sector_t *sec) {
  VerticalDoor Door = SpawnThinker(VerticalDoor);
  if (Door && !Door.IsDestroyed) {
    sec->special = 0;
    Door.Init(sec, 0, 16, 150, 0, 0, VerticalDoor::DOOREV_RaiseIn5Mins);
  }
}


//==========================================================================
//
//  EV_TextureChangeDoor
//
//==========================================================================
/*final*/ int EV_TextureChangeDoor (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, line_t *Line, Entity E) {
  int Rtn;
  sector_t *sec;
  TextureChangeDoor Door;

  Rtn = false;

  if (!Arg1) {
    if (!Line || !Line->backsector) return false;

    // if the sector has an active thinker, use it
    if (Line->backsector->CeilingData) {
      if (!E.bIsPlayer) return false;
      Door = TextureChangeDoor(Line->backsector->CeilingData);
      if (Door && Door.Direction == 0) return Door.StartClosing();
      return false;
    }

    // new door thinker
    if (FindAnimDoor(XLevel.Sides[Line->sidenum[0]].TopTexture)) {
      Door = SpawnThinker(TextureChangeDoor);
      Door.Init(Line->backsector, Arg1, Arg2, Arg3, Arg4, Arg5, Line);
      Rtn = true;
    }
  } else {
    for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0; hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx)) {
      if (sec->CeilingData) continue;
      foreach (auto i; 0..sec.lines.length) {
        Line = sec->lines[i];
        if (!Line->backsector) continue;
        // new door thinker
        if (FindAnimDoor(XLevel.Sides[Line->sidenum[0]].TopTexture)) {
          Rtn = true;
          Door = SpawnThinker(TextureChangeDoor);
          Door.Init(sec, Arg1, Arg2, Arg3, Arg4, Arg5, Line);
          break;
        }
      }
    }
  }

  return Rtn;
}


//**************************************************************************
//
//  Ceilings
//
//**************************************************************************

//==========================================================================
//
//  EV_DoCeiling
//
//  Move a ceiling up/down and all around!
//
//==========================================================================
/*final*/ int EV_DoCeiling (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type, line_t *Line) {
  sector_t *sec;
  CeilingMover Ceiling;
  int Rtn = false;

  if (!Arg1) {
    if (!Line || !Line->backsector) return false;

    // reactivate in-stasis ceilings... for certain types
    if ((Type == CeilingMover::CEILEV_CrushAndRaiseA ||
         Type == CeilingMover::CEILEV_CrushAndRaiseSilA) &&
        CeilingMover(Line->backsector->CeilingData))
    {
      CeilingMover(Line->backsector->CeilingData).ActivateInStasis(0);
    }

    if (!Line->backsector->CeilingData) {
      if (!Line->backsector->lines.length) return false;
      // new ceiling thinker
      Rtn = true;
      Ceiling = SpawnThinker(CeilingMover);
      Ceiling.Init(Line->backsector, Arg1, Arg2, Arg3, Arg4, Arg5, Type, Line);
    }
  } else {
    // reactivate in-stasis ceilings... for certain types
    if (Type == CeilingMover::CEILEV_CrushAndRaiseA ||
        Type == CeilingMover::CEILEV_CrushAndRaiseSilA)
    {
      foreach AllThinkers(CeilingMover, Ceiling) {
        Ceiling.ActivateInStasis(Arg1);
      }
    }

    for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0; hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx)) {
      if (sec->CeilingData || !sec->lines.length) {
        //printdebug("sector #%s (tag %s) (ceiling): already moving or no lines (%s)", Sec-&XLevel.Sectors[0], Arg1, Sec->lines.length);
        continue;
      }

      //printdebug("sector #%s (tag %s): got ceiling thinker", Sec-&XLevel.Sectors[0], Arg1);
      // new ceiling thinker
      Rtn = true;
      Ceiling = SpawnThinker(CeilingMover);
      Ceiling.Init(sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type, Line);
    }
  }

  return Rtn;
}


//==========================================================================
//
//  EV_CeilingCrushStop
//
//  Stop a ceiling from crushing!
//
//==========================================================================
/*final*/ int EV_CeilingCrushStop (line_t *line, int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  int rtn = false;
  CeilingMover Ceiling;
  foreach AllThinkers(CeilingMover, Ceiling) {
    if (Ceiling.CrushStop(Arg1)) rtn = true;
  }
  return rtn;
}


//==========================================================================
//
//  EV_StartCeilingWaggle
//
//==========================================================================
/*final*/ bool EV_StartCeilingWaggle (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  sector_t *Sector;
  CeilingWaggle Waggle;
  bool RetCode = false;
  for (int hidx = XLevel.FindSectorFromTag(out Sector, Arg1); hidx >= 0; hidx = XLevel.FindSectorFromTag(out Sector, Arg1, hidx)) {
    if (Sector->CeilingData || !Sector->lines.length) continue; // already busy with another thinker
    RetCode = true;
    Waggle = SpawnThinker(CeilingWaggle);
    Waggle.Init(Sector, Arg1, Arg2, Arg3, Arg4, Arg5);
  }
  return RetCode;
}


//**************************************************************************
//
//  Floors
//
//**************************************************************************

//==========================================================================
//
//  EV_DoFloor
//
//  HANDLE FLOOR TYPES
//
//==========================================================================
/*final*/ int EV_DoFloor (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type, line_t *Line) {
  sector_t *sec;
  FloorMover Floor;
  int Rtn = false;

  if (!Arg1) {
    if (!Line || !Line->backsector) return false;

    if (!Line->backsector->FloorData) {
      // new floor thinker
      if (!Line->backsector->lines.length) return false;
      Rtn = true;
      Floor = SpawnThinker(FloorMover);
      Floor.Init(Line->backsector, Arg1, Arg2, Arg3, Arg4, Arg5, Type, Line);
    }
  } else {
    for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0; hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx)) {
      // ALREADY MOVING?  IF SO, KEEP GOING...
      if (sec->FloorData || !sec->lines.length) {
        //printdebug("sector #%s (tag %s) (floor): already moving or no lines (%s)", Sec-&XLevel.Sectors[0], Arg1, Sec->lines.length);
        continue;
      }

      //printdebug("sector #%s (tag %s): got floor thinker", Sec-&XLevel.Sectors[0], Arg1);
      // new floor thinker
      Rtn = true;
      Floor = SpawnThinker(FloorMover);
      Floor.Init(sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type, Line);
    }
  }

  return Rtn;
}


//==========================================================================
//
// EV_FloorCrushStop
//
//==========================================================================
/*final*/ int EV_FloorCrushStop (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  FloorMover Floor;
  int Rtn = 0;
  foreach AllThinkers(FloorMover, Floor) {
    if (Floor.CrushStop(Arg1)) Rtn = 1;
  }
  return Rtn;
}


//==========================================================================
//
//  EV_DoDonut()
//
//  Handle donut function: lower pillar, raise surrounding pool, both to
// height, texture and type of the sector surrounding the pool.
//  Passed the linedef that triggered the donut
//  Returns whether a thinker was created
//
//==========================================================================
/*final*/ int EV_DoDonut (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  sector_t *s1;
  int rtn = 0;
  // do function on all sectors with same tag as linedef
  // s1 is pillar's sector
  for (int hidx = XLevel.FindSectorFromTag(out s1, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out s1, Arg1, hidx))
  {
    if (!s1) { printerror("!!!EV_DoDonut: s3 is null"); continue; } //k8: just in case

    // ALREADY MOVING?  IF SO, KEEP GOING...
    if (s1->FloorData) continue;

    sector_t *s2 = getNextSector(s1->lines[0], s1); // s2 is pool's sector
    if (!s2) { printerror("!!!EV_DoDonut: s3 is null"); continue; } //k8: just in case
    rtn = 1;

    // find a two sided line around the pool whose other side isn't the pillar
    foreach (line_t *ln; s2.lines) {
      if (!(ln.flags&ML_TWOSIDED) || (ln.backsector == s1)) continue;
      sector_t *s3 = ln.backsector;
      if (!s3) { printerror("!!!EV_DoDonut: s3 is null"); continue; } //k8: just in case

      // spawn rising slime
      FloorMover Floor = SpawnThinker(FloorMover);
      Floor.InitDonut(s2, s3, Arg2);

      // spawn lowering donut-hole
      Floor = SpawnThinker(FloorMover);
      Floor.InitDonut2(s1, s3, Arg3);
      break;
    }
  }
  return rtn;
}


//==========================================================================
//
//  EV_StartFloorWaggle
//
//==========================================================================
/*final*/ bool EV_StartFloorWaggle (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  sector_t *Sector;
  bool RetCode = false;
  for (int hidx = XLevel.FindSectorFromTag(out Sector, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out Sector, Arg1, hidx))
  {
    if (Sector->FloorData || !Sector->lines.length) continue; // already busy with another thinker
    RetCode = true;
    FloorWaggle Waggle = SpawnThinker(FloorWaggle);
    Waggle.Init(Sector, Arg1, Arg2, Arg3, Arg4, Arg5);
  }
  return RetCode;
}


//**************************************************************************
//
//  Stairs
//
//**************************************************************************

//==========================================================================
//
//  EV_BuildStairsOld
//
//  Build a staircase!
//
//  FIXME: split this to several functions, because "compat" sux
//
//==========================================================================
/*final*/ int EV_BuildStairsOld (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
                                 bool Generic, line_t *Line)
{
  float Height;
  int Ok;
  int Texture;
  int Rtn;
  sector_t *sec;
  sector_t *TSec;
  FloorMover Floor;
  line_t *SecLine;
  int Direction;
  float StairSize;
  bool IgnTxt;
  int OldSecNum;

  if (!Arg1 && (!Line || !Line->backsector)) return false;

  if (Generic) {
    Direction = (Arg4&1 ? 1 : -1);
    IgnTxt = !!(Arg4&2);
  } else {
    Direction = 1;
    IgnTxt = false;
  }

  StairSize = float(Arg3*Direction);
  Rtn = 0;

  int SecNum;
  if (Arg1) {
    foreach (SecNum; 0..XLevel.Sectors.length) {
      if (IsSectorTagEqual(&XLevel.Sectors[SecNum], Arg1)) break;
    }
  } else {
    SecNum = 1;
  }

  while (SecNum >= 0 && SecNum < XLevel.Sectors.length) {
    sec = (Arg1 ? &XLevel.Sectors[SecNum] : Line->backsector);

    //OldSecNum = /*SecNum*/Sec-&XLevel.Sectors[0]; //jff 3/4/98 preserve loop index
    //int SecNum = OldSecNum;
    OldSecNum = SecNum;

    // ALREADY MOVING? IF SO, KEEP GOING...
    if (!sec->FloorData) {
      // new floor thinker
      Rtn = 1;
      Height = GetPlanePointZ(ref sec->floor, vector(0.0, 0.0, 0.0))+StairSize;
      Floor = SpawnThinker(FloorMover);
      Floor.InitStair(sec, Arg1, Arg2, Arg3, Arg4, Arg5, Generic, Height);

      Texture = sec->floor.pic;

      // Find next sector to raise
      // 1. Find 2-sided line with same sector side[0]
      // 2. Other side is the next sector to raise
      // 3. Unless already moving, or different texture, then stop building
      do {
        Ok = false;
        foreach (int i; 0..sec.lines.length) {
          SecLine = sec->lines[i];
          if (!(SecLine->flags&ML_TWOSIDED)) continue;
          TSec = SecLine->frontsector;
          if (sec != TSec) continue;
          TSec = SecLine->backsector;
          if (!TSec) continue; //jff 5/7/98 if no backside, continue
          if (!IgnTxt && TSec->floor.pic != Texture) continue;

          Height += StairSize;
          if (TSec->FloorData) continue;

          sec = TSec;
          // SecNum = TSec-XLevel.Sectors;
          foreach (int j; 0..XLevel.Sectors.length) {
            if (TSec == &XLevel.Sectors[j]) {
              SecNum = j;
              break;
            }
          }
          Floor = SpawnThinker(FloorMover);
          Floor.InitStair(sec, Arg1, Arg2, Arg3, Arg4, Arg5, Generic, Height);
          Ok = true;
          break;
        }
      } while (Ok);
    }
    if (!Level.CompatStairs) SecNum = OldSecNum; //jff 3/4/98 restore loop index
    // next sector
    if (!Arg1) break;
    ++SecNum;
    if (SecNum < 0 || SecNum > XLevel.Sectors.length) break;
    while (SecNum < XLevel.Sectors.length) {
      if (IsSectorTagEqual(&XLevel.Sectors[SecNum], Arg1)) break;
      ++SecNum;
    }
  }
  return Rtn;
}


//==========================================================================
//
//  EV_BuildStairs
//
//  Build a staircase!
//
//  StairDirection is either positive or negative, denoting build stairs
// up or down.
//
//==========================================================================
/*final*/ int EV_BuildStairs (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int StairsType) {
  sector_t *sec;
  StairStepMover StairStep;
  StairStepMover StairQueueHead = none;

  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    if (sec->FloorData) continue; // already moving? if so, keep going...

    StairStep = SpawnThinker(StairStepMover);
    StairStep.Init(sec, Arg1, Arg2, Arg3, Arg4, Arg5, StairsType);
    if (StairQueueHead) {
      StairQueueHead.AppendToQueue(StairStep);
    } else {
      StairQueueHead = StairStep;
    }
    sec->special &= ~SECSPEC_BASE_MASK;
  }

  for (StairStep = StairQueueHead; StairStep; StairStep = StairStep.QueueNext) {
    StairStep.ProcessStairSector();
  }

  return (StairQueueHead ? 1 : 0); //k8: was `1`
}


//**************************************************************************
//
//  Platforms
//
//**************************************************************************

//==========================================================================
//
//  EV_DoPlat
//
//  Do Platforms.
//
//==========================================================================
/*final*/ int EV_DoPlat (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type, line_t *Line) {
  Platform  Plat;
  sector_t *sec;

  int Rtn = 0;

  if (!Arg1) {
    if (!Line || !Line->backsector) return 0;

    // activate all <type> plats that are in stasis
    if ((Type == Platform::PLATEV_PerpetualRaise ||
         Type == Platform::PLATEV_PerpetualRaiseLip ||
         Type == Platform::PLATEV_Toggle) && Platform(Line->backsector->FloorData))
    {
      // activate in stasis
      Platform(Line->backsector->FloorData).ActivateInStasis(Arg1);
      if (Type == Platform::PLATEV_Toggle) Rtn = 1;
    }

    if (!Line->backsector->FloorData) {
      // find lowest & highest floors around sector
      Rtn = 1;
      Plat = SpawnThinker(Platform);
      Plat.Init(Line->backsector, Arg1, Arg2, Arg3, Arg4, Arg5, Type);
    }
  } else {
    // activate all <type> plats that are in stasis
    if (Type == Platform::PLATEV_PerpetualRaise ||
        Type == Platform::PLATEV_PerpetualRaiseLip ||
        Type == Platform::PLATEV_Toggle)
    {
      // activate in stasis
      foreach AllThinkers(Platform, Plat) {
        Plat.ActivateInStasis(Arg1);
      }
      if (Type == Platform::PLATEV_Toggle) Rtn = 1;
    }

    for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
         hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
    {
      if (sec->FloorData) continue;
      // find lowest & highest floors around sector
      Rtn = 1;
      Plat = SpawnThinker(Platform);
      Plat.Init(sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type);
    }
  }

  return Rtn;
}


//==========================================================================
//
//  EV_StopPlat
//
//==========================================================================
/*final*/ int EV_StopPlat (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  Platform Plat;
  foreach AllThinkers(Platform, Plat) {
    Plat.StopPlat(Arg1);
  }
  return 1;
}


//**************************************************************************
//
//  Pillar
//
//**************************************************************************

//==========================================================================
//
//  EV_BuildPillar
//
//==========================================================================
/*final*/ int EV_BuildPillar (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, bool Crush) {
  sector_t *sec;
  Pillar pillarObj;
  int Rtn = 0;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0; hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx)) {
    if (sec->FloorData || sec->CeilingData) continue; // already moving
    Rtn = 1;
    pillarObj = SpawnThinker(Pillar);
    pillarObj.Init(sec, Arg1, Arg2, Arg3, Arg4, Arg5, Crush);
  }
  return Rtn;
}


//==========================================================================
//
//  EV_OpenPillar
//
//==========================================================================
/*final*/ int EV_OpenPillar (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  sector_t *sec;
  Pillar pillarObj;
  int Rtn = 0;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0; hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx)) {
    if (sec->FloorData || sec->CeilingData) continue; // already moving
    Rtn = 1;
    pillarObj = SpawnThinker(Pillar);
    pillarObj.InitOpen(sec, Arg1, Arg2, Arg3, Arg4, Arg5);
  }
  return Rtn;
}


//**************************************************************************
//
//  Elevator
//
//**************************************************************************

//==========================================================================
//
//  EV_DoElevator
//
//==========================================================================
/*final*/ int EV_DoElevator (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type, line_t *Line) {
  if (!Line && (Type == Elevator::ELEVEV_Current)) return false;

  int Rtn = 0;
  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    // skip if already busy
    if (sec->FloorData || sec->CeilingData) continue;
    // new elevator thinker
    Rtn = 1;
    Elevator Elev = SpawnThinker(Elevator);
    Elev.Init(sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type, Line);
  }
  return Rtn;
}


//**************************************************************************
//
//  Polyobj Event Code
//
//**************************************************************************

//==========================================================================
//
//  AcsPolyMoveEx
//
//==========================================================================
override int AcsPolyMoveEx (int po, int hspeed, int yawangle, int dist,
                            int vspeed, int vdist, int moveflags, Entity Activator)
{
  //printdebug("AcsPolyMoveEx: po=%s; hspeed=%s; yawangle=%s; dist=%s; vspeed=%s; vdist=%s; forced=%s", po, hspeed, yawangle, dist, vspeed, vdist, forced);
  bool forced = !!(moveflags&POBJ_MOVE_OVERRIDE);
  bool nolink = !!(moveflags&POBJ_MOVE_NOLINK);
  return EV_MovePoly(nullptr, po, hspeed, yawangle, dist, 0, timesEight:false, overRide:forced, vspeed:vspeed, vdist:vdist, nolink:nolink);
}


//==========================================================================
//
//  AcsPolyMoveToEx
//
//==========================================================================
override int AcsPolyMoveToEx (int po, int speed, int x, int y, int z, int moveflags, Entity Activator) {
  auto poly = XLevel.GetPolyobj(po);
  if (!poly) return 0;

  TVec dst = vector(x, y, 0);
  TVec rel = vector(dst.x-poly.startSpot.x, dst.y-poly.startSpot.y, 0);
  float vdist = z-poly.startSpot.z;
  if (!rel && !vdist) return 1;

  float dist = length2D(rel);
  if (dist < 1 || fabs(vdist) < 1) return 1;

  int vspeed = (vdist < 0 ? -speed : speed);

  bool forced = !!(moveflags&POBJ_MOVE_OVERRIDE);
  bool nolink = !!(moveflags&POBJ_MOVE_NOLINK);

  rel = normalize(rel);
  TAVec angles;
  VectorAngles(rel, out angles);
  return EV_MovePoly(/*line*/nullptr, po, speed, 0, 0, 0, timesEight:false, overRide:forced, floatAngle:angles.yaw, floatDist:dist, vspeed:vspeed, vdist:cast(int)fabs(vdist), nolink:nolink);
}


//==========================================================================
//
//  AcsPolyMoveToSpotEx
//
//  this uses target height too
//
//==========================================================================
override int AcsPolyMoveToSpotEx (int po, int speed, int targettid, int moveflags, Entity Activator) {
  if (!speed || !targettid) return false;
  Entity ent = Level.FindMobjFromTID(targettid, none);
  if (!ent) return 0;

  auto poly = XLevel.GetPolyobj(po);
  if (!poly) return 0;

  return AcsPolyMoveToEx(po, speed, cast(int)ent.Origin.x, cast(int)ent.Origin.y, cast(int)ent.Origin.z, moveflags, Activator);
}


//==========================================================================
//
//  EV_StopPoly
//
//==========================================================================
/*final*/ bool EV_StopPoly (line_t *line, int Arg1, int Arg2, int Arg3,
                            int Arg4, int Arg5, int direction, bool overRide,
                            optional bool nolink)
{
  int polyNum = Arg1;
  polyobj_t *poly = XLevel.GetPolyobj(polyNum);
  if (!poly) { printerror("EV_RotatePoly: invalid polyobj num %s", polyNum); return false; }
  PolyobjThinker.ClearPolyobjThinkers(poly);
  PolyobjStopSequence(poly);

  int seen = polyNum;
  bool doStep = false;
  for (int mirror = XLevel.GetPolyobjMirror(polyNum); mirror; mirror = XLevel.GetPolyobjMirror(/*polyNum*/mirror)) {
    poly = XLevel.GetPolyobj(mirror);
    if (!poly) { printerror("EV_RotatePoly: invalid polyobj mirror num %s for pobj %s", mirror, polyNum); continue; }
    if (mirror == seen) {
      printdebug("EV_StopPoly: found mirror loop for pobj %s (this is harmless)", polyNum);
      break;
    }
    if (doStep) seen = XLevel.GetPolyobjMirror(seen);
    doStep = !doStep;
    PolyobjThinker.ClearPolyobjThinkers(poly);
    PolyobjStopSequence(poly);
  }

  return true;
}


//==========================================================================
//
//  EV_RotatePoly
//
//==========================================================================
/*final*/ bool EV_RotatePoly (line_t *line, int polyNum, int speed, int byteAngle,
                              int Arg4, int Arg5, int direction, bool overRide,
                              optional bool nolink)
{
  polyobj_t *poly = XLevel.GetPolyobj(polyNum);
  if (!poly) { printerror("EV_RotatePoly: invalid polyobj num %d", polyNum); return false; }

  //printdebug("ROTATE POBJ #%d (speed=%s; byteAngle=%s; dir=%s)", polyNum, speed, byteAngle, direction);
  if (!overRide && PolyobjThinker.IsPolyobjBusy(poly)) {
    // poly is already moving
    //printdebug("   already moving.");
    return false;
  }

  PolyobjRotator pe = SpawnThinker(PolyobjRotator);
  //pe.polyobj = polyNum;
  pe.dist = (byteAngle ? (byteAngle == 255 ? -1.0 : float(byteAngle)*(90.0/64.0)/*Angle*/) : 360.0);
  pe.speed = /*AngleClamp360Signed*/(32.0*float(speed)*float(direction)*90.0/64.0/8.0); // was AngleMod180
  pe.thrust_force = pe.speed/32.0*float(0x800)/90.0; //THRUST
  pe.nolink = nolink;
  //printdebug("  dist=%s; speed=%s; thrust_force=%s", pe.dist, pe.speed, pe.thrust_force);
  PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);

  pe.AppendTo(poly);
  //poly->SpecialData = pe;

  int seen = polyNum;
  bool doStep = false;
  for (int mirror = XLevel.GetPolyobjMirror(polyNum); mirror; mirror = XLevel.GetPolyobjMirror(mirror)) {
    poly = XLevel.GetPolyobj(mirror);
    if (!poly) {
      printerror("EV_RotatePoly: invalid mirror polyobj num %s for pobj %s", mirror, polyNum);
      break;
    }
    // is mirroring poly is already in motion?
    if (!overRide && PolyobjThinker.IsPolyobjBusy(poly)) break;

    // using override actions will never work this way, so force-stop it
    // but let's not scare people ;-)
    if (mirror == seen) {
      printdebug("EV_RotatePoly: found mirror loop for pobj %s (this is harmless)", polyNum);
      break;
    }
    if (doStep) seen = XLevel.GetPolyobjMirror(seen);
    doStep = !doStep;

    pe = SpawnThinker(PolyobjRotator);
    //pe.polyobj = mirror;
    pe.dist = (byteAngle ? (byteAngle == 255 ? -1.0 : float(byteAngle)*(90.0/64.0)/*Angle*/) : 360.0);
    direction = -direction;
    pe.speed = /*AngleClamp360Signed*/(32.0*float(speed)*float(direction)*90.0/64.0/8.0); // was AngleMod180
    pe.thrust_force = pe.speed/32.0*float(0x800)/90.0; //THRUST
    pe.nolink = nolink;
    //printdebug("  dist=%s; speed=%s; thrust_force=%s", pe.dist, pe.speed, pe.thrust_force);
    PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);

    pe.AppendTo(poly);
    //poly->SpecialData = pe;
  }
  return true;
}


//==========================================================================
//
//  EV_MovePolyTo
//
//  po: polyobj to move
//  speed: how quickly the polyobject should move, in map units per octic.
//  target: the tid of the spot to which the polyobject should move.
//
//==========================================================================
/*final*/ bool EV_MovePolyToSpot (line_t *line, int Arg1, int Arg2, int Arg3, int Arg4,
                                  int Arg5, bool timesEight, bool overRide,
                                  optional bool nolink)
{
  int pnum = Arg1;
  int speed = Arg2;
  int ttid = Arg3;
  if (!speed || !ttid) return false;
  Entity ent = Level.FindMobjFromTID(ttid, none);
  if (!ent) return false;

  auto poly = XLevel.GetPolyobj(pnum);
  if (!poly) return false;

  TVec dst = vector(ent.Origin.x, ent.Origin.y, 0);
  TVec rel = vector(dst.x-poly.startSpot.x, dst.y-poly.startSpot.y, 0);
  if (!rel) return true;

  float dist = length2D(rel);
  if (dist < 1) return true;

  rel = normalize(rel);
  TAVec angles;
  VectorAngles(rel, out angles);
  return EV_MovePoly(line, pnum, speed, 0, 0, 0, timesEight, overRide, angles.yaw, dist);
}


//==========================================================================
//
//  EV_MovePoly
//
//  po: polyobj to move
//  2: speed
//  3: angle
//  4: distance
//
//==========================================================================
/*final*/ bool EV_MovePoly (line_t *line, int Arg1, int Arg2, int Arg3, int Arg4,
                            int Arg5, bool timesEight, bool overRide,
                            optional float floatAngle, optional float floatDist,
                            //optional bool ignoreThings,
                            optional int vspeed, optional int vdist,
                            optional bool nolink)
{
  int polyNum = Arg1;
  polyobj_t *poly = XLevel.GetPolyobj(polyNum);
  if (!poly) { printerror("EV_MovePoly: invalid polyobj num %s", polyNum); return false; }

  if (!overRide && PolyobjThinker.IsPolyobjBusy(poly)) return false; // poly is already moving

  // no z movement for non-3d pobjs
  if (!poly->posector) { vspeed = 0; vdist = 0; }

  float realDist = float(Arg4)*(timesEight ? 8.0 : 1.0);
  float realVDist = float(vdist)*(timesEight ? 8.0 : 1.0);
  float realSpeed = float(Arg2)*4.0;
  float realVSpeed = float(vspeed)*4.0;

  // just in case
  if (!poly->posector) { realVDist = 0; realVSpeed = 0; }

  //printdebug("EV_MovePoly: po=%s; vspeed=%s; vdist=%s", polyNum, realVSpeed, realVDist);

  PolyobjMover pe = SpawnThinker(PolyobjMover);
  //pe.ignoreThings = ignoreThings;
  //pe.polyobj = polyNum;
  pe.dist = realDist;
  if (specified_floatDist) pe.dist = floatDist;
  pe.speed = realSpeed;
  pe.thrust_force = pe.speed/8.0; //THRUST
  if (specified_vspeed) { pe.vspeed = realVSpeed; pe.vdist = realVDist; }

  float an = (specified_floatAngle ? floatAngle : float(Arg3)*(90.0/64.0));
  if (!Arg2) an = 0;
  pe.angle = an;
  pe.nolink = nolink;
  PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);

  pe.AppendTo(poly);
  //poly->SpecialData = pe;

  int seen = polyNum;
  bool doStep = false;
  for (int mirror = XLevel.GetPolyobjMirror(polyNum); mirror; mirror = XLevel.GetPolyobjMirror(mirror)) {
    poly = XLevel.GetPolyobj(mirror);
    if (!poly) {
      printerror("EV_MovePoly: invalid mirror polyobj num %s for pobj %s", mirror, polyNum);
      break;
    }
    if (!overRide && PolyobjThinker.IsPolyobjBusy(poly)) break; // mirroring poly is already in motion

    // using override actions will never work this way, so force-stop it
    // but let's not scare people ;-)
    if (mirror == seen) {
      printdebug("EV_MovePoly: found mirror loop for pobj %s (this is harmless)", polyNum);
      break;
    }
    if (doStep) seen = XLevel.GetPolyobjMirror(seen);
    doStep = !doStep;

    pe = SpawnThinker(PolyobjMover);
    //pe.polyobj = mirror;
    pe.dist = realDist;
    pe.speed = realSpeed;
    pe.thrust_force = pe.speed/8.0; //THRUST
    if (specified_vspeed) { pe.vspeed = realVSpeed; pe.vdist = realVDist; }
    if (Arg2) an = AngleMod360(an+180.0); // reverse the angle
    pe.angle = an;
    pe.nolink = nolink;
    PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);

    pe.AppendTo(poly);
    //poly->SpecialData = pe;
  }

  return true;
}


//==========================================================================
//
//  EV_OpenPolyDoor
//
//==========================================================================
/*final*/ bool EV_OpenPolyDoor (line_t *line, int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int type) {
  int polyNum;
  PolyobjDoor pd;
  polyobj_t *poly;
  float an = 0.0;

  polyNum = Arg1;
  poly = XLevel.GetPolyobj(polyNum);
  if (!poly) { printerror("EV_OpenPolyDoor: invalid polyobj num %s", polyNum); return false; }
  if (PolyobjThinker.IsPolyobjBusy(poly)) return false; // poly is already moving

  pd = SpawnThinker(PolyobjDoor);
  pd.type = type;
  //pd.polyobj = polyNum;
  if (type == PolyobjDoor::PODOOR_SLIDE) {
    pd.waitTime = float(Arg5)/35.0;
    pd.speed = float(Arg2)*4.0;
    pd.totalDist = float(Arg4);  // Distance
    pd.dist = pd.totalDist;
    an = float(Arg3)*(90.0/64.0);
    pd.xSpeed = cos(an);
    pd.ySpeed = sin(an);

    //thrust
    pd.thrust_force = pd.speed/8.0;

    PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);
  } else if (type == PolyobjDoor::PODOOR_SWING) {
    pd.waitTime = float(Arg4)/35.0;
    pd.speed = /*AngleClamp360Signed*/(4.0*float(Arg2)*(90.0/64.0)); // was AngleMod180
    pd.totalDist = float(Arg3)*(90.0/64.0);
    pd.dist = pd.totalDist;

    //THRUST
    pd.thrust_force = pd.speed*float(0x1000)/180.0;

    PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);
  }

  pd.AppendTo(poly);
  //poly->SpecialData = pd;

  int seen = polyNum;
  bool doStep = false;
  for (int mirror = XLevel.GetPolyobjMirror(polyNum); mirror; mirror = XLevel.GetPolyobjMirror(mirror)) {
    poly = XLevel.GetPolyobj(mirror);
    if (!poly) {
      printerror("EV_OpenPolyDoor: invalid mirror polyobj num %s for pobj %s", mirror, polyNum);
      break;
    }
    if (PolyobjThinker.IsPolyobjBusy(poly)) break; // mirroring poly is already in motion

    // using override actions will never work this way, so force-stop it
    // but let's not scare people ;-)
    if (mirror == seen) {
      printdebug("EV_OpenPolyDoor: found mirror loop for pobj %s (this is harmless)", polyNum);
      break;
    }
    if (doStep) seen = XLevel.GetPolyobjMirror(seen);
    doStep = !doStep;

    pd = SpawnThinker(PolyobjDoor);
    //pd.polyobj = mirror;
    pd.type = type;
    if (type == PolyobjDoor::PODOOR_SLIDE) {
      pd.waitTime = float(Arg5)/35.0;
      pd.speed = float(Arg2)*4.0;
      pd.totalDist = float(Arg4);  // Distance
      pd.dist = pd.totalDist;
      an = AngleMod360(an+180.0); // reverse the angle
      pd.xSpeed = cos(an);
      pd.ySpeed = sin(an);
      pd.thrust_force = pd.speed/8.0; //thrust
      PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);
    } else if (type == PolyobjDoor::PODOOR_SWING) {
      pd.waitTime = float(Arg4)/35.0;
      pd.speed = /*AngleClamp360Signed*/(4.0*float(-Arg2)*(90.0/64.0)); // was AngleMod180
      pd.totalDist = float(Arg3)*(90.0/64.0);
      pd.dist = pd.totalDist;
      pd.thrust_force = pd.speed*float(0x1000)/180.0; //THRUST
      PolyobjStartSequence(poly, GetSeqTrans(poly->seqType, SEQ_Door), 0);
    }

    pd.AppendTo(poly);
    //poly->SpecialData = pd;
  }

  return true;
}


//**************************************************************************
//
//  Light specials
//
//**************************************************************************

//==========================================================================
//
//  SpawnFireFlicker
//
//==========================================================================
/*final*/ void SpawnFireFlicker (sector_t *sector) {
  FireFlicker Flick = SpawnThinker(FireFlicker);
  if (Flick && !Flick.IsDestroyed) Flick.Init(sector);
}


//==========================================================================
//
//  SpawnGlowingLight
//
//  Spawn glowing light
//
//==========================================================================
/*final*/ void SpawnGlowingLight (sector_t *sector) {
  GlowingLight G = SpawnThinker(GlowingLight);
  if (G && !G.IsDestroyed) G.Init(sector);
}


//==========================================================================
//
//  SpawnLightFlash
//
//==========================================================================
/*final*/ void SpawnLightFlash (sector_t *sector) {
  LightFlash Flash = SpawnThinker(LightFlash);
  if (Flash && !Flash.IsDestroyed) Flash.Init(sector);
}


//==========================================================================
//
//  SpawnStrobeFlash
//
//==========================================================================
/*final*/ void SpawnStrobeFlash (sector_t *sector, int fastOrSlow, int maxtime, int inSync) {
  Strobe Flash = SpawnThinker(Strobe);
  if (Flash && !Flash.IsDestroyed) Flash.Init(sector, fastOrSlow, maxtime, inSync);
}


//==========================================================================
//
//  SpawnPhasedLight
//
//==========================================================================
/*final*/ void SpawnPhasedLight (sector_t *sector, int base, int index) {
  PhasedLight Phase = SpawnThinker(PhasedLight);
  if (Phase && !Phase.IsDestroyed) Phase.Init(sector, base, index);
}


//==========================================================================
//
//  SpawnLightSequence
//
//==========================================================================
/*final*/ void SpawnLightSequence (sector_t *sector, float indexStep) {
  int seqSpecial = SECSPEC_LightSequence; // look for Light_Sequence, first
  sector_t *sec = sector;
  float count = 1.0;
  do {
    sector_t *nextSec = nullptr;
    //  Make sure that the search doesn't back up.
    sec->special = (sec->special&~SECSPEC_BASE_MASK)|SECSPEC_LightSequenceStart;
    foreach (line_t *ln; sec.lines) {
      sector_t *tempSec = getNextSector(ln, sec);
      if (!tempSec) continue;
      if ((tempSec->special&SECSPEC_BASE_MASK) == seqSpecial) {
        if (seqSpecial == SECSPEC_LightSequence) {
          seqSpecial = SECSPEC_LightSequenceAlt;
        } else {
          seqSpecial = SECSPEC_LightSequence;
        }
        nextSec = tempSec;
        count += 1.0;
      }
    }
    sec = nextSec;
  } while (sec);

  sec = sector;
  count *= indexStep;
  float index = 0.0;
  float indexDelta = 64.0/count;
  int base = sector->params.lightlevel;
  do {
    sector_t *nextSec = nullptr;
    if (sec->params.lightlevel) base = sec->params.lightlevel;
    SpawnPhasedLight(sec, base, int(index));
    // clear sector special
    sec->special &= ~SECSPEC_BASE_MASK;
    index += indexDelta;
    foreach (line_t *ln; sec.lines) {
      sector_t *tempSec = getNextSector(ln, sec);
      if (!tempSec) continue;
      if ((tempSec->special&SECSPEC_BASE_MASK) == SECSPEC_LightSequenceStart) nextSec = tempSec;
    }
    sec = nextSec;
  } while (sec);
}


//==========================================================================
//
//  EV_StartLightStrobing
//
//  Start strobing lights (usually from a trigger)
//
//==========================================================================
/*final*/ int EV_StartLightStrobing (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  int Ret = 0;
  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    if (sec->LightingData) continue;
    Strobe Flash = SpawnThinker(Strobe);
    if (Flash && !Flash.IsDestroyed) {
      Ret = 1;
      Flash.Init(sec, Arg3, Arg2, Arg4);
    }
  }
  return Ret;
}


//==========================================================================
//
//  EV_TagLightTurnOn
//
//  Turn line's tag lights on
//
//==========================================================================
/*final*/ int EV_TagLightTurnOn (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    int Max = 0;
    foreach (line_t *ln; sec.lines) {
      sector_t *TSec = getNextSector(ln, sec);
      if (!TSec) continue;
      Max = max(Max, TSec->params.lightlevel);
    }
    sec->params.lightlevel = Max;
  }
  return 1;
}


//==========================================================================
//
//  EV_TurnTagLightsOff
//
//  Turn line's tag lights off
//
//==========================================================================
/*final*/ int EV_TurnTagLightsOff (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    int Min = sec->params.lightlevel;
    foreach (line_t *ln; sec.lines) {
      sector_t *TSec = getNextSector(ln, sec);
      if (!TSec) continue;
      Min = min(Min, TSec->params.lightlevel);
    }
    sec->params.lightlevel = Min;
  }
  return 1;
}


//============================================================================
//
//  EV_LightRaiseByValue
//
//============================================================================
/*final*/ bool EV_LightRaiseByValue (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  sector_t *sec;
  bool Rtn = false;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    sec->params.lightlevel = clamp(sec->params.lightlevel+Arg2, 0, 255);
    Rtn = true;
  }
  return Rtn;
}


//============================================================================
//
//  EV_LightLowerByValue
//
//============================================================================
/*final*/ bool EV_LightLowerByValue (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  sector_t *sec;
  bool Rtn = false;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    sec->params.lightlevel = clamp(sec->params.lightlevel-Arg2, 0, 255);
    Rtn = true;
  }
  return Rtn;
}


//============================================================================
//
//  EV_LightChangeToValue
//
//============================================================================
/*final*/ bool EV_LightChangeToValue (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  sector_t *sec;
  bool Rtn = false;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    sec->params.lightlevel = clamp(Arg2, 0, 255);
    Rtn = true;
  }
  return Rtn;
}


//============================================================================
//
//  EV_SpawnLight
//
//============================================================================
/*final*/ bool EV_SpawnLight (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Type) {
  sector_t *sec;
  bool Rtn = false;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    LightEffect Light = SpawnThinker(LightEffect);
    if (Light && !Light.IsDestroyed) {
      Light.Init(sec, Arg1, Arg2, Arg3, Arg4, Arg5, Type);
      Rtn = true;
    }
  }
  return Rtn;
}


//==========================================================================
//
//  EV_LightStop
//
//==========================================================================
/*final*/ bool EV_LightStop (int Tag) {
  Lighting L;
  foreach AllThinkers(Lighting, L) {
    if (IsSectorTagEqual(L.Sector, Tag)) {
      if (L.Sector->LightingData == L) L.Sector->LightingData = none;
      L.Destroy();
    }
  }
  return true;
}


//==========================================================================
//
//  SpawnTransferWallLight
//
//==========================================================================
/*final*/ void SpawnTransferWallLight (line_t *Line) {
  if (!Line) return;
  WallLightTransfer Tr = SpawnThinker(WallLightTransfer);
  if (Tr && !Tr.IsDestroyed) {
    Tr.Init(Line->frontsector, Line->arg1, Line->arg2, Line->arg3, Line->arg4, Line->arg5);
  }
}


//**************************************************************************
//
//  Scrollers
//
//**************************************************************************

//==========================================================================
//
//  SpawnScrollingFloor
//
//==========================================================================
/*final*/ void SpawnScrollingFloor (sector_t *Sector, int XDir, int YDir, int Speed) {
  if (!Sector) return;
  Scroller Scroll = SpawnThinker(Scroller);
  if (Scroll && !Scroll.IsDestroyed) {
    Scroll.InitFloor(Sector, XDir, YDir, Speed);
  }
}


//==========================================================================
//
//  SpawnWallScroller
//
//==========================================================================
/*final*/ void SpawnWallScroller (line_t *Line, int XDir, int YDir) {
  if (!Line) return;
  Scroller Scroll = SpawnThinker(Scroller);
  if (Scroll && !Scroll.IsDestroyed) {
    Scroll.InitWall(Line, XDir, YDir);
  }
}


//==========================================================================
//
//  SpawnWallOffsetsScroller
//
//==========================================================================
/*final*/ void SpawnWallOffsetsScroller (line_t *Line) {
  if (!Line) return;
  Scroller Scroll = SpawnThinker(Scroller);
  if (Scroll && !Scroll.IsDestroyed) {
    Scroll.InitWallOffsets(Line);
  }
}


//==========================================================================
//
//  SpawnTextureBothScroller
//
//==========================================================================
/*final*/ void SpawnTextureBothScroller (line_t *Line) {
  if (!Line) return;
  Scroller Scroll = SpawnThinker(Scroller);
  if (Scroll && !Scroll.IsDestroyed) {
    Scroll.InitTextureBoth(Line, float(Line->arg2-Line->arg3)/64.0, float(Line->arg5-Line->arg4)/64.0, 0, 7);
  }
}


//==========================================================================
//
//  SpawnScrollCeiling
//
//==========================================================================
/*final*/ void SpawnScrollCeiling (line_t *Line) {
  if (!Line) return;
  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Line->arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Line->arg1, hidx))
  {
    int secnum = sec-&XLevel.Sectors[0];
    Scroller Scroll = SpawnThinker(Scroller);
    if (Scroll && !Scroll.IsDestroyed) {
      Scroll.InitGen(Scroller::SCROLLEV_Ceiling, Line, secnum);
    }
  }
}


//==========================================================================
//
//  SpawnScrollFloor
//
//==========================================================================
/*final*/ void SpawnScrollFloor (line_t *Line) {
  if (!Line) return;
  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Line->arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Line->arg1, hidx))
  {
    int secnum = sec-&XLevel.Sectors[0];
    if (Line->arg3 != 1) {
      // scroll the floor texture
      Scroller Scroll = SpawnThinker(Scroller);
      if (Scroll && !Scroll.IsDestroyed) {
        Scroll.InitGen(Scroller::SCROLLEV_Floor, Line, secnum);
      }
    }

    if (Line->arg3 > 0) {
      // carry objects on the floor
      Scroller Scroll = SpawnThinker(Scroller);
      if (Scroll && !Scroll.IsDestroyed) {
        Scroll.InitGen(Scroller::SCROLLEV_Carry, Line, secnum);
      }
    }
  }
}


//==========================================================================
//
//  SpawnScrollTextureModel
//
//  Scroll wall according to linedef
//  (same direction and speed as scrolling floors)
//
//==========================================================================
/*final*/ void SpawnScrollTextureModel (line_t *Line) {
  if (!Line) return;
  int Searcher = -1;
  for (line_t *Other = XLevel.FindLine(Line->arg1, &Searcher); Other;
       Other = XLevel.FindLine(Line->arg1, &Searcher))
  {
    if (Line != Other) {
      Scroller Scroll = SpawnThinker(Scroller);
      if (Scroll && !Scroll.IsDestroyed) {
        Scroll.InitTextureModel(Other, Line);
      }
    }
  }
}


//==========================================================================
//
//  EV_ScrollTextureBoth
//
//==========================================================================
/*final*/ bool EV_ScrollTextureBoth (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  if (!Arg1) return false; // no lines to adjust

  int WhichSide = 0;
  if (Arg1 < 0) {
    WhichSide = 1;
    Arg1 = -Arg1;
  }

  SetWallScroller(Arg1, float(Arg2-Arg3)/64.0, float(Arg5-Arg4)/64.0, WhichSide, 7);
  return true;
}


//==========================================================================
//
//  EV_ScrollWall
//
//==========================================================================
/*final*/ bool EV_ScrollWall (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  if (!Arg1) return false; // no lines to adjust
  SetWallScroller(Arg1, float(Arg2)/float(0x10000), float(Arg3)/float(0x10000), !!Arg4, Arg5);
  return true;
}


//==========================================================================
//
//  SetWallScroller
//
//==========================================================================
/*final*/ void SetWallScroller (int LineId, float XSpeed, float YSpeed, int WhichSide, int Where) {
  Scroller Scroll;

  Where &= 7;
  if (!Where) return;

  if (!XSpeed && !YSpeed) {
    // as a special case with no deltas remove any texture scrolers
    foreach AllThinkers(Scroller, Scroll) {
      if (Scroll.Type != Scroller::SCROLLEV_Side) continue;
      // check if line has a correct tag
      if (!IsLineTagEqual(Scroll.AffecteeSrcLine, LineId)) continue;
      // check if it's the correct side
      if (Scroll.AffecteeSrcLine->sidenum[WhichSide] != Scroll.Affectee) continue;
      // check if it's scrolling the same wall parts
      if (Scroll.SideParts != Where) continue;
      // ok, destroy the thinker
      Scroll.Destroy();
    }
  } else {
    array!Scroller FoundScrollers;
    foreach AllThinkers(Scroller, Scroll) {
      if (Scroll.Type != Scroller::SCROLLEV_Side) continue;
      //  Check if line has a correct tag.
      if (!IsLineTagEqual(Scroll.AffecteeSrcLine, LineId)) continue;
      //  Check if it's the correct side.
      if (Scroll.AffecteeSrcLine->sidenum[WhichSide] != Scroll.Affectee) continue;
      //  Check if it's scrolling the same wall parts
      if (Scroll.SideParts != Where) continue;
      //  Found it.
      Scroll.AdjustTextureBoth(XSpeed, YSpeed);
      FoundScrollers[FoundScrollers.length] = Scroll;
    }

    int Searcher = -1;
    for (line_t *Other = XLevel.FindLine(LineId, &Searcher); Other;
         Other = XLevel.FindLine(LineId, &Searcher))
    {
      // check if this line already has scroller
      int i;
      for (i = 0; i < FoundScrollers.length; ++i) {
        if (FoundScrollers[i].Affectee == Other->sidenum[WhichSide]) break;
      }
      if (i == FoundScrollers.length) {
        // start a new scroller
        Scroll = SpawnThinker(Scroller);
        if (Scroll && !Scroll.IsDestroyed) {
          Scroll.InitTextureBoth(Other, XSpeed, YSpeed, WhichSide, Where);
        }
      }
    }
  }
}


//==========================================================================
//
//  EV_ScrollFloor
//
//==========================================================================
/*final*/ bool EV_ScrollFloor (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  // set floor scrolling
  if (Arg4 == 0 || Arg4 == 2) {
    SetScroller(Scroller::SCROLLEV_Floor, Arg1, Arg2, Arg3);
  } else {
    SetScroller(Scroller::SCROLLEV_Floor, Arg1, 0, 0);
  }

  // set carrying of items
  if (Arg4 > 0) {
    SetScroller(Scroller::SCROLLEV_Carry, Arg1, Arg2, Arg3);
  } else {
    SetScroller(Scroller::SCROLLEV_Carry, Arg1, 0, 0);
  }
  return true;
}


//==========================================================================
//
//  EV_ScrollCeiling
//
//==========================================================================
/*final*/ bool EV_ScrollCeiling (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  SetScroller(Scroller::SCROLLEV_Ceiling, Arg1, Arg2, Arg3);
  return true;
}


//==========================================================================
//
//  SetScroller
//
//==========================================================================
/*final*/ void SetScroller (int Type, int Arg1, int Arg2, int Arg3) {
  // adjust existing scrollers. If there is any, it means that all
  // tagged sectors have them and there's no need to spawn new ones.
  Scroller Sc;
  bool Found = false;
  foreach AllThinkers(Scroller, Sc) {
    if (Sc.Type == Type && IsSectorTagEqual(Sc.Sector, Arg1)) {
      Sc.SetSpeed(Arg2, Arg3);
      Found = true;
    }
  }

  if (Found) return;

  // don't spawn scrollers if both speeds are 0
  if (!Arg2 && !Arg3) return;

  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    int secnum = sec-&XLevel.Sectors[0];
    Sc = SpawnThinker(Scroller);
    if (Sc && !Sc.IsDestroyed) {
      Sc.InitScripted(Type, Arg2, Arg3, secnum);
    }
  }
}


//**************************************************************************
//
//  Transfering floor texture and sector special
//
//**************************************************************************

//==========================================================================
//
//  EV_FloorTransferTrigger
//
//==========================================================================
/*final*/ bool EV_FloorTransferTrigger (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, line_t *Line) {
  bool Rtn = false;
  sector_t *sec;
  if (!Line) return false;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    Rtn = true;
    sec->floor.pic = Line->frontsector->floor.pic;
    sec->special = (sec->special&SECSPEC_SECRET_MASK)|(Line->frontsector->special&~SECSPEC_SECRET_MASK);
  }
  return Rtn;
}


//==========================================================================
//
//  EV_FloorTransferNumeric
//
//==========================================================================
/*final*/ bool EV_FloorTransferNumeric (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  sector_t *sec;
  bool Rtn = false;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1, -1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    Rtn = true;
    sector_t *MdlSec = FindModelFloorSector(sec, GetPlanePointZ(ref sec->floor, sec->soundorg));
    if (MdlSec) {
      sec->floor.pic = MdlSec->floor.pic;
      sec->special = MdlSec->special;
    }
  }
  return Rtn;
}


//************************************************************************
//
//  Changing of sector properties
//
//************************************************************************

//=========================================================================
//
//  EV_SectorSoundChange
//
//=========================================================================
/*final*/ bool EV_SectorSoundChange (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  sector_t *sec;
  if (!Arg1) return false;
  bool rtn = false;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    sec.seqType = Arg2;
    rtn = true;
  }
  return rtn;
}


//=========================================================================
//
//  EV_SectorSetColor
//
//=========================================================================
/*final*/ bool EV_SectorSetColor(int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  sector_t *sec;
  int Col = RGBA(Arg2, Arg3, Arg4, 0);
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    sec.params.LightColor = Col;
  }
  return true;
}


//=========================================================================
//
//  EV_SectorSetFade
//
//=========================================================================
/*final*/ bool EV_SectorSetFade (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  sector_t *sec;
  int clrFade = RGBA(Arg2, Arg3, Arg4, 255);
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    sec.params.Fade = clrFade;
  }
  return true;
}


//=========================================================================
//
//  ConvertSpecialDamageType
//
//=========================================================================
name ConvertSpecialDamageType (int mod) {
  switch (mod) {
    //0 = MOD_UNKNOWN
    case 9: return 'BFGSplash'; // MOD_BFG_SPLASH
    case 12: return 'Drowning'; // MOD_WATER
    case 13: return 'Slime'; // MOD_SLIME
    case 14: return 'Fire'; // MOD_LAVA
    case 15: return 'Crush'; // MOD_CRUSH
    case 16: return 'Telefrag'; // MOD_TELEFRAG
    case 17: return 'Falling'; // MOD_FALLING
    case 18: return 'Suicide'; // MOD_SUICIDE
    //case 19: return ''; // MOD_BARREL //???
    case 20: return 'Exit'; // MOD_EXIT
    //case 21: return ''; // MOD_SPLASH //???
    case 22: return 'Melee'; // MOD_HIT
    case 23: return 'Railgun'; // MOD_RAILGUN
    case 24: return 'Ice'; // MOD_ICE (ala Hexen)
    case 25: return 'Disintegrate'; // MOD_DISINTEGRATE (ala Strife's Mauler)
    case 26: return 'Poison'; // MOD_POISON
    case 27: return 'Electric'; // MOD_ELECTRIC
    case 1000: return 'Massacre'; // Massacre (no constant)
  }
  return '';
}


//=========================================================================
//
//  EV_SectorSetDamage
//
//=========================================================================
/*final*/ bool EV_SectorSetDamage (int tag, int amount, int mod, int interval, int leaky) {
  sector_t *sec;
  if (!tag) return false; //k8: is this right?
  bool res = false;
  for (int hidx = XLevel.FindSectorFromTag(out sec, tag); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, tag, hidx))
  {
    sec.Damage = amount;
    sec.DamageType = ConvertSpecialDamageType(mod);
    sec.DamageInterval = (interval ? interval : -1); // fix for "0 is default"
    sec.DamageLeaky = (leaky ? leaky : -1); // fix for "0 is default"
    res = true;
  }
  return res;
}


//==========================================================================
//
//  EV_SectorSetGravity
//
//==========================================================================
/*final*/ bool EV_SectorSetGravity (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  bool Ret = false;
  sector_t *sec;

  if (Arg3 > 99) Arg3 = 99;
  float SecGrav = float(Arg2)+float(Arg3)*0.01;

  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    sec.Gravity = SecGrav;
    Ret = true;
  }
  return Ret;
}


//==========================================================================
//
//  SetSectorFriction
//
//==========================================================================
/*final*/ bool EV_SectorSetFriction (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5)
{
  bool Ret = false;

  // An amount of 100 should result in a friction of
  // ORIG_FRICTION (0xE800)
  // killough 8/28/98: prevent odd situations (clamping)
  int OldFriction = clamp((0x1EB8*Arg2)/0x80+0xD001, 0, 0x10000);

  // The following check might seem odd. At the time of movement,
  // the move distance is multiplied by 'friction/0x10000', so a
  // higher friction value actually means 'less friction'.

  // [RH] Twiddled these values so that momentum on ice (with
  //    friction 0xf900) is the same as in Heretic/Hexen.
  int OldMoveFactor;
  if (OldFriction >= 0xe800) { // ice
    //movefactor = ((0x10092 - friction)*(0x70))/0x158;
    OldMoveFactor = ((0x10092-OldFriction)*1024)/4352+568;
  } else {
    OldMoveFactor = ((OldFriction-0xDB34)*(0xA))/0x80;
  }

  // killough 8/28/98: prevent odd situations
  if (OldMoveFactor < 32) OldMoveFactor = 32;

  float Friction = (1.0-float(OldFriction)/float(0x10000))*35.0;
  float MoveFactor = float(OldMoveFactor)/float(0x10000);

  Ret = false;
  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    // killough 8/28/98:
    //
    // Instead of spawning thinkers, which are slow and expensive,
    // modify the sector's own friction values. Friction should be
    // a property of sectors, not objects which reside inside them.
    // Original code scanned every object in every friction sector
    // on every tic, adjusting its friction, putting unnecessary
    // drag on CPU. New code adjusts friction of sector only once
    // at level startup, and then uses this friction value.
    sec.Friction = Friction;
    sec.MoveFactor = MoveFactor;
    // when used inside a script, the sectors' friction flags can be enabled and disabled at will
    if (OldFriction == 0xe800) sec.special &= ~SECSPEC_FRICTION_MASK; else sec.special |= SECSPEC_FRICTION_MASK;
    Ret = true;
  }
  return Ret;
}


//=========================================================================
//
//  EV_SectorChangeFlags
//
//=========================================================================
/*final*/ bool EV_SectorChangeFlags (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  bool Rtn = false;
  if (!Arg1) return false;
  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
         if (Arg3&SECF_SILENT) sec->bSilent = false;
    else if (Arg2&SECF_SILENT) sec->bSilent = true;
         if (Arg3&SECF_NOFALLINGDAMAGE) sec->bNoFallingDamage = false;
    else if (Arg2&SECF_NOFALLINGDAMAGE) sec->bNoFallingDamage = true;
    Rtn = true;
  }
  return Rtn;
}


//==========================================================================
//
//  EV_SectorSetFloorPanning
//
//==========================================================================
/*final*/ bool EV_SectorSetFloorPanning (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  float XOffs = float(Arg2)+float(Arg3)/100.0;
  float YOffs = float(Arg4)+float(Arg5)/100.0;
  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    sec.floor.xoffs = XOffs;
    sec.floor.yoffs = YOffs;
    ClampSecPlaneOffsets(&sec.floor);
  }
  return true;
}


//==========================================================================
//
//  EV_SectorSetCeilingPanning
//
//==========================================================================
/*final*/ bool EV_SectorSetCeilingPanning (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  float XOffs = float(Arg2)+float(Arg3)/100.0;
  float YOffs = float(Arg4)+float(Arg5)/100.0;
  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    sec.ceiling.xoffs = XOffs;
    sec.ceiling.yoffs = YOffs;
    ClampSecPlaneOffsets(&sec.ceiling);
  }
  return true;
}


//==========================================================================
//
//  EV_SectorSetRotation
//
//==========================================================================
/*final*/ bool EV_SectorSetRotation (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  float afloor = AngleMod360(Arg2);
  float aceil = AngleMod360(Arg3);
  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    sec.floor.Angle = afloor;
    sec.ceiling.Angle = aceil;
  }
  return true;
}


//==========================================================================
//
//  EV_SectorSetFloorScale
//
//==========================================================================
/*final*/ bool EV_SectorSetFloorScale (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  float XScale = float(Arg2)+float(Arg3)/100.0;
  float YScale = float(Arg4)+float(Arg5)/100.0;
  if (XScale) XScale = 1.0/XScale;
  if (YScale) YScale = 1.0/YScale;

  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    if (XScale) sec.floor.XScale = XScale;
    if (YScale) sec.floor.YScale = YScale;
  }

  return true;
}


//==========================================================================
//
//  EV_SectorSetCeilingScale
//
//==========================================================================
/*final*/ bool EV_SectorSetCeilingScale (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  float XScale = float(Arg2)+float(Arg3)/100.0;
  float YScale = float(Arg4)+float(Arg5)/100.0;
  if (XScale) XScale = 1.0/XScale;
  if (YScale) YScale = 1.0/YScale;

  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    if (XScale) sec.ceiling.XScale = XScale;
    if (YScale) sec.ceiling.YScale = YScale;
  }

  return true;
}


//==========================================================================
//
//  EV_SectorSetFloorScale2
//
//==========================================================================
/*final*/ bool EV_SectorSetFloorScale2 (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  float XScale = float(Arg2)/float(0x10000);
  float YScale = float(Arg3)/float(0x10000);
  if (XScale) XScale = 1.0/XScale;
  if (YScale) YScale = 1.0/YScale;

  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    if (XScale) sec.floor.XScale = XScale;
    if (YScale) sec.floor.YScale = YScale;
  }

  return true;
}


//==========================================================================
//
//  EV_SectorSetCeilingScale2
//
//==========================================================================
/*final*/ bool EV_SectorSetCeilingScale2 (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  float XScale = float(Arg2)/float(0x10000);
  float YScale = float(Arg3)/float(0x10000);
  if (XScale) XScale = 1.0/XScale;
  if (YScale) YScale = 1.0/YScale;

  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    if (XScale) sec.ceiling.XScale = XScale;
    if (YScale) sec.ceiling.YScale = YScale;
  }

  return true;
}


//==========================================================================
//
//  EV_LineAlignFloor
//
//==========================================================================
/*final*/ bool EV_LineAlignFloor (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  int Searcher = -1;
  bool Ret = false;
  for (line_t *Line = XLevel.FindLine(Arg1, &Searcher); Line;
       Line = XLevel.FindLine(Arg1, &Searcher))
  {
    sector_t *sec = (Arg2 ? Line->backsector : Line->frontsector);
    if (!sec) continue;

    TVec v1 = *Line->v1;

    float Angle = atan2(Line->v2->y-v1.y, Line->v2->x-v1.x);
    float Norm = Angle-90.0;
    float Dist = -(cos(Norm)*v1.x+sin(Norm)*v1.y);

    if (Arg2) {
      Angle = AngleMod360(Angle+180.0);
      Dist = -Dist;
    }

    sec->floor.BaseAngle = Angle;
    while (Dist < 0.0) Dist += 256.0;
    while (Dist >= 256.0) Dist -= 256.0;
    sec->floor.BaseYOffs = Dist;
    Ret = true;
  }

  return Ret;
}


//==========================================================================
//
//  EV_LineAlignCeiling
//
//==========================================================================
/*final*/ bool EV_LineAlignCeiling (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  int Searcher = -1;
  bool Ret = false;
  for (line_t *Line = XLevel.FindLine(Arg1, &Searcher); Line;
       Line = XLevel.FindLine(Arg1, &Searcher))
  {
    sector_t *sec = (Arg2 ? Line->backsector : Line->frontsector);
    if (!sec) continue;

    TVec v1 = *Line->v1;

    float Angle = atan2(Line->v2->y-v1.y, Line->v2->x-v1.x);
    float Norm = Angle-90.0;
    float Dist = -(cos(Norm)*v1.x+sin(Norm)*v1.y);

    if (Arg2) {
      Angle = AngleMod360(Angle+180.0);
      Dist = -Dist;
    }

    sec->ceiling.BaseAngle = Angle;
    while (Dist < 0.0) Dist += 256.0;
    while (Dist >= 256.0) Dist -= 256.0;
    sec->ceiling.BaseYOffs = Dist;
    Ret = true;
  }

  return Ret;
}


//==========================================================================
//
//  EV_LineSetTextureOffset
//
//==========================================================================
/*final*/ bool EV_LineSetTextureOffset (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  // check if the side is valid
  if (Arg4 < 0 || Arg4 > 1) return false;

  int NoChange = 0x7fff0000;

  int Searcher = -1;
  for (line_t *Line = XLevel.FindLine(Arg1, &Searcher); Line;
       Line = XLevel.FindLine(Arg1, &Searcher))
  {
    if (Line->sidenum[Arg4] < 0) continue;
    side_t *Side = &XLevel.Sides[Line->sidenum[Arg4]];

    // X offset
    if (Arg2 != NoChange) {
      float Offs = float(Arg2)/float(0x10000);
      if (!(Arg5&8)) {
        // set
        if (Arg5&1) Side->Top.TextureOffset = Offs;
        if (Arg5&2) Side->Mid.TextureOffset = Offs;
        if (Arg5&4) Side->Bot.TextureOffset = Offs;
      } else {
        // add
        if (Arg5&1) Side->Top.TextureOffset += Offs;
        if (Arg5&2) Side->Mid.TextureOffset += Offs;
        if (Arg5&4) Side->Bot.TextureOffset += Offs;
      }
    }

    // Y offset
    if (Arg3 != NoChange) {
      float Offs = float(Arg3)/float(0x10000);
      if (!(Arg5&8)) {
        // set
        if (Arg5&1) Side->Top.RowOffset = Offs;
        if (Arg5&2) Side->Mid.RowOffset = Offs;
        if (Arg5&4) Side->Bot.RowOffset = Offs;
      }
      else {
        // add
        if (Arg5&1) Side->Top.RowOffset += Offs;
        if (Arg5&2) Side->Mid.RowOffset += Offs;
        if (Arg5&4) Side->Bot.RowOffset += Offs;
      }
    }
    ClampSideOffsets(Side);
  }

  return true;
}


//**************************************************************************
//
//  Thing line specials
//
//**************************************************************************

//==========================================================================
//
//  EV_ThingProjectile
//
//==========================================================================
override bool EV_ThingProjectile (int Arg1, int Arg2, int Arg3, int Arg4,
  int Arg5, int agravity, int newtid, name TypeName, Entity Activator)
{
  return DoThingProjectile(
    tid:Arg1, TypeID:Arg2, AAngle:Arg3, ASpeed:Arg4, AVSpeed:Arg5,
    agravity, newtid, TypeName, Activator, DestTID:0, ForceDest:none, Intercept:false);
}


//==========================================================================
//
//  EV_ThingProjectileAimed
//
//==========================================================================
/*final*/ bool EV_ThingProjectileAimed (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, Entity Activator) {
  return DoThingProjectile(tid:Arg1, TypeID:Arg2, AAngle:0, ASpeed:Arg3, AVSpeed:0,
    agravity:0, newtid:Arg5, TypeName:'', Activator, DestTID:Arg4,
    ForceDest:Activator, Intercept:false);
}


//==========================================================================
//
//  EV_ThingProjectileIntercept
//
//==========================================================================
/*final*/ bool EV_ThingProjectileIntercept (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, Entity Activator)
{
  return DoThingProjectile(tid:Arg1, TypeID:Arg2, AAngle:0, ASpeed:Arg3, AVSpeed:0,
    agravity:0, newtid:Arg5, TypeName:'', Activator, DestTID:Arg4,
    ForceDest:Activator, Intercept:true);
}


//==========================================================================
//
//  DoThingProjectile
//
//==========================================================================
/*final*/ bool DoThingProjectile (int tid, int TypeID, int AAngle, int ASpeed,
  int AVSpeed, int agravity, int newtid, name TypeName, Entity Activator,
  int DestTID, Entity ForceDest, bool Intercept)
{
  class!EntityEx moType;
  bool success = false;

  if (TypeName) {
    moType = class!EntityEx(FindClassNoCase(TypeName));
  }
  else {
    moType = class!EntityEx(FindClassFromScriptId(TypeID, LineSpecialGameInfo(Game).GameFilterFlag));
  }
  moType = class!EntityEx(moType.Replacement);
  if (!moType) return false;

  if (Level.Game.nomonsters && moType.default.bMonster) return false;

  float angle = float(AAngle)*(360.0/256.0);
  float speed = float(ASpeed)/8.0;
  float vspeed = float(AVSpeed)/8.0;

  //print("projectile '%C', vspeed=%f (%f); intercept=%B", moType, AVSpeed, vspeed, Intercept);
  foreach (EntityEx A; eachTID(tid, Activator)) {
    Entity Targ = ForceDest;
    if (DestTID) {
      Targ = FindMobjFromTID(DestTID, none);
      if (!Targ) continue;
      if (Targ == self) Targ = none; // just in case
    }

    EntityEx newA = Spawn(moType, A.Origin);
    if (!newA || newA.IsDestroyed) {
      if (!tid) break;
      continue;
    }

    //print("proj %C: org=%s; A=%C", newA, A.Origin, A);
    //print("%C: *** special:%B; agravity:%B, nogravity:%B; grav=%f", newA, newA.bSpecial, agravity, newA.bNoGravity, newA.Gravity);
    if (newA.SightSound) newA.PlaySound(newA.SightSound, CHAN_VOICE);

    newA.Target = A; // originator
    if (Targ) {
      TVec TargOrg = Targ.Origin+vector(0.0, 0.0, Targ.Height/2.0);
      TVec Delta = TargOrg-newA.Origin;
      TVec TargVel = Targ.Velocity;

      if (!Targ.bNoGravity && Targ.WaterLevel < 3) {
        // If the target is subject to gravity and not underwater,
        // assume that it isn't moving vertically. Thanks to gravity,
        // even if we did consider the vertical component of the target's
        // velocity, we would still miss more often than not.
        TargVel.z = 0.0;
      }

      if (Intercept && speed > 0.0 && (TargVel.x || TargVel.y || TargVel.z)) {
        // aiming at the target's position some time in the future
        // is basically just an application of the law of sines:
        //     a/sin(A) = b/sin(B)

        float Dist = Length(Delta);
        float TargSpeed = Length(TargVel)/35.0;
        float YDotX = DotProduct(-Delta, TargVel)/35.0;
        float arccos = acos(FClamp(YDotX/TargSpeed/Dist, -1.0, 1.0));
        float Multiplier = (Random()-Random())*0.1+1.1;
        float SinB = FClamp(TargSpeed*Multiplier*sin(arccos)/speed, -1.0, 1.0);

        // use the cross product of two of the triangle's sides to get a rotation vector
        TVec rv = CrossProduct(TargVel, Delta);
        // the vector must be normalized
        rv = Normalise(rv);
        // rotate around this vector
        TVec AimVec = RotateVectorAroundVector(Delta, rv, asin(SinB));
        // and make the projectile follow that vector at the desired speed
        float AimScale = speed/Dist*35.0;
        newA.Velocity = AimVec*AimScale;
        newA.Angles.yaw = atan2(newA.Velocity.y, newA.Velocity.x);
      } else {
        newA.Angles.yaw = atan2(Delta.y, Delta.x);
        newA.Velocity = Normalise(Delta)*speed*35.0;
      }
      if (newA.bSeekerMissile) newA.Tracer = EntityEx(Targ);
    } else {
      newA.Angles.yaw = angle;
      newA.Velocity.x = speed*cos(angle)*35.0;
      newA.Velocity.y = speed*sin(angle)*35.0;
      newA.Velocity.z = vspeed*35.0;
    }

    if (newA.bSpecial) newA.bDropped = true; // Don't respawn
    if (agravity) {
      newA.bNoGravity = false;
      //if (!(mobj->flags3 & MF3_ISMONSTER) && agravity == 1) // gozzo checks this, VaVoom did no checks
      if (agravity == 1 && !newA.bMonster) newA.Gravity = 0.125; // 1.0/8.0
    } else {
      newA.bNoGravity = true;
    }
    newA.SetTID(newtid);

    if (newA.bMissile) {
      if (newA.CheckMissileSpawn()) success = true;
    } else if (!newA.TestLocation()) {
      //  If it counts as kill, adjust total kills count
      if (newA.CountsAsKill()) --TotalKills;
      //  Same for items.
      if (newA.bCountItem) --TotalItems;
      newA.Destroy();
    } else {
      success = true;
    }

    if (!tid) break;
  }

  return success;
}


//==========================================================================
//
//  EV_ThingSpawn
//
//==========================================================================
/*final*/ bool EV_ThingSpawn (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
                              bool fog, bool Facing, Entity Activator)
{
  bool success = false;
  int tid = Arg1;

  class!EntityEx moType = class!EntityEx(FindClassFromScriptId(Arg2, LineSpecialGameInfo(Game).GameFilterFlag));
  moType = class!EntityEx(moType.Replacement); //k8: dunno if we need this
  if (!moType) return false;

  if (Level.Game.nomonsters && moType.default.bMonster) return false;

  float angle = float(Arg3)*360.0/256.0;
  foreach (EntityEx A; eachTID(tid, Activator)) {
    EntityEx newAct = Spawn(moType, A.Origin);
    if (!newAct || newAct.IsDestroyed) {
      if (!tid) break;
      continue;
    }
    if (newAct.bFloatBob) {
      newAct.Origin.z = A.Origin.z-A.FloorZ;
      newAct.SetOrigin2(newAct.Origin, properFloorCheck:false);
    }
    if (!newAct.TestLocation()) {
      // didn't fit
      // if it counts as kill, adjust total kills count
      if (newAct.CountsAsKill()) --TotalKills;
      // same for items
      if (newAct.bCountItem) --TotalItems;
      newAct.Destroy();
    } else {
      newAct.Angles.yaw = Facing ? A.Angles.yaw : angle;
      newAct.SetTID(Arg4);
      if (fog) Spawn(TeleportFog, A.Origin+vector(0.0, 0.0, LineSpecialGameInfo(Game).TeleFogHeight));

      if (newAct.bSpecial) newAct.bDropped = true; // don't respawn
      /* no need to do this, bobbing is done in renderer
      if (newAct.bFloatBob) newAct.Special1f = newAct.Origin.z-newAct.FloorZ;
      */
      success = true;
    }
    if (!tid) break;
  }
  return success;
}


//==========================================================================
//
//  AcsSpawnThing
//
//==========================================================================
override int AcsSpawnThing (name Name, TVec Org, int Tid, float Angle, bool forced) {
  class EClass = FindClassNoCase(Name);
  if (!EClass) {
    if (!SetNamePutElement('AcsSpawnThing:NoClass', Name)) print("AcsSpawnThing: No such class `%s`", Name);
    return false;
  }

  class!EntityEx EntClass = class!EntityEx(EClass);
  if (!EntClass) {
    if (!SetNamePutElement('AcsSpawnThing:NotActorClass', Name)) print("AcsSpawnThing: `%s` is not an actor class", Name);
    return false;
  }
  //k8: should we ignore replacement here?
  auto repl = class!EntityEx(GetClassReplacement(EntClass));
  if (repl) EntClass = repl;

  if (Level.Game.nomonsters && EntClass.default.bMonster) return false;

  EntityEx NewAct = Spawn(EntClass, Org);
  //printdebug("AcsSpawnThing: name=%s(%C); forced=%B; TID=%s org: %s : %s", Name, EntClass, forced, Tid, Org, NewAct.Origin);
  bool PrevPassMobj = NewAct.bPassMobj;
  NewAct.bPassMobj = true;
  if (!forced) {
    if (!NewAct.TestLocation()) {
      // didn't fit
      // if it counts as kill, subtract total
      if (NewAct.CountsAsKill()) --Level.TotalKills;
      // the same for items
      if (NewAct.bCountItem) --Level.TotalItems;
      NewAct.Destroy();
      return false;
    }
  }
  NewAct.bPassMobj = PrevPassMobj;

  NewAct.Angles.yaw = Angle;
  NewAct.SetTID(Tid);
  if (NewAct.bSpecial) NewAct.bDropped = true; // don't respawn
  return true;
}


//==========================================================================
//
//  AcsSpawnSpot
//
//==========================================================================
override int AcsSpawnSpot (name Name, int SpotTid, int Tid, float Angle, bool forced) {
  int NumSpawned = 0;
  foreach (EntityEx A; eachTID(SpotTid)) {
    NumSpawned += AcsSpawnThing(Name, A.Origin, Tid, Angle, forced);
  }
  return NumSpawned;
}


//==========================================================================
//
//  AcsSpawnSpotFacing
//
//==========================================================================
override int AcsSpawnSpotFacing (name Name, int SpotTid, int Tid, bool forced) {
  int NumSpawned = 0;
  foreach (EntityEx A; eachTID(SpotTid)) {
    NumSpawned += AcsSpawnThing(Name, A.Origin, Tid, A.Angles.yaw, forced:forced);
  }
  return NumSpawned;
}


//==========================================================================
//
//  AcsDamageActor
//
//==========================================================================
override int AcsDamageActor (int targettid, int targetptr, int inflictortid, int inflictorptr, int damage, name damagetype, Entity Activator) {
  // get target
  EntityEx tgt = EntityEx(targettid ? FindMobjFromTID(targettid, none) : Activator);
  if (!tgt) return -1;
  tgt = EntityEx(tgt.DecorDoAAPtr('AcsDamageActor:tgt', targetptr));
  if (!tgt) return -1;

  // get inflictor
  EntityEx ifc = EntityEx(inflictortid ? FindMobjFromTID(inflictortid, none) : Activator);
  if (ifc) ifc = EntityEx(ifc.DecorDoAAPtr('AcsDamageActor:ifc', inflictorptr));

  //k8: clamp damage, just because
  return tgt.Damage(ifc, ifc, clamp(damage, 0, 100000), damagetype);
}


//==========================================================================
//
//  AcsSpawnDecal
//
//==========================================================================
override int AcsSpawnDecal (Entity ent, name decalname, TVec org, float dist, float angle, bool permanent) {
  EntityEx ee = EntityEx(ent);
  if (!ee) return 0;
  if (!decalname || nameEquCI(decalname, 'none')) return 0;
  if (!dist) dist = 64.0f;
  if (dist <= 0) return 0;
  TVec dir = AngleYawVector(angle);
  // offset by radius?
  bool res = ee.TraceSplat(org, dir, dist, aDecalName:decalname, doRailings:true, permanent:permanent);
  return (res ? 1 : 0);
}


//==========================================================================
//
//  EV_ThingActivate
//
//==========================================================================
/*final*/ bool EV_ThingActivate (int tid, EntityEx Activator) {
  bool success = false;
  foreach (EntityEx A; eachTID(tid, Activator)) {
    if (A.Activate(Activator)) success = true;
  }
  return success;
}


//==========================================================================
//
//  EV_ThingDeactivate
//
//==========================================================================
/*final*/ bool EV_ThingDeactivate (int tid, EntityEx Activator) {
  bool success = false;
  foreach (EntityEx A; eachTID(tid, Activator)) {
    if (A.Deactivate(Activator)) success = true;
  }
  return success;
}


//==========================================================================
//
//  EV_ThingRemove
//
//==========================================================================
/*final*/ bool EV_ThingRemove (int tid, Entity activator) {
  bool success = false;
  foreach (EntityEx A; Level.eachTID(tid, activator)) {
    //  Be friendly to level statistics.
    if (A.CountsAsKill() && A.Health > 0) --TotalKills;
    if (A.bCountItem) --TotalItems;
    A.RemoveThing();
    success = true;
  }
  return success;
}


//==========================================================================
//
//  EV_ThingDestroy
//
//==========================================================================
/*final*/ bool EV_ThingDestroy (int tid, int Extreme, Entity activator) {
  bool success = false;
  foreach (EntityEx A; eachTID(tid, activator)) {
    if (A.bShootable) {
      A.Damage(none, none, (Extreme ? 1000000 : A.Health), '', forced:true, spawnBlood:true);
      success = true;
    }
  }
  return success;
}


//===========================================================================
//
//  EV_HealThing
//
//===========================================================================
/*final*/ bool EV_HealThing (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, EntityEx A) {
  if (A) {
    int Max = Arg2;

    if (Max == 0 || !A.bIsPlayer) {
      A.GiveBody(Arg1);
      return true;
    }

    if (Max == 1) {
      Max = 200;
      class!Health SClass = class!Health(FindClass('Soulsphere'));
      if (SClass) Max = SClass.default.MaxAmount;
    }

    // if health is already above max, do nothing
    if (A.Health < Max) {
      A.Health += Arg1;
      if (A.Health > Max && Max > 0) A.Health = Max;
      A.Player.Health = A.Health;
    }
  }

  return !!A;
}


//==========================================================================
//
//  EV_ThingDamage
//
//==========================================================================
/*final*/ int EV_ThingDamage (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, Entity Activator) {
  return DoThingDamage(Arg1, Arg2, ModToDamageType(Arg3), Activator);
}


//==========================================================================
//
//  DoThingDamage
//
//==========================================================================
override int DoThingDamage (int Tid, int Amount, name DmgType, Entity Activator) {
  int NumDamaged = 0;
  foreach (EntityEx A; eachTID(Tid, Activator)) {
    if (A.bShootable) {
      if (Amount > 0) {
        A.Damage(none, EntityEx(Activator), Amount, DmgType, spawnBlood:true);
      } else if (A.Health < A.InitialHealth) {
        // negative amount heals thing
        A.Health -= Amount;
        if (A.Health > A.InitialHealth) A.Health = A.InitialHealth;
        if (A.bIsPlayer) A.Player.Health = A.Health;
      }
      ++NumDamaged;
    }
  }
  return NumDamaged;
}


//===========================================================================
//
//  EV_ThingSetGoal
//
//===========================================================================
/*final*/ bool EV_ThingSetGoal (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  EntityEx NewGoal = none;
  foreach (EntityEx Ent; eachTID(Arg2)) {
    if (!Ent.IsA('PatrolPoint')) continue;
    NewGoal = Ent;
    break;
  }

  bool Ret = false;
  foreach (EntityEx E; eachTID(Arg1)) {
    Ret = true;
    if (E.bShootable) {
      E.Goal = NewGoal;
      E.bChaseGoal = !!Arg4;
      if (!E.Target) E.ReactionTime = float(Arg3);
    }
  }

  return Ret;
}


//===========================================================================
//
//  EV_ChangeCamera
//
//===========================================================================
/*final*/ bool EV_ChangeCamera (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, EntityEx A) {
  Entity Camera = none;
  if (Arg1) Camera = FindMobjFromTID(Arg1, none);

  if (!A || !A.Player || Arg2) {
    BasePlayer P;
    foreach AllActivePlayers(P) {
      if (Camera) {
        P.Camera = Camera;
        if (Arg3) PlayerEx(P).bRevertCamera = true;
      } else {
        P.Camera = P.MO;
        PlayerEx(P).bRevertCamera = false;
      }
    }
  } else {
    if (Camera) {
      A.Player.Camera = Camera;
      if (Arg3) PlayerEx(A.Player).bRevertCamera = true;
    } else {
      A.Player.Camera = A;
      PlayerEx(A.Player).bRevertCamera = false;
    }
  }

  return true;
}


//===========================================================================
//
//  EV_ThingSetTranslation
//
//===========================================================================
/*final*/ bool EV_ThingSetTranslation (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, EntityEx A) {
  int Trans;
  if (Arg2 == -1 && A) {
    Trans = A.Translation;
  } else if (Arg2 >= 1 && Arg2 < VLevel::MAX_LEVEL_TRANSLATIONS) {
    Trans = (Entity::TRANSL_Level<<Entity::TRANSL_TYPE_SHIFT)+Arg2-1;
  } else {
    Trans = 0;
  }

  bool Ret = false;
  if (Arg1) {
    foreach (EntityEx Ent; eachTID(Arg1)) {
      Ret = true;
      Ent.Translation = Trans ? Trans : Ent.default.Translation;
    }
  } else if (A) {
    Ret = true;
    A.Translation = (Trans ? Trans : A.default.Translation);
  }
  return Ret;
}


//===========================================================================
//
//  EV_ThingHate
//
//===========================================================================
/*final*/ bool EV_ThingHate (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, EntityEx A) {
  EntityEx Hatee = none;
  bool NothingToHate = false;

  if (Arg2) {
    foreach (Hatee; eachTID(Arg2)) {
      if (Hatee.bShootable && // can't hate nonshootable things
          Hatee.Health > 0 && // can't hate dead things
          !Hatee.bDormant)  // can't target dormant things
      {
        break;
      }
    }
    if (!Hatee) NothingToHate = true;
  }

  if (Arg1 == 0 && Arg2 == 0) {
    // cannot hate itself
    Hatee = none;
    NothingToHate = true;
  }

  /*
  if (Arg1 == 0) {
    if (A && A.bIsPlayer) return false; // Players cannot have their attitudes set
    Hater = A;
  }
  else
  {
    for (Hater = EntityEx(FindMobjFromTID(Arg1, none)); Hater;
      Hater = EntityEx(FindMobjFromTID(Arg1, Hater)))
    {
      if (Hater.Health > 0 && Hater.bShootable)
      {
        break;
      }
    }
  }
  */

  foreach (EntityEx Hater; eachTID(Arg1, A)) {
    if (Hater.bIsPlayer) continue; // players cannot have their attitudes set
    if (Hater.Health <= 0 || !Hater.bShootable) continue;
    if (!Hater.SeeState) continue; // can't hate if can't attack
    // If hating a group of things, record the TID and nullptr
    // the target (if its TID doesn't match). A_Look will
    // find an appropriate thing to go chase after.
    if (Arg3) {
      Hater.TIDToHate = Arg2;
      Hater.LastLookActor = none;

      // if the TID to hate is 0, then don't forget the target and lastenemy fields
      if (Arg2) {
        if (Hater.Target && Hater.Target.TID != Arg2) Hater.Target = none;
        if (Hater.LastEnemy && Hater.LastEnemy.TID != Arg2) Hater.LastEnemy = none;
      }
    }
    // Hate types for Arg3:
    //
    // 0 - Just hate one specific actor
    // 1 - Hate actors with given TID and attack players when shot
    // 2 - Same as 1, but will go after enemies without seeing them first
    // 3 - Hunt actors with given TID and also players
    // 4 - Same as 3, but will go after monsters without seeing them first
    // 5 - Hate actors with given TID and ignore player attacks
    // 6 - Same as 5, but will go after enemies without seeing them first

    // Note here: If you use Thing_Hate (tid, 0, 2), you can make
    // a monster go after a player without seeing him first.
    Hater.bNoSightCheck = (Arg3 == 2 || Arg3 == 4 || Arg3 == 6);
    Hater.bHuntPlayers = (Arg3 == 3 || Arg3 == 4);
    Hater.bNoHatePlayers = (Arg3 == 5 || Arg3 == 6);

    if (Arg2 == 0) {
      Hatee = A;
    } else if (NothingToHate) {
      Hatee = none;
    } else if (Arg3) {
      do {
        Hatee = EntityEx(FindMobjFromTID(Arg2, Hatee));
      } while (!Hatee ||
               Hatee == Hater ||   // can't hate self
               !Hatee.bShootable ||  // can't hate nonshootable things
               Hatee.Health <= 0 ||  // can't hate dead things
               Hatee.bDormant);
    }

    if (Hatee && Hatee != Hater && (Arg3 == 0 || (Hater.Goal && Hater.Target != Hater.Goal))) {
      if (Hater.Target) Hater.LastEnemy = Hater.Target;
      Hater.Target = Hatee;
      if (!Hater.bDormant) {
        if (Hater.Health > 0) Hater.SetState(Hater.SeeState);
      }
    }
  }
  return true;
}


//===========================================================================
//
//  EV_ThingMove
//
//===========================================================================
/*final*/ bool EV_ThingMove (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, EntityEx A) {
  if (Arg1) A = EntityEx(FindMobjFromTID(Arg1, none));
  EntityEx Dest = EntityEx(FindMobjFromTID(Arg2, none));

  if (A && Dest) {
    TVec OldOrg = A.Origin;
    A.SetOrigin(Dest.Origin, properFloorCheck:true); //k8: really?
    if (A.TestLocation()) {
      if (Arg3) {
        Spawn(TeleportFog, OldOrg+vector(0.0, 0.0, LineSpecialGameInfo(Game).TeleFogHeight));
        Spawn(TeleportFog, A.Origin+vector(0.0, 0.0, LineSpecialGameInfo(Game).TeleFogHeight));
      }
      return true;
    } else {
      A.SetOrigin(OldOrg, properFloorCheck:true); //k8: really?
      return false;
    }
  }
  return false;
}


//===========================================================================
//
//  EV_ThingSetSpecial
//
//  It's recomended to use SetThingSpecial ACS command that can set all 5
// arguments.
//
//===========================================================================
/*final*/ bool EV_ThingSetSpecial (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, EntityEx A) {
  bool success = false;
  foreach (EntityEx Ent; eachTID(Arg1, A)) {
    Ent.Special = Arg2;
    Ent.Args[0] = Arg3;
    Ent.Args[1] = Arg4;
    Ent.Args[2] = Arg5;
    success = true;
  }
  return success;
}


//===========================================================================
//
//  EV_ThrustThingZ
//
//  (tid, force, up/down, set/add)
//
//===========================================================================
/*final*/ bool EV_ThrustThingZ (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, EntityEx A) {
  float Force = float(Arg2)*35.0/4.0;
  if (Arg3) Force = -Force;

  bool success = false;
  foreach (EntityEx Ent; eachTID(Arg1, A)) {
    //print("THRUSTZ for '%C', force=%s (%s), oldz=%f", Ent, Force, Arg4, Ent.Velocity.z);
    if (!Arg4) Ent.Velocity.z = 0;
    Ent.Velocity.z = fclamp(Ent.Velocity.z+Force, -4096, 4096); // k8: why not?
    //if (!Arg4) Ent.Velocity.z = Force; else Ent.Velocity.z += Force;
    success = true;
  }
  return success;

  /*
  if (Arg1) {
    foreach (Entity Ent; eachTID(Arg1)) {
      if (!Arg4) Ent.Velocity.z = Force; else Ent.Velocity.z += Force;
    }
    return true;
  }

  if (A) {
    if (!Arg4) A.Velocity.z = Force; else A.Velocity.z += Force;
    return true;
  }

  return false;
  */
}


//===========================================================================
//
//  EV_ThingChangeTID
//
//===========================================================================
/*final*/ bool EV_ThingChangeTID (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, EntityEx A) {
  foreach (EntityEx Ent; eachTID(Arg1, A)) {
    if (Ent.TID != Arg2) Ent.SetTID(Arg2);
  }
  return true;
}


//===========================================================================
//
//  EV_ThingStop
//
//===========================================================================
/*final*/ bool EV_ThingStop (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, EntityEx A) {
  bool Ret = false;
  foreach (EntityEx Ent; eachTID(Arg1, A)) {
    Ent.Velocity = vector(0.0, 0.0, 0.0);
    Ret = true;
  }
  return Ret;
}


//===========================================================================
//
//  EV_SetPlayerProperty
//
//===========================================================================
/*final*/ bool EV_SetPlayerProperty (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, EntityEx A) {
  if (!Arg1) {
    if (!A || !A.bIsPlayer) return false;
    return A.SetPlayerProperty(Arg3, Arg2);
  } else {
    bool Ret = false;
    foreach (int i; 0..MAXPLAYERS) {
      if (!Game.Players[i] || !Game.Players[i].bSpawned || !Game.Players[i].MO) continue;
      if (EntityEx(Game.Players[i].MO).SetPlayerProperty(Arg3, Arg2)) Ret = true;
    }
    return Ret;
  }
}


//===========================================================================
//
//  EV_ThingRaise
//
//===========================================================================
/*final*/ bool EV_ThingRaise (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, EntityEx A) {
  bool Ret = false;
  foreach (EntityEx Ent; eachTID(Arg1, A)) {
    if (Ent.DoThingRaise()) Ret = true;
  }
  return Ret;
}


//**************************************************************************
//
//  Force field
//
//**************************************************************************

//==========================================================================
//
//  EV_ForceField
//
//==========================================================================
/*final*/ bool EV_ForceField (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, EntityEx A) {
  if (A && !A.IsDestroyed) {
    A.Damage(none, none, 16, '', spawnBlood:true);
    A.Velocity.x += 7.8125*cos(A.Angles.yaw+180.0)*35.0;
    A.Velocity.y += 7.8125*sin(A.Angles.yaw+180.0)*35.0;
  }
  return true;
}


//==========================================================================
//
//  EV_RemoveForceField
//
//==========================================================================
/*final*/ bool EV_RemoveForceField (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx))
  {
    foreach (line_t *secline; sec.lines) {
      if (secline->special != LNSPEC_ForceField) continue;
      if (!(secline->flags&ML_TWOSIDED)) continue;

      XLevel.Sides[secline->sidenum[0]].MidTexture = 0;
      XLevel.Sides[secline->sidenum[1]].MidTexture = 0;
      secline->special = 0;
      secline->flags &= ~ML_BLOCKING;
    }
  }
  return true;
}


//**************************************************************************
//
//  Teleportation
//
//**************************************************************************

//==========================================================================
//
//  EV_Teleport
//
//==========================================================================
/*final*/ bool EV_Teleport (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5,
                            EntityEx thing, line_t *Line, bool fog,
                            optional bool keepMomentum, optional int Special)
{
  //int i;
  //int count;
  EntityEx A;
  int SecTag;
  sector_t *sec;
  bool SrcFog;
  bool KeepOrient;
  bool KeepVelocity;
  TVec DstOrg;
  float Angle;
  TVec OldVel;

  if (!thing) return false; // teleport function called with an invalid mobj
  if (thing.bNoTeleport) return false;

  //if (Special == LNSPEC_TeleportNoStop) print("154: thing=%C", thing);

  A = none;
  if (fog || Special == LNSPEC_TeleportNoStop) {
    SecTag = Arg2;
    SrcFog = !Arg3;
    KeepOrient = false;
  } else {
    SecTag = Arg3;
    SrcFog = false;
    KeepOrient = !Arg2;
  }

  if (Special == LNSPEC_TeleportNoStop) {
    KeepOrient = false;
    KeepVelocity = true;
    fog = true;
  }

  if (Arg1) {
    int count = 0;
    for (A = EntityEx(FindMobjFromTID(Arg1, none)); A; A = EntityEx(FindMobjFromTID(Arg1, A))) {
      if (SecTag == 0 || IsSectorTagEqual(A.Sector, SecTag)) ++count;
    }
    if (count == 0) return false;
    count = 1+(P_Random()%count);
    A = none;
    foreach (int i; 0..count) {
      do { A = EntityEx(FindMobjFromTID(Arg1, A)); } while (A && SecTag != 0 && !IsSectorTagEqual(A.Sector, SecTag));
    }
  } else if (SecTag) {
    for (int hidx = XLevel.FindSectorFromTag(out sec, SecTag); hidx >= 0;
         hidx = XLevel.FindSectorFromTag(out sec, SecTag, hidx))
    {
      foreach AllThinkers(EntityEx, A) {
        if (!TeleportDest(A)) continue; // not a teleportman
        if (A.Sector != sec) continue; // wrong sector
        break;
      }
      if (A) break;
    }
  }
  if (!A) return false;

  DstOrg = A.Origin;

  // Lee Killough's changes for silent teleporters from BOOM
  if (KeepOrient && Line) {
    // Get the angle between the exit thing and source linedef.
    // Rotate 180 degrees, so that walking perpendicularly across
    // teleporter linedef causes thing to exit in the direction
    // indicated by the exit thing.
    Angle = atan2(Line->normal.y, Line->normal.x)-A.Angles.yaw+180.0;
    // Momentum of thing crossing teleporter linedef
    OldVel = thing.Velocity;
  }

  if (KeepVelocity) OldVel = thing.Velocity;

  // k8: yeah, it seems that for `KeepVelocity` we need to force floor destination
  if (KeepVelocity || !TeleportDest2(A)) DstOrg.z = EntityEx::ONFLOORZ;

  if (thing.Teleport(DstOrg, A.Angles.yaw, fog, SrcFog, KeepOrient)) {
    if (KeepVelocity) {
      /*
      if (Special == LNSPEC_TeleportNoStop) {
        print("154: DONE: thing=%C; ovel=%s; vel=%s; avel=%s", thing, OldVel, thing.Velocity, A.Velocity);
        print("  radius=%s; height=%s; bPassMobj=%B; az=%s; tz=%s", thing.Radius, thing.Height, thing.bPassMobj, DstOrg.z, thing.Origin.z);
      }
      */
      thing.Velocity = OldVel;
      return true;
    }
    // Lee Killough's changes for silent teleporters from BOOM
    if (!fog && Line && KeepOrient) {
      // rotate thing according to difference in angles
      thing.Angles.yaw = AngleMod360(thing.Angles.yaw+Angle);
      // rotate thing's momentum to come out of exit just like it entered
      thing.Velocity.x = OldVel.x*cos(Angle)-OldVel.y*sin(Angle);
      thing.Velocity.y = OldVel.y*cos(Angle)+OldVel.x*sin(Angle);
    }
    return true;
  }

  //if (Special == LNSPEC_TeleportNoStop) print("154: CANNOT: thing=%C", thing);
  return false;
}


//==========================================================================
//
//  EV_TeleportOther
//
//  Teleport anything matching other_tid to dest_tid
//
//==========================================================================
/*final*/ bool EV_TeleportOther (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  bool Ret = false;
  if (Arg1 && Arg2) {
    foreach (EntityEx A; eachTID(Arg1, none)) {
      if (EV_Teleport(Arg2, 0, 0, 0, 0, A, nullptr, !!Arg3)) Ret = true;
    }
  }
  return Ret;
}


//==========================================================================
//
//  DoGroupForOne
//
//==========================================================================
/*final*/ int DoGroupForOne(EntityEx victim, EntityEx source, EntityEx dest, bool floorz, bool fog) {
  float an = dest.Angles.yaw-source.Angles.yaw;
  float offX = victim.Origin.x-source.Origin.x;
  float offY = victim.Origin.y-source.Origin.y;
  float offAngle = victim.Angles.yaw-source.Angles.yaw;
  float newX = offX*cos(an)-offY*sin(an);
  float newY = offX*sin(an)+offY*cos(an);

  int res = victim.Teleport(vector(dest.Origin.x+newX,
    dest.Origin.y+newY, floorz ? EntityEx::ONFLOORZ : dest.Origin.z +
    victim.Origin.z-source.Origin.z), 0.0, fog, fog, !fog);
  // P_Teleport only changes angle if fog is true
  victim.Angles.yaw = AngleMod360(dest.Angles.yaw+offAngle);

  return res;
}


//==========================================================================
//
//  EV_TeleportGroup
//
//  [RH] Teleport a group of actors centered around source_tid so
//  that they become centered around dest_tid instead.
//
//==========================================================================
/*final*/ bool EV_TeleportGroup (int group_tid, int source_tid, int dest_tid, bool moveSource, bool fog, EntityEx victim) {
  EntityEx sourceOrigin = EntityEx(FindMobjFromTID(source_tid, none));
  if (!sourceOrigin) {
    // if there is no source origin, behave like TeleportOther
    return EV_TeleportOther(group_tid, dest_tid, fog, 0, 0);
  }

  EntityEx destOrigin = none;
  do {
    destOrigin = EntityEx(FindMobjFromTID(dest_tid, destOrigin));
  } while (destOrigin && !TeleportDest(destOrigin));

  if (!destOrigin) return false;

  int didSomething = 0;
  bool floorz = !TeleportDest2(destOrigin);

  // Use the passed victim if group_tid is 0
  if (group_tid == 0 && victim) {
    didSomething = DoGroupForOne(victim, sourceOrigin, destOrigin, floorz, fog);
  } else {
    // for each actor with tid matching arg0, move it to the same
    // position relative to destOrigin as it is relative to
    // sourceOrigin before the teleport
    for (victim = EntityEx(FindMobjFromTID(group_tid, none)); victim;
         victim = EntityEx(FindMobjFromTID(group_tid, victim)))
    {
      didSomething |= DoGroupForOne(victim, sourceOrigin, destOrigin, floorz, fog);
    }
  }

  if (moveSource && didSomething) {
    didSomething |= sourceOrigin.Teleport(vector(destOrigin.Origin.x,
      destOrigin.Origin.y, floorz ? EntityEx::ONFLOORZ : destOrigin.Origin.z),
      0.0, false, false, true);
    sourceOrigin.Angles.yaw = destOrigin.Angles.yaw;
  }

  return didSomething;
}


//==========================================================================
//
//  EV_TeleportSector
//
//  [RH] Teleport a group of actors in a sector. Source_tid is used as a
//  reference point so that they end up in the same position relative to
//  dest_tid. Group_tid can be used to not teleport all actors in the sector.
//
//==========================================================================
/*final*/ bool EV_TeleportSector (int tag, int source_tid, int dest_tid, bool fog, int group_tid) {
  EntityEx sourceOrigin = EntityEx(FindMobjFromTID(source_tid, none));
  if (!sourceOrigin) return false;

  EntityEx destOrigin = none;
  do {
    destOrigin = EntityEx(FindMobjFromTID(dest_tid, destOrigin));
  } while (destOrigin && !TeleportDest(destOrigin));

  if (!destOrigin) return false;

  int didSomething = 0;
  bool floorz = !TeleportDest2(destOrigin);

  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, tag); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, tag, hidx))
  {
    msecnode_t *Node = sec->TouchingThingList;
    while (Node) {
      EntityEx A = EntityEx(Node->Thing);
      msecnode_t *ndNext = Node->SNext;
      // possibly limit actors by group
      if (A.Sector == sec && (group_tid == 0 || A.TID == group_tid)) {
        didSomething |= DoGroupForOne(A, sourceOrigin, destOrigin, floorz, fog);
      }
      Node = ndNext;
    }
  }

  return !!didSomething;
}


//==========================================================================
//
//  EV_SilentLineTeleport
//
//  Silent linedef-based TELEPORTATION, by Lee Killough
//  Primarily for rooms-over-rooms etc.
//  This is the complete player-preserving kind of teleporter.
//  It has advantages over the teleporter with thing exits.
//
//  [RH] Modified to support different source and destination ids.
//
//==========================================================================
/*final*/ bool EV_SilentLineTeleport (line_t *line, int side, EntityEx thing,
                                      int id, bool reverse)
{
  int searcher;
  line_t *l;

  if (side || thing.bNoTeleport || !line) return false;

  searcher = -1;
  for (l = XLevel.FindLine(id, &searcher); l; l = XLevel.FindLine(id, &searcher)) {
    if (l == line || !l->backsector) continue;

    // get the thing's position along the source linedef
    TVec SrcXAxis = line.ndir; //Normalise(line.dir);
    TVec SrcYAxis = -line->normal;
    float pos = DotProduct(SrcXAxis, thing.Origin-(*line->v1));
    float oldZ = thing.Origin.z;

    float slen = line.dir.length2DSquared;
    float dlen = l.dir.length2DSquared;
    if (dlen < 0.01f || slen < 0.01f) {
      pos = 0;
    } else {
      // rescale position according to the length of the new line
      slen = sqrt(slen);
      dlen = sqrt(dlen);
      pos = pos*dlen/slen;
    }

    // interpolate position across the exit linedef
    TVec DstXAxis;
    TVec DstYAxis;
    TVec newPos;
    if (reverse) {
      DstXAxis = l.dir;
      DstYAxis = -l->normal;
      newPos = *l->v1;
    } else {
      DstXAxis = (*l->v1)-(*l->v2);
      DstYAxis = l->normal;
      newPos = *l->v2;
    }
    DstXAxis = Normalise2D(DstXAxis);
    newPos += pos*DstXAxis;

    //FIXME: use proper floor/ceiling tracing here, not point checks

    // height of thing above ground
    float tfh = thing.Origin.z-thing.FloorZ;
    // adjust z position to be same height above ground as before
    // ground level at the exit is measured as the higher of the two floor heights at the exit linedef
    float newgh = fmax(XLevel.GetSectorFloorPointZ(l->frontsector, newPos), XLevel.GetSectorFloorPointZ(l->backsector, newPos));
    newPos.z = tfh+newgh;

    // attempt to teleport, aborting if blocked
    if (!thing.TeleportMove(newPos/*, ForceProperFloorCheck:true*/)) return false;
    if (thing.Origin.z < thing.FloorZ) thing.Origin.z = thing.FloorZ; //k8: just in case

    // rotate thing's orientation according to difference in linedef angles
    TVec TempV = vector(DotProduct(DstXAxis, SrcXAxis), DotProduct(DstYAxis, SrcXAxis));
    TAVec TempA;
    VectorAngles(TempV, out TempA);
    thing.Angles.yaw = AngleMod360(thing.Angles.yaw-TempA.yaw);

    // rotate thing's momentum to come out of exit just like it entered
    float TempX = DotProduct(thing.Velocity, SrcXAxis);
    float TempY = DotProduct(thing.Velocity, SrcYAxis);
    thing.Velocity.x = TempX*DstXAxis.x+TempY*DstYAxis.x;
    thing.Velocity.y = TempX*DstXAxis.y+TempY*DstYAxis.y;

    // adjust a player's view, in case there has been a height change
    if (thing.bIsPlayer && thing.Player.MO == thing) {
      thing.Player.ViewOrg.z += thing.Origin.z-oldZ;
      //auto pex = PlayerEx(thing.Player);
      //if (pex) pex.lastViewOrgZForPfx = thing.Origin.z;

      thing.Player.bFixAngle = true;
    }
    return true;
  }

  return false;
}


//**************************************************************************
//
//  Noise alert
//
//**************************************************************************

private transient array!Entity recSoundSectorEntities; // will be collected in native code


/*final*/ void RecursiveSound (sector_t *sec, Entity soundtarget, bool Splash, optional float maxdist, optional Entity emitter) {
  // wake up all monsters in this sector
  if (!sec) return; // just in case

  //recSoundSectorEntities.reset(); // will be cleared by `doRecursiveSound()`
  XLevel.doRecursiveSound(ref recSoundSectorEntities, sec, soundtarget, maxdist, (emitter ? emitter.Origin : vector(0, 0, 0)));

  // process entities
  //print("entities for sound processing: %d", recSoundSectorEntities.length);
  // `Ent != soundtarget` already checked, and maxdist too
  EntityEx stt = EntityEx(soundtarget);
  if (Splash) {
    foreach (Entity Ent; recSoundSectorEntities) {
      EntityEx e = EntityEx(Ent);
      if (e && !e.bNoSplashAlert) e.LastHeard = stt;
    }
  } else {
    // slightly faster
    foreach (Entity Ent; recSoundSectorEntities) {
      EntityEx e = EntityEx(Ent);
      e.LastHeard = stt;
    }
  }
  /*
  foreach (Entity Ent; recSoundSectorEntities) {
    if (Ent != soundtarget && (!Splash || !EntityEx(Ent).bNoSplashAlert)) {
      EntityEx(Ent).LastHeard = EntityEx(soundtarget);
    }
  }
  */

  // reset 'em, to help GC a little
  recSoundSectorEntities.reset();
}


//==========================================================================
//
//  NoiseAlert
//
//  If a monster yells at a player, it will alert other monsters to the
//  player.
//
//==========================================================================
/*final*/ void NoiseAlert (Entity target, Entity emitter, optional bool Splash,
                           optional float maxdist,
                           optional bool targetEmitter,
                           optional bool targetNonPlayer,
                           optional bool emitFromTarget)
{
  //if (!emitter) return;

  //print("NoiseAlert: target=%C; emitter=%C", target, emitter);

  Entity tgt = (targetEmitter ? emitter : target);
  Entity emt = (emitFromTarget ? target : emitter);
  if (!emt) return;

  if (tgt && tgt.bIsPlayer && PlayerEx(tgt.Player).bNoTarget) return;

  //if (!specified_Splash) Splash = false; // `false` is default
  RecursiveSound(emt.Sector, tgt, Splash, maxdist!optional, emt);
}


//==========================================================================
//
//  EV_NoiseAlert
//
//==========================================================================
/*final*/ bool EV_NoiseAlert (EntityEx A, int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  EntityEx ASource;
  EntityEx ATarget;

  if (!Arg1) {
    ASource = A;
  } else {
    ASource = EntityEx(FindMobjFromTID(Arg1, none));
  }

  if (!Arg2) {
    ATarget = A;
  } else {
    ATarget = EntityEx(FindMobjFromTID(Arg2, none));
  }

  NoiseAlert(ASource, ATarget);
  return true;
}


//==========================================================================
//
// EV_LineSearchForPuzzleItem
//
//==========================================================================
/*final*/ bool EV_LineSearchForPuzzleItem (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, EntityEx A) {
  Inventory Item;

  if (!A) return false;
  if (!A.bIsPlayer) return false;

  // search player's inventory for puzzle items
  for (Item = A.Inventory; Item; Item = Item.Inventory) {
    PuzzleItem pp = PuzzleItem(Item);
    if (!pp) continue;
    if (pp.PuzzleItemNumber == Arg1) {
      // a puzzle item was found for the line
      if (A.UseInventory(Item)) return true;
    }
  }

  return false;
}


//**************************************************************************
//
//  Point pushers and pullers
//
//**************************************************************************

//==========================================================================
//
//  GetPushThing
//
//  Returns a pointer to an MT_PUSH or MT_PULL thing, nullptr otherwise.
//
//==========================================================================
/*final*/ EntityEx GetPushThing (int s) {
  if (s < 0 || s >= XLevel.Sectors.length) return none;
  for (Entity thing = XLevel.Sectors[s].ThingList; thing; thing = thing.SNext) {
    if (PointPusher(thing) || PointPuller(thing)) {
      return EntityEx(thing);
    }
  }
  return none;
}


//==========================================================================
//
//  SpawnPushers
//
//  Initialise the sectors where pushers are present
//
//==========================================================================
/*final*/ void SpawnPushers () {
  sector_t *sec;

  foreach (int i; 0..XLevel.Lines.length) {
    line_t *l = &XLevel.Lines[i];
    switch (l->special) {
      case LNSPEC_SectorSetWind: // wind
        for (int hidx = XLevel.FindSectorFromTag(out sec, l->arg1); hidx >= 0;
             hidx = XLevel.FindSectorFromTag(out sec, l->arg1, hidx))
        {
          Pusher P = SpawnThinker(Pusher);
          if (P && !P.IsDestroyed) {
            P.Init(Pusher::PUSHER_Wind, l->arg4 ? l : nullptr, l->arg2, l->arg3, none, sec-&XLevel.Sectors[0]);
          }
        }
        break;

      case LNSPEC_SectorSetCurrent: // current
        for (int hidx = XLevel.FindSectorFromTag(out sec, l->arg1); hidx >= 0;
             hidx = XLevel.FindSectorFromTag(out sec, l->arg1, hidx))
        {
          Pusher P = SpawnThinker(Pusher);
          if (P && !P.IsDestroyed) {
            P.Init(Pusher::PUSHER_Current, l->arg4 ? l : nullptr, l->arg2, l->arg3, none, sec-&XLevel.Sectors[0]);
          }
        }
        break;

      case LNSPEC_PointPushSetForce: // push/pull
        if (l->arg1) {
          // [RH] find thing by sector
          for (int hidx = XLevel.FindSectorFromTag(out sec, l->arg1); hidx >= 0;
               hidx = XLevel.FindSectorFromTag(out sec, l->arg1, hidx))
          {
            int ssnum = sec-&XLevel.Sectors[0];
            EntityEx thing = GetPushThing(ssnum);
            if (thing) {
              // No MT_P* means no effect
              // [RH] Allow narrowing it down by tid
              if (!l->arg2 || l->arg2 == thing.TID) {
                Pusher P = SpawnThinker(Pusher);
                if (P && !P.IsDestroyed) {
                  P.Init(Pusher::PUSHER_Push, l->arg4 ? l : nullptr, l->arg3, 0, thing, ssnum);
                }
              }
            }
          }
        } else {
          // [RH] Find thing by tid
          foreach (EntityEx thing; eachTID(l->arg2)) {
            if (PointPuller(thing) || PointPusher(thing)) {
              /*
              int s;
              for (s = 0; s < XLevel.Sectors.length; ++s) if (&XLevel.Sectors[s] == thing.Sector) break;
              */
              if (!thing.Sector) continue;
              int s = thing.Sector-&XLevel.Sectors[0];
              Pusher P = SpawnThinker(Pusher);
              if (P && !P.IsDestroyed) {
                P.Init(Pusher::PUSHER_Push, l->arg4 ? l : nullptr, l->arg3, 0, thing, s);
              }
            }
          }
        }
        break;
    }
  }
}


//==========================================================================
//
//  AdjustPusher
//
//==========================================================================
/*final*/ bool AdjustPusher (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, line_t *Line, int Type) {
  if (Line || Arg4) return false;

  int tag = Arg1;
  int magnitude = Arg2;
  int angle = Arg3;
  Pusher Collection = none;

  // find pushers already attached to the sector, and change their parameters
  Pusher P;
  foreach AllThinkers(Pusher, P) {
    if (P.CheckForSectorMatch(Type, tag) >= 0) {
      P.ChangeValues(magnitude, angle);
      P.AdjustLink = Collection;
      Collection = P;
    }
  }

  // now create pushers for any sectors that don't already have them
  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, tag); hidx >= 0;
       hidx = XLevel.FindSectorFromTag(out sec, tag, hidx))
  {
    int secnum = sec-&XLevel.Sectors[0];
    for (P = Collection; P; P = P.AdjustLink) {
      if (P.Affectee == secnum) break;
    }
    if (!P) {
      P = SpawnThinker(Pusher);
      P.Init(Type, nullptr, magnitude, angle, none, secnum);
    }
  }

  return true;
}


//==========================================================================
//
//  EV_LineTranslucent
//
//==========================================================================
/*final*/ bool EV_LineTranslucent (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  bool res = false;
  int Searcher = -1;
  for (line_t *Other = XLevel.FindLine(Arg1, &Searcher); Other; Other = XLevel.FindLine(Arg1, &Searcher)) {
    Other->alpha = float(Arg2)/255.0;
         if (Arg3 == 0) Other->flags &= ~ML_ADDITIVE;
    else if (Arg3 == 1) Other->flags |= ML_ADDITIVE;
    else printerror("Invalid line translucency type %d", Arg3);
    res = true;
  }
  return res;
}


//==========================================================================
//
//  EV_SectorSetPlaneReflection
//
//==========================================================================
int EV_SectorSetPlaneReflection (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5) {
  int res = 0;
  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Arg1); hidx >= 0; hidx = XLevel.FindSectorFromTag(out sec, Arg1, hidx)) {
    sec.floor.MirrorAlpha = float(255-Arg2)/255.0;
    sec.ceiling.MirrorAlpha = float(255-Arg3)/255.0;
    res = 1;
  }
  return res;
}


//=========================================================================
//
//  EV_SectorSetGlow
//
//=========================================================================
/*final*/ bool EV_SectorSetGlow (bool forCeiling, int tag, int height, int r, int g, int b) {
  //printdebug("EV_SectorSetGlow: forCeiling=%B; tag=%s; height=%s; r=%s; g=%s; b=%s", forCeiling, tag, height, r, g, b);
  bool res = false;
  bool setIt = (r >= 0 && height > 0);
  int clr = (setIt ? 0xff_00_00_00|(clamp(r, 0, 255)<<16)|(clamp(g, 0, 255)<<8)|clamp(b, 0, 255) : 0);
  sector_t *sector;
  for (int hidx = XLevel.FindSectorFromTag(out sector, tag); hidx >= 0; hidx = XLevel.FindSectorFromTag(out sector, tag, hidx)) {
    res = true;
    if (setIt) {
      // set glow
      if (forCeiling) {
        sector.params.bCeilingGlow = true;
        sector.params.glowCeiling = clr;
        sector.params.glowCeilingHeight = height;
      } else {
        sector.params.bFloorGlow = true;
        sector.params.glowFloor = clr;
        sector.params.glowFloorHeight = height;
      }
    } else {
      // reset glow
      if (forCeiling) {
        sector.params.bCeilingGlow = false;
        sector.params.glowCeiling = 0;
        sector.params.glowCeilingHeight = 0;
      } else {
        sector.params.bFloorGlow = false;
        sector.params.glowFloor = 0;
        sector.params.glowFloorHeight = 0;
      }
    }
  }
  return res;
}


//==========================================================================
//
//  EV_GlassBreak
//
//==========================================================================
/*final*/ bool EV_GlassBreak (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, line_t *Line, EntityEx A) {
  int Quest1, Quest2;

  if (!Line) return false;
  if (Line->flags&ML_TWOSIDED) Line->flags &= ~(ML_BLOCKING|ML_BLOCKEVERYTHING);

  bool switched = ChangeSwitchTexture(Line->sidenum[0], false, 'switches/normbutn', Quest1);
  Line->special = 0;

  if (Line->sidenum[1] != -1) {
    if (ChangeSwitchTexture(Line->sidenum[1], false, 'switches/normbutn', Quest2)) switched = true;
  } else {
    Quest2 = Quest1;
  }

  if (switched) {
    if (!Arg1) {
      // break some glass
      float x = Line->v1->x+(Line->v2->x-Line->v1->x)/2.0;
      float y = Line->v1->y+(Line->v2->y-Line->v1->y)/2.0;
      x += (Line->frontsector->soundorg.x-x)/5.0;
      y += (Line->frontsector->soundorg.y-y)/5.0;

      foreach (; 0..7) {
        EntityEx glass = Spawn(GlassJunk, vector(x, y, EntityEx::ONFLOORZ));
        if (!glass || glass.IsDestroyed) continue;
        glass.Origin.z += 24.0;
        glass.SetState(GetStatePlus(glass.IdleState, P_Random()%glass.Health, IgnoreJump:true));
        if (glass.IsDestroyed) continue;
        float an = Random()*360.0;
        glass.Angles.yaw = an;
        float speed = Random()*4.0*35.0;
        glass.Velocity.x = cos(an)*speed;
        glass.Velocity.y = sin(an)*speed;
        glass.Velocity.z = Random()*8.0*35.0;
      }
    }

    if (Quest1 || Quest2) {
      // up stats and signal this mission is complete
      if (!A) {
        foreach (int i; 0..MAXPLAYERS) {
          if (Game.Players[i] && Game.Players[i].bSpawned) {
            A = EntityEx(Game.Players[i].MO);
            break;
          }
        }
      }

      if (A && A.bIsPlayer) {
        A.GiveInventoryType(QuestItem29);
        A.GiveInventoryType(class!Inventory(FindClass('UpgradeAccuracy')));
        A.GiveInventoryType(class!Inventory(FindClass('UpgradeStamina')));
      }
    }
  }

  // we already changed the switch texture, so don't make the main code switch it back
  return false;
}


//==========================================================================
//
//  EV_SendToCommunicator
//
//==========================================================================
/*final*/ bool EV_SendToCommunicator (EntityEx A, int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, int Side) {
  if (Arg2 && Side) return false;

  if (A && A.bIsPlayer && A.FindInventory(Communicator)) {
    if (!Arg4) PlayerEx(A.Player).SetObjectives(Arg1);

    PlayerEx(A.Player).ClientVoice(Arg1);

         if (Arg3 == 0) A.Player.cprint("Incoming Message");
    else if (Arg3 == 1) A.Player.cprint("Incoming Message from BlackBird");

    return true;
  }

  return false;
}


//==========================================================================
//
//  EV_StartConversation
//
//==========================================================================
/*final*/ bool EV_StartConversation (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, EntityEx A) {
  if (!A || !A.bIsPlayer) return false;
  foreach (EntityEx Ent; eachTID(Arg1)) {
    if (StartConversation(A, Ent)) {
      if (Arg2) {
        A.Angles.yaw = atan2(Ent.Origin.y-A.Origin.y, Ent.Origin.x-A.Origin.x);
        A.Player.bFixAngle = true;
      }
      return true;
    }
  }
  return false;
}


//===========================================================================
//
//  implLocalQuake
//
//===========================================================================
/*final*/ int implLocalQuake (int intensity, int duration, float damrad, float tremrad, int tid, Entity Activator, optional name sound) {
  QuakeFocus focus;
  int count = 0;

  //print("A_LocalQuake: intensity=%s; dur=%s; dmgradius=%s; tremorradius=%s; tid=%s", intensity, duration, damrad, tremrad, tid);

  if (tid == 0 && Activator) {
    // activator
    //print(" (a)spawning quaker for '%C'", Activator);
    focus = SpawnEntityChecked(class!QuakeFocus, QuakeFocus, Activator.Origin);
    if (focus) {
      //print("  (a)spawned quaker for '%C'", Activator);
      focus.Richters = intensity;
      focus.QuakeDuration = duration>>1;  // decremented every 2 tics
      focus.DamageRadius = damrad;
      focus.TremorRadius = tremrad;
      if (sound) focus.SoundName = sound;
      ++count;
    }
  }

  // find all quake foci
  foreach (EntityEx target; eachTID(tid)) {
    //print(" spawning quaker for '%C'", target);
    focus = SpawnEntityChecked(class!QuakeFocus, QuakeFocus, target.Origin);
    if (focus) {
      //print("  spawned quaker for '%C'", target);
      focus.Richters = intensity;
      focus.QuakeDuration = duration>>1;  // decremented every 2 tics
      focus.DamageRadius = damrad;
      focus.TremorRadius = tremrad;
      if (sound) focus.SoundName = sound;
      ++count;
    }
  }

  return count;
}



//===========================================================================
// Quake variables
//
//      Arg1     Intensity on richter scale (2..9)
//      Arg2     Duration in tics
//      Arg3     Radius for damage, in tile units (64 pixels)
//      Arg4     Radius for tremor in tile units (64 pixels)
//      Arg5     TID of map thing for focus of quake
//
//===========================================================================

//===========================================================================
//
//  A_LocalQuake
//
//===========================================================================
[decorate] final bool A_LocalQuake (int Arg1, int Arg2, int Arg3, int Arg4, int Arg5, Entity Activator) {
  return implLocalQuake(Arg1, Arg2, float(Arg3)*64.0, float(Arg4)*64.0, Arg5, Activator);
}


//==========================================================================
//
//  AcsRadiusQuake2
//
//==========================================================================
override void AcsRadiusQuake2 (Entity Activator, int tid, int intensity, int duration, int damrad, int tremrad, name sound) {
  implLocalQuake(intensity, duration, damrad, tremrad, tid, Activator, sound);
}


//==========================================================================
//
//  AcsWarp
//
//==========================================================================
override void AcsWarp (Entity Activator, int tid, float xofs, float yofs, float zofs, float angle, int flags,
                       name succState, bool exact, float heightoffset, float radiusoffset, float pitch)
{
  Actor act = Actor(Activator);
  if (!act) {
    if (Activator) {
      printwarn("ACS: Warp without activator! (%C)");
      for (class c = Activator.Class; c; c = GetClassParent(c)) print("  %C", c);
    } else {
      printwarn("ACS: Warp without activator!");
    }
    return;
  }
  //printdebug("ACS: warping %C", act);
  flags |= Actor::WARPF_USETID;
  act.A_Warp(tid, xofs, yofs, zofs, angle, flags, (succState ? act.FindState(succState) : none), heightoffset, radiusoffset, pitch);
}


//==========================================================================
//
//  ForceLightning
//
//==========================================================================
/*final*/ void ForceLightning (int Mode) {
  LightningThinker Lightning = none;
  Thinker Th;
  foreach AllThinkers(LightningThinker, Th) {
    Lightning = LightningThinker(Th);
    break;
  }
  if (!Lightning) {
    Lightning = SpawnThinker(LightningThinker);
    if (!Lightning || Lightning.IsDestroyed) return;
    Lightning.Init();
  }
  Lightning.ForceLightning(Mode);
}


//==========================================================================
//
//  ModToDamageType
//
//==========================================================================
/*final*/ name ModToDamageType (int Mod) {
  switch (Mod) {
    case 9: return 'BFGSplash';
    case 12: return 'Drowning';
    case 13: return 'Slime';
    case 14: return 'Fire';
    case 15: return 'Crush';
    case 16: return 'Telefrag';
    case 17: return 'Falling';
    case 18: return 'Suicide';
    case 20: return 'Exit';
    case 22: return 'Melee';
    case 23: return 'Railgun';
    case 24: return 'Ice';
    case 25: return 'Disintegrate';
    case 26: return 'Poison';
    case 27: return 'Electric';
    case 1000: return 'Massacre';
    default: return '';
  }
}


//==========================================================================
//
//  PolyRotateMobj
//
//==========================================================================
override void PolyRotateMobj (Entity A, float dangle) {
  if (!dangle) return;
  EntityEx ex = EntityEx(A);
  if (!ex) return;
  float oldyaw = AngleMod360(ex.Angles.yaw);
  ex.Angles.yaw = AngleMod360(ex.Angles.yaw+dangle);
  if (ex.bIsPlayer && ex.Player.MO == self) ex.Player.bFixAngle = true;
  ex.LastMoveAngles.yaw += ex.Angles.yaw-oldyaw;
}


/*
  // damage it
  if (killit) {
    if (ex.bMonster || ex.bMissile || ex.bIsPlayer) {
      ex.bInvulnerable = false;
      ex.Damage(none, none, 10000, 'Crush', NoArmor:true, forced:true, spawnBlood:true, ignoreDamageFactors:true, ignorePowerups:true);
    }
  }
*/


//==========================================================================
//
//  PolyThrustMobj
//
//  returns `true` if po is blocked, `false` if mobj is killed
//
//==========================================================================
override bool PolyThrustMobj (Entity Other, TVec thrustDir, polyobj_t *po, bool vertical) {
  EntityEx ex = EntityEx(Other);
  if (!ex) return false;

  if (!ex.bShootable && !Other.bIsPlayer) return true;

  // check platform crushing
  if (po->posector && vertical && !ex.bInvulnerable && po->bCrush) {
    //ex.bInvulnerable = false;
    ex.Damage(none, none, 10000, 'Crush', NoArmor:true, forced:true, spawnBlood:true, ignoreDamageFactors:true, ignorePowerups:true);
    return false;
  }

  bool wasForce = false;
  float force = 0;
  for (PolyobjThinker pe = PolyobjThinker(po->SpecialData); pe; pe = pe.NextAction) {
    if (pe.isDestroyed) continue;
    force += fclamp(pe.thrust_force*(pe isa 'PolyobjRotator' ? 8.0 : 3.0), 1.0, 128.0);
    wasForce = true;
  }
  if (!wasForce) force = 1.0;

  #if 0
  if (Other.bSolid && (Other.bIsPlayer || Other.bMonster) && pe isa 'PolyobjRotator') {
    if (Other.IsInPolyObj(po) || !Other.CheckPosition(Other.Origin)) {
      printdebug("%C(%s): moving from %s", ex, ex.UniqueId, ex.Origin);
      Other.UnlinkFromWorld();
      foreach (; 0..16) {
        Other.Origin += thrustDir.xy*0.4;
        if (!Other.IsInPolyObj(po)) break;
      }
      bool okpos = Other.CheckPosition(Other.Origin);
      printdebug("%C(%s): moved to %s (ok=%B)", ex, ex.UniqueId, ex.Origin, okpos);
      Other.LinkToWorld();
      if (!okpos) {
        ex.bInvulnerable = false;
        ex.Damage(none, none, 10000, 'Crush', spawnBlood:true, forced:true, NoArmor:true, ignoreDamageFactors:true, ignorePowerups:true);
        return;
      }
    }
  }
  #endif

  Other.Velocity += (force*thrustDir)*2.0;
  if (po->bCrush) {
    TVec testPos = Other.Origin+force*thrustDir*Game.frametime;
    // platforms are always deadly
    if (po->posector && !ex.bInvulnerable && (po->bSideCrush || !Other.CheckPosition(testPos))) {
      ex.Damage(none, none, 10000, 'Crush', NoArmor:true, forced:true, spawnBlood:true, ignoreDamageFactors:true, ignorePowerups:true);
      return false;
    }
    if (po->bHurtOnTouch || !Other.CheckPosition(testPos)) {
      // damage other type of actors
      ex.Damage(none, none, 3, 'Crush', spawnBlood:true);
    }
  }

  return true;
}


//==========================================================================
//
//  PolyCrushMobj
//
//==========================================================================
override void PolyCrushMobj (Entity Other, polyobj_t *po) {
  EntityEx ex = EntityEx(Other);
  if (!ex || !po) return;

  if (po.bCrush) {
    // crunch ice corpses
    if (ex.bIceCorpse) {
      // crush ice corpses
      if (Actor(Other)) {
        Actor(Other).A_FreezeDeathChunks();
        return;
      }
    }

    // crunch bodies to giblets
    ex.GibEntity('PolyObjectGibs');
  }
}


//==========================================================================
//
//  PolyBusy
//
//==========================================================================
override bool PolyBusy (int polyobj) {
  polyobj_t *poly = XLevel.GetPolyobj(polyobj);
  return (poly && PolyobjThinker.IsPolyobjBusy(poly));
}


//==========================================================================
//
//  ThingCount
//
//==========================================================================
override int ThingCount (int type, name TypeName, int tid, int SectorTag) {
  class!EntityEx moType;

  if (!(type+tid) && !TypeName) return 0; // nothing to count

  if (TypeName) {
    moType = class!EntityEx(FindClassNoCase(TypeName));
    if (!moType) return 0;
  } else {
    moType = class!EntityEx(FindClassFromScriptId(type, LineSpecialGameInfo(Game).GameFilterFlag));
  }

  // count things
  int Count = DoThingCount(moType, tid, SectorTag);
  if (moType) {
    // if this class has a replacement, count number of instances of replacement class too
    class!EntityEx RepType = class!EntityEx(GetClassReplacement( moType));
    if (RepType && RepType != moType) Count += DoThingCount(RepType, tid, SectorTag);
  }

  return Count;
}


//==========================================================================
//
//  DoThingCount
//
//==========================================================================
/*final*/ int DoThingCount (class!EntityEx moType, int tid, int SectorTag) {
  int count = 0;
  if (tid) {
    // count TID things
    foreach (EntityEx Ent; eachTID(tid)) {
      if (Ent.Health <= 0) continue; // don't count dead monsters
      if (Inventory(Ent) && Ent.Owner) continue; // don't count things in somebody's inventory
      if (SectorTag != -1 && !IsSectorTagEqual(Ent.Sector, SectorTag)) continue; // wrong sector tag
      if (!moType || moType == Ent.Class) ++count;
    }
  } else if (moType) {
    // count only types
    EntityEx Ent;
    foreach AllThinkers(moType, Ent) {
      if (Ent.Class != moType) continue; // doesn't match
      if (Ent.Health <= 0) continue; // don't count dead monsters
      if (Inventory(Ent) && Ent.Owner) continue; // don't count things in somebody's inventory
      if (SectorTag != -1 && !IsSectorTagEqual(Ent.Sector, SectorTag)) continue; // wrong sector tag
      ++count;
    }
  }
  return count;
}


//==========================================================================
//
//  SectorDamage
//
//==========================================================================
override void SectorDamage (int Tag, int Amount, name DamageType, name ProtectionType, int Flags) {
  class!Inventory ProtectClass = class!Inventory(FindClassNoCase(ProtectionType));

  sector_t *sec;
  for (int hidx = XLevel.FindSectorFromTag(out sec, Tag); hidx >= 0; hidx = XLevel.FindSectorFromTag(out sec, Tag, hidx)) {
    Entity entNext;
    for (Entity Ent = sec->ThingList; Ent; Ent = entNext) {
      entNext = Ent.SNext;
      EntityEx ee = EntityEx(Ent);
      if (!ee) continue;

      if (!ee.bShootable) continue;
      if (!(Flags&DAMAGE_NONPLAYERS) && !Ent.bIsPlayer) continue;
      if (!(Flags&DAMAGE_PLAYERS) && Ent.bIsPlayer) continue;

      if (!(Flags&DAMAGE_IN_AIR) && !Ent.WaterLevel && Ent.Origin.z != GetPlanePointZ(ref sec->floor, Ent.Origin)) continue;

      if (ProtectClass) {
        if (!(Flags&DAMAGE_SUBCLASSES_PROTECT)) {
          if (ee.FindInventory(ProtectClass)) continue;
        } else {
          Inventory Item;
          for (Item = ee.Inventory; Item; Item = Item.Inventory) {
            if (Item.IsA(ProtectionType)) break;
          }
          if (Item) continue;
        }
      }

      ee.Damage(none, none, Amount, DamageType/*, spawnBlood:true*/);
    }
  }
}


//==========================================================================
//
//  SpawnMapThing
//
//  the fields in `mthing` should already be in host byte order
//
//==========================================================================
override void SpawnMapThing (mthing_t *mthing) {
  int spawnMask;
  class!EntityEx moClass, oldClass;

  if (!mthing || mthing.type <= 0) return;

  //if (mthing.tid == 54 || mthing.tid == 43) writeln("*** TREE! ***");
  //print("SPAWN MAP THING: %s; type=%s; org=(%s,%s); height=%s; opts=0x%08x; skill=0x%08x", mthing.tid, mthing.type, mthing.x, mthing.y, mthing.height, mthing.options, mthing.SkillClassFilter);

  // count deathmatch start positions
  if (mthing.type == 11) {
    DeathmatchStarts.length += 1;
    CopyMThing(mthing, &DeathmatchStarts[$-1]);
    return;
  }

  if (bCheckStrifeStartSpots && mthing.type >= 118 && mthing.type <= 127) {
    // map start spots, i.e. player starts
    mthing.args[1-1] = mthing.type-117;
    mthing.type = 1;
  }

  // check for player starts 1 to 4
  bool IsPlayerStart = false;
  if (mthing.type >= 1 && mthing.type <= 4) IsPlayerStart = true;
  // check for player starts 5 to 8
  if (mthing.type >= ExtPlayersBase && mthing.type < ExtPlayersBase+4) {
    // change type to range 5-8
    mthing.type = 5+mthing.type-ExtPlayersBase;
    IsPlayerStart = true;
  }

  if (!IsPlayerStart || bFilterStarts) {
    // check current game type with spawn flags
         if (!Game.netgame) spawnMask = MTF_GSINGLE;
    else if (Game.deathmatch) spawnMask = MTF_GDEATHMATCH;
    else spawnMask = MTF_GCOOP;

    if (!(mthing.options&spawnMask)) return;

    // check current skill with spawn flags
    if (!(mthing.SkillClassFilter&World.GetSpawnFilter())) return;

    // check current character classes with spawn flags
    // but if class mask is empty, spawn anyway
    if (mthing.SkillClassFilter&MTF2_CLASS_MASK) {
      spawnMask = GetPClassSpawnFlags();
      if (spawnMask && !(mthing.SkillClassFilter&spawnMask)) {
        // not for current class
        //moClass = class!EntityEx(FindClassFromEditorId(mthing.type, LineSpecialGameInfo(Game).GameFilterFlag));
        //printdebug("%C: thing %s skipped due to class mask: 0x%08x : 0x%08x", moClass, mthing.type, mthing.SkillClassFilter&MTF2_CLASS_MASK, spawnMask);
        return;
      }
    }
  }

  if (IsPlayerStart) {
    // save spots for respawning in network games
    PlayerStarts.length += 1;
    CopyMThing(mthing, &PlayerStarts[$-1]);
    return;
  }

  // sector's sound sequence types
  if (mthing.type >= 1400 && mthing.type < 1410) {
    XLevel.PointInSector(vector(mthing.x, mthing.y, 0.0)).seqType = mthing.type-1400;
    return;
  }

  if (mthing.type == 1411) {
    int SeqType = (mthing.args[1-1] == 255 ? -1 : mthing.args[1-1]);
    if (SeqType > 63) {
      print("Sound sequence %d out of range", SeqType);
    } else {
      XLevel.PointInSector(vector(mthing.x, mthing.y, 0.0)).seqType = SeqType;
    }
    return;
  }

  // zdoom music changers
  if (mthing.type >= 14101 && mthing.type <= 14165) {
    SpawnThinker(SecMusicChangerBase, default, default, mthing, AllowReplace:false);
    return;
  }

  // remap old ambient sound types to the generic one
  if (mthing.type >= 14001 && mthing.type <= 14064) {
    mthing.args[1-1] = mthing.type-14000;
    mthing.type = 14065;
  }

  // find which type to spawn
  moClass = class!EntityEx(FindClassFromEditorId(mthing.type, LineSpecialGameInfo(Game).GameFilterFlag));
  if (!moClass) {
    // can't find thing type
    if (mthing.type == 9200) {
      // decal
      auto dcs = Spawn(Unknown, default, default, mthing, AllowReplace:false);
      dcs.bSolid = false;
      TAVec agl;
      agl.yaw = AngleMod360(mthing.angle+180); // turn it to the wall
      TVec dir;
      AngleVector(agl, dir);
      //print("  dir0=%v (a=%f)", dir, agl.yaw);
      dir = Normalise(dir);
      //print("  dir1=%v", dir);
      EntityEx::trsplat_t tr;
      // trace without z offset
      if (dcs.TraceSplat(dcs.Origin-dir, dir, 64.0+4, &tr, 0)) {
        //print("  spawning!");
        dcs.SpawnDecalById(tr.hit, mthing.args[1-1]+mthing.args[2-1]*256, tr.side, tr.line);
      } else {
        print("(INFO): cannot spawn decal at (%f,%f); angle=%d; id=%d", mthing.x, mthing.y, mthing.angle, mthing.args[1-1]+mthing.args[2-1]*256);
      }
      dcs.Destroy();
      return;
    }
    print("SpawnMapThing: Unknown type %d at (%f, %f)", mthing.type, mthing.x, mthing.y);
    moClass = Unknown;
  } else {
    oldClass = moClass;
    moClass = class!EntityEx(GetClassReplacement(moClass));
    if (!moClass) moClass = oldClass;
    // check skill replacements
    foreach (ref const auto repl; /*skd.Replacements*/World.SkillReplacements) {
      if (repl.oldClass == oldClass) {
        //printdebug("*** skill (%d) replacement: normal `%C` replaced with `%C`", World.GameSkill, oldClass, repl.newClass);
        moClass = repl.newClass;
        break;
      }
      if (repl.oldClass == moClass) {
        //printdebug("*** skill (%d) replacement: replaced `%C` (%C) replaced with `%C`", World.GameSkill, oldClass, moClass, repl.newClass);
        moClass = repl.newClass;
        break;
      }
    }
    if (!moClass) return; // nothing to do
    //print("SpawnMapThing: type=%d; oldClass='%C'; newClass='%C'; solid=%B", mthing.type, oldClass, moClass, moClass.default.bSolid);

    // if actor has no sprites, also map it to the unknown thing
    if (FindClassState(moClass, 'Spawn') && !AreStateSpritesPresent(FindClassState(moClass, 'Spawn'))) {
      print("SpawnMapThing: %C of type %d at (%f, %f), has no frames", moClass, mthing.type, mthing.x, mthing.y);
      moClass = Unknown;
    }
  }

  if (Level.Game.nomonsters && moClass.default.bMonster) {
    //print("  monster skipped (%C)", moClass);
    return;
  }

  // spawn it
  EntityEx thg = EntityEx(SpawnThinker(moClass, default, default, mthing, AllowReplace:false));
  if (thg && !thg.IsDestroyed && thg.bFixMapthingPos) thg.FixMapthingPos();
  //print("SpawnMapThing: '%C' (%d) height=%f (defheight=%f); org=%s", thg, mthing.type, thg.Height, moClass.default.Height, thg.Origin);
  //if (moClass.default.bSolid && !thg.bSolid) print("  ****FUUUUUUU");

  //if (mthing.type == 9001 && mthing.tid == 55) print("SPAWN MAP THING: %s; type=%s; org=(%s,%s); height=%s; opts=0x%08x; skill=0x%08x; thorg=%s", mthing.tid, mthing.type, mthing.x, mthing.y, mthing.height, mthing.options, mthing.SkillClassFilter, thg.Origin);
}


//==========================================================================
//
//  CheckLock
//
//==========================================================================
/*final*/ bool CheckLock (Entity user, int lockidx, bool door) {
  if (!user) return false;
  if (!user.bIsPlayer) return false;
  if (!lockidx) return true;
  LockDef *Lock = GetLockDef(lockidx);
  if (!Lock) {
    if (lockidx == 103) {
      user.Player.centerprint("%s", Lock103Message);
    } else {
      user.Player.centerprint("That doesn't seem to work");
    }
    user.PlaySound('misc/keytry', CHAN_VOICE);
    return false;
  }
  if (CheckLockDef(Lock, EntityEx(user))) return true;
  user.Player.centerprint("%s", (door ? Lock->Message : Lock->RemoteMessage));
  user.PlaySound(Lock->LockedSound, CHAN_VOICE);
  return false;
}


//==========================================================================
//
//  CheckLockDef
//
//==========================================================================
/*final*/ bool CheckLockDef (LockDef *Lock, EntityEx User) {
  if (!Lock) return false; // just in case
  // empty lock list means check for any key
  if (!Lock->Locks.length) {
    for (Inventory Item = User.Inventory; Item; Item = Item.Inventory) {
      if (Key(Item)) return true;
    }
    return false;
  } else {
    foreach (auto ref lockinfo; Lock->Locks) {
      bool good = false;
      foreach (class keyclass; lockinfo.AnyKeyList) {
        //printdebug("%C: looking for key `%C`", User, keyclass);
        if (User.FindInventoryKey(class!Inventory(keyclass))) {
          good = true;
          break;
        }
      }
      if (!good) return false;
    }
    return true;
  }
}


//**************************************************************************
//
//  CONVERSATION STUFF
//
//**************************************************************************

//==========================================================================
//
//  StartConversation
//
//==========================================================================
bool StartConversation (EntityEx User, EntityEx UseOn) {
  if (Game.netgame) return false;
  if (!User || !User.bIsPlayer || User.Health <= 0) return false;
  if (!UseOn || UseOn.Health <= 0) return false;
  if (UseOn.bInCombat) return false; // this dude is too busy to talk right now
  if (!UseOn.ConversationID) return false;

  int SpeechNum = UseOn.GetSpeech();
  if (SpeechNum) {
    CurrentSpeaker = UseOn;
    CurrentSpeakingTo = User;
    OldSpeakerAngle = UseOn.Angles.yaw;
    UseOn.Angles.yaw = atan2(User.Origin.y-UseOn.Origin.y, User.Origin.x-UseOn.Origin.x);
    User.PlaySound('misc/chat', CHAN_VOICE);
    StartSpeech(SpeechNum);
  }

  return true;
}


//==========================================================================
//
//  StartSpeech
//
//==========================================================================
/*final*/ void StartSpeech (int SpeechNum) {
  FRogueConSpeech *Speech;
  bool conJumped;

  do {
    conJumped = false;

    if (!SpeechNum) {
      StopSpeech();
      return;
    }

    if (SpeechNum < 0) {
      Speech = &XLevel.GenericSpeeches[-SpeechNum-1];
    } else {
      Speech = &XLevel.LevelSpeeches[SpeechNum-1];
    }

    if (Speech->JumpToConv &&
        CheckForNeededItem(CurrentSpeakingTo, Speech->CheckItem1, 1) != -2 &&
        CheckForNeededItem(CurrentSpeakingTo, Speech->CheckItem2, 1) != -2 &&
        CheckForNeededItem(CurrentSpeakingTo, Speech->CheckItem3, 1) != -2)
    {
      CurrentSpeaker.CurrentSpeech = Speech->JumpToConv;
      SpeechNum = CurrentSpeaker.GetSpeech();
      conJumped = true;
    }
  } while (conJumped);
  CurrentSpeechIndex = SpeechNum;

  PlayerEx(CurrentSpeakingTo.Player).ClientSpeech(CurrentSpeaker, SpeechNum);
}


//==========================================================================
//
//  GetClassFromID
//
//==========================================================================
final class!EntityEx GetClassFromID (int ID) {
  if (ID) {
    class Cls;
    foreach AllClasses(EntityEx, Cls) {
      if (class!EntityEx(Cls).default.ConversationID == ID) return class!EntityEx(Cls);
    }
    printerror("Unknown item %d", ID);
  }
  return none;
}


//==========================================================================
//
//  CheckForNeededItem
//
//==========================================================================
/*final*/ int CheckForNeededItem (EntityEx A, int ID, int Amount) {
  if (!ID) return -1;
  // Strife hack: item ID 168 (Coin) with amount 0 is always present
  if (ID == 168 && Amount == 0) {
    dprint("CheckForNeededItem: want 0 coins, success");
    return 0;
  }
  // get class ID
  class!EntityEx CID = GetClassFromID(ID);
  dprint("CheckForNeededItem: A=%C; CID=%C (%s); Amount=%d", A, CID, ID, Amount);
  // check inventory items
  if (class!Inventory(CID) && class!Inventory(CID).default.bInvBar) {
    Inventory Item = A.FindInventory(class!Inventory(CID));
    dprint ("  checked in inventory for %C; found %C (amount=%d); res=%d", CID, Item, (Item ? Item.Amount : -666), (!Item || Item.Amount < Amount ? -2 : 0));
    return (!Item || Item.Amount < Amount ? -2 : 0);
  }
  // check keys
  Inventory Item = A.FindInventory(class!Inventory(CID));
  if (Item) {
    dprint ("  checked in inventory for KEY %C; found %C (amount=%d)", CID, Item, (Item ? Item.Amount : -666));
    return -1;
  }
  return -2;
}


//==========================================================================
//
//  StopSpeech
//
//==========================================================================
/*final*/ void StopSpeech () {
  CurrentSpeaker.Angles.yaw = OldSpeakerAngle;
  CurrentSpeaker = none;
  CurrentSpeakingTo = none;
  CurrentSpeechIndex = 0;
}


//==========================================================================
//
//  ConChoiceImpulse
//
//==========================================================================
/*final*/ void ConChoiceImpulse (int ChoiceNum) {
  FRogueConSpeech *Speech;
  FRogueConChoice *Choice;
  //int SpeechNum;
  int Item1;
  int Item2;
  int Item3;
  class!EntityEx ItemType;
  Inventory Item;
  bool GaveItem;

  if (ConversationSlideshow) {
    // resume conversation after slideshow
    StartSpeech(CurrentSpeaker.GetSpeech());
    ConversationSlideshow = false;
    return;
  }

  if (!CurrentSpeaker || !CurrentSpeechIndex) return;

  if (!ChoiceNum) {
    StopSpeech();
    return;
  }

  if (CurrentSpeechIndex < 0) {
    Speech = &XLevel.GenericSpeeches[-CurrentSpeechIndex-1];
  } else {
    Speech = &XLevel.LevelSpeeches[CurrentSpeechIndex-1];
  }

  Choice = &Speech->Choices[ChoiceNum-1];
  // check if player has needed items
  Item1 = CheckForNeededItem(CurrentSpeakingTo, Choice->NeedItem1, Choice->NeedAmount1);
  Item2 = CheckForNeededItem(CurrentSpeakingTo, Choice->NeedItem2, Choice->NeedAmount2);
  Item3 = CheckForNeededItem(CurrentSpeakingTo, Choice->NeedItem3, Choice->NeedAmount3);
  if (Item1 == -2 || Item2 == -2 || Item3 == -2) {
    CurrentSpeakingTo.Player.cprint("%s", Choice->TextNo);
    StopSpeech();
    return;
  }

  GaveItem = true;
  if (Choice->GiveItem > 0) {
    ItemType = GetClassFromID(Choice->GiveItem);
    if (ItemType) {
      Item = SpawnEntityChecked(class!Inventory, ItemType, default, default, default, false);
      if (Item) {
        // this shouldn't count for the item statistics
        if (Item.bCountItem) {
          Item.bCountItem = false;
          --Level.TotalItems;
        }
        GaveItem = Item.TryPickup(CurrentSpeakingTo);
        if (!GaveItem) Item.Destroy();
      }
    }
  }

  if (GaveItem) {
    if (Item1 != -1) {
      Item = CurrentSpeakingTo.FindInventory(class!Inventory(GetClassFromID(Choice->NeedItem1)));
      Item.Amount -= Choice->NeedAmount1;
      if (Item.Amount <= 0) Item.Destroy();
    }
    if (Item2 != -1) {
      Item = CurrentSpeakingTo.FindInventory(class!Inventory(GetClassFromID(Choice->NeedItem2)));
      Item.Amount -= Choice->NeedAmount2;
      if (Item.Amount <= 0) Item.Destroy();
    }
    if (Item3 != -1) {
      Item = CurrentSpeakingTo.FindInventory(class!Inventory(GetClassFromID(Choice->NeedItem3)));
      Item.Amount -= Choice->NeedAmount3;
      if (Item.Amount <= 0) Item.Destroy();
    }
  }

  if (Choice->Objectives) PlayerEx(CurrentSpeakingTo.Player).SetObjectives(Choice->Objectives);

  if (!GaveItem) {
    CurrentSpeakingTo.Player.cprint("%s", Choice->TextNo);
  } else if (strcmp(Choice->TextOK, "") && strcmp(Choice->TextOK, "_")) {
    CurrentSpeakingTo.Player.cprint("%s", Choice->TextOK);
  }

  if (Choice->Next < 0) {
    CurrentSpeaker.CurrentSpeech = -Choice->Next;
    if (!ConversationSlideshow) StartSpeech(CurrentSpeaker.GetSpeech());
  } else {
    if (Choice->Next) CurrentSpeaker.CurrentSpeech = Choice->Next;
    StopSpeech();
    ConversationSlideshow = false;
  }
}


//==========================================================================
//
//  AddPlayerCorpse
//
//==========================================================================
/*final*/ void AddPlayerCorpse (EntityEx Corpse) {
  if (bodyqueslot >= BodyQueSize) {
    // too many player corpses, remove an old one
    if (bodyque[bodyqueslot%BodyQueSize]) {
      bodyque[bodyqueslot%BodyQueSize].Destroy();
    }
  }
  bodyque[bodyqueslot%BodyQueSize] = Corpse;
  Corpse.Translation = XLevel.SetBodyQueueTrans(bodyqueslot%BodyQueSize, Corpse.Translation);
  ++bodyqueslot;
}


//==========================================================================
//
//  ParticleEffect
//
//  for fading particles (type1 == pt_fading):
//    high 8 bits of color is starting alpha
//    ramp is amount of fadeout (can be -1, which means "duration"
//
//==========================================================================
override void ParticleEffect (int count, int type1, int type2, TVec origin, float ornd,
                              TVec velocity, float vrnd, float acceleration, float grav,
                              int color, float duration, float ramp, optional TVec accelV)
{
  if (duration <= 0) return;

  if (type1 == pt_fading) {
    if ((color>>>24) < 1) return; // nothing to do
  }

  TVec porg = origin;

  foreach (auto i; 0..count) {
    // no random origin
    if (ornd) {
      porg.x = origin.x+((Random()*ornd)-ornd/2.0);
      porg.y = origin.y+((Random()*ornd)-ornd/2.0);
      porg.z = origin.z+((Random()*ornd)-ornd/2.0);
    }

    //TODO
    if (type1 == pt_fading) {
      return;
      /*
      p.die = Level.XLevel.Time+duration*Random();
      p.color = color;
      if (ramp < 0) {
        int initalpha = color>>>24;
        ramp = -initalpha; // hack!
      }
      p.ramp = ramp;
      p.org = origin;
      p.vel = velocity;
      p.accel = accelV;
      p.dur = duration;
      continue;
      */
    }

    particle_t *p = Level.NewParticle(porg);
    if (!p) return;

    p.die = Level.XLevel.Time+duration*Random();
    p.color = color;
    p.Size = 1.0;
    if (ramp) p.ramp = Random()*ramp;

    if (type2) {
      // choose between the two types
      p.type = (i&1 ? type1 : type2);
    } else {
      p.type = type1;
    }

    // no random velocity
    if (!vrnd) {
      p.vel = velocity;
    } else {
      p.vel.x = velocity.x*(Random()-vrnd);
      p.vel.y = velocity.y*(Random()-vrnd);
      p.vel.z = velocity.z*(Random()-vrnd);
    }
    p.accel.x = acceleration;
    p.accel.y = acceleration;
    p.accel.z = acceleration;
    p.gravity = grav;
  }
}


//==========================================================================
//
//  UpdateParticle
//
//==========================================================================
override void UpdateParticle (particle_t *p, float DeltaTime) {
  float time2 = DeltaTime*10.0; // 15;
  float time3 = DeltaTime*15.0;
  float dvel = 4.0*DeltaTime;
  float grav = DeltaTime*p.gravity /*sv_gravity.value * 0.05*/;
  p.vel.z -= grav;

  switch (p.type) {
    case pt_static:
      p.vel += p.accel*DeltaTime;
      break;

    case pt_explode:
      p.ramp += time2;
      if (p.ramp >= 16.0) {
        p.die = -1.0;
      } else {
        p.color = LineSpecialGameInfo.default.ramp1[int(p.ramp)];
      }
      p.vel.x += p.vel.x*dvel;
      p.vel.y += p.vel.y*dvel;
      p.vel.z += p.vel.z*dvel;
      p.vel += p.accel*DeltaTime;
      p.vel.z -= grav;
      break;

    case pt_explode2:
      p.ramp += time3;
      if (p.ramp >= 16.0) {
        p.die = -1.0;
      } else {
        p.color = LineSpecialGameInfo.default.ramp2[int(p.ramp)];
      }
      p.vel.x -= p.vel.x*DeltaTime;
      p.vel.y -= p.vel.y*DeltaTime;
      p.vel.z -= p.vel.z*DeltaTime;
      p.vel += p.accel*DeltaTime;
      p.vel.z -= grav;
      break;

    case pt_fountain:
      p.vel += p.accel*DeltaTime;
      p.color = (p.color&0x00ffffff)|(int(float(p.color>>24)-255.0/51.0*35.0*DeltaTime)<<24);
      break;

    case pt_spark:
      p.vel += p.accel*DeltaTime;
      p.color = (p.color&0x00ffffff)|(int(float(p.color>>24)-255.0/10.0*35.0*DeltaTime)<<24);
      break;

    case pt_ice_chunk:
      p.vel.x -= p.vel.x*DeltaTime;
      p.vel.y -= p.vel.y*DeltaTime;
      p.vel.z += p.accel.z*DeltaTime;
      break;

    case pt_rail:
      p.vel += p.accel*DeltaTime;
      p.color = (p.color&0x00ffffff)|(int(float(p.color>>24)-255.0*DeltaTime)<<24);
      break;
  }
}


//==========================================================================
//
//  AcsFadeRange
//
//==========================================================================
override void AcsFadeRange (float BlendR1, float BlendG1, float BlendB1, float BlendA1,
                            float BlendR2, float BlendG2, float BlendB2, float BlendA2,
                            float Duration, Entity Activator)
{
  if (Activator) {
    if (!Activator.bIsPlayer) return;
    StartFlashFader(BlendR1, BlendG1, BlendB1, BlendA1, BlendR2, BlendG2, BlendB2, BlendA2, Duration, Activator);
  } else {
    BasePlayer P;
    foreach AllActivePlayers(P) {
      StartFlashFader(BlendR1, BlendG1, BlendB1, BlendA1, BlendR2, BlendG2, BlendB2, BlendA2, Duration, P.MO);
    }
  }
}


//==========================================================================
//
//  StartFlashFader
//
//==========================================================================
/*final*/ void StartFlashFader (float BlendR1, float BlendG1, float BlendB1, float BlendA1,
                                float BlendR2, float BlendG2, float BlendB2, float BlendA2,
                                float Duration, Entity ForWho)
{
  PlayerEx P = PlayerEx(ForWho.Player);
  if (Duration <= 0.0) {
    P.BlendR = BlendR2;
    P.BlendG = BlendG2;
    P.BlendB = BlendB2;
    P.BlendA = BlendA2;
  } else {
    if (BlendA1 < 0.0) {
      if (P.BlendA <= 0.0) {
        BlendR1 = BlendR2;
        BlendG1 = BlendG2;
        BlendB1 = BlendB2;
        BlendA1 = 0.0;
      } else {
        BlendR1 = P.BlendR;
        BlendG1 = P.BlendG;
        BlendB1 = P.BlendB;
        BlendA1 = P.BlendA;
      }
    }
    FlashFader F = SpawnThinker(FlashFader);
    if (F && !F.IsDestroyed) {
      F.Init(BlendR1, BlendG1, BlendB1, BlendA1, BlendR2, BlendG2, BlendB2, BlendA2, Duration, EntityEx(ForWho));
    }
  }
}


//==========================================================================
//
//  AcsCancelFade
//
//==========================================================================
override void AcsCancelFade (Entity Activator) {
  Thinker Th;
  foreach AllThinkers(FlashFader, Th) {
    if (!Activator || FlashFader(Th).ForWho == Activator) {
      FlashFader(Th).Cancel();
    }
  }
}


//==========================================================================
//
//  P_Massacre
//
//  Kills all monsters.
//
//==========================================================================
/*final*/ int P_Massacre () {
  int count = 0;
  EntityEx mo;
  foreach AllThinkers(EntityEx, mo) {
    if (mo.bMonster && mo.Health > 0) {
      mo.bNonShootable = false;
      mo.bInvulnerable = false;
      mo.bDormant = false;
      mo.bShootable = true;
      mo.Damage(none, none, 10000, spawnBlood:true);
      ++count;
    }
  }
  return count;
}


//==========================================================================
//
//  P_MassacreEx
//
//  Kills all monsters.
//
//==========================================================================
/*final*/ int P_MassacreEx (string classmask, bool spawnBlood) {
  int count = 0;
  EntityEx mo;
  foreach AllThinkers(EntityEx, mo) {
    if (mo.bMonster && mo.Health > 0) {
      if (classmask && !globmatch(string(GetClassName(mo.Class)), classmask, caseSensitive:false)) continue;
      mo.bNonShootable = false;
      mo.bInvulnerable = false;
      mo.bDormant = false;
      mo.bShootable = true;
      bool oldBlood = mo.bNoBlood;
      if (!spawnBlood) mo.bNoBlood = true;
      mo.Damage(none, none, 10000, spawnBlood:spawnBlood);
      if (!spawnBlood) mo.bNoBlood = oldBlood;
      ++count;
    }
  }
  return count;
}


//==========================================================================
//
//  SetMarineWeapon
//
//==========================================================================
override void SetMarineWeapon (int Tid, int Weapon, Entity Activator) {
  foreach (EntityEx Ent; eachTID(Tid, Activator)) {
    if (ScriptedMarine(Ent)) ScriptedMarine(Ent).SetWeapon(Weapon);
  }
}


//==========================================================================
//
//  SetMarineSprite
//
//==========================================================================
override void SetMarineSprite (int Tid, name SrcClassName, Entity Activator) {
  // if there's no such class, print message and do nothing
  class TmpClass = FindClass(SrcClassName);
  if (!TmpClass) {
    printwarn("SetMarineSprite: Unknown class `%s`", SrcClassName);
    return;
  }

  // if it's not a valid actor class, it will set sprite back to default
  class!EntityEx SrcClass = class!EntityEx(TmpClass);

  foreach (EntityEx Ent; eachTID(Tid, Activator)) {
    if (ScriptedMarine(Ent)) ScriptedMarine(Ent).SetSprite(SrcClass);
  }
}


//==========================================================================
//
//  GetDefaultDoorSound
//
//==========================================================================
name GetDefaultDoorSound (sector_t *Sector) {
  return DefaultDoorSound;
}


//==========================================================================
//
//  GetClassSpawnFlags
//
//==========================================================================
int GetPClassSpawnFlags () {
  if (!Game.netgame) {
    // single player
    //return MainGameInfo(Game).classFlags[GetCvar('class')];
    int pcl = GetCvar('class');
    //printdebug("GetPClassSpawnFlags: class=%s", pcl);
    if (pcl < 0 || pcl > 15) return 0;
    return (MTF2_CLASS_BASE<<pcl);
  }
#ifdef FIXME  //  Because of client/server and in-game joining we can't do this
  else if (!deathmatch)
  {
    // Cooperative
    int spawnMask = 0;
    for (i = 0; i < MAXPLAYERS; i++)
    {
      if (GPlayers[i])
      {
        spawnMask |= classFlags[PlayerClass[i]];
      }
    }
    return spawnMask;
  }
#endif
  return 0;
}


//==========================================================================
//
//  GetDehackedItemType
//
//==========================================================================
class!Inventory GetDehackedItemType (EntityEx Ent) {
  return none;
}


defaultproperties {
  ExtPlayersBase = 4001;
  Lock103Message = "That doesn't seem to work";
  BodyQueSize = DEFAULT_BODYQUESIZE;
  CorpseQueSize = DEFAULT_CORPSEQUEUESIZE;
  DefaultDoorSound = 'DoorNormal';
  DefaultCeilingSound = 'CeilingNormal';
  DefaultSilentCeilingSound = 'CeilingSemiSilent';
  DefaultFloorSound = 'Floor';
  DefaultFloorAltSound = 'Floor';
  DefaultStairStepSound = 'Floor';
  DefaultPlatformSound = 'Platform';
}
