//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//**
//**  Base class for all items that a player can carry.
//**
//**************************************************************************

class Inventory : Actor
  abstract;

const float BONUSADD    = 0.2;

const int DefMaxAmount    = -2;

//  Special values for powerup's blend colour.
const int INVERSECOLOUR   = 0x00123456;
const int GOLDCOLOUR    = 0x00123457;
const int REDCOLOUR     = 0x00123458;
const int GREENCOLOUR   = 0x00123459;

int         Amount;         // Amount of item this instance has.
int         InterHubAmount;     // Amount of item that can be kept between hubs or levels.
int         MaxAmount;        // Max amount of item this instance can have.
string        PickupMessage;
float       RespawnTime;      // Tics from pickup time to respawn time.
int         GiveQuestNum;
name        IconName;
float       DropTime;
//  Spawn PickuFlash when picked up.
class!Actor    PickupFlashType;

name        PickupSound;
name        UseSound;

//  Originally these didn't respawn in deathmatch
bool        bBigPowerup;
//  Play pickup sound at full volume
bool        bFullVolPickupSound;
//  Used by HandlePickup.
bool        bPickupGood;
//  Can be displayed in the inventory bar
bool        bInvBar;
//  Keep item in inventory even if amount is 0
bool        bKeepDepleted;
//  This item cannot be tossed out
bool        bUndroppable;
//  Ignore skill level when giving this item
bool        bIgnoreSkill;
//  Automaticly use when picked up.
bool        bAutoActivate;
//  For auto activate items always pick up the item, even if it wasn't used.
bool        bAlwaysPickup;
//  Keep powerup while travelingbetween levels in a hub
bool        bHubPower;
//  Remove when traveling between different clusters.
bool        bInterHubStrip;
//  No feedback when picked up
bool        bQuiet;
//  When picked up while it's still active, time is added
bool        bAdditiveTime;
//  CreateCopy changed the owner
bool        bCreateCopyMoved;
//  Powerup failed to activate.
bool        bInitEffectFailed;

bool bNoAutoaim;
bool bIsHitscanWeapon;

replication
{
  reliable if (Role == ROLE_Authority && bNetOwner)
    Amount, MaxAmount;
}


enum /*EFireCustomMissileFlags*/ {
  FPF_AIMATANGLE = 1,
  FPF_TRANSFERTRANSLATION = 2,
  FPF_NOAUTOAIM = 4,
};

// for `A_Saw`
const int SF_NORANDOM = 1;
const int SF_RANDOMLIGHTMISS = 2;
const int SF_RANDOMLIGHTHIT = 4;
const int SF_RANDOMLIGHTBOTH = 6;
const int SF_NOUSEAMMOMISS = 8;
const int SF_NOUSEAMMO = 16;
const int SF_NOPULLIN = 32; // not implemented
const int SF_NOTURN = 64;
const int SF_STEALARMOR = 128; // not implemented


//==========================================================================
//
//  OnMapSpawn
//
//==========================================================================

override void OnMapSpawn(mthing_t *mthing)
{
  if (!mthing)
  {
    //  Non-placed items are dropped by default.
    bDropped = true;
  }
  if (MaxAmount == DefMaxAmount)
  {
    MaxAmount = LineSpecialGameInfo(Level.Game).InvDefaultMaxAmount;
  }
  ::OnMapSpawn(mthing);
}

//==========================================================================
//
//  Destroyed
//
//==========================================================================

override void Destroyed()
{
  if (Role == ROLE_Authority)
  {
    if (Owner)
    {
      EntityEx(Owner).RemoveInventory(self);
    }
    Inventory = none;
  }
  ::Destroyed();
}

//==========================================================================
//
//  Tick
//
//==========================================================================

override void Tick(float DeltaTime)
{
  ::Tick(DeltaTime);
  if (DropTime)
  {
    DropTime -= DeltaTime;
    if (DropTime <= 0.0)
    {
      DropTime = 0.0;
      bSpecial = default.bSpecial;
      bSolid = default.bSolid;
    }
  }
}


//==========================================================================
//
//  IsAutoaimDisabled
//
//==========================================================================
final bool IsAutoaimDisabled () {
  if (bNoAutoaim) return true;
  if (bIsHitscanWeapon && !GetCvarB('k8HitscanAutoAim')) return true;
  return false;
}


//==========================================================================
//
//  BecomeItem
//
//==========================================================================
final void BecomeItem()
{
  UnlinkFromWorld();
  bNoSector = true;
  bNoBlockmap = true;
  LinkToWorld();
  SetTID(0);
  bSpecial = false;
  SetState(FindState('Held'));
}

//==========================================================================
//
//  BecomePickup
//
//==========================================================================

final void BecomePickup()
{
  if (Owner)
  {
    EntityEx(Owner).RemoveInventory(self);
  }
  UnlinkFromWorld();
  bNoSector = false;
  bNoBlockmap = false;
  LinkToWorld();
  bSpecial = default.bSpecial;
  SetState(IdleState);
}

//==========================================================================
//
//  AttachToOwner
//
//==========================================================================

void AttachToOwner(EntityEx NewOwner)
{
  BecomeItem();
  NewOwner.AddInventory(self);
}

//==========================================================================
//
//  DetachedFromOwner
//
//  Event called when item is being removed from Owner's inventory.
//
//==========================================================================

void DetachedFromOwner()
{
}

//==========================================================================
//
//  TouchSpecial
//
//==========================================================================

final override void TouchSpecial(EntityEx Toucher, optional bool noflash)
{
  if (!Toucher.bPickUp)
  {
    // Can't be picked up by toucher
    return;
  }
  if (Toucher.Health <= 0)
  {
    // Toucher is dead
    return;
  }

  //  Make sure that if it's a voodoo doll touching item it's given to the
  // actual player actor.
  if (Toucher.bIsPlayer)
  {
    Toucher = EntityEx(Toucher.Player.MO);
  }

  if (!TryPickup(Toucher))
  {
    return;
  }

  if (!bQuiet && (!specified_noflash || !noflash))
  {
    if (Toucher.bIsPlayer)
    {
      Toucher.Player.cprint(GetPickupMessage());
    }
    PlayPickupSound(Toucher);
    if (Toucher.bIsPlayer)
    {
      PlayerEx(Toucher.Player).BonusFlash += BONUSADD;
    }
  }

  DoPickupSpecial(Toucher);
  if (bCountItem)
  {
    if (Toucher.bIsPlayer)
    {
      Toucher.Player.ItemCount++;
    }
    Level.CurrentItems++;
  }
}

//==========================================================================
//
//  TryPickup
//
//==========================================================================

bool TryPickup(EntityEx Toucher)
{
  EntityEx NewToucher = Toucher;
  bPickupGood = false;
  if (Toucher.Inventory && Toucher.Inventory.HandlePickup(self))
  {
    if (!bPickupGood)
    {
      return false;
    }
    GoAwayAndDie();
  }
  else if (MaxAmount == 0)
  {
    //  A special case: Items with max amount of 0 can be picked up if
    // they are autoactivate-able.
    if (!bAutoActivate)
    {
      return false;
    }

    //  Put it in the inventory long enoung to be used.
    Toucher.AddInventory(self);
    bool UseGood = Use(true);
    Toucher.RemoveInventory(self);

    if (UseGood || bAlwaysPickup)
    {
      GoAwayAndDie();
    }
    else
    {
      return false;
    }
  }
  else
  {
    Inventory Copy = CreateCopy(Toucher);
    if (!Copy)
    {
      return false;
    }
    //  Some powerups cannot activate absolutely, for example,
    // PowerMorph; fail the pickup if so.
    if (Copy.bInitEffectFailed)
    {
      if (Copy != self)
      {
        Copy.Destroy();
      }
      else
      {
        bInitEffectFailed = false;
      }
      return false;
    }
    //  Handle owner-changing powerups
    if (Copy.bCreateCopyMoved)
    {
      NewToucher = EntityEx(Copy.Owner);
      Copy.Owner = none;
      Copy.bCreateCopyMoved = false;
    }
    Copy.AttachToOwner(NewToucher);
    if (bAutoActivate && Copy.Use(true))
    {
      Copy.Amount--;
      if (Copy.Amount <= 0)
      {
        Copy.bSpecial = false;
        Copy.SetState(Copy.FindState('HoldAndDestroy'));
      }
    }
  }
  GiveQuest(Toucher);
  return true;
}

//==========================================================================
//
//  HandlePickup
//
//  Called for each item in touchers inventory. Returns true if pickup
// should be interrupted. Sets bPickupGood to true if pickup should be
// considered successful.
//
//==========================================================================

bool HandlePickup(Inventory Item)
{
  if (Item.Class == Class)
  {
    if (Amount < MaxAmount)
    {
      Amount += Item.Amount;
      if (Amount > MaxAmount)
      {
        Amount = MaxAmount;
      }
      Item.bPickupGood = true;
    }
    return true;
  }

  if (Inventory)
  {
    return Inventory.HandlePickup(Item);
  }
  return false;
}

//==========================================================================
//
//  CreateCopy
//
//==========================================================================

Inventory CreateCopy(EntityEx Toucher)
{
  Inventory Copy;
  if (GoAway())
  {
    //  Must create a copy
    Copy = Spawn(class!Inventory(Class), default, default, default, false);
    Copy.Amount = Amount;
    Copy.MaxAmount = MaxAmount;
    //print("COPIED %C (%C)", Copy, self);
  }
  else
  {
    //  Use this one
    Copy = self;
    /*
    print("USED AS COPY %C", self);
    if (HasFieldByName('user_unloading')) {
      print("GRS: %C; user_unloading=%d:%d; spread=%d:%d", self,
        GetIntFieldByName('user_unloading'), GetIntFieldByName('user_unloading', default_value:true),
        GetIntFieldByName('user_spread'), GetIntFieldByName('user_spread', default_value:true));
    }
    */
  }
  return Copy;
}

//==========================================================================
//
//  CreateTossable
//
//  Create item suitable fro dropping.
//
//==========================================================================

Inventory CreateTossable()
{
  if (!IdleState)
  {
    //  This item has no spawn state so it cannot be seen.
    return none;
  }
  if (bUndroppable || !Owner || Amount <= 0)
  {
    return none;
  }

  if (Amount == 1 && !bKeepDepleted)
  {
    //  Drop the current one.
    BecomePickup();
    DropTime = 1.0;
    bSpecial = false;
    bSolid = false;
    return self;
  }

  Inventory Copy = Spawn(class!Inventory(Class), default, default, default, false);
  Copy.Amount = 1;
  Copy.MaxAmount = MaxAmount;
  Copy.DropTime = 1.0;
  Copy.bSpecial = false;
  Copy.bSolid = false;
  Amount--;
  return Copy;
}

//==========================================================================
//
//  ShouldStay
//
//  Returns true if item should stay after it's been picked up.
//
//==========================================================================

bool ShouldStay()
{
  return false;
}

//==========================================================================
//
//  ShouldRespawn
//
//==========================================================================

bool ShouldRespawn()
{
  if (bBigPowerup && !LineSpecialGameInfo(Level.Game).bRespawnBigItems)
  {
    return false;
  }
  return LineSpecialGameInfo(Level.Game).bRespawnItems;
}

//==========================================================================
//
//  GoAway
//
//==========================================================================

final bool GoAway()
{
  //  Never respawn dropped items.
  if (bDropped)
  {
    if (PickupFlashType)
    {
      //  Initiate the artifact pickup animation.
      Spawn(PickupFlashType, Origin);
    }
    return false;
  }

  if (!ShouldStay())
  {
    if (PickupFlashType)
    {
      //  Initiate the artifact pickup animation.
      Spawn(PickupFlashType, Origin);
    }
    if (ShouldRespawn())
    {
      Hide();
    }
    else
    {
      // Don't respawn
      return false;
    }
  }
  return true;
}

//==========================================================================
//
//  GoAwayAndDie
//
//==========================================================================

final void GoAwayAndDie()
{
  if (!GoAway())
  {
    bSpecial = false;
    SetState(FindState('HoldAndDestroy'));
  }
}

//==========================================================================
//
//  Hide
//
//==========================================================================

final void Hide()
{
  bSpecial = false;
  bInvisible = true;
  if (LineSpecialGameInfo(Level.Game).bRavenStylePickupRespawn)
  {
    SetState(FindState('HideSpecial'));
    StateTime = 40.0;
    if (PickupFlashType)
    {
      StateTime += 30.0 / 35.0;
    }
  }
  else
  {
    SetState(FindState('DormantPickup'));
    StateTime = 30.0;
  }
  if (RespawnTime)
  {
    StateTime = RespawnTime;
  }
}

//==========================================================================
//
//  GetPickupMessage
//
//==========================================================================

string GetPickupMessage()
{
  return PickupMessage;
}

//==========================================================================
//
//  DoPickupSpecial
//
//==========================================================================

void DoPickupSpecial(EntityEx Toucher)
{
  if (Special)
  {
    Level.ExecuteActionSpecial(Special, Args[0], Args[1], Args[2],
      Args[3], Args[4], nullptr, 0, Toucher);
    Special = 0;
  }
}

//==========================================================================
//
//  PlayPickupSound
//
//==========================================================================

void PlayPickupSound(EntityEx Toucher)
{
  if (PickupSound)
  {
    Toucher.PlaySound(PickupSound, /*CHAN_BODY*/CHAN_AUTO, 1.0,
      bFullVolPickupSound ? ATTN_NONE : ATTN_NORMAL);
  }
}

//==========================================================================
//
//  GiveQuest
//
//==========================================================================

final void GiveQuest(EntityEx Toucher)
{
  if (GiveQuestNum)
  {
    Toucher.GiveInventoryType(class!Inventory(FindClass(
      StrToName(va("QuestItem%d", GiveQuestNum)))));
  }
}

//==========================================================================
//
//  DoRespawn
//
//==========================================================================

bool DoRespawn()
{
  return true;
}

//==========================================================================
//
//  SpecialDropAction
//
//==========================================================================

bool SpecialDropAction(EntityEx Source)
{
  return false;
}

//==========================================================================
//
//  PrevInv
//
//  Return previous item with bInvBar flag set.
//
//==========================================================================

Inventory PrevInv()
{
  Inventory Item = Inventory;
  while (Item && !Item.bInvBar)
  {
    Item = Item.Inventory;
  }
  return Item;
}

//==========================================================================
//
//  NextInv
//
//  Return next item with bInvBar flag set.
//
//==========================================================================

Inventory NextInv()
{
  Inventory Ret = none;
  Inventory Item = EntityEx(Owner).Inventory;
  while (Item && Item != self)
  {
    if (Item.bInvBar)
    {
      Ret = Item;
    }
    Item = Item.Inventory;
  }
  return Ret;
}

//==========================================================================
//
//  Use
//
//==========================================================================

bool Use(bool Pickup)
{
  return false;
}

//==========================================================================
//
//  DoEffect
//
//==========================================================================

void DoEffect()
{
}

//==========================================================================
//
//  GetBlend
//
//==========================================================================

int GetBlend()
{
  return 0;
}

//==========================================================================
//
//  AbsorbDamage
//
//==========================================================================

void AbsorbDamage(int damage, name DmgType, out int NewDamage)
{
  if (Inventory)
  {
    Inventory.AbsorbDamage(damage, DmgType, NewDamage);
  }
}

//==========================================================================
//
//  OwnerDied
//
//==========================================================================

void OwnerDied()
{
}

//==========================================================================
//
//  GetSpeedFactor
//
//==========================================================================

float GetSpeedFactor()
{
  if (Inventory)
  {
    return Inventory.GetSpeedFactor();
  }
  else
  {
    return 1.0;
  }
}

//**************************************************************************
//  State jumps
//**************************************************************************

//==========================================================================
//
//  A_JumpIfNoAmmo
//
//==========================================================================

final void A_JumpIfNoAmmo(state Label)
{
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;

  // inly for weapons
  if (!bIsPlayer || XLevel.StateCall) return;
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;
  if (!Wpn) return;

  if (!Wpn.CheckAmmo(Wpn.FireMode, false, true)) {
    PlayerEx(Player).SetViewObject(Wpn);
    DoJump(Label);
  }
}

//**************************************************************************
//  Weapon functions
//**************************************************************************

//==========================================================================
//
//  A_Lower
//
//  Lowers current weapon, and changes weapon at bottom.
//
//==========================================================================
final void A_Lower () {
  decorate_A_Lower();
}


//==========================================================================
//
//  A_Lower
//
//  Lowers current weapon, and changes weapon at bottom.
//
//==========================================================================
final void decorate_A_Lower (optional float lowerspeed) {
  if (!bIsPlayer) return;

  Weapon ready = PlayerEx(Player).ReadyWeapon;
  Weapon pending = PlayerEx(Player).PendingWeapon;

  if (!pending) {
    print("AUTHOR OF THIS MOD IS IDIOT! (2)");
    return;
  }

  if (ready && ready == pending) {
    print("AUTHOR OF THIS MOD IS IDIOT! (3)");
    return;
  }

  if (!specified_lowerspeed) lowerspeed = Weapon::LOWERSPEED;
  if (lowerspeed <= 0) lowerspeed = Weapon::LOWERSPEED; //k8: sanity guard

  if (PlayerEx(Player).MorphTime || PlayerEx(Player).bInstantWeaponSwitch) {
    Player.ViewStates[ps_weapon].SY = Weapon::WEAPONBOTTOM;
  } else {
    // FIXME!!
    if (Level.Game.frametime < 1.0/35.0) {
      Player.ViewStates[ps_weapon].SY += lowerspeed;
    } else {
      Player.ViewStates[ps_weapon].SY += lowerspeed*35.0*Level.Game.frametime;
    }
  }

  if (Player.ViewStates[ps_weapon].SY < Weapon::WEAPONBOTTOM) return; // not lowered all the way yet

  if (Player.PlayerState == PST_DEAD) {
    // Player is dead, so don't bring up a pending weapon
    Player.ViewStates[ps_weapon].SY = Weapon::WEAPONBOTTOM;
    return;
  }

  if (Player.MO.Health <= 0) {
    // Player is dead, so keep the weapon off screen.
    Player.SetViewObject(none);
    Player.SetViewState(ps_weapon, none);
    return;
  }

  // clear flash state, needed for Strife
  Player.SetViewState(ps_flash, none);

  PlayerEx(Player).SetWeapon(pending/*PlayerEx(Player).PendingWeapon*/);
  PlayerEx(Player).BringUpWeapon();
}


//==========================================================================
//
//  A_Raise
//
//==========================================================================
final void A_Raise () {
  decorate_A_Raise();
}


//==========================================================================
//
//  A_Raise
//
//==========================================================================
final void decorate_A_Raise (optional float raisespeed) {
  if (!bIsPlayer) return;
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;

  if (!specified_raisespeed) raisespeed = Weapon::RAISESPEED;
  if (raisespeed <= 0) raisespeed = Weapon::RAISESPEED; //k8: sanity guard

  // FIXME!!
  if (Level.Game.frametime < 1.0/35.0) {
    Player.ViewStates[ps_weapon].SY -= raisespeed;
  } else {
    Player.ViewStates[ps_weapon].SY -= raisespeed*35.0*Level.Game.frametime;
  }

  if (Player.ViewStates[ps_weapon].SY > Weapon::WEAPONTOP) return; // not raised all the way yet
  Player.ViewStates[ps_weapon].SY = Weapon::WEAPONTOP;
  Player.SetViewObject(Wpn);
  if (Wpn) {
    Player.SetViewState(ps_weapon, Wpn.GetReadyState());
  } else {
    Player.SetViewState(ps_weapon, none);
  }
}


//===========================================================================
//
//  A_ReFire
//
//  The player can re-fire the weapon without lowering it entirely.
//
//===========================================================================
private final void do_A_ReFire (optional state refirestate) {
  if (!bIsPlayer) return;
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;

  if (!Wpn) {
    PlayerEx(Player).Refire = 0;
    return;
  }

  if (Wpn.FireMode == Weapon::FIRE_Primary &&
      (Player.Buttons&BT_ATTACK) &&
      !PlayerEx(Player).PendingWeapon && Player.MO.Health > 0)
  {
    //writeln("A_ReFire: primary");
    ++PlayerEx(Player).Refire;
    if (!k8InWeaponReady) PlayerEx(Player).FireWeapon(refirestate!optional);
  }
  else if (Wpn.FireMode == Weapon::FIRE_Secondary &&
           (Player.Buttons&BT_ALT_ATTACK) &&
           !PlayerEx(Player).PendingWeapon && Player.MO.Health > 0)
  {
    //writeln("A_ReFire: secondary");
    ++PlayerEx(Player).Refire;
    if (!k8InWeaponReady) PlayerEx(Player).AltFireWeapon(refirestate!optional);
  } else {
    //writeln("A_ReFire: nothing");
    PlayerEx(Player).Refire = 0;
    Wpn.CheckAmmo(Wpn.FireMode, true);
  }
}


//===========================================================================
//
//  A_ReFire
//
//  VC state function cannot have arguments yet
//
//===========================================================================
final void A_ReFire () {
  do_A_ReFire();
}


//===========================================================================
//
//  A_ReFire
//
//===========================================================================
final void decorate_A_ReFire (optional state refirestate) {
  do_A_ReFire(refirestate!optional);
}


//===========================================================================
//
//  A_ClearReFire
//
//===========================================================================
final void A_ClearReFire () {
  if (bIsPlayer) PlayerEx(Player).Refire = 0;
}


//===========================================================================
//
//  A_GunFlash
//
//===========================================================================
final void A_GunFlash () {
  decorate_A_GunFlash();
}


//===========================================================================
//
//  A_GunFlash
//
//  GFF_NOEXTCHANGE is 1
//
//===========================================================================
final void decorate_A_GunFlash (optional name newstate, optional int flags)
{
  if (!bIsPlayer) return;

  Weapon Wpn = PlayerEx(Player).ReadyWeapon;
  if (!Wpn) return; // just in case
  Player.SetViewObject(Wpn);

  if (!specified_newstate) newstate = 'Flash';

  if (MeleeState) SetState(MeleeState);
  if (newstate && !(flags&1)) {
    Player.SetViewState(ps_flash, Wpn.FindState(newstate));
  }
}


//===========================================================================
//
//  A_CheckReload
//
//===========================================================================

final void A_CheckReload()
{
  if (!bIsPlayer)
  {
    return;
  }
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;

  Wpn.CheckAmmo(Wpn.FireMode, true);
}

//===========================================================================
//
//  A_Light
//
//===========================================================================

final void A_Light(int LightValue)
{
  if (!bIsPlayer)
  {
    return;
  }

  if (LightValue < 0)
  {
    LightValue = 0;
  }
  else if (LightValue > 20)
  {
    LightValue = 20;
  }
  Player.ExtraLight = LightValue;
}

//===========================================================================
//
//  A_Light0
//
//===========================================================================

final void A_Light0()
{
  if (!bIsPlayer)
  {
    return;
  }

  Player.ExtraLight = 0;
}

//===========================================================================
//
//  A_Light1
//
//===========================================================================

final void A_Light1()
{
  if (!bIsPlayer)
  {
    return;
  }

  Player.ExtraLight = 1;
}

//===========================================================================
//
//  A_Light2
//
//===========================================================================

final void A_Light2()
{
  if (!bIsPlayer)
  {
    return;
  }

  Player.ExtraLight = 2;
}

//==========================================================================
//
//  A_LightInverse
//
//==========================================================================

final void A_LightInverse()
{
  if (bIsPlayer)
  {
    Player.ExtraLight = 255;
  }
}


//**************************************************************************
//  Weapon attack functions
//**************************************************************************

//===========================================================================
//
//  A_Saw
//
//===========================================================================
final void A_Saw () {
  decorate_A_Saw();
}


//===========================================================================
//
//  decorate_A_Saw
//
//===========================================================================
final void decorate_A_Saw (optional name FullSound, optional name HitSound,
  optional int SawDamage, optional class!Actor PuffType,
  optional int flags, optional float range, optional float spread_xy, optional float spread_z
  /*, optional float lifesteal, optional float lifestealmax, string armorbonustype*/)
{
  //float angle;
  //int damage;
  //TAVec aimAng;
  //EntityEx AimTarget;
  TVec dir;

  if (!bIsPlayer) return;

  if (!specified_FullSound) {
    FullSound = 'weapons/sawfull';
    HitSound = 'weapons/sawhit';
  }

  if (!SawDamage) SawDamage = 2;
  if (!PuffType) PuffType = BulletPuff;
  if (!specified_range || !range) range = SAWRANGE;
  range = fmax(1.0, range); // just in case

  int oldAmmo1, oldAmmo2;

  Weapon Wpn = PlayerEx(Player).ReadyWeapon;
  if (Wpn) {
    oldAmmo1 = (Wpn.Ammo1 ? Wpn.Ammo1.Amount : 0);
    oldAmmo2 = (Wpn.Ammo2 ? Wpn.Ammo2.Amount : 0);
    if (!(flags&SF_NOUSEAMMO)) {
      if (!Wpn.DepleteAmmo(Wpn.FireMode)) return;
    }
  }

  int damage = SawDamage;
  if (!(flags&SF_NORANDOM)) damage *= P_Random()%10+1;

  TAVec aimAng = Angles;
  aimAng.yaw = AngleMod360(aimAng.yaw+(Random()-Random())*45.0/8.0);

  EntityEx AimTarget = AimLineAttack(dir, aimAng, range/*SAWRANGE*/);
  LineAttack(dir, /*SAWRANGE*/range, damage, PuffType, default, default, 'Chainsaw');

  if (!AimTarget) {
    // miss
    if (Wpn && !(flags&SF_NOUSEAMMO) && (flags&SF_NOUSEAMMOMISS)) {
      // restore ammo
      if (Wpn.Ammo1) Wpn.Ammo1.Amount = oldAmmo1;
      if (Wpn.Ammo2) Wpn.Ammo2.Amount = oldAmmo2;
    }
    // light
    if (flags&SF_RANDOMLIGHTMISS) {
      auto randVal = P_Random();
           if (randVal < 64) Player.ExtraLight = 0;
      else if (randVal < 160) Player.ExtraLight = 1;
      else Player.ExtraLight = 2;
    }
    PlaySound(FullSound, CHAN_WEAPON);
    return;
  }

  PlaySound(HitSound, CHAN_WEAPON);

  // turn to face target
  if (!(flags&SF_NOTURN)) {
    float angle = atan2(AimTarget.Origin.y-Origin.y, AimTarget.Origin.x-Origin.x);
    if (AngleMod360(angle-Angles.yaw) > 180.0) {
      if (AngleMod360(angle-Angles.yaw) < -90.0/20.0) {
        Angles.yaw = angle+90.0/21.0;
      } else {
        Angles.yaw = Angles.yaw-90.0/20.0;
      }
    } else {
      if (AngleMod360(angle-Angles.yaw) > 90.0/20.0) {
        Angles.yaw = angle-90.0/21.0;
      } else {
        Angles.yaw += 90.0/20.0;
      }
    }
  }
  Angles.yaw = AngleMod360(Angles.yaw);

  bJustAttacked = true;
  if (bIsPlayer) {
    Player.bFixAngle = true;
    // light
    if (flags&SF_RANDOMLIGHTHIT) {
      auto randVal = P_Random();
           if (randVal < 64) Player.ExtraLight = 0;
      else if (randVal < 160) Player.ExtraLight = 1;
      else Player.ExtraLight = 2;
    }
  }
}


//===========================================================================
const int CPF_USEAMMO       = 1;
const int CPF_DAGGER        = 2;
const int CPF_PULLIN        = 4;
const int CPF_NORANDOMPUFFZ = 8;
const int CPF_NOTURN        = 16;
const int CPF_STEALARMOR    = 32; // not implemented yet


//===========================================================================
//
//  A_CustomPunch
//
//===========================================================================
final void A_CustomPunch (int PunchDamage, optional bool NoRandom,
  optional int Flags, optional class!Actor PuffType,
  optional float Range, optional float LifeSteal,
  optional float lifestealmax, optional class!BasicArmorBonus armorbonustype,
  optional name meleesound, optional name misssound)
{
  TAVec aimAngles;
  TVec dir;
  EntityEx AimTarget;

  if (!bIsPlayer) return;
  if (Range < 0) return; //k8: sanity check
  if (!Range) Range = MELEERANGE; //SAWRANGE; // use saw range instead of melee range here, for puffs

  bool UseAmmo = (specified_Flags ? !!(Flags&CPF_USEAMMO) : false);
  if (!PuffType) PuffType = BulletPuff;

  Weapon Wpn = PlayerEx(Player).ReadyWeapon;

  aimAngles = Angles;
  aimAngles.yaw = AngleMod360(aimAngles.yaw+(Random()-Random())*45.0/8.0);
  AimTarget = AimLineAttack(dir, aimAngles, Range);

  // use ammo only if hit something
  if (Wpn && AimTarget && UseAmmo) {
    if (!Wpn.DepleteAmmo(Wpn.FireMode)) return;
  }

  if (!NoRandom) PunchDamage *= (P_Random()%8+1);

  LineAttack(dir, Range, PunchDamage, PuffType, default, default, PuffType.default.DamageType);

  // turn to face target
  if (AimTarget) {
    if (LifeSteal > 0) {
      float stealed = fmax(0, float(PunchDamage)*LifeSteal);
      if (stealed > 0 && lifestealmax > 0) stealed = fmin(stealed, lifestealmax);
      if (stealed > 0) {
        if (Flags&CPF_STEALARMOR) {
          RepairArmorWith(int(stealed), armorbonustype!optional);
        } else {
          GiveBody(int(stealed));
        }
      }
    }
    if (Wpn) PlaySound((meleesound ? meleesound : Wpn.AttackSound), CHAN_WEAPON);
    if (!(Flags&CPF_NOTURN)) {
      Angles.yaw = atan2(AimTarget.Origin.y-Origin.y, AimTarget.Origin.x-Origin.x);
      if (bIsPlayer) Player.bFixAngle = true;
    }
    if (Flags&CPF_PULLIN) bJustAttacked = true;
    if (Flags&CPF_DAGGER) A_AttackAlert(self, AimTarget); // incorrect; see https://zdoom.org/wiki/A_CustomPunch
  } else {
    if (misssound) PlaySound(misssound, CHAN_WEAPON);
  }
}


//===========================================================================
const int FBF_USEAMMO = 1;
const int FBF_NORANDOM = 2;
const int FBF_EXPLICITANGLE = 4;
const int FBF_NOPITCH = 8;
const int FBF_NOFLASH = 16;
const int FBF_NORANDOMPUFFZ = 32;


//===========================================================================
//
//  A_FireBullets
//
//===========================================================================

final void A_FireBullets(float SpreadHoriz, float SpreadVert, int NumBullets,
  int DamagePerBullet, optional class!Actor PuffType, optional int Flags,
  optional float Range)
{
  TVec dir;
  int damage;
  TAVec rot;
  TVec aimDir;
  bool UseAmmo = (specified_Flags ? !!(Flags&FBF_USEAMMO) : true);
  bool randDamage = true;
  bool randSpread = true;
  bool noAimPitch = false;
  bool doFlash = false; // not implemented yet
  bool doRandPuffZ = false; // not implemented yet

  if (!PuffType || !specified_PuffType) PuffType = BulletPuff;
  if (!specified_Range || !Range) Range = 8192; //MISSILERANGE;

  if (!bIsPlayer) return;
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;

  if (UseAmmo) {
    if (!Wpn) return;
    if (!Wpn.DepleteAmmo(Wpn.FireMode)) return;
  }

  if (specified_Flags) {
    randDamage = !(Flags&FBF_NORANDOM);
    randSpread = !(Flags&FBF_EXPLICITANGLE);
    noAimPitch = !!(Flags&FBF_NOPITCH);
    doFlash = !(Flags&FBF_NOFLASH);
    doRandPuffZ = !(Flags&FBF_NORANDOMPUFFZ);
  }

  if (MeleeState) SetState(MeleeState);

  bool noAAim = false;
  name decal = ''; // default
  if (Wpn) {
    PlaySound(Wpn.AttackSound, CHAN_WEAPON);
    noAAim = Wpn.IsAutoaimDisabled(); //bNoAutoaim;
    if (!noAAim && !GetCvarB('k8HitscanAutoAim')) noAAim = true;
    decal = Wpn.DecalName;
  }

  Aim(aimDir, 16.0 * 64.0, default, noAAim, noAimPitch);

  if ((NumBullets == 1 && !PlayerEx(Player).Refire) || NumBullets == 0) {
    damage = DamagePerBullet;
    if (randDamage) damage *= (P_Random()%3+1);
    LineAttack(aimDir, Range, damage, PuffType, default, default, PuffType.default.DamageType, false, decal);
  } else {
    if (NumBullets == -1) NumBullets = 1;
    foreach (auto i; 0..NumBullets) {
      if (randSpread) {
        rot.pitch = (Random() - Random()) * SpreadVert;
        rot.yaw = (Random() - Random()) * SpreadHoriz;
      } else {
        rot.pitch = SpreadVert;
        rot.yaw = SpreadHoriz;
      }
      rot.roll = 0.0;
      dir = RotateDirectionVector(aimDir, rot);
      damage = DamagePerBullet;
      if (randDamage) damage *= (P_Random()%3+1);
      LineAttack(dir, Range, damage, PuffType, default, default, PuffType.default.DamageType, (i != 0), decal);
    }
  }
}


//===========================================================================
//
//  doFireMissileProjectile
//
//  `A_FireCustomMissile()` and `A_FireProjectile()` are the same thing, so
//  they'll both will use this code
//
//===========================================================================
final void doFireMissileProjectile (class!Actor MissileType, optional float Angle,
  optional bool UseAmmo, optional int SpawnXY, optional float SpawnZ,
  optional int Flags, optional float Pitch)
{
  if (!MissileType || !bIsPlayer) return;

  if (!specified_UseAmmo) UseAmmo = true;

  name decal = ''; // default
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;
  if (UseAmmo) {
    if (!Wpn) return;
    if (!Wpn.DepleteAmmo(Wpn.FireMode)) return;
  }
  if (Wpn) decal = Wpn.DecalName;

  TVec ShootOrg = Origin;
  if (SpawnXY) {
    ShootOrg.x += float(SpawnXY)*cos(Angles.yaw-90.0);
    ShootOrg.y += float(SpawnXY)*sin(Angles.yaw-90.0);
  }
  ShootOrg.x += SpawnZ;

  float ShootAngle = Angles.yaw;
  if (Flags&FPF_AIMATANGLE) ShootAngle += Angle;
  // Temporarily adjusts the pitch
  float SavedPitch = Angles.pitch;
  if (Flags&FPF_NOAUTOAIM) Angles.pitch += Pitch; // `A_FireCustomMissile()` does this another way

  EntityEx AimTarget;
  EntityEx A = SpawnPlayerMissileEx(MissileType, false, AimTarget, ShootAngle, ShootOrg, decal, noAutoAim:!!(Flags&FPF_NOAUTOAIM));
  Angles.pitch = SavedPitch;

  if (A) {
    if (Flags&FPF_TRANSFERTRANSLATION) A.Translation = self.Translation;
    // handle seeker missiles
    if (A.bSeekerMissile) A.Tracer = AimTarget;
    if (!(Flags&FPF_AIMATANGLE)) VectorRotateAroundZ(ref A.Velocity, Angle);
  }
}


//===========================================================================
//
//  A_FireCustomMissile
//
//===========================================================================

final void A_FireCustomMissile (class!Actor MissileType, optional float Angle,
  optional bool UseAmmo, optional int SpawnXY, optional float SpawnZ,
  optional int Flags, optional float Pitch)
{
  Pitch = -Pitch; // this does it this way
  doFireMissileProjectile(MissileType, Angle!optional, UseAmmo!optional, SpawnXY!optional, SpawnZ!optional, Flags!optional, Pitch!optional);
}


//===========================================================================
//
//  A_FireProjectile
//
//===========================================================================
final void A_FireProjectile (class!Actor MissileType, optional float Angle, optional bool UseAmmo, optional int SpawnXY, optional float SpawnZ,
   optional int Flags, optional float Pitch)
{
  doFireMissileProjectile(MissileType, Angle!optional, UseAmmo!optional, SpawnXY!optional, SpawnZ!optional, Flags!optional, Pitch!optional);
}


//===========================================================================
//
//  A_RailAttack
//
//  TODO: process other arguments
//
//===========================================================================
final void A_RailAttack (int RailDamage, optional float Offset,
  optional bool UseAmmo, optional string Colour1, optional string Colour2,
  optional int Flags, optional float MaxDiff, optional class!Actor PuffType,
  optional float spread_xy, optional float spread_z,
  optional float range,
  optional int duration, optional float sparsity, optional float driftspeed, // for particles
  optional class!Actor spawnclass, // for particles
  optional float spawnofs_z, optional int spiraloffset, optional int limit)
{
  if (!specified_UseAmmo) UseAmmo = true;

  if (!bIsPlayer) return;
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;
  if (!Wpn) return;

  if ((specified_Flags && (Flags&1)) || UseAmmo) {
    if (!Wpn.DepleteAmmo(Wpn.FireMode, default, 1)) return;
  }

  int Col1 = ParseColour(Colour1);
  int Col2 = ParseColour(Colour2);
  TVec Dir;
  AngleVector(Angles, out Dir);
  RailAttack(Dir, Offset, RailDamage, Col1, Col2, MaxDiff, PuffType, !!(Flags & 1), !!(Flags & 2),
    distance:range!optional, spawnofs_z:spawnofs_z!optional, pierceLimit:limit!optional);
}


//**************************************************************************
//  Doom weapon atack functions
//**************************************************************************

//===========================================================================
//
//  A_FirePistol
//
//===========================================================================
final void A_FirePistol () {
  TVec dir;
  bool Accurate;

  bool noAAim = false;
  name decal = ''; // default
  if (bIsPlayer) {
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (Wpn) {
      if (!Wpn.DepleteAmmo(Wpn.FireMode, default, 1)) return;
      Player.SetViewObject(Wpn);
      Player.SetViewState(ps_flash, Wpn.FindState('Flash'));
      decal = Wpn.DecalName;
      noAAim = Wpn.IsAutoaimDisabled(); //bNoAutoaim;
      if (!noAAim && !GetCvarB('k8HitscanAutoAim')) noAAim = true;
    }
    if (MeleeState) SetState(MeleeState);
    Accurate = !PlayerEx(Player).Refire;
    //writeln("PISTOL: Accurate=", Accurate, "; refire=", PlayerEx(Player).Refire);
  } else {
    Accurate = true;
  }

  PlaySound('weapons/pistol', CHAN_WEAPON);

  Aim(dir, 16.0*64.0, default, noAAim);
  GunShot(Accurate, dir, 'Bullet', false, decal, (bIsPlayer ? 8192.0 : MISSILERANGE));
}


//===========================================================================
//
//  A_FireShotgun
//
//===========================================================================

final void A_FireShotgun()
{
  int i;
  TVec dir;

  if (!bIsPlayer)
  {
    return;
  }
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;

  PlaySound('weapons/shotgf', CHAN_WEAPON);
  if (MeleeState) SetState(MeleeState);

  bool noAAim = false;
  name decal = ''; // default
  if (Wpn)
  {
    if (!Wpn.DepleteAmmo(Wpn.FireMode, default, 1))
    {
      return;
    }
    Player.SetViewObject(Wpn);
    Player.SetViewState(ps_flash, Wpn.FindState('Flash'));
    decal = Wpn.DecalName;
    noAAim = Wpn.IsAutoaimDisabled(); //bNoAutoaim;
    if (!noAAim && !GetCvarB('k8HitscanAutoAim')) noAAim = true;
  }

  Aim(dir, 16.0 * 64.0, default, noAAim);
  for (i = 0; i < 7; i++)
  {
    GunShot(false, dir, 'Shell', (i != 0), decal, (bIsPlayer ? 8192.0 : MISSILERANGE));
  }
}

//===========================================================================
//
//  A_FireShotgun2
//
//===========================================================================

final void A_FireShotgun2()
{
  int i;
  int damage;
  TAVec rot;
  TVec aimDir;
  TVec dir;

  if (!bIsPlayer)
  {
    return;
  }
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;

  PlaySound('weapons/sshotf', CHAN_WEAPON);
  if (MeleeState) SetState(MeleeState);

  bool noAAim = false;
  name decal = ''; // default
  if (Wpn)
  {
    if (!Wpn.DepleteAmmo(Wpn.FireMode, default, 2))
    {
      return;
    }
    Player.SetViewObject(Wpn);
    Player.SetViewState(ps_flash, Wpn.FindState('Flash'));
    decal = Wpn.DecalName;
    noAAim = Wpn.IsAutoaimDisabled; //bNoAutoaim;
    if (!noAAim && !GetCvarB('k8HitscanAutoAim')) noAAim = true;
  }

  Aim(aimDir, 16.0 * 64.0, default, noAAim);
  for (i = 0; i < 20; i++)
  {
    rot.pitch = (Random() - Random()) * 45.0 / 8.0;
    rot.yaw = (Random() - Random()) * 45.0 / 4.0;
    rot.roll = 0.0;
    dir = RotateDirectionVector(aimDir, rot);
    damage = 5 * (P_Random() % 3 + 1);
    LineAttack(dir, (bIsPlayer ? 8192.0 : MISSILERANGE), damage, BulletPuff, default, default, 'Shell', (i != 0), decal);
  }
}

//===========================================================================
//
//  A_OpenShotgun2
//
//===========================================================================

final void A_OpenShotgun2()
{
  PlaySound('weapons/sshoto', CHAN_WEAPON);
}

//===========================================================================
//
//  A_LoadShotgun2
//
//===========================================================================

final void A_LoadShotgun2()
{
  PlaySound('weapons/sshotl', CHAN_WEAPON);
}

//===========================================================================
//
//  A_CloseShotgun2
//
//===========================================================================

final void A_CloseShotgun2()
{
  PlaySound('weapons/sshotc', CHAN_WEAPON);
  A_ReFire();
}

//===========================================================================
//
//  A_FireCGun
//
//===========================================================================

final void A_FireCGun()
{
  TVec dir;

  if (!bIsPlayer)
  {
    return;
  }
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;

  PlaySound('weapons/chngun', CHAN_WEAPON);

  bool noAAim = false;
  name decal = ''; // default
  if (Wpn)
  {
    if (!Wpn.DepleteAmmo(Wpn.FireMode, default, 1))
    {
      return;
    }
    Player.SetViewObject(Wpn);
    if (Player.ViewStates[ps_weapon].State == Wpn.GetAttackState(false))
    {
      Player.SetViewState(ps_flash, Wpn.FindState('Flash'));
    }
    else
    {
      Player.SetViewState(ps_flash, GetStatePlus(Wpn.FindState('Flash'), 1));
    }
    decal = Wpn.DecalName;
    noAAim = Wpn.IsAutoaimDisabled; //bNoAutoaim;
    if (!noAAim && !GetCvarB('k8HitscanAutoAim')) noAAim = true;
  }

  if (MeleeState) SetState(MeleeState);

  Aim(dir, 16.0 * 64.0, default, noAAim);
  GunShot(!PlayerEx(Player).Refire, dir, 'Bullet', false, decal, (bIsPlayer ? 8192.0 : MISSILERANGE));
}

//===========================================================================
//
//  A_FireMissile
//
//===========================================================================

final void A_FireMissile()
{
  if (!bIsPlayer)
  {
    return;
  }
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;
  name decal = ''; // default
  if (Wpn)
  {
    if (!Wpn.DepleteAmmo(Wpn.FireMode, default, 1))
    {
      return;
    }
    decal = Wpn.DecalName;
  }
  SpawnPlayerMissile(Rocket, decal);
}

//===========================================================================
//
//  A_FirePlasma
//
//===========================================================================

final void A_FirePlasma()
{
  if (!bIsPlayer)
  {
    return;
  }
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;
  name decal = ''; // default
  if (Wpn)
  {
    if (!Wpn.DepleteAmmo(Wpn.FireMode, default, 1))
    {
      return;
    }
    Player.SetViewObject(Wpn);
    if (!(P_Random() & 1))
    {
      Player.SetViewState(ps_flash, Wpn.FindState('Flash'));
    }
    else
    {
      Player.SetViewState(ps_flash, GetStatePlus(Wpn.FindState('Flash'), 1));
    }
    decal = Wpn.DecalName;
  }
  SpawnPlayerMissile(PlasmaBall, decal);
}

//===========================================================================
//
//  DoFireRailgun
//
//===========================================================================

final void DoFireRailgun(float Offset)
{
  if (!bIsPlayer)
  {
    return;
  }
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;
  if (Wpn)
  {
    if (!Wpn.DepleteAmmo(Wpn.FireMode, default, 1))
    {
      return;
    }
    Player.SetViewObject(Wpn);
    if (!(P_Random() & 1))
    {
      Player.SetViewState(ps_flash, Wpn.FindState('Flash'));
    }
    else
    {
      Player.SetViewState(ps_flash, GetStatePlus(Wpn.FindState('Flash'), 1));
    }
  }
  int RailDamage = Level.Game.deathmatch ? 100 : 150;
  TVec Dir;
  AngleVector(Angles, out Dir);
  RailAttack(Dir, Offset, RailDamage);
}

//===========================================================================
//
//  A_FireRailgun
//
//===========================================================================

final void A_FireRailgun()
{
  DoFireRailgun(0.0);
}

//===========================================================================
//
//  A_FireRailgunLeft
//
//===========================================================================

final void A_FireRailgunLeft()
{
  DoFireRailgun(-10.0);
}

//===========================================================================
//
//  A_FireRailgunRight
//
//===========================================================================

final void A_FireRailgunRight()
{
  DoFireRailgun(10.0);
}

//===========================================================================
//
//  A_RailWait
//
//===========================================================================

final void A_RailWait()
{
}

//===========================================================================
//
//  A_BFGsound
//
//===========================================================================

final void A_BFGsound()
{
  PlaySound('weapons/bfgf', CHAN_WEAPON);
}

//===========================================================================
//
//  A_FireBFG
//
//===========================================================================

final void A_FireBFG()
{
  if (!bIsPlayer)
  {
    return;
  }
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;
  name decal = ''; // default
  if (Wpn)
  {
    if (!Wpn.DepleteAmmo(Wpn.FireMode, default, BFG9000.default.AmmoUse1))
    {
      return;
    }
    decal = Wpn.DecalName;
  }
  SpawnPlayerMissile(BFGBall, decal);
}

//**************************************************************************
//
//**************************************************************************

//==========================================================================
//
//  A_RestoreSpecialThing1
//
//  Make a special thing visible again.
//
//==========================================================================

final void A_RestoreSpecialThing1()
{
  bInvisible = false;
  if (DoRespawn())
  {
    PlaySound('misc/spawn', CHAN_VOICE);
  }
}

//==========================================================================
//
//  A_RestoreSpecialThing2
//
//==========================================================================

final void A_RestoreSpecialThing2()
{
  bSpecial = true;
  SetState(IdleState);
}

states
{
  //  Hide pickup like in Doom and Strife.
DormantPickup:
  TNT1 A 1050
  TNT1 A -1
  {
    EntityEx  A;

    bInvisible = false;
    bSpecial = true;
    SetState(IdleState);

    // spawn a teleport fog at the new spot
    A = Spawn(ItemFog, Origin);
    A.PlaySound('misc/spawn', CHAN_ITEM);
  }
  Stop

  //  Hide for 40 secs
HideSpecial:
  ACLO E 1400
  ACLO A 4 A_RestoreSpecialThing1
  ACLO BABCBCDC 4
  ACLO D 4 A_RestoreSpecialThing2
  Stop

  //  Invisible state for held items
Held:
  TNT1 A -1
  Stop

  //  Will destroy item as soon as possible
HoldAndDestroy:
  TNT1 A 1
  Stop
}

defaultproperties
{
  Amount = 1;
  InterHubAmount = 1;
  MaxAmount = 1;
  bSpecial = true;
  PickupMessage = "You got a pickup";
  PickupSound = 'misc/i_pkup';
  UseSound = 'misc/invuse';
  bNoAutoaim = false;
  bIsHitscanWeapon = false;
}
