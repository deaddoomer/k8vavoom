//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//**
//**  Base class for all items that a player can carry.
//**
//**************************************************************************
class Inventory : Actor abstract;

const float BONUSADD = 0.2;
const int DefMaxAmount = -2;

// special values for powerup's blend color
const int INVERSECOLOR = 0x00123456;
const int GOLDCOLOR    = 0x00123457;
const int REDCOLOR     = 0x00123458;
const int GREENCOLOR   = 0x00123459;
const int MONOCOLOR    = 0x0012345A;
const int BEREDCOLOR   = 0x0012345B;

int /*[checkpoint]*/ Amount; // amount of item this instance has
int /*[checkpoint]*/ InterHubAmount; // amount of item that can be kept between hubs or levels
int /*[checkpoint]*/ MaxAmount; // max amount of item this instance can have
string PickupMessage;
float RespawnTime; // tics from pickup time to respawn time
int GiveQuestNum;
name IconName;
float DropTime;
// spawn PickupFlash when picked up
class!Actor PickupFlashType;

name PickupSound;
name UseSound;

bool bBigPowerup; // originally these didn't respawn in deathmatch
bool bFullVolPickupSound; // play pickup sound at full volume
bool bPickupGood; // used by HandlePickup
bool bInvBar; // can be displayed in the inventory bar
bool bKeepDepleted; // keep item in inventory even if amount is 0
bool bUndroppable; // this item cannot be tossed out
bool bIgnoreSkill; // ignore skill level when giving this item
bool bAutoActivate; // automaticly use when picked up
bool bAlwaysPickup; // for auto activate items always pick up the item, even if it wasn't used
bool bHubPower; // keep powerup while travelingbetween levels in a hub
bool bInterHubStrip; // remove when traveling between different clusters
bool bQuiet; // no feedback when picked up
bool bAdditiveTime; // when picked up while it's still active, time is added
bool bCreateCopyMoved; // CreateCopy changed the owner
bool bInitEffectFailed; // powerup failed to activate
bool bTransferInventory; // transfer inventory on pickup

bool bNoAutoaim;
bool bIsHitscanWeapon;
bool bIsCheckpointSaveAllowed = true;


replication {
  reliable if (Role == ROLE_Authority && bNetOwner)
    Amount, MaxAmount;
}


//==========================================================================
//
//  IsCheckpointSaveAllowed
//
//==========================================================================
bool IsCheckpointSaveAllowed () {
  return bIsCheckpointSaveAllowed;
}


//==========================================================================
//
//  QS_Save
//
//==========================================================================
override void QS_Save () {
  QS_PutInt("Amount", Amount);
  QS_PutInt("MaxAmount", MaxAmount);
}


//==========================================================================
//
//  QS_Load
//
//==========================================================================
override void QS_Load () {
  Amount = QS_GetInt("Amount");
  MaxAmount = QS_GetInt("MaxAmount");
}


//==========================================================================
//
//  OnMapSpawn
//
//==========================================================================
override void OnMapSpawn (mthing_t *mthing) {
  if (!mthing) {
    // non-placed items are dropped by default
    bDropped = true;
  }
  if (MaxAmount == DefMaxAmount) MaxAmount = LineSpecialGameInfo(Level.Game).InvDefaultMaxAmount;
  ::OnMapSpawn(mthing);
}


//==========================================================================
//
//  Destroyed
//
//==========================================================================
override void Destroyed () {
  if (Role == ROLE_Authority) {
    if (Owner) {
      //printdebug("%C:%s: inventory dying...", self, self.UniqueId);
      EntityEx(Owner).RemoveInventory(self);
    }
    Inventory = none;
    //printdebug("%C:%s: inventory dead.", self, self.UniqueId);
  }
  ::Destroyed();
}


//==========================================================================
//
//  Tick
//
//==========================================================================
override void Tick (float DeltaTime) {
  ::Tick(DeltaTime);
  if (DropTime) {
    DropTime -= DeltaTime;
    if (DropTime <= 0.0) {
      DropTime = 0.0;
      bSpecial = default.bSpecial;
      bSolid = default.bSolid;
    }
  }
}


//==========================================================================
//
//  IsAutoaimDisabled
//
//==========================================================================
final bool IsAutoaimDisabled () {
  if (bNoAutoaim) return true;
  if (bIsHitscanWeapon && !GetCvarB('k8HitscanAutoAim')) return true;
  return false;
}


//==========================================================================
//
//  BecomeItem
//
//==========================================================================
final void BecomeItem () {
  UnlinkFromWorld();
  bNoSector = true;
  bNoBlockmap = true;
  bIntrJustMoved = false; // disable movement interpolation
  LinkToWorld();
  SetTID(0);
  bSpecial = false;
  SetState(FindState('Held'));
}


//==========================================================================
//
//  BecomePickup
//
//==========================================================================
final void BecomePickup () {
  if (Owner) EntityEx(Owner).RemoveInventory(self);
  UnlinkFromWorld();
  bNoSector = false;
  bNoBlockmap = false;
  bIntrJustMoved = false; // disable movement interpolation
  LinkToWorld(properFloorCheck:true);
  bSpecial = default.bSpecial;
  SetState(IdleState);
}


//==========================================================================
//
//  DestroyInventory
//
//==========================================================================
void DestroyInventory () {
  for (;;) {
    Inventory inv = Inventory;
    if (!inv) break;
    RemoveInventory(inv);
    delete inv;
  }
}


//==========================================================================
//
//  TransferInventoryTo
//
//  used in custom inventory `TryPickup()`
//
//==========================================================================
void TransferInventoryTo (EntityEx NewOwner) {
  if (!NewOwner || NewOwner == self) return;
  if (!Inventory) return;
  //printdebug("*** COPYING INVENTORY FROM `%C` to `%C`", self, NewOwner);
  //DebugDumpInventory();
  for (;;) {
    Inventory inv = Inventory;
    if (!inv) break;
    //printdebug("***   COPYING INVENTORY FROM `%C` to `%C` (inv=%C, inv.Owner=%C)", self, NewOwner, inv, inv.Owner);
    EntityEx(inv.Owner).RemoveInventory(inv);
    NewOwner.AddInventory(inv);
  }
  //printdebug("*** DONE COPYING INVENTORY FROM `%C` to `%C`", self, NewOwner);
}


//==========================================================================
//
//  AttachToOwner
//
//  `oldInv` is used to transfer inventory
//  because this is ususally called on a copy, we need to pass the
//  original item here
//
//==========================================================================
void AttachToOwner (EntityEx NewOwner, optional Inventory oldInv) {
  BecomeItem();
  //bool doDebug = (self !isa 'LDWeaponNameAlternation');
  //if (doDebug) printdebug("%C: AttachToOwner(NewOwner=%C, oldInv=%C; transfer=%B (old=%B))", self, NewOwner, oldInv, bTransferInventory, (oldInv ? oldInv.bTransferInventory : false));
  assert(NewOwner && NewOwner != self);
  // the case of `oldInv == self` is processed by `AddInventory()`
  if (oldInv && oldInv.bTransferInventory && oldInv != self) {
    //if (doDebug) { printdebug("%C:   transferring oldInv inventory...", self); oldInv.DebugDumpInventory(); }
    // add ourselves first, and then all our inventory
    NewOwner.AddInventory(self);
    oldInv.TransferInventoryTo(NewOwner);
  } else {
    NewOwner.AddInventory(self);
  }
  //if (doDebug) printdebug("%C: AttachToOwner(NewOwner=%C, oldInv=%C): COMPLETE", self, NewOwner, oldInv);
  /* old code; most of this is now processed in `AddInventory()`
  if (oldInv) {
    assert(NewOwner != oldInv);
    assert(Inventory == none);
    NewOwner.AddInventory(self);
    if (oldInv.bTransferInventory) oldInv.TransferInventoryTo(NewOwner);
  } else {
    if (bTransferInventory) {
      //HACK!
      Inventory savedinv = Inventory;
      Inventory = none;
      NewOwner.AddInventory(self);
      Inventory = savedinv;
      TransferInventoryTo(NewOwner);
    } else {
      DestroyInventory();
      NewOwner.AddInventory(self);
    }
  }
  */
}


//==========================================================================
//
//  DetachedFromOwner
//
//  Event called when item is being removed from Owner's inventory.
//
//==========================================================================
void DetachedFromOwner () {
}


//==========================================================================
//
//  TouchSpecial
//
//==========================================================================
override void TouchSpecial (EntityEx Toucher, optional bool noflash) {
  if (!Toucher.bPickUp) return; // can't be picked up by toucher
  if (Toucher.Health <= 0) return; // toucher is dead

  // make sure that if it's a voodoo doll touching item it's given to the actual player actor
  if (Toucher.bIsPlayer) Toucher = EntityEx(Toucher.Player.MO);

  if (!TryPickup(Toucher)) return;

  if (!bQuiet && (!specified_noflash || !noflash)) {
    if (Toucher.bIsPlayer) Toucher.Player.cprint("%s", GetPickupMessage());
    PlayPickupSound(Toucher);
    if (Toucher.bIsPlayer) PlayerEx(Toucher.Player).BonusFlash += BONUSADD;
  }

  DoPickupSpecial(Toucher);
  if (bCountItem) {
    if (Toucher.bIsPlayer) ++Toucher.Player.ItemCount;
    ++Level.CurrentItems;
  }
}


//==========================================================================
//
//  TryPickup
//
//==========================================================================
bool TryPickup (EntityEx Toucher) {
  //bool doDebug = (self !isa 'LDWeaponNameAlternation');
  //if (doDebug) printwarn("%C: TryPickup: new owner `%C`; bTransferInventory=%B)", self, Toucher, bTransferInventory);

  EntityEx NewToucher = Toucher;
  bPickupGood = false;
  if (Toucher.Inventory && Toucher.Inventory.HandlePickup(self)) {
    if (!bPickupGood) return false;
    if (bTransferInventory) TransferInventoryTo(Toucher);
    GoAwayAndDie();
  } else if (MaxAmount == 0) {
    // a special case: items with max amount of 0 can be picked up if they are autoactivate-able
    if (!bAutoActivate) return false;

    // put it in the inventory long enough to be used
    Toucher.AddInventory(self);
    bool UseGood = Use(true);
    Toucher.RemoveInventory(self);

    if (UseGood || bAlwaysPickup) {
      GoAwayAndDie();
    } else {
      return false;
    }
  } else {
    Inventory Copy = CreateCopy(Toucher);
    if (!Copy) return false;
    if (!Inventory(Copy)) {
      printwarn("Inventory::CreateCopy(%C): failed to properly copy `%C`!", self, Copy);
      delete Copy;
      return false;
    } else {
      // some powerups cannot activate absolutely, for example, PowerMorph; fail the pickup if so
      if (Copy.bInitEffectFailed) {
        if (Copy != self) {
          Copy.Destroy();
        } else {
          bInitEffectFailed = false;
        }
        return false;
      }
      // handle owner-changing powerups
      if (Copy.bCreateCopyMoved) {
        NewToucher = EntityEx(Copy.Owner);
        Copy.Owner = none;
        Copy.bCreateCopyMoved = false;
      }
      //if (doDebug) printdebug("%C: TryPickup: attaching copy `%C` to the new owner `%C` (same:%B; bTransferInventory=%B)", self, Copy, NewToucher, (Copy == self), self.bTransferInventory);
      Copy.AttachToOwner(NewToucher, self);
      if (bAutoActivate && Copy.Use(true)) {
        --Copy.Amount;
        if (Copy.Amount <= 0) {
          Copy.bSpecial = false;
          Copy.SetState(Copy.FindState('HoldAndDestroy'));
        }
      }
    }
  }
  GiveQuest(Toucher);
  return true;
}


//==========================================================================
//
//  HandlePickup
//
//  Called for each item in touchers inventory. Returns true if pickup
//  should be interrupted. Sets bPickupGood to true if pickup should be
//  considered successful.
//
//==========================================================================
bool HandlePickup (Inventory Item) {
  if (Item.Class == Class) {
    // ammo has its own handler, so just use `MaxAmount` here
    int maxam = MaxAmount;
    if (Amount < maxam) {
      Amount = min(Amount+max(0, Item.Amount), maxam);
      Item.bPickupGood = true;
    }
    return true;
  }

  if (Inventory) return Inventory.HandlePickup(Item);
  return false;
}


//==========================================================================
//
//  CreateCopy
//
//==========================================================================
Inventory CreateCopy (EntityEx Toucher) {
  Inventory Copy;
  if (GoAway()) {
    // must create a copy
    Copy = SpawnEntityChecked(class!Inventory, class!Inventory(Class), Origin, Angles, default, AllowReplace:false);
    assert(Copy);
    Copy.Amount = Amount;
    Copy.MaxAmount = MaxAmount;
    // copy "transfer inventory" flag, in case the item will be dropped, and
    // will get some inventory, and then picked up again (some pickups can do this)
    Copy.bTransferInventory = bTransferInventory;
  } else {
    // use this one
    Copy = self;
  }
  return Copy;
}


//==========================================================================
//
//  CreateTossable
//
//  Create item suitable for dropping.
//
//==========================================================================
Inventory CreateTossable (optional int DropAmount) {
  if (!IdleState) return none; // this item has no spawn state so it cannot be seen

  if (!specified_DropAmount || DropAmount < 0) DropAmount = 1; // drop one by default

  if (bUndroppable || !Owner || Amount <= 0 || DropAmount == 0) return none;

  if (Amount <= DropAmount && !bKeepDepleted) {
    // drop the current one
    BecomePickup();
    DropTime = 1.0;
    bSpecial = false;
    bSolid = false;
    return self;
  }

  // create copy to drop
  Inventory Copy = SpawnEntityChecked(class!Inventory, class!Inventory(Class), default, default, default, AllowReplace:false);
  assert(Copy);
  Copy.Amount = clamp(DropAmount, 1, Amount);
  Copy.MaxAmount = MaxAmount;
  Copy.DropTime = 1.0;
  Copy.bSpecial = false;
  Copy.bSolid = false;
  Amount -= Copy.Amount;
  return Copy;
}


//==========================================================================
//
//  ShouldStay
//
//  Returns true if item should stay after it's been picked up.
//
//==========================================================================
bool ShouldStay () {
  return false;
}


//==========================================================================
//
//  ShouldRespawn
//
//==========================================================================
bool ShouldRespawn () {
  if (bBigPowerup && !LineSpecialGameInfo(Level.Game).bRespawnBigItems) return false;
  return LineSpecialGameInfo(Level.Game).bRespawnItems;
}


//==========================================================================
//
//  GoAway
//
//==========================================================================
final bool GoAway () {
  // never respawn dropped items
  if (bDropped) {
    if (PickupFlashType) {
      // initiate the artifact pickup animation
      Spawn(PickupFlashType, Origin);
    }
    return false;
  }

  if (!ShouldStay()) {
    if (PickupFlashType) Spawn(PickupFlashType, Origin); // initiate the artifact pickup animation
    if (ShouldRespawn()) {
      Hide();
    } else {
      // don't respawn
      return false;
    }
  }

  return true;
}


//==========================================================================
//
//  GoAwayAndDie
//
//==========================================================================
final void GoAwayAndDie () {
  if (!GoAway()) {
    bSpecial = false;
    SetState(FindState('HoldAndDestroy'));
  }
}


//==========================================================================
//
//  Hide
//
//==========================================================================
final void Hide () {
  bSpecial = false;
  bInvisible = true;
  if (LineSpecialGameInfo(Level.Game).bRavenStylePickupRespawn) {
    SetState(FindState('HideSpecial'));
    StateTime = 40.0;
    if (PickupFlashType) StateTime += 30.0/35.0;
  } else {
    SetState(FindState('DormantPickup'));
    StateTime = 30.0;
  }
  if (RespawnTime) StateTime = RespawnTime;
}


//==========================================================================
//
//  GetPickupMessage
//
//==========================================================================
string GetPickupMessage () {
  return PickupMessage;
}


//==========================================================================
//
//  DoPickupSpecial
//
//==========================================================================
void DoPickupSpecial (EntityEx Toucher) {
  if (Special) {
    Level.ExecuteActionSpecial(Special, Args[0], Args[1], Args[2], Args[3], Args[4], nullptr, 0, Toucher);
    Special = 0;
  }
}


//==========================================================================
//
//  PlayPickupSound
//
//==========================================================================
void PlayPickupSound (EntityEx Toucher) {
  if (PickupSound) {
    Toucher.PlaySound(PickupSound, /*CHAN_BODY*/CHAN_AUTO, 1.0, (bFullVolPickupSound ? ATTN_NONE : ATTN_NORMAL));
  }
}


//==========================================================================
//
//  GiveQuest
//
//==========================================================================
final void GiveQuest (EntityEx Toucher) {
  if (GiveQuestNum) {
    Toucher.GiveInventoryType(class!Inventory(FindClass(name(va("QuestItem%d", GiveQuestNum)))));
  }
}


//==========================================================================
//
//  DoRespawn
//
//==========================================================================
/*
override bool DoRespawn () {
  return true;
}
*/


//==========================================================================
//
//  SpecialDropAction
//
//==========================================================================
bool SpecialDropAction (EntityEx Source) {
  return false;
}


//==========================================================================
//
//  PrevInv
//
//  Return previous item with bInvBar flag set
//
//==========================================================================
Inventory PrevInv () {
  Inventory Item = Inventory;
  while (Item && !Item.bInvBar) Item = Item.Inventory;
  return Item;
}


//==========================================================================
//
//  NextInv
//
//  Return next item with bInvBar flag set
//
//==========================================================================
Inventory NextInv () {
  Inventory Ret = none;
  Inventory Item = EntityEx(Owner).Inventory;
  while (Item && Item != self) {
    if (Item.bInvBar) Ret = Item;
    Item = Item.Inventory;
  }
  return Ret;
}


//==========================================================================
//
//  Use
//
//==========================================================================
bool Use (bool Pickup) {
  return false;
}


//==========================================================================
//
//  DoEffect
//
//==========================================================================
void DoEffect () {
}


//==========================================================================
//
//  GetBlend
//
//==========================================================================
int GetBlend () {
  return 0;
}


//==========================================================================
//
//  AbsorbDamage
//
//  absorb damage taken
//
//==========================================================================
void AbsorbDamage (EntityEx inflictor, int damage, name DmgType, ref int NewDamage) {
  if (Inventory) {
    Inventory.AbsorbDamage(inflictor, damage, DmgType, NewDamage);
  }
}


//==========================================================================
//
//  AmplifyDamage
//
//  amplify damage dealt
//
//==========================================================================
void AmplifyDamage (EntityEx target, int damage, name DmgType, ref int NewDamage) {
  if (Inventory) {
    Inventory.AmplifyDamage(target, damage, DmgType, NewDamage);
  }
}


//==========================================================================
//
//  OwnerDied
//
//==========================================================================
void OwnerDied () {
}


//==========================================================================
//
//  GetSpeedFactor
//
//==========================================================================
float GetSpeedFactor () {
  return (Inventory ? Inventory.GetSpeedFactor() : 1.0);
}
