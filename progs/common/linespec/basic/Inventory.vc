//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//**
//**  Base class for all items that a player can carry.
//**
//**************************************************************************
class Inventory : Actor abstract;

const float BONUSADD = 0.2;
const int DefMaxAmount = -2;

// special values for powerup's blend colour
const int INVERSECOLOUR = 0x00123456;
const int GOLDCOLOUR    = 0x00123457;
const int REDCOLOUR     = 0x00123458;
const int GREENCOLOUR   = 0x00123459;

int /*[checkpoint]*/ Amount; // amount of item this instance has
int /*[checkpoint]*/ InterHubAmount; // amount of item that can be kept between hubs or levels
int /*[checkpoint]*/ MaxAmount; // max amount of item this instance can have
string PickupMessage;
float RespawnTime; // tics from pickup time to respawn time
int GiveQuestNum;
name IconName;
float DropTime;
// spawn PickupFlash when picked up
class!Actor PickupFlashType;

name PickupSound;
name UseSound;

bool bBigPowerup; // originally these didn't respawn in deathmatch
bool bFullVolPickupSound; // play pickup sound at full volume
bool bPickupGood; // used by HandlePickup
bool bInvBar; // can be displayed in the inventory bar
bool bKeepDepleted; // keep item in inventory even if amount is 0
bool bUndroppable; // this item cannot be tossed out
bool bIgnoreSkill; // ignore skill level when giving this item
bool bAutoActivate; // automaticly use when picked up
bool bAlwaysPickup; // for auto activate items always pick up the item, even if it wasn't used
bool bHubPower; // keep powerup while travelingbetween levels in a hub
bool bInterHubStrip; // remove when traveling between different clusters
bool bQuiet; // no feedback when picked up
bool bAdditiveTime; // when picked up while it's still active, time is added
bool bCreateCopyMoved; // CreateCopy changed the owner
bool bInitEffectFailed; // powerup failed to activate

bool bNoAutoaim;
bool bIsHitscanWeapon;
bool bIsCheckpointSaveAllowed = true;


replication {
  reliable if (Role == ROLE_Authority && bNetOwner)
    Amount, MaxAmount;
}


enum /*EFireCustomMissileFlags*/ {
  FPF_AIMATANGLE = 1,
  FPF_TRANSFERTRANSLATION = 2,
  FPF_NOAUTOAIM = 4,
};

// for `A_Saw`
const int SF_NORANDOM = 1;
const int SF_RANDOMLIGHTMISS = 2;
const int SF_RANDOMLIGHTHIT = 4;
const int SF_RANDOMLIGHTBOTH = 6;
const int SF_NOUSEAMMOMISS = 8;
const int SF_NOUSEAMMO = 16;
const int SF_NOPULLIN = 32; // not implemented
const int SF_NOTURN = 64;
const int SF_STEALARMOR = 128; // not implemented


//==========================================================================
//
//  IsCheckpointSaveAllowed
//
//==========================================================================
bool IsCheckpointSaveAllowed () {
  return bIsCheckpointSaveAllowed;
}


//==========================================================================
//
//  QS_Save
//
//==========================================================================
override void QS_Save () {
  QS_PutInt("Amount", Amount);
  QS_PutInt("MaxAmount", MaxAmount);
}


//==========================================================================
//
//  QS_Load
//
//==========================================================================
override void QS_Load () {
  Amount = QS_GetInt("Amount");
  MaxAmount = QS_GetInt("MaxAmount");
}


//==========================================================================
//
//  OnMapSpawn
//
//==========================================================================
override void OnMapSpawn (mthing_t *mthing) {
  if (!mthing) {
    // non-placed items are dropped by default
    bDropped = true;
  }
  if (MaxAmount == DefMaxAmount) MaxAmount = LineSpecialGameInfo(Level.Game).InvDefaultMaxAmount;
  ::OnMapSpawn(mthing);
}


//==========================================================================
//
//  Destroyed
//
//==========================================================================
override void Destroyed () {
  if (Role == ROLE_Authority) {
    if (Owner) EntityEx(Owner).RemoveInventory(self);
    Inventory = none;
  }
  ::Destroyed();
}


//==========================================================================
//
//  Tick
//
//==========================================================================
override void Tick (float DeltaTime) {
  ::Tick(DeltaTime);
  if (DropTime) {
    DropTime -= DeltaTime;
    if (DropTime <= 0.0) {
      DropTime = 0.0;
      bSpecial = default.bSpecial;
      bSolid = default.bSolid;
    }
  }
}


//==========================================================================
//
//  IsAutoaimDisabled
//
//==========================================================================
final bool IsAutoaimDisabled () {
  if (bNoAutoaim) return true;
  if (bIsHitscanWeapon && !GetCvarB('k8HitscanAutoAim')) return true;
  return false;
}


//==========================================================================
//
//  BecomeItem
//
//==========================================================================
final void BecomeItem () {
  UnlinkFromWorld();
  bNoSector = true;
  bNoBlockmap = true;
  LinkToWorld();
  SetTID(0);
  bSpecial = false;
  SetState(FindState('Held'));
}


//==========================================================================
//
//  BecomePickup
//
//==========================================================================
final void BecomePickup () {
  if (Owner) EntityEx(Owner).RemoveInventory(self);
  UnlinkFromWorld();
  bNoSector = false;
  bNoBlockmap = false;
  LinkToWorld();
  bSpecial = default.bSpecial;
  SetState(IdleState);
}


//==========================================================================
//
//  AttachToOwner
//
//==========================================================================
void AttachToOwner (EntityEx NewOwner) {
  BecomeItem();
  NewOwner.AddInventory(self);
}


//==========================================================================
//
//  DetachedFromOwner
//
//  Event called when item is being removed from Owner's inventory.
//
//==========================================================================
void DetachedFromOwner () {
}


//==========================================================================
//
//  TouchSpecial
//
//==========================================================================
override void TouchSpecial (EntityEx Toucher, optional bool noflash) {
  if (!Toucher.bPickUp) return; // can't be picked up by toucher
  if (Toucher.Health <= 0) return; // toucher is dead

  // make sure that if it's a voodoo doll touching item it's given to the actual player actor
  if (Toucher.bIsPlayer) Toucher = EntityEx(Toucher.Player.MO);

  if (!TryPickup(Toucher)) return;

  if (!bQuiet && (!specified_noflash || !noflash)) {
    if (Toucher.bIsPlayer) Toucher.Player.cprint("%s", GetPickupMessage());
    PlayPickupSound(Toucher);
    if (Toucher.bIsPlayer) PlayerEx(Toucher.Player).BonusFlash += BONUSADD;
  }

  DoPickupSpecial(Toucher);
  if (bCountItem) {
    if (Toucher.bIsPlayer) ++Toucher.Player.ItemCount;
    ++Level.CurrentItems;
  }
}


//==========================================================================
//
//  TryPickup
//
//==========================================================================
bool TryPickup (EntityEx Toucher) {
  EntityEx NewToucher = Toucher;
  bPickupGood = false;
  if (Toucher.Inventory && Toucher.Inventory.HandlePickup(self)) {
    if (!bPickupGood) return false;
    GoAwayAndDie();
  } else if (MaxAmount == 0) {
    // a special case: items with max amount of 0 can be picked up if they are autoactivate-able
    if (!bAutoActivate) return false;

    // put it in the inventory long enoung to be used
    Toucher.AddInventory(self);
    bool UseGood = Use(true);
    Toucher.RemoveInventory(self);

    if (UseGood || bAlwaysPickup) {
      GoAwayAndDie();
    } else {
      return false;
    }
  } else {
    Inventory Copy = CreateCopy(Toucher);
    if (!Copy) return false;
    // some powerups cannot activate absolutely, for example, PowerMorph; fail the pickup if so
    if (Copy.bInitEffectFailed) {
      if (Copy != self) {
        Copy.Destroy();
      } else {
        bInitEffectFailed = false;
      }
      return false;
    }
    // handle owner-changing powerups
    if (Copy.bCreateCopyMoved) {
      NewToucher = EntityEx(Copy.Owner);
      Copy.Owner = none;
      Copy.bCreateCopyMoved = false;
    }
    Copy.AttachToOwner(NewToucher);
    if (bAutoActivate && Copy.Use(true)) {
      --Copy.Amount;
      if (Copy.Amount <= 0) {
        Copy.bSpecial = false;
        Copy.SetState(Copy.FindState('HoldAndDestroy'));
      }
    }
  }
  GiveQuest(Toucher);
  return true;
}


//==========================================================================
//
//  HandlePickup
//
//  Called for each item in touchers inventory. Returns true if pickup
//  should be interrupted. Sets bPickupGood to true if pickup should be
//  considered successful.
//
//==========================================================================
bool HandlePickup (Inventory Item) {
  if (Item.Class == Class) {
    if (Amount < MaxAmount) {
      Amount += Item.Amount;
      if (Amount > MaxAmount) Amount = MaxAmount;
      Item.bPickupGood = true;
    }
    return true;
  }

  if (Inventory) return Inventory.HandlePickup(Item);
  return false;
}


//==========================================================================
//
//  CreateCopy
//
//==========================================================================
Inventory CreateCopy (EntityEx Toucher) {
  Inventory Copy;
  if (GoAway()) {
    // must create a copy
    Copy = Spawn(class!Inventory(Class), default, default, default, false);
    Copy.Amount = Amount;
    Copy.MaxAmount = MaxAmount;
  } else {
    // use this one
    Copy = self;
  }
  return Copy;
}


//==========================================================================
//
//  CreateTossable
//
//  Create item suitable fro dropping.
//
//==========================================================================
Inventory CreateTossable () {
  if (!IdleState) return none; // this item has no spawn state so it cannot be seen
  if (bUndroppable || !Owner || Amount <= 0) return none;

  if (Amount == 1 && !bKeepDepleted) {
    // drop the current one
    BecomePickup();
    DropTime = 1.0;
    bSpecial = false;
    bSolid = false;
    return self;
  }

  Inventory Copy = Spawn(class!Inventory(Class), default, default, default, false);
  Copy.Amount = 1;
  Copy.MaxAmount = MaxAmount;
  Copy.DropTime = 1.0;
  Copy.bSpecial = false;
  Copy.bSolid = false;
  --Amount;
  return Copy;
}


//==========================================================================
//
//  ShouldStay
//
//  Returns true if item should stay after it's been picked up.
//
//==========================================================================
bool ShouldStay () {
  return false;
}


//==========================================================================
//
//  ShouldRespawn
//
//==========================================================================
bool ShouldRespawn () {
  if (bBigPowerup && !LineSpecialGameInfo(Level.Game).bRespawnBigItems) return false;
  return LineSpecialGameInfo(Level.Game).bRespawnItems;
}


//==========================================================================
//
//  GoAway
//
//==========================================================================
final bool GoAway () {
  // never respawn dropped items
  if (bDropped) {
    if (PickupFlashType) {
      // initiate the artifact pickup animation
      Spawn(PickupFlashType, Origin);
    }
    return false;
  }

  if (!ShouldStay()) {
    if (PickupFlashType) Spawn(PickupFlashType, Origin); // initiate the artifact pickup animation
    if (ShouldRespawn()) {
      Hide();
    } else {
      // don't respawn
      return false;
    }
  }
  return true;
}


//==========================================================================
//
//  GoAwayAndDie
//
//==========================================================================
final void GoAwayAndDie () {
  if (!GoAway()) {
    bSpecial = false;
    SetState(FindState('HoldAndDestroy'));
  }
}


//==========================================================================
//
//  Hide
//
//==========================================================================
final void Hide () {
  bSpecial = false;
  bInvisible = true;
  if (LineSpecialGameInfo(Level.Game).bRavenStylePickupRespawn) {
    SetState(FindState('HideSpecial'));
    StateTime = 40.0;
    if (PickupFlashType) StateTime += 30.0/35.0;
  } else {
    SetState(FindState('DormantPickup'));
    StateTime = 30.0;
  }
  if (RespawnTime) StateTime = RespawnTime;
}


//==========================================================================
//
//  GetPickupMessage
//
//==========================================================================
string GetPickupMessage () {
  return PickupMessage;
}


//==========================================================================
//
//  DoPickupSpecial
//
//==========================================================================
void DoPickupSpecial (EntityEx Toucher) {
  if (Special) {
    Level.ExecuteActionSpecial(Special, Args[0], Args[1], Args[2], Args[3], Args[4], nullptr, 0, Toucher);
    Special = 0;
  }
}


//==========================================================================
//
//  PlayPickupSound
//
//==========================================================================
void PlayPickupSound (EntityEx Toucher) {
  if (PickupSound) {
    Toucher.PlaySound(PickupSound, /*CHAN_BODY*/CHAN_AUTO, 1.0, (bFullVolPickupSound ? ATTN_NONE : ATTN_NORMAL));
  }
}


//==========================================================================
//
//  GiveQuest
//
//==========================================================================
final void GiveQuest (EntityEx Toucher) {
  if (GiveQuestNum) {
    Toucher.GiveInventoryType(class!Inventory(FindClass(name(va("QuestItem%d", GiveQuestNum)))));
  }
}


//==========================================================================
//
//  DoRespawn
//
//==========================================================================
bool DoRespawn () {
  return true;
}


//==========================================================================
//
//  SpecialDropAction
//
//==========================================================================
bool SpecialDropAction (EntityEx Source) {
  return false;
}


//==========================================================================
//
//  PrevInv
//
//  Return previous item with bInvBar flag set
//
//==========================================================================
Inventory PrevInv () {
  Inventory Item = Inventory;
  while (Item && !Item.bInvBar) Item = Item.Inventory;
  return Item;
}


//==========================================================================
//
//  NextInv
//
//  Return next item with bInvBar flag set
//
//==========================================================================
Inventory NextInv () {
  Inventory Ret = none;
  Inventory Item = EntityEx(Owner).Inventory;
  while (Item && Item != self) {
    if (Item.bInvBar) Ret = Item;
    Item = Item.Inventory;
  }
  return Ret;
}


//==========================================================================
//
//  Use
//
//==========================================================================
bool Use (bool Pickup) {
  return false;
}


//==========================================================================
//
//  DoEffect
//
//==========================================================================
void DoEffect () {
}


//==========================================================================
//
//  GetBlend
//
//==========================================================================
int GetBlend () {
  return 0;
}


//==========================================================================
//
//  AbsorbDamage
//
//==========================================================================
void AbsorbDamage (int damage, name DmgType, ref int NewDamage) {
  if (Inventory) {
    Inventory.AbsorbDamage(damage, DmgType, NewDamage);
  }
}


//==========================================================================
//
//  OwnerDied
//
//==========================================================================
void OwnerDied () {
}


//==========================================================================
//
//  GetSpeedFactor
//
//==========================================================================
float GetSpeedFactor () {
  return (Inventory ? Inventory.GetSpeedFactor() : 1.0);
}
