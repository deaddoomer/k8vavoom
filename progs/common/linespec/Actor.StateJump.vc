//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

//**************************************************************************
//  State jumps
//**************************************************************************

//==========================================================================
//
//  A_Jump
//
//==========================================================================

final void A_Jump(int Chance, state Label1, optional state Label2,
  optional state Label3, optional state Label4, optional state Label5,
  optional state Label6, optional state Label7, optional state Label8,
  optional state Label9, optional state Label10, optional state Label11,
  optional state Label12, optional state Label13, optional state Label14,
  optional state Label15, optional state Label16)
{
  if (P_Random() < Chance) {
    if (!specified_Label2) {
      DoJump(Label1);
    } else {
      array!state List;
      List[0] = Label1;
      List[1] = Label2;
      if (specified_Label3) List[$] = Label3;
      if (specified_Label4) List[$] = Label4;
      if (specified_Label5) List[$] = Label5;
      if (specified_Label6) List[$] = Label6;
      if (specified_Label7) List[$] = Label7;
      if (specified_Label8) List[$] = Label8;
      if (specified_Label9) List[$] = Label9;
      if (specified_Label10) List[$] = Label10;
      if (specified_Label11) List[$] = Label11;
      if (specified_Label12) List[$] = Label12;
      if (specified_Label13) List[$] = Label13;
      if (specified_Label14) List[$] = Label14;
      if (specified_Label15) List[$] = Label15;
      if (specified_Label16) List[$] = Label16;
      DoJump(List[P_Random()%List.Num]);
    }
  }

  //  State jumps should not affect state chain results.
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
}

//==========================================================================
//
//  A_JumpIf
//
//==========================================================================

final void A_JumpIf(bool Expr, state Label)
{
  if (Expr)
  {
    DoJump(Label);
  }

  //  State jumps should not affect state chain results.
  if (XLevel.StateCall)
  {
    XLevel.StateCall->Result = false;
  }
}

//==========================================================================
//
//  A_JumpIfCloser
//
//==========================================================================

final void A_JumpIfCloser(float Dist, state Label)
{
  EntityEx Targ;

  if (!bIsPlayer)
  {
    Targ = Target;
  }
  else
  {
    TVec Dir;
    Targ = Aim(Dir, 16.0 * 64.0);
  }

  if (Targ && DistTo2(Targ) < Dist && ((Origin.z > Targ.Origin.z &&
    Origin.z - Target.Origin.z - Target.Height < Dist) ||
    (Origin.z <= Targ.Origin.z &&
    Target.Origin.z - Origin.z - Height < Dist)))
  {
    DoJump(Label);
  }

  //  State jumps should not affect state chain results.
  if (XLevel.StateCall)
  {
    XLevel.StateCall->Result = false;
  }
}

//==========================================================================
//
//  A_JumpIfHealthLower
//
//==========================================================================

final void A_JumpIfHealthLower(int HealthVal, state Label)
{
  if (Health < HealthVal)
  {
    DoJump(Label);
  }

  //  State jumps should not affect state chain results.
  if (XLevel.StateCall)
  {
    XLevel.StateCall->Result = false;
  }
}

//==========================================================================
//
//  A_JumpIfInventory
//
//==========================================================================

final void A_JumpIfInventory(class!Actor ItemType, int Amount, state Label)
{
  if (ItemType)
  {
    Inventory Item = FindInventory(class!Inventory(ItemType));
    if (Item)
    {
      if ((Amount > 0 && Item.Amount >= Amount) ||
        (Amount == 0 && Item.Amount >= Item.MaxAmount))
      {
        DoJump(Label);
      }
    }
  }

  //  State jumps should not affect state chain results.
  if (XLevel.StateCall)
  {
    XLevel.StateCall->Result = false;
  }
}

//==========================================================================
//
//  A_JumpIfInTargetInventory
//
//==========================================================================

final void A_JumpIfInTargetInventory(class!Actor ItemType, int Amount, state Label)
{
  if (ItemType && Target)
  {
    Inventory Item = Target.FindInventory(class!Inventory(ItemType));
    if (Item)
    {
      if ((Amount > 0 && Item.Amount >= Amount) ||
        (Amount == 0 && Item.Amount >= Item.MaxAmount))
      {
        DoJump(Label);
      }
    }
  }

  //  State jumps should not affect state chain results.
  if (XLevel.StateCall)
  {
    XLevel.StateCall->Result = false;
  }
}

//==========================================================================
//
//  A_JumpIfTargetInLOS
//
//==========================================================================

final void A_JumpIfTargetInLOS(state Label, optional float Fov)
{
  //  State jumps should not affect state chain results.
  if (XLevel.StateCall)
  {
    XLevel.StateCall->Result = false;
  }

  EntityEx Targ;
  if (!bIsPlayer)
  {
    Targ = Target;
    if (!Targ || !CanSee(Targ))
    {
      return;
    }
    if (Fov && Fov < 360.0)
    {
      float Ang = AngleMod180(atan2(Targ.Origin.y - Origin.y,
        Targ.Origin.x - Origin.x) - Angles.yaw);
      if (fabs(Ang) > Fov / 2.0)
      {
        return;
      }
    }
  }
  else
  {
    TVec Dir;
    Targ = Aim(Dir, 16.0 * 64.0);
  }

  if (Targ)
  {
    DoJump(Label);
  }
}

//==========================================================================
//
//  A_JumpIfCVarTrue
//
//==========================================================================

final void A_JumpIfCVarTrue (string cvar, state Label) {
  name cvn = StrToName(cvar);
  if (CvarExists(cvn)) {
    if (GetCvarB(cvn)) DoJump(Label);
  }
  // State jumps should not affect state chain results.
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
}

//==========================================================================
//
//  A_JumpIfCVarFalse
//
//==========================================================================

final void A_JumpIfCVarFalse (string cvar, state Label) {
  name cvn = name(cvar);
  if (CvarExists(cvn)) {
    //print("A_JumpIfCVarFalse: cvar is '%s', value is %s", cvar, (GetCvarB(cvn) ? "true" : "false"));
    if (!GetCvarB(cvn)) DoJump(Label);
  } else {
    //print("A_JumpIfCVarFalse: cvar '%s' NOT FOUND!", cvar);
    DoJump(Label);
  }
  // State jumps should not affect state chain results.
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
}
