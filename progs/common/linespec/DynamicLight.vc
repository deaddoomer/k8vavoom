//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class DynamicLight : Actor;

enum {
  DLTYPE_Point,
  DLTYPE_MuzzleFlash,
  DLTYPE_Pulse,
  DLTYPE_Flicker,
  DLTYPE_FlickerRandom,
  DLTYPE_Sector,
  DLTYPE_Subtractive, // not supported yet
  DLTYPE_SectorSubtractive, // not supported yet
};

ubyte LightType;
float LightTime;
float Intensity;


//==========================================================================
//
//  OnMapSpawn
//
//==========================================================================
override void OnMapSpawn (mthing_t *mthing) {
  ::OnMapSpawn(mthing);

  //TODO: replace with statics
  if (LightType == DLTYPE_Subtractive) {
    //bDormant = true;
    //print("*** SUBTRACTIVE: r=%d; g=%d; b=%d; Args[3]=%d; Args[4]=%d", Args[0], Args[1], Args[2], Args[3], Args[4]);
    if (RGB(Args[0], Args[1], Args[2]) == 0) {
      dprint("*** DUMMY SUBTRACTIVE: r=%d; g=%d; b=%d; Args[3]=%d; Args[4]=%d", Args[0], Args[1], Args[2], Args[3], Args[4]);
      Destroy();
    }
    return;
  }

  // use static light for placed point lights that cannot be deactivated
  if (LightType == DLTYPE_Point && mthing && !TID && !bDormant) {
    //dprint("*** adding static light for class '%n'", GetClassName(Class));
    if (mthing->arg1 == 255 && mthing->arg2 == 255 && mthing->arg3) {
      Level.AddStaticLight(Origin, StaticIntensityToRadius(float(mthing->arg4)));
    } else {
      Level.AddStaticLightRGB(Origin,
        StaticIntensityToRadius(float(mthing->arg4)),
        RGB(mthing->arg1, mthing->arg2, mthing->arg3));
    }
    Destroy();
  } else if (LightType == DLTYPE_Sector && mthing && !TID && Level.XLevel.bConvertSectorLightsToStatic && Sector) {
    // hack for Discharge map set
    float Scale = float(Args[3])*0.125;
    if (!Scale) Scale = 1.0;
    Intensity = float(Sector->params.lightlevel)*Scale;
    if (Intensity < 0.0) Intensity = 0.0;
    if (Intensity > 255.0) Intensity = 255.0;
    //print("*** FORCED static light for class '%C' (lt=%s; TID=%s; dormant=%B, mthing is %shere); RGB=(%s,%s,%s); scale=%s; intensity=%s", Class, LightType, TID, bDormant, (mthing ? "" : "not "), Args[0], Args[1], Args[2], Scale, Intensity);
    Level.AddStaticLightRGB(Origin, IntensityToRadius(Intensity), RGB(Args[0], Args[1], Args[2]));
    /*
    if (Args[0] == 255 && Args[1] == 255 && Args[2]) {
      Level.AddStaticLight(Origin, StaticIntensityToRadius(float(mthing->arg4)));
    } else {
      Level.AddStaticLightRGB(Origin,
        StaticIntensityToRadius(float(mthing->arg4)),
        RGB(mthing->arg1, mthing->arg2, mthing->arg3));
    }
    */
    Destroy();
  } else {
    //dprint("*** CANNOT add static light for class '%C' (lt=%s; TID=%s; dormant=%B, mthing is %shere)", Class, LightType, TID, bDormant, (mthing ? "" : "not "));
  }
}


//==========================================================================
//
//  BeginPlay
//
//==========================================================================
override void BeginPlay () {
  ::BeginPlay();
  if (!bDormant) Activate(none);
}


//==========================================================================
//
//  Activate
//
//==========================================================================
override bool Activate (EntityEx Activator) {
  bDormant = false;
  LightTime = 0.0;
  Intensity = float(Args[3]);
  return true;
}


//==========================================================================
//
//  Deactivate
//
//==========================================================================
override bool Deactivate (EntityEx Activator) {
  bDormant = true;
  return true;
}


//==========================================================================
//
//  ClientTick
//
//==========================================================================
override void ClientTick (float DeltaTime) {
  ::ClientTick(DeltaTime);

  if (bDormant) return;

  int realLightType = LightType;

  switch (LightType) {
    case DLTYPE_Point:
      Intensity = float(Args[3]);
      break;
    case DLTYPE_Pulse:
      {
        // avoid division by 0
        float PulseCycle = (Angles.yaw ? Angles.yaw/35.0 : 1.0/35.0);
        LightTime += DeltaTime;
        if (LightTime >= PulseCycle) LightTime = 0.0;
        float Frac = (1.0+sin(360.0*LightTime/PulseCycle))*0.5;
        Intensity = float(Args[3])+Frac*float(Args[4]-Args[3]);
      }
      break;
    case DLTYPE_Flicker:
      Intensity = float(Random() >= Angles.yaw/360.0 ? Args[4] : Args[3]);
      break;
    case DLTYPE_FlickerRandom:
      LightTime += DeltaTime;
      if (LightTime > Angles.yaw/35.0) {
        LightTime = 0.0;
        Intensity = float(Args[3])+Random()*float(Args[4]-Args[3]);
      }
      break;
    case DLTYPE_Sector:
      {
        float Scale = float(Args[3])*0.125;
        if (!Scale) Scale = 1.0;
        Intensity = float(Sector->params.lightlevel)*Scale;
        if (Intensity < 0.0) Intensity = 0.0;
        if (Intensity > 255.0) Intensity = 255.0;
      }
      break;
    case DLTYPE_SectorSubtractive:
      {
        float Scale = float(Args[3])*0.125;
        if (!Scale) Scale = 1.0;
        Intensity = float(Sector->params.lightlevel)*Scale;
        if (Intensity < 0.0) Intensity = 0.0;
        if (Intensity > 255.0) Intensity = 255.0;
        realLightType = DLTYPE_Subtractive;
      }
      break;
    case DLTYPE_Subtractive:
      Intensity = float(Args[3]);
      //if (RGB(Args[0], Args[1], Args[2]) == 0) return;
      break;
  }

  dlight_t *dl = AllocDlight(self, Origin, IntensityToRadius(Intensity));
  if (dl) {
    //dl->origin = Origin;
    dl->colour = RGB(Args[0], Args[1], Args[2]);
    //dl->radius = IntensityToRadius(Intensity);
    dl->die = XLevel.Time+0.01;
    dl->type = /*LightType*/realLightType;
  }
}


//==========================================================================
//
//  StaticIntensityToRadius
//
//==========================================================================
final float StaticIntensityToRadius (float Val) {
  if (Val <= 20.0) return Val*3.5;
  if (Val <= 30.0) return Val*3.0;
  if (Val <= 40.0) return Val*2.8;
  if (Val <= 60.0) return Val*2.4;
  return Val*2.0;
}


//==========================================================================
//
//  IntensityToRadius
//
//==========================================================================
final float IntensityToRadius (float Val) {
  if (Val <= 20.0) return Val*4.5;
  if (Val <= 30.0) return Val*3.6;
  if (Val <= 40.0) return Val*3.3;
  if (Val <= 60.0) return Val*2.8;
  return Val*2.5;
}


defaultproperties {
  Height = 0.0;
  Radius = 0.1;
  bNoBlockmap = true;
  bInvisible = true;
  bNoGravity = true;
}
