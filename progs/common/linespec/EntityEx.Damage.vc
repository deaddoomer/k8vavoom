//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

final static name k8GetBloodClassName (name newblood, name oldblood) {
  if (FindClass(newblood)) return newblood;
  return oldblood;
}


//==========================================================================
//
// K8onBeforeLineDamage
//
// this script will be called before hitscan line damage is done
// you can return new damage, or <= 0 to prevent any hitscan damage.
// note that poisoned puffs will still inflict damage to victim.
// also note that preventing victim from taking any damage will not
// "awake" it.
//
//==========================================================================

final int K8onBeforeLineDamage (EntityEx inflictor, TVec hitpos, int damage, name damageType, bool secondary) {
  // is it from player?
  if (!inflictor) return damage;
  if (!inflictor.bIsPlayer) return damage;

  if (damageType != 'Bullet' &&
      damageType != 'Shell' &&
      damageType != 'BDW_Bullet' &&
      damageType != 'BDW_Shell'
     )
  {
    return damage;
  }

  if (!GetCvarB('k8HSEnabled')) return damage;

  /*bool*/auto debugme = GetCvarB('k8HSDEBUG');

  if (debugme) print("ME: %s; inf: %s", NameToStr(GetClassName(self.Class)), NameToStr(GetClassName(GetClassReplacee(inflictor.Class))));

  PlayerPawn plr = PlayerPawn(inflictor);

  /*
  sector_t ss;
  auto atest = &ss;
  */
  /*
  print("goo");
  auto a = booboo();
  print("zoo");
  */

  //if (k8CheckBoolCVar('k8HSShowKnownDamage', debugme)) print("K8HS: damage type '%s', damage=%d", damageType, damage);

  bool fastkills = GetCvarB('k8HSFastKillAnnoyingMonsters');

  int fastdamage = 0;

  int vicHealth = Health; // current health
  int vicSpHealth = InitialHealth; // spawning health (i.e. full health for monsters)

  if (debugme) print("vicSpHealth=%d; vicHealth=%d", vicSpHealth, vicHealth);

  if (vicSpHealth < 1 || vicHealth < 1) return damage; // something is very wrong with this monster!

  //int vicMass = Mass;
  float vicRadius = Radius;
  float vicHgt = Height;

  // kill certain monsters in one shot
  if (fastkills) {
    if (GetClassName(GetClassReplacee(self.Class)) == 'PainElemental') {
      if (GetCvarB('k8HSInstaKillPainElementals')) fastdamage = vicHealth+10;
    } else if (GetClassName(GetClassReplacee(self.Class)) == 'LostSoul') {
      if (GetCvarB('k8HSInstaKillLostSouls')) fastdamage = vicHealth+10;
      fastdamage = vicHealth+10;
    }
    if (fastdamage > 0) return fastdamage;
  }

  float hithgt = hitpos.z; //-Pos.z;
  float fromtop = vicHgt-hithgt;
  if (debugme) print("  hithgt=%f; fromtop=%f", hithgt, fromtop);

  bool headshot = false;
  bool showHeadshots = false;
  if (debugme) showHeadshots = GetCvarB('k8HSShowHeadshots');

  if (vicHgt <= 56.0) {
    // humans, archvile, cacodemon, demon, imp, lost soul, pain elemental, revenant
    headshot = (fromtop <= 14.0);
    if (headshot && showHeadshots) print("HS56: TAN");
  } else if (vicHgt <= 64.0) {
    // arachnotron(64)
    // bruiser(64)
    if (GetClassName(GetClassReplacee(self.Class)) == 'Arachnotron') {
      headshot = (fromtop <= 18.0);
      if (debugme) print("*******ARACHNO!");
    } else {
      headshot = (fromtop <= 15.0);
    }
    if (headshot && showHeadshots) print("HS64: TAN");
  } else {
    // cyberdemon(110)
    // mastermind(100)
    // keen(72)
    headshot = (fromtop <= 20.0);
    if (headshot && showHeadshots) print("HSBIG: TAN");
  }

  // calc distance
  float mult = GetCvarF('k8HSDistMult');
  if (mult < 0.1) mult = 1.1;
  if (mult > 4) mult = 4;

  float len = 10000;
  if (headshot) {
    //len = Distance2D(inflictor)*mult;
    len = sqrt((self.Origin.x-inflictor.Origin.x)*(self.Origin.x-inflictor.Origin.x)+(self.Origin.y-inflictor.Origin.y)*(self.Origin.y-inflictor.Origin.y));
    // 600: E1M1, from entry to top of the stairs
    if (debugme) print("K8HS: len=%f; multlen=%f", len, len*mult);
    len *= mult;
  }

  // head shot
  if (headshot) {
    if (showHeadshots) {
      //Log(s:"K8HS: Headshot! ", s:vicName, s:"; vicHgt=", d:vicHgt, s:"; fromtop=", d:fromtop, s:"; mass=", d:vicMass, s:"; radius=", d:vicRadius, s:"; len=", d:len);
      print("K8HS: Headshot! %s; vicHgt=%f; fromtop=%f; radius=%f; len=%f", NameToStr(GetClassName(Class)), vicHgt, fromtop, vicRadius, len);
    }
    bool debugCrits = false;
    if (debugme) debugCrits = GetCvarB('k8HSDebugCrits');
    int dodmg = damage; //*2 baron of hell and other Big Things
    int smallHealth = 50; // baron of hell and other Big Things
    int critChance = int(Random()*100);

    //TODO: int tick = gametic;
    //int tick = k8hsLastHitTick+1;

    if (debugme) print("K8HS: len=%f; critChance=%d; hscount=%d", len, critChance, plr.k8hsCount);
    // shotgun, etc -- multiple hitscans per one tick?
    if (secondary) {
      // very rarely, shotgun can do double criticals
      ++plr.k8hsCount;
      if (plr.k8hsCount == 1) {
        // first hitscan
      } else if (plr.k8hsCount == 2) {
        // second hitscan; 1.25 damage sometimes
        critChance = 1;
        if (Random()*100.0 > 75.0) {
          dodmg += dodmg/4;
          if (debugCrits) print("*Critx1.25 (2); d=%d", dodmg);
        }
      } else {
        // third and other hitscans; 1.25 damage sometimes
        critChance = 1;
        if (Random()*100.0 > 80) {
          dodmg += dodmg/4;
          if (debugCrits) print("*Critx1.25 (3); d=%d", dodmg);
        }
      }
    } else {
      plr.k8hsCount = 0;
    }

    if (critChance > 13 && !GetCvarB('k8HSCriticals')) critChance = 13;

    int oldcc = critChance;
         if (len > 800) { if (critChance >= 75 && Random()*100 > 10) critChance = 13; }
    else if (len > 400) { if (critChance >= 75 && Random()*100 > 40) critChance = 13; }
    else if (len > 300) { if (critChance >= 75 && Random()*100 > 50) critChance = 13; }
    else if (len > 200) { if (critChance >= 75 && Random()*100 > 70) critChance = 13; }
    else if (len < 90) {
           if (plr.k8hsCount <= 2) critChance += 42;
      else if (plr.k8hsCount >= 8) critChance += 10;
      else critChance += (8-plr.k8hsCount)*9;
    }
    if (debugme) print("oldcc=%d; critChance=%d; len=%f", oldcc, critChance, len);

    // create message
    bool showMessage = false;
    string messageText = "";
    int messageColor = CR_YELLOW;

    if (critChance >= 95) {
      dodmg *= 10;
      if (debugCrits) print("*Critx10; d=%d", dodmg);
      messageText = "CRITICAL x10!";
      messageColor = CR_YELLOW;
      showMessage = true;
    } else if (critChance >= 85) {
      dodmg *= 7;
      if (debugCrits) print("*Critx7; d=%d", dodmg);
      messageText = "CRITICAL x7!";
      messageColor = CR_ORANGE;
      showMessage = true;
    } else if (critChance >= 75) {
      dodmg *= 3;
      if (debugCrits) print("*Critx3; d=%d", dodmg);
      messageText = "CRITICAL x3!";
      messageColor = CR_RED;
      showMessage = true;
    } else if (critChance >= 55) {
      dodmg *= 2;
      if (debugCrits) print("*Critx2; d=%d", dodmg);
      messageText = "CRITICAL x2!";
      messageColor = CR_RED;
      //showMessage = true;
    } else if (critChance > 10) {
      dodmg += dodmg/2; // *1.5
      if (debugCrits) print("*Critx1.5; d=%d", dodmg);
      messageText = "CRITICAL x1.5!";
      messageColor = CR_RED;
      //showMessage = true;
    }

    if (debugCrits) print("  critChance=%d; damage=%d; dodmg=%d", critChance, damage, dodmg);

    if (vicSpHealth < 100) {
      // humans, imps, ...
      //dodmg = (damage <= 10 ? damage*4 : damage*3);
      smallHealth = vicSpHealth/10;
    } else if (vicSpHealth < 1000) {
      // demons, cacodemons, ...
      //dodmg = (damage <= 10 ? damage*3 : damage*2);
      smallHealth = vicSpHealth/10;
      if (smallHealth < 12) smallHealth = 12;
    }

    if (dodmg) {
      if (showMessage && GetCvarB('k8HSShowCriticals')) {
        inflictor.Player.ClientHudMessage(messageText, 'smallfont', 0, 123666, messageColor, "",
          0.5, 0.45, 0, 0,
          1.5, 0.0, 0.0);
        /*
        native void ClientHudMessage(string Message, name Font, int Type, int Id,
          int Colour, string ColourName, float x, float y, int HudWidth,
          int HudHeight, float HoldTime, float Time1, float Time2);
        */
      }

      if (fastkills) {
        if (GetClassName(GetClassReplacee(self.Class)) == 'Archvile') {
          fastdamage = GetCvar('k8HSFastKillArchVileDamage');
          if (fastdamage > 0 && dodmg < fastdamage) {
            //Log(s:"Archvile superdamage: old=", d:dodmg, s:"; new=", d:fastdamage, s:"; health=", d:vicHealth);
            dodmg = fastdamage;
          }
        }
      }
      // if we will left victim with very small health, kill it instead
      bool instakill = false;
      if (vicHealth-dodmg <= smallHealth) dodmg = vicHealth;
      int xdmg = dodmg;
      if (vicHealth <= dodmg) {
        // instakill, gore (fe, 'cause +1)
        instakill = true;
        dodmg = Health+5;
        if (debugCrits) print("  INSTAKILL");
      }
      // preventing normal damage will prevent monster alerting too, heh

      // ketchup spawn
      if (instakill) {
        bool doSpray = !bNoBlood && GetCvarB('k8HSHeadKillBloodSpray');

        if (doSpray) {
          bool poolType2 = (P_Random() >= 0x80);
          name bloodClassName = k8GetBloodClassName('K8Gore_BloodTransient', 'Blood');
          name poolClassName = k8GetBloodClassName((poolType2 ? 'K8Gore_GrowingBloodPool2' : 'K8Gore_GrowingBloodPool'), '');
          //writeln("bloodtype: ", GetClassName(self.BloodType), "; ", GetClassName(GetClassReplacee(self.BloodType)));

          if (self.BloodType && GetClassName(GetClassReplacee(self.BloodType)) == 'BloodGreen') {
            bloodClassName = k8GetBloodClassName('K8Gore_BloodTransient_Green', bloodClassName);
            //mistClassName = 'K8Gore_BloodmistBigTransientGreen';
            poolClassName = k8GetBloodClassName((poolType2 ? 'K8Gore_GrowingBloodPool2_Green' : 'K8Gore_GrowingBloodPool_Green'), poolClassName);
          } else if (self.BloodType && GetClassName(GetClassReplacee(self.BloodType)) == 'BloodBlue') {
            bloodClassName = k8GetBloodClassName('K8Gore_BloodTransient_Blue', bloodClassName);
            //mistClassName = 'K8Gore_BloodmistBigTransientBlue';
            poolClassName = k8GetBloodClassName((poolType2 ? 'K8Gore_GrowingBloodPool2_Blue' : 'K8Gore_GrowingBloodPool_Blue'), poolClassName);
          }

          //writeln("  bloodclass: ", bloodClassName);

          class!Actor bloodClass = class!Actor(FindClass(bloodClassName));

          if (bloodClass) {
            int bcc = int(GetCvarF('k8HSHeadKillBloodCount'));
            if (bcc > 0) {
              bcc += int(Random()*13-6); // -6..6
              if (bcc < 8) bcc = 8;
              if (bcc > 64) bcc = 64;
            }

            TVec spos;
            for (; bcc > 0; --bcc) {
              spos.x = Origin.x+((Random()*51-25)/10.0);
              spos.y = Origin.y+((Random()*51-25)/10.0);
              spos.z = Origin.z+Height+((Random()*29-14)/10.0);
              Level.Spawn(bloodClass, spos); // optional TAVec AAngles, optional mthing_t *mthing, optional bool AllowReplace
            }
          }

          if (GetCvarB('k8HSHeadKillBloodPool')) {
            //poolClassName = 'SmallBloodPool';
            class!Actor poolClass = class!Actor(FindClass(poolClassName));
            if (poolClass) {
              //print("***SPAWNING BLOOD POOL: '%n'", GetClassName(poolClass));
              Level.Spawn(poolClass, Origin);
            }
          }

          //class!Actor mistClass = mistClassName;
          //if (mistClass) Spawn(mistClass, Pos);
        }

        Health = 1;
        dodmg = 2;
      }

      return dodmg;
    }
  }

  return damage;
}


//==========================================================================
//
//  Damage
//
//  Damages both enemies and players.
//  "inflictor" is the thing that caused the damage, creature or missile,
// can be nullptr (slime, etc).
//  "source" is the thing to target after taking damage, creature or nullptr.
//  Source and inflictor are the same for melee attacks. Source can be nullptr
// for slime, barrel explosions and other environmental stuff.
//
//==========================================================================

void DamageEx (EntityEx inflictor, EntityEx source, int damage, name DmgType, bool NoArmor, TVec hitp, bool secondary) {
  int newdmg = K8onBeforeLineDamage(inflictor, hitp, damage, DmgType, secondary);
  //print("THP(%s):(%f,%f,%f); dmg=%d; new=%d; type='%s'", (secondary ? "2" : "1"), hitp.x, hitp.y, hitp.z, damage, newdmg, NameToStr(DmgType));
  //print("THP:(%f,%f,%f); dmg=%d; type='%s'", hitp.x, hitp.y, hitp.z, damage, NameToStr(StrToName("FUCK!")));
  Damage(inflictor, source, /*damage*/newdmg, DmgType, NoArmor);
}

final void Damage(EntityEx inflictor, EntityEx source, int damage,
  optional name DmgType, optional bool NoArmor)
{
  int i;

  if (!bShootable)
  {
    // shouldn't happen...
    return;
  }

  if (DmgType == 'None' || DmgType == 'none') {
    //print("DAMAGE TYPE: NONE");
    DmgType = '';
  }
  //if (!DmgType) DmgType = 'None';

  if (Health <= 0)
  {
    if (inflictor && DmgType == 'Ice')
    {
      return;
    }
    else if (bIceCorpse)  // frozen
    {
      StateTime = 0.1;
      Velocity.x = 0.0;
      Velocity.y = 0.0;
    }
    return;
  }

  if (bInvulnerable && damage < 10000)
  {
    // Actor is invulnerable
    if (bIsPlayer)
    {
      if (LineSpecialGameInfo(Level.Game).bNoDamageThrustInvulnerable)
      {
        // For player, no exceptions
        return;
      }
    }
    else if (!inflictor || !inflictor.bDamageInvulnerable)
    {
      return;
    }
  }

  if (inflictor && inflictor.bPierceArmor)
  {
    NoArmor = true;
  }

  //  Spectral targets only take damage from spectral projectiles.
  if (bSpectral)
  {
    if (!inflictor || !inflictor.bSpectral)
    {
      if (MissileState)
      {
        SetState(MissileState);
      }
      return;
    }
  }

  //  Andy Baker's Stealth monsters
  if (bStealth)
  {
    Alpha = 1.0;
    VisDir = -1;
  }

  if (bSkullFly)
  {
    if (bSkullFlyInvulnerable)
    {
      // Invulnerable during charge attack
      return;
    }
    bSkullFly = false;
    Velocity = vector(0.0, 0.0, 0.0);
    if (Health > 0)
    {
      SetState(SeeState);
    }
  }

  if (bDormant)
  {
    // Invulnerable, and won't wake up
    return;
  }

  if (bIsPlayer)
  {
    // Take half damage in trainer mode
    damage = ftoi(itof(damage) * Level.World.SkillDamageFactor);
  }

  // Special damage types
  if (inflictor)
  {
    damage = inflictor.DoSpecialDamage(self, source, damage);
    if (damage == -1)
    {
      return;
    }
  }

  if (DmgType == 'SpectralLow' && bLowSpectralResist)
  {
    damage = 0;
  }

  if (DmgType == 'Fire' && bFireResist)
  {
    damage >>= 1;
  }
  else
  {
    for (i = 0; i < DamageFactors.Num; i++)
    {
      if (DamageFactors[i].DamageType == DmgType ||
          (!DmgType && (DamageFactors[i].DamageType == 'None' || DamageFactors[i].DamageType == 'none')))
      {
        damage = ftoi(itof(damage) * DamageFactors[i].Factor);
        if (damage <= 0)
        {
          return;
        }
        break;
      }
    }
  }

  damage = TakeSpecialDamage(inflictor, source, damage, DmgType);
  if (damage == -1)
  {
    return;
  }

  //  Push the target unless using a weapon that should not inflict
  // thrust
  if (inflictor && inflictor != self && bColideWithThings &&
    !inflictor.bNoDamageThrust)
  {
    float kickback;
    if (bIsPlayer && !GetCvar('damage_thrust'))
    {
      kickback = 0.0;
    }
    else if (!source || !source.bIsPlayer)
    {
      kickback = LineSpecialGameInfo(Level.Game).DefaultKickBack;
    }
    else
    {
      kickback = PlayerEx(source.Player).ReadyWeapon.Kickback;
    }
    if (kickback)
    {
      TVec dir;
      float thrust;

      thrust = kickback / 8.0 * itof(damage) / Mass;
      if (thrust < 0.0 || thrust > 10.0)
      {
        thrust = 10.0;
      }
      // make fall forwards sometimes
      if ((damage < 40) && (damage > Health)
         && (Origin.z - inflictor.Origin.z > 64.0)
         && (P_Random() & 1)
         // [RH] But only if not too fast and not flying
         && thrust < 10.0
         && !(bNoGravity))
      {
        Angles.yaw += 180.0;
        thrust *= 4.0;
      }
      dir = GetCentre() - inflictor.GetCentre();
      if (Length(dir) < 0.001)
      {
        //  Zero length. In this case Doom would use angle 0
        dir = vector(1.0, 0.0, 0.0);
      }
      if (source && source.bIsPlayer && (source == inflictor) &&
        PlayerEx(source.Player).ReadyWeapon.bStaff2Kickback)
      {
        // Staff power level 2
        dir.z = 0.0;
        Velocity += 35.0 * 10.0 * Normalise(dir);
        Velocity.z += 35.0 * 5.0;
      }
      else
      {
        Velocity += 35.0 * thrust * Normalise(dir);
      }
    }
  }

  // player specific
  if (bIsPlayer)
  {
    if (PlayerEx(Player).CheckFriendlyFire(source, damage))
    {
      return;
    }

    //  End of game hell hack.
    if ((Sector->special & SECSPEC_BASE_MASK) ==
      SECSPEC_DamageSuperHellslimeExit && damage >= Health)
    {
      damage = Health - 1;
    }

    // Below certain threshold, ignore damage in GOD mode, or with INVUL power.
    if (damage < 1000 && (bInvulnerable ||
      (PlayerEx(Player).Cheats & PlayerEx::CF_GODMODE)))
    {
      return;
    }

    if (!NoArmor && Inventory)
    {
      int NewDmg = damage;
      Inventory.AbsorbDamage(damage, DmgType, NewDmg);
      damage = NewDmg;
      if (damage <= 0)
      {
        return;
      }
    }

    if (damage >= Health && (Level.World.bSkillAutoUseHealth ||
      Level.Game.deathmatch) && !PlayerEx(Player).MorphTime)
    {
      // Try to use some inventory health
      AutoUseHealth(damage - Health + 1);
    }

    if (Player.Health - damage < 50 && !Level.Game.deathmatch)
    {
      // Try to use some inventory health
      AutoUseStrifeHealth(damage - Health + 1);
    }
    Player.Health -= damage;  // mirror mobj health here for Dave
    if (Player.Health < 0)
    {
      Player.Health = 0;
    }
    if (Player.Health < 1 && (PlayerEx(Player).Cheats & PlayerEx::CF_BUDDHA)) Player.Health = 1;
    PlayerEx(Player).Attacker = source;
    PlayerEx(Player).DamageFlash += itof(damage) / 35.0;  // add damage after armor / invuln
    if (PlayerEx(Player).DamageFlash > 3.0)
    {
      PlayerEx(Player).DamageFlash = 3.0; // teleport stomp does 10k points...
    }

    // For Korax Arena
    PlayerEx(Player).Damaged(inflictor);
  }

  // do the damage
  Health -= damage;
  if (bIsPlayer && Health < 1 && (PlayerEx(Player).Cheats & PlayerEx::CF_BUDDHA)) Health = 1;
  if (Health <= 0)
  {
    // Death
    Special1 = damage;
    // check for special fire damage or ice damage deaths
    if (DmgType == 'Fire')
    {
      if (bIsPlayer && !PlayerEx(Player).MorphTime)
      {
        // Check for flame death
        if (!inflictor || !inflictor.bConditionalFireDamage ||
          (Health > -50 && damage > 25))
        {
          DamageType = 'Fire';
        }
      }
      else
      {
        DamageType = 'Fire';
      }
    }
    else
    {
      DamageType = DmgType;
    }
    if (source && source.IsServant())
    {
      // Minotaur's kills go to his master
      EntityEx master = source.Tracer;
      // Make sure still alive and not a pointer to fighter head
      if (master && master.bIsPlayer && (master.Player.MO == master))
      {
        source = master;
      }
    }
    Died(source, inflictor);
    return;
  }

  state WoundState = FindState('Wound', DmgType, false);
  if (Health <= WoundHealth && WoundState)
  {
    SetState(WoundState);
    return;
  }

  float PChance = PainChance;
  for (i = 0; i < PainChances.Num; i++)
  {
    if (PainChances[i].DamageType == DmgType ||
        (!DmgType && (PainChances[i].DamageType == 'None' || PainChances[i].DamageType == 'none')))
    {
      PChance = PainChances[i].Chance;
      break;
    }
  }

  if (!bNoPain && ((Random() < PChance) && !bSkullFly))
  {
    if (inflictor && inflictor.bLightning)
    {
      if ((P_Random() < 96 && !inflictor.bPainless) ||
          inflictor.bForcePain)
      {
        bJustHit = true;  // fight back!
        if (FindState('Pain', DmgType, false))
        {
          SetState(FindState('Pain', DmgType, false));
        }
      }
      else
      {
        // "electrocute" the target
        bFullBright = true;
        if (HowlSound && bMonster && P_Random() < 128 &&
          !GetSoundPlayingInfo(self, GetSoundID(HowlSound)))
        {
          PlaySound(HowlSound, CHAN_VOICE);
        }
      }
    }
    else
    {
      bJustHit = true;  // fight back!
      if (!inflictor || (inflictor && (!inflictor.bPainless ||
          inflictor.bForcePain)))
      {
        if (FindState('Pain', DmgType, false))
        {
          SetState(FindState('Pain', DmgType, false));
        }
      }
      if (inflictor && inflictor.bHowlVictims)
      {
        if (HowlSound && bMonster && P_Random() < 128 &&
          !GetSoundPlayingInfo(self, GetSoundID(HowlSound)))
        {
          PlaySound(HowlSound, CHAN_VOICE);
        }
      }
    }
  }

  ReactionCount = 0;  // we're awake now...

  if (source)
  {
    if (source == Target)
    {
      Threshold = BASETHRESHOLD;
      if (State == IdleState && SeeState)
      {
        SetState(SeeState);
      }
    }
    else if (OkayToSwitchTarget(source))
    {
      // Target actor is not intent on another actor,
      // so make him chase after source

      // killough 2/15/98: remember last enemy, to prevent
      // sleeping early; 2/21/98: Place priority on players

      if (!LastEnemy || (!LastEnemy.bIsPlayer && !TIDToHate) ||
        LastEnemy.Health <= 0)
      {
        LastEnemy = Target; // remember last enemy - killough
      }
      Target = source;
      Threshold = BASETHRESHOLD;
      if (State == IdleState && SeeState)
      {
        SetState(SeeState);
      }
    }
  }
}

//==========================================================================
//
//  DoSpecialDamage
//
//==========================================================================

int DoSpecialDamage(EntityEx victim, EntityEx source, int damage)
{
  if (victim.bIsPlayer && MissilePoisonDamage > 0)
  {
    victim.PoisonPlayer(source, MissilePoisonDamage);
    damage >>= 1;
  }
  return damage;
}

//==========================================================================
//
//  TakeSpecialDamage
//
//==========================================================================

int TakeSpecialDamage(EntityEx inflictor, EntityEx source, int damage,
  name DmgType)
{
  if (bNoDamage)
  {
    return 0;
  }

  //  Always apply damage if actor has regular death state or no death
  // states at all.
  if (FindState('Death') || !HasSpecialStates('Death'))
  {
    return damage;
  }
  //  If there's no corresponding death state, actor takes no damage at
  // all.
  if (DmgType == 'Ice')
  {
    if (FindState('Death', 'Ice', true))
    {
      return damage;
    }
    if ((bIsPlayer || bMonster) && !bNoIceDeath)
    {
      return damage;
    }
    return -1;
  }
  else
  {
    return FindState('Death', DmgType) ? damage : -1;
  }
}

//==========================================================================
//
//  OkayToSwitchTarget
//
//==========================================================================

bool OkayToSwitchTarget(EntityEx source)
{
  if (source == self)
  {
    //  Don't hate self.
    return false;
  }
  if (!source.bShootable)
  {
    //  Don't hate actors that cannot be hurt.
    return false;
  }
  if (bNoTargetSwitch && Target)
  {
    return false;
  }
  if ((Master && source.IsA(GetClassName(Master.Class))) ||   // don't attack your master (or others of its type)
    (source.Master && IsA(GetClassName(source.Master.Class))))  // don't attack your minion (or those of others of your type)
  {
    if (!IsHostile(source) &&               // allow target switch if other is considered hostile
      (source.TID != TIDToHate || TIDToHate == 0) &&    // or has the tid we hate
      source.TIDToHate == TIDToHate)            // or has different hate information
    {
      return false;
    }
  }
  if (source.bNeverTarget && (source.TID != TIDToHate || TIDToHate == 0) &&
    !IsHostile(source))
  {
    return false;
  }
  if (Threshold && !bNoGrudge)
  {
    return false;
  }
  if (IsFriend(source))
  {
    //  Don't hate friends.
    return false;
  }

  int Inf = GetInfighting();
  if (Inf < 0 && !source.bIsPlayer && !IsHostile(source))
  {
    //  Infighting is off, so don't target it if it's not hostile.
    return false;
  }

  if (TIDToHate && TIDToHate == source.TIDToHate)
  {
    //  Don't target actors that hate the same thing.
    return false;
  }
  if (source.bIsPlayer && bNoHatePlayers)
  {
    return false;
  }
  if (Target && Target.Health > 0 && TIDToHate &&
    Target.TID == TIDToHate && Random() < 0.5 && CanSee(Target))
  {
    //  Don't be too quick to give up things we hate
    return false;
  }
  return true;
}

//==========================================================================
//
//  Died
//
//==========================================================================

void Died(EntityEx source, EntityEx inflictor)
{
  Inventory Item;

  //  Calculate gibs health
  int GHealth = GibsHealth;
  if (!GHealth)
  {
    GHealth = ftoi(itof(-default.Health) *
      LineSpecialGameInfo(Level.Game).GibsHealthFactor);
  }

  //  Handle possible unmorph on death
  bool WasGibbed = Health < GHealth;
  EntityEx RealSelf = none;
  int RealStyle = 0;
  int RealHealth = 0;
  if (MorphedDeath(RealSelf, RealStyle, RealHealth))
  {
    if (!(RealStyle & MORPH_UNDOBYDEATHSAVES))
    {
      if (WasGibbed)
      {
        int RealGibHealth = RealSelf.GibsHealth;
        if (!RealGibHealth)
        {
          RealGibHealth = ftoi(itof(-RealSelf.default.Health) *
            LineSpecialGameInfo(Level.Game).GibsHealthFactor);
        }
        if (RealSelf.Health >= RealGibHealth)
        {
          //  If morphed was gibbed, so must original be (where allowed)
          RealSelf.Health = RealGibHealth -1;
        }
      }
      RealSelf.Died(source, inflictor);
    }
    return;
  }

  //  Notify actor's items.
  for (Item = Inventory; Item;)
  {
    Inventory Next = Item.Inventory;
    Item.OwnerDied();
    Item = Next;
  }

  if (source)
  {
    //  Set Target to the thing that killed it. It's needed for Strife's
    // special dropped items.
    Target = source;
  }

  if (inflictor && inflictor.bNoExtremeDeath)
  {
    //  Prevent gibing animation.
    Health = -1;
  }

  if (source && (source.bIsPlayer) &&
    PlayerEx(source.Player).IsWeaponAlwaysExtremeDeath())
  {
    // Always extreme death.
    Health = -5000;
  }

  if (bIsPlayer && Level.bDeathSlideShow)
  {
    //  Start sad finale.
    PlayerEx(Player).StartDeathSlideShow();
  }

  bShootable = false;
  bFloat = false;
  bSkullFly = false;
  if (!bNoGravKill)
  {
    bNoGravity = false;
  }
  bDropOff = true;
  bCorpse = true;
  bPassMobj = false;

  float NewHeight = 0.0;
  if (DamageType == 'Fire')
  {
    NewHeight = BurnHeight;
  }
  if (!NewHeight)
  {
    NewHeight = DeathHeight;
  }
  if (NewHeight < 0.0)
  {
    Height = 0.0;
  }
  else if (NewHeight)
  {
    Height = NewHeight;
  }
  else
  {
    Height /= 4.0;
  }

  if (Special && (!bSpecial || bMonster))
  {
    // Initiate monster death actions
    Level.ExecuteActionSpecial(Special, Args[0], Args[1], Args[2],
      Args[3], Args[4], nullptr, 0, Level.bActivateOwnSpecial ? self :
      source);
  }
  if (CountsAsKill())
  {
    Level.CurrentKills++;
  }
  if (source && source.bIsPlayer)
  {
    if (CountsAsKill())
    {
      // count for intermission
      source.Player.KillCount++;
    }
    PlayerEx(source.Player).KilledActor(self);
  }
  else if (!Level.Game.netgame && CountsAsKill())
  {
    // Count all monster deaths,
    // even those caused by other monsters
    Level.Game.Players[0].KillCount++;
  }

  if (bIsPlayer)
  {
    //  Display obituary.
    PlayerEx(Player).DisplayObituary(inflictor, source, DamageType);

    XLevel.StartTypedACScripts(Level::SCRIPT_Death, 0, 0, 0, self, true,
      false);

    PlayerEx(Player).Deaths++;

    // Count environment kills against you
    if (!source)
    {
      Player.Frags--;
    }

    PlayerEx(Player).Killed(source, inflictor);

    bSolid = false;
    bFly = false;
    Player.PlayerState = PST_DEAD;
    PlayerEx(Player).DropWeapon();
#ifdef FIXME
    if (Player == Level.Game.Players[consoleplayer] && automapactive)
    {
      // Don't die in auto map, switch view prior to dying
      AM_Stop();
    }
#endif
  }

  state DeathState = none;
  if (DamageType)
  {
    // Specialised death state for this damage type (ice, etc).
    DeathState = FindState('Death', DamageType, true);
    if (DamageType == 'Ice' && !bNoIceDeath && (bIsPlayer || bMonster))
    {
      if (FindState('Death', 'Ice', true))
      {
        DeathState = FindState('Death', 'Ice', true);
      }
      else
      {
        DeathState = FindState('GenericFreezeDeath');
      }
    }
  }
  if (!DeathState)
  {
    //  Don't pass damage type unless it's a massacre damage.
    if (DamageType != 'Massacre')
    {
      DamageType = '';
    }

    if (Health < GHealth)
    {
      // Extreme death
      DeathState = FindState('Death', 'Extreme', true);
    }
    if (!DeathState)
    {
      // Normal death
      DeathState = FindState('Death');
    }
  }

  if (DeathState)
  {
    SetState(DeathState);
    StateTime -= Random() * 0.1;
    if (StateTime < 1.0 / 35.0)
    {
      StateTime = 1.0 / 35.0;
    }
  }
  else
  {
    //if (bIsPlayer) writeln("************ DESTROYING PLAYER!");
    Destroy();
  }
}

//==========================================================================
//
//  MorphedDeath
//
//==========================================================================

bool MorphedDeath(out EntityEx Morphed, out int MorphedStyle,
  out int MorphedHealth)
{
  // May be a morphed player
  if (bIsPlayer && PlayerEx(Player).MorphTime &&
    (PlayerEx(Player).MorphStyle & MORPH_UNDOBYDEATH) &&
    PlayerEx(Player).MO)
  {
    int RealStyle = PlayerEx(Player).MorphStyle;
    int RealHealth = Health;
    if (PlayerEx(Player).UndoPlayerMorph(
      PlayerEx(Player).MorphStyle & MORPH_UNDOBYDEATHFORCED,
      PlayerEx(Player)))
    {
      Morphed = EntityEx(PlayerEx(Player).MO);
      MorphedStyle = RealStyle;
      MorphedHealth = RealHealth;
      return true;
    }
    return false;
  }

  return false;
}

//==========================================================================
//
//  PoisonPlayer - Sets up all data concerning poisoning
//
//==========================================================================

final void PoisonPlayer(EntityEx poisoner, int poison)
{
  if ((PlayerEx(Player).Cheats & PlayerEx::CF_GODMODE) || bInvulnerable)
  {
    return;
  }
  PlayerEx(Player).PoisonCount += poison;
  PlayerEx(Player).Poisoner = poisoner;
  PlayerEx(Player).PoisonerPlayer = poisoner ? PlayerEx(poisoner.Player) :
    none;
  if (PlayerEx(Player).PoisonCount > 100)
  {
    PlayerEx(Player).PoisonCount = 100;
  }
  PlayerEx(Player).LastPoisonTime = XLevel.Time;
}

//==========================================================================
//
//  PoisonDamage
//
//  Similar to Actor::Damage
//
//==========================================================================

final void PoisonDamage(EntityEx inflictor, EntityEx source, int damage,
  bool playPainSound)
{
  if (Health <= 0)
  {
    return;
  }
  if (bInvulnerable && damage < 10000)
  { // mobj is invulnerable
    return;
  }
  if (bIsPlayer)
  {
    // Take half damage in trainer mode
    damage = ftoi(itof(damage) * Level.World.SkillDamageFactor);
  }
  if (damage < 1000 && ((PlayerEx(Player).Cheats & PlayerEx::CF_GODMODE) ||
    bInvulnerable))
  {
    return;
  }
  if (damage >= Player.Health && (Level.World.bSkillAutoUseHealth ||
    Level.Game.deathmatch) && !PlayerEx(Player).MorphTime)
  {
    // Try to use some inventory health
    AutoUseHealth(damage - Player.Health + 1);
  }
  Player.Health -= damage;  // mirror mobj health here for Dave
  if (Player.Health < 0)
  {
    Player.Health = 0;
  }
  if (Player.Health < 1 && (PlayerEx(Player).Cheats & PlayerEx::CF_BUDDHA)) Player.Health = 1;
  PlayerEx(Player).Attacker = source;

  //
  // do the damage
  //
  Health -= damage;
  if (bIsPlayer && Health < 1 && (PlayerEx(Player).Cheats & PlayerEx::CF_BUDDHA)) Health = 1;
  if (Health <= 0)
  {
    // Death
    Special1 = damage;
    if (bIsPlayer && inflictor && !PlayerEx(Player).MorphTime)
    {
      // Check for flame death
      if (inflictor.DamageType == 'Fire' && (Health > -50) && (damage > 25))
      {
        DamageType = 'Fire';
      }
      else
      {
        DamageType = inflictor.DamageType;
      }
    }
    Died(source, inflictor);
    return;
  }
  if (!(XLevel.TicTime & 63) && playPainSound)
  {
    SetState(FindState('Pain'));
  }
}
