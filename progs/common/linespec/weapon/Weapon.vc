//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class Weapon : Inventory abstract;

const float LOWERSPEED = 6.0;
const float RAISESPEED = 6.0;

const float WEAPONBOTTOM = 128.0;
const float WEAPONTOP    = 32.0;

enum {
  FIRE_Primary,
  FIRE_Secondary,
  // special value for CheckAmmo
  FIRE_Either,
}

// type of ammo weapon needs to operate
class!Ammo AmmoType1;
class!Ammo AmmoType2;
// how much ammo to give when picked up
int AmmoGive1;
int AmmoGive2;
// how much ammo used in each shot
int AmmoUse1;
int AmmoUse2;
// weapon given together with current one
class!Weapon SisterWeaponType;

name UpSound;
name ReadySound;


int SlotNumber = -1; // weapon slot this weapon is placed in
int SelectionOrder; // weapons with lower values have greater priority
int Position; // position this weapon has in each slot
float Kickback; // kickback from this weapon

float PSpriteSY; // y-adjustment value for full screen

int PlayerModelVersion; // for displaying weapon with player model

ubyte FireMode;

float BotCombatDist;

int ReloadCounter;


bool bWimpyWeapon; // switch away if got ammo for more powerfull weapon
bool bNoAutoFire; // don't auto fire
bool bPoweredUp; // this is a powered up version of another weapon
bool bStaff2Kickback; // does Heretic staff level 2 style kickback
bool bAmmoOptional; // ammo is optional
bool bAltAmmoOptional; // ammo is optional for alternate fire
bool bCheckAnyAmmo; // can be selected if have any ammo (either normal, or alt)
bool bReadySndHalf; // half a chance to play the reay sound
bool bDontBob; // don't bob weapon
bool bNoAlert; // doesn't allert monsters when fired
bool bCheatNotWeapon; // not considered a weapon by gimme cheat
bool bAxeBlood; // use axe's blood splatter
bool bNoAutoSwitch; // never switch to this weapon when picked up
bool bPrimaryUsesBoth; // primary fire uses both ammo types
bool bAltUsesBoth; // alternate fire uses both ammo types
bool bGivenAsMorphWeapon; // this weapon was given when owner morphed into something

bool bBotMelee; // it's a melee weapon
bool bBotProjectile; // it's a projectile weapon
bool bBotBfg; // it's a BFG

// runtime in-inventory references
Ammo Ammo1;
Ammo Ammo2;
Weapon SisterWeapon;

float FOVScale;


replication {
  reliable if (Role == ROLE_Authority && bNetOwner)
    Ammo1, Ammo2;
}


//==========================================================================
//
//  IsCheckpointSaveAllowed
//
//==========================================================================
override bool IsCheckpointSaveAllowed () {
  if (SisterWeapon) return false;
  return true;
}


//==========================================================================
//
//  QS_Save
//
//==========================================================================
override void QS_Save () {
  ::QS_Save(); // inventory
  QS_PutInt("Ammo1.Amount", (Ammo1 ? Ammo1.Amount : 0));
  QS_PutInt("Ammo1.MaxAmount", (Ammo1 ? Ammo1.MaxAmount : 0));
  QS_PutInt("Ammo2.Amount", (Ammo2 ? Ammo2.Amount : 0));
  QS_PutInt("Ammo2.MaxAmount", (Ammo2 ? Ammo2.MaxAmount : 0));
}


//==========================================================================
//
//  QS_Load
//
//==========================================================================
override void QS_Load () {
  ::QS_Load(); // inventory
  if (Ammo1) {
    Ammo1.Amount = QS_GetInt("Ammo1.Amount");
    Ammo1.MaxAmount = QS_GetInt("Ammo1.MaxAmount");
  }
  if (Ammo2) {
    Ammo2.Amount = QS_GetInt("Ammo2.Amount");
    Ammo2.MaxAmount = QS_GetInt("Ammo2.MaxAmount");
  }
}


//==========================================================================
//
//  Destroyed
//
//==========================================================================
override void Destroyed () {
  if (SisterWeapon) {
    SisterWeapon.SisterWeapon = none;
    SisterWeapon.Destroy();
  }
  ::Destroyed();
}


//==========================================================================
//
//  TryPickup
//
//==========================================================================
override bool TryPickup (EntityEx Toucher) {
  // if sprites for ready state are missing, you can't pick up this weapon
  state ReadyState = FindState('Ready');
  if (ReadyState && AreStateSpritesPresent(ReadyState)) {
    return ::TryPickup(Toucher);
  }
  return false;
}


//==========================================================================
//
//  HandlePickup
//
//==========================================================================
override bool HandlePickup (Inventory Item) {
  if (Item.Class == Class) {
    if (Weapon(Item).PickupForAmmo(self)) Item.bPickupGood = true;
    return true;
  }

  if (Inventory) return Inventory.HandlePickup(Item);
  return false;
}


//==========================================================================
//
//  CreateCopy
//
//==========================================================================
override Inventory CreateCopy (EntityEx Toucher) {
  Weapon Copy = Weapon(::CreateCopy(Toucher));
  if (Copy) {
    Copy.AmmoGive1 = AmmoGive1;
    Copy.AmmoGive2 = AmmoGive2;
  }
  return Copy;
}


//==========================================================================
//
//  CreateTossable
//
//==========================================================================
override Inventory CreateTossable () {
  // drop the weapon that is meant to be placed in a level, i.e. that normally gives you ammo
  if (SisterWeapon && !default.AmmoGive1 && !default.AmmoGive2 &&
      (SisterWeapon.default.AmmoGive1 > 0 || SisterWeapon.default.AmmoGive2 > 0))
  {
    return SisterWeapon.CreateTossable();
  }

  Weapon Copy = Weapon(::CreateTossable());
  if (Copy) {
    // if weapon has a sister weapon, remove it too
    if (SisterWeapon) {
      SisterWeapon.SisterWeapon = none;
      SisterWeapon.Destroy();
    }
    // dropped weapons don't have ammo to prevent cheating
    Copy.AmmoGive1 = 0;
    Copy.AmmoGive2 = 0;
  }
  return Copy;
}


//==========================================================================
//
//  AttachToOwner
//
//==========================================================================
override void AttachToOwner (EntityEx NewOwner) {
  ::AttachToOwner(NewOwner);

  // set up references to ammo items since they are used a lots
  Ammo1 = AddAmmo(NewOwner, AmmoType1, AmmoGive1);
  Ammo2 = AddAmmo(NewOwner, AmmoType2, AmmoGive2);
  SisterWeapon = AddWeapon(SisterWeaponType);

  if (Owner.Player && !bNoAutoSwitch && GetCvarB('wpn_autoswitch')) {
    // Doom and Strife always switch to a new weapon, Heretic and Hexen
    // only switch to more powerful weapons; always check for ammo
    auto pawn = PlayerPawn(Owner);
    if (!pawn) return;
    auto plr = PlayerEx(Owner.Player);
    if (!plr) return;

    bool doSwitch = LineSpecialGameInfo(Level.Game).bAlwaysSwitchNewWeapon;
    if (!doSwitch) {
      doSwitch = true;
      if (plr.ReadyWeapon) {
        int ReadySlot = -1, ReadyIndex = -1;
        if (pawn.FindWeaponSlot(class!Weapon(plr.ReadyWeapon.Class), out ReadySlot, out ReadyIndex)) {
          int NewSlot = -1, NewIndex = -1;
          if (pawn.FindWeaponSlot(class!Weapon(Class), out NewSlot, out NewIndex)) {
            doSwitch = (NewSlot > ReadySlot) || (NewSlot == ReadySlot && NewIndex > ReadyIndex);
          }
        }
      }
    }

    if (doSwitch && CheckAmmo(FIRE_Either, false)) {
      PlayerEx(Owner.Player).PendingWeapon = self;
    }
  }
}


//==========================================================================
//
//  AddAmmo
//
//  Returns false if the ammo can't be picked up at all
//
//==========================================================================
final Ammo AddAmmo (EntityEx Toucher, class!Ammo AmmoType, int count) {
  if (!AmmoType) return none;

  if (!bIgnoreSkill) {
    // extra ammo in baby mode and nightmare mode
    count = int(float(count)*Level.World.SkillAmmoFactor);
  }

  Ammo AmmoItem = Ammo(Toucher.FindInventory(AmmoType));
  if (!AmmoItem) {
    AmmoItem = Spawn(AmmoType, default, default, default, false);
    AmmoItem.AttachToOwner(Toucher);
    AmmoItem.Amount = count;
  } else if (AmmoItem.Amount < AmmoItem./*MaxAmount*/k8GetAmmoKingMax()) {
    AmmoItem.Amount += count;
  }

  if (AmmoItem.Amount > AmmoItem./*MaxAmount*/k8GetAmmoKingMax()) {
    AmmoItem.Amount = AmmoItem./*MaxAmount*/k8GetAmmoKingMax();
  }

  return AmmoItem;
}


//==========================================================================
//
//  AddExistingAmmo
//
//==========================================================================
final bool AddExistingAmmo (Ammo AmmoItem, int count) {
  int oldammo;

  if (!AmmoItem || count <= 0) return false;
  if (AmmoItem.Amount == AmmoItem./*MaxAmount*/k8GetAmmoKingMax()) return false;

  if (!bIgnoreSkill) {
    // extra ammo in baby mode and nightmare mode
    count = int(float(count)*Level.World.SkillAmmoFactor);
  }

  oldammo = AmmoItem.Amount;
  AmmoItem.Amount += count;
  if (AmmoItem.Amount > AmmoItem./*MaxAmount*/k8GetAmmoKingMax()) {
    AmmoItem.Amount = AmmoItem./*MaxAmount*/k8GetAmmoKingMax();
  }

  if (oldammo <= 0 && AmmoItem.Owner.Player) {
    PlayerEx(AmmoItem.Owner.Player).GotAmmo(AmmoItem);
  }

  return true;
}


//==========================================================================
//
//  AddWeapon
//
//==========================================================================
final Weapon AddWeapon (class!Weapon WeaponType) {
  if (!WeaponType) return none;
  Weapon Wpn = Weapon(EntityEx(Owner).FindInventory(WeaponType));
  if (!Wpn) {
    Wpn = Spawn(WeaponType, default, default, default, false);
    Wpn.AttachToOwner(EntityEx(Owner));
  }
  return Wpn;
}


//==========================================================================
//
//  PickupForAmmo
//
//==========================================================================
bool PickupForAmmo (Weapon ExistingWeapon) {
  // leave placed weapons forever on net games
  if (ShouldStay() && !bDropped) return false;
  bool gaveammo = false;
  if (AddExistingAmmo(ExistingWeapon.Ammo1, AmmoGive1)) gaveammo = true;
  if (AddExistingAmmo(ExistingWeapon.Ammo2, AmmoGive2)) gaveammo = true;
  return gaveammo;
}


//==========================================================================
//
//  ShouldStay
//
//==========================================================================
override bool ShouldStay () {
  return LineSpecialGameInfo(Level.Game).bWeaponsStay;
}


//==========================================================================
//
//  Use
//
//  Using a weapon makes it active.
//
//==========================================================================
override bool Use (bool Pickup) {
  // can't directly use powered up weapon
  if (bPoweredUp) return false;
  // see which weapon to use
  Weapon UseWpn = self;
  if (SisterWeapon && SisterWeapon.bPoweredUp &&
      EntityEx(Owner).FindInventory(PowerWeaponLevel2))
  {
    UseWpn = SisterWeapon;
  }
  if (Owner.bIsPlayer && PlayerEx(Owner.Player).ReadyWeapon != UseWpn) {
    PlayerEx(Owner.Player).PendingWeapon = UseWpn;
  }
  return false;
}


//==========================================================================
//
//  GetUpState
//
//==========================================================================
state GetUpState () {
  return FindState('Select');
}


//==========================================================================
//
//  GetDownState
//
//==========================================================================
state GetDownState () {
  return FindState('Deselect');
}


//==========================================================================
//
//  GetReadyState
//
//==========================================================================
state GetReadyState () {
  return FindState('Ready');
}


//==========================================================================
//
//  GetAttackState
//
//==========================================================================
state GetAttackState (bool Hold) {
  state S = none;
  if (Hold) S = FindState('Hold');
  if (!S) S = FindState('Fire');
  return S;
}


//==========================================================================
//
//  GetAltAttackState
//
//==========================================================================
state GetAltAttackState (bool Hold) {
  state S = none;
  if (Hold) S = FindState('AltHold');
  if (!S) S = FindState('AltFire');
  return S;
}


//==========================================================================
//
//  GetReloadState
//
//==========================================================================
state GetReloadState () {
  return FindState('Reload');
}


//==========================================================================
//
//  CheckSpecialWeaponAmmo
//
//  Special hack for BDW Assault Rifle and BDW Shotgun
//
//==========================================================================
bool CheckSpecialWeaponAmmo (ubyte Mode) {
  name ammoName;
       if (GetClassName(Class) == 'BDW_Rifle') ammoName = 'BDW_RifleAmmo';
  else if (GetClassName(Class) == 'BDW_Shotgun') ammoName = 'BDW_ShotgunAmmo';
  else return true;

  for (Inventory a2 = EntityEx(Owner).Inventory; a2; a2 = a2.Inventory) {
    if (GetClassName(a2.Class) == ammoName) {
      //print("%C; AmountX=%s; AmmoUse1=%s", self, a2.Amount, AmmoUse1);
      return (a2.Amount > 0);
    }
  }

  return false;
}


//==========================================================================
//
//  CheckAmmoIfZero
//
//  Special hack for BDW Assault Rifle and BDW Shotgun
//
//==========================================================================
final bool CheckAmmoAmount (ubyte Mode) {
  if (Mode == FIRE_Primary) {
    int Amount1 = (Ammo1 ? Ammo1.Amount : 0);
    //print("%C; Amount1=%s; AmmoUse1=%s", self, Amount1, AmmoUse1);
    if (Amount1 == 0 && AmmoUse1 == 0) return CheckSpecialWeaponAmmo(Mode);
    return (Amount1 >= AmmoUse1);
  } else {
    int Amount2 = (Ammo2 ? Ammo2.Amount : 0);
    if (Amount2 == 0 && AmmoUse2 == 0) return CheckSpecialWeaponAmmo(Mode);
    return (Amount2 >= AmmoUse2);
  }
}


//==========================================================================
//
//  CheckAmmo
//
//  Returns true if there is enough mana to shoot.  If not, selects the
//  next weapon to use.
//
//==========================================================================
bool CheckAmmo (ubyte Mode, bool AutoSwitch, optional bool RequireAmmo) {
  // search for infinite ammo power; any subclass will do
  Inventory InfiniteAmmo = EntityEx(Owner).Inventory;
  while (InfiniteAmmo) {
    if (PowerInfiniteAmmo(InfiniteAmmo)) break;
    InfiniteAmmo = InfiniteAmmo.Inventory;
  }

  if (InfiniteAmmo) {
    // don't waste ammo if we have an infinite ammo powerup
    return true;
  }

  if (Mode == FIRE_Either) {
    if (CheckAmmo(FIRE_Primary, false, RequireAmmo!optional) ||
        CheckAmmo(FIRE_Secondary, false, RequireAmmo!optional))
    {
      return true;
    }
  } else {
    if (!RequireAmmo && bAmmoOptional) return true;

    bool Good = true;
    if (bCheckAnyAmmo) {
      // for any fire mode, any ammo will do
      if (!CheckAmmoAmount(FIRE_Primary) || !CheckAmmoAmount(FIRE_Secondary)) Good = false;
    } else {
      if ((Mode == FIRE_Primary || bAltUsesBoth) && !CheckAmmoAmount(FIRE_Primary)) Good = false;
      if (Good && (Mode == FIRE_Secondary || bPrimaryUsesBoth) && !CheckAmmoAmount(FIRE_Secondary)) Good = false;
      if (Good && Mode == FIRE_Secondary && !FindState('AltFire')) Good = false;
    }

    /*
    int Amount1 = (Ammo1 ? Ammo1.Amount : 0);
    int Amount2 = (Ammo2 ? Ammo2.Amount : 0);

    if (bCheckAnyAmmo) {
      // for any fire mode, any ammo will do
      if ((Mode == FIRE_Primary || Mode == FIRE_Secondary) &&
          Amount1 < AmmoUse1 && Amount2 < AmmoUse2)
      {
        //HACK
        if ((Amount1 == 0 && AmmoUse1 == 0) && (Amount2 == 0 && AmmoUse2 == 0)) {
          // more checks!
          Good = false;
        } else {
          Good = false;
        }
      }
    } else {
      //HACK!
      if ((Mode == FIRE_Primary || bAltUsesBoth) && Amount1 < AmmoUse1) {
        Good = false;
      } else {
        //HACK
        if (Amount1 == 0 && AmmoUse1 == 0) {
          // more checks!
          Good = false;
        }
      }
      print("%C is %B (both=%B; Amount1=%s; AmmoUse1=%s)", self, Good, bAltUsesBoth, Amount1, AmmoUse1);
      //HACK!
      if (Good && (Mode == FIRE_Secondary || bPrimaryUsesBoth) && Amount2 < AmmoUse2) {
        //HACK
        if (Amount2 == 0 && AmmoUse2 == 0) {
          // more checks!
          Good = false;
        } else {
          Good = false;
        }
      }
      // if weapon has no secondary fire, there's never enough ammo for it
      if (Good && Mode == FIRE_Secondary && !FindState('AltFire')) Good = false;
    }
    */

    if (Good) return true;
  }

  if (!AutoSwitch) return false;

  // out of ammo, pick a weapon to change to
  Weapon Best = PlayerEx(Owner.Player).BestWeapon();

  PlayerEx(Owner.Player).PendingWeapon = Best;
  Owner.Player.SetViewObject(self);
  Owner.Player.SetViewState(ps_weapon, GetDownState());
  return false;
}


//==========================================================================
//
//  DepleteAmmo
//
//==========================================================================
final bool DepleteAmmo (ubyte Mode, optional bool CheckEnough, optional int DehackedUse) {
  // search for infinite ammo power; any subclass will do
  Inventory InfiniteAmmo = EntityEx(Owner).Inventory;
  while (InfiniteAmmo) {
    if (PowerInfiniteAmmo(InfiniteAmmo)) break;
    InfiniteAmmo = InfiniteAmmo.Inventory;
  }

  if (InfiniteAmmo) {
    // don't waste ammo if we have an infinite ammo powerup
    return true;
  }

  // default parameter values
  if (!specified_CheckEnough) CheckEnough = true;
  if (!specified_DehackedUse) DehackedUse = AmmoUse1;

  if (CheckEnough && !CheckAmmo(Mode, false)) return false;

  /*
  print("DepleteAmmo0(%C): primary=%s, secondary=%s, Ammo1=%C(%d), Ammo2=%C(%d)", self,
    (Mode == FIRE_Primary ? "tan" : "ona"), (Mode == FIRE_Secondary ? "tan" : "ona"),
    Ammo1, (Ammo1 ? Ammo1.Amount : -666),
    Ammo2, (Ammo2 ? Ammo2.Amount : -666));
  */

  if ((Mode == FIRE_Primary || bAltUsesBoth) && Ammo1) {
    if (LineSpecialGameInfo(Level.Game).bDehacked) {
      Ammo1.Amount -= DehackedUse;
    } else {
      Ammo1.Amount -= AmmoUse1;
    }
  }
  if ((Mode == FIRE_Secondary || bPrimaryUsesBoth) && Ammo2) Ammo2.Amount -= AmmoUse2;

  // don't let ammo go below zero
  if (Ammo1 && Ammo1.Amount < 0) Ammo1.Amount = 0;
  if (Ammo2 && Ammo2.Amount < 0) Ammo2.Amount = 0;

  /*
  print("DepleteAmmo1(%C): primary=%s, secondary=%s, Ammo1=%C(%d), Ammo2=%C(%d)", self,
    (Mode == FIRE_Primary ? "tan" : "ona"), (Mode == FIRE_Secondary ? "tan" : "ona"),
    Ammo1, (Ammo1 ? Ammo1.Amount : -666),
    Ammo2, (Ammo2 ? Ammo2.Amount : -666));
  */

  return true;
}


//===========================================================================
//
//  EndPowerup
//
//===========================================================================
final void EndPowerup () {
  if (SisterWeapon) {
    PlayerEx(Owner.Player).SetWeapon(SisterWeapon);
    if (SisterWeapon.GetReadyState() != GetReadyState()) {
      PlayerEx(Owner.Player).SetViewObject(SisterWeapon);
      PlayerEx(Owner.Player).SetViewState(ps_weapon, SisterWeapon.GetReadyState());
    }
  }
}


states {
LightDone:
  SHTG E 0 A_Light0
  Stop
}


defaultproperties {
  PickupSound = 'misc/w_pkup';
}
