//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//**
//**  Class for Actor state action methods.
//**
//**************************************************************************

// flags for A_Remove*
enum /*ERemoveFlags*/ {
  RMVF_MISSILES   = 0x00000001,
  RMVF_NOMONSTERS = 0x00000002,
  RMVF_MISC       = 0x00000004,
  RMVF_EVERYTHING = 0x00000008,
  RMVF_EXFILTER   = 0x00000010,
  RMVF_EXSPECIES  = 0x00000020,
  RMVF_EITHER     = 0x00000040,
};

// flags for A_RadiusGive
enum /*ERadiusGiveFlags*/ {
  RGF_GIVESELF  = 1,
  RGF_PLAYERS   = 1<<1,
  RGF_MONSTERS  = 1<<2,
  RGF_OBJECTS   = 1<<3,
  RGF_VOODOO    = 1<<4,
  RGF_CORPSES   = 1<<5,
  RGF_NOTARGET  = 1<<6,
  RGF_NOTRACER  = 1<<7,
  RGF_NOMASTER  = 1<<8,
  RGF_CUBE      = 1<<9,
  RGF_NOSIGHT   = 1<<10,
  RGF_MISSILES  = 1<<11,
  RGF_INCLUSIVE = 1<<12,
  RGF_ITEMS     = 1<<13,
  RGF_KILLED    = 1<<14,
  RGF_EXFILTER  = 1<<15,
  RGF_EXSPECIES = 1<<16,
  RGF_EITHER    = 1<<17,
};


enum /*WARPF*/ {
  WARPF_ABSOLUTEOFFSET    = 0x1,
  WARPF_ABSOLUTEANGLE     = 0x2,
  WARPF_USECALLERANGLE    = 0x4,

  WARPF_NOCHECKPOSITION   = 0x8,

  WARPF_INTERPOLATE       = 0x10,
  WARPF_WARPINTERPOLATION = 0x20,
  WARPF_COPYINTERPOLATION = 0x40,

  WARPF_STOP              = 0x80,
  WARPF_TOFLOOR           = 0x100,
  WARPF_TESTONLY          = 0x200,
  WARPF_ABSOLUTEPOSITION  = 0x400,
  WARPF_BOB               = 0x800,
  WARPF_MOVEPTR           = 0x1000,
  WARPF_USEPTR            = 0x2000,
  WARPF_USETID            = 0x2000,
  WARPF_COPYVELOCITY      = 0x4000,
  WARPF_COPYPITCH         = 0x8000,
};


// flags for A_QuakeEx are in `QuakeFocusEx`


//==========================================================================
//
//  A_k8ConLog
//
//==========================================================================
final void decorate_A_k8ConLog (string msg) {
  if (msg) print("DECORATE LOG: %s", msg);
}


//==========================================================================
//
//  A_RetDoJump
//
//==========================================================================
final void decorate_A_RetDoJump (state State) {
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
       if (XLevel.StateCall) XLevel.StateCall->State = State;
  else if (bIsPlayer && XLevel.CallingState == Player.ViewStates[PS_WEAPON].State) Player.SetViewState(PS_WEAPON, State);
  else if (bIsPlayer && XLevel.CallingState == Player.ViewStates[PS_FLASH].State) Player.SetViewState(PS_FLASH, State);
  else if (bIsPlayer && XLevel.CallingState == Player.ViewStates[PS_WEAPON_OVL].State) Player.SetViewState(PS_WEAPON_OVL, State);
  else SetState(State);
}


//==========================================================================
//
//  decorate_GetArg
//
//==========================================================================
final int decorate_GetArg (int n) {
  return (n >= 0 && n < 5 ? Args[n] : 0);
}


//==========================================================================
//
//  A_SetArg
//
//==========================================================================
final void A_SetArg (int n, int v) {
  if (n >= 0 && n < 5) Args[n] = v;
}


//==========================================================================
//
//  A_SetAngle
//
//==========================================================================
final void A_SetAngle (float newyaw, optional int flags, optional int aptr) {
  Entity tgt = DecorDoAAPtr('A_SetAngle', aptr!optional);
  if (!tgt) return;
  tgt.Angles.yaw = AngleMod360(newyaw);
  //dprint("A_SetAngle: not implemented!");
}


/*
const int SPF_FORCECLAMP = 0x01;
const int SPF_INTERPOLATE = 0x00;
*/

//==========================================================================
//
//  clampPitch
//
//==========================================================================
private final float clampPitch (float newpitch) {
  // hack, so player head won't be clamped down
  //print("  A_SetPitch00: newpitch=%f", newpitch);
  if (newpitch >= 360) {
    newpitch = AngleMod360(newpitch);
    //print("  A_SetPitch01: newpitch=%f", newpitch);
  }
  if (newpitch > 180) newpitch = AngleMod360(newpitch)-360; // [-90..]
  //print("  A_SetPitch02: newpitch=%f", newpitch);
  //return fclamp(newpitch, -90.0, 90.0);
  return fclamp(newpitch, -80.0, 80.0); // actual engine limits
}


//==========================================================================
//
//  A_SetPitch
//
//  should be always clamped on player
//
//==========================================================================
final void A_SetPitch (float newpitch, optional int flags, optional int aptr) {
  Entity tgt = DecorDoAAPtr('A_SetPitch', aptr!optional);
  if (!tgt) return;
  if (tgt.bIsPlayer || (flags&0x01) != 0) newpitch = clampPitch(newpitch);
  tgt.Angles.pitch = /*AngleMod360*/(newpitch);
}


//==========================================================================
//
//  A_SetRoll
//
//==========================================================================
final void A_SetRoll (float newroll, optional int flags, optional int aptr) {
  Entity tgt = DecorDoAAPtr('A_SetRoll', aptr!optional);
  if (!tgt) return;
  tgt.Angles.roll = AngleMod360(newroll);
}


//==========================================================================
//
//  ACS_Execute
//
//==========================================================================
final bool ACS_Execute (int script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunACS(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_ExecuteAlways
//
//==========================================================================
final bool ACS_ExecuteAlways (int script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunACSAlways(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_ExecuteWithResult
//
//==========================================================================
final int ACS_ExecuteWithResult (int script, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunACSWithResult(self, script, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_NamedExecute
//
//==========================================================================
final bool ACS_NamedExecute (string script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunNamedACS(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_NamedExecuteAlways
//
//==========================================================================
final bool ACS_NamedExecuteAlways (string script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  //print("ACS_NamedExecuteAlways: script=%s; map=%d; args=(%d,%d,%d,%d)", script, map, s_arg1, s_arg2, s_arg3, s_arg4);
  return XLevel.RunNamedACSAlways(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_NamedExecuteWithResult
//
//==========================================================================
final int ACS_NamedExecuteWithResult (string script, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunNamedACSWithResult(self, script, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  decorate_CountInv
//
//==========================================================================
final int decorate_CountInv (name ItemName, optional int aptr) {
  Entity tgt = DecorDoAAPtr('decorate_CountInv', aptr!optional);
  if (!tgt) return 0;
  return tgt.CheckInventory(ItemName);
}


//==========================================================================
//
//  A_SpawnProjectile
//
//==========================================================================
final void A_SpawnProjectile (name MissileTypeName, optional float SpawnHeight, optional float SpawnXYOffset,
                              optional float Angle, optional int AimMode, optional float Pitch, optional int aptr)
{
  if (!MissileTypeName) return;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_SpawnProjectile', aptr!optional));
  if (!tgt) return;

  int Flags = AimMode&~3;
  AimMode &= 3;

  class!EntityEx MissileType = class!EntityEx(FindClassNoCase(MissileTypeName));
  if (!MissileType) return;
  MissileType = class!EntityEx(GetClassReplacement(MissileType));
  if (!MissileType) return;
  //if (Level.Game.nomonsters && MissileType.default.bMonster) return;

  if (tgt.Target || AimMode == 2) {
    if (MissileType) {
      if (!specified_SpawnHeight) SpawnHeight = 32.0;
      if (!specified_SpawnXYOffset) SpawnXYOffset = 0; // was 1, why?
      TVec Offs = float(SpawnXYOffset)*vector(cos(tgt.Angles.yaw-90.0), sin(tgt.Angles.yaw-90.0), 0.0);
      EntityEx A;

      switch (AimMode) {
        default:
          tgt.Origin += Offs;
          A = tgt.SpawnMissile(tgt.Target, MissileType, SpawnHeight);
          tgt.Origin -= Offs;
          break;
        case 1:
          Offs.z = SpawnHeight;
          A = tgt.SpawnMissileXYZ(tgt.Origin+Offs, tgt.Target, MissileType);
          break;
        case 2:
          tgt.Origin += Offs;
          A = tgt.SpawnMissileAngles(MissileType, tgt.Angles.yaw, Pitch, SpawnHeight);
          tgt.Origin -= Offs;
          break;
      }

      if (A) {
        VectorRotateAroundZ(ref A.Velocity, Angle);
        // find correct shooter for projectiles shooting projectiles
        if (tgt.IsMissile(!!(Flags&4))) {
          EntityEx Own = tgt/*self*/;
          while (Own.IsMissile(!!(Flags&4)) && Own.Target) Own = Own.Target;
          A.Target = Own;
          if (A.bSeekerMissile) A.Tracer = tgt.Tracer;
        } else if (A.bSeekerMissile) {
          A.Tracer = tgt.Target;
        }
      }
    }
  } else if (Flags&8) {
    if (tgt.SeeState) tgt.SetState(tgt.SeeState);
  }
}


//===========================================================================
//
//  A_Quake
//
//===========================================================================
final bool A_Quake (float intensity, float ticduration, float damrad, float tremrad, optional name soundname) {
  if (ticduration < 1) return false;
  if (damrad < 1 && tremrad < 1) return false;
  damrad = fmax(0, damrad);
  tremrad = fmax(0, tremrad);
  if (intensity < 1) return false;
  intensity = fmin(intensity, 9);
  QuakeFocus focus = Spawn(QuakeFocus, Origin);
  if (focus) {
    focus.Richters = int(intensity);
    focus.QuakeDuration = int(ticduration)>>1; // decremented every 2 tics
    focus.DamageRadius = damrad;
    focus.TremorRadius = tremrad;
    //if (soundname) PlaySound(soundname, CHAN_AUTO);
    focus.SoundName = soundname;
    return true;
  }
  return false;
}


//===========================================================================
//
//  A_QuakeEx
//
//  radii are in map units
//
//===========================================================================
final bool A_QuakeEx (float intensityX, float intensityY, float intensityZ, float ticduration, float damrad, float tremrad,
                      optional name soundname, optional int flags, optional float mulwavex, optional float mulwavey, optional float mulwavez,
                      optional int falloff, optional int highpoint, optional float rollIntensity, optional float rollWave)
{
  if (ticduration < 1) return false;
  if (damrad < 1 && tremrad < 1) return false;
  damrad = fmax(0, damrad);
  tremrad = fmax(0, tremrad);
  if (intensityX < 1 && intensityY < 1 && intensityZ < 1) return false;
  intensityX = fmin(intensityX, 9);
  intensityY = fmin(intensityY, 9);
  intensityZ = fmin(intensityZ, 9);
  QuakeFocusEx focus = Spawn(QuakeFocusEx, Origin);
  if (focus) {
    focus.Richters = vector(int(intensityX), int(intensityY), int(intensityZ));
    focus.QuakeDuration = int(ticduration)>>1; // decremented every 2 tics
    focus.DamageRadius = damrad;
    focus.TremorRadius = tremrad;
    //if (soundname) PlaySound(soundname, CHAN_AUTO);
    focus.SoundName = soundname;
    focus.Flags = flags;
    focus.MulWave = vector(mulwavex, mulwavey, mulwavez);
    focus.Falloff = fmax(0, falloff);
    focus.HighPoint = fmax(0, highpoint);
    return true;
  }
  return false;
}


//==========================================================================
//
//  decorate_A_CheckFlag
//
//==========================================================================
final void decorate_A_CheckFlag (string flagname, state label, optional int aptr) {
  // state jumps should not affect state chain results
  //print("A_CheckFlag: name=<%s>; label=<%s>; aptr=%s", flagname, label, aptr);
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_CheckFlag', aptr!optional));
  if (!tgt) return;
  //if (!decoDoCheckFlag(flagname, tgt)) return;
  if (!tgt.GetDecorateFlag(flagname)) return;
  DoJump(label);
}


//==========================================================================
//
//  decorate_A_ChangeFlag
//
//==========================================================================
/*
final void decorate_A_ChangeFlag (string flagname, int value) {
  //decoDoFlagAction(flagname, self, !!value);
  print("A_ChangeFlag: name=<%s>; value=%s", flagname, value);
  //print("  nopain0=%s", bNoPain);
  decoDoSetFlag(flagname, self, !!value);
  //print("  nopain1=%s", bNoPain);
}
*/


//==========================================================================
//
//  decorate_A_DamageSelf
//
//==========================================================================
final void decorate_A_DamageSelf (int amount, optional name damagetype, optional int flags, optional name filter, optional name species, optional int src, optional int inflict) {
  if (flags) { print("DECORATE: A_DamageSelf with `flags` is not supported yet!"); }
  if (specified_filter) { print("DECORATE: A_DamageSelf with `filter` is not supported yet!"); }
  if (specified_species) { print("DECORATE: A_DamageSelf with `species` is not supported yet!"); }
  if (specified_src) { print("DECORATE: A_DamageSelf with `src` is not supported yet!"); }
  if (specified_inflict) { print("DECORATE: A_DamageSelf with `inflict` is not supported yet!"); }
  if (amount == 0) return;
  Damage(inflictor:self, source:self, amount, DmgType:damagetype!optional);
}


//==========================================================================
//
//  decorate_A_SetTics
//
//==========================================================================
final void decorate_A_SetTics (int tics) {
  tics = max(tics, 0);
  StateTime = float(tics)/35.0;
}


//==========================================================================
//
//  decorate_A_CheckFloorTextureGlob
//
//==========================================================================
final void decorate_A_CheckFloorTextureGlob (string txname, state label, optional int aptr, optional bool dumpTexture) {
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_CheckFloorTexture', aptr!optional));
  if (!tgt) return;
  if (!tgt.Sector) return; // just in case
  auto tname = GetTextureName(tgt.Sector.floor.pic);
  if (dumpTexture) print("TEXTURE NAME: <%s> gmatch <%s>: res=%B", tname, txname, globmatch(string(tname), txname, caseSensitive:false));
  if (!globmatch(string(tname), txname, caseSensitive:false)) return;
  DoJump(label);
}


//==========================================================================
//
//  A_DropItem
//
//==========================================================================
final void A_DropItem (name item, optional int dropamount, optional int chance) {
  if (!item) return;

  float dropChance = 1;
  if (specified_chance) {
    if (chance <= 0) return;
    if (chance < 256) dropChance = float(chance)/256.0;
  }

  class!EntityEx dip = class!EntityEx(FindClassNoCase(item));
  if (!dip) return;
  dip = class!EntityEx(GetClassReplacement(dip));
  if (!dip) return;

  if (specified_dropamount) {
    if (dip !isa Inventory) dropamount = 1;
  } else {
    dropamount = 1;
  }

  DropItem(dip, dropamount, dropChance);
}


//==========================================================================
//
//  a_removechildren_checkIfChildShouldBeRemoved
//
//==========================================================================
final private bool a_removechildren_checkIfChildShouldBeRemoved (Actor child, bool all, int flags, string filter, string species) {
  if (!all && child.Health > 0) return false; // it is still alive
  bool filterHit = true, speciesHit = true;
  if (filter) {
    filterHit = (stricmp(filter, string(GetClassName(child.Class))) != 0);
    if (flags&RMVF_EXFILTER) filterHit = !filterHit; // filter inverted
  }
  if (species) {
    speciesHit = (stricmp(species, string(child.GetSpecies())) != 0);
    if (flags&RMVF_EXSPECIES) speciesHit = !speciesHit; // species inverted
  }
  if (flags&RMVF_EITHER) {
    if (!filterHit && !speciesHit) return false;
  } else {
    if (!filterHit || !speciesHit) return false;
  }
  // check other flags
  if (!(flags&RMVF_EVERYTHING)) {
    if (child.bMonster) {
      // monster?
      if (flags&RMVF_NOMONSTERS) return false;
    } else if (child.IsMissile(false)) { // or precise?
      // missile?
      if (!(flags&RMVF_MISSILES)) return false;
    } else {
      // other?
      if (!(flags&RMVF_MISC)) return false;
    }
  }
  return true;
}


#ifdef VC_SCRIPT_USE_SPAWNED_CHILDREN_ARRAY
#else
// this is trick so `delete` will clear the array for us
transient private array!Actor A_RC_KillList;
#endif

//==========================================================================
//
//  A_RemoveChildren
//
//==========================================================================
final void A_RemoveChildren (optional bool all, optional int flags, optional string filter, optional string species) {
  if (stricmp(filter, "none") == 0) filter = "";
  if (stricmp(species, "none") == 0) species = "";

#ifdef VC_SCRIPT_USE_SPAWNED_CHILDREN_ARRAY
  foreach (auto idx; 0..SpawnedChildren.length) {
    Actor child = Actor(SpawnedChildren[idx]);
    if (!child) continue;
    if (!a_removechildren_checkIfChildShouldBeRemoved(child, all, flags, filter, species)) continue;
    // kill it!
    //print("%C: removing children #%d (%C)", self, idx, SpawnedChildren[idx]);
    delete SpawnedChildren[idx];
  }

  // shrink array
  /*
  foreach (auto idx; 0..SpawnedChildren.length; reverse) {
    if (SpawnedChildren[idx]) {
      if (idx+1 < SpawnedChildren.length) SpawnedChildren.length = idx+1;
      break;
    }
  }
  */
#else
  //array!Actor A_RC_KillList;
  A_RC_KillList.clear(); // clear, but don't reallocate
  Actor th;
  foreach AllThinkers(Actor, th) {
    if (th && th.SpawnParent == self && a_removechildren_checkIfChildShouldBeRemoved(th, all, flags, filter, species)) A_RC_KillList[$] = th;
  }
  foreach (auto idx; 0..A_RC_KillList.length) {
    th = A_RC_KillList[idx];
    if (th) {
      //print("%C: removing children #%d (%C)", self, idx, th);
      delete th;
    }
  }
  A_RC_KillList.clear(); // clear, but don't reallocate
#endif
}


//==========================================================================
//
//  A_RadiusGive
//
//==========================================================================
final int A_RadiusGive (name itemname, float distance, int flags, optional int amount, optional string filter, optional string species, optional float mindist, optional int limit) {
  if (!specified_limit) limit = int.max;
  if (limit < 1) return 0;

  if (amount < 0) return 0;
  amount = max(1, amount); // 0 is 1 anyway

  if (distance <= 0) return 0; // as per docs
  if (mindist > distance) return 0;

  // find item class
  if (!itemname) return 0;
  class!Inventory itemtype = class!Inventory(FindClassNoCase(itemname));
  if (!itemtype) return 0;
  itemtype = class!Inventory(GetClassReplacement(itemtype));
  if (!itemtype) return 0;

  // fix filters
  if (stricmp(filter, "none") == 0) filter = "";
  if (stricmp(species, "none") == 0) species = "";

  bool giveCube = (flags&RGF_CUBE);
  int count = 0;
  Entity enti;
  foreach RadiusThings(enti, Origin, distance*(giveCube ? 2.0 : 1.0)) {
    EntityEx ent = EntityEx(enti);
    if (!ent) continue;
    if (ent == self) {
      if (!(flags&RGF_GIVESELF)) continue;
    } else {
      // check distance
      if (mindist > 0 && length2d(ent.Origin-Origin) > mindist) continue;
      if (giveCube) {
        // additional check for cube giver
        if (fabs(Origin.x-ent.Origin.x) > distance || fabs(Origin.y-ent.Origin.y) > distance) continue;
      }

      // check filters
      bool filterHit = true, speciesHit = true;
      if (filter) {
        filterHit = (stricmp(filter, string(GetClassName(ent.Class))) != 0);
        if (flags&RGF_EXFILTER) filterHit = !filterHit; // filter inverted
      }
      if (species) {
        speciesHit = (stricmp(species, string(ent.GetSpecies())) != 0);
        if (flags&RGF_EXSPECIES) speciesHit = !speciesHit; // species inverted
      }
      if (flags&RGF_EITHER) {
        if (!filterHit && !speciesHit) continue;
      } else {
        if (!filterHit || !speciesHit) continue;
      }

      if (ent.bCorpse && (flags&RGF_CORPSES)) {
        // do nothing, really
      } else {
        // check allowed flags
        if (ent.bIsPlayer) {
          // player
          if (ent.Player.PlayerState == PST_DEAD) continue;
          //if (ent.Player.bIsBot)
          if (ent.Player.MO != self) {
            // voodoo doll
            if (!(flags&RGF_VOODOO)) continue;
          } else {
            if (!(flags&RGF_PLAYERS)) continue;
          }
        } else if (ent.bMonster) {
          // monster
          if (!(flags&RGF_MONSTERS)) continue;
          if (ent.Health <= 0 && !(flags&RGF_KILLED)) continue;
        } else if (ent.bMissile) {
          // missile
          if (!(flags&RGF_MISSILES)) continue;
        } else {
          // other
          if (ent isa Inventory) {
            if (!(flags&RGF_ITEMS)) continue;
          } else {
            if (!(flags&RGF_OBJECTS)) continue;
            // should be either shootable or vulnerable
            if (!ent.bShootable && !ent.bNoDamage) continue;
          }
        }
      }

      // check NOxxx
      if (flags&(RGF_NOTARGET|RGF_NOTRACER|RGF_NOMASTER)) {
        if (flags&RGF_INCLUSIVE) {
          // should satisfy all
          bool isTarget = (flags&RGF_NOTARGET ? (Target == ent) : true);
          bool isTracer = (flags&RGF_NOTRACER ? (Tracer == ent) : true);
          bool isMaster = (flags&RGF_NOMASTER ? (Master == ent) : true);
          if (isTarget && isTracer && isMaster) continue;
        } else {
          bool isTarget = (flags&RGF_NOTARGET ? (Target == ent) : false);
          bool isTracer = (flags&RGF_NOTRACER ? (Tracer == ent) : false);
          bool isMaster = (flags&RGF_NOMASTER ? (Master == ent) : false);
          if (isTarget || isTracer || isMaster) continue;
        }
      }

      // sight check
      if (!(flags&RGF_NOSIGHT) && !CanSee(ent)) continue;
    }

    // it is ok to give an item
    if (DoGiveInventory(itemtype, amount, ent)) {
      ++count;
      if (count >= limit) break;
    }
  }

  return count;
}


//==========================================================================
//
//  decorate_CheckClass
//
//==========================================================================
final bool decorate_CheckClass (name classname, optional int ptr_select, optional bool match_superclass) {
  Entity tgt = DecorDoAAPtr('decorate_CheckClass', ptr_select!optional);
  if (!tgt) return false;
  if (!classname) return false;
  class!Entity tc = class!Entity(tgt.Class);
  while (tc) {
    if (nameicmp(GetClassName(tc), classname) == 0) return true;
    if (!match_superclass) break;
    tc = class!Entity(GetClassParent(tc));
  }
  return false;
}


//==========================================================================
//
//  A_JumpIfRadiusAmountGreater
//
//  don't include self
//
//==========================================================================
final void A_JumpIfRadiusAmountGreater (float radius, int amount, class!Actor checkClass, state label, optional bool exact) {
  if (XLevel.StateCall) XLevel.StateCall->Result = false;

  if (radius < 0) return;
  if (!checkClass) return;
  if (amount < 1) { DoJump(label); return; }

  Entity e;
  if (exact) {
    foreach RadiusThings(e, Origin, radius) {
      if (e.Class == checkClass) {
        if (e != self) {
          if (!(--amount)) { DoJump(label); return; }
        }
      }
    }
  } else {
    //print("=============");
    foreach RadiusThings(e, Origin, radius) {
      //print("   %C", e);
      if (e isa checkClass) {
        if (e != self) {
          if (!(--amount)) {
            //print("%C: radius %s; check %C; hit it!", self, radius, checkClass);
            DoJump(label);
            return;
          }
        }
      }
    }
  }
  //print("%C: check %C with raduis %s, at %s, %s left", self, checkClass, radius, Origin, amount);
}


//==========================================================================
//
//  A_SpawnParticle
//
//==========================================================================
final void A_SpawnParticle (string color1, optional int flags, optional int lifetime,
                            optional float size, optional float angle,
                            optional float xoff, optional float yoff, optional float zoff,
                            optional float velx, optional float vely, optional float velz,
                            optional float accelx, optional float accely, optional float accelz,
                            optional int startalpha, optional int fadestep, optional float sizestep)
{
/*
  if (!specified_lifetime) lifetime = 35;
  if (lifetime <= 0) return;
  if (!specified_startalpha) startalpha = 255;
  if (startalpha <= 0) return;
  int clr = ParseColour(color1);
  startalpha = clamp(startalpha, 0, 255);
  clr |= startalpha<<24;
  Level.ParticleEffect(
    count:1,
    type1:pt_fading,
    type2:0,
    origin:vector(Origin.x+xoff, Origin.y+yoff, Origin.z+zoff),
    orng:0,
    velocity:vector(velx, vely, velz),
    vrnd:0,
    acceleration:0,
    grav:0,
    colour:clr,
    duration:lifetime/35.0,
    ramp:clamp(fadestep, -1, 255),
    accelV:vector(accelx, accely, accelz)
  );
*/
}


//==========================================================================
//
//  A_JumpIfTracerCloser
//
//==========================================================================
final state A_JumpIfTracerCloser (float distance, state label, optional bool noz) {
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (!Tracer) return none;
  distance = fmax(0, distance);
  float dist = (noz ? DistTo(Tracer) : DistTo2(Tracer));
  if (dist < distance) {
    DoJump(label);
    return label;
  } else {
    return none;
  }
}


//==========================================================================
//
//  A_Warp
//
//==========================================================================
final bool A_Warp (int aptr, optional float xofs, optional float yofs, optional float zofs,
                    optional float angle, optional int flags, optional state success_state,
                    optional float heightoffset, optional float radiusoffset, optional float pitch)
{
  if (success_state) {
    if (XLevel.StateCall) XLevel.StateCall->Result = false;
  }

  EntityEx tgt;
  if (flags&WARPF_USETID) {
    tgt = (aptr ? EntityEx(Level.FindMobjFromTID(aptr, none)) : EntityEx(self));
  } else {
    tgt = EntityEx(DecorDoAAPtr('A_Warp', aptr));
  }
  if (!tgt) return false;

  EntityEx tomove = self;

  if (flags&WARPF_MOVEPTR) {
    //print("%C: A_Warp(WARPF_MOVEPTR) is not supported yet!", self);
    //return false;
    tomove = tgt;
  }


  TVec dest = tgt.Origin;

  if (flags&WARPF_ABSOLUTEPOSITION) {
    dest = vector(xofs, yofs, zofs);
    if (flags&WARPF_TOFLOOR) {
      //dest.z = tgt.FloorZ+zofs; //FIXME: is this right?
      sector_t *sec = XLevel.PointInSector(dest);
      dest.z = GetPlanePointZ(ref sec->floor, dest)+zofs;
    }
  } else {
    if (xofs || yofs || zofs) {
      if (flags&WARPF_ABSOLUTEOFFSET) {
        //FIXME: up is not right here?
        dest += vector(xofs, yofs, 0);
      } else {
        TVec fwd, right, up;
        AngleVectors(tgt.Angles, out fwd, out right, out up);
        dest += fwd*xofs;
        dest += right*yofs;
        //FIXME: up is not right here?
        //dir += up*zofs;
      }
    }
    //FIXME: up is not right here?
    if (flags&WARPF_TOFLOOR) {
      //dest.z = tgt.FloorZ+zofs; //FIXME: is this right?
      sector_t *sec = XLevel.PointInSector(dest);
      dest.z = GetPlanePointZ(ref sec->floor, dest)+zofs;
    } else {
      dest.z += zofs;
    }
  }

  dest += vector(tgt.Radius*radiusoffset, tgt.Radius*radiusoffset, tgt.Height*heightoffset);

  TAVec newa = tomove.Angles;
  if (!(flags&WARPF_USECALLERANGLE)) newa.yaw = tgt.Angles.yaw;

  if (flags&WARPF_ABSOLUTEANGLE) {
    newa.yaw = AngleMod360(angle);
  } else {
    newa.yaw = AngleMod360(newa.yaw+angle);
  }

  if (flags&WARPF_COPYPITCH) {
    newa.pitch = pitch;
  } else {
    newa.pitch += pitch;
  }

  if (!(flags&WARPF_NOCHECKPOSITION)) {
    if (!tomove.CheckPosition(dest)) return false;
  }

  if (flags&WARPF_TESTONLY) return true;

  //print("A_Warp: src=%C; tgt=%C; heightoffset=%s; flags=0x%08x; pitch=%s; angles=%s; apitch=%s; newapitch=%s", self, tgt, heightoffset, flags, pitch, tomove.Angles, Angles.pitch, newa.pitch);

  tomove.UnlinkFromWorld();
  tomove.Origin = dest;
  tomove.Angles = newa;
  tomove.LinkToWorld();

       if (flags&WARPF_STOP) tomove.Velocity = vector(0, 0, 0);
  else if (flags&WARPF_COPYVELOCITY) tomove.Velocity = tgt.Velocity;

  if (success_state) {
    DoJump(success_state);
  }

  return true;
}


//==========================================================================
//
//  A_k8MoveBy
//
//==========================================================================
final void A_k8MoveBy (optional float dx, optional float dy, optional float dz) {
  if (!dx.isfinite || !dy.isfinite || !dz.isfinite) return;
  // so link the thing into its new position
  if (dx || dy) UnlinkFromWorld();
  Origin.x += dx;
  Origin.y += dy;
  Origin.z += dz;
  if (dx || dy) LinkToWorld(properFloorCheck:true);
}


//==========================================================================
//
//  A_k8MoveTo
//
//==========================================================================
final void A_k8MoveTo (optional float nx, optional float ny, optional float nz) {
  if (!nx.isfinite || !ny.isfinite || !nz.isfinite) return;
  // so link the thing into its new position
  if (specified_nx || specified_ny) UnlinkFromWorld();
  if (specified_nx) Origin.x = nx;
  if (specified_ny) Origin.y = ny;
  if (specified_nz) Origin.z = nz;
  if (specified_nx || specified_ny) LinkToWorld(properFloorCheck:true);
}


//==========================================================================
//
//  common_k8JumpIfLiquidFloor
//
//==========================================================================
final bool common_k8JumpIfLiquidFloor (EntityEx tgt, state label) {
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (!tgt) return false;
  if (!tgt.Sector) return false; // just in case
  if (IsAnimatedTexture(tgt.Sector.floor.pic)) {
    //print("ANIM FLOOR: %s", GetTextureName(tgt.Sector.floor.pic));
    DoJump(label);
    return true;
  }
  auto tname = string(GetTextureName(tgt.Sector.floor.pic));
  if (globmatch(tname, "*water*", caseSensitive:false) ||
      globmatch(tname, "*nukage*", caseSensitive:false) ||
      globmatch(tname, "*lava*", caseSensitive:false) ||
      globmatch(tname, "*blood*", caseSensitive:false) ||
      globmatch(tname, "*slime*", caseSensitive:false) ||
      globmatch(tname, "*slimage*", caseSensitive:false) ||
      globmatch(tname, "f_watr*", caseSensitive:false)) // Strife water
  {
    DoJump(label);
    return true;
  }
  return false;
}


//==========================================================================
//
//  A_k8JumpIfLiquidFloor
//
//==========================================================================
final bool A_k8JumpIfLiquidFloor (state label, optional int aptr) {
  // state jumps should not affect state chain results
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfLiquidFloor', aptr!optional));
  return common_k8JumpIfLiquidFloor(tgt, label);
}


//==========================================================================
//
//  A_k8JumpIfOnLiquidFloor
//
//==========================================================================
final bool A_k8JumpIfOnLiquidFloor (state label, optional int aptr) {
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfOnLiquidFloor', aptr!optional));
  if (!tgt) return false;
  if (!tgt.Sector) return false; // just in case
  if (tgt.Origin.z > tgt.FloorZ) return false;
  return common_k8JumpIfLiquidFloor(tgt, label);
}


//==========================================================================
//
//  A_k8JumpIfOnFloorSky
//
//==========================================================================
final bool A_k8JumpIfOnFloorSky (state label, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfSkyFloor', aptr!optional));
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (!tgt) return false;
  if (!tgt.Sector) return false; // just in case
  if (tgt.Origin.z > tgt.FloorZ) return false;
  if (tgt.Sector.floor.pic == Level.Game.skyflatnum) {
    //print("ANIM FLOOR: %s", GetTextureName(tgt.Sector.floor.pic));
    DoJump(label);
    return true;
  }
  return false;
}


//==========================================================================
//
//  A_k8JumpIfFloorSky
//
//==========================================================================
final bool A_k8JumpIfFloorSky (state label, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfSkyFloor', aptr!optional));
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (!tgt) return false;
  if (!tgt.Sector) return false; // just in case
  if (tgt.Sector.floor.pic == Level.Game.skyflatnum) {
    //print("ANIM FLOOR: %s", GetTextureName(tgt.Sector.floor.pic));
    DoJump(label);
    return true;
  }
  return false;
}


//==========================================================================
//
//  A_k8JumpIfCeilingSky
//
//==========================================================================
final bool A_k8JumpIfCeilingSky (state label, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfSkyFloor', aptr!optional));
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (!tgt) return false;
  if (!tgt.Sector) return false; // just in case
  if (tgt.Sector.ceiling.pic == Level.Game.skyflatnum) {
    //print("ANIM FLOOR: %s", GetTextureName(tgt.Sector.floor.pic));
    DoJump(label);
    return true;
  }
  return false;
}
