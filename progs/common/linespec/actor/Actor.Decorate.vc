//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//**
//**  Class for Actor state action methods.
//**
//**************************************************************************

// flags for A_Remove*
enum /*ERemoveFlags*/ {
  RMVF_MISSILES   = 0x00000001,
  RMVF_NOMONSTERS = 0x00000002,
  RMVF_MISC       = 0x00000004,
  RMVF_EVERYTHING = 0x00000008,
  RMVF_EXFILTER   = 0x00000010,
  RMVF_EXSPECIES  = 0x00000020,
  RMVF_EITHER     = 0x00000040,
};

// flags for A_RadiusGive
enum /*ERadiusGiveFlags*/ {
  RGF_GIVESELF  = 1,
  RGF_PLAYERS   = 1<<1,
  RGF_MONSTERS  = 1<<2,
  RGF_OBJECTS   = 1<<3,
  RGF_VOODOO    = 1<<4,
  RGF_CORPSES   = 1<<5,
  RGF_NOTARGET  = 1<<6,
  RGF_NOTRACER  = 1<<7,
  RGF_NOMASTER  = 1<<8,
  RGF_CUBE      = 1<<9,
  RGF_NOSIGHT   = 1<<10,
  RGF_MISSILES  = 1<<11,
  RGF_INCLUSIVE = 1<<12,
  RGF_ITEMS     = 1<<13,
  RGF_KILLED    = 1<<14,
  RGF_EXFILTER  = 1<<15,
  RGF_EXSPECIES = 1<<16,
  RGF_EITHER    = 1<<17,
};


enum /*WARPF*/ {
  WARPF_ABSOLUTEOFFSET    = 0x1,
  WARPF_ABSOLUTEANGLE     = 0x2,
  WARPF_USECALLERANGLE    = 0x4,

  WARPF_NOCHECKPOSITION   = 0x8,

  WARPF_INTERPOLATE       = 0x10,
  WARPF_WARPINTERPOLATION = 0x20,
  WARPF_COPYINTERPOLATION = 0x40,

  WARPF_STOP              = 0x80,
  WARPF_TOFLOOR           = 0x100,
  WARPF_TESTONLY          = 0x200,
  WARPF_ABSOLUTEPOSITION  = 0x400,
  WARPF_BOB               = 0x800,
  WARPF_MOVEPTR           = 0x1000,
  WARPF_USEPTR            = 0x2000,
  WARPF_USETID            = 0x2000,
  WARPF_COPYVELOCITY      = 0x4000,
  WARPF_COPYPITCH         = 0x8000,
};

// Flags for GetZAt
enum /*EZFlags*/ {
  GZF_ABSOLUTEPOS =     1,      // Use the absolute position instead of an offsetted one.
  GZF_ABSOLUTEANG =     1 << 1,   // Don't add the actor's angle to the parameter.
  GZF_CEILING =         1 << 2,   // Check the ceiling instead of the floor.
  GZF_3DRESTRICT =      1 << 3,   // Ignore midtextures and 3D floors above the pointer's z.
  GZF_NOPORTALS =       1 << 4,   // Don't pass through any portals.
  GZF_NO3DFLOOR =       1 << 5,   // Pass all 3D floors.
};


// flags for A_QuakeEx are in `QuakeFocusEx`


//==========================================================================
//
//  A_k8ConLog
//
//==========================================================================
final void decorate_A_k8ConLog (string msg) {
  if (msg) print("DECORATE LOG: %s", msg);
}


//==========================================================================
//
//  A_RetDoJump
//
//==========================================================================
final void decorate_A_RetDoJump (state State) {
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
       if (XLevel.StateCall) XLevel.StateCall->State = State;
  else if (bIsPlayer && XLevel.CallingState == Player.ViewStates[PS_WEAPON].State) Player.SetViewState(PS_WEAPON, State);
  else if (bIsPlayer && XLevel.CallingState == Player.ViewStates[PS_FLASH].State) Player.SetViewState(PS_FLASH, State);
  else if (bIsPlayer && XLevel.CallingState == Player.ViewStates[PS_WEAPON_OVL].State) Player.SetViewState(PS_WEAPON_OVL, State);
  else SetState(State);
}


//==========================================================================
//
//  decorate_GetArg
//
//==========================================================================
final int decorate_GetArg (int n) {
  return (n >= 0 && n < 5 ? Args[n] : 0);
}


//==========================================================================
//
//  A_SetArg
//
//==========================================================================
final void A_SetArg (int n, int v) {
  if (n >= 0 && n < 5) Args[n] = v;
}


//==========================================================================
//
//  A_SetAngle
//
//==========================================================================
final void A_SetAngle (float newyaw, optional int flags, optional int aptr) {
  Entity tgt = DecorDoAAPtr('A_SetAngle', aptr!optional);
  if (!tgt) return;
  tgt.Angles.yaw = AngleMod360(newyaw);
  //dprint("A_SetAngle: not implemented!");
}


/*
const int SPF_FORCECLAMP = 0x01;
const int SPF_INTERPOLATE = 0x00;
*/

//==========================================================================
//
//  clampPitch
//
//==========================================================================
private final float clampPitch (float newpitch) {
  // hack, so player head won't be clamped down
  //print("  A_SetPitch00: newpitch=%f", newpitch);
  if (newpitch >= 360) {
    newpitch = AngleMod360(newpitch);
    //print("  A_SetPitch01: newpitch=%f", newpitch);
  }
  if (newpitch > 180) newpitch = AngleMod360(newpitch)-360; // [-90..]
  //print("  A_SetPitch02: newpitch=%f", newpitch);
  //return fclamp(newpitch, -90.0, 90.0);
  return fclamp(newpitch, -80.0, 80.0); // actual engine limits
}


//==========================================================================
//
//  A_SetPitch
//
//  should be always clamped on player
//
//==========================================================================
final void A_SetPitch (float newpitch, optional int flags, optional int aptr) {
  Entity tgt = DecorDoAAPtr('A_SetPitch', aptr!optional);
  if (!tgt) return;
  if (tgt.bIsPlayer || (flags&0x01) != 0) newpitch = clampPitch(newpitch);
  tgt.Angles.pitch = /*AngleMod360*/(newpitch);
}


//==========================================================================
//
//  A_SetRoll
//
//==========================================================================
final void A_SetRoll (float newroll, optional int flags, optional int aptr) {
  Entity tgt = DecorDoAAPtr('A_SetRoll', aptr!optional);
  if (!tgt) return;
  tgt.Angles.roll = AngleMod360(newroll);
}


//==========================================================================
//
//  ACS_Execute
//
//==========================================================================
final bool ACS_Execute (int script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunACS(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_ExecuteAlways
//
//==========================================================================
final bool ACS_ExecuteAlways (int script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunACSAlways(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_ExecuteWithResult
//
//==========================================================================
final int ACS_ExecuteWithResult (int script, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunACSWithResult(self, script, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_NamedExecute
//
//==========================================================================
final bool ACS_NamedExecute (string script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunNamedACS(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_NamedExecuteAlways
//
//==========================================================================
final bool ACS_NamedExecuteAlways (string script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  //print("ACS_NamedExecuteAlways: script=%s; map=%d; args=(%d,%d,%d,%d)", script, map, s_arg1, s_arg2, s_arg3, s_arg4);
  return XLevel.RunNamedACSAlways(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_NamedExecuteWithResult
//
//==========================================================================
final int ACS_NamedExecuteWithResult (string script, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunNamedACSWithResult(self, script, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  decorate_CountInv
//
//==========================================================================
final int decorate_CountInv (name ItemName, optional int aptr) {
  Entity tgt = DecorDoAAPtr('decorate_CountInv', aptr!optional);
  if (!tgt) return 0;
  return tgt.CheckInventory(ItemName, allowReplacement:true);
}


//==========================================================================
//
//  decorate_GetZAt
//
//==========================================================================
//[float x[, float y[, float angle[, int flags[, int pick_pointer]]]]]
final float decorate_GetZAt (optional float x, optional float y, optional float angle, optional int flags, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('decorate_GetZAt', aptr!optional));
  if (!tgt) return (flags&GZF_CEILING ? CeilingZ : FloorZ);

  TVec org = tgt.Origin;
  if (flags&GZF_ABSOLUTEPOS) {
    org = vector(x, y);
  } else {
    TAVec ang = tgt.Angles;
    if (!(flags&GZF_ABSOLUTEANG)) ang.yaw += angle;
    ang.pitch = 0;
    ang.roll = 0;
    TVec forward;
    TVec right;
    TVec up;

    AngleVectors(ang, out forward, out right, out up);
    org = tgt.Origin;
    org += forward*x;
    org += right*y;
  }

  if (flags&GZF_NO3DFLOOR) {
    sector_t *sec = XLevel.PointInSector(org);
    if (flags&GZF_CEILING) {
      return GetPlanePointZ(ref sec->ceiling, org);
    } else {
      return GetPlanePointZ(ref sec->floor, org);
    }
  } else if ((flags&(GZF_CEILING|GZF_3DRESTRICT)) == (GZF_CEILING|GZF_3DRESTRICT)) {
    //k8: this is prolly not right
    sector_t *sec = XLevel.PointInSector(org);
    return GetPlanePointZ(ref sec->ceiling, org);
  } else {
    tmtrace_t tmtrace;
    tgt.GetFloorAndCeilingEx(out tmtrace, org, collideWorld:true, collideThings:false);
    return (flags&GZF_CEILING ? tmtrace.CeilingZ : tmtrace.FloorZ);
  }
}


//==========================================================================
//
//  decorate_GetDistance
//
//==========================================================================
//float GetDistance (bool checkz [, int ptr_select])
final float decorate_GetDistance (bool checkz, optional int aptr) {
  Entity tgt = DecorDoAAPtr('decorate_GetDistance', aptr!optional);
  if (!tgt) return 0;
  if (tgt == self) return 0;
  return (checkz ? DistTo(tgt) : DistTo2(tgt));
}


//==========================================================================
//
//  decorate_GetAngle
//
//==========================================================================
//float GetAngle (int flags[, int ptr_select])
final float decorate_GetAngle (optional int flags, optional int aptr) {
  if (!specified_aptr || aptr == AAPTR_DEFAULT) aptr = AAPTR_TARGET;
  Entity tgt = DecorDoAAPtr('decorate_GetAngle', aptr);
  if (!tgt) return 0;
  if (tgt == self) return 0;
  float ang = (flags&2 ?
    atan2(Origin.y-tgt.Origin.y, Origin.x-tgt.Origin.x) : // from target to self
    atan2(tgt.Origin.y-Origin.y, tgt.Origin.x-Origin.x)); // from self to target
  if (flags&1) {
    // relative
    ang = AngleDiff(ang, (flags&2 ? tgt.Angles.yaw : Angles.yaw));
  }
  return ang;
}


//==========================================================================
//
//  A_SpawnProjectile
//
//==========================================================================
final void A_SpawnProjectile (name MissileTypeName, optional float SpawnHeight, optional float SpawnXYOffset,
                              optional float Angle, optional int AimMode, optional float Pitch, optional int aptr)
{
  if (!MissileTypeName) return;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_SpawnProjectile', aptr!optional));
  if (!tgt) return;

  int Flags = AimMode&~3;
  AimMode &= 3;

  class!EntityEx MissileType = class!EntityEx(FindClassNoCase(MissileTypeName));
  if (!MissileType) return;
  MissileType = class!EntityEx(GetClassReplacement(MissileType));
  if (!MissileType) return;
  //if (Level.Game.nomonsters && MissileType.default.bMonster) return;

  if (tgt.Target || AimMode == 2) {
    if (MissileType) {
      if (!specified_SpawnHeight) SpawnHeight = 32.0;
      if (!specified_SpawnXYOffset) SpawnXYOffset = 0; // was 1, why?
      TVec Offs = float(SpawnXYOffset)*vector(cos(tgt.Angles.yaw-90.0), sin(tgt.Angles.yaw-90.0), 0.0);
      EntityEx A;

      switch (AimMode) {
        default:
          tgt.Origin += Offs;
          A = tgt.SpawnMissile(tgt.Target, MissileType, SpawnHeight);
          tgt.Origin -= Offs;
          break;
        case 1:
          Offs.z = SpawnHeight;
          A = tgt.SpawnMissileXYZ(tgt.Origin+Offs, tgt.Target, MissileType);
          break;
        case 2:
          tgt.Origin += Offs;
          A = tgt.SpawnMissileAngles(MissileType, tgt.Angles.yaw, Pitch, SpawnHeight);
          tgt.Origin -= Offs;
          break;
      }

      if (A) {
        VectorRotateAroundZ(ref A.Velocity, Angle);
        // find correct shooter for projectiles shooting projectiles
        if (tgt.IsMissile(!!(Flags&4))) {
          EntityEx Own = tgt/*self*/;
          while (Own.IsMissile(!!(Flags&4)) && Own.Target) Own = Own.Target;
          A.Target = Own;
          if (A.bSeekerMissile) A.Tracer = tgt.Tracer;
        } else if (A.bSeekerMissile) {
          A.Tracer = tgt.Target;
        }
      }
    }
  } else if (Flags&8) {
    if (tgt.SeeState) tgt.SetState(tgt.SeeState);
  }
}


//===========================================================================
//
//  A_Quake
//
//===========================================================================
final bool A_Quake (float intensity, float ticduration, float damrad, float tremrad, optional name soundname) {
  if (ticduration < 1) return false;
  if (damrad < 1 && tremrad < 1) return false;
  damrad = fmax(0, damrad);
  tremrad = fmax(0, tremrad);
  if (intensity < 1) return false;
  intensity = fmin(intensity, 9);
  QuakeFocus focus = Spawn(QuakeFocus, Origin);
  if (focus) {
    focus.Richters = int(intensity);
    focus.QuakeDuration = int(ticduration)>>1; // decremented every 2 tics
    focus.DamageRadius = damrad;
    focus.TremorRadius = tremrad;
    //if (soundname) PlaySound(soundname, CHAN_AUTO);
    focus.SoundName = soundname;
    return true;
  }
  return false;
}


//===========================================================================
//
//  A_QuakeEx
//
//  radii are in map units
//
//===========================================================================
final bool A_QuakeEx (float intensityX, float intensityY, float intensityZ, float ticduration, float damrad, float tremrad,
                      optional name soundname, optional int flags, optional float mulwavex, optional float mulwavey, optional float mulwavez,
                      optional int falloff, optional int highpoint, optional float rollIntensity, optional float rollWave)
{
  if (ticduration < 1) return false;
  if (damrad < 1 && tremrad < 1) return false;
  damrad = fmax(0, damrad);
  tremrad = fmax(0, tremrad);
  if (intensityX < 1 && intensityY < 1 && intensityZ < 1) return false;
  intensityX = fmin(intensityX, 9);
  intensityY = fmin(intensityY, 9);
  intensityZ = fmin(intensityZ, 9);
  QuakeFocusEx focus = Spawn(QuakeFocusEx, Origin);
  if (focus) {
    focus.Richters = vector(int(intensityX), int(intensityY), int(intensityZ));
    focus.QuakeDuration = int(ticduration)>>1; // decremented every 2 tics
    focus.DamageRadius = damrad;
    focus.TremorRadius = tremrad;
    //if (soundname) PlaySound(soundname, CHAN_AUTO);
    focus.SoundName = soundname;
    focus.Flags = flags;
    focus.MulWave = vector(mulwavex, mulwavey, mulwavez);
    focus.Falloff = fmax(0, falloff);
    focus.HighPoint = fmax(0, highpoint);
    return true;
  }
  return false;
}


//==========================================================================
//
//  decorate_A_CheckFlag
//
//==========================================================================
final void decorate_A_CheckFlag (string flagname, state label, optional int aptr) {
  // state jumps should not affect state chain results
  //print("A_CheckFlag: name=<%s>; label=<%s>; aptr=%s", flagname, label, aptr);
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_CheckFlag', aptr!optional));
  if (!tgt) return;
  //if (!decoDoCheckFlag(flagname, tgt)) return;
  if (!tgt.GetDecorateFlag(flagname)) return;
  DoJump(label);
}


//==========================================================================
//
//  decorate_A_ChangeFlag
//
//==========================================================================
/*
final void decorate_A_ChangeFlag (string flagname, int value) {
  //decoDoFlagAction(flagname, self, !!value);
  print("A_ChangeFlag: name=<%s>; value=%s", flagname, value);
  //print("  nopain0=%s", bNoPain);
  decoDoSetFlag(flagname, self, !!value);
  //print("  nopain1=%s", bNoPain);
}
*/


//==========================================================================
//
//  decorate_A_DamageSelf
//
//==========================================================================
final void decorate_A_DamageSelf (int amount, optional name damagetype, optional int flags, optional name filter, optional name species, optional int src, optional int inflict) {
  if (flags) { print("DECORATE: A_DamageSelf with `flags` is not supported yet!"); }
  if (specified_filter) { print("DECORATE: A_DamageSelf with `filter` is not supported yet!"); }
  if (specified_species) { print("DECORATE: A_DamageSelf with `species` is not supported yet!"); }
  if (specified_src) { print("DECORATE: A_DamageSelf with `src` is not supported yet!"); }
  if (specified_inflict) { print("DECORATE: A_DamageSelf with `inflict` is not supported yet!"); }
  if (amount == 0) return;
  Damage(inflictor:self, source:self, amount, DmgType:damagetype!optional);
}


//==========================================================================
//
//  decorate_A_SetTics
//
//==========================================================================
final void decorate_A_SetTics (int tics) {
  tics = max(tics, 0);
  StateTime = float(tics)/35.0;
}


//==========================================================================
//
//  decorate_A_CheckFloorTextureGlob
//
//==========================================================================
final void decorate_A_CheckFloorTextureGlob (string txname, state label, optional int aptr, optional bool dumpTexture) {
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_CheckFloorTexture', aptr!optional));
  if (!tgt) return;
  if (!tgt.Sector) return; // just in case
  auto tname = GetTextureName(tgt.Sector.floor.pic);
  if (dumpTexture) print("TEXTURE NAME: <%s> gmatch <%s>: res=%B", tname, txname, globmatch(string(tname), txname, caseSensitive:false));
  if (!globmatch(string(tname), txname, caseSensitive:false)) return;
  DoJump(label);
}


//==========================================================================
//
//  A_DropItem
//
//==========================================================================
final void A_DropItem (name item, optional int dropamount, optional int chance) {
  if (!item) return;

  float dropChance = 1;
  if (specified_chance) {
    if (chance <= 0) return;
    if (chance < 256) dropChance = float(chance)/256.0;
  }

  class!EntityEx dip = class!EntityEx(FindClassNoCase(item));
  if (!dip) return;
  dip = class!EntityEx(GetClassReplacement(dip));
  if (!dip) return;

  if (specified_dropamount) {
    if (dip !isa Inventory) dropamount = 1;
  } else {
    dropamount = 1;
  }

  DropItem(dip, dropamount, dropChance);
}


//==========================================================================
//
//  a_removechildren_checkIfChildShouldBeRemoved
//
//==========================================================================
final private bool a_removechildren_checkIfChildShouldBeRemoved (Actor child, bool all, int flags, string filter, string species) {
  if (!all && child.Health > 0) return false; // it is still alive
  bool filterHit = true, speciesHit = true;
  if (filter) {
    filterHit = (stricmp(filter, string(GetClassName(child.Class))) != 0);
    if (flags&RMVF_EXFILTER) filterHit = !filterHit; // filter inverted
  }
  if (species) {
    speciesHit = (stricmp(species, string(child.GetSpecies())) != 0);
    if (flags&RMVF_EXSPECIES) speciesHit = !speciesHit; // species inverted
  }
  if (flags&RMVF_EITHER) {
    if (!filterHit && !speciesHit) return false;
  } else {
    if (!filterHit || !speciesHit) return false;
  }
  // check other flags
  if (!(flags&RMVF_EVERYTHING)) {
    if (child.bMonster) {
      // monster?
      if (flags&RMVF_NOMONSTERS) return false;
    } else if (child.IsMissile(false)) { // or precise?
      // missile?
      if (!(flags&RMVF_MISSILES)) return false;
    } else {
      // other?
      if (!(flags&RMVF_MISC)) return false;
    }
  }
  return true;
}


#ifdef VC_SCRIPT_USE_SPAWNED_CHILDREN_ARRAY
#else
// this is trick so `delete` will clear the array for us
transient private array!Actor A_RC_KillList;
#endif

//==========================================================================
//
//  A_RemoveChildren
//
//==========================================================================
final void A_RemoveChildren (optional bool all, optional int flags, optional string filter, optional string species) {
  if (stricmp(filter, "none") == 0) filter = "";
  if (stricmp(species, "none") == 0) species = "";

#ifdef VC_SCRIPT_USE_SPAWNED_CHILDREN_ARRAY
  foreach (auto idx; 0..SpawnedChildren.length) {
    Actor child = Actor(SpawnedChildren[idx]);
    if (!child) continue;
    if (!a_removechildren_checkIfChildShouldBeRemoved(child, all, flags, filter, species)) continue;
    // kill it!
    //print("%C: removing children #%d (%C)", self, idx, SpawnedChildren[idx]);
    delete SpawnedChildren[idx];
  }

  // shrink array
  /*
  foreach (auto idx; 0..SpawnedChildren.length; reverse) {
    if (SpawnedChildren[idx]) {
      if (idx+1 < SpawnedChildren.length) SpawnedChildren.length = idx+1;
      break;
    }
  }
  */
#else
  //array!Actor A_RC_KillList;
  A_RC_KillList.clear(); // clear, but don't reallocate
  Actor th;
  foreach AllThinkers(Actor, th) {
    if (th && th.SpawnParent == self && a_removechildren_checkIfChildShouldBeRemoved(th, all, flags, filter, species)) A_RC_KillList[$] = th;
  }
  foreach (auto idx; 0..A_RC_KillList.length) {
    th = A_RC_KillList[idx];
    if (th) {
      //print("%C: removing children #%d (%C)", self, idx, th);
      delete th;
    }
  }
  A_RC_KillList.clear(); // clear, but don't reallocate
#endif
}


//==========================================================================
//
//  A_RadiusGive
//
//==========================================================================
final int A_RadiusGive (name itemname, float distance, int flags, optional int amount, optional string filter, optional string species, optional float mindist, optional int limit) {
  if (!specified_limit) limit = int.max;
  if (limit < 1) return 0;

  if (amount < 0) return 0;
  amount = max(1, amount); // 0 is 1 anyway

  if (distance <= 0) return 0; // as per docs
  if (mindist > distance) return 0;

  // find item class
  if (!itemname) return 0;
  class!Inventory itemtype = class!Inventory(FindClassNoCase(itemname));
  if (!itemtype) return 0;
  itemtype = class!Inventory(GetClassReplacement(itemtype));
  if (!itemtype) return 0;

  // fix filters
  if (stricmp(filter, "none") == 0) filter = "";
  if (stricmp(species, "none") == 0) species = "";

  bool giveCube = (flags&RGF_CUBE);
  int count = 0;
  Entity enti;
  foreach RadiusThings(enti, Origin, distance*(giveCube ? 2.0 : 1.0)) {
    EntityEx ent = EntityEx(enti);
    if (!ent) continue;
    if (ent == self) {
      if (!(flags&RGF_GIVESELF)) continue;
    } else {
      // check distance
      if (mindist > 0 && length2d(ent.Origin-Origin) > mindist) continue;
      if (giveCube) {
        // additional check for cube giver
        if (fabs(Origin.x-ent.Origin.x) > distance || fabs(Origin.y-ent.Origin.y) > distance) continue;
      }

      // check filters
      bool filterHit = true, speciesHit = true;
      if (filter) {
        filterHit = (stricmp(filter, string(GetClassName(ent.Class))) != 0);
        if (flags&RGF_EXFILTER) filterHit = !filterHit; // filter inverted
      }
      if (species) {
        speciesHit = (stricmp(species, string(ent.GetSpecies())) != 0);
        if (flags&RGF_EXSPECIES) speciesHit = !speciesHit; // species inverted
      }
      if (flags&RGF_EITHER) {
        if (!filterHit && !speciesHit) continue;
      } else {
        if (!filterHit || !speciesHit) continue;
      }

      if (ent.bCorpse && (flags&RGF_CORPSES)) {
        // do nothing, really
      } else {
        // check allowed flags
        if (ent.bIsPlayer) {
          // player
          if (ent.Player.PlayerState == PST_DEAD) continue;
          //if (ent.Player.bIsBot)
          if (ent.Player.MO != self) {
            // voodoo doll
            if (!(flags&RGF_VOODOO)) continue;
          } else {
            if (!(flags&RGF_PLAYERS)) continue;
          }
        } else if (ent.bMonster) {
          // monster
          if (!(flags&RGF_MONSTERS)) continue;
          if (ent.Health <= 0 && !(flags&RGF_KILLED)) continue;
        } else if (ent.bMissile) {
          // missile
          if (!(flags&RGF_MISSILES)) continue;
        } else {
          // other
          if (ent isa Inventory) {
            if (!(flags&RGF_ITEMS)) continue;
          } else {
            if (!(flags&RGF_OBJECTS)) continue;
            // should be either shootable or vulnerable
            if (!ent.bShootable && !ent.bNoDamage) continue;
          }
        }
      }

      // check NOxxx
      if (flags&(RGF_NOTARGET|RGF_NOTRACER|RGF_NOMASTER)) {
        if (flags&RGF_INCLUSIVE) {
          // should satisfy all
          bool isTarget = (flags&RGF_NOTARGET ? (Target == ent) : true);
          bool isTracer = (flags&RGF_NOTRACER ? (Tracer == ent) : true);
          bool isMaster = (flags&RGF_NOMASTER ? (Master == ent) : true);
          if (isTarget && isTracer && isMaster) continue;
        } else {
          bool isTarget = (flags&RGF_NOTARGET ? (Target == ent) : false);
          bool isTracer = (flags&RGF_NOTRACER ? (Tracer == ent) : false);
          bool isMaster = (flags&RGF_NOMASTER ? (Master == ent) : false);
          if (isTarget || isTracer || isMaster) continue;
        }
      }

      // sight check
      if (!(flags&RGF_NOSIGHT) && !CanSee(ent, disableBetterSight:true)) continue;
    }

    // it is ok to give an item
    if (DoGiveInventory(itemtype, amount, ent)) {
      ++count;
      if (count >= limit) break;
    }
  }

  return count;
}


//==========================================================================
//
//  decorate_CheckClass
//
//==========================================================================
final bool decorate_CheckClass (name classname, optional int ptr_select, optional bool match_superclass) {
  Entity tgt = DecorDoAAPtr('decorate_CheckClass', ptr_select!optional);
  if (!tgt) return false;
  if (!classname) return false;
  class!Entity tc = class!Entity(tgt.Class);
  while (tc) {
    if (nameicmp(GetClassName(tc), classname) == 0) return true;
    if (!match_superclass) break;
    tc = class!Entity(GetClassParent(tc));
  }
  return false;
}


//==========================================================================
//
//  A_JumpIfRadiusAmountGreater
//
//  don't include self
//
//==========================================================================
final void A_JumpIfRadiusAmountGreater (float radius, int amount, class!Actor checkClass, state label, optional bool exact) {
  if (XLevel.StateCall) XLevel.StateCall->Result = false;

  if (radius < 0) return;
  if (!checkClass) return;
  if (amount < 1) { DoJump(label); return; }

  Entity e;
  if (exact) {
    foreach RadiusThings(e, Origin, radius) {
      if (e.Class == checkClass) {
        if (e != self) {
          if (!(--amount)) { DoJump(label); return; }
        }
      }
    }
  } else {
    //print("=============");
    foreach RadiusThings(e, Origin, radius) {
      //print("   %C", e);
      if (e isa checkClass) {
        if (e != self) {
          if (!(--amount)) {
            //print("%C: radius %s; check %C; hit it!", self, radius, checkClass);
            DoJump(label);
            return;
          }
        }
      }
    }
  }
  //print("%C: check %C with raduis %s, at %s, %s left", self, checkClass, radius, Origin, amount);
}


//==========================================================================
//
//  A_SpawnParticle
//
//==========================================================================
final void A_SpawnParticle (string color1, optional int flags, optional int lifetime,
                            optional float size, optional float angle,
                            optional float xoff, optional float yoff, optional float zoff,
                            optional float velx, optional float vely, optional float velz,
                            optional float accelx, optional float accely, optional float accelz,
                            optional int startalpha, optional int fadestep, optional float sizestep)
{
/*
  if (!specified_lifetime) lifetime = 35;
  if (lifetime <= 0) return;
  if (!specified_startalpha) startalpha = 255;
  if (startalpha <= 0) return;
  int clr = ParseColor(color1);
  startalpha = clamp(startalpha, 0, 255);
  clr |= startalpha<<24;
  Level.ParticleEffect(
    count:1,
    type1:pt_fading,
    type2:0,
    origin:vector(Origin.x+xoff, Origin.y+yoff, Origin.z+zoff),
    orng:0,
    velocity:vector(velx, vely, velz),
    vrnd:0,
    acceleration:0,
    grav:0,
    color:clr,
    duration:lifetime/35.0,
    ramp:clamp(fadestep, -1, 255),
    accelV:vector(accelx, accely, accelz)
  );
*/
}


//==========================================================================
//
//  A_JumpIfTracerCloser
//
//==========================================================================
final state A_JumpIfTracerCloser (float distance, state label, optional bool noz) {
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (!Tracer) return none;
  distance = fmax(0, distance);
  float dist = (noz ? DistTo(Tracer) : DistTo2(Tracer));
  if (dist < distance) {
    DoJump(label);
    return label;
  } else {
    return none;
  }
}


//==========================================================================
//
//  A_Warp
//
//==========================================================================
final bool A_Warp (int aptr, optional float xofs, optional float yofs, optional float zofs,
                    optional float angle, optional int flags, optional state success_state,
                    optional float heightoffset, optional float radiusoffset, optional float pitch)
{
  if (success_state) {
    if (XLevel.StateCall) XLevel.StateCall->Result = false;
  }

  EntityEx tgt;
  if (flags&WARPF_USETID) {
    tgt = (aptr ? EntityEx(Level.FindMobjFromTID(aptr, none)) : EntityEx(self));
  } else {
    tgt = EntityEx(DecorDoAAPtr('A_Warp', aptr));
  }
  if (!tgt) return false;

  EntityEx tomove = self;

  if (flags&WARPF_MOVEPTR) {
    //print("%C: A_Warp(WARPF_MOVEPTR) is not supported yet!", self);
    //return false;
    tomove = tgt;
  }


  TVec dest = tgt.Origin;

  if (flags&WARPF_ABSOLUTEPOSITION) {
    dest = vector(xofs, yofs, zofs);
    if (flags&WARPF_TOFLOOR) {
      //dest.z = tgt.FloorZ+zofs; //FIXME: is this right?
      sector_t *sec = XLevel.PointInSector(dest);
      dest.z = GetPlanePointZ(ref sec->floor, dest)+zofs;
    }
  } else {
    if (xofs || yofs || zofs) {
      if (flags&WARPF_ABSOLUTEOFFSET) {
        //FIXME: up is not right here?
        dest += vector(xofs, yofs, 0);
      } else {
        TVec fwd, right, up;
        AngleVectors(tgt.Angles, out fwd, out right, out up);
        dest += fwd*xofs;
        dest += right*yofs;
        //FIXME: up is not right here?
        //dir += up*zofs;
      }
    }
    //FIXME: up is not right here?
    if (flags&WARPF_TOFLOOR) {
      //dest.z = tgt.FloorZ+zofs; //FIXME: is this right?
      sector_t *sec = XLevel.PointInSector(dest);
      dest.z = GetPlanePointZ(ref sec->floor, dest)+zofs;
    } else {
      dest.z += zofs;
    }
  }

  dest += vector(tgt.Radius*radiusoffset, tgt.Radius*radiusoffset, tgt.Height*heightoffset);

  TAVec newa = tomove.Angles;
  if (!(flags&WARPF_USECALLERANGLE)) newa.yaw = tgt.Angles.yaw;

  if (flags&WARPF_ABSOLUTEANGLE) {
    newa.yaw = AngleMod360(angle);
  } else {
    newa.yaw = AngleMod360(newa.yaw+angle);
  }

  if (flags&WARPF_COPYPITCH) {
    newa.pitch = pitch;
  } else {
    newa.pitch += pitch;
  }

  if (!(flags&WARPF_NOCHECKPOSITION)) {
    if (!tomove.CheckPosition(dest)) return false;
  }

  if (flags&WARPF_TESTONLY) return true;

  //print("A_Warp: src=%C; tgt=%C; heightoffset=%s; flags=0x%08x; pitch=%s; angles=%s; apitch=%s; newapitch=%s", self, tgt, heightoffset, flags, pitch, tomove.Angles, Angles.pitch, newa.pitch);

  tomove.bIntrJustMoved = !!(flags&WARPF_INTERPOLATE); // disable movement interpolation
  //tomove.LastMoveOrigin = tomove.Origin;
  //tomove.LastMoveAngles = tomove.Angles;
  //tomove.LastMoveTime = XLevel.Time;
  tomove.UnlinkFromWorld();
  tomove.Origin = dest;
  tomove.Angles = newa;
  tomove.LinkToWorld();

       if (flags&WARPF_STOP) tomove.Velocity = vector(0, 0, 0);
  else if (flags&WARPF_COPYVELOCITY) tomove.Velocity = tgt.Velocity;

  if (success_state) {
    DoJump(success_state);
  }

  return true;
}


//==========================================================================
// flags for A_CheckLOF

enum /*ELOFFlags*/ {
  CLOFF_NOAIM_VERT =      0x1,
  CLOFF_NOAIM_HORZ =      0x2,

  CLOFF_JUMPENEMY =     0x4,
  CLOFF_JUMPFRIEND =      0x8,
  CLOFF_JUMPOBJECT =      0x10,
  CLOFF_JUMPNONHOSTILE =    0x20,

  CLOFF_SKIPENEMY =     0x40,
  CLOFF_SKIPFRIEND =      0x80,
  CLOFF_SKIPOBJECT =      0x100,
  CLOFF_SKIPNONHOSTILE =    0x200,

  CLOFF_MUSTBESHOOTABLE =   0x400,

  CLOFF_SKIPTARGET =      0x800,
  CLOFF_ALLOWNULL =     0x1000,
  CLOFF_CHECKPARTIAL =    0x2000,

  CLOFF_MUSTBEGHOST =     0x4000,
  CLOFF_IGNOREGHOST =     0x8000,

  CLOFF_MUSTBESOLID =     0x10000,
  CLOFF_BEYONDTARGET =    0x20000,

  CLOFF_FROMBASE =      0x40000,
  CLOFF_MUL_HEIGHT =      0x80000,
  CLOFF_MUL_WIDTH =     0x100000,

  CLOFF_JUMP_ON_MISS =    0x200000,
  CLOFF_AIM_VERT_NOOFFSET = 0x400000,

  CLOFF_SETTARGET =     0x800000,
  CLOFF_SETMASTER =     0x1000000,
  CLOFF_SETTRACER =     0x2000000,

  CLOFF_SKIPOBSTACLES = CLOFF_SKIPENEMY|CLOFF_SKIPFRIEND|CLOFF_SKIPOBJECT|CLOFF_SKIPNONHOSTILE,
  CLOFF_NOAIM = CLOFF_NOAIM_VERT|CLOFF_NOAIM_HORZ
};


//==========================================================================
//
//  A_CheckLOF
//
//==========================================================================
final state A_CheckLOF (optional state jump, optional int flags, optional float range,
                        optional float minrange, optional float angle, optional float pitch,
                        optional float offsetheight, optional float offsetwidth,
                        optional int ptr_target, optional float offsetforward)
{
  // state jumps should not affect state chain results.
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (specified_minrange) {
    printwarn("A_CheckLOF is not fully implemented yet!");
    return none;
  }

  if (range <= 0) return none;

  EntityEx Targ;
  if (!bIsPlayer) {
    Targ = Aim(nullptr, range, Angles.yaw, noAutoaim:false, noVertAutoAim:false);
    if (!Targ || Targ != Target) return none;
  } else {
    // this is prolly called from weapon code, so target is what we have in player's crosshair
    TVec Dir;
    //Targ = Aim(Dir, distmax/*16.0*64.0*/); // old code
    bool noAAim = !PlayerEx(Player).bAutoAim, noAAVert = false;
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (Wpn && Wpn.IsAutoaimDisabled()) noAAim = true; //bNoAutoaim;
    //if (flags&JLOSF_NOAUTOAIM) noAAim = true;
    noAAVert = noAAim;
    Targ = Aim(nullptr, 8192/*16*64*/, Angles.yaw, noAutoaim:noAAim, noVertAutoAim:noAAVert);
    if (!Targ || !Targ.bShootable || !Targ.bMonster || Targ.Health <= 0) return none;
  }

  // just in case
  if (!Targ) return none;

  if (jump) DoJump(jump);
  return jump;

//final bool checkIfTargetInLOS (optional float Fov, optional int flags, optional float distmax, optional float distclose) {
/*
  name cvn = name(cvar);
  if (CvarExists(cvn)) {
    if (GetCvarB(cvn)) DoJump(Label);
  }
*/
#ifdef THIS_WILL_NEVER_BE_DEFINED_I_HOPE
  if (distmax == 0) distmax = 8192;
  Fov = fabs(Fov);

  // according to https://zdoom.org/wiki/A_JumpIfTargetInLOS
  if ((flags&JLOSF_PROJECTILE) && !bMissile) flags &= ~JLOSF_PROJECTILE;

  EntityEx Targ;
  if (!bIsPlayer) {
    Targ = Target;
    // according to https://zdoom.org/wiki/A_JumpIfTargetInLOS
         if (flags&JLOSF_CHECKMASTER) Targ = Master;
    else if (flags&JLOSF_CHECKTRACER) Targ = Tracer;
    else if (flags&JLOSF_PROJECTILE) Targ = (bSeekerMissile ? Tracer : none);
  } else {
    // this is prolly called from weapon code, so target is what we have in player's crosshair
    TVec Dir;
    //Targ = Aim(Dir, distmax/*16.0*64.0*/); // old code
    //k8: emulate autoaim in any case
    /*
    bool noAAim = !PlayerEx(Player).bAutoAim, noAAVert = false;
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (Wpn && Wpn.IsAutoaimDisabled()) noAAim = true; //bNoAutoaim;
    if (flags&JLOSF_NOAUTOAIM) noAAim = true;
    noAAVert = noAAim;
    */
    bool noAAim = !!(flags&JLOSF_NOAUTOAIM);
    bool noAAVert = noAAim;
    Targ = Aim(nullptr, 8192/*16*64*/, Angles.yaw, noAutoaim:noAAim, noVertAutoAim:noAAVert);
  }

  // moved here from `!bIsPlayer`
  if (!Targ) return false;

  // check target type flags before other, more expensive flags

  // combatant?
  if (flags&JLOSF_COMBATANTONLY) {
    if (!Targ.bIsPlayer && !Targ.bMonster) return false;
    if (Targ.bCorpse) return false; //k8: i added this too, as corpse is not a combatant
  }

  // dead?
  if ((flags&JLOSF_DEADNOJUMP) && Targ.Health <= 0) return false;

  // ally?
  if (flags&JLOSF_ALLYNOJUMP) {
    //FIXME: incomplete
    if (Targ == self || (bIsPlayer && Targ.bFriendly)) return false;
  }

  // check distance
  if (distclose > 0 && DistTo2(Targ) <= distclose) {
    // "close" in effect, fix flags and fov
    if (flags&JLOSF_CLOSENOJUMP) {
      // it doesn't matter what we'll do here, no jump will be taken
      return false;
    }
    if (flags&JLOSF_CLOSENOFOV) Fov = 0; // all-around vision
    if (flags&JLOSF_CLOSENOSIGHT) flags |= JLOSF_NOSIGHT;
  }

  // check sight
  if (!(flags&JLOSF_NOSIGHT)) {
    //k8: dunno, "better sight" should not be in effect here, i think
    if (flags&JLOSF_TARGETLOS) {
      if (!Targ.CanSee(self, disableBetterSight:true)) return false;
    } else {
      if (!CanSee(Targ, disableBetterSight:true)) return false;
    }
  }

  // check FOV
  if (Fov && Fov < 360.0) {
    if (flags&JLOSF_FLIPFOV) {
      // target fov
      float Ang = AngleMod180(atan2(Origin.y-Targ.Origin.y, Origin.x-Targ.Origin.x)-Targ.Angles.yaw);
      if (fabs(Ang) > Fov/2.0) return false;
    } else {
      // our fov
      float Ang = AngleMod180(atan2(Targ.Origin.y-Origin.y, Targ.Origin.x-Origin.x)-Angles.yaw);
      if (fabs(Ang) > Fov/2.0) return false;
    }
  }

  // all checks passed
  return true;
#endif
}


//==========================================================================
//
//  A_k8MoveBy
//
//==========================================================================
final void A_k8MoveBy (optional float dx, optional float dy, optional float dz) {
  if (!dx.isfinite || !dy.isfinite || !dz.isfinite) return;
  // so link the thing into its new position
  if (dx || dy) UnlinkFromWorld();
  Origin.x += dx;
  Origin.y += dy;
  Origin.z += dz;
  if (dx || dy) LinkToWorld(properFloorCheck:true);
  bIntrJustMoved = false; // disable movement interpolation
}


//==========================================================================
//
//  A_k8MoveTo
//
//==========================================================================
final void A_k8MoveTo (optional float nx, optional float ny, optional float nz) {
  if (!nx.isfinite || !ny.isfinite || !nz.isfinite) return;
  // so link the thing into its new position
  if (specified_nx || specified_ny) UnlinkFromWorld();
  if (specified_nx) Origin.x = nx;
  if (specified_ny) Origin.y = ny;
  if (specified_nz) Origin.z = nz;
  if (specified_nx || specified_ny) LinkToWorld(properFloorCheck:true);
  bIntrJustMoved = false; // disable movement interpolation
}


//==========================================================================
//
//  common_k8JumpIfLiquidFloor
//
//==========================================================================
final bool common_k8JumpIfLiquidFloor (EntityEx tgt, state label) {
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (!tgt) return false;
  if (!tgt.Sector) return false; // just in case
  if (IsAnimatedTexture(tgt.Sector.floor.pic)) {
    //print("ANIM FLOOR: %s", GetTextureName(tgt.Sector.floor.pic));
    DoJump(label);
    return true;
  }
  auto tname = string(GetTextureName(tgt.Sector.floor.pic));
  if (globmatch(tname, "*water*", caseSensitive:false) ||
      globmatch(tname, "*nukage*", caseSensitive:false) ||
      globmatch(tname, "*lava*", caseSensitive:false) ||
      globmatch(tname, "*blood*", caseSensitive:false) ||
      globmatch(tname, "*slime*", caseSensitive:false) ||
      globmatch(tname, "*slimage*", caseSensitive:false) ||
      globmatch(tname, "f_watr*", caseSensitive:false)) // Strife water
  {
    DoJump(label);
    return true;
  }
  return false;
}


//==========================================================================
//
//  A_k8JumpIfLiquidFloor
//
//==========================================================================
final bool A_k8JumpIfLiquidFloor (state label, optional int aptr) {
  // state jumps should not affect state chain results
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfLiquidFloor', aptr!optional));
  return common_k8JumpIfLiquidFloor(tgt, label);
}


//==========================================================================
//
//  A_k8JumpIfOnLiquidFloor
//
//==========================================================================
final bool A_k8JumpIfOnLiquidFloor (state label, optional int aptr) {
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfOnLiquidFloor', aptr!optional));
  if (!tgt) return false;
  if (!tgt.Sector) return false; // just in case
  if (tgt.Origin.z > tgt.FloorZ) return false;
  return common_k8JumpIfLiquidFloor(tgt, label);
}


//==========================================================================
//
//  A_k8JumpIfOnFloorSky
//
//==========================================================================
final bool A_k8JumpIfOnFloorSky (state label, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfSkyFloor', aptr!optional));
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (!tgt) return false;
  if (!tgt.Sector) return false; // just in case
  if (tgt.Origin.z > tgt.FloorZ) return false;
  if (tgt.Sector.floor.pic == Level.Game.skyflatnum) {
    //print("ANIM FLOOR: %s", GetTextureName(tgt.Sector.floor.pic));
    DoJump(label);
    return true;
  }
  return false;
}


//==========================================================================
//
//  A_k8JumpIfFloorSky
//
//==========================================================================
final bool A_k8JumpIfFloorSky (state label, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfSkyFloor', aptr!optional));
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (!tgt) return false;
  if (!tgt.Sector) return false; // just in case
  if (tgt.Sector.floor.pic == Level.Game.skyflatnum) {
    //print("ANIM FLOOR: %s", GetTextureName(tgt.Sector.floor.pic));
    DoJump(label);
    return true;
  }
  return false;
}


//==========================================================================
//
//  A_k8JumpIfCeilingSky
//
//==========================================================================
final bool A_k8JumpIfCeilingSky (state label, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfSkyFloor', aptr!optional));
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (!tgt) return false;
  if (!tgt.Sector) return false; // just in case
  if (tgt.Sector.ceiling.pic == Level.Game.skyflatnum) {
    //print("ANIM FLOOR: %s", GetTextureName(tgt.Sector.floor.pic));
    DoJump(label);
    return true;
  }
  return false;
}
