//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//**
//**  Class for Actor state action methods.
//**
//**************************************************************************

// flags for A_Remove*
enum /*ERemoveFlags*/ {
  RMVF_MISSILES   = 0x00000001,
  RMVF_NOMONSTERS = 0x00000002,
  RMVF_MISC       = 0x00000004,
  RMVF_EVERYTHING = 0x00000008,
  RMVF_EXFILTER   = 0x00000010,
  RMVF_EXSPECIES  = 0x00000020,
  RMVF_EITHER     = 0x00000040,
};

// flags for A_RadiusGive
enum /*ERadiusGiveFlags*/ {
  RGF_GIVESELF  = 1,
  RGF_PLAYERS   = 1<<1,
  RGF_MONSTERS  = 1<<2,
  RGF_OBJECTS   = 1<<3,
  RGF_VOODOO    = 1<<4,
  RGF_CORPSES   = 1<<5,
  RGF_NOTARGET  = 1<<6,
  RGF_NOTRACER  = 1<<7,
  RGF_NOMASTER  = 1<<8,
  RGF_CUBE      = 1<<9,
  RGF_NOSIGHT   = 1<<10,
  RGF_MISSILES  = 1<<11,
  RGF_INCLUSIVE = 1<<12,
  RGF_ITEMS     = 1<<13,
  RGF_KILLED    = 1<<14,
  RGF_EXFILTER  = 1<<15,
  RGF_EXSPECIES = 1<<16,
  RGF_EITHER    = 1<<17,
};


//==========================================================================
//
//  A_k8ConLog
//
//==========================================================================
final void decorate_A_k8ConLog (string msg) {
  if (msg) print("DECORATE LOG: %s", msg);
}


//==========================================================================
//
//  A_RetDoJump
//
//==========================================================================
final void decorate_A_RetDoJump (state State) {
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
       if (XLevel.StateCall) XLevel.StateCall->State = State;
  else if (bIsPlayer && XLevel.CallingState == Player.ViewStates[ps_weapon].State) Player.SetViewState(ps_weapon, State);
  else if (bIsPlayer && XLevel.CallingState == Player.ViewStates[ps_flash].State) Player.SetViewState(ps_flash, State);
  else SetState(State);
}


//==========================================================================
//
//  decorate_GetArg
//
//==========================================================================
final int decorate_GetArg (int n) {
  return (n >= 0 && n < 5 ? Args[n] : 0);
}


//==========================================================================
//
//  A_SetArg
//
//==========================================================================
final void A_SetArg (int n, int v) {
  if (n >= 0 && n < 5) Args[n] = v;
}


//==========================================================================
//
//  A_SetAngle
//
//==========================================================================
final void A_SetAngle (float newyaw, optional int flags, optional int aptr) {
  Entity tgt = DecorDoAAPtr('A_SetAngle', aptr!optional);
  if (!tgt) return;
  tgt.Angles.yaw = AngleMod360(newyaw);
  //dprint("A_SetAngle: not implemented!");
}


/*
const int SPF_FORCECLAMP = 0x01;
const int SPF_INTERPOLATE = 0x00;
*/

//==========================================================================
//
//  clampPitch
//
//==========================================================================
private final float clampPitch (float newpitch) {
  // hack, so player head won't be clamped down
  //print("  A_SetPitch00: newpitch=%f", newpitch);
  if (newpitch >= 360) {
    newpitch = AngleMod360(newpitch);
    //print("  A_SetPitch01: newpitch=%f", newpitch);
  }
  if (newpitch > 180) newpitch = AngleMod360(newpitch)-360; // [-90..]
  //print("  A_SetPitch02: newpitch=%f", newpitch);
  //return fclamp(newpitch, -90.0, 90.0);
  return fclamp(newpitch, -80.0, 80.0); // actual engine limits
}


//==========================================================================
//
//  A_SetPitch
//
//  should be always clamped on player
//
//==========================================================================
final void A_SetPitch (float newpitch, optional int flags, optional int aptr) {
  Entity tgt = DecorDoAAPtr('A_SetPitch', aptr!optional);
  if (!tgt) return;
  if (tgt.bIsPlayer || (flags&0x01) != 0) newpitch = clampPitch(newpitch);
  tgt.Angles.pitch = /*AngleMod360*/(newpitch);
}


//==========================================================================
//
//  A_SetRoll
//
//==========================================================================
final void A_SetRoll (float newroll, optional int flags, optional int aptr) {
  Entity tgt = DecorDoAAPtr('A_SetRoll', aptr!optional);
  if (!tgt) return;
  tgt.Angles.roll = AngleMod360(newroll);
}


//==========================================================================
//
//  ACS_Execute
//
//==========================================================================
final bool ACS_Execute (int script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunACS(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_ExecuteAlways
//
//==========================================================================
final bool ACS_ExecuteAlways (int script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunACSAlways(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_ExecuteWithResult
//
//==========================================================================
final int ACS_ExecuteWithResult (int script, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunACSWithResult(self, script, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_NamedExecute
//
//==========================================================================
final bool ACS_NamedExecute (string script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunNamedACS(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_NamedExecuteAlways
//
//==========================================================================
final bool ACS_NamedExecuteAlways (string script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  //print("ACS_NamedExecuteAlways: script=%s; map=%d; args=(%d,%d,%d,%d)", script, map, s_arg1, s_arg2, s_arg3, s_arg4);
  return XLevel.RunNamedACSAlways(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_NamedExecuteWithResult
//
//==========================================================================
final int ACS_NamedExecuteWithResult (string script, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunNamedACSWithResult(self, script, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  decorate_CountInv
//
//==========================================================================
final int decorate_CountInv (name ItemName, optional int aptr) {
  Entity tgt = DecorDoAAPtr('decorate_CountInv', aptr!optional);
  if (!tgt) return 0;
  return tgt.CheckInventory(ItemName);
}


//==========================================================================
//
//  A_SpawnProjectile
//
//==========================================================================
final void A_SpawnProjectile (name MissileTypeName, optional float SpawnHeight, optional float SpawnXYOffset,
                              optional float Angle, optional int AimMode, optional float Pitch, optional int aptr)
{
  if (!MissileTypeName) return;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_SpawnProjectile', aptr!optional));
  if (!tgt) return;

  int Flags = AimMode&~3;
  AimMode &= 3;

  class!EntityEx MissileType = class!EntityEx(FindClassNoCase(MissileTypeName));
  if (!MissileType) return;
  MissileType = class!EntityEx(GetClassReplacement(MissileType));
  if (!MissileType) return;
  //if (Level.Game.nomonsters && MissileType.default.bMonster) return;

  if (tgt.Target || AimMode == 2) {
    if (MissileType) {
      if (!specified_SpawnHeight) SpawnHeight = 32.0;
      if (!specified_SpawnXYOffset) SpawnXYOffset = 0; // was 1, why?
      TVec Offs = float(SpawnXYOffset)*vector(cos(tgt.Angles.yaw-90.0), sin(tgt.Angles.yaw-90.0), 0.0);
      EntityEx A;

      switch (AimMode) {
        default:
          tgt.Origin += Offs;
          A = tgt.SpawnMissile(tgt.Target, MissileType, SpawnHeight);
          tgt.Origin -= Offs;
          break;
        case 1:
          Offs.z = SpawnHeight;
          A = tgt.SpawnMissileXYZ(tgt.Origin+Offs, tgt.Target, MissileType);
          break;
        case 2:
          tgt.Origin += Offs;
          A = tgt.SpawnMissileAngles(MissileType, tgt.Angles.yaw, Pitch, SpawnHeight);
          tgt.Origin -= Offs;
          break;
      }

      if (A) {
        VectorRotateAroundZ(ref A.Velocity, Angle);
        // find correct shooter for projectiles shooting projectiles
        if (tgt.IsMissile(!!(Flags&4))) {
          EntityEx Own = tgt/*self*/;
          while (Own.IsMissile(!!(Flags&4)) && Own.Target) Own = Own.Target;
          A.Target = Own;
          if (A.bSeekerMissile) A.Tracer = tgt.Tracer;
        } else if (A.bSeekerMissile) {
          A.Tracer = tgt.Target;
        }
      }
    }
  } else if (Flags&8) {
    if (tgt.SeeState) tgt.SetState(tgt.SeeState);
  }
}


//===========================================================================
//
//  A_Quake
//
//===========================================================================
final bool A_Quake (float intensity, float ticduation, float damrad, float tremrad, optional name soundname) {
  if (ticduation < 1) return false;
  if (damrad < 1 && tremrad < 1) return false;
  damrad = fmax(0, damrad);
  tremrad = fmax(0, tremrad);
  if (intensity < 1) return false;
  if (intensity > 9) intensity = 9;
  QuakeFocus focus = Spawn(QuakeFocus, Origin);
  if (focus) {
    focus.Richters = int(intensity);
    focus.QuakeDuration = int(ticduation)>>1; // decremented every 2 tics
    focus.DamageRadius = damrad;
    focus.TremorRadius = tremrad;
    if (soundname) PlaySound(soundname, CHAN_AUTO);
    return true;
  }
  return false;
}


//==========================================================================
//
//  decorate_A_CheckFlag
//
//==========================================================================
final void decorate_A_CheckFlag (string flagname, state label, optional int aptr) {
  // state jumps should not affect state chain results
  //print("A_CheckFlag: name=<%s>; label=<%s>; aptr=%s", flagname, label, aptr);
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_CheckFlag', aptr!optional));
  if (!tgt) return;
  //if (!decoDoCheckFlag(flagname, tgt)) return;
  if (!tgt.GetDecorateFlag(flagname)) return;
  DoJump(label);
}


//==========================================================================
//
//  decorate_A_ChangeFlag
//
//==========================================================================
/*
final void decorate_A_ChangeFlag (string flagname, int value) {
  //decoDoFlagAction(flagname, self, !!value);
  print("A_ChangeFlag: name=<%s>; value=%s", flagname, value);
  //print("  nopain0=%s", bNoPain);
  decoDoSetFlag(flagname, self, !!value);
  //print("  nopain1=%s", bNoPain);
}
*/


//==========================================================================
//
//  decorate_A_DamageSelf
//
//==========================================================================
final void decorate_A_DamageSelf (int amount, optional name damagetype, optional int flags, optional name filter, optional name species, optional int src, optional int inflict) {
  if (flags) { print("DECORATE: A_DamageSelf with `flags` is not supported yet!"); }
  if (specified_filter) { print("DECORATE: A_DamageSelf with `filter` is not supported yet!"); }
  if (specified_species) { print("DECORATE: A_DamageSelf with `species` is not supported yet!"); }
  if (specified_src) { print("DECORATE: A_DamageSelf with `src` is not supported yet!"); }
  if (specified_inflict) { print("DECORATE: A_DamageSelf with `inflict` is not supported yet!"); }
  if (amount == 0) return;
  Damage(inflictor:self, source:self, amount, DmgType:damagetype!optional);
}


//==========================================================================
//
//  decorate_A_SetTics
//
//==========================================================================
final void decorate_A_SetTics (int tics) {
  tics = max(tics, 0);
  StateTime = float(tics)/35.0;
}


//==========================================================================
//
//  decorate_A_CheckFloorTextureGlob
//
//==========================================================================
final void decorate_A_CheckFloorTextureGlob (string txname, state label, optional int aptr, optional bool dumpTexture) {
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_CheckFloorTexture', aptr!optional));
  if (!tgt) return;
  if (!tgt.Sector) return; // just in case
  auto tname = GetTextureName(tgt.Sector.floor.pic);
  if (dumpTexture) print("TEXTURE NAME: <%s> gmatch <%s>: res=%B", tname, txname, globmatch(txname, string(tname), caseSensitive:false));
  if (!globmatch(txname, string(tname), caseSensitive:false)) return;
  DoJump(label);
}


//==========================================================================
//
//  A_DropItem
//
//==========================================================================
final void A_DropItem (name item, optional int dropamount, optional int chance) {
  if (!item) return;

  float dropChance = 1;
  if (specified_chance) {
    if (chance <= 0) return;
    if (chance < 256) dropChance = float(chance)/256.0;
  }

  class!EntityEx dip = class!EntityEx(FindClassNoCase(item));
  if (!dip) return;
  dip = class!EntityEx(GetClassReplacement(dip));
  if (!dip) return;

  if (specified_dropamount) {
    if (dip !isa Inventory) dropamount = 1;
  } else {
    dropamount = 1;
  }

  DropItem(dip, dropamount, dropChance);
}


//==========================================================================
//
//  a_removechildren_checkIfChildShouldBeRemoved
//
//==========================================================================
final private bool a_removechildren_checkIfChildShouldBeRemoved (Actor child, bool all, int flags, string filter, string species) {
  if (!all && child.Health > 0) return false; // it is still alive
  bool filterHit = true, speciesHit = true;
  if (filter) {
    filterHit = (stricmp(filter, string(GetClassName(child.Class))) != 0);
    if (flags&RMVF_EXFILTER) filterHit = !filterHit; // filter inverted
  }
  if (species) {
    speciesHit = (stricmp(species, string(child.GetSpecies())) != 0);
    if (flags&RMVF_EXSPECIES) speciesHit = !speciesHit; // species inverted
  }
  if (flags&RMVF_EITHER) {
    if (!filterHit && !speciesHit) return false;
  } else {
    if (!filterHit || !speciesHit) return false;
  }
  // check other flags
  if (!(flags&RMVF_EVERYTHING)) {
    if (child.bMonster) {
      // monster?
      if (flags&RMVF_NOMONSTERS) return false;
    } else if (child.IsMissile(false)) { // or precise?
      // missile?
      if (!(flags&RMVF_MISSILES)) return false;
    } else {
      // other?
      if (!(flags&RMVF_MISC)) return false;
    }
  }
  return true;
}


#ifdef VC_SCRIPT_USE_SPAWNED_CHILDREN_ARRAY
#else
// this is trick so `delete` will clear the array for us
transient private array!Actor A_RC_KillList;
#endif

//==========================================================================
//
//  A_RemoveChildren
//
//==========================================================================
final void A_RemoveChildren (optional bool all, optional int flags, optional string filter, optional string species) {
  if (stricmp(filter, "none") == 0) filter = "";
  if (stricmp(species, "none") == 0) species = "";

#ifdef VC_SCRIPT_USE_SPAWNED_CHILDREN_ARRAY
  foreach (auto idx; 0..SpawnedChildren.length) {
    Actor child = Actor(SpawnedChildren[idx]);
    if (!child) continue;
    if (!a_removechildren_checkIfChildShouldBeRemoved(child, all, flags, filter, species)) continue;
    // kill it!
    //print("%C: removing children #%d (%C)", self, idx, SpawnedChildren[idx]);
    delete SpawnedChildren[idx];
  }

  // shrink array
  /*
  foreach (auto idx; 0..SpawnedChildren.length; reverse) {
    if (SpawnedChildren[idx]) {
      if (idx+1 < SpawnedChildren.length) SpawnedChildren.length = idx+1;
      break;
    }
  }
  */
#else
  //array!Actor A_RC_KillList;
  A_RC_KillList.clear(); // clear, but don't reallocate
  Actor th;
  foreach AllThinkers(Actor, th) {
    if (th && a_removechildren_checkIfChildShouldBeRemoved(th, all, flags, filter, species)) A_RC_KillList[$] = th;
  }
  foreach (auto idx; 0..A_RC_KillList.length) {
    th = A_RC_KillList[idx];
    if (th) {
      //print("%C: removing children #%d (%C)", self, idx, th);
      delete th;
    }
  }
  A_RC_KillList.clear(); // clear, but don't reallocate
#endif
}


//==========================================================================
//
//  A_RadiusGive
//
//==========================================================================
final int A_RadiusGive (name itemname, float distance, int flags, optional int amount, optional string filter, optional string species, optional float mindist, optional int limit) {
  if (!specified_limit) limit = int.max;
  if (limit < 1) return 0;

  if (amount < 0) return 0;
  amount = max(1, amount); // 0 is 1 anyway

  if (distance <= 0) return 0; // as per docs
  if (mindist > distance) return 0;

  // find item class
  if (!itemname) return 0;
  class!Inventory itemtype = class!Inventory(FindClassNoCase(itemname));
  if (!itemtype) return 0;
  itemtype = class!Inventory(GetClassReplacement(itemtype));
  if (!itemtype) return 0;

  // fix filters
  if (stricmp(filter, "none") == 0) filter = "";
  if (stricmp(species, "none") == 0) species = "";

  bool giveCube = (flags&RGF_CUBE);
  int count = 0;
  Entity enti;
  foreach RadiusThings(enti, Origin, distance*(giveCube ? 2.0 : 1.0)) {
    EntityEx ent = EntityEx(enti);
    if (!ent) continue;
    if (ent == self) {
      if (!(flags&RGF_GIVESELF)) continue;
    } else {
      // check distance
      if (mindist > 0 && length2d(ent.Origin-Origin) > mindist) continue;
      if (giveCube) {
        // additional check for cube giver
        if (fabs(Origin.x-ent.Origin.x) > distance || fabs(Origin.y-ent.Origin.y) > distance) continue;
      }

      // check filters
      bool filterHit = true, speciesHit = true;
      if (filter) {
        filterHit = (stricmp(filter, string(GetClassName(ent.Class))) != 0);
        if (flags&RGF_EXFILTER) filterHit = !filterHit; // filter inverted
      }
      if (species) {
        speciesHit = (stricmp(species, string(ent.GetSpecies())) != 0);
        if (flags&RGF_EXSPECIES) speciesHit = !speciesHit; // species inverted
      }
      if (flags&RGF_EITHER) {
        if (!filterHit && !speciesHit) continue;
      } else {
        if (!filterHit || !speciesHit) continue;
      }

      if (ent.bCorpse && (flags&RGF_CORPSES)) {
        // do nothing, really
      } else {
        // check allowed flags
        if (ent.bIsPlayer) {
          // player
          if (ent.Player.PlayerState == PST_DEAD) continue;
          //if (ent.Player.bIsBot)
          if (ent.Player.MO != self) {
            // voodoo doll
            if (!(flags&RGF_VOODOO)) continue;
          } else {
            if (!(flags&RGF_PLAYERS)) continue;
          }
        } else if (ent.bMonster) {
          // monster
          if (!(flags&RGF_MONSTERS)) continue;
          if (ent.Health <= 0 && !(flags&RGF_KILLED)) continue;
        } else if (ent.bMissile) {
          // missile
          if (!(flags&RGF_MISSILES)) continue;
        } else {
          // other
          if (ent isa Inventory) {
            if (!(flags&RGF_ITEMS)) continue;
          } else {
            if (!(flags&RGF_OBJECTS)) continue;
            // should be either shootable or vulnerable
            if (!ent.bShootable && !ent.bNoDamage) continue;
          }
        }
      }

      // check NOxxx
      if (flags&(RGF_NOTARGET|RGF_NOTRACER|RGF_NOMASTER)) {
        if (flags&RGF_INCLUSIVE) {
          // should satisfy all
          bool isTarget = (flags&RGF_NOTARGET ? (Target == ent) : true);
          bool isTracer = (flags&RGF_NOTRACER ? (Tracer == ent) : true);
          bool isMaster = (flags&RGF_NOMASTER ? (Master == ent) : true);
          if (isTarget && isTracer && isMaster) continue;
        } else {
          bool isTarget = (flags&RGF_NOTARGET ? (Target == ent) : false);
          bool isTracer = (flags&RGF_NOTRACER ? (Tracer == ent) : false);
          bool isMaster = (flags&RGF_NOMASTER ? (Master == ent) : false);
          if (isTarget || isTracer || isMaster) continue;
        }
      }

      // sight check
      if (!(flags&RGF_NOSIGHT) && !CanSee(ent)) continue;
    }

    // it is ok to give an item
    if (DoGiveInventory(itemtype, amount, ent)) {
      ++count;
      if (count >= limit) break;
    }
  }

  return count;
}


//==========================================================================
//
//  decorate_CheckClass
//
//==========================================================================
final bool decorate_CheckClass (string classname, optional int ptr_select, optional bool match_superclass) {
  Entity tgt = DecorDoAAPtr('decorate_CheckClass', ptr_select!optional);
  if (!tgt) return false;
  class!Entity tc = class!Entity(tgt.Class);
  while (tc) {
    if (stricmp(string(GetClassName(tc)), classname) == 0) return true;
    if (!match_superclass) break;
    tc = class!Entity(GetClassParent(tc));
  }
  return false;
}


//==========================================================================
//
//  A_JumpIfRadiusAmountGreater
//
//  don't include self
//
//==========================================================================
final void A_JumpIfRadiusAmountGreater (float radius, int amount, class!Actor checkClass, state label, optional bool exact) {
  if (XLevel.StateCall) XLevel.StateCall->Result = false;

  if (radius < 0) return;
  if (!checkClass) return;
  if (amount < 1) { DoJump(label); return; }

  Entity e;
  if (exact) {
    foreach RadiusThings(e, Origin, radius) {
      if (e.Class == checkClass) {
        if (e != self) {
          if (!(--amount)) { DoJump(label); return; }
        }
      }
    }
  } else {
    //print("=============");
    foreach RadiusThings(e, Origin, radius) {
      //print("   %C", e);
      if (e isa checkClass) {
        if (e != self) {
          if (!(--amount)) {
            //print("%C: radius %s; check %C; hit it!", self, radius, checkClass);
            DoJump(label);
            return;
          }
        }
      }
    }
  }
  //print("%C: check %C with raduis %s, at %s, %s left", self, checkClass, radius, Origin, amount);
}


//==========================================================================
//
//  A_k8MoveBy
//
//==========================================================================
final void A_k8MoveBy (optional float dx, optional float dy, optional float dz) {
  if (!dx.isfinite || !dy.isfinite || !dz.isfinite) return;
  // so link the thing into its new position
  if (dx || dy) UnlinkFromWorld();
  Origin.x += dx;
  Origin.y += dy;
  Origin.z += dz;
  if (dx || dy) LinkToWorld();
}


//==========================================================================
//
//  A_k8MoveTo
//
//==========================================================================
final void A_k8MoveTo (optional float nx, optional float ny, optional float nz) {
  if (!nx.isfinite || !ny.isfinite || !nz.isfinite) return;
  // so link the thing into its new position
  if (specified_nx || specified_ny) UnlinkFromWorld();
  if (specified_nx) Origin.x = nx;
  if (specified_ny) Origin.y = ny;
  if (specified_nz) Origin.z = nz;
  if (specified_nx || specified_ny) LinkToWorld();
}


//==========================================================================
//
//  common_k8JumpIfLiquidFloor
//
//==========================================================================
final void common_k8JumpIfLiquidFloor (EntityEx tgt, state label) {
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (!tgt) return;
  if (!tgt.Sector) return; // just in case
  if (IsAnimatedTexture(tgt.Sector.floor.pic)) {
    //print("ANIM FLOOR: %s", GetTextureName(tgt.Sector.floor.pic));
    DoJump(label);
    return;
  }
  auto tname = string(GetTextureName(tgt.Sector.floor.pic));
  if (globmatch("*water*", tname, caseSensitive:false) ||
      globmatch("*nukage*", tname, caseSensitive:false) ||
      globmatch("*lava*", tname, caseSensitive:false) ||
      globmatch("*blood*", tname, caseSensitive:false) ||
      globmatch("*slime*", tname, caseSensitive:false) ||
      globmatch("*slimage*", tname, caseSensitive:false) ||
      globmatch("f_watr*", tname, caseSensitive:false)) // Strife water
  {
    DoJump(label);
  }
}


//==========================================================================
//
//  A_k8JumpIfLiquidFloor
//
//==========================================================================
final void A_k8JumpIfLiquidFloor (state label, optional int aptr) {
  // state jumps should not affect state chain results
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfLiquidFloor', aptr!optional));
  common_k8JumpIfLiquidFloor(tgt, label);
}


//==========================================================================
//
//  A_k8JumpIfOnLiquidFloor
//
//==========================================================================
final void A_k8JumpIfOnLiquidFloor (state label, optional int aptr) {
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfOnLiquidFloor', aptr!optional));
  if (!tgt) return;
  if (!tgt.Sector) return; // just in case
  if (tgt.Origin.z > tgt.FloorZ) return;
  common_k8JumpIfLiquidFloor(tgt, label);
}


//==========================================================================
//
//  A_k8JumpIfFloorCeiling
//
//==========================================================================
final void A_k8JumpIfFloorCeiling (state label, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfSkyFloor', aptr!optional));
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (!tgt) return;
  if (!tgt.Sector) return; // just in case
  if (tgt.Sector.floor.pic == Level.Game.skyflatnum) {
    //print("ANIM FLOOR: %s", GetTextureName(tgt.Sector.floor.pic));
    DoJump(label);
    return;
  }
}


//==========================================================================
//
//  A_k8JumpIfSkyCeiling
//
//==========================================================================
final void A_k8JumpIfSkyCeiling (state label, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfSkyFloor', aptr!optional));
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (!tgt) return;
  if (!tgt.Sector) return; // just in case
  if (tgt.Sector.ceiling.pic == Level.Game.skyflatnum) {
    //print("ANIM FLOOR: %s", GetTextureName(tgt.Sector.floor.pic));
    DoJump(label);
    return;
  }
}
