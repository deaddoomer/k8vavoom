//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//  Inventory functions
//**************************************************************************


//==========================================================================
//
//  doChooseRandomInvenotry
//
//==========================================================================
final class!Thinker doChooseRandomInvenotry (class!RandomSpawner spc) {
  int len = spc.default.DropItemList.length;
  if (!len) return none;
  int i = 0;
  int n = 0;
  while (i < len) {
    if (spc.default.DropItemList[i].Type) {
      int amn = spc.default.DropItemList[i].Amount;
      if (amn <= 0) amn = 1;
      // this is how we can weight the list.
      n += amn;
    }
    ++i;
  }
  if (n == 0) {
    printwarn("RandomSpawner `%C` is invalid!", spc);
    return none;
  }
  // then we reset the iterator to the start position...
  i = 0;
  // take a random number...
  n = P_Random()%n;
  // and iterate in the array up to the random number chosen
  while (n > -1) {
    if (spc.default.DropItemList[i].Type) {
      int amn = spc.default.DropItemList[i].Amount;
      if (amn <= 0) amn = 1;
      n -= amn;
      if (i+1 < spc.default.DropItemList.length && n > -1) {
        ++i;
      } else {
        n = -1;
      }
    }
  }
  // ...and we can spawn the dropped item...

  if (Random() <= spc.default.DropItemList[i].Chance) {
    class!EntityEx cls = class!EntityEx(FindClass(GetClassName(GetClassReplacement(spc.default.DropItemList[i].Type))));
    if (!cls) return none;
    if (!class!Inventory(cls) && !class!RandomSpawner(cls)) return none;
    return cls;
  }

  return none;
}


//==========================================================================
//
//  DoGiveInventory
//
//==========================================================================
final bool DoGiveInventory (class!Inventory ItemType, int Amount, EntityEx Receiver) {
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (!Receiver) return false;

  if (!Amount) Amount = 1;

  bool Ret = true;
  if (ItemType) {
    auto origItemType = ItemType;
    // some degenerative mods tries to give the player a `RandomSpawner` instance
    // check for this, and perform special processing
    class!Thinker replCls = class!Thinker(GetClassReplacement(ItemType));
    if (!replCls) replCls = ItemType;
    if (!replCls) {
      printwarn("something is very FUCKED while trying to give item `%C`", ItemType);
      return false;
    }
    // check for `RandomSpawner`
    class!RandomSpawner spc = class!RandomSpawner(replCls);
    if (spc) {
      // ok, try to spawn something; allow chained random spawners, but prevent looping
      int attemptsLeft = 32;
      while (spc) {
        --attemptsLeft;
        if (attemptsLeft == 0) {
          if (GetClassReplacement(origItemType)) {
            FatalError("Idiotic mod author tried to give looped RandomSpawner (%C -> %C); this will NEVER work.", origItemType, GetClassReplacement(origItemType));
          } else {
            FatalError("Idiotic mod author tried to give looped RandomSpawner (%C); this will NEVER work.", origItemType);
          }
        }
        // random spawner
        replCls = doChooseRandomInvenotry(spc);
        if (!replCls) return false;
        ItemType = class!Inventory(replCls);
        if (ItemType) {
          print("RandomSpawner `%C` got inventory `%C`", spc, ItemType);
          break;
        }
        spc = class!RandomSpawner(replCls);
        if (!spc) {
          FatalError("Idiotic mod author tried to give something that is not Inventory (%C) via random spawner; this will NEVER work.", replCls);
        }
      }
    } else {
      ItemType = class!Inventory(replCls);
      if (!ItemType) {
        FatalError("Idiotic mod author tried to give something that is not Inventory (%C -> %C); this will NEVER work.", origItemType, replCls);
      }
    }

    if (!ItemType) return false; // something is VERY fucked here

    Inventory Item = Spawn(ItemType, default, default, default, AllowReplace:false);
    if (!Inventory(Item)) {
      FatalError("Idiotic mod author tried to give something that is not Inventory (%C); this will NEVER work.", Item);
    }

    if (Health(Item)) {
      Item.Amount *= Amount;
    } else {
      Item.Amount = Amount;
    }

    Item.bDropped = true;
    // this shouldn't count for the item statistics
    if (Item.bCountItem) {
      Item.bCountItem = false;
      --Level.TotalItems;
    }

    if (!Item.TryPickup(Receiver)) {
      Item.Destroy();
      Ret = false;
    }
  } else {
    Ret = false;
  }

  if (XLevel.StateCall) XLevel.StateCall->Result = Ret;

  return Ret;
}


//==========================================================================
//
//  A_GiveInventory
//
//==========================================================================
final void A_GiveInventory (class!Inventory ItemType, optional int Amount, optional int giveto) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_GiveInventory', giveto!optional));
  DoGiveInventory(ItemType, Amount, /*self*/tgt);
}


//==========================================================================
//
//  A_GiveToTarget
//
//==========================================================================
final void A_GiveToTarget (class!Inventory ItemType, optional int Amount) {
  DoGiveInventory(ItemType, Amount, Target);
}


//==========================================================================
//
//  DoTakeInventory
//
//==========================================================================
final void DoTakeInventory (class!Inventory ItemType, int Amount, EntityEx Receiver) {
  if (!Receiver) return;

  if (XLevel.StateCall) XLevel.StateCall->Result = false;

  Inventory Item = Receiver.FindInventory(ItemType);
  if (Item && !HexenArmor(Item)) {
    if (Item.Amount > 0 && XLevel.StateCall) XLevel.StateCall->Result = true;
    if (!Amount || Item.Amount <= Amount) {
      if (Item.bKeepDepleted) {
        Item.Amount = 0;
      } else {
        Item.Destroy();
      }
    } else {
      Item.Amount -= Amount;
    }
  }
}


//==========================================================================
//
//  A_TakeInventory
//
//==========================================================================
final void A_TakeInventory (class!Inventory ItemType, optional int Amount, optional int flags, optional int giveto) {
  EntityEx dest = EntityEx(DecorDoAAPtr('A_TakeInventory', giveto!optional));
  if (!dest) return;
  // process TIF_NOTAKEINFINITE
  if (flags&1) {
    if (ItemType isa Ammo) {
      if (dest.FindInfiniteAmmoPowerup()) return;
    }
  }
  DoTakeInventory(ItemType, Amount, dest);
}


//==========================================================================
//
//  A_TakeFromTarget
//
//==========================================================================
final void A_TakeFromTarget (class!Inventory ItemType, optional int Amount) {
  DoTakeInventory(ItemType, Amount, Target);
}


//==========================================================================
//
//  A_DropInventory
//
//==========================================================================
final void A_DropInventory (class!Inventory ItemType) {
  Inventory Item = FindInventory(ItemType);
  if (Item) DropInventory(Item);
}


//==========================================================================
//
//  A_SelectWeapon
//
//==========================================================================
final void A_SelectWeapon (class!Weapon WeaponType) {
  if (!bIsPlayer) return;

  Weapon Wpn = Weapon(FindInventory(WeaponType));
  if (Wpn) {
    if (PlayerEx(Player).ReadyWeapon != Wpn) {
      PlayerEx(Player).PendingWeapon = Wpn;
    }
  } else if (XLevel.StateCall) {
    XLevel.StateCall->Result = false;
  }
}


//**************************************************************************
//  Weapon functions
//**************************************************************************
final void A_Recoil (float Force) {
  TVec Dir;
  TAVec Ang = Angles;
  Ang.yaw += 180.0;
  AngleVector(Ang, out Dir);
  Velocity += Dir*Force*35.0;
}


//**************************************************************************
//  Weapon attack functions
//**************************************************************************

//===========================================================================
//
//  A_Punch
//
//===========================================================================
final void A_Punch (optional bool alertIfHit, optional bool noAlertIfKilled) {
  if (bIsPlayer) {
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (Wpn) {
      if (!Wpn.DepleteAmmo(Wpn.FireMode)) return;
    }
  }

  int damage = (P_Random()%10+1)<<1;

  if (FindInventory(PowerStrength)) damage *= 10;

  TVec dir;
  TAVec aimAngles = Angles;
  aimAngles.yaw = AngleMod360(aimAngles.yaw+(Random()-Random())*45.0/8.0);
  EntityEx AimTarget = AimLineAttack(dir, aimAngles, MELEERANGE);
  EntityEx hitEntity;
  LineAttack(dir, MELEERANGE, damage, BulletPuff, default, default, 'Fist', out hitEntity:hitEntity);

  if (alertIfHit && hitEntity) {
    //print("FIST HIT: ent=%C (health=%s of %s)", hitEntity, hitEntity.Health, hitEntity.default.Health);
    if (!noAlertIfKilled || hitEntity.Health > 0) {
      LineSpecialLevelInfo(Level).NoiseAlert(self, self);
    }
  }

  // turn to face target
  if (AimTarget) {
    PlaySound('*fist', CHAN_WEAPON);
    Angles.yaw = atan2(AimTarget.Origin.y-Origin.y, AimTarget.Origin.x-Origin.x);
    if (bIsPlayer) Player.bFixAngle = true;
  }
}


//==========================================================================
//
//  A_FireAssaultGun
//
//==========================================================================
final void A_FireAssaultGun () {
  PlaySound('weapons/assaultgun', CHAN_WEAPON);

  TVec dir;

  if (bIsPlayer) {
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (!Wpn.DepleteAmmo(Wpn.FireMode)) return;

    SetState(MissileState);

    bool noAAim = false;
    if (!GetCvarB('k8HitscanAutoAim')) noAAim = true;

    Aim(dir, 16.0*64.0, noAutoaim:noAAim);

    if (PlayerEx(Player).Refire) {
      TAVec angles;
      VectorAngles(dir, out angles);
      angles.yaw = AngleMod360(angles.yaw+(Random()-Random())*45.0/2.0/float(1<<(PlayerEx(Player).Accuracy*5/100)));
      AngleVector(angles, out dir);
    }
  } else {
    Aim(dir, 16.0*64.0);
  }

  int damage = 4*(P_Random()%3+1);
  LineAttack(dir, (bIsPlayer ? 8192.0 : MISSILERANGE), damage, StrifePuff, default, default, 'Bullet');
}
