//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//  Inventory functions
//**************************************************************************


//==========================================================================
//
//  DoGiveInventory
//
//==========================================================================
final bool DoGiveInventory (class!Inventory ItemType, int Amount, EntityEx Receiver, optional bool disableReplace) {
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
  if (!Receiver) return false;

  if (!Amount) Amount = 1;

  bool Ret = true;
  if (ItemType) {
    auto origItemType = ItemType;
    Inventory Item = SpawnInventoryType(self, ItemType, disableReplace:disableReplace!optional);
    if (Item) {
      //Inventory Item = Spawn(ItemType, default, default, default, AllowReplace:false);
      if (!Inventory(Item)) {
        FatalError("Idiotic mod author tried to give something that is not Inventory (%C); this will NEVER work.", Item);
      }

      if (Health(Item)) {
        Item.Amount *= Amount;
      } else {
        Item.Amount = Amount;
      }

      Item.bDropped = true;
      // this shouldn't count for the item statistics
      if (Item.bCountItem) {
        Item.bCountItem = false;
        --Level.TotalItems;
      }

      //printdebug("DoGiveInventory:%C: Item=%C (Item at %s)", self, Item, GetClassLocationStr(Item.Class));
      if (!Item.TryPickup(Receiver)) {
        Item.Destroy();
        Ret = false;
      }
    }
  } else {
    Ret = false;
  }

  if (XLevel.StateCall) XLevel.StateCall->Result = Ret;

  return Ret;
}


//==========================================================================
//
//  A_GiveInventory
//
//==========================================================================
final void A_GiveInventory (class!Inventory ItemType, optional int Amount, optional int giveto) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_GiveInventory', giveto!optional));
  DoGiveInventory(ItemType, Amount, /*self*/tgt, disableReplace:true);
}


//==========================================================================
//
//  A_GiveToTarget
//
//==========================================================================
final void A_GiveToTarget (class!Inventory ItemType, optional int Amount) {
  DoGiveInventory(ItemType, Amount, Target, disableReplace:true);
}


//==========================================================================
//
//  DoTakeInventory
//
//==========================================================================
final void DoTakeInventory (class!Inventory ItemType, int Amount, EntityEx Receiver) {
  if (!Receiver) return;

  if (XLevel.StateCall) XLevel.StateCall->Result = false;

  Inventory Item = Receiver.FindInventory(ItemType);
  if (Item && !HexenArmor(Item)) {
    if (Item.Amount > 0 && XLevel.StateCall) XLevel.StateCall->Result = true;
    if (!Amount || Item.Amount <= Amount) {
      if (Item.bKeepDepleted) {
        Item.Amount = 0;
      } else {
        Item.Destroy();
      }
    } else {
      Item.Amount -= Amount;
    }
  }
}


//==========================================================================
//
//  A_TakeInventory
//
//==========================================================================
final void A_TakeInventory (class!Inventory ItemType, optional int Amount, optional int flags, optional int giveto) {
  EntityEx dest = EntityEx(DecorDoAAPtr('A_TakeInventory', giveto!optional));
  if (!dest) return;
  // process TIF_NOTAKEINFINITE
  if (flags&1) {
    if (ItemType isa Ammo) {
      if (dest.FindInfiniteAmmoPowerup()) return;
    }
  }
  DoTakeInventory(ItemType, Amount, dest);
}


//==========================================================================
//
//  A_TakeFromTarget
//
//==========================================================================
final void A_TakeFromTarget (class!Inventory ItemType, optional int Amount) {
  DoTakeInventory(ItemType, Amount, Target);
}


//==========================================================================
//
//  A_DropInventory
//
//==========================================================================
final void A_DropInventory (class!Inventory ItemType) {
  Inventory Item = FindInventory(ItemType);
  if (Item) DropInventory(Item);
}


//==========================================================================
//
//  A_SelectWeapon
//
//==========================================================================
final void A_SelectWeapon (class!Weapon WeaponType) {
  if (!bIsPlayer) return;

  Weapon Wpn = Weapon(FindInventory(WeaponType));
  if (Wpn) {
    if (PlayerEx(Player).ReadyWeapon != Wpn) {
      PlayerEx(Player).PendingWeapon = Wpn;
    }
  } else if (XLevel.StateCall) {
    XLevel.StateCall->Result = false;
  }
}


//**************************************************************************
//  Weapon functions
//**************************************************************************
final void A_Recoil (float Force) {
  TVec Dir;
  TAVec Ang = Angles;
  Ang.yaw += 180.0;
  AngleVector(Ang, out Dir);
  Velocity += Dir*Force*35.0;
}


//**************************************************************************
//  Weapon attack functions
//**************************************************************************

//===========================================================================
//
//  A_Punch
//
//===========================================================================
final void A_Punch (optional bool alertIfHit, optional bool noAlertIfKilled) {
  if (bIsPlayer) {
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (Wpn) {
      if (!Wpn.DepleteAmmo(Wpn.FireMode)) return;
    }
  }

  int damage = (P_Random()%10+1)<<1;

  if (FindInventory(PowerStrength)) damage *= 10;

  TVec dir;
  TAVec aimAngles = Angles;
  aimAngles.yaw = AngleMod360(aimAngles.yaw+(Random()-Random())*45.0/8.0);
  EntityEx AimTarget = AimLineAttack(dir, aimAngles, MELEERANGE);
  EntityEx hitEntity;
  LineAttack(dir, MELEERANGE, damage, BulletPuff, default, default, 'Fist', out hitEntity:hitEntity);

  if (alertIfHit && hitEntity) {
    //print("FIST HIT: ent=%C (health=%s of %s)", hitEntity, hitEntity.Health, hitEntity.InitialHealth);
    if (!noAlertIfKilled || hitEntity.Health > 0) {
      LineSpecialLevelInfo(Level).NoiseAlert(self, self);
    }
  }

  // turn to face target
  if (AimTarget) {
    PlaySound('*fist', CHAN_WEAPON);
    Angles.yaw = atan2(AimTarget.Origin.y-Origin.y, AimTarget.Origin.x-Origin.x);
    if (bIsPlayer) Player.bFixAngle = true;
  }
}


//==========================================================================
//
//  A_FireAssaultGun
//
//==========================================================================
final void A_FireAssaultGun () {
  PlaySound('weapons/assaultgun', CHAN_WEAPON);

  TVec dir;

  if (bIsPlayer) {
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (!Wpn.DepleteAmmo(Wpn.FireMode)) return;

    SetState(MissileState);

    bool noAAim = false;
    if (!GetCvarB('k8HitscanAutoAim')) noAAim = true;

    Aim(dir, 16.0*64.0, noAutoaim:noAAim);

    if (PlayerEx(Player).Refire) {
      TAVec angles;
      VectorAngles(dir, out angles);
      angles.yaw = AngleMod360(angles.yaw+(Random()-Random())*45.0/2.0/float(1<<(PlayerEx(Player).Accuracy*5/100)));
      AngleVector(angles, out dir);
    }
  } else {
    Aim(dir, 16.0*64.0);
  }

  int damage = 4*(P_Random()%3+1);
  LineAttack(dir, (bIsPlayer ? 8192.0 : MISSILERANGE), damage, StrifePuff, default, default, 'Bullet');
}
