//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//  Generic monster attacks
//**************************************************************************

// Minotaur variables
bool bFloorFireRefired; // internal to minotaur AI
// Special1 charge duration countdown
const float MinotaurLookDist = 16.0*54.0;
const float ChargeSpeed = 455.0;

float StartTime; // minotaur start time


//===========================================================================
//
//  helperSpawnShotSupplementalMissile
//
//===========================================================================
final EntityEx helperSpawnShotSupplementalMissile (class!Actor missile, TVec hitPoint,
                                                   float spawnheight, optional float spawnofsxy,
                                                   float scatter, optional bool nopitch)
{
  if (!missile) return none;
  TVec neworg = Origin;
  neworg.z += spawnheight;
  // move left-right a little
  TVec right = AngleYawVector(Angles.yaw+90); //k8: or -90?
  neworg += right*(FRandomBetween(-scatter, scatter));
  TVec newdir = (hitPoint-neworg).normalise;
  TAVec rot;
  VectorAngles(newdir, out rot);
  neworg.z -= spawnheight;
  if (nopitch) rot.pitch = 0;
  return SpawnMissileAngles(missile, rot.yaw, rot.pitch, spawnheight, spawnofsxy!optional, customOrigin:neworg);
}


//==========================================================================
//
//  A_CustomMissile
//
//==========================================================================
[decorate] final void A_CustomMissile (class!Actor MissileType, optional float SpawnHeight,
                            optional int SpawnXYOffset, optional float Angle, optional int Flags/*AimMode*/,
                            optional float Pitch, optional int aptr)
{
  if (!specified_aptr) aptr = AAPTR_TARGET;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_CustomMissile', aptr));
  if (!specified_aptr && tgt != Target) Error("WUTA?! in `A_CustomMissile`");

  //int Flags = AimMode&~3;
  int AimMode = Flags&3;
  if (Flags&CMF_ABSOLUTEPITCH) {
    if (!tgt) return;
    AimMode = CMF_AIMDIRECTION;
  }

  if (tgt || AimMode == 2) {
    if (Flags&CMF_CHECKTARGETDEAD) {
      if (!tgt) return;
      if (tgt.Health <= 0 || tgt.bCorpse) return;
    }

    if (MissileType) {
      Angle = AngleMod360(Angle);

      if (!specified_SpawnHeight) SpawnHeight = 32.0;
      if (!specified_SpawnXYOffset) SpawnXYOffset = 1;
      TVec Offs = float(SpawnXYOffset)*vector(cos(Angles.yaw-90.0), sin(Angles.yaw-90.0), 0.0);

      EntityEx A;
      switch (AimMode) {
        default:
          Origin += Offs;
          A = SpawnMissile(tgt, MissileType, SpawnHeight);
          Origin -= Offs;
          break;
        case CMF_AIMOFFSET:
          Offs.z = SpawnHeight;
          A = SpawnMissileXYZ(Origin+Offs, tgt, MissileType);
          break;
        case CMF_AIMDIRECTION:
          Origin += Offs;
          //k8: why `Angles.yaw?' but gozzo does this too
          //    but seems that gozzo overrides this later
          //A = SpawnMissileAngles(MissileType, Angles.yaw, Pitch, SpawnHeight);
          // will be turned later
          A = SpawnMissileAngles(MissileType, (Flags&CMF_ABSOLUTEANGLE ? Angle : Angles.yaw), Pitch, SpawnHeight);
          //if (A) A.Angles.yaw = Angle; // yet store it
          //if (A) print("%C: A_CustomMissile of '%C': Angle=%s; Pitch=%s; angles=%s; vel=%s", self, MissileType, Angle, Pitch, A.Angles, A.Velocity);
          Origin -= Offs;
          break;
      }

      if (A) {
        if (AimMode == CMF_AIMDIRECTION) {
          if (Angle && !(Flags&CMF_ABSOLUTEANGLE)) {
            VectorRotateAroundZ(ref A.Velocity, Angle);
            A.Angles.yaw += Angle;
          }
        } else {
          VectorRotateAroundZ(ref A.Velocity, Angle);
        }
        A.Angles.yaw = AngleMod360(A.Angles.yaw);
        // find correct shooter for projectiles shooting projectiles
        if (IsMissile(!!(Flags&CMF_TRACKOWNER))) {
          EntityEx Own = self;
          while (Own.IsMissile(!!(Flags&CMF_TRACKOWNER)) && Own.Target) Own = Own.Target;
          A.Target = Own;
          if (A.bSeekerMissile) A.Tracer = Tracer;
        } else if (A.bSeekerMissile) {
          A.Tracer = tgt;
        }
        if (Flags&CMF_OFFSETPITCH) Pitch += A.Angles.pitch;
        if (Flags&CMF_SAVEPITCH) A.Angles.pitch = Pitch;
      }
      //if (Flags&CMF_SAVEPITCH) print("%C: saved pitch is %s", self, Pitch);
    }
  } else if (Flags&CMF_CHECKTARGETDEAD) {
    //k8: ???
    if (SeeState) SetState(SeeState);
  }
}


//==========================================================================
//
//  FireSuperBullet
//
//==========================================================================
final void FireSuperBullet () {
  //Actor(MO).A_FireBullets(0, 0, 1, 10000, BulletPuff);
  bool noAAim = true;
  name decal = '';
  TVec aimDir;

  Aim(aimDir, 16.0*64.0, default, noAAim);
  LineAttack(aimDir, distance:10000, LADamage:10000, PuffType:BulletPuff,
             DmgType:BulletPuff.default.DamageType, secondary:false, decalType:decal);
}


//==========================================================================
//
//  A_CustomBulletAttack
//
//==========================================================================
[decorate] final void A_CustomBulletAttack (float SpreadHoriz, float SpreadVert,
                                 int NumBullets, int DamagePerBullet, optional class!Actor PuffType,
                                 optional float Range, optional int Flags, optional int aptr,
                                 optional class!Actor missile, optional float spawnheight, optional float spawnofsxy)
{
  if (!specified_aptr) aptr = AAPTR_TARGET;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_CustomBulletAttack', aptr));

  if (!Range) Range = (bIsPlayer ? 8192.0 : MISSILERANGE);
  //FIXME: not specified and none are two different things
  if (!PuffType || !specified_PuffType) PuffType = BulletPuff;

  if (Flags&CBAF_DISABLEMISSILE) missile = none;
  if (missile && (Flags&CBAF_NOMISSILENO3D) && !GetCvarB('r_models')) missile = none;

  if (!(Flags&CBAF_AIMFACING)) {
    if (tgt) common_A_FaceSomething(tgt);
  }
  //if (!tgt && !(Flags&CBAF_AIMFACING)) return;
  //if (!(Flags&CBAF_AIMFACING)) A_FaceTarget();

  if (AttackSound) PlaySound(AttackSound, CHAN_WEAPON);

  TVec aimDir;
  if (bIsPlayer) {
    bool noAAim = false;
    if (!GetCvarB('k8HitscanAutoAim')) noAAim = true;
    AimLineAttack(aimDir, Angles, MISSILERANGE, noAAim);
  } else {
    AimLineAttack(aimDir, Angles, MISSILERANGE);
  }

  if (missile && !specified_spawnheight) spawnheight = CalculateLineAttackZOfs(); // fix missile height

  TAVec rot;
  EntityEx puff;
  TVec hitPoint;
  foreach (auto i; 0..NumBullets) {
    if (Flags&CBAF_EXPLICITANGLE) {
      rot.pitch = SpreadVert;
      rot.yaw = SpreadHoriz;
    } else {
      rot.pitch = (Random()-Random())*SpreadVert;
      rot.yaw = (Random()-Random())*SpreadHoriz;
    }
    if (Flags&CBAF_NOPITCH) rot.pitch = 0;
    rot.roll = 0.0;
    TVec dir = RotateDirectionVector(aimDir, rot);
    int damage = DamagePerBullet;
    if (!(Flags&CBAF_NORANDOM)) damage *= ((P_Random()%3)+1);
    LineAttack(dir, Range, damage, PuffType, NoAttackGhosts:default,
               outHitPoint:&hitPoint, PuffType.default.DamageType, secondary:(i != 0),
               disableRandomZ:!!(Flags&CBAF_NORANDOMPUFFZ), out puffEntity:puff);
    if (missile) {
      EntityEx msl;
      if (Flags&CBAF_MISSILEHRANDOM) {
        msl = helperSpawnShotSupplementalMissile(missile, hitPoint, spawnheight, spawnofsxy!optional, scatter:1, nopitch:!!(Flags&CBAF_NOPITCH));
      } else {
        VectorAngles(dir, out rot);
        if (Flags&CBAF_NOPITCH) rot.pitch = 0;
        msl = SpawnMissileAngles(missile, rot.yaw, rot.pitch, spawnheight, spawnofsxy!optional);
      }
      if (msl && puff) {
        if (Flags&CBAF_PUFFTARGET) msl.Target = puff;
        if (Flags&CBAF_PUFFMASTER) msl.Master = puff;
        if (Flags&CBAF_PUFFTRACER) msl.Tracer = puff;
      }
    }
  }
}


//===========================================================================
//
//  A_CustomRailgun
//
//===========================================================================
[decorate] final void A_CustomRailgun (int RailDamage, optional float Offset,
                            optional string Color1, optional string Color2, optional int Flags,
                            optional bool DoAim, optional float MaxDiff,
                            optional class!Actor PuffType,
                            optional float spread_xy, optional float spread_z, // not implemented
                            optional float range,
                            optional int duration, optional float sparsity, optional float driftspeed, optional class!Actor spawnclass, // not implemented
                            optional float spawnofs_z,
                            optional int spiraloffset, // not implemented
                            optional int limit,
                            optional float veleffect)
{
  if (DoAim && !Target) return;

  // Andy Baker's stealth monsters
  if (bStealth) VisDir = 1;

  if (!specified_veleffect) veleffect = 3.0;

  bAmbush = false;

  if (DoAim) {
    Angles.yaw = atan2(Target.Origin.y-Origin.y, Target.Origin.x-Origin.x);
  }

  TVec Dir;
  if (bIsPlayer) {
    bool noAAim = false;
    if (!GetCvarB('k8HitscanAutoAim')) noAAim = true;
    AimLineAttack(Dir, Angles, 8192, noAAim);
  } else {
    AimLineAttack(Dir, Angles, MISSILERANGE);
  }

  TAVec Ang;
  VectorAngles(Dir, out Ang);

  if (DoAim) {
    // trail a little bit behind the target
    Ang.yaw = atan2(
      Target.Origin.y-Target.Velocity.y*veleffect/35.0-Origin.y,
      Target.Origin.x-Target.Velocity.y*veleffect/35.0-Origin.x);

    if (Target.bShadow) Ang.yaw = AngleMod360(Angles.yaw+(Random()-Random())*45.0);
    Angles.yaw = Ang.yaw;
  }

  AngleVector(Ang, out Dir);
  int Col1 = (Color1 && stricmp(Color1, "none") != 0 ? ParseColor(Color1) : 0);
  int Col2 = (Color2 && stricmp(Color2, "none") != 0 ? ParseColor(Color2) : 0);
  RailAttack(Dir, Offset, RailDamage, Col1, Col2, MaxDiff, PuffType, !!(Flags&1), !!(Flags&2),
    distance:range!optional, spawnofs_z:spawnofs_z!optional, pierceLimit:limit!optional);
}


//==========================================================================
//
//  A_CustomMeleeAttack
//
//==========================================================================
[decorate] final void A_CustomMeleeAttack (int MeleeDamage, optional name MeleeSound,
                                optional name MissSound, optional name DamageType, optional bool Bleed)
{
  if (!Target) return;

  A_FaceTarget();
  if (CheckMeleeRange()) {
    if (!DamageType) DamageType = 'Melee';
    if (MeleeSound) PlaySound(MeleeSound, CHAN_WEAPON);
    Target.Damage(self, self, MeleeDamage, DamageType, spawnBlood:true);
  } else {
    if (MissSound) PlaySound(MissSound, CHAN_WEAPON);
  }
}


//==========================================================================
//
//  A_CustomComboAttack
//
//==========================================================================
[decorate] final void A_CustomComboAttack (class!Actor MissileType, float MissileHeight,
                                int MeleeDamage, optional name MeleeSound, optional name DamageType,
                                optional bool Bleed)
{
  if (!Target) return;

  A_FaceTarget();
  if (CheckMeleeRange()) {
    if (!DamageType) DamageType = 'Melee';
    if (MeleeSound) PlaySound(MeleeSound, CHAN_WEAPON);
    Target.Damage(self, self, MeleeDamage, DamageType, spawnBlood:true);
    return;
  }

  if (MissileType) {
    EntityEx A = SpawnMissile(Target, MissileType, MissileHeight);
    if (A) {
      if (A.bSeekerMissile) A.Tracer = Target;
    }
  }
}


//==========================================================================
//
//  DoAttack
//
//==========================================================================
final void DoAttack (bool DoMelee, bool DoMissile, int MeleeDamage,
                     name MeleeSound, class!Actor MissileType, float MissileHeight)
{
  if (!Target) return;

  A_FaceTarget();
  if (DoMelee && MeleeDamage > 0 && CheckMeleeRange()) {
    if (MeleeSound) PlaySound(MeleeSound, CHAN_WEAPON);
    int damage = (P_Random()%8+1)*MeleeDamage;
    Target.Damage(self, self, damage, 'Melee', spawnBlood:true);
    return;
  }

  if (DoMissile && MissileType) {
    EntityEx A = SpawnMissile(Target, MissileType, MissileHeight);
    if (A) {
      if (A.bSeekerMissile) A.Tracer = Target;
    }
  }
}


//==========================================================================
//
//  A_MeleeAttack
//
//==========================================================================
[decorate] final void A_MeleeAttack () {
  DoAttack(true, false, MeleeDamage, MeleeSound, MissileType, MissileHeight);
}


//==========================================================================
//
//  A_MissileAttack
//
//==========================================================================
[decorate] final void A_MissileAttack () {
  DoAttack(false, true, MeleeDamage, MeleeSound, MissileType, MissileHeight);
}


//==========================================================================
//
//  A_ComboAttack
//
//==========================================================================
[decorate] final void A_ComboAttack () {
  DoAttack(true, true, MeleeDamage, MeleeSound, MissileType, MissileHeight);
}


//==========================================================================
//
//  A_BasicAttack
//
//==========================================================================
[decorate] final void A_BasicAttack (int AMeleeDamage, name AMeleeSound, class!Actor AMissileType, float AMissileHeight) {
  DoAttack(true, true, AMeleeDamage, AMeleeSound, AMissileType, AMissileHeight);
}


//==========================================================================
//
//  A_BulletAttack
//
//==========================================================================
[decorate] final void A_BulletAttack () {
  if (!Target) return;

  if (AttackSound) PlaySound(AttackSound, CHAN_WEAPON);
  A_FaceTarget();

  TVec aimDir;
  AimLineAttack(out aimDir, Angles, MISSILERANGE);

  int NumBullets = GetMissileDamage(0, 1);
  foreach (auto i; 0..NumBullets) {
    TVec dir = aimDir;
    VectorRotateAroundZ(ref dir, (Random()-Random())*45.0/2.0);
    int damage = ((P_Random()%5)+1)*3;
    LineAttack(dir, MISSILERANGE, damage, BulletPuff, DmgType:'Bullet', secondary:(i != 0));
  }
}


//===========================================================================
//
//  A_MonsterRail
//
//===========================================================================
[decorate] final void A_MonsterRail () {
  if (!Target) return;

  // Andy Baker's stealth monsters
  if (bStealth) VisDir = 1;

  bAmbush = false;

  Angles.yaw = atan2(Target.Origin.y-Origin.y, Target.Origin.x-Origin.x);

  TVec Dir;
  AimLineAttack(out Dir, Angles, MISSILERANGE);

  TAVec Ang;
  VectorAngles(Dir, out Ang);

  // trail a little bit behind the target
  Ang.yaw = atan2(
    Target.Origin.y-Target.Velocity.y*3.0/35.0-Origin.y,
    Target.Origin.x-Target.Velocity.y*3.0/35.0-Origin.x);

  if (Target.bShadow) Ang.yaw = AngleMod360(Angles.yaw+(Random()-Random())*45.0);
  Angles.yaw = Ang.yaw;

  AngleVector(Ang, out Dir);
  RailAttack(Dir, 0.0, GetMissileDamage(0, 1));
}


//==========================================================================
//
//  DoExplode
//
//  Handles a bunch of exploding things.
//
//==========================================================================
final void DoExplode (int damage, float distance, bool damageSelf, optional int dmgdistance,
                      optional EntityEx dmgsource, optional name dmgtype)
{
  if (!specified_dmgsource) dmgsource = Target;
  if (!specified_dmgtype) dmgtype = DamageType;
  if (specified_dmgdistance && dmgdistance > 0) {
    RadiusAttack(dmgsource, damage, distance, damageSelf, dmgtype, dmgdistance);
  } else {
    RadiusAttack(dmgsource, damage, distance, damageSelf, dmgtype);
  }

  if (Origin.z <= FloorZ+distance) HitFloorType();

  if (bExplodeParticles) {
    // spawn explosion effects -- dynamic light and particles
    foreach (auto i; 0..MAXPLAYERS) {
      if (!Level.Game.Players[i]) continue;
      if (!Level.Game.Players[i].bSpawned) continue;
      PlayerEx(Level.Game.Players[i]).ClientParticleExplosion(DLightColor, DLightRadius, Origin+vector(0.0, 0.0, Height*0.5));
    }
  } else if (ExplodeEffect) {
    SendExplosion(ExplodeEffect, DLightRadius, Origin);
  }

  // clear old dynamic light and trail effects
  bDynamicLight = false;
  bLeaveTrail = false;
}


//==========================================================================
//
//  A_Explode
//
//  Handles a bunch of exploding things.
//
//==========================================================================
[decorate] final void A_Explode (optional int damage, optional float radius, optional int flags) {
  ubyte damageSelf;

  if (!specified_damage) damage = 128;
  if (!specified_radius) radius = 128;

  if (specified_flags) {
    damageSelf = (flags&XF_HURTSOURCE ? 1 : 0);
  } else {
    damageSelf = 1;
  }

  float distance = radius;

  PreExplode();
  GetExplodeParms(damage, distance, damageSelf);

  CheckSplash(distance);
  DoExplode(damage, distance, damageSelf);
}


//==========================================================================
//
//  A_ExplodeAndAlert
//
//==========================================================================
[decorate] final void A_ExplodeAndAlert () {
  A_Explode();
  if (Target && Target.bIsPlayer) LineSpecialLevelInfo(Level).NoiseAlert(Target, self);
}


//==========================================================================
//
//  A_ExplodeParms
//
//==========================================================================
[decorate] final void A_ExplodeParms () {
  int damage = ExplosionDamage;
  float distance = float(ExplosionRadius);
  ubyte damageSelf = !bExplosionDontHurtSelf;

  if (!damage) damage = 128;
  if (!distance) distance = float(damage);
  DoExplode(damage, distance, damageSelf);
}


//==========================================================================
//
//  decorate_A_Explode
//
//==========================================================================
[decorate] final void decorate_A_Explode (optional int damage, optional float distance,
                               optional int flags, optional bool Alert, optional int dmgdistance,
                               optional int nails, optional int naildamage,
                               optional class!EntityEx PuffType, optional name dmgType)
{
  /*
    XF_NOTMISSILE -- Not a missile: if set, the calling actor is considered to be the source. By default, the calling actor is assumed to be a projectile, and the source is therefore considered to be the calling actor's target.
    XF_EXPLICITDAMAGETYPE -- The damagetype parameter will never change to the actor's damagetype.
    XF_NOSPLASH -- No splash: if set, the explosion does not create any terrain splashes.
  */
  bool damageSelf = (specified_flags ? !!(flags&XF_HURTSOURCE) : true);
  if (!specified_PuffType) PuffType = BulletPuff;
  name NailDamageType = 'Nail';
  if (!specified_dmgType) {
    //k8: dunno if this is right
    if (!(flags&XF_EXPLICITDAMAGETYPE)) dmgType = DamageType;
  } else {
    NailDamageType = dmgType; //k8: dunno
  }
  if (specified_damage) {
    if (!damage) damage = 128;
    if (!distance) distance = 128;
    //if (!specified_flags) damageSelf = true;
  } else {
    damage = ExplosionDamage;
    distance = ExplosionRadius;
    damageSelf = !bExplosionDontHurtSelf;
    if (!damageSelf && specified_flags && (flags&XF_HURTSOURCE)) damageSelf = true; //k8:dunno
    if (!damage) damage = 128;
    if (!distance) distance = damage;
  }

  // NailBomb effect, from SMMU but not from its source code: instead it was
  // implemented and generalized from the documentation at
  // http://www.doomworld.com/eternity/engine/codeptrs.html
  if (specified_nails && nails > 0) {
    TAVec Ang;
    TVec adir;
    foreach (auto i; 0..nails) {
      Ang.yaw = AngleMod360(float(i*(360/nails)));
      // comparing the results of a test wad with Eternity, it seems A_NailBomb does not aim
      //AimLineAttack(self, Ang, MISSILERANGE),
      //LineAttack(Ang, MISSILERANGE, 0, naildamage, default, default,'Nail');
      //LineAttack(Ang, MISSILERANGE, 0, naildamage, 'None', BulletPuff);
      AngleVector(Ang, out adir);
      LineAttack(/*Ang*/adir, MISSILERANGE, naildamage, PuffType, DmgType:NailDamageType, secondary:false);
    }
  }

  EntityEx dmgsource = Target;
  if (flags&XF_NOTMISSILE) dmgsource = self;

  if (specified_dmgdistance && dmgdistance > 0) {
    DoExplode(damage, float(distance), damageSelf, dmgdistance, dmgsource:dmgsource, dmgtype:dmgType);
  } else {
    DoExplode(damage, float(distance), damageSelf, dmgsource:dmgsource, dmgtype:dmgType);
  }
  if (!(flags&XF_NOSPLASH)) CheckSplash(float(distance));

  if (Alert && dmgsource && dmgsource.bIsPlayer) LineSpecialLevelInfo(Level).NoiseAlert(dmgsource, self);
}


//==========================================================================
//
//  A_RadiusThrust
//
//==========================================================================
[decorate] final void A_RadiusThrust (optional int Force, optional int Distance, optional int flags,
                           optional float fullthrustdistance)
{
  if (!Force) Force = 128;
  if (!Distance) Distance = Force;

  if (!specified_flags) flags = RTF_AFFECTSOURCE; //???
  bool AffectSelf = !!(flags&RTF_AFFECTSOURCE);
  //???if (!specified_AffectSelf) AffectSelf = true;

  RadiusAttack((flags&RTF_NOTMISSILE ? self : Target), Force, float(Distance), AffectSelf, DamageType,
    /*false*/!(flags&RTF_NOIMPACTDAMAGE), thrustZ:!!(flags&RTF_THRUSTZ), fullthrustdistance:fullthrustdistance!optional);
  if (Origin.z <= FloorZ+float(Distance)) HitFloorType();
}


//==========================================================================
//
//  A_Detonate
//
//==========================================================================
[decorate] final void A_Detonate () {
  int damage = GetMissileDamage(0, 1);
  DoExplode(damage, float(damage), true);
}


//==========================================================================
//
//  A_ThrowGrenade
//
//==========================================================================
[decorate] final void A_ThrowGrenade (class!Actor ItemType, optional float SpawnHeight,
                                      optional float XYVel, optional float ZVel, optional bool UseAmmo)
{
  if (!specified_UseAmmo) UseAmmo = true;

  //print("bIsPlayer: %B", bIsPlayer);
  Entity owo = Owner;
  if (!owo) owo = self;

  //  If called from weapon, then use ammo.
  if (bIsPlayer &&
      (XLevel.CallingState == Player.ViewStates[PS_WEAPON].State ||
       XLevel.CallingState == Player.ViewStates[PS_FLASH].State ||
       XLevel.CallingState == Player.ViewStates[PS_WEAPON_OVL].State))
  {
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (!Wpn) { KeepChainResult(); return; }
    if (UseAmmo && !Wpn.DepleteAmmo(Wpn.FireMode)) { KeepChainResult(); return; }
  }

  Actor A = SpawnEntityChecked(class!Actor, ItemType, owo.Origin+vector(0.0, 0.0, SpawnHeight+35.0-owo.FloorClip));
  if (A) {
    A.CarryBloodTranslations(self);
    A.PlayMissileSpawnSound(self);
    if (XYVel) A.Speed = fabs(XYVel*35.0); //k8:???
    A.Angles.yaw = AngleMod360(owo.Angles.yaw+(Random()*2.0-1.0)*45.0/8.0);
    A.Velocity.z = (ZVel+2.0*sin(owo.Angles.pitch))*35.0;
    A.Origin.z += 2.0*sin(owo.Angles.pitch);
    A.Velocity.x += A.Speed*cos(A.Angles.yaw);
    A.Velocity.y += A.Speed*sin(A.Angles.yaw);
    A.Velocity.x += Velocity.x/2.0;
    A.Velocity.y += Velocity.y/2.0;
    A.Target = self;
    if (A.bRandomise) A.StateTime = fmax(1.0/35.0, A.StateTime-Random()*0.1);
    A.CheckMissileSpawn();
  } else {
    KeepChainResult();
  }
}


//==========================================================================
//
//  A_CheckForReload
//
//==========================================================================
[decorate] final void A_CheckForReload (int Count, state Jump, optional bool dontIncrement) {
  if (Count <= 0) return;

  if (bIsPlayer) {
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (!Wpn) return;

    int ReloadCounter = Wpn.ReloadCounter;
    if (!specified_dontIncrement) dontIncrement = false;

    if (!dontIncrement || ReloadCounter != 0) {
      ReloadCounter = (Wpn.ReloadCounter+1)%Count;
    } else {
      // 0 % 1 = 1?  So how do we check if the weapon was never fired?  We should only do this when we're not incrementing the counter though.
      ReloadCounter = 1;
    }
    if (!dontIncrement) Wpn.ReloadCounter = ReloadCounter;

    // if we have not made our last shot...
    if (ReloadCounter != 0) {
      // go back to the refire frames, instead of continuing on to the reload frames
      PlayerEx(Player).SetViewObject(Wpn);
      DoJump(Jump); // do not modify chain result
    } else {
      // we need to reload; however, don't reload if we're out of ammo
      Wpn.CheckAmmo(Weapon::FIRE_Either, AutoSwitch:false, RequireAmmo:true); //k8: don't require ammo here?
    }
  }
}


//==========================================================================
//
//  A_ResetReloadCounter
//
//==========================================================================
[decorate] final void A_ResetReloadCounter () {
  if (bIsPlayer) {
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (Wpn) Wpn.ReloadCounter = 0;
  }
}


//==========================================================================
//
//  A_ZoomFactor
//
//==========================================================================
[decorate] final void A_ZoomFactor (float zoom, optional int flags) {
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;
  if (Wpn && bIsPlayer) {
    if (!zoom) zoom = 1.0;
    zoom = fclamp(zoom, 0.1, 50);
    zoom = 1.0/zoom;

    if (flags&ZOOM_INSTANT) {
      // make the zoom instant
      PlayerEx(Player).FOV = PlayerEx(Player).DesiredFOV*zoom;
    }
    if (flags&ZOOM_NOSCALETURNING) {
      // disable pitch/yaw scaling
      zoom = -zoom;
    }
    Wpn.FOVScale = zoom;
  }
}


//==========================================================================
//
//  BlastActor
//
//==========================================================================
final void BlastActor (Actor victim, Actor source, float speed, class!Actor BlastEffect) {
  float angle; //???
  //k8: angle was always zero, wtf?!
  angle = AngleMod360(FRandomFull()*360.0);

  if (victim.bMissile) {
    if (victim.IsA('SorcBall')) {
      // don't blast sorcerer balls
      return;
    } else if (MageStaffFX2(victim)) {
      // reflect to originator
      victim.Tracer = victim.Target;
      victim.Target = source;
    }
  }

  if (victim.Class == HolySpirit) {
    if (victim.Tracer == source) {
      victim.Tracer = victim.Target;
      victim.Target = source;
    }
  }

  victim.Velocity.x = speed*cos(angle)*35.0;
  victim.Velocity.y = speed*sin(angle)*35.0;

  // spawn blast puff
  float ang = atan2(source.Origin.y-victim.Origin.y, source.Origin.x-victim.Origin.x);
  float x = victim.Origin.x+(victim.Radius+1.0)*cos(ang);
  float y = victim.Origin.y+(victim.Radius+1.0)*sin(ang);
  float z = victim.Origin.z-victim.FloorClip+victim.Height/2.0;

  Actor A = none;
  if (BlastEffect) {
    A = SpawnEntityChecked(class!Actor, BlastEffect, vector(x, y, z));
    if (A) {
      A.CarryBloodTranslations(self);
      A.Velocity.x = victim.Velocity.x;
      A.Velocity.y = victim.Velocity.y;
    }
  }

  if (victim.bMissile) {
    victim.Velocity.z = 8.0*35.0;
    if (A) A.Velocity.z = victim.Velocity.z;
  } else {
    victim.Velocity.z = 1000.0/fmax(1, victim.Mass)*35.0;
  }

  if (victim.bIsPlayer) {
    // players handled automatically
  } else {
    victim.bSlide = true;
    victim.bBlasted = true;
  }

  // touchy objects die when blasted
  if (victim.bTouchy) {
    victim.bArmed = false; // disarm
    Damage(victim, source, victim.Health, spawnBlood:true);
  }
}


//==========================================================================
//
//  A_Blast
//
//==========================================================================
[decorate] final void A_Blast (optional int BlastFlags, optional float Strength/*ignored*/,
                    optional float Radius, optional float Speed,
                    optional class!Actor BlastEffect, optional name BlastSound)
{
  //const int BF_USEAMMO      = 1;
  //const int BF_DONTWARN     = 2;
  //const int BF_AFFECTBOSSES = 4;
  //const int BF_NOIMPACTDAMAGE = 8;

  if (!Radius) Radius = 255; // default radius
  if (!Speed) Speed = 20; // default speed
  if (!specified_BlastEffect) BlastEffect = class!Actor(FindClassNoCase('BlastEffect'));
  if (!specified_BlastSound) BlastSound = 'BlastRadius';

  if (bIsPlayer && (BlastFlags&BF_USEAMMO)) {
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (!Wpn) return;
    if (!Wpn.DepleteAmmo(Wpn.FireMode)) return;
  }

  if (BlastSound) PlaySound(BlastSound, CHAN_ITEM);
  if (!(BlastFlags&BF_DONTWARN)) LineSpecialLevelInfo(Level).NoiseAlert(self, self);

  Actor mo;
  foreach AllThinkers(Actor, mo) {
    if (mo == self) continue;
    if (mo.bBoss && !(BlastFlags&BF_AFFECTBOSSES)) continue; // not a valid monster
    if (mo.bCanBlast || mo.bIceCorpse) {
      // frozen corpse
      // let these special cases go
    } else if (mo.bMonster && mo.Health <= 0) {
      continue;
    } else if (!mo.bMonster && !mo.bIsPlayer && !mo.bMissile && !mo.bTouchy) {
      // must be monster, player, missile or touchy
      continue;
    }
    if (mo.bDormant) continue; // no dormant creatures
    if (mo.bDontBlast) continue;
    float dist = self.DistTo(mo);
    if (dist > Radius) continue; // out of range
    BlastActor(mo, self, Speed, BlastEffect);
  }
}


//==========================================================================
//
//  A_MonsterRefire
//
//==========================================================================
[decorate] final void A_MonsterRefire (int prob, state jump) {
  // keep firing unless target got out of sight
  A_FaceTarget();

  if (P_Random() < prob) return;

  if (!Target || Target.Health <= 0 || !CanSee(Target, disableBetterSight:true)) {
    DoJump(jump); // do not modify chain result (k8: why?)
  }
}


//==========================================================================
//
//  FindEnemySelf
//
//==========================================================================
final EntityEx FindEnemySelf () {
  Entity Other;
  foreach RoughBlockSearch(Other, 20) {
    EntityEx link = EntityEx(Other);
    if (!link) continue;
    if (!link.bMonster && (!link.bIsPlayer || link == Tracer)) continue;
    if (!link.bShootable) continue;
    if (link.bDormant) continue;
    if (link.bSummonedMonster && (link.Tracer && (link.Tracer == Tracer || link.Tracer.IsTeammate(Tracer)))) continue;
    if (link.IsTeammate(Tracer)) continue;
    if (bScreenSeeker) {
      if (CanSee(link)) {
        float angle = AngleMod360(atan2(link.Origin.y-Origin.y, link.Origin.x-Origin.x)-Angles.yaw);
        if (angle <= 226.0*360.0/256.0 || angle >= 30.0*360.0/256.0) continue;
      }
    } else {
      if (!CanSee(link)) continue;
    }
    return link;
  }
  return none;
}


//===========================================================================
//
//  FindEnemyMaster
//
//  Minotaur looking around player
//
//===========================================================================
final EntityEx FindEnemyMaster () {
  Entity Other;
  foreach Tracer.RoughBlockSearch(Other, 20) {
    EntityEx link = EntityEx(Other);
    if (!link) continue;
    if (!Tracer.bIsPlayer) continue;
    if (!link.bMonster && (!link.bIsPlayer || link == Tracer)) continue;
    if (!link.bShootable) continue;
    if (link.bDormant) continue;
    if (link.bSummonedMonster && (link.Tracer && (link.Tracer == Tracer || link.Tracer.IsTeammate(Tracer)))) continue;
    if (link.IsTeammate(Tracer)) continue;
    if (Level.Game.netgame && !Level.Game.deathmatch && link.bIsPlayer) continue;
    if (Tracer.CanSee(link)) return link;
    if (Tracer.bScreenSeeker) {
      if (Tracer.CanSee(link)) {
        float angle = AngleMod360(atan2(link.Origin.y-Tracer.Origin.y, link.Origin.x-Tracer.Origin.x)-Tracer.Angles.yaw);
        if (angle <= 226.0*360.0/256.0 || angle >= 30.0*360.0/256.0) continue;
      }
    } else {
      if (!Tracer.CanSee(link)) continue;
    }
  }
  return none;
}


//==========================================================================
//
//  A_MinotaurLook
//
//  Look for enemy of player
//
//==========================================================================
[decorate] final void A_MinotaurLook () {
  Actor mo;

  if (!bSummonedMonster) {
    A_Look();
    return;
  }

  Target = none;

  if (Level.Game.deathmatch) {
    // quick search for players
    foreach (auto i; 0..MAXPLAYERS) {
      if (!Level.Game.Players[i] || !Level.Game.Players[i].bSpawned) continue;
      mo = Actor(Level.Game.Players[i].MO);
      if (mo == Tracer) continue;
      if (mo.Health <= 0) continue;
      if (mo.IsTeammate(Tracer)) continue;
      float dist = DistTo(mo);
      if (dist > MinotaurLookDist) continue;
      Target = mo;
      break;
    }
  }

  if (!Target) {
    // near player monster search
    if (Tracer && (Tracer.Health > 0) && Tracer.bIsPlayer) {
      Target = FindEnemyMaster();
    } else {
      Target = FindEnemySelf();
    }
  }

  if (!Target) {
    // normal monster search
    foreach AllThinkers(Actor, mo) {
      if (!mo.bMonster) continue;
      if (mo.Health <= 0) continue;
      if (!mo.bShootable) continue;
      float dist = DistTo(mo);
      if (dist > MinotaurLookDist) continue;
      if (mo == Tracer || mo == self) continue;
      if (mo.bSummonedMonster && (mo.Tracer == Tracer || mo.IsTeammate(Tracer))) continue;
      Target = mo;
      break; // found mobj to attack
    }
  }

  if (Target) {
    SetState(FindState('SeeNF'));
  } else {
    SetState(FindState('RoamNF'));
  }
}


//==========================================================================
//
//  A_MinotaurChase
//
//==========================================================================
[decorate] final void A_MinotaurChase () {
  RenderStyle = STYLE_Normal;
  Alpha = 1.0; // in case pain caused him to skip his fade in

  if (!bSummonedMonster) {
    A_Chase();
    return;
  }

  if (XLevel.Time-StartTime >= PowerMinotaur.default.EffectTime) {
    Damage(none, none, 10000, spawnBlood:true);
    return;
  }

  if (P_Random() < 30) A_MinotaurLook(); // adjust to closest target

  if (!Target || (Target.Health <= 0) || !Target.bShootable) {
    // look for a new enemy
    SetState(FindState('Look'));
    return;
  }

  FaceMovementDirection();
  ReactionCount = 0;

  // melee attack
  if (MeleeState && CheckMeleeRange()) {
    if (AttackSound) PlaySound(AttackSound, CHAN_WEAPON);
    SetState(MeleeState);
    return;
  }

  // missile attack
  if (MissileState && CheckMissileRange()) {
    SetState(MissileState);
    return;
  }

  // chase towards target
  if (!StepMove()) NewChaseDir();

  // active sound
  if (ActiveSound && P_Random() < 6) PlaySound(ActiveSound, CHAN_VOICE);
}


//==========================================================================
//
//  A_MinotaurRoam
//
//==========================================================================
[decorate] final void A_MinotaurRoam () {
  RenderStyle = STYLE_Normal;
  Alpha = 1.0; // in case pain caused him to skip his fade in.

  if (XLevel.Time-StartTime >= PowerMinotaur.default.EffectTime) {
    Damage(none, none, 10000, spawnBlood:true);
    return;
  }

  if (P_Random() < 30) A_MinotaurLook(); // adjust to closest target

  if (P_Random() < 6) {
    // choose new direction
    MoveDir = P_Random()%8;
    FaceMovementDirection();
  }

  if (!StepMove()) {
    // turn
    if (P_Random()&1) MoveDir = (++MoveDir)%8; else MoveDir = (MoveDir+7)%8;
    FaceMovementDirection();
  }
}


//==========================================================================
//
//  A_MinotaurAtk1
//
//  Melee attack.
//
//==========================================================================
[decorate] final void A_MinotaurAtk1 () {
  if (!Target) return;

  PlaySound('minotaur/melee', CHAN_WEAPON);
  if (CheckMeleeRange()) {
    Target.Damage(self, self, HITDICE(4), spawnBlood:true);
    if (Target.bIsPlayer) {
      // squish the player
      auto pex = PlayerEx(Target.Player);
      if (pex.MO == Target) pex.DeltaViewHeight = -512.0;
    }
  }
}


//==========================================================================
//
//  A_MinotaurDecide
//
//  Choose a missile attack.
//
//==========================================================================
[decorate] final void A_MinotaurDecide () {
  if (!Target) return;
  if (!bSummonedMonster) PlaySound('minotaur/sight', CHAN_VOICE);

  float dist = DistTo(Target);

  if (Target.Origin.z+Target.Height > Origin.z &&
      Target.Origin.z+Target.Height < Origin.z+Height &&
      dist < (bSummonedMonster ? 16.0 : 8.0)*64.0 && dist > 1.0*64.0 &&
      P_Random() < (bSummonedMonster ? 230 : 150))
  {
    // charge attack
    // don't call the state function right away
    SetState(FindState('Charge'));
    bSkullFly = true;
    A_FaceTarget();
    Velocity = Normalise(Target.Origin-Origin)*ChargeSpeed;
    Special1 = 35/2;  // Charge duration
  } else if (Target.Origin.z == Target.FloorZ && dist < 9.0*64.0 && P_Random() < (bSummonedMonster ? 100 : 220)) {
    // floor fire attack
    SetState(FindState('Hammer'));
    bFloorFireRefired = false;
  } else {
    // swing attack
    A_FaceTarget();
    // don't need to call SetState because the current state
    // falls through to the swing attack
  }
}


//==========================================================================
//
//  A_MinotaurAtk2
//
//  Swing attack.
//
//==========================================================================
[decorate] final void A_MinotaurAtk2 () {
  TAVec ang;

  if (!Target) return;
  PlaySound('minotaur/attack2', CHAN_WEAPON);
  if (CheckMeleeRange()) {
    Target.Damage(self, self, HITDICE((bSummonedMonster ? 3 : 5)), spawnBlood:true);
    return;
  }

  EntityEx A = SpawnMissile(Target, MinotaurFX1, 40.0);
  if (A) {
    VectorAngles(A.Velocity, out ang);
    float angle = A.Angles.yaw;
    SpawnMissileAngles(MinotaurFX1, AngleMod360(angle-(45.0/8.0)), ang.pitch, 40.0);
    SpawnMissileAngles(MinotaurFX1, AngleMod360(angle+(45.0/8.0)), ang.pitch, 40.0);
    SpawnMissileAngles(MinotaurFX1, AngleMod360(angle-(45.0/16.0)), ang.pitch, 40.0);
    SpawnMissileAngles(MinotaurFX1, AngleMod360(angle+(45.0/16.0)), ang.pitch, 40.0);
  }
}


//==========================================================================
//
//  A_MinotaurAtk3
//
//  Floor fire attack.
//
//==========================================================================
[decorate] final void A_MinotaurAtk3 () {
  if (!Target) return;

  PlaySound('minotaur/attack3', CHAN_WEAPON);
  if (CheckMeleeRange()) {
    Target.Damage(self, self, HITDICE((bSummonedMonster ? 3 : 5)), spawnBlood:true);
    if (Target.bIsPlayer) {
      // squish the player
      auto pex = PlayerEx(Target.Player);
      if (pex.MO == Target) pex.DeltaViewHeight = -512.0;
    }
  } else {
    EntityEx A = SpawnMissile(Target, MinotaurFX2);
    if (A) A.PlaySound('minotaur/attack1', CHAN_VOICE);
  }

  if (Random() < 0.75 && !bFloorFireRefired) {
    SetState(FindState('HammerLoop'));
    bFloorFireRefired = true;
  }
}


//==========================================================================
//
//  A_MinotaurCharge
//
//==========================================================================
[decorate] final void A_MinotaurCharge () {
  if (!Target) return;

  if (Special1 > 0) {
    class!Actor PuffType = PhoenixPuff;
    if (bSummonedMonster) PuffType = PunchPuff;
    EntityEx puff = Spawn(PuffType, Origin);
    if (puff) {
      puff.CarryBloodTranslations(self);
      puff.Velocity.z = 2.0*35.0;
    }
    --Special1;
  } else {
    bSkullFly = false;
    SetState(SeeState);
  }
}
