//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//  Monster AI
//**************************************************************************

enum /*EKillFlags*/ {
  KILS_FOILINVUL = 0x00000001,
  KILS_KILLMISSILES = 0x00000002,
  KILS_NOMONSTERS = 0x00000004,
  KILS_FOILBUDDHA = 0x00000008,
  KILS_EXFILTER = 0x00000010,
  KILS_EXSPECIES = 0x00000020,
  KILS_EITHER = 0x00000040,
};


// Flags for A_AlertMonsters
enum /*EAlertFlags*/ {
  AMF_TARGETEMITTER = 1,
  AMF_TARGETNONPLAYER = 2,
  AMF_EMITFROMTARGET = 4,
}


// A_CheckProximity flags
enum /*EProximityFlags*/ {
  CPXF_ANCESTOR    = 1,
  CPXF_LESSOREQUAL = 1<<1,
  CPXF_NOZ         = 1<<2,
  CPXF_COUNTDEAD   = 1<<3,
  CPXF_DEADONLY    = 1<<4,
  CPXF_EXACT       = 1<<5,
  CPXF_SETTARGET   = 1<<6,
  CPXF_SETMASTER   = 1<<7,
  CPXF_SETTRACER   = 1<<8,
  CPXF_FARTHEST    = 1<<9,
  CPXF_CLOSEST     = 1<<10,
  CPXF_SETONPTR    = 1<<11,
  CPXF_CHECKSIGHT  = 1<<12,
};


enum /*FAF_Flags*/ {
  FAF_BOTTOM = 1,
  FAF_MIDDLE = 2,
  FAF_TOP    = 4,
};


//==========================================================================
//
//  A_Look
//
//  Stay in state until a player is sighted or has a goal.
//
//==========================================================================
final void A_Look () {
  EntityEx targ;
  Entity Ent;

  // set goal now if appropriate
  if (Special == LNSPEC_ThingSetGoal && Args[0] == 0) {
    Goal = none;
    for (Ent = Level.FindMobjFromTID(Args[1], none); Ent; Ent = Level.FindMobjFromTID(Args[1], Ent)) {
      if (!Ent.IsA('PatrolPoint')) continue;
      Goal = EntityEx(Ent);
      break;
    }
    Special = 0;
    ReactionTime = float(Args[2])+XLevel.Time;
    bChaseGoal = !!Args[3];
  }

  Threshold = 0; // any shot will wake up

  if (TIDToHate) {
    targ = Target;
    //!LastPlayerSeenPosValid = false;
  } else {
    //!if (Target && !Target.bIsPlayer) LastPlayerSeenPosValid = false;
    targ = (Level.CompatSoundTarget || bNoSector ? EntityEx(Sector->SoundTarget) : LastHeard);
    if (targ) {
      // if it's dead, don't chase it
      if (targ && targ.Health <= 0) targ = none;
      if (targ && targ.bIsPlayer) {
        if (PlayerEx(targ.Player).bNoTarget) return;
        /*!!!
        // if it is player, and we cannot see it, run to the place we last seen it
        if (LastPlayerSeenPosValid && !CanSee(targ)) {
          print("%C: running to last place where i've seen the player: %s", self, LastPlayerSeenPos);
          A_Wander();
          return;
        }
        LastPlayerSeenPosValid = true;
        LastPlayerSeenPos = targ.Origin;
        */
      }
    }
    /*!!!
    else {
      // no last heard target
      if (LastPlayerSeenPosValid) {
        print("%C: running to last place where i've seen the player: %s", self, LastPlayerSeenPos);
        A_Wander();
        return;
      }
    }
    */
  }

  // Andy Baker's stealth monsters
  if (bStealth) VisDir = -1;

  if (targ && targ.bShootable) {
    if (bFriendly && targ.bFriendly) {
      // if we find a valid target here, the wandering logic should *not* be activated!
      // if would cause the seestate to be set twice
      if (!LookForPlayers(bLookAllAround)) {
        // let the actor wander around aimlessly looking for a fight
        if (SeeState) {
          if (!bInChase) SetState(SeeState);
        } else {
          A_Wander();
        }
      }
    } else {
      Target = targ;
      if (bAmbush) {
        if (!CanSee(Target)) {
          if (!LookForPlayers(bLookAllAround)) return;
        }
      }
    }
  } else {
    if (!LookForPlayers(bLookAllAround)) return;
  }

  // go into chase state
  // don't start chasing after a goal if it isn't time yet
  if (Target == Goal) {
    //!LastPlayerSeenPosValid = false;
    if (ReactionTime > XLevel.Time) Target = none;
  } else if (SightSound) {
    if (bBoss) {
      // full volume
      PlaySound(SightSound, /*CHAN_VOICE*/CHAN_SIGHT, 1.0, ATTN_NONE);
    } else {
      PlaySound(SightSound, /*CHAN_VOICE*/CHAN_SIGHT);
    }
  }

  if (Target) SetState(SeeState);
}


//==========================================================================
//
//  A_Look2
//
//==========================================================================
final void A_Look2 () {
  Threshold = 0; // any shot will wake up
  EntityEx targ = LastHeard;

  if (!bNeutral && targ && targ.bShootable) {
    if (bFriendly != targ.bFriendly || Level.bNoAllies) {
      Target = targ;
      if (!bStandMustSeeTarget || CanSee(targ)) {
        Threshold = 10;
        // let the actor wander around aimlessly looking for a fight
        if (SeeState) {
          if (!bInChase) SetState(SeeState);
        } else {
          A_Wander();
        }
        return;
      }
    } else {
      if (LookForPlayers(bLookAllAround)) {
        // let the actor wander around aimlessly looking for a fight
        if (SeeState) {
          if (!bInChase) SetState(SeeState);
        } else {
          A_Wander();
        }
        bInCombat = true;
        return;
      }
    }
  }

  if (P_Random() < 30) {
    if (!(P_Random()&1)) {
      SetState(GetStatePlus(IdleState, 1, true));
    } else {
      SetState(GetStatePlus(IdleState, 2, true));
    }
  }

  if (!bStanding && P_Random() < 40) SetState(GetStatePlus(IdleState, 3, true));
}


//==========================================================================
//
//  A_LookEx
//
//  [KS] Borrowed the A_Look code to make a parameterized version.
//
//==========================================================================
final void A_LookEx (int flags, optional float minseedist, optional float maxseedist, optional float maxheardist,
                     optional float fov, optional name wakestate)
{
  EntityEx targ;
  Entity Ent;
  float dist;

  // fix optional args
  //if (!specified_minseedist) minseedist = 0; // this is default
  //if (!specified_maxseedist) maxseedist = 0; // this is default
  //if (!specified_maxheardist) maxheardist = 0; // this is default
  //if (!specified_fov) fov = 0; // this is default
  if (!specified_wakestate) wakestate = 'See';

  // set goal now if appropriate
  if (Special == LNSPEC_ThingSetGoal && Args[0] == 0) {
    Goal = none;
    for (Ent = Level.FindMobjFromTID(Args[1], none); Ent; Ent = Level.FindMobjFromTID(Args[1], Ent)) {
      if (!Ent.IsA('PatrolPoint')) continue;
      Goal = EntityEx(Ent);
      break;
    }
    Special = 0;
    ReactionTime = float(Args[2])+XLevel.Time;
    bChaseGoal = !!Args[3];
  }

  Threshold = 0; // any shot will wake up
  if (TIDToHate) {
    targ = Target;
  } else {
    if (!(flags&Entity::LOF_NOSOUNDCHECK)) {
      targ = (Level.CompatSoundTarget || bNoSector ? EntityEx(Sector->SoundTarget) : LastHeard);
      // if it's dead, don't chase it
      if (targ && targ.Health <= 0) targ = none;

      // [KS] If the target is too far away, don't respond to the sound.
      if (targ && maxheardist && DistTo(targ) > maxheardist) targ = none;
    }

    if (targ && targ.bIsPlayer && PlayerEx(targ.Player).bNoTarget) return;
  }

  // Andy Baker's stealth monsters
  if (bStealth) VisDir = -1;

  if (targ && targ.bShootable) {
    if (bFriendly && targ.bFriendly) {
      if (!(flags&Entity::LOF_NOSIGHTCHECK)) {
        // if we find a valid target here, the wandering logic should *not* be activated!
        // if would cause the seestate to be set twice
        if (!LookForPlayers(bLookAllAround)) {
          // let the actor wander around aimlessly looking for a fight
          if (FindState(wakestate)) {
            if (!bInChase) SetState(FindState(wakestate));
          } else {
            A_Wander();
          }
        }
      } else {
        // let the actor wander around aimlessly looking for a fight
        if (FindState(wakestate)) {
          if (!bInChase) SetState(FindState(wakestate));
        } else {
          A_Wander();
        }
      }
    } else {
      Target = targ;
      if (bAmbush) {
        if (targ) {
          if (!CanSee(Target) && (!minseedist || DistTo(Target) < minseedist) &&
              (!maxseedist || DistTo(Target) > maxseedist))
          {
            if (!LookForPlayers(bLookAllAround)) return;
          }
        } else {
          if (!LookForPlayers(bLookAllAround)) return;
        }
      }
    }
  } else {
    if (!(flags&Entity::LOF_NOSIGHTCHECK)) {
      if (!LookForPlayers(bLookAllAround)) return;
    } else {
      return;
    }
  }

  // go into chase state
  // don't start chasing after a goal if it isn't time yet
  if (Target == Goal) {
    if (ReactionTime > XLevel.Time) Target = none;
  } else if (SightSound && !(flags&Entity::LOF_NOSEESOUND)) {
    if (flags&Entity::LOF_FULLVOLSEESOUND) {
      // full volume
      PlaySound(SightSound, /*CHAN_VOICE*/CHAN_SIGHT, 1.0, ATTN_NONE);
    } else {
      PlaySound(SightSound, /*CHAN_VOICE*/CHAN_SIGHT);
    }
  }

  if (Target) {
    state wkst = FindState(wakestate);
    if (wkst) {
      SetState(FindState(wakestate));
    } else {
      SetState(SeeState);
    }
  }
}


//==========================================================================
//
//  A_TurretLook
//
//  Stay in state untill alarm is triggered.
//
//==========================================================================
final void A_TurretLook () {
  Threshold = 0;
  EntityEx targ = LastHeard;
  if (targ && targ.Health > 0 && targ.bShootable && bFriendly != targ.bFriendly) {
    Target = targ;
    if (bAmbush && !CanSee(Target)) return;
    // go into chase state
    if (SightSound) PlaySound(SightSound, /*CHAN_VOICE*/CHAN_SIGHT);
    LastHeard = none;
    Threshold = 10;
    SetState(SeeState);
  }
}


//==========================================================================
//
//  A_Wander
//
//==========================================================================
final void A_Wander () {
  bInCombat = false;
  if (bStanding) return;

  if (ReactionCount != 0) {
    --ReactionCount;
    return;
  }

  // turn towards movement direction if not there yet
  if (MoveDir < DI_NODIR) {
    Angles.yaw = float(int(Angles.yaw/45.0))*45.0;
    float delta = AngleMod180(Angles.yaw-float(MoveDir)*45.0);

         if (delta > 0.0) Angles.yaw = AngleMod360(Angles.yaw-45.0);
    else if (delta < 0.0) Angles.yaw = AngleMod360(Angles.yaw+45.0);
  }

  /*!!!
  if (LastPlayerSeenPosValid && (bNoFear || !bFrightened)) {
    if (!StepMove()) {
      print("%C: setting chase dir to last place where i've seen the player: %s", self, LastPlayerSeenPos);
      NewChaseDirTo(LastPlayerSeenPos);
      if (StepMove()) return;
    }
  }
  */

  if (--MoveCount < 0 || !StepMove()) {
    RandomChaseDir();
    MoveCount += 5;
  }
}


//==========================================================================
//
//  DoChase
//
//  Actor has a melee attack, so it tries to close as fast as possible
//
//  FIXME: optional flags are not working
//
//==========================================================================
void DoChase (bool FastChase, state AMeleeState, state AMissileState,
              bool NightmareFast, bool PlayActive, bool DontMove,
              optional bool noRandomTurn, optional bool noDirectionTurn,
              optional bool noPostAttackTurn, optional bool stopIfBlocked)
{
  float delta;
  float dist;
  float ang;
  float oldX;
  float oldY;
  int oldFloor;

  if (bInChase) return;
  bInChase = true;

  // Andy Baker's stealth monsters
  if (bStealth) VisDir = -1;

  if (ReactionCount) --ReactionCount;

  bInCombat = true;
  // modify target threshold
  if (Threshold) {
    if (!Target || Target.Health <= 0) {
      Threshold = 0;
    } else {
      --Threshold;
    }
  }

  if (NightmareFast && Level.Game.fastparm == 1) {
    // monsters move faster in nightmare mode
    StateTime *= 0.5;
    if (StateTime < 0.1) StateTime = 0.1;
  }

  // turn towards movement direction if not there yet
  // killough 9/7/98: keep facing towards target if strafing or backing out
  if (strafecount) {
    A_FaceTarget();
  } else {
    if (MoveDir < 8) {
      Angles.yaw = float(int(Angles.yaw/45.0))*45.0;
      delta = AngleMod180(Angles.yaw-float(MoveDir)*45.0);
           if (delta > 0.0) Angles.yaw = AngleMod360(Angles.yaw-45.0);
      else if (delta < 0.0) Angles.yaw = AngleMod360(Angles.yaw+45.0);
    }
  }

  // if the target is dead and not a goal, stop chasing it
  if (Target && Target != Goal && Target.Health <= 0) Target = none;

  /*!!!
  // if we lost a target, try to run to the last poing we've seen it
  if (!Target && LastPlayerSeenPosValid && (bNoFear || !bFrightened)) {
    print("%C: 000: !!!!", self);
    A_Wander();
    return;
  }

  if (LastPlayerSeenPosValid && Target && Target.bIsPlayer && Target.Health > 0 && !CanSee(Target)) {
    print("%C: lost player!", self);
    A_Wander();
    return;
  }
  */

  if (!Target || !Target.bShootable) {
    // look for a new target
    if (LookForPlayers(true) && Target != Goal) {
      // got a new target
      bInChase = false;
      return;
    }
    if (!Target) {
      if (bFriendly) {
        A_Look();
        if (!Target) {
          if (!DontMove) A_Wander();
          bInChase = false;
          return;
        }
      } else {
        SetState(IdleState);
        bInCombat = false;
        bInChase = false;
        return;
      }
    }
  }

  // do not attack twice in a row
  if (bJustAttacked) {
    bJustAttacked = false;
    if (!IsFast() && !DontMove) NewChaseDir();
    bInChase = false;
    return;
  }

  // don't attack if just moving toward goal
  if (Target == Goal || (bChaseGoal && Goal)) {
    EntityEx SavedTarget = Target;
    Target = Goal;
    bool Result = CheckMeleeRange();
    Target = SavedTarget;

    if (Result) {
      // reached the goal

      // execute the specials of any PatrolSpecials with the same TID as the goal
      Entity Ent;
      for (Ent = Level.FindMobjFromTID(Goal.TID, none); Ent; Ent = Level.FindMobjFromTID(Goal.TID, Ent)) {
        if (Ent.Class != PatrolSpecial) continue;
        Level.ExecuteActionSpecial(Ent.Special, Ent.Args[0],
          Ent.Args[1], Ent.Args[2], Ent.Args[3], Ent.Args[4],
          nullptr, 0, self);
      }

      float LastGoalAng = Goal.Angles.yaw;
      int Delay;
      EntityEx NewGoal = none;
      for (Ent = Level.FindMobjFromTID(Goal.Args[0], none); Ent; Ent = Level.FindMobjFromTID(Goal.Args[0], Ent)) {
        if (!Ent.IsA('PatrolPoint')) continue;
        NewGoal = EntityEx(Ent);
        break;
      }
      if (NewGoal && Goal == Target) {
        Delay = NewGoal.Args[1];
        ReactionTime = float(Delay)+XLevel.Time;
      } else {
        Delay = 0;
        ReactionTime = default.ReactionTime;
        Angles.yaw = LastGoalAng; // look in direction of last goal
      }
      if (Target == Goal) Target = none;
      bJustAttacked = true;
      if (NewGoal && Delay != 0) {
        bInCombat = true;
        SetState(IdleState);
      }
      Goal = NewGoal;
      bInChase = false;
      return;
    }
  }

  if (Goal != Target) {
    if (FastChase && !DontMove) {
      // strafe
      if (FastChaseStrafeCount > 0) {
        --FastChaseStrafeCount;
      } else {
        FastChaseStrafeCount = 0;
        Velocity.x = 0.0;
        Velocity.y = 0.0;
        dist = DistTo(Target);
        if (dist < 640.0) {
          if (P_Random() < 100) {
            ang = atan2(Target.Origin.y-Origin.y, Target.Origin.x-Origin.x);
            if (P_Random() < 128) ang = AngleMod360(ang+90.0); else ang = AngleMod360(ang-90.0);
            Velocity.x = 13.0*cos(ang)*35.0;
            Velocity.y = 13.0*sin(ang)*35.0;
            FastChaseStrafeCount = 3; // strafe time
          }
        }
      }
    }

    // scared monsters attack less frequently
    if ((!Target.bIsPlayer || !(PlayerEx(Target.Player).Cheats&PlayerEx::CF_FRIGHTENING)) &&
         !bFrightened || P_Random() < 43)
    {
      // check for melee attack
      if (AMeleeState && CheckMeleeRange()) {
        if (AttackSound) PlaySound(AttackSound, CHAN_WEAPON);
        SetState(AMeleeState);
        bInChase = false;
        return;
      }

      // check for missile attack
      if (AMissileState) {
        if (IsFast() || !MoveCount) {
          if (CheckMissileRange()) {
            SetState(AMissileState);
            bJustAttacked = true;
            bInChase = false;
            return;
          }
        }
      }
    }
  }

  // possibly choose another target
  if ((Level.Game.netgame || TIDToHate) && !Threshold) {
    if (!CanSee(Target)) {
      bool PrevNoSightCheck = bNoSightCheck;
      bNoSightCheck = false;
      bool GotNew = LookForPlayers(true);
      bNoSightCheck = PrevNoSightCheck;
      if (GotNew) {
        // got a new target
        bInChase = false;
        return;
      }
    }
  }

  if (strafecount) --strafecount;

  // chase towards player
  if ((!FastChase || !FastChaseStrafeCount) && !DontMove) {
    oldX = Origin.x;
    oldY = Origin.y;
    oldFloor = Sector->floor.pic;
    //k8: dunno if this is right
    bool tryMoveAgain = true;
         if (--MoveCount < 0) NewChaseDir();
    else if (!StepMove()) { tryMoveAgain = false; NewChaseDir(); }
    if (!stopIfBlocked) tryMoveAgain = true;
    if (tryMoveAgain && bCantLeaveFloorpic && Sector->floor.pic != oldFloor) {
      TryMove(vector(oldX, oldY, Origin.z), false);
      NewChaseDir();
    }
  } else if (DontMove && MoveCount > 0) {
    MoveCount = 0;
  }

  // make active sound
  if (PlayActive && P_Random() < 3) PlayActiveSound();

  bInChase = false;
}


//==========================================================================
//
//  CheckForResurrect
//
//  Check for ressurecting a body.
//
//==========================================================================
final bool CheckForResurrect (bool UseVileStates) {
  float viletryx;
  float viletryy;
  Entity Other;

  if (MoveDir != DI_NODIR) {
    // check for corpses to raise
    viletryx = Origin.x+Speed/35.0*LineSpecialGameInfo(Level.Game).xspeed[MoveDir];
    viletryy = Origin.y+Speed/35.0*LineSpecialGameInfo(Level.Game).yspeed[MoveDir];

    // for all things in radius check whether object is a corpse that can be raised
    foreach RadiusThings(Other, vector(viletryx, viletryy, 0.0), MAXRADIUS) {
      // detect a corpse that could be raised
      float maxdist = Other.Radius+Radius;

      if (fabs(Other.Origin.x-viletryx) > maxdist ||
          fabs(Other.Origin.y-viletryy) > maxdist)
      {
        continue; // not actually touching
      }

      if (!CanSee(Other)) continue; // can't see, possibly in other region

      if (!EntityEx(Other).DoThingRaise()) continue;

      // this is now a archvile minion, so hate what he hates
      EntityEx(Other).CopyFriendliness(self, false);

      // got one!
      EntityEx temp = Target;
      Target = EntityEx(Other);
      A_FaceTarget();
      Target = temp;

      // enter heal state
      state HealState = FindState('Heal');
      if (!HealState && UseVileStates) {
        // for DeHackEd compatibility use Arch-vile heal states if this one doesn't have it's own
        HealState = FindClassState(Archvile, 'Heal');
      }
      if (HealState) SetState(HealState);

      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  A_Chase
//
//==========================================================================
final void A_Chase () {
  DoChase(false, MeleeState, MissileState, LineSpecialGameInfo(Level.Game).bNightmareFastChase, true, false);
}


//==========================================================================
//
//  decorate_A_Chase
//
//==========================================================================
final void decorate_A_Chase (optional state AMeleeState, optional state AMissileState, optional int Flags) {
  if (specified_AMeleeState) {
    if ((Flags&8) && CheckForResurrect(false)) return;
    DoChase(!!(Flags&1), AMeleeState, AMissileState,
            !!(Flags&4), !(Flags&2), !!(Flags&16),
            !!(Flags&32), !!(Flags&64), !!(Flags&128), !!(Flags&256));
  } else {
    DoChase(false, MeleeState, MissileState, LineSpecialGameInfo(Level.Game).bNightmareFastChase, true, false);
  }
}


//============================================================================
//
//  A_FastChase
//
//============================================================================
final void A_FastChase () {
  DoChase(true, MeleeState, MissileState, true, true, false);
}


//==========================================================================
//
//  A_VileChase
//
//==========================================================================
final void A_VileChase () {
  if (!CheckForResurrect(true)) A_Chase(); // return to normal attack
}


//==========================================================================
//
//  A_ExtChase
//
//==========================================================================
final void A_ExtChase (bool UseMelee, bool UseMissile, optional bool PlayActive, optional bool NightmareFast) {
  if (!specified_PlayActive) PlayActive = true;
  state Melee = MeleeState;
  if (!UseMelee) Melee = none;
  state Missile = MissileState;
  if (!UseMissile) Missile = none;
  DoChase(false, Melee, Missile, NightmareFast, PlayActive, false);
}


//==========================================================================
//
//  A_FaceTarget
//
//==========================================================================
final void A_FaceTarget () {
  decorate_A_FaceTarget();
}


//==========================================================================
//
//  decorate_A_FaceTarget
//
//==========================================================================
final void decorate_A_FaceTarget (optional float max_turn, optional float max_pitch,
                                  optional float ang_offset, optional float pitch_offset,
                                  optional int flags, optional float z_ofs)
{
  common_A_FaceSomething(Target, max_turn!optional, max_pitch!optional,
                         ang_offset!optional, pitch_offset!optional,
                         flags!optional, z_ofs!optional);
}


//==========================================================================
//
//  decorate_A_FaceTracer
//
//==========================================================================
final void decorate_A_FaceTracer (optional float max_turn, optional float max_pitch,
                                  optional float ang_offset, optional float pitch_offset,
                                  optional int flags, optional float z_ofs)
{
  common_A_FaceSomething(Tracer, max_turn!optional, max_pitch!optional,
                         ang_offset!optional, pitch_offset!optional,
                         flags!optional, z_ofs!optional);
}


//==========================================================================
//
//  decorate_A_FaceMaster
//
//==========================================================================
final void decorate_A_FaceMaster (optional float max_turn, optional float max_pitch,
                                  optional float ang_offset, optional float pitch_offset,
                                  optional int flags, optional float z_ofs)
{
  common_A_FaceSomething(Master, max_turn!optional, max_pitch!optional,
                         ang_offset!optional, pitch_offset!optional,
                         flags!optional, z_ofs!optional);
}


//==========================================================================
//
//  common_A_FaceSomething
//
//==========================================================================
final void common_A_FaceSomething (EntityEx Tgt, optional float max_turn, optional float max_pitch,
                                  optional float ang_offset, optional float pitch_offset,
                                  optional int flags, optional float z_ofs)
{
  if (!Tgt || Tgt == self) return;

  // Andy Baker's stealth monsters
  if (bStealth) VisDir = 1;

  bAmbush = false;

  float newyaw = AngleTo(Tgt);
  float adiff = AngleDelta(Angles.yaw, newyaw);

  if (specified_max_turn && max_turn < adiff) {
    if (adiff < 0) Angles.yaw -= max_turn+ang_offset; else Angles.yaw += max_turn+ang_offset;
  } else {
    Angles.yaw = newyaw+ang_offset;
  }
  Angles.yaw = AngleMod360(Angles.yaw);

  if (specified_max_pitch && max_pitch <= 180) {
    TVec dist = Tgt.Origin-Origin;
    dist.z = 0;

    // positioning ala missile spawning, 32 units above foot level
    float source_z = Origin.z+32;
    float target_z;

    // if the target z is above the target's head, reposition to the middle of its body
    if (source_z >= Origin.z+Height) source_z = GetCentreZ();

    if (flags&(FAF_BOTTOM|FAF_MIDDLE|FAF_TOP)) {
      // note there is no +32 on purpose. this is for customization sake.
      // if one doesn't want this behavior, just don't use FAF_BOTTOM.
      if (flags&FAF_BOTTOM) target_z = Tgt.Origin.z;
      if (flags&FAF_MIDDLE) target_z = Tgt.GetCentreZ();
      if (flags&FAF_TOP) target_z = Tgt.Origin.z+Tgt.Height;
    } else {
      target_z = Tgt.Origin.z+32;
      if (target_z >= Tgt.Origin.z+Tgt.Height) target_z = Tgt.GetCentreZ();
    }

    target_z += z_ofs;

    float dist_z = target_z-source_z;
    if (dist_z > 0) {
      float ddist = sqrt(dist.x*dist.x+dist.y*dist.y+dist_z*dist_z);
      if (ddist > 0) {
        float other_pitch = AngleMod180(-asin(dist_z/ddist));
        if (max_pitch != 0) {
          if (Angles.pitch > other_pitch) {
            max_pitch = AngleMod360(fmin(max_pitch, Angles.pitch-other_pitch));
            Angles.pitch -= max_pitch;
          } else {
            max_pitch = AngleMod360(fmin(max_pitch, other_pitch-Angles.pitch));
            Angles.pitch += max_pitch;
          }
        } else {
          Angles.pitch = other_pitch;
        }
        Angles.pitch += pitch_offset;
      }
    }
  }


  if (!max_turn && !ang_offset && Tgt.bShadow) {
    Angles.yaw = AngleMod360(Angles.yaw+(Random()-Random())*45.0);
  }
}


//==========================================================================
//
//  A_Die
//
//==========================================================================
final void A_Die (optional name DamageType) {
  if (!specified_DamageType) {
    Damage(none, none, Health, forced:true);
  } else {
    Damage(none, none, Health, DamageType, forced:true);
  }
}


//==========================================================================
//
//  A_CentaurDefend
//
//==========================================================================
final void A_CentaurDefend () {
  A_FaceTarget();
  if (CheckMeleeRange() && Random() < 0.125) {
    A_UnSetInvulnerable();
    SetState(MeleeState);
  }
}


//==========================================================================
//
//  A_AlertMonsters
//
//==========================================================================
final void A_AlertMonsters (optional float maxrange, optional int flags) {
  //print("A_AlertMonsters(%C): tgt=%C; plr=%s", self, Target, (Target && Target.bIsPlayer ? "tan" : "ona"));
  if (Target && (Target.bIsPlayer || (flags&(AMF_TARGETEMITTER|AMF_TARGETNONPLAYER)))) {
    LineSpecialLevelInfo(Level).NoiseAlert(target:Target, emitter:self, maxdist:maxrange!optional,
                                           targetEmitter:!!(flags&AMF_TARGETEMITTER),
                                           targetNonPlayer:!!(flags&AMF_TARGETNONPLAYER),
                                           emitFromTarget:!!(flags&AMF_EMITFROMTARGET));
  } else {
    // for weapons
    if (self.bIsPlayer || (flags&(AMF_TARGETEMITTER|AMF_TARGETNONPLAYER))) {
      LineSpecialLevelInfo(Level).NoiseAlert(target:self, emitter:self, maxdist:maxrange!optional,
                                             targetEmitter:!!(flags&AMF_TARGETEMITTER),
                                             targetNonPlayer:!!(flags&AMF_TARGETNONPLAYER),
                                             emitFromTarget:!!(flags&AMF_EMITFROMTARGET));
    }
  }
}


//==========================================================================
//
//  A_ClearTarget
//
//==========================================================================
final void A_ClearTarget () {
  Target = none;
  LastEnemy = none;
  LastHeard = none;
}


//==========================================================================
//
//  A_ClearSoundTarget
//
//==========================================================================
final void A_ClearSoundTarget () {
  Sector->SoundTarget = none;
  for (Entity Ent = Sector->ThingList; Ent; Ent = Ent.SNext) {
    EntityEx(Ent).LastHeard = none;
  }
}


//==========================================================================
//
//  A_KillMaster
//
//==========================================================================
final void A_KillMaster () {
  if (Master) Master.Damage(self, self, Master.Health, default, true);
}


//==========================================================================
//
//  A_KillChildren
//
//==========================================================================
final void A_KillChildren (optional name damagetype, optional int flags
             /*, optional string filter, optional string species, optional int src, optional int inflict*/)
{
  Actor A;
  if (specified_damagetype) {
    if (!damagetype || nameicmp(damagetype, 'none') == 0) damagetype = '';
    //else if (stricmp(damagetype, "NODAMAGE") == 0) damagetype = "None";//FIXME: TODO
  }
  foreach AllThinkers(Actor, A) {
    if (A.Master == self) {
      if (A.IsMissile(false)) {
        if (!(flags&KILS_KILLMISSILES)) continue;
      } else if (A.bMonster) {
        if (flags&KILS_NOMONSTERS) continue;
      } else {
        continue;
      }
      if (specified_damagetype) {
        A.Damage(self, self, A.Health, damagetype, NoArmor:true, forced:!!(flags&KILS_FOILINVUL));
      } else {
        A.Damage(self, self, A.Health, default, NoArmor:true, forced:!!(flags&KILS_FOILINVUL));
      }
    }
  }
}


//==========================================================================
//
//  A_SentinelBob
//
//==========================================================================
final void A_SentinelBob () {
  if (bInFloat) { Velocity.z = 0.0; return; }

  if (Threshold) return;

  float maxz = CeilingZ-Height-16.0;
  float minz = FloorZ+96.0;
  if (minz > maxz) minz = maxz;

  if (minz < Origin.z) {
    Velocity.z -= 1.0*35.0;
  } else {
    Velocity.z += 1.0*35.0;
  }
  ReactionCount = (minz >= Origin.z ? 4 : 0);
}


//==========================================================================
//
//  A_Burst
//
//==========================================================================
final void A_Burst (class!Actor ChunkType) {
  if (!ChunkType) return;
  ChunkType = GetCompatibleClassReplacement(Actor, ChunkType);
  if (!ChunkType) return;

  // stop the thing and reset it's height
  Velocity = vector(0.0, 0.0, 0.0);
  Height = default.Height;

  //  Calculate number of chunks based on the size of the thing.
  int NumChunks = int(Radius*Height)/32;
  if (NumChunks < 4) NumChunks = 4;

  int i = NumChunks+((P_Random()-P_Random())%(NumChunks/4));
  if (i < 24) i = 24;
  for (; i >= 0; --i) {
    Actor A = Spawn(ChunkType, Origin+vector((Random()-0.5)*2.0*Radius, (Random()-0.5)*2.0*Radius, Random()*Height));
    if (A) {
      A.Velocity.z = (A.Origin.z-Origin.z)/Height*4.0*35.0;
      A.Velocity.x = (Random()-Random())*2.0*35.0;
      A.Velocity.y = (Random()-Random())*2.0*35.0;
      A.RenderStyle = RenderStyle;
      A.Alpha = Alpha;
      A.CopyFriendliness(self, true);
    }
  }

  // if it's a boss, execute special boss death actions
  if (bBossDeath) A_BossDeath();

  // drop items and go away
  A_NoBlocking();
  Destroy();
}


//==========================================================================
//
//  A_CheckProximity
//
//==========================================================================
final void A_CheckProximity (state Label, name classname, float distance, optional int count, optional int flags, optional int aptr) {
  // state jumps should not affect state chain results.
  if (XLevel.StateCall) XLevel.StateCall->Result = false;

  if (!specified_aptr) aptr = AAPTR_DEFAULT;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_CheckProximity', aptr));
  //if (!specified_aptr && tgt != Target) Error("WUTA?! in `A_CheckProximity`");
  if (!tgt) return;

  if (flags&CPXF_SETONPTR) {
    //k8: is this right?
    if (flags&CPXF_SETTARGET) tgt.Target = none;
    if (flags&CPXF_SETMASTER) tgt.Master = none;
    if (flags&CPXF_SETTRACER) tgt.Tracer = none;
  } else {
    if (flags&CPXF_SETTARGET) Target = none;
    if (flags&CPXF_SETMASTER) Master = none;
    if (flags&CPXF_SETTRACER) Tracer = none;
  }

  distance = fmax(0.1, distance);

  if (!specified_count) count = 1;
  if (count < 1) return; // oops
  if (!classname) return; // oops

  EntityEx bestent = none;
  float bestdist = (flags&CPXF_FARTHEST ? -1 : float.max);

  Entity ee;
  foreach RadiusThings(out ee, tgt.Origin, distance) {
    EntityEx ent = EntityEx(ee);
    if (!ent) continue;
    // k8: is this right?
    if (flags&CPXF_COUNTDEAD) {
      // nothing to do
    } else if (flags&CPXF_DEADONLY) {
      if (ent.bMonster && !ent.bCorpse) continue;
    } else {
      if (ent.bMonster && ent.bCorpse) continue;
    }
    // check class match
    if (nameicmp(GetClassName(ent.Class), classname) != 0) {
      if (!(flags&CPXF_ANCESTOR)) continue;
      class!EntityEx tc = class!EntityEx(ent.Class);
      bool found = false;
      while (tc) {
        if (nameicmp(GetClassName(tc), classname) == 0) { found = true; break; }
        tc = class!EntityEx(GetClassParent(tc));
      }
      if (!found) continue;
    }
    // check distance (save it, we may need it later)
    float dist = (flags&CPXF_NOZ ? tgt.DistTo2(ent) : tgt.DistTo(ent));
    if (dist > distance) continue;
    // check LOS
    if (flags&CPXF_CHECKSIGHT) {
      if (!tgt.CanSee(ent)) continue;
    }
    // count things
    --count;
    // early exit, if possible
    if (count < 0 && (flags&(CPXF_EXACT|CPXF_LESSOREQUAL))) return; // oops, too many
    // if we want it to be saved with a distance condition, we cannot exit early
    if ((flags&(CPXF_SETTARGET|CPXF_SETMASTER|CPXF_SETTRACER)) && (flags&(CPXF_FARTHEST|CPXF_CLOSEST))) {
      if (flags&CPXF_FARTHEST) {
        if (dist <= bestdist) continue;
      } else {
        // closest
        if (dist >= bestdist) continue;
      }
      bestent = ent;
      bestdist = dist;
    } else {
      if (!bestent) bestent = ent; // take first one
      // early exit, if possible
      if (count == 0 && !(flags&(CPXF_LESSOREQUAL|CPXF_EXACT))) break;
    }
  }

  if (!bestent) return; // nothing was found, oops

  // check condition
  if (flags&CPXF_EXACT) {
    if (count != 0) return;
  } else if (flags&CPXF_LESSOREQUAL) {
    if (count < 0) return;
  }

  // set pointers
  if (flags&(CPXF_SETTARGET|CPXF_SETMASTER|CPXF_SETTRACER)) {
    if (flags&CPXF_SETONPTR) {
      //k8: is this right?
      if (flags&CPXF_SETTARGET) tgt.Target = bestent;
      if (flags&CPXF_SETMASTER) tgt.Master = bestent;
      if (flags&CPXF_SETTRACER) tgt.Tracer = bestent;
    } else {
      if (flags&CPXF_SETTARGET) Target = bestent;
      if (flags&CPXF_SETMASTER) Master = bestent;
      if (flags&CPXF_SETTRACER) Tracer = bestent;
    }
  }

  // perform jump
  DoJump(Label);
}
