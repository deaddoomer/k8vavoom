//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

//**************************************************************************
//  State jumps
//**************************************************************************

//==========================================================================
//
//  A_Jump
//
//==========================================================================

final void A_Jump (int Chance, state Label1, optional state Label2,
  optional state Label3, optional state Label4, optional state Label5,
  optional state Label6, optional state Label7, optional state Label8,
  optional state Label9, optional state Label10, optional state Label11,
  optional state Label12, optional state Label13, optional state Label14,
  optional state Label15, optional state Label16, optional state Label17,
  optional state Label18, optional state Label19, optional state Label20,
  optional state Label21, optional state Label22, optional state Label23,
  optional state Label24, optional state Label25, optional state Label26,
  optional state Label27, optional state Label28, optional state Label29)
{
  if (Chance > 0) {
    state[32] List;
    List[0] = Label1;
    int count = 1;
    if (specified_Label2) List[count++] = Label2;
    if (specified_Label3) List[count++] = Label3;
    if (specified_Label4) List[count++] = Label4;
    if (specified_Label5) List[count++] = Label5;
    if (specified_Label6) List[count++] = Label6;
    if (specified_Label7) List[count++] = Label7;
    if (specified_Label8) List[count++] = Label8;
    if (specified_Label9) List[count++] = Label9;
    if (specified_Label10) List[count++] = Label10;
    if (specified_Label11) List[count++] = Label11;
    if (specified_Label12) List[count++] = Label12;
    if (specified_Label13) List[count++] = Label13;
    if (specified_Label14) List[count++] = Label14;
    if (specified_Label15) List[count++] = Label15;
    if (specified_Label16) List[count++] = Label16;
    if (specified_Label17) List[count++] = Label17;
    if (specified_Label18) List[count++] = Label18;
    if (specified_Label19) List[count++] = Label19;
    if (specified_Label20) List[count++] = Label20;
    if (specified_Label21) List[count++] = Label21;
    if (specified_Label22) List[count++] = Label22;
    if (specified_Label23) List[count++] = Label23;
    if (specified_Label24) List[count++] = Label24;
    if (specified_Label25) List[count++] = Label25;
    if (specified_Label26) List[count++] = Label26;
    if (specified_Label27) List[count++] = Label27;
    if (specified_Label28) List[count++] = Label28;
    if (specified_Label29) List[count++] = Label29;

    if (Chance > 255 || P_Random() < Chance) {
      int n = 0;
      if (count > 1) n = P_Random()%count;
      DoJump(List[n]);
    }
  }

  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
}


//==========================================================================
//
//  A_JumpIf
//
//==========================================================================
final void A_JumpIf (bool Expr, state Label) {
  if (Expr) DoJump(Label);

  // state jumps should not affect state chain results.
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
}

//==========================================================================
//
//  A_JumpIf
//
//  use `float` instead of bool, so decorate will work as expected
//
//==========================================================================
final void decorate_A_JumpIf (float Expr, state Label) {
  if (Expr) DoJump(Label);

  // state jumps should not affect state chain results.
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
}


//==========================================================================
//
//  A_JumpIfCloser
//
//==========================================================================
final void A_JumpIfCloser (float Dist, state Label) {
  EntityEx Targ;

  if (!bIsPlayer) {
    Targ = Target;
  } else {
    TVec Dir;
    Targ = Aim(Dir, 16.0 * 64.0);
  }

  if (Targ && DistTo2(Targ) < Dist &&
      ((Origin.z > Targ.Origin.z && Origin.z-Target.Origin.z-Target.Height < Dist) ||
       (Origin.z <= Targ.Origin.z && Target.Origin.z-Origin.z-Height < Dist)))
  {
    DoJump(Label);
  }

  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
}


//==========================================================================
//
//  A_JumpIfHealthLower
//
//==========================================================================

final void A_JumpIfHealthLower(int HealthVal, state Label, optional int aptr)
{
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_JumpIfHealthLower', aptr!optional));
  if (tgt) {
    if (tgt.Health < HealthVal) DoJump(Label);
  }
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
}

//==========================================================================
//
//  A_JumpIfInventory
//
//==========================================================================

final void A_JumpIfInventory(class!Actor ItemType, int Amount, state Label, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_JumpIfInventory', aptr!optional));
  if (!tgt) {
    XLevel.StateCall->Result = false;
    return;
  }

  if (ItemType) {
    Inventory Item = tgt.FindInventory(class!Inventory(ItemType));
    if (Item) {
      if ((Amount > 0 && Item.Amount >= Amount) ||
          (Amount == 0 && Item.Amount >= Item.MaxAmount))
      {
        DoJump(Label);
      }
    }
  }

  //  State jumps should not affect state chain results.
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
}

//==========================================================================
//
//  A_JumpIfInTargetInventory
//
//==========================================================================

final void A_JumpIfInTargetInventory(class!Actor ItemType, int Amount, state Label, optional int aptr)
{
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_JumpIfInventory', aptr!optional));
  if (!tgt) {
    XLevel.StateCall->Result = false;
    return;
  }

  if (ItemType && tgt.Target)
  {
    Inventory Item = tgt.Target.FindInventory(class!Inventory(ItemType));
    if (Item)
    {
      if ((Amount > 0 && Item.Amount >= Amount) ||
          (Amount == 0 && Item.Amount >= Item.MaxAmount))
      {
        DoJump(Label);
      }
    }
  }

  //  State jumps should not affect state chain results.
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
}


// Flags for A_JumpIfTargetInLOS and A_JumpIfInTargetLOS
//enum EJumpFlags
//!NOT_IMPLEMENTED!const int JLOSF_PROJECTILE =    1;
const int JLOSF_NOSIGHT =     1 << 1;
//!NOT_IMPLEMENTED!const int JLOSF_CLOSENOFOV =    1 << 2;
//!NOT_IMPLEMENTED!const int JLOSF_CLOSENOSIGHT =  1 << 3;
//!NOT_IMPLEMENTED!const int JLOSF_CLOSENOJUMP =   1 << 4;
const int JLOSF_DEADNOJUMP = 1<<5;
const int JLOSF_CHECKMASTER = 1<<6;
//!NOT_IMPLEMENTED!const int JLOSF_TARGETLOS =   1 << 7;
//!NOT_IMPLEMENTED!const int JLOSF_FLIPFOV =     1 << 8;
const int JLOSF_ALLYNOJUMP =    1 << 9;
//!NOT_IMPLEMENTED!const int JLOSF_COMBATANTONLY = 1 << 10;
//!NOT_IMPLEMENTED!const int JLOSF_NOAUTOAIM =   1 << 11;
//!NOT_IMPLEMENTED!const int JLOSF_CHECKTRACER =   1 << 12;
//};


//==========================================================================
//
//  A_JumpIfTargetInLOS
//
//==========================================================================
final void A_JumpIfTargetInLOS(state Label, optional float Fov, optional int flags, optional float distmax, optional float distclose) {
  // state jumps should not affect state chain results
  if (XLevel.StateCall) XLevel.StateCall->Result = false;

  if (distmax == 0) distmax = 8192;

  EntityEx Targ;
  if (!bIsPlayer) {
    Targ = (flags&JLOSF_CHECKMASTER ? Master : Target);
    if (!Targ) return;
    if (!(flags&JLOSF_NOSIGHT)) {
      if (!CanSee(Targ)) return;
    }
    if (Fov && Fov < 360.0) {
      float Ang = AngleMod180(atan2(Targ.Origin.y-Origin.y, Targ.Origin.x-Origin.x)-Angles.yaw);
      if (fabs(Ang) > Fov/2.0) return;
    }
  } else {
    TVec Dir;
    //Targ = Aim(Dir, distmax/*16.0*64.0*/); // old code
    bool noAAim = !PlayerEx(self).bAutoAim, noAAVert = false;
    Weapon Wpn = PlayerEx(self).ReadyWeapon;
    if (Wpn && Wpn.IsAutoaimDisabled()) noAAim = true; //bNoAutoaim;
    noAAVert = noAAim;
    Targ = Aim(nullptr, 8192/*16*64*/, Angles.yaw, noAutoaim:noAAim, noVertAutoAim:noAAVert);
  }

  if (Targ) {
    if ((flags&JLOSF_DEADNOJUMP) && Targ.Health <= 0) return;
    if (flags&JLOSF_ALLYNOJUMP) {
      //FIXME: incomplete
      if (Targ == self || (bIsPlayer && Targ.bFriendly)) return;
    }
    DoJump(Label);
  }
}


//==========================================================================
//
//  A_JumpIfCVarTrue
//
//==========================================================================

final void A_JumpIfCVarTrue (string cvar, state Label) {
  name cvn = StrToName(cvar);
  if (CvarExists(cvn)) {
    if (GetCvarB(cvn)) DoJump(Label);
  }
  // State jumps should not affect state chain results.
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
}

//==========================================================================
//
//  A_JumpIfCVarFalse
//
//==========================================================================

final void A_JumpIfCVarFalse (string cvar, state Label) {
  name cvn = name(cvar);
  if (CvarExists(cvn)) {
    //print("A_JumpIfCVarFalse: cvar is '%s', value is %s", cvar, (GetCvarB(cvn) ? "true" : "false"));
    if (!GetCvarB(cvn)) DoJump(Label);
  } else {
    //print("A_JumpIfCVarFalse: cvar '%s' NOT FOUND!", cvar);
    DoJump(Label);
  }
  // State jumps should not affect state chain results.
  if (XLevel.StateCall) XLevel.StateCall->Result = false;
}
