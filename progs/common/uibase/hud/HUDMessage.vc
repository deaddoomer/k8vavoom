//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
class HUDMessage : Widget;

// ID, used as a priority or to replace a previous message.
int Id;

array!SplitLine MsgLines;
name MsgFont;
int MsgColour;
float MsgAlpha;

// calculated size of the message box
int MsgWidth;
int MsgHeight;

// message location
float MsgX;
float MsgY;

int HudWidth;
int HudHeight;

// true if text lines should be centred
bool bCentreX;

float HoldTime;
float Time;


//==========================================================================
//
//  Init
//
//==========================================================================
void Init (string Message, name AFont, int Type, int AId, int Colour,
  float AMsgX, float AMsgY, int AHudWidth, int AHudHeight, float AHoldTime,
  float Time1, float Time2)
{
  Id = AId;
  MsgFont = AFont;
  if (!MsgFont) MsgFont = 'smallfont';
  MsgColour = Colour;
  HoldTime = AHoldTime;

  // position of the message
  MsgX = AMsgX;
  MsgY = AMsgY;
  if (AHudWidth == 0 || AHudHeight == 0) {
    /*
    writeln("HUD0: ", AHudWidth, "x", AHudHeight, "; msgx=", AMsgX, "; msgy=", AMsgY);
    SetSize(GetVirtualWidth(), GetVirtualHeight());
    Width = GetVirtualWidth();
    Height = GetVirtualHeight();
    writeln("  size: ", Width, "x", Height);
    */
    if (fabs(MsgX) > 2.0) {
      bCentreX = true;
      MsgX = 0.5;
    } else {
      if (fabs(MsgX) > 1.0) bCentreX = true;
      MsgX = (MsgX > 1.0 ? MsgX-1.0 : MsgX < -1.0 ? MsgX+1.0 : MsgX);
    }
  } else {
    //writeln("HUD1: ", AHudWidth, "x", AHudHeight);
    HudWidth = AHudWidth;
    HudHeight = AHudHeight;
    Width = abs(HudWidth);
    Height = abs(HudHeight);
    ScaleX = float(Parent.Width)/float(Width);
    ScaleY = float(Parent.Height)/float(Height);

    int IntPart = int(MsgX);
    int FracPart = int(fabs(MsgX-float(IntPart))*10.0+0.5);
    if (FracPart&4) bCentreX = true;
    if (MsgX > 0.0) {
      MsgX = float(IntPart)+float(FracPart&3)/10.0;
    } else {
      MsgX = float(IntPart)-float(FracPart&3)/10.0;
    }
  }

  // calculate width and height of the text
  SetFont(MsgFont);
  MsgHeight = SplitText(Message, MsgLines, Width);
  MsgWidth = 0;
  foreach (auto i; 0..MsgLines.length) {
    if (MsgLines[i].Width > MsgWidth) MsgWidth = MsgLines[i].Width;
  }
}


//==========================================================================
//
//  OnDraw
//
//==========================================================================
override void OnDraw () {
  int x, y;

  if (HudWidth == 0) {
    //writeln("HUD0: ", HudWidth, "x", HudHeight, "; msgx=", MsgX, "; msgy=", MsgY);
    SetSize(GetVirtualWidth(), GetVirtualHeight());
    //writeln("  size: ", Width, "x", Height);

    if (MsgX > 0.0) {
      x = int(float(Width-MsgWidth)*MsgX);
    } else {
      x = int(float(Width)*(-MsgX));
    }
    if (MsgY > 0.0) {
      y = int(float(Height-MsgHeight)*MsgY);
    } else {
      y = int(float(Height)*(-MsgY));
    }
  } else {
    SetSize(GetVirtualWidth(), GetVirtualHeight());

    int IntPart = int(MsgX);
    int FracPart = int(fabs(MsgX-float(IntPart))*10.0+0.5);
    x = IntPart;
    // fractional part specifies alignment:
    //   0 - centre
    //   1 - left
    //   2 - right
    switch (FracPart&3) {
      case 0: x -= MsgWidth/2; break;
      case 2: x -= MsgWidth; break;
    }

    IntPart = int(MsgY);
    FracPart = int(fabs(MsgY-float(IntPart))*10.0+0.5);
    y = IntPart;
    // fractional part specifies alignment:
    //   0 - centre
    //   1 - top
    //   2 - bottom
    switch (FracPart&3) {
      case 0: y -= MsgHeight/2; break;
      case 2: y -= MsgHeight; break;
    }
  }

  foreach (auto i; 0..MsgLines.length) {
    if (bCentreX) {
      DrawLine(i, x+(MsgWidth-MsgLines[i].Width)/2, y, MsgLines[i].Text);
    } else {
      DrawLine(i, x, y, MsgLines[i].Text);
    }
    y += MsgHeight/MsgLines.length;
  }
}


//==========================================================================
//
//  DrawLine
//
//==========================================================================
void DrawLine (int LineIdx, int x, int y, string Text) {
  DrawText(x, y, Text, MsgColour, CR_YELLOW, MsgAlpha);
}


//==========================================================================
//
//  Tick
//
//==========================================================================
override void Tick (float DeltaTime) {
  Time += DeltaTime;
  if (HoldTime && HoldTime < Time) MarkDead(); //Destroy();
}


defaultproperties {
  Width = 640;
  Height = 480;
  bTickEnabled = true;
  MsgAlpha = 1.0;
}
