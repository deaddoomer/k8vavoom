//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class HUDMessage : Widget;

// ID, used as a priority or to replace a previous message.
int Id;
int ticStart; // do not start message before this tic

string oldtext;
name oldfont;

array!SplitLine MsgLines;
name MsgFont;
int MsgColor;
float MsgAlpha;

// calculated size of the message box
int MsgWidth;
int MsgHeight;

// message location
float MsgX;
float MsgY;

int HudWidth;
int HudHeight;
bool isTextFont;

// true if text lines should be centered
bool bCenterX;
bool isHealthBar;

float HoldTime;
float Time;

/*ClientGameShared*/ClientGameBase ClGame;

float hbarCurr, hbarMax; // health

int hbarPicBack = -1;
int hbarPicFill = -1;
int hbarPicBorder = -1;


//==========================================================================
//
//  Reset
//
//==========================================================================
void Reset () {
  ticStart = default.ticStart;
  oldtext = default.oldtext;
  oldfont = default.oldfont;
  MsgLines.reset();
  MsgFont = default.MsgFont;
  MsgColor = default.MsgColor;
  MsgAlpha = default.MsgAlpha;
  MsgWidth = default.MsgWidth;
  MsgHeight = default.MsgHeight;
  MsgX = default.MsgX;
  MsgY = default.MsgY;
  HudWidth = default.HudWidth;
  HudHeight = default.HudHeight;
  isTextFont = default.isTextFont;
  bCenterX = default.bCenterX;
  isHealthBar = default.isHealthBar;
  HoldTime = default.HoldTime;
  Time = default.Time;
  hbarCurr = default.hbarCurr;
  hbarMax = default.hbarMax;
  hbarPicBack = default.hbarPicBack;
  hbarPicFill = default.hbarPicFill;
  hbarPicBorder = default.hbarPicBorder;
}


//==========================================================================
//
//  HBarLoadGfx
//
//==========================================================================
void HBarLoadGfx () {
  hbarPicBack = R_RegisterPicPath('graphics/healthbar/hbarbot.png');
  hbarPicFill = R_RegisterPicPath('graphics/healthbar/hbartop.png');
  hbarPicBorder = R_RegisterPicPath('graphics/healthbar/hbarbrd.png');
  if (hbarPicBack < 0 || hbarPicFill < 0 || hbarPicBorder < 0) {
    hbarPicBack = -666;
  }
}


//==========================================================================
//
//  IsActive
//
//==========================================================================
final bool IsActive () {
  if (!ClGame || !ClGame.Game) return true; // just in case
  if (ClGame.Game.isPaused) return false; // paused
  // check scheduled tic
  if (!ClGame.GLevel) return true; // just in case
  if (ClGame.GLevel.TicTime < ticStart) return false; // not active yet
  return true; // active
}


//==========================================================================
//
//  Init
//
//==========================================================================
void Init (string Message, name AFont, int Type, int AId, int Color,
  float AMsgX, float AMsgY, int AHudWidth, int AHudHeight, float AHoldTime,
  float Time1, float Time2)
{
  Time = 0;

  // health bar: Time1 is current health, Time2 is max health, Message is name

  //print("HUDMSG(%d): font=[%s]; pos=(%f,%f); size=(%d,%d); msg=<%q>; HoldTime=%s; times=(%s,%s)", AId, AFont, AMsgX, AMsgY, AHudWidth, AHudHeight, Message, AHoldTime, Time1, Time2);
  //ticStart = (ClGame && ClGame.GLevel ? ClGame.GLevel.TicTime+1 : 0); // schedule to next tic (k8: no more)
  ticStart = 0;

  Id = AId;
  MsgFont = AFont;
  if (!MsgFont) { MsgFont = 'smallfont'; AFont = MsgFont; }
  MsgColor = Color;
  HoldTime = AHoldTime;
  HoldTime = fclamp(HoldTime, 0, 100000); // 0 MEANS ALOT HERE!
  //if (HoldTime > 0) HoldTime += 0.5/35.0;

  if (AFont == 'HEALTHBAR') {
    MsgFont = 'smallfont';
    HBarLoadGfx();
    isHealthBar = true;
    hbarCurr = fmax(0, Time1);
    hbarMax = fmax(1, Time2);
    bCenterX = true;
    MsgAlpha = fclamp(GetCvarF('k8HealthBarAlpha'), 0, 1);
    HoldTime = 0.25;
  } else {
    isHealthBar = false;
  }

  if (GetCvarB('hud_scale_messages')) {
    isTextFont =
      (nameicmp(AFont, 'confont') == 0) ||
      (nameicmp(AFont, 'smallfont') == 0) ||
      (nameicmp(AFont, 'smallfont2') == 0) ||
      (nameicmp(AFont, 'bigfont') == 0);
  }
  if (isHealthBar) isTextFont = false;

  // check for spaces
  /*
  if (isTextFont) {
    bool allSpaces = true;
    foreach (auto f; 0..Message.length) if (Message[f] > 32) { allSpaces = false; break; }
    if (!allSpaces) {
      print("HUDMSG: font=<%s>; pos=(%f,%f); size=(%d,%d); msg=<%q>", AFont, AMsgX, AMsgY, AHudWidth, AHudHeight, Message);
    }
  }
  */

  auto root = GetRootWidget();
  if (Width != root.Width || Height != root.Height) {
    //SetSize(GetVirtualWidth(), GetVirtualHeight());
    SetSize(root.Width, root.Height);
  }

  int wrapWidth = GetVirtualWidth()-32;

  // position of the message
  MsgX = AMsgX;
  MsgY = AMsgY;
  if (AHudWidth == 0 || AHudHeight == 0) {
    /*
    writeln("HUD0: ", AHudWidth, "x", AHudHeight, "; msgx=", AMsgX, "; msgy=", AMsgY);
    SetSize(GetVirtualWidth(), GetVirtualHeight());
    Width = GetVirtualWidth();
    Height = GetVirtualHeight();
    writeln("  size: ", Width, "x", Height);
    */
    if (fabs(MsgX) > 2.0) {
      bCenterX = true;
      MsgX = 0.5;
    } else {
      if (fabs(MsgX) > 1.0) bCenterX = true;
      MsgX = (MsgX > 1.0 ? MsgX-1.0 : MsgX < -1.0 ? MsgX+1.0 : MsgX);
    }
    if (fabs(MsgY-0.5) <= 0.1) {
      if (MsgY <= 0.5) MsgY -= 0.1; else MsgY += 0.1;
    }

    int wx = GetVirtualWidth()-int(GetVirtualWidth()*(fabs(MsgX)*2))-32;
    if (wx < 32) {
      wrapWidth = 640-32;
    } else {
      wrapWidth = max(320, min(wrapWidth, wx));
    }
  } else {
    //writeln("HUD1: ", AHudWidth, "x", AHudHeight);
    HudWidth = AHudWidth;
    HudHeight = AHudHeight;
    wrapWidth = abs(HudWidth);

    /*
    auto root = GetRootWidget();
    if (root) {
      if (Width != root.Width || Height != root.Height) {
        //SetSize(GetVirtualWidth(), GetVirtualHeight());
        SetSize(root.Width, root.Height);
      }
    }
    */

    /*
    SetFont(MsgFont);
    int tw = TextHeight(va("%q", Message));
    if (tw > TextHeight("AW")+4) {
      // this must be a picture
      isTextFont = false;
    }
    print("%n:<%q>", AFont, Message);
    */

    int IntPart = int(MsgX);
    int FracPart = int(fabs(MsgX-float(IntPart))*10.0+0.5);
    if (FracPart&4) bCenterX = true;
    if (MsgX > 0.0) {
      MsgX = float(IntPart)+float(FracPart&3)/10.0;
    } else {
      MsgX = float(IntPart)-float(FracPart&3)/10.0;
    }

    if (!isTextFont) {
      float sx = float(root.Width)/float(abs(HudWidth));
      float sy = float(root.Height)/float(abs(HudHeight));
      ScaleX = sx;
      ScaleY = sy;
      //print("  scale:(%f,%f); scaled size:(%s, %s); vsize=(%s,%s); rsize=(%s,%s)", sx, sy, roundi(root.Width/sx), roundi(root.Height/sy), GetVirtualWidth(), GetVirtualHeight(), root.Width, root.Height);
      SetSize(roundi(root.Width/sx), roundi(root.Height/sy));
      //root.dumpClipRect();
      //print("============"); for (Widget ww = self; ww; ww = ww.Parent) { print("ww=%C", ww); ww.dumpClipRect(); }
    } else {
      float sx = float(root.Width)/float(abs(HudWidth));
      int wx = GetVirtualWidth()-roundi(MsgX*sx)*2-32;
      //print("*** wx=%d", wx);
      if (wx < 32) {
        wrapWidth = GetVirtualWidth()-32;
      } else {
        wrapWidth = max(320, min(wrapWidth, wx));
      }
    }
  }

  // calculate width and height of the text
  if (Message != oldtext || AFont != oldfont) {
    MsgLines.length = 0;
    SetFont(MsgFont);
    MsgHeight = SplitText(Message, MsgLines, /*Width*/wrapWidth);
    //print("========= <%q> (%s:%s) =========", Message, MsgLines.length, wrapWidth);
    MsgWidth = 0;
    foreach (auto i; 0..MsgLines.length) {
      //print("  #%d: <%q>", i, MsgLines[i].Text);
      if (MsgLines[i].Width > MsgWidth) MsgWidth = MsgLines[i].Width;
    }
  }
}


//==========================================================================
//
//  OnDraw
//
//==========================================================================
override void OnDraw () {
  int x, y;

  SetFont(MsgFont);

  auto root = GetRootWidget();
  /*
  if (Width != root.Width || Height != root.Height) {
    //SetSize(GetVirtualWidth(), GetVirtualHeight());
    SetSize(root.Width, root.Height);
  }
  */
  //print("rhgt=%d; hgt=%d; vhgt=%d", root.Height, Height, GetVirtualHeight());

  if (HudWidth == 0) {
    //writeln("HUD0: ", HudWidth, "x", HudHeight, "; msgx=", MsgX, "; msgy=", MsgY);
    //writeln("  size: ", Width, "x", Height);

    if (MsgX > 0.0) {
      x = int(float(Width-MsgWidth)*MsgX);
    } else {
      x = int(float(Width)*(-MsgX));
    }
    if (MsgY > 0.0) {
      y = int(float(Height-MsgHeight)*MsgY);
    } else {
      y = int(float(Height)*(-MsgY));
    }
  } else {
    int msgwdt = MsgWidth;
    int msghgt = MsgHeight;
    x = int(MsgX);
    y = int(MsgY);

    //float sx = float(GetVirtualWidth())/float(abs(HudWidth));
    //float sy = float(GetVirtualHeight())/float(abs(HudHeight));
    if (isTextFont) {
      //FIXME: make big scales work as expected
      float sx = float(root.Width)/float(abs(HudWidth));
      float sy = float(root.Height)/float(abs(HudHeight));
      /*
      print("HUDMSG: msg=<%q>; pos=(%d,%d); fixedpos=(%d,%d); scale=(%f,%f); size=(%d,%d); hudsize=(%d,%d)", MsgLines[0].Text, x, y, roundi(x*sx), roundi(y*sy), sx, sy, Width, Height, HudWidth, HudHeight);
      dumpClipRect("self");
      root.dumpClipRect("root");
      */
      x = roundi(x*sx);
      y = roundi(y*sy);
      // scale this, so center will work properly
      //msgwdt = roundi(msgwdt*sx);
      //msghgt = roundi(msghgt*sx);
      //ScaleX = 1;
      //ScaleY = 1;
    }

    //print("msg=<%q>", MsgLines[0].Text);
    int IntPart = int(MsgX);
    int FracPart = int(fabs(MsgX-float(IntPart))*10.0+0.5);
    //print("  x=%d; frac=%d", x, FracPart);
    // fractional part specifies alignment:
    //   0 - center
    //   1 - left
    //   2 - right
    switch (FracPart&3) {
      case 0: x -= MsgWidth/2; break;
      case 2: x -= MsgWidth; break;
    }

    IntPart = int(MsgY);
    FracPart = int(fabs(MsgY-float(IntPart))*10.0+0.5);
    //print("  y=%d; frac=%d", y, FracPart);
    // fractional part specifies alignment:
    //   0 - center
    //   1 - top
    //   2 - bottom
    switch (FracPart&3) {
      case 0: y -= MsgHeight/2; break;
      case 2: y -= MsgHeight; break;
    }

  }

  if (isHealthBar && hbarPicBack > 0) {
    // hbarPicBorder: 320x16
    // hbarPicBack: 316x10
    // hbarPicFill: 316x10
    int picX = (root.Width-320)/2;
    /*
    R_DrawPic(picX, y, hbarPicBorder);
    R_DrawPic(picX, y, hbarPicBack);
    R_DrawPicPart(picX, y, fclamp(hbarCurr/hbarMax, 0, 1), 1, hbarPicFill);
    */
    float used = fclamp(hbarCurr/hbarMax, 0, 1);
    //used = 0.3;
    R_DrawPic(picX, y, hbarPicBorder, MsgAlpha);
    if (used > 0) R_DrawPicPart(picX, y, used, 1, hbarPicFill, MsgAlpha);
    if (used < 1) R_DrawPicPartEx(picX, y, used, 0, 1, 1, hbarPicBack, MsgAlpha);
    y += 16;
  }

  foreach (auto i; 0..MsgLines.length) {
    if (bCenterX) {
      DrawTextLine(i, x+(MsgWidth-MsgLines[i].Width)/2, y, MsgLines[i].Text);
    } else {
      DrawTextLine(i, x, y, MsgLines[i].Text);
    }
    y += MsgHeight/MsgLines.length;
  }
}


//==========================================================================
//
//  DrawTextLine
//
//==========================================================================
void DrawTextLine (int LineIdx, int x, int y, string Text) {
  float alpha = (isTextFont ? MsgAlpha : (MsgAlpha >= 1 ? 0.99 : MsgAlpha));
  DrawText(x, y, Text, MsgColor, CR_YELLOW, alpha);
}


//==========================================================================
//
//  Tick
//
//==========================================================================
override void Tick (float DeltaTime) {
  if (!IsActive) return; // do not tick when game is paused
  if (HoldTime && Time > HoldTime) {
    if (isHealthBar) {
      while (MsgAlpha > 0 && Time > HoldTime) {
        MsgAlpha -= 0.05;
        HoldTime += 0.05;
      }
      if (MsgAlpha <= 0) {
        Destroy();
        return;
      }
    } else {
      //print("TIME=%s; HoldTime=%s; tfrm=%s; htfrm=%s; <%q>", Time, HoldTime, Time/35.0, HoldTime/35.0, (MsgLines.length ? MsgLines[0].Text : "<>"));
      Destroy();
      return;
    }
  }
  // moved here, so messages won't blink
  Time += DeltaTime;
}


defaultproperties {
  Width = 640;
  Height = 480;
  bTickEnabled = true;
  MsgAlpha = 1.0;
}
