//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2021 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class StatusBarShared : Widget;

protected ClientGameBase ClGame;

enum NUM_NOTIFY_LINES = 8;
enum NUM_CHAT_LINES = 16;

const float CenterMessageFadeoutTime = 0.3;

struct NotifyMessage {
  string text;
  string nick; // for chat
  int dupcount;
  float time;
}

// sorted by time
array!NotifyMessage notifyMessages; // NUM_NOTIFY_LINES
int notifyMsgCount;

// sorted by time
array!NotifyMessage chatMessages; // NUM_CHAT_LINES
int chatMsgCount;

array!SplitLine CenterMessageLines;
int CenterMessageHeight;
float CenterTime;

HUDMessageContainer HudMsgWin;

bool lastWasFullscreen;


enum {
  SB_DMG_TOP,
  SB_DMG_BOTTOM,
  SB_DMG_LEFT,
  SB_DMG_RIGHT,
  SB_DMG_LEFT_TOP,
  SB_DMG_LEFT_BOTTOM,
  SB_DMG_RIGHT_TOP,
  SB_DMG_RIGHT_BOTTOM,

  SB_DMG_MAXDIR,
};

const int SB_DMG_UP_FLAG = 1;
const int SB_DMG_DOWN_FLAG = 2;

const float SB_DMG_TIMEOUT = 0.8;
const float SB_DMG_ALPHA = 0.8;

// 640x512
// ofs is from the center
const float SB_DMG_XOFS = 0.05;
const float SB_DMG_YOFS = 0.05;
// height/width fraction
const float SB_DMG_SIZE = 0.1;
const float SB_DMG_SMALL_SIZE_B = 0.7;
const float SB_DMG_SMALL_SIZE_S = 0.3;
// in pixels
const int SB_DMG_THICKNESS = 8;



//==========================================================================
//
//  OnCreate
//
//==========================================================================
override void OnCreate () {
  ::OnCreate();
  HudMsgWin = NewChild(HUDMessageContainer);
  HudMsgWin.ClGame = ClGame;
  Width = GetVirtualWidth();
  Height = GetVirtualHeight();
  //HudMsgWin.Width = Width;
  //HudMsgWin.Height = Height;
  lastWasFullscreen = false;
  // load healthbar graphics
  R_RegisterPicPath('graphics/healthbar/healthbar_bottom.png');
  R_RegisterPicPath('graphics/healthbar/healthbar_top.png');
  R_RegisterPicPath('graphics/healthbar/healthbar_border.png');
}


//==========================================================================
//
//  SetClGame
//
//==========================================================================
void SetClGame (ClientGameBase aclgame) {
  ClGame = aclgame;
  HudMsgWin.ClGame = ClGame;
}


//==========================================================================
//
//  SetClGame
//
//==========================================================================
ClientGameBase GetClGame () {
  return ClGame;
}


//==========================================================================
//
//  StartMap
//
//  WARNING! this can be called several times for one map! (k8:FIXME!)
//
//==========================================================================
void StartMap () {
  ClearNotify();
  ClearCenterMessage();
  ClearHudMessages();
}


//==========================================================================
//
//  OnDraw
//
//==========================================================================
override void OnDraw () {
  DrawNotify();
  DrawChat();
  DrawCenterMessage();
}


//==========================================================================
//
//  Tick
//
//==========================================================================
override void Tick (float DeltaTime) {
  auto root = GetRootWidget();
  //print("SBTICK: root=%C; sz=(%d,%d)", root, root.Width, root.Height);
  if (root && (Width != root.Width || Height != root.Height)) {
    SetSize(root.Width, root.Height);
  }
  UpdateNotify(DeltaTime);
  UpdateChat(DeltaTime);
  UpdateCenterMessage(DeltaTime);
}


//**************************************************************************
//  Notify messages
//**************************************************************************

//==========================================================================
//
//  ClearNotify
//
//==========================================================================
void ClearNotify () {
  notifyMsgCount = 0;
  chatMsgCount = 0;
}


//==========================================================================
//
//  CompressMessageSlots
//
//==========================================================================
void CompressMessageSlots (ref array!NotifyMessage list, ref int count) {
  list.sort(delegate int (ref NotifyMessage a, ref NotifyMessage b) {
    if (a.time <= 0.0) {
      // timeouted messages will be moved to the end of the list
      return (b.time <= 0.0 ? 0 : 1);
    } else if (b.time <= 0.0) {
      // timeouted messages will be moved to the end of the list
      return -1;
    } else {
      float d = (a.time-b.time);
      return (d < 0 ? -1 : d > 0 ? 1 : 0);
    }
  });
  count = 0;
  while (count < list.length && list[count].time > 0.0) ++count;
}


//==========================================================================
//
//  AllocMessageSlot
//
//==========================================================================
void AllocMessageSlot (int maxcount, ref array!NotifyMessage list, ref int count, string nick, string s, float time) {
  if (time <= 0.0) return;
  if (!s) return;
  // find existing message
  NotifyMessage *msg;
  for (int n = count-1; n >= 0; --n) {
    msg = &list[n];
    assert(msg.time > 0.0);
    if (msg.nick == nick && msg.text == s) {
      ++msg.dupcount;
      msg.time = time;
      CompressMessageSlots(ref list, ref count);
      return;
    }
  }
  // append new message
  assert(count <= maxcount);
  if (count == maxcount) {
    foreach (int c; 1..list.length) list[c-1] = list[c];
  } else {
    if (list.length < maxcount) list.length = maxcount;
    ++count;
  }
  msg = &list[count-1];
  msg.dupcount = 1;
  msg.nick = nick;
  msg.text = s;
  msg.time = time;
}


//==========================================================================
//
//  AddNotifyMessage
//
//==========================================================================
void AddNotifyMessage (string Str) {
  Str = Str.xstrip;
  if (!Str) return;

  SetFont('smallfont');
  array!SplitLine Lines;
  SplitText(Str, Lines, GetVirtualWidth()-32);

  foreach (auto i; 0..Lines.length) {
    string text = Lines[i].Text.xstrip;
    if (!text) continue;
    AllocMessageSlot(NUM_NOTIFY_LINES, ref notifyMessages, ref notifyMsgCount, "", text, GetCvarF('hud_notify_time'));
  }
}


//==========================================================================
//
//  AddChatMessage
//
//==========================================================================
void AddChatMessage (string nick, string aText) {
  aText = aText.xstrip;
  if (!aText) return;

  nick = nick.removeColors.xstrip;
  if (!nick) nick = "<dumb>";
  nick ~= ":";

  SetFont('smallfont');
  array!SplitLine Lines;
  SplitText(aText, Lines, GetVirtualWidth()-32);

  foreach (auto i; 0..Lines.length) {
    string text = Lines[i].Text.removeColors.xstrip;
    if (!text) continue;
    AllocMessageSlot(NUM_CHAT_LINES, ref chatMessages, ref chatMsgCount, nick, text, GetCvarF('hud_chat_time'));
  }
}


//==========================================================================
//
//  DrawNotify
//
//==========================================================================
void DrawNotify () {
  if (!notifyMsgCount) return;
  SetFont('smallfont');
  SetTextAlign(hleft, vtop);

  int col = GetCvar('hud_font_color');

  // notify lines
  int y = 0;
  if (GetCvar('dbg_world_think_vm_time') || GetCvar('dbg_world_think_decal_time') || GetCvar('draw_gc_stats')) y += FontHeight();

  foreach (ref NotifyMessage msg; notifyMessages) {
    if (msg.time > 0.0) {
      DrawText(4, y, (msg.dupcount > 1 ? va("%s  \c[darkgreen][x%s]", msg.text, msg.dupcount) : msg.text), col);
      y += FontHeight();
    }
  }
}


//==========================================================================
//
//  DrawChat
//
//==========================================================================
void DrawChat () {
  if (!chatMsgCount) return;
  SetFont('smallfont');
  SetTextAlign(hleft, vtop);

  int ncol = GetCvar('hud_chat_nick_color');
  int tcol = GetCvar('hud_chat_text_color');

  // count messages
  int y = Height-64;
  foreach (ref NotifyMessage msg; chatMessages) {
    if (msg.time > 0.0) y -= FontHeight();
  }

  foreach (ref NotifyMessage msg; chatMessages) {
    if (msg.time > 0.0) {
      DrawText(4, y, msg.nick, ncol);
      DrawText(4+TextWidth(msg.nick)+2, y, (msg.dupcount > 1 ? va("%s  \c[darkgreen][x%s]", msg.text, msg.dupcount) : msg.text), tcol);
      y += FontHeight();
    }
  }
}


//==========================================================================
//
//  UpdateNotify
//
//==========================================================================
void UpdateNotify (float DeltaTime) {
  if (!notifyMsgCount) return;
  bool changed = false;
  foreach (ref NotifyMessage msg; notifyMessages) {
    if (msg.time > 0.0) { changed = true; msg.time -= DeltaTime; }
  }
  if (changed) CompressMessageSlots(ref notifyMessages, ref notifyMsgCount);
}


//==========================================================================
//
//  UpdateChat
//
//==========================================================================
void UpdateChat (float DeltaTime) {
  if (!chatMsgCount) return;
  bool changed = false;
  foreach (ref NotifyMessage msg; chatMessages) {
    if (msg.time > 0.0) { changed = true; msg.time -= DeltaTime; }
  }
  if (changed) CompressMessageSlots(ref chatMessages, ref chatMsgCount);
}


//**************************************************************************
//  Center message
//**************************************************************************

//==========================================================================
//
//  ClearCenterMessage
//
//==========================================================================
void ClearCenterMessage () {
  CenterTime = 0.0;
}


//==========================================================================
//
//  AddCenterMessage
//
//==========================================================================
void AddCenterMessage (string Msg) {
  SetFont('smallfont');
  CenterMessageHeight = SplitText(Msg, CenterMessageLines, 600);
  CenterTime = fmax(0.5, GetCvarF('hud_center_message_time'));
}


//==========================================================================
//
//  DrawCenterMessage
//
//==========================================================================
void DrawCenterMessage () {
  if (CenterTime && CenterMessageLines) {
    //auto ovw = GetVirtualWidth();
    //auto ovh = GetVirtualHeight();
    auto ovw = cast(int)Width;
    auto ovh = cast(int)Height;
    int LineH = CenterMessageHeight/CenterMessageLines.length;
    SetFont('smallfont');
    SetTextAlign(hleft, vtop);
    int tx = ovw/2;
    int ty = (ovh-FontHeight()-4)/2-CenterMessageLines.length*LineH;
    float alpha = (CenterTime < 0 ? (CenterMessageFadeoutTime+CenterTime)/CenterMessageFadeoutTime : 1);
    foreach (auto i; 0..CenterMessageLines.length) {
      DrawText(tx-CenterMessageLines[i].Width/2, ty+i*LineH, CenterMessageLines[i].Text, GetCvar('hud_font_color_centered'), CR_YELLOW, alpha);
    }
  }
}


//==========================================================================
//
//  UpdateCenterMessage
//
//==========================================================================
void UpdateCenterMessage (float DeltaTime) {
  if (CenterTime) {
    CenterTime -= DeltaTime;
    if (CenterTime < -CenterMessageFadeoutTime) CenterTime = 0.0;
  }
}



//**************************************************************************
//  HUD messages
//**************************************************************************

//==========================================================================
//
//  ClearHudMessages
//
//==========================================================================
void ClearHudMessages () {
  if (HudMsgWin) HudMsgWin.ClearHudMessages();
}


//==========================================================================
//
//  AddHudMessage
//
//==========================================================================
void AddHudMessage (string Message, name aFont, int Type, int Id, int Color,
  string ColorName, float x, float y, int HudWidth, int HudHeight,
  float HoldTime, float Time1, float Time2, float Alpha)
{
  if (!HudMsgWin) return;
  HudMsgWin.AddHudMessage(Message, aFont, Type, Id, Color, ColorName, x, y, HudWidth, HudHeight, HoldTime, Time1, Time2, Alpha);
}


// fullscreen statusbar
 // the screen is not 640x480
void SB_DrawFullscreenStats () {}

// normal statusbar, called in order
void SB_DrawMainBarPre (bool inAutomap) {} // the screen is not 640x480
void SB_FillMainBar (bool inAutomap) {} // this fills the sides with the rock texture; the screen is 640x480
void SB_DrawMainBar (bool inAutomap) {} // the screen is 640x480
void SB_DrawMainBarPost (bool inAutomap) {} // the screen is not 640x480


struct SB_SavedVScreenState {
  int width, height;
  float scaleY;
}


final void SB_SetCorrected640x480 (out SB_SavedVScreenState sss) {
  sss.width = GetVirtualWidth();
  sss.height = GetVirtualHeight();
  sss.scaleY = ScaleY;
  SetVirtualScreen(640, 480);
  if (Width != 640 || Height != 480) SetSize(640, 480);
  ScaleY = ScaleY*R_GetAspectRatio();
  Y = -int(480.0*ScaleY-480);
}


final void SB_RestoreVScreen (const ref SB_SavedVScreenState sss) {
  ScaleY = sss.scaleY;
  Y = 0;
  SetVirtualScreen(sss.width, sss.height);
  if (Width != sss.width || Height != sss.height) SetSize(sss.width, sss.height);
}


void SB_DrawMainBarCorrected (bool inAutomap, bool doFill) {
  SB_SavedVScreenState sss;
  SB_SetCorrected640x480(out sss);
  scope(exit) SB_RestoreVScreen(ref sss);
  if (doFill) SB_FillMainBar(inAutomap);
  SB_DrawMainBar(inAutomap);
}


// this is common code for all games
void SB_DrawMainPart (int sb_view) {
  int sblocks = R_GetScreenBlocks();
  if (sblocks >= R_SCREEN_BLOCKS_NO_STATUSBAR) return;
  auto ovw = GetVirtualWidth();
  auto ovh = GetVirtualHeight();
  if (Width != ovw || Height != ovh) SetSize(ovw, ovh);
  if (sb_view == SB_VIEW_FULLSCREEN || sblocks >= R_SCREEN_BLOCKS_FS_STATUSBAR) {
    SB_DrawFullscreenStats();
  } else {
    bool inAutomap = (sb_view == SB_VIEW_AUTOMAP);
    SB_DrawMainBarPre(inAutomap);
    SB_DrawMainBarCorrected(inAutomap, doFill:true);
    SB_DrawMainBarPost(inAutomap);
  }
}


// global locations
const int WI_SPACINGY = 33;

// deathmatch stuff
const int DM_MATRIXX = 202;
const int DM_MATRIXY = 208;

const int DM_TOTALSX = 329;
const int DM_DEATHSX = 429;

const int DM_SPACINGX = 40;


//==========================================================================
//
//  SB_DrawDeathmatchStats
//
//==========================================================================
void SB_DrawDeathmatchStats () {
  SetFont('bigfont');

  PlayerReplicationInfo RepInfo;

  SetTextAlign(hcenter, vtop);
  // draw stat titles (top line)
  DrawText(DM_TOTALSX, DM_MATRIXY-WI_SPACINGY, "FRAGS");
  DrawText(DM_DEATHSX, DM_MATRIXY-WI_SPACINGY, "DEATHS");

  // draw stats
  int y = DM_MATRIXY;

  foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo) {
    if (RepInfo.PlayerNum == ClGame.cl.ClientNum) {
      // your face
      int star = R_RegisterPic('stfst01');
      picinfo_t info;
      R_GetPicInfo(star, &info);
      DrawPic(DM_MATRIXX-info.width-5, y-8, star);
    }
    SetTextAlign(hleft, vtop);
    SetFont('smallfont');
    DrawText(DM_MATRIXX, y+5, RepInfo.PlayerName);
    SetTextAlign(hright, vtop);
    SetFont('bigfont');
    DrawText(DM_TOTALSX, y, va("%s", RepInfo.Frags));
    DrawText(DM_DEATHSX, y, va("%s", RepInfo.Deaths));
    //print("  f:%s d:%s -- %s", RepInfo.Frags, RepInfo.Deaths, RepInfo.PlayerName);
    y += 24;
  }
}


// net game stuff
const int NG_STATSY = 210;
const int NG_STATSX = (172+32/2);

const int NG_SPACINGX = 64;


//==========================================================================
//
//  SB_DrawCoopStats
//
//==========================================================================
void SB_DrawCoopStats () {
  picinfo_t info;
  PlayerReplicationInfo RepInfo;

  int pwidth = TextWidth("%");

  SetFont('bigfont');
  SetTextAlign(hright, vtop);
  // draw stat titles (top line)
  DrawText(NG_STATSX+NG_SPACINGX, NG_STATSY, "kills");
  DrawText(NG_STATSX+2*NG_SPACINGX, NG_STATSY, "items");
  DrawText(NG_STATSX+3*NG_SPACINGX, NG_STATSY, "scrt");
  DrawText(NG_STATSX+4*NG_SPACINGX, NG_STATSY, "frgs");

  // draw stats
  int y = NG_STATSY+TextHeight("kills");

  foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo) {
    int i = RepInfo.PlayerNum;
    int x = NG_STATSX;

    if (i == ClGame.cl.ClientNum) {
      // your face
      int star = R_RegisterPic('stfst01');
      DrawPic(x-info.width, y, star);
    }

    SetTextAlign(hright, vtop);
    x += NG_SPACINGX;
    DrawText(x-pwidth, y+10, va("%d", RepInfo.KillCount));
    x += NG_SPACINGX;
    DrawText(x-pwidth, y+10, va("%d", RepInfo.ItemCount));
    x += NG_SPACINGX;
    DrawText(x-pwidth, y+10, va("%d", RepInfo.SecretCount));
    x += NG_SPACINGX;

    SetTextAlign(hright, vtop);
    DrawText(x, y+10, va("%d", RepInfo.Frags));

    y += WI_SPACINGY;
  }
}


//==========================================================================
//
//  SB_DrawNetworkStats
//
//==========================================================================
void SB_DrawNetworkStats () {
  if (!ClGame) return;
  if (!ClGame.GLevel) return;
  if (ClGame.Game.NetMode <= GameInfo::NM_Standalone) return;
  if (!ClGame.cl || !ClGame.cl.MO || ClGame.cl.MO.Health > 0) return;
  if (ClGame.deathmatch) {
    SB_DrawDeathmatchStats();
  } else {
    SB_DrawCoopStats();
  }
}


//==========================================================================
//
//  SB_DrawNetworkStats
//
//==========================================================================
void SB_Drawer (int sb_view) {
  SB_Housekeeping(sb_view);
}


//==========================================================================
//
//  SB_DrawDamageIndicator
//
//==========================================================================
void SB_DrawDamageIndicator (int dir, int clr, float alpha, int udflag) {
  if (alpha <= 0.0) return;
  alpha = fmin(1.0, alpha);

  //int mind = min(Width, Height);
  int maxd = max(Width, Height);

  float rsz = fmax(Width*(0.5+SB_DMG_YOFS)-Width*0.5, Height*(0.5+SB_DMG_YOFS)-Height*0.5);

  /*
  float x0 = mind*(0.5-SB_DMG_YOFS);
  float y0 = mind*(0.5-SB_DMG_YOFS);
  float x1 = mind*(0.5+SB_DMG_YOFS);
  float y1 = mind*(0.5+SB_DMG_YOFS);
  */
  float x0 = Width*0.5-rsz;
  float x1 = Width*0.5+rsz;
  float y0 = Height*0.5-rsz;
  float y1 = Height*0.5+rsz;

  int sizeh = int(maxd*SB_DMG_SIZE*0.25);
  int sizev = sizeh;

  int wdt, hgt;

  //udflag &= ~SB_DMG_DOWN_FLAG;
  //udflag &= ~SB_DMG_UP_FLAG;

  switch (dir) {
    case SB_DMG_TOP:
      wdt = sizeh;
      hgt = int(SB_DMG_THICKNESS);
      R_FillRect((x0+x1-wdt)*0.5, y0, wdt, hgt, clr, alpha);
      if (udflag) {
        int w2 = int(wdt*SB_DMG_SMALL_SIZE_B), h2 = int(hgt*SB_DMG_SMALL_SIZE_S);
        if (udflag&SB_DMG_UP_FLAG) R_FillRect((x0+x1-w2)*0.5, y0-h2*2, w2, h2, clr, alpha);
        if (udflag&SB_DMG_DOWN_FLAG) R_FillRect((x0+x1-w2)*0.5, y0+hgt+h2, w2, h2, clr, alpha);
      }
      break;
    case SB_DMG_BOTTOM:
      wdt = sizeh;
      hgt = int(SB_DMG_THICKNESS);
      R_FillRect((x0+x1-wdt)*0.5, y1-hgt, wdt, hgt, clr, alpha);
      if (udflag) {
        int w2 = int(wdt*SB_DMG_SMALL_SIZE_B), h2 = int(hgt*SB_DMG_SMALL_SIZE_S);
        if (udflag&SB_DMG_UP_FLAG) R_FillRect((x0+x1-w2)*0.5, y1+h2, w2, h2, clr, alpha);
        if (udflag&SB_DMG_DOWN_FLAG) R_FillRect((x0+x1-w2)*0.5, y1-hgt-h2*2, w2, h2, clr, alpha);
      }
      break;
    case SB_DMG_LEFT:
      wdt = int(SB_DMG_THICKNESS);
      hgt = sizev;
      R_FillRect(x0, (y0+y1-hgt)*0.5, wdt, hgt, clr, alpha);
      if (udflag) {
        int w2 = int(wdt*SB_DMG_SMALL_SIZE_S), h2 = int(hgt*SB_DMG_SMALL_SIZE_B);
        if (udflag&SB_DMG_UP_FLAG) R_FillRect(x0-w2*2, (y0+y1-h2)*0.5, w2, h2, clr, alpha);
        if (udflag&SB_DMG_DOWN_FLAG) R_FillRect(x0+wdt+w2, (y0+y1-h2)*0.5, w2, h2, clr, alpha);
      }
      break;
    case SB_DMG_RIGHT:
      wdt = int(SB_DMG_THICKNESS);
      hgt = sizev;
      R_FillRect(x1-wdt, (y0+y1-hgt)*0.5, wdt, hgt, clr, alpha);
      if (udflag) {
        int w2 = int(wdt*SB_DMG_SMALL_SIZE_S), h2 = int(hgt*SB_DMG_SMALL_SIZE_B);
        if (udflag&SB_DMG_UP_FLAG) R_FillRect(x1+w2, (y0+y1-h2)*0.5, w2, h2, clr, alpha);
        if (udflag&SB_DMG_DOWN_FLAG) R_FillRect(x1-wdt-w2*2, (y0+y1-h2)*0.5, w2, h2, clr, alpha);
      }
      break;
    case SB_DMG_LEFT_TOP:
      // left
      wdt = int(SB_DMG_THICKNESS);
      hgt = sizev;
      R_FillRect(x0, y0+SB_DMG_THICKNESS, wdt, hgt, clr, alpha);
      if (udflag) {
        int w2 = int(wdt*SB_DMG_SMALL_SIZE_S), h2 = int(hgt*SB_DMG_SMALL_SIZE_B);
        if (udflag&SB_DMG_UP_FLAG) R_FillRect(x0-w2*2, y0+SB_DMG_THICKNESS+2, w2, h2, clr, alpha);
        if (udflag&SB_DMG_DOWN_FLAG) R_FillRect(x0+wdt+w2, y0+SB_DMG_THICKNESS+2+w2, w2, h2-w2*2, clr, alpha);
      }
      // top
      wdt = sizeh;
      hgt = int(SB_DMG_THICKNESS);
      R_FillRect(x0+SB_DMG_THICKNESS, y0, wdt, hgt, clr, alpha);
      if (udflag) {
        int w2 = int(wdt*SB_DMG_SMALL_SIZE_B), h2 = int(hgt*SB_DMG_SMALL_SIZE_S);
        if (udflag&SB_DMG_UP_FLAG) R_FillRect(x0+SB_DMG_THICKNESS+2, y0-h2*2, w2, h2, clr, alpha);
        if (udflag&SB_DMG_DOWN_FLAG) R_FillRect(x0+SB_DMG_THICKNESS+2+h2, y0+hgt+h2, w2-h2*2, h2, clr, alpha);
      }
      break;
    case SB_DMG_LEFT_BOTTOM:
      // left
      wdt = int(SB_DMG_THICKNESS);
      hgt = sizev;
      R_FillRect(x0, y1-SB_DMG_THICKNESS-hgt, wdt, hgt, clr, alpha);
      if (udflag) {
        int w2 = int(wdt*SB_DMG_SMALL_SIZE_S), h2 = int(hgt*SB_DMG_SMALL_SIZE_B);
        if (udflag&SB_DMG_UP_FLAG) R_FillRect(x0-w2*2, y1-SB_DMG_THICKNESS-2-h2, w2, h2, clr, alpha);
        if (udflag&SB_DMG_DOWN_FLAG) R_FillRect(x0+wdt+w2, y1-SB_DMG_THICKNESS-2-h2+w2, w2, h2-w2*2, clr, alpha);
      }
      // bottom
      wdt = sizeh;
      hgt = int(SB_DMG_THICKNESS);
      R_FillRect(x0+SB_DMG_THICKNESS, y1-hgt, wdt, hgt, clr, alpha);
      if (udflag) {
        int w2 = int(wdt*SB_DMG_SMALL_SIZE_B), h2 = int(hgt*SB_DMG_SMALL_SIZE_S);
        if (udflag&SB_DMG_UP_FLAG) R_FillRect(x0+SB_DMG_THICKNESS+2, y1+h2, w2, h2, clr, alpha);
        if (udflag&SB_DMG_DOWN_FLAG) R_FillRect(x0+SB_DMG_THICKNESS+2+h2, y1-hgt-h2*2, w2-h2*2, h2, clr, alpha);
      }
      break;
    case SB_DMG_RIGHT_TOP:
      // right
      wdt = int(SB_DMG_THICKNESS);
      hgt = sizev;
      R_FillRect(x1-wdt, y0+SB_DMG_THICKNESS, wdt, hgt, clr, alpha);
      if (udflag) {
        int w2 = int(wdt*SB_DMG_SMALL_SIZE_S), h2 = int(hgt*SB_DMG_SMALL_SIZE_B);
        if (udflag&SB_DMG_UP_FLAG) R_FillRect(x1+w2, y0+SB_DMG_THICKNESS+2, w2, h2, clr, alpha);
        if (udflag&SB_DMG_DOWN_FLAG) R_FillRect(x1-wdt-w2*2, y0+SB_DMG_THICKNESS+2+w2, w2, h2-w2*2, clr, alpha);
      }
      // top
      wdt = sizeh;
      hgt = int(SB_DMG_THICKNESS);
      R_FillRect(x1-SB_DMG_THICKNESS-wdt, y0, wdt, hgt, clr, alpha);
      if (udflag) {
        int w2 = int(wdt*SB_DMG_SMALL_SIZE_B), h2 = int(hgt*SB_DMG_SMALL_SIZE_S);
        if (udflag&SB_DMG_UP_FLAG) R_FillRect(x1-SB_DMG_THICKNESS-2-w2, y0-h2-2, w2, h2, clr, alpha);
        if (udflag&SB_DMG_DOWN_FLAG) R_FillRect(x1-SB_DMG_THICKNESS-2-w2+h2, y0+hgt+h2, w2-h2*2, h2, clr, alpha);
      }
      break;
    case SB_DMG_RIGHT_BOTTOM:
      // right
      wdt = int(SB_DMG_THICKNESS);
      hgt = sizev;
      R_FillRect(x1-wdt, y1-SB_DMG_THICKNESS-hgt, wdt, hgt, clr, alpha);
      if (udflag) {
        int w2 = int(wdt*SB_DMG_SMALL_SIZE_S), h2 = int(hgt*SB_DMG_SMALL_SIZE_B);
        if (udflag&SB_DMG_UP_FLAG) R_FillRect(x1+w2, y1-h2-SB_DMG_THICKNESS-2, w2, h2, clr, alpha);
        if (udflag&SB_DMG_DOWN_FLAG) R_FillRect(x1-wdt-w2*2, y1-h2-SB_DMG_THICKNESS-2+w2, w2, h2-w2*2, clr, alpha);
      }
      // bottom
      wdt = sizeh;
      hgt = int(SB_DMG_THICKNESS);
      R_FillRect(x1-SB_DMG_THICKNESS-wdt, y1-hgt, wdt, hgt, clr, alpha);
      if (udflag) {
        int w2 = int(wdt*SB_DMG_SMALL_SIZE_B), h2 = int(hgt*SB_DMG_SMALL_SIZE_S);
        if (udflag&SB_DMG_UP_FLAG) R_FillRect(x1-SB_DMG_THICKNESS-2-w2, y1+h2, w2, h2, clr, alpha);
        if (udflag&SB_DMG_DOWN_FLAG) R_FillRect(x1-SB_DMG_THICKNESS-2-w2+h2, y1-hgt-h2*2, w2-h2*2, h2, clr, alpha);
      }
      break;
  }
}


//==========================================================================
//
//  SB_DrawAdvancedDamage
//
//  advanced damage indicator code
//
//==========================================================================
void SB_DrawAdvancedDamage (Player cl) {
  //if (!GetCvarB('r_statusbar_advdamage')) return;
  #if 0
  //printdebug("Width=%s; Height=%s", Width, Height);
  SB_DrawDamageIndicator(SB_DMG_TOP, RGB(255, 0, 0), 0.6, SB_DMG_UP_FLAG|SB_DMG_DOWN_FLAG);
  SB_DrawDamageIndicator(SB_DMG_BOTTOM, RGB(255, 0, 0), 0.6, SB_DMG_UP_FLAG|SB_DMG_DOWN_FLAG);
  SB_DrawDamageIndicator(SB_DMG_LEFT, RGB(255, 0, 0), 0.6, SB_DMG_UP_FLAG|SB_DMG_DOWN_FLAG);
  SB_DrawDamageIndicator(SB_DMG_RIGHT, RGB(255, 0, 0), 0.6, SB_DMG_UP_FLAG|SB_DMG_DOWN_FLAG);
  SB_DrawDamageIndicator(SB_DMG_LEFT_TOP, RGB(255, 0, 0), 0.6, SB_DMG_UP_FLAG|SB_DMG_DOWN_FLAG);
  SB_DrawDamageIndicator(SB_DMG_LEFT_BOTTOM, RGB(255, 0, 0), 0.6, SB_DMG_UP_FLAG|SB_DMG_DOWN_FLAG);
  SB_DrawDamageIndicator(SB_DMG_RIGHT_TOP, RGB(255, 0, 0), 0.6, SB_DMG_UP_FLAG|SB_DMG_DOWN_FLAG);
  SB_DrawDamageIndicator(SB_DMG_RIGHT_BOTTOM, RGB(255, 0, 0), 0.6, SB_DMG_UP_FLAG|SB_DMG_DOWN_FLAG);
  return;
  #endif

  float[SB_DMG_MAXDIR] dmgAttackTimeout;
  int[SB_DMG_MAXDIR] dmgUpDownFlag;

  int dmgflash = 0;

  if (cl && cl.MO && PlayerPawn(cl.MO) && cl.MO.Player) {
    auto pex = PlayerEx(cl.MO.Player);
    if (pex) dmgflash = int(clamp(pex.DamageFlashBlend, 0, 114)*(255.0/114.0));
    //printdebug("=== %d attackers (flash:%s) ===", cl.Attackers.length, dmgflash);
  }

  if (cl && cl.MO && cl.Attackers) {
    Entity mo = cl.MO;
    TAVec itang;

    //printdebug("=== %d attackers (flash:%s) ===", cl.Attackers.length, dmgflash);
    foreach (auto ref atk; cl.Attackers) {
      //if (atk.GameTime < 0) continue;
      float td = fmax(0.0, cl.GameTime-atk.GameTime);
      if (td >= SB_DMG_TIMEOUT) continue;

      //if (dmgflash) { atk.GameTime = cl.GameTime; td = 0; }

      VectorAngles(atk.Origin-mo.Origin, out itang);

      float diffangyaw = AngleDiff(mo.Angles.yaw, itang.yaw);
      bool toright = (diffangyaw < 0.0);
      diffangyaw = fabs(diffangyaw);

      int dir;
           if (diffangyaw < 22.5) dir = SB_DMG_TOP; // forward
      else if (diffangyaw < 67.5) dir = (toright ? SB_DMG_RIGHT_TOP : SB_DMG_LEFT_TOP); // forward, diagonal
      else if (diffangyaw < 112.5) dir = (toright ? SB_DMG_RIGHT : SB_DMG_LEFT); // left/right
      else if (diffangyaw < 157.5) dir = (toright ? SB_DMG_RIGHT_BOTTOM : SB_DMG_LEFT_BOTTOM); // backward, diagonal
      else dir = SB_DMG_BOTTOM; // backward

      //dmgAttackTimeout[dir] = SB_DMG_TIMEOUT;
      dmgAttackTimeout[dir] = SB_DMG_TIMEOUT-td;

      float diffangpitch = AngleDiff(/*mo.Angles.pitch*/0, itang.pitch);
      bool toup = (diffangpitch < 0.0);
      diffangpitch = fabs(diffangpitch);

      if (diffangpitch > 45.0) dmgUpDownFlag[dir] |= (toup ? SB_DMG_UP_FLAG : SB_DMG_DOWN_FLAG);

      //atk.GameTime = -1;
    }
  }

  int clr = RGB(255, dmgflash, 0);

  // draw damage indicators
  foreach (int dir; 0..SB_DMG_MAXDIR) {
    float td = fmin(SB_DMG_TIMEOUT, dmgAttackTimeout[dir]);
    if (td <= 0.0) continue;

    float alpha = (td/SB_DMG_TIMEOUT)*SB_DMG_ALPHA;

    SB_DrawDamageIndicator(dir, clr, alpha, dmgUpDownFlag[dir]);
  }
}


//==========================================================================
//
//  SB_UpdateWidgets
//
//==========================================================================
void SB_UpdateWidgets () {
}


//==========================================================================
//
//  SB_Housekeeping
//
//==========================================================================
void SB_Housekeeping (int sb_view) {
  bool fs = (sb_view == SB_VIEW_FULLSCREEN);
  lastWasFullscreen = fs;
}


defaultproperties {
}
