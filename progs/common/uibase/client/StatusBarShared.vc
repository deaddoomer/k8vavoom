//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class StatusBarShared : Widget;

#define HUD_ALLOW_REUSE

ClientGameBase ClGame;

const int NUM_NOTIFY_LINES = 5;

string[NUM_NOTIFY_LINES] notify_lines;
float[NUM_NOTIFY_LINES] notify_times;
int num_notify;
int first_notify;

array!SplitLine CentreMessageLines;
int CentreMessageHeight;
float CentreTime;

Widget HudMsgWin;

bool lastWasFullscreen;


//==========================================================================
//
//  OnCreate
//
//==========================================================================
override void OnCreate () {
  ::OnCreate();
  HudMsgWin = NewChild(Widget);
  Width = GetVirtualWidth();
  Height = GetVirtualHeight();
  HudMsgWin.Width = Width;
  HudMsgWin.Height = Height;
  lastWasFullscreen = false;
  // load healthbar graphics
  R_RegisterPicPath('graphics/healthbar/hbarbot.png');
  R_RegisterPicPath('graphics/healthbar/hbartop.png');
  R_RegisterPicPath('graphics/healthbar/hbarbrd.png');
}


//==========================================================================
//
//  StartMap
//
//  WARNING! this can be called several times for one map! (k8:FIXME!)
//
//==========================================================================
void StartMap () {
  ClearNotify();
  ClearCentreMessage();
  ClearHudMessages();
}


//==========================================================================
//
//  OnDraw
//
//==========================================================================
override void OnDraw () {
  DrawNotify();
  DrawCentreMessage();
}


//==========================================================================
//
//  Tick
//
//==========================================================================
override void Tick (float DeltaTime) {
  auto root = GetRootWidget();
  //print("SBTICK: root=%C; sz=(%d,%d)", root, root.Width, root.Height);
  if (root && (Width != root.Width || Height != root.Height)) {
    SetSize(root.Width, root.Height);
  }
  if (HudMsgWin && (HudMsgWin.Width != Width || HudMsgWin.Height != Height)) {
    HudMsgWin.SetSize(root.Width, root.Height);
  }
  UpdateNotify(DeltaTime);
  UpdateCentreMessage(DeltaTime);
}


//**************************************************************************
//  Notify messages
//**************************************************************************

//==========================================================================
//
//  ClearNotify
//
//==========================================================================
void ClearNotify () {
  num_notify = 0;
  first_notify = 0;
}


//==========================================================================
//
//  AddNotifyMessage
//
//==========================================================================
void AddNotifyMessage (string Str) {
  array!SplitLine Lines;

  SetFont('smallfont');
  SplitText(Str, Lines, GetVirtualWidth()-32);

  foreach (auto i; 0..Lines.length) {
    if (num_notify >= NUM_NOTIFY_LINES) {
      --num_notify;
      ++first_notify;
    }
    notify_lines[(num_notify+first_notify)%NUM_NOTIFY_LINES] = Lines[i].Text;
    notify_times[(num_notify+first_notify)%NUM_NOTIFY_LINES] = GetCvarF('hud_notify_time');
    ++num_notify;
  }
}


//==========================================================================
//
//  DrawNotify
//
//==========================================================================
void DrawNotify () {
  SetFont('smallfont');
  SetTextAlign(hleft, vtop);

  int col = GetCvar('hud_font_color');

  // notify lines
  int y = 0;
  int i = 0;
  while (i < num_notify) {
    if (notify_times[(i+first_notify)%NUM_NOTIFY_LINES] <= 0.0) {
      ++first_notify;
      --num_notify;
    } else {
      DrawText(4, y, notify_lines[(i+first_notify)%NUM_NOTIFY_LINES], col);
      y += 9;
      ++i;
    }
  }
}


//==========================================================================
//
//  UpdateNotify
//
//==========================================================================
void UpdateNotify (float DeltaTime) {
  foreach (auto i; 0..num_notify) notify_times[(i+first_notify)%NUM_NOTIFY_LINES] -= DeltaTime;
}


//**************************************************************************
//  Centre message
//**************************************************************************

//==========================================================================
//
//  ClearCentreMessage
//
//==========================================================================
void ClearCentreMessage () {
  CentreTime = 0.0;
}


//==========================================================================
//
//  AddCentreMessage
//
//==========================================================================
void AddCentreMessage (string Msg) {
  SetFont('smallfont');
  CentreMessageHeight = SplitText(Msg, CentreMessageLines, 600);
  CentreTime = GetCvarF('hud_centre_message_time');
}


//==========================================================================
//
//  DrawCentreMessage
//
//==========================================================================
void DrawCentreMessage () {
  if (CentreTime && CentreMessageLines.length) {
    auto ovw = GetVirtualWidth();
    auto ovh = GetVirtualHeight();
    int LineH = CentreMessageHeight/CentreMessageLines.length;
    SetFont('smallfont');
    SetTextAlign(hleft, vtop);
    int tx = ovw/2;
    int ty = (ovh-CentreMessageLines.length*LineH)/2-32;
    foreach (auto i; 0..CentreMessageLines.length) {
      DrawText(tx-CentreMessageLines[i].Width/2, ty+i*LineH, CentreMessageLines[i].Text, GetCvar('hud_font_color_centered'), CR_YELLOW);
    }
  }
}


//==========================================================================
//
//  UpdateCentreMessage
//
//==========================================================================
void UpdateCentreMessage (float DeltaTime) {
  CentreTime -= DeltaTime;
  if (CentreTime < 0.0) CentreTime = 0.0;
}


//**************************************************************************
//  HUD messages
//**************************************************************************

//==========================================================================
//
//  ClearHudMessages
//
//==========================================================================
void ClearHudMessages () {
  HudMsgWin.DestroyAllChildren();
}


//==========================================================================
//
//  AddHudMessage
//
//==========================================================================
void AddHudMessage (string Message, name Font, int Type, int Id, int Color,
  string ColorName, float x, float y, int HudWidth, int HudHeight,
  float HoldTime, float Time1, float Time2)
{
  Widget Probe;
  HUDMessage Msg;
  bool isHealthBar = false;

  class!HUDMessage hudClass = none;

  if (Font == 'HEALTHBAR') {
    if (!Id || Id == 0xffffffff) return; // orphaned
    hudClass = HUDMessage;
    isHealthBar = true;
    Type = HUDMSG_PLAIN; // just in case
  } else {
    switch (Type&0xff) {
      default: case HUDMSG_PLAIN: hudClass = HUDMessage; break;
      case HUDMSG_FADEOUT: hudClass = HUDMessageFadeOut; break;
      case HUDMSG_TYPEON: hudClass = HUDMessageTypeOnFadeOut; break;
      case HUDMSG_FADEINOUT: hudClass = HUDMessageFadeInOut; break;
    }
  }

  // log to console if needed.
  if (Type&HUDMSG_LOG) {
    print("\ci<------------------------------->");
    print("%s%s", TextColorString(Color), Message);
    print("\ci<------------------------------->");
    Type &= ~HUDMSG_LOG;
  }
  //print("id=%s; font=%s; x=%f; y=%f; size=(%dx%d); hold=%f; t1=%f; t2=%f; msg=<%q>", Id, Font, x, y, HudWidth, HudHeight, HoldTime, Time1, Time2, Message);

  // handle colors specified by name
  if (Type&HUDMSG_COLORSTRING) Color = FindTextColor(ColorName);

#ifdef HUD_ALLOW_REUSE
  HUDMessage hudReuse = none;
#endif

  // reuse previous message with the same ID, if possible
  if (Id && Id != 0xffffffff) {
    for (Probe = HudMsgWin.FirstChild; Probe; Probe = Probe.Next) {
      if (HUDMessage(Probe).Id == Id) {
        //print("*** found and destroyed old HUD message with id %d", Id);
#ifdef HUD_ALLOW_REUSE
        if (Probe.Class == hudClass) {
          hudReuse = HUDMessage(Probe);
        } else
#endif
        {
          delete Probe;
        }
        break;
      }
    }
    //print("*** new HUD message with id %d", Id);
  } else {
    // is this orphaned message with infinite hold time?
    if (HoldTime <= 0 && (Type&0xffff) == HUDMSG_PLAIN) {
      // yes, don't allow it, or we may get HUD message spam
      HoldTime = 0.5;
    }
  }

#ifdef HUD_ALLOW_REUSE
  if (hudReuse) {
    Msg = hudReuse;
    Msg.Reset();
  } else
#endif
  {
    Msg = HudMsgWin.NewChild(hudClass);
  }

  Msg.ClGame = ClGame;

  Msg.Init(Message, Font, Type, Id, Color, x, y, HudWidth, HudHeight, HoldTime, Time1, Time2);

  // insert in the list in the proper location
#ifdef HUD_ALLOW_REUSE
  if (!hudReuse)
#endif
  {
    Probe = HudMsgWin.FirstChild;
    while (Probe && (Probe == Msg || HUDMessage(Probe).Id > Id)) Probe = Probe.Next;
    if (Probe) Msg.MoveBefore(Probe);
  }
  //Msg.dumpClipRect("MSG02");

  /*
  int count = 0;
  for (Probe = HudMsgWin.FirstChild; Probe; Probe = Probe.Next) ++count;
  if (count) {
    print("=== HUD MESSAGES: %d", count);
    for (Probe = HudMsgWin.FirstChild; Probe; Probe = Probe.Next) print("  %C (%d)", Probe, HUDMessage(Probe).Id);
  }
  */
}


// fullscreen statusbar
 // the screen is not 640x480
void SB_DrawFullscreenStats () {}

// normal statusbar, called in order
void SB_DrawMainBarPre (bool inAutomap) {} // the screen is not 640x480
void SB_FillMainBar (bool inAutomap) {} // this fills the sides with the rock texture; the screen is 640x480
void SB_DrawMainBar (bool inAutomap) {} // the screen is 640x480
void SB_DrawMainBarPost (bool inAutomap) {} // the screen is not 640x480


struct SB_SavedVScreenState {
  int width, height;
  float scaleY;
}


final void SB_SetCorrected640x480 (out SB_SavedVScreenState sss) {
  sss.width = GetVirtualWidth();
  sss.height = GetVirtualHeight();
  sss.scaleY = ScaleY;
  SetVirtualScreen(640, 480);
  if (Width != 640 || Height != 480) SetSize(640, 480);
  ScaleY = ScaleY*R_GetAspectRatio();
  Y = -int(480.0*ScaleY-480);
}


final void SB_RestoreVScreen (const ref SB_SavedVScreenState sss) {
  ScaleY = sss.scaleY;
  Y = 0;
  SetVirtualScreen(sss.width, sss.height);
  if (Width != sss.width || Height != sss.height) SetSize(sss.width, sss.height);
}


// this is common code for all games
void SB_DrawMainPart (int sb_view) {
  auto ovw = GetVirtualWidth();
  auto ovh = GetVirtualHeight();
  if (Width != ovw || Height != ovh) SetSize(ovw, ovh);
  if (sb_view == SB_VIEW_FULLSCREEN) {
    SB_DrawFullscreenStats();
  } else {
    bool inAutomap = (sb_view == SB_VIEW_AUTOMAP);
    SB_DrawMainBarPre(inAutomap);
    {
      SB_SavedVScreenState sss;
      SB_SetCorrected640x480(out sss);
      scope(exit) SB_RestoreVScreen(ref sss);
      SB_FillMainBar(inAutomap);
      SB_DrawMainBar(inAutomap);
    }
    SB_DrawMainBarPost(inAutomap);
  }
}


// global locations
const int WI_SPACINGY = 33;

// deathmatch stuff
const int DM_MATRIXX = 202;
const int DM_MATRIXY = 208;

const int DM_TOTALSX = 329;
const int DM_DEATHSX = 429;

const int DM_SPACINGX = 40;


//==========================================================================
//
//  SB_DrawDeathmatchStats
//
//==========================================================================
void SB_DrawDeathmatchStats () {
  SetFont('bigfont');

  PlayerReplicationInfo RepInfo;

  SetTextAlign(hcentre, vtop);
  // draw stat titles (top line)
  DrawText(DM_TOTALSX, DM_MATRIXY-WI_SPACINGY, "FRAGS");
  DrawText(DM_DEATHSX, DM_MATRIXY-WI_SPACINGY, "DEATHS");

  // draw stats
  int y = DM_MATRIXY;

  foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo) {
    if (RepInfo.PlayerNum == ClGame.cl.ClientNum) {
      // your face
      int star = R_RegisterPic('stfst01');
      picinfo_t info;
      R_GetPicInfo(star, &info);
      DrawPic(DM_MATRIXX-info.width-5, y-8, star);
    }
    SetTextAlign(hleft, vtop);
    SetFont('smallfont');
    DrawText(DM_MATRIXX, y+5, RepInfo.PlayerName);
    SetTextAlign(hright, vtop);
    SetFont('bigfont');
    DrawText(DM_TOTALSX, y, va("%s", RepInfo.Frags));
    DrawText(DM_DEATHSX, y, va("%s", RepInfo.Deaths));
    //print("  f:%s d:%s -- %s", RepInfo.Frags, RepInfo.Deaths, RepInfo.PlayerName);
    y += 24;
  }
}


// net game stuff
const int NG_STATSY = 210;
const int NG_STATSX = (172+32/2);

const int NG_SPACINGX = 64;


//==========================================================================
//
//  SB_DrawCoopStats
//
//==========================================================================
void SB_DrawCoopStats () {
  picinfo_t info;
  PlayerReplicationInfo RepInfo;

  int pwidth = TextWidth("%");

  SetFont('bigfont');
  SetTextAlign(hright, vtop);
  // draw stat titles (top line)
  DrawText(NG_STATSX+NG_SPACINGX, NG_STATSY, "kills");
  DrawText(NG_STATSX+2*NG_SPACINGX, NG_STATSY, "items");
  DrawText(NG_STATSX+3*NG_SPACINGX, NG_STATSY, "scrt");
  DrawText(NG_STATSX+4*NG_SPACINGX, NG_STATSY, "frgs");

  // draw stats
  int y = NG_STATSY+TextHeight("kills");

  foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo) {
    int i = RepInfo.PlayerNum;
    int x = NG_STATSX;

    if (i == ClGame.cl.ClientNum) {
      // your face
      int star = R_RegisterPic('stfst01');
      DrawPic(x-info.width, y, star);
    }

    SetTextAlign(hright, vtop);
    x += NG_SPACINGX;
    DrawText(x-pwidth, y+10, va("%d", RepInfo.KillCount));
    x += NG_SPACINGX;
    DrawText(x-pwidth, y+10, va("%d", RepInfo.ItemCount));
    x += NG_SPACINGX;
    DrawText(x-pwidth, y+10, va("%d", RepInfo.SecretCount));
    x += NG_SPACINGX;

    SetTextAlign(hright, vtop);
    DrawText(x, y+10, va("%d", RepInfo.Frags));

    y += WI_SPACINGY;
  }
}


//==========================================================================
//
//  SB_DrawNetworkStats
//
//==========================================================================
void SB_DrawNetworkStats () {
  if (!ClGame) return;
  if (!ClGame.GLevel) return;
  if (ClGame.Game.NetMode <= GameInfo::NM_Standalone) return;
  if (!ClGame.cl || !ClGame.cl.MO || ClGame.cl.MO.Health > 0) return;
  if (ClGame.deathmatch) {
    SB_DrawDeathmatchStats();
  } else {
    SB_DrawCoopStats();
  }
}


//==========================================================================
//
//  SB_DrawNetworkStats
//
//==========================================================================
void SB_Drawer (int sb_view) {
  SB_Housekeeping(sb_view);
}


void SB_UpdateWidgets () {
}


void SB_Housekeeping (int sb_view) {
  bool fs = (sb_view == SB_VIEW_FULLSCREEN);
  lastWasFullscreen = fs;
}


defaultproperties {
}
