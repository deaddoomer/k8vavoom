//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class HUDMessage : Widget;

/*ClientGameShared*/ClientGameBase ClGame;

// ID, used as a priority or to replace a previous message.
int Id;

string oldtext;
name oldfont;

array!SplitLine MsgLines;
name MsgFont;
string MsgText;
int MsgColor;
float MsgAlpha;

// calculated size of the message box
int MsgWidth;
int MsgHeight;

// message location
float MsgX;
float MsgY;

int HudWidth;
int HudHeight;
bool isTextFont;

bool bCenterX; // true if text lines should be centered
int DrawMsgX, DrawMsgY;

bool isHealthBar;

float HoldTime;
float Time;

float hbarCurr, hbarMax; // health

int hbarPicBack = -1;
int hbarPicFill = -1;
int hbarPicBorder = -1;


//==========================================================================
//
//  IntegralScale
//
//==========================================================================
bool IntegralScale () {
  int div = 1;
  int wdt = Parent.Width, hgt = Parent.Height;
  while (wdt/div >= 640 && hgt/div >= 400) ++div;
  if (div > 1) --div;
  int mywdt = Parent.Width/div;
  int myhgt = Parent.Height/div;
  float scaleX = float(Parent.Width)/float(mywdt);
  float scaleY = float(Parent.Height)/float(myhgt);
  int xofs = int((Parent.Width-mywdt*scaleX)/2);
  int yofs = int((Parent.Height-myhgt*scaleY)/2);
  return SetConfiguration(xofs, yofs, mywdt, myhgt, scaleX, scaleY);
}


//==========================================================================
//
//  FullscreenScaleSize
//
//==========================================================================
bool FullscreenScaleSize (int mywdt, int myhgt, optional bool proportional) {
  //SetSize(Parent.Width, Parent.Height);
  float scaleX = float(Parent.Width)/float(mywdt);
  float scaleY = float(Parent.Height)/float(myhgt);
  if (proportional) {
    float scale = fmin(scaleX, scaleY);
    int xofs = int((Parent.Width-mywdt*scale)/2);
    int yofs = int((Parent.Height-myhgt*scale)/2);
    return SetConfiguration(xofs, yofs, mywdt, myhgt, scale, scale);
  } else {
    int xofs = int((Parent.Width-mywdt*scaleX)/2);
    int yofs = int((Parent.Height-myhgt*scaleY)/2);
    return SetConfiguration(xofs, yofs, mywdt, myhgt, scaleX, scaleY);
  }
}


//==========================================================================
//
//  FullscreenScale
//
//==========================================================================
bool FullscreenScale () {
  //SetSize(Parent.Width, Parent.Height);
  int mywdt = 640;
  int myhgt = (Parent.Height >= 1024 ? 512 : 400);
  //FullscreenScaleSize(mywdt, myhgt);
  return FullscreenScaleSize(640, 480);
}


//==========================================================================
//
//  FixSize
//
//==========================================================================
bool FixSize () {
  if (!HudWidth || !HudHeight) {
    //return IntegralScale();
    return FullscreenScale();
  } else {
    //FIXME: negative HUD height means "ignore statusbar"
    return FullscreenScaleSize(HudWidth, abs(HudHeight), proportional:false);
  }
}


//==========================================================================
//
//  CalcMsgCoords
//
//==========================================================================
void CalcMsgCoords () {
  // split message, and calculate message size
  MsgLines.length = 0;
  SetFont(MsgFont);
  MsgHeight = SplitText(MsgText, MsgLines, Width);
  MsgWidth = 0;
  MsgHeight = 0;
  foreach (auto ref line; MsgLines) {
    MsgWidth = max(MsgWidth, line.Width);
    MsgHeight += FontHeight();
  }
  if (MsgWidth < 1) MsgWidth = 1;
  if (MsgHeight < 1) MsgHeight = 1;

  //printdebug("id=%s: pos=(%s,%s); size=(%sx%s), hud=(%sx%s); font=<%s>; text=\"%q\"", Id, MsgX, MsgY, Width, Height, HudWidth, HudHeight, MsgFont, MsgText);
  //printdebug("  linecount=%s; msgsize=(%sx%s)", MsgLines.length, MsgWidth, MsgHeight);

  if (!HudWidth || !HudHeight) {
    // default size

    // x coord
    // [-2.0, -1.0): Same as [-1.0,0.0), but center each line inside box
    // [-1.0, 0.0): Position between left and right edge of screen
    // [0.0, 1.0]: Position between left and right edge valid box locations
    // (1.0, 2.0]: Same as [0.0,1.0], but center each line inside box
    if (MsgX < 0) {
      // screen coords
      bCenterX = (MsgX < -1.0f);
      float nx;
      if (bCenterX) {
        nx = fclamp(MsgX+2, 0.0f, 1.0f);
      } else {
        nx = fclamp(MsgX+1, 0.0f, 1.0f);
      }
      DrawMsgX = int(nx*Width);
    } else {
      // box coords
      bCenterX = (MsgX > 1.0f);
      float nx;
      if (bCenterX) {
        nx = fclamp(MsgX-1, 0.0f, 1.0f);
      } else {
        nx = fclamp(MsgX, 0.0f, 1.0f);
      }
      DrawMsgX = int(nx*(Width-MsgWidth));
    }

    // y coord
    // [-1.0, 0.0): Position between top and bottom edge of screen
    // [ 0.0, 1.0]: Position between top and bottom of valid box locations
    if (MsgY < 0) {
      // screen coords
      float ny = fclamp(MsgY+1, 0.0f, 1.0f);
      DrawMsgY = int(ny*Height);
    } else {
      // box coords
      float ny = fclamp(MsgY, 0.0f, 1.0f);
      DrawMsgY = int(ny*(Height-MsgHeight));
    }
  } else {
    //wrapWidth
    DrawMsgX = int(MsgX);
    DrawMsgY = int(MsgY);
    int FracPart;

    FracPart = int(fabs(MsgX-DrawMsgX)*10.0+0.5);
    // fractional part specifies alignment:
    //   0 - center
    //   1 - left
    //   2 - right
    switch (FracPart&3) {
      case 0: DrawMsgX -= MsgWidth/2; break;
      case 2: DrawMsgX -= MsgWidth; break;
    }
    bCenterX = !!(FracPart&4);

    // fractional part specifies alignment:
    //   0 - center
    //   1 - top
    //   2 - bottom
    switch (FracPart&3) {
      case 0: DrawMsgY -= MsgHeight/2; break;
      case 2: DrawMsgY -= MsgHeight; break;
    }
  }
  //printdebug("  drawpos=(%s,%s)", DrawMsgX, DrawMsgY);
}


//==========================================================================
//
//  OnConfigurationChanged
//
//==========================================================================
override void OnConfigurationChanged () {
  if (FixSize()) CalcMsgCoords();
}


//==========================================================================
//
//  Reset
//
//==========================================================================
void Reset () {
  oldtext = default.oldtext;
  oldfont = default.oldfont;
  MsgLines.reset();
  MsgFont = default.MsgFont;
  MsgColor = default.MsgColor;
  MsgAlpha = default.MsgAlpha;
  MsgWidth = default.MsgWidth;
  MsgHeight = default.MsgHeight;
  MsgX = default.MsgX;
  MsgY = default.MsgY;
  HudWidth = default.HudWidth;
  HudHeight = default.HudHeight;
  isTextFont = default.isTextFont;
  bCenterX = default.bCenterX;
  DrawMsgX = default.DrawMsgX;
  DrawMsgY = default.DrawMsgY;
  isHealthBar = default.isHealthBar;
  HoldTime = default.HoldTime;
  Time = default.Time;
  hbarCurr = default.hbarCurr;
  hbarMax = default.hbarMax;
  hbarPicBack = default.hbarPicBack;
  hbarPicFill = default.hbarPicFill;
  hbarPicBorder = default.hbarPicBorder;
}


//==========================================================================
//
//  HBarLoadGfx
//
//==========================================================================
void HBarLoadGfx () {
  hbarPicBack = R_RegisterPicPath('graphics/healthbar/healthbar_bottom.png');
  hbarPicFill = R_RegisterPicPath('graphics/healthbar/healthbar_top.png');
  hbarPicBorder = R_RegisterPicPath('graphics/healthbar/healthbar_border.png');
  if (hbarPicBack < 0 || hbarPicFill < 0 || hbarPicBorder < 0) {
    hbarPicBack = -666;
  }
}


//==========================================================================
//
//  IsActive
//
//==========================================================================
final bool IsActive () {
  if (!ClGame || !ClGame.Game) return true; // just in case
  if (ClGame.Game.isPaused) return false; // paused
  return true; // active
}


//==========================================================================
//
//  Init
//
//==========================================================================
void Init (string Message, name AFont, int Type, int AId, int Color,
  float AMsgX, float AMsgY, int AHudWidth, int AHudHeight, float AHoldTime,
  float Time1, float Time2)
{
  Time = 0;

  // health bar: Time1 is current health, Time2 is max health, Message is name

  //print("HUDMSG(%d): font=[%s]; pos=(%f,%f); size=(%d,%d); msg=<%q>; HoldTime=%s; times=(%s,%s)", AId, AFont, AMsgX, AMsgY, AHudWidth, AHudHeight, Message, AHoldTime, Time1, Time2);

  Id = AId;
  MsgFont = AFont;
  if (!MsgFont) { MsgFont = 'smallfont'; AFont = MsgFont; }
  MsgColor = Color;
  MsgText = Message;
  HoldTime = AHoldTime;
  HoldTime = fclamp(HoldTime, 0, 100000); // 0 MEANS ALOT HERE!
  HudWidth = AHudWidth;
  HudHeight = AHudHeight;
  MsgX = AMsgX;
  MsgY = AMsgY;
  //if (HoldTime > 0) HoldTime += 0.5/35.0;

  if (AFont == 'HEALTHBAR') {
    MsgFont = 'smallfont';
    HBarLoadGfx();
    isHealthBar = true;
    hbarCurr = fmax(0, Time1);
    hbarMax = fmax(1, Time2);
    bCenterX = true;
    MsgAlpha = fclamp(GetCvarF('k8HealthBarAlpha'), 0, 1);
    HoldTime = 0.25;
  } else {
    isHealthBar = false;
  }

  if (GetCvarB('hud_scale_messages')) {
    isTextFont =
      (nameicmp(AFont, 'confont') == 0) ||
      (nameicmp(AFont, 'smallfont') == 0) ||
      (nameicmp(AFont, 'smallfont2') == 0) ||
      (nameicmp(AFont, 'bigfont') == 0);
  }
  if (isHealthBar) isTextFont = false;
  isTextFont = false;

  // check for spaces
  /*
  if (isTextFont) {
    bool allSpaces = true;
    foreach (auto f; 0..Message.length) if (Message[f] > 32) { allSpaces = false; break; }
    if (!allSpaces) {
      print("HUDMSG: font=<%s>; pos=(%f,%f); size=(%d,%d); msg=<%q>", AFont, AMsgX, AMsgY, AHudWidth, AHudHeight, Message);
    }
  }
  */

  /*
  auto root = Parent;
  if (Width != root.Width || Height != root.Height) {
    //SetSize(GetVirtualWidth(), GetVirtualHeight());
    SetSize(root.Width, root.Height);
  }
  */
  FixSize();

  //int wrapWidth = GetVirtualWidth()-32;

  // position of the message
  CalcMsgCoords();

  #if 0
  if (AHudWidth == 0 || AHudHeight == 0) {
    if (fabs(MsgX) > 2.0) {
      bCenterX = true;
      MsgX = 0.5;
    } else {
      if (fabs(MsgX) > 1.0) bCenterX = true;
      MsgX = (MsgX > 1.0 ? MsgX-1.0 : MsgX < -1.0 ? MsgX+1.0 : MsgX);
    }
    if (fabs(MsgY-0.5) <= 0.1) {
      if (MsgY <= 0.5) MsgY -= 0.1; else MsgY += 0.1;
    }

    int wx = GetVirtualWidth()-int(GetVirtualWidth()*(fabs(MsgX)*2))-32;
    if (wx < 32) {
      wrapWidth = 640-32;
    } else {
      wrapWidth = max(320, min(wrapWidth, wx));
    }
  } else {
    //writeln("HUD1: ", AHudWidth, "x", AHudHeight);
    HudWidth = AHudWidth;
    HudHeight = AHudHeight;
    wrapWidth = abs(HudWidth);

    /*
    auto root = Parent;
    if (root) {
      if (Width != root.Width || Height != root.Height) {
        //SetSize(GetVirtualWidth(), GetVirtualHeight());
        SetSize(root.Width, root.Height);
      }
    }
    */

    /*
    SetFont(MsgFont);
    int tw = TextHeight(va("%q", Message));
    if (tw > TextHeight("AW")+4) {
      // this must be a picture
      isTextFont = false;
    }
    print("%n:<%q>", AFont, Message);
    */

    int IntPart = int(MsgX);
    int FracPart = int(fabs(MsgX-float(IntPart))*10.0+0.5);
    if (FracPart&4) bCenterX = true;
    if (MsgX > 0.0) {
      MsgX = float(IntPart)+float(FracPart&3)/10.0;
    } else {
      MsgX = float(IntPart)-float(FracPart&3)/10.0;
    }

    if (!isTextFont) {
      float sx = float(root.Width)/float(abs(HudWidth));
      float sy = float(root.Height)/float(abs(HudHeight));
      ScaleX = sx;
      ScaleY = sy;
      //print("  scale:(%f,%f); scaled size:(%s, %s); vsize=(%s,%s); rsize=(%s,%s)", sx, sy, roundi(root.Width/sx), roundi(root.Height/sy), GetVirtualWidth(), GetVirtualHeight(), root.Width, root.Height);
      SetSize(roundi(root.Width/sx), roundi(root.Height/sy));
      //root.dumpClipRect();
      //print("============"); for (Widget ww = self; ww; ww = ww.Parent) { print("ww=%C", ww); ww.dumpClipRect(); }
    } else {
      float sx = float(root.Width)/float(abs(HudWidth));
      int wx = GetVirtualWidth()-roundi(MsgX*sx)*2-32;
      //print("*** wx=%d", wx);
      if (wx < 32) {
        wrapWidth = GetVirtualWidth()-32;
      } else {
        wrapWidth = max(320, min(wrapWidth, wx));
      }
    }
  }

  // calculate width and height of the text
  if (Message != oldtext || AFont != oldfont) {
    MsgLines.length = 0;
    SetFont(MsgFont);
    MsgHeight = SplitText(Message, MsgLines, /*Width*/wrapWidth);
    //print("========= <%q> (%s:%s) =========", Message, MsgLines.length, wrapWidth);
    MsgWidth = 0;
    foreach (auto i; 0..MsgLines.length) {
      //print("  #%d: <%q>", i, MsgLines[i].Text);
      if (MsgLines[i].Width > MsgWidth) MsgWidth = MsgLines[i].Width;
    }
  }
  #endif
}


//==========================================================================
//
//  OnDraw
//
//==========================================================================
override void OnDraw () {
  float alpha = fclamp(MsgAlpha, 0.0f, 1.0f);// : (MsgAlpha >= 1 ? 0.99 : MsgAlpha));
  if (alpha == 0) return;

  //if (!HudWidth || !HudHeight) return;

  SetFont(MsgFont);

  int y;
  if (isHealthBar) {
    y = int(Height*0.1);
    if (hbarPicBack > 0) {
      // hbarPicBorder: 320x16
      // hbarPicBack: 316x10
      // hbarPicFill: 316x10
      int picX = (Width-320)/2;
      /* not
      R_DrawPic(picX, y, hbarPicBorder);
      R_DrawPic(picX, y, hbarPicBack);
      R_DrawPicPart(picX, y, fclamp(hbarCurr/hbarMax, 0, 1), 1, hbarPicFill);
      */
      float used = fclamp(hbarCurr/hbarMax, 0, 1);
      used = 0.3;
      DrawPic(picX, y, hbarPicBorder, MsgAlpha);
      if (used > 0) DrawPicPart(picX, y, used, 1, hbarPicFill, MsgAlpha);
      if (used < 1) DrawPicPartEx(picX, y, used, 0, 1, 1, hbarPicBack, MsgAlpha);
      y += 16;
    }
    bCenterX = true;
    DrawMsgX = (Width-MsgWidth)/2;
  } else {
    y = DrawMsgY;
  }
  SetTextAlign(hleft, vtop);
  //DrawMsgX = -200;
  //bCenterX = false;
  foreach (auto ref line; MsgLines) {
    int x = DrawMsgX+(bCenterX ? (MsgWidth-line.Width)/2 : 0);
    DrawText(x, y, line.Text, MsgColor, CR_YELLOW, alpha);
    y += FontHeight();
  }

  #if 0
  int x, y;
  auto root = Parent;
  if (!HudWidth || !HudHeight) {
    if (MsgX > 0.0) {
      x = int(float(Width-MsgWidth)*MsgX);
    } else {
      x = int(float(Width)*(-MsgX));
    }
    if (MsgY > 0.0) {
      y = int(float(Height-MsgHeight)*MsgY);
    } else {
      y = int(float(Height)*(-MsgY));
    }
  } else {
    int msgwdt = MsgWidth;
    int msghgt = MsgHeight;
    x = int(MsgX);
    y = int(MsgY);

    //float sx = float(GetVirtualWidth())/float(abs(HudWidth));
    //float sy = float(GetVirtualHeight())/float(abs(HudHeight));
    if (isTextFont) {
      //FIXME: make big scales work as expected
      float sx = float(root.Width)/float(abs(HudWidth));
      float sy = float(root.Height)/float(abs(HudHeight));
      /*
      print("HUDMSG: msg=<%q>; pos=(%d,%d); fixedpos=(%d,%d); scale=(%f,%f); size=(%d,%d); hudsize=(%d,%d)", MsgLines[0].Text, x, y, roundi(x*sx), roundi(y*sy), sx, sy, Width, Height, HudWidth, HudHeight);
      dumpClipRect("self");
      root.dumpClipRect("root");
      */
      x = roundi(x*sx);
      y = roundi(y*sy);
      // scale this, so center will work properly
      //msgwdt = roundi(msgwdt*sx);
      //msghgt = roundi(msghgt*sx);
      //ScaleX = 1;
      //ScaleY = 1;
    }

    //print("msg=<%q>", MsgLines[0].Text);
    int IntPart = int(MsgX);
    int FracPart = int(fabs(MsgX-float(IntPart))*10.0+0.5);
    //print("  x=%d; frac=%d", x, FracPart);
    // fractional part specifies alignment:
    //   0 - center
    //   1 - left
    //   2 - right
    switch (FracPart&3) {
      case 0: x -= MsgWidth/2; break;
      case 2: x -= MsgWidth; break;
    }

    IntPart = int(MsgY);
    FracPart = int(fabs(MsgY-float(IntPart))*10.0+0.5);
    //print("  y=%d; frac=%d", y, FracPart);
    // fractional part specifies alignment:
    //   0 - center
    //   1 - top
    //   2 - bottom
    switch (FracPart&3) {
      case 0: y -= MsgHeight/2; break;
      case 2: y -= MsgHeight; break;
    }
  }

  if (isHealthBar && hbarPicBack > 0) {
    // hbarPicBorder: 320x16
    // hbarPicBack: 316x10
    // hbarPicFill: 316x10
    int picX = (root.Width-320)/2;
    /*
    R_DrawPic(picX, y, hbarPicBorder);
    R_DrawPic(picX, y, hbarPicBack);
    R_DrawPicPart(picX, y, fclamp(hbarCurr/hbarMax, 0, 1), 1, hbarPicFill);
    */
    float used = fclamp(hbarCurr/hbarMax, 0, 1);
    //used = 0.3;
    R_DrawPic(picX, y, hbarPicBorder, MsgAlpha);
    if (used > 0) R_DrawPicPart(picX, y, used, 1, hbarPicFill, MsgAlpha);
    if (used < 1) R_DrawPicPartEx(picX, y, used, 0, 1, 1, hbarPicBack, MsgAlpha);
    y += 16;
  }

  foreach (auto i; 0..MsgLines.length) {
    if (bCenterX) {
      DrawTextLine(i, x+(MsgWidth-MsgLines[i].Width)/2, y, MsgLines[i].Text);
    } else {
      DrawTextLine(i, x, y, MsgLines[i].Text);
    }
    y += MsgHeight/MsgLines.length;
  }
  #endif
}


//==========================================================================
//
//  DrawTextLine
//
//==========================================================================
void DrawTextLine (int LineIdx, int x, int y, string Text) {
  float alpha = (isTextFont ? MsgAlpha : (MsgAlpha >= 1 ? 0.99 : MsgAlpha));
  DrawText(x, y, Text, MsgColor, CR_YELLOW, alpha);
}


//==========================================================================
//
//  Tick
//
//==========================================================================
override void Tick (float DeltaTime) {
  if (!IsActive) return; // do not tick when game is paused
  if (HoldTime && Time > HoldTime) {
    if (isHealthBar) {
      while (MsgAlpha > 0 && Time > HoldTime) {
        MsgAlpha -= 0.05;
        HoldTime += 0.05;
      }
      if (MsgAlpha <= 0) {
        Destroy();
        return;
      }
    } else {
      //print("  %C(%s): TIME=%s; HoldTime=%s; tfrm=%s; htfrm=%s; <%q>", self, UniqueId, Time, HoldTime, Time/35.0, HoldTime/35.0, (MsgLines.length ? MsgLines[0].Text : "<>"));
      Destroy();
      return;
    }
  }
  // moved here, so messages won't blink
  Time += DeltaTime;
}


defaultproperties {
  Width = 640;
  Height = 480;
  bTickEnabled = true;
  MsgAlpha = 1.0;
}
