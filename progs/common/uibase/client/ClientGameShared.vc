//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class ClientGameShared : LineSpecialClientGame abstract;

// for gzdoom
struct OptionValueDef {
  string caption;
  float value;
}

struct OptionValue {
  string Name;
  array!OptionValueDef list;
}

array!OptionValue optvals;


array!name savedChoices;
array!int savedChoicesIdx;

const int MAX_MENU_STACK = 64;

StatusBarShared GSBar;

array!MenuScreen menuStack;

MenuScreen CurrentMenuScreen;

MenuControlKey CurrentCtl;
int ControlColumn; // menu column for controls

int MenuPClass;
name MenuStartMap;
string SkillClassName;
int SkillToConfirm;


int BigSelectorXOffset;
int BigSelectorYOffset;
int BigSelectorAnimSpeed;
array!name BigSelectorAnimFrames;

name DefaultFinaleMusic;
name DefaultFinaleType;


array!MenuDefinition menudefs;


// ////////////////////////////////////////////////////////////////////////// //
enum MsgBoxInputType {
  None,
  YesNo,
  Keybind,
}

enum {
  MB_None,
  MB_Quit,
  MB_ControlAll,
  MB_ControlStrife,
  MB_ControlNonStrife,
  MB_Shareware,
  MB_Nightmare,
  MB_EndGame,
}


// message box
struct MessageBoxState {
  bool active;
  int x;
  int y;
  int width;
  int height;
  string text; // ...and here is the message string!
  string origText; // w/o YES/NO menu
  bool wantInput; // timed message = no input from user
  int type; // MB_XXX
  name flatName;
  // for quit box
  name soundName;
  bool playAndQuit;
  // for yes/no
  bool currYes;
}

MessageBoxState msgboxState;


//**************************************************************************
//
// menu filter API
//
//**************************************************************************

//==========================================================================
//
//  MenuFilterOptionList
//
//==========================================================================
void MenuFilterOptionList (ref array!MenuDefOptionBase optlist, void delegate (MenuDefOptionBase opt) checker) {
  //printdebug("  optlist.length=%s", optlist.length);
  foreach (MenuDefOptionBase opt; optlist) {
    //printdebug("   %s", opt);
    if (MenuDefOptionSubHeader(opt)) continue; // ignore subheaders
    if (MenuDefOptionControls(opt)) continue; // ignore controls
    if (MenuDefOptionBind(opt)) continue; // ignore bind
    if (!opt.test()) continue; // condition failed
    auto mmo = MenuDefOptionModSubMenus(opt);
    if (mmo) { MenuFilterOptionList(mmo.options, checker); continue; }
    checker(opt);
  }
}


//==========================================================================
//
//  MenuCollectFilteredOptions
//
//==========================================================================
void MenuCollectFilteredOptions (void delegate (MenuDefOptionBase opt) checker) {
  assert(checker);
  foreach (MenuDefinition mdef; menudefs) {
    //printdebug("::: %s :::", mdef);
    MenuFilterOptionList(mdef.options, checker);
  }
}


//==========================================================================
//
//  PostSpawn
//
//  called after the engine spawned the object
//
//==========================================================================
void PostSpawn () {
  LoadMenuDefs();
  LoadGZMenuDefs();
}


//==========================================================================
//
//  TranslateText
//
//==========================================================================
private final static string TranslateText (string text) {
  if (StrStartsWith(text, "$")) text = GetLangString(text[1..$]);
  return text;
}


//==========================================================================
//
//  LoadMenuDefs
//
//==========================================================================
void LoadMenuDefs () {
  {
    auto par = MenuDefinition.openParser("//uidef/menu_list.txt");
    scope(exit) delete par;
    par.Expect("menus");
    par.Expect("{");
    while (!par.Check("}")) {
      if (par.Check(",")) continue;
      par.ExpectString();
      string fname = va("//uidef/%s", par.String);
      MenuDefinition mdef = MenuScreenTextDef.LoadMenu(fname);
      if (!mdef) continue;
      if (!mdef.menuName) { delete mdef; continue; }
      menudefs[$] = mdef;
    }
  }

  // load mod menus
  foreach (int lump; WadIterateNS(EWadNamespace.Global)) {
    if (W_LumpName(lump) == 'modmenu') {
      auto par = MenuDefinition.openParserFromLump(lump);
      scope(exit) delete par;
      while (par.Check("menudef")) {
        auto mdef = SpawnObject(MenuDefinition);
        mdef.parse(par);
        if (!mdef) continue;
        if (!mdef.menuName) { delete mdef; continue; }
        // try to extend menu
        if (mdef.extension) {
          MenuDefinition mtoext = none;
          foreach (MenuDefinition m; menudefs) {
            if (stricmp(m.menuName, mdef.menuName) == 0) {
              mtoext = m;
              break;
            }
          }
          if (mtoext) {
            // extend it
            auto modext = mtoext.findModSubMenuOption();
            foreach (MenuDefOptionBase opt; mdef.options) modext.options[$] = opt;
            mdef.options.clear();
            delete mdef;
            continue;
          }
        }
        // either no menu to extend found, or a brand new menu
        menudefs[$] = mdef;
      }
    }
  }

  // find mod option submenu
  /*
  MenuDefOptionModSubMenus msub = none;
  foreach (MenuDefinition mdef; menudefs) {
    if (mdef.menuName.stricmp("OptionsMenu") == 0) {
      msub = mdef.findModSubMenuOption();
      if (msub) break;
    }
  }

  // find orphan gz menus
  if (msub) {
    foreach (MenuDefinition mdef; menudefs) {
      if (mdef.menuName.stricmp("OptionsMenu") == 0) {
        msub = mdef.findModSubMenuOption();
        if (msub) break;
      }
    }
  }
  */
}


//==========================================================================
//
//  SkipGZIdiocity
//
//  section name skipped
//
//==========================================================================
void SkipGZIdiocity (ScriptsParser par) {
  if (!par.Check("{")) {
    par.ExpectString();
    par.Expect("{");
  }
  int level = 1;
  for (;;) {
    if (par.Check("{")) {
      ++level;
      continue;
    }
    if (par.Check("}")) {
      --level;
      if (level == 0) break;
      continue;
    }
    if (!par.GetString()) return;
  }
}


//==========================================================================
//
//  ParseGZOptionMenu
//
//==========================================================================
void ParseGZOptionMenu (ScriptsParser par, bool extend) {
  par.ExpectString();
  string mname = par.String.toLowerCase();
  // hack for idiotic mods that overrides the whole options menu
  bool isOptRedefine = (!extend && stricmp(mname, "OptionsMenu") == 0);
  if (isOptRedefine) extend = true;
  MenuDefinition mdef;
  int stidx = 0;
  MenuDefOptionModSubMenus suboption = none;
  if (extend) {
    foreach (auto md2; menudefs) {
      if (stricmp(string(md2.menuName), mname) == 0) {
        // i found her!
        mdef = md2;
        break;
      }
    }
    if (!mdef) {
      //par.ScriptError("cannot extend unknown menu '%s'", mname);
      printwarn("GZ-MENUDEF ERROR: cannot extend unknown menu '%s'", mname);
    } else {
      stidx = mdef.options.length;
      suboption = mdef.findModSubMenuOption();
    }
  } else {
    mdef = SpawnObject(MenuDefinition);
    mdef.menuName = mname;
    mdef.gzMenu = true;
  }
  //print("MENUDEF: %soptions menu '%s'...", (extend ? "extending " : ""), mdef.menuName);
  par.Expect("{");
  while (!par.Check("}")) {
    if (par.Check("Title")) {
      par.ExpectString();
      if (mdef && !extend) mdef.title = par.String;
      continue;
    }
    auto opt = MenuDefOptionBase.parseGZ(par);
    if (!opt) continue;
    if (!mdef) { delete opt; continue; }
    if (suboption) {
      // hack for idiotic mods that overrides the whole options menu
      if (isOptRedefine) {
        // this should be submenu
        auto sub = MenuDefOptionSubMenu(opt);
        if (!sub) { delete opt; continue; }
        // check if it is known option
        if (stricmp(sub.subname, "CustomizeControls") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "MouseOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "JoystickOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "PlayerMenu") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "GameplayOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "CompatibilityOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "AutomapOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "HUDOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "MiscOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "SoundOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "VideoOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "VideoModeMenu") == 0) { delete opt; continue; }
        sub.gzPostFilter = true;
        // other things will be postfiltered
      }
      suboption.options[$] = opt;
    } else {
      mdef.options[$] = opt;
    }
  }
  if (mdef) {
    MenuDefinition.filterOptionList(mdef.options, stidx);
    if (suboption) MenuDefinition.filterOptionList(suboption.options);
    if (!extend) menudefs[$] = mdef;
  }
  /*
  // hack for some idiotic mods
  if (!extend && mdef && stricmp(mdef.menuName, "KetchupOptionsGZDoom") == 0) {
    foreach (auto md2; menudefs) {
      if (stricmp(string(md2.menuName), "OptionsMenu") == 0) {
        print("GZ: hacking in ketchup options (%s)", mdef.title);
        // i found her!
        suboption = md2.findModSubMenuOption();
        auto optsub = SpawnObject(MenuDefOptionSubMenu);
        optsub.title = mdef.title;
        optsub.subname = mdef.menuName;
        suboption.options[$] = optsub;
      }
    }
  }
  */
}


//==========================================================================
//
//  LoadGZMenuDef
//
//  parse GZDoom menudef
//
//==========================================================================
void LoadGZMenuDef (ScriptsParser par) {
  for (;;) {
    if (par.Check("AddOptionMenu")) {
      ParseGZOptionMenu(par, extend:true);
    } else if (par.Check("OptionMenu")) {
      ParseGZOptionMenu(par, extend:false);
    } else if (par.Check("OptionValue")) {
      par.ExpectString();
      int f = 0;
      while (f < optvals.length) {
        if (stricmp(optvals[f].Name, par.String) == 0) {
          optvals[f].list.length = 0;
          optvals.remove(f);
        } else {
          ++f;
        }
      }
      optvals.length += 1;
      optvals[$-1].Name = par.String;
      par.Expect("{");
      while (!par.Check("}")) {
        par.ExpectFloat(withSign:true);
        float val = par.Float;
        par.Expect(",");
        par.ExpectString();
        string cap = par.String;
        optvals[$-1].list.length += 1;
        optvals[$-1].list[$-1].caption = cap;
        optvals[$-1].list[$-1].value = val;
      }
    } else if (par.Check("OptionString")) {
      // sometimes used for "true" and "false" (colorfull hell)
      par.ExpectString();
      int f = 0;
      while (f < optvals.length) {
        if (stricmp(optvals[f].Name, par.String) == 0) {
          optvals[f].list.length = 0;
          optvals.remove(f);
        } else {
          ++f;
        }
      }
      optvals.length += 1;
      optvals[$-1].Name = par.String;
      par.Expect("{");
      while (!par.Check("}")) {
        bool ok = true;
        float val;
             if (par.CheckFloat(withSign:true)) val = par.Float;
        else if (par.Check("true")) val = 1;
        else if (par.Check("false")) val = 0;
        else if (par.Check("on")) val = 1;
        else if (par.Check("off")) val = 0;
        else ok = false;
        par.Expect(",");
        par.ExpectString();
        if (ok) {
          string cap = par.String;
          optvals[$-1].list.length += 1;
          optvals[$-1].list[$-1].caption = cap;
          optvals[$-1].list[$-1].value = val;
        }
      }
      // remove empty option
      if (optvals[$-1].list.length == 0) {
        optvals.remove(optvals.length-1);
      }
    } else {
      if (!par.GetString()) break;
      //par.ScriptError("unknown gz menudef command '%s'", par.String);
      print("GZMENU: skipping unimplemented section '%s'", par.String);
      SkipGZIdiocity(par);
    }
  }
}


//==========================================================================
//
//  LoadGZMenuDefs
//
//  parse GZDoom menudef
//
//==========================================================================
void LoadGZMenuDefs () {
  if (GetCvarB('_gz_skip_menudef')) return;
  foreach (int lump; WadIterateNS(EWadNamespace.Global)) {
    if (W_LumpName(lump) == 'menudef') {
      auto par = SpawnObject(ScriptsParser);
      scope(exit) delete par;
      par.OpenLumpIndex(lump);
      par.SetCMode(true);
      par.SetEscape(true);
      LoadGZMenuDef(par);
    }
  }
  // fix optionvalue forwards
  foreach (MenuDefinition mdef; menudefs) {
    mdef.fixGZOptionValues(optvals, delegate bool (string subname) {
      foreach (MenuDefinition m; menudefs) {
        if (m.gzMenu && stricmp(m.menuName, subname) == 0) return true;
      }
      return false;
    });
  }
}


//==========================================================================
//
//  GetAllMenuNames
//
//  mode:
//    -1: only gz
//     0: all
//     1: only non-gz
//
//==========================================================================
void GetAllMenuNames (ref array!string names, int mode) {
  if (mode >= 0) {
    // all
    names[$] = "Save";
    names[$] = "Load";
    names[$] = "Resolution";
    names[$] = "MenuSearch";
  }
  foreach (MenuDefinition mdef; menudefs) {
    if ((mode < 0 && !mdef.gzMenu) || (mode > 0 && mdef.gzMenu)) continue;
    names[$] = mdef.menuName;
  }
}


//==========================================================================
//
//  SetCommonMenu
//
//==========================================================================
bool SetCommonMenu (string Name) {
  //if (!stricmp(Name, "Main")) { PushMenuScreen(SpawnMenu(MenuScreenMain)); return true; }
  if (!stricmp(Name, "Save")) { PushMenuScreen(SpawnMenu(MenuScreenSaveGame)); return true; }
  if (!stricmp(Name, "Load")) { PushMenuScreen(SpawnMenu(MenuScreenLoadGame)); return true; }
  //if (!stricmp(Name, "PSetup")) { PushMenuScreen(SpawnMenu(MenuScreenPlayerSetup)); return true; }
  if (!stricmp(Name, "Options") || !stricmp(Name, "OptionsMenu")) { PushMenuScreen(SpawnNamedMenu('OptionsMenu')); return true; }
  //if (!stricmp(Name, "Controls")) { PushMenuScreen(SpawnMenu(MenuScreenControls)); return true; }
  if (!stricmp(Name, "Controls")) { PushMenuScreen(SpawnNamedMenu('ControlsMain')); return true; }
  if (!stricmp(Name, "Mouse")) { PushMenuScreen(SpawnNamedMenu('MouseOptions')); return true; }
  if (!stricmp(Name, "Resolution")) { PushMenuScreen(SpawnMenu(MenuScreenScreenResolution)); return true; }
  if (!stricmp(Name, "Video")) { PushMenuScreen(SpawnNamedMenu('VideoOptions')); return true; }
  if (!stricmp(Name, "Sound")) { PushMenuScreen(SpawnNamedMenu('SoundOptions')); return true; }
  if (!stricmp(Name, "MenuSearch")) { PushMenuScreen(SpawnMenu(MenuScreenSearchFilter)); return true; }

  // find named menu
  foreach (MenuDefinition mdef; menudefs) {
    if (stricmp(mdef.menuName, Name) == 0) {
      PushMenuScreen(SpawnNamedMenu(name(Name)));
      return true;
    }
  }

  //if (!stricmp(Name, "Help")) { PushMenuScreen(SpawnMenu(MenuScreenHelp)); return true; }
  //if (!stricmp(Name, "Quit")) { ShowQuitPrompt(); return true; }
  //PushMenuScreen(SpawnMenu(MenuScreenMain));
  return false;
}


//==========================================================================
//
//  SpawnMenu
//
//==========================================================================
MenuScreen SpawnMenu (class!MenuScreen CID) {
  class!MenuScreen rpl = class!MenuScreen(GetClassReplacement(CID));
  if (rpl) CID = rpl;
  MenuScreen m = MenuScreen(GRoot.NewChild(CID));
  m.ClGame = self;
  m.CreateMenu();
  foreach (auto i, auto scc; savedChoices) {
    if (scc == GetClassName(CID)) {
      m.SetSavedChoice(savedChoicesIdx[i]);
      break;
    }
  }
  return m;
}


//==========================================================================
//
//  HasNamedMenuStr
//
//  FIXME: SLOOOW!
//
//==========================================================================
bool HasNamedMenuStr (string menuName) {
  if (!menuName) return false;
  foreach (MenuDefinition mdef; menudefs) {
    if (stricmp(mdef.menuName, menuName) == 0) return true;
  }
  return false;
}


//==========================================================================
//
//  SpawnNamedMenuStr
//
//==========================================================================
MenuScreen SpawnNamedMenuStr (string menuName) {
  if (!menuName) {
    FatalError("Cannot spawn unnamed menu");
    return none;
  }

  MenuDefinition mdefmain = none;
  foreach (MenuDefinition mdef; menudefs) {
    if (stricmp(mdef.menuName, menuName) == 0) {
      mdefmain = mdef;
      break;
    }
  }
  if (!mdefmain) {
    FatalError("Menu '%n' not found (name)", menuName);
    return none;
  }

  // create menu
  auto m = MenuScreenTextDef(GRoot.NewChild(MenuScreenTextDef));
  m.ClGame = self;
  m.CreateMenuFromDef(mdefmain);
  m.FinishCreatingMenu();
  // set saved choice
  name mnm = name(mdefmain.menuName);
  foreach (auto i, auto scc; savedChoices) {
    if (scc == mnm) {
      m.SetSavedChoice(savedChoicesIdx[i]);
      break;
    }
  }

  return m;
}


//==========================================================================
//
//  SpawnNamedMenu
//
//==========================================================================
MenuScreen SpawnNamedMenu (name menuName) {
  return SpawnNamedMenuStr(string(menuName));
}


// ////////////////////////////////////////////////////////////////////////// //
// menu stack handling
// ////////////////////////////////////////////////////////////////////////// //

//==========================================================================
//
//  PushMenuScreen
//
//==========================================================================
void PushMenuScreen (MenuScreen menu) {
  // avoid stacking menus invoked by hotkeys
  foreach (auto i, auto msc; menuStack) {
    if (!msc) continue;
    if (menu isa MenuScreenTextDef) {
      if (msc !isa MenuScreenTextDef) continue;
      if (MenuScreenTextDef(msc).menuName != MenuScreenTextDef(menu).menuName) continue;
    } else {
      if (msc.Class != menu.Class) continue;
    }
    while (menuStack.length > i) {
      delete menuStack[$-1];
      menuStack.remove(menuStack.length-1);
    }
    CurrentMenuScreen = none;
    break;
  }

  if (menuStack.length >= MAX_MENU_STACK) FatalError("PushMenu: menu stack overflow");

  menuStack[$] = menu;

  SetCvar('__ui_active', 1);
  if (!CurrentMenuScreen) {
    /*
    if (cl.paused) S_ResumeSound();
    C_ClearNotify();
    */
    CmdBuf_AddText("HideConsole\n");
    LocalSound(menu.ActivateSound);
    if (GetCvarB('ui_mouse')) GRoot.SetMouse(true);
  } else {
    CurrentMenuScreen.Hide();
  }

  CurrentMenuScreen = menu;
  CurrentMenuScreen.SetFocus();
}


//==========================================================================
//
//  SaveMenuChoice
//
//==========================================================================
void SaveMenuChoice (MenuScreen menu) {
  if (!menu) return;
  if (menu isa MenuScreenTextDef) {
    auto md = MenuScreenTextDef(menu);
    name menuName = md.menuName;
    if (!menuName) return; // just in case
    // save choice
    bool found = false;
    foreach (auto i, ref auto scc; savedChoices) {
      if (savedChoices[i] == menuName) {
        savedChoicesIdx[i] = menu.GetChoiceForSaving();
        found = true;
        break;
      }
    }
    // if not found, append it
    if (!found) {
      savedChoices[$] = menuName;
      savedChoicesIdx[$] = menu.GetChoiceForSaving();
    }
  } else {
    // save choice
    bool found = false;
    foreach (auto i, ref auto scc; savedChoices) {
      if (savedChoices[i] == GetClassName(menu.Class)) {
        savedChoicesIdx[i] = menu.GetChoiceForSaving();
        found = true;
        break;
      }
    }
    // if not found, append it
    if (!found) {
      savedChoices[$] = GetClassName(menu.Class);
      savedChoicesIdx[$] = menu.GetChoiceForSaving();
    }
  }
}


//==========================================================================
//
//  PopMenu
//
//==========================================================================
void PopMenu () {
  if (menuStack.length == 0) FatalError("PopMenu: menu stack underflow");
  MenuScreen menu = menuStack[$-1];
  menuStack.length -= 1;

  SaveMenuChoice(menu);

  if (menuStack.length) {
    if (menu) LocalSound(menu.DeactivateSound);
    CurrentMenuScreen = menuStack[$-1];
    CurrentMenuScreen.Show();
    CurrentMenuScreen.Raise();
    CurrentMenuScreen.SetFocus();
  } else {
    if (menu) LocalSound(menu.ClearMenusSound);
    CurrentMenuScreen = none;
    SetCvar('__ui_active', 0);
    GRoot.SetMouse(false);
  }

  delete menu;
}


//==========================================================================
//
//  ForceMenuOff
//
//==========================================================================
void ForceMenuOff () {
  foreach (ref auto msc; menuStack) {
    SaveMenuChoice(msc);
    delete msc;
  }
  menuStack.clear();
  CurrentMenuScreen = none;
  SetCvar('__ui_active', 0);
  GRoot.SetMouse(false);
}


//**************************************************************************
//
// message box API
//
//**************************************************************************

//==========================================================================
//
//  IsQuitPromptEnabled
//
//==========================================================================
bool IsQuitPromptEnabled () {
  return GetCvarB('menu_quit_prompt');
}


//==========================================================================
//
//  GetMessageBoxInputType
//
//==========================================================================
MsgBoxInputType GetMessageBoxInputType () {
  if (!msgboxState.active || !msgboxState.wantInput) return MsgBoxInputType.None;
  if (msgboxState.type == MB_None) return MsgBoxInputType.None; //wtf?!
  if (msgboxState.type == MB_Shareware) return MsgBoxInputType.None; //wtf?!
  if (msgboxState.type >= MB_ControlAll && msgboxState.type <= MB_ControlNonStrife) return MsgBoxInputType.Keybind; //wtf?!
  return MsgBoxInputType.YesNo;
}


//==========================================================================
//
//  QuitMessageBoxSound
//
//==========================================================================
void QuitMessageBoxSound (name QuitSound) {
  if (!QuitSound) return;
  msgboxState.active = true;
  msgboxState.playAndQuit = true;
  msgboxState.soundName = QuitSound;
  StopLocalSounds();
  CmdBuf_AddText("Music stop\n");
  LocalSound(QuitSound);
}


//==========================================================================
//
//  MessageBoxAppendYesNoMenuText
//
//==========================================================================
protected void MessageBoxAppendYesNoMenuText () {
  if (msgboxState.currYes) {
    msgboxState.text ~= "\n\n\c[White][YES]\c-\nNO";
  } else {
    msgboxState.text ~= "\n\nYES\n\c[White][NO]\c-";
  }
}


//==========================================================================
//
//  MessageBoxSetYesNoPos
//
//==========================================================================
void MessageBoxSetYesNoPos (bool yes) {
  if (msgboxState.currYes != yes) {
    msgboxState.currYes = yes;
    msgboxState.text = msgboxState.origText;
    MessageBoxAppendYesNoMenuText();
  }
}


//==========================================================================
//
//  MessageBoxStartMessage
//
//==========================================================================
void MessageBoxStartMessage (string text, int type, bool input) {
  float ui_msgxbox_wrap_trigger = GetCvarF('ui_msgxbox_wrap_trigger');
  float ui_msgxbox_wrap_width = GetCvarF('ui_msgxbox_wrap_width');

  if (ui_msgxbox_wrap_trigger > 0 && ui_msgxbox_wrap_width > 0) {
    // split too long text
    GRoot.SetFont('smallfont');
    msgboxState.width = GRoot.TextWidth(text);
    //if (msgboxState.width > GetVirtualWidth()-192) text = GRoot.SplitTextWithNewlines(text, /*GetVirtualWidth()-132*/304);
    if (float(msgboxState.width)/float(GetVirtualWidth()) > ui_msgxbox_wrap_trigger) {
      int newwdt = int(float(GetVirtualWidth())*ui_msgxbox_wrap_width);
      //print("oldwdt=%s; oldtext=<%q>", msgboxState.width, text);
      text = GRoot.SplitTextWithNewlines(text, newwdt, trimRight:true);
      //print("newwdt=%s; newtext=<%q>", newwdt, text);
    }
  }

  msgboxState.active = true;
  msgboxState.text = text;
  msgboxState.origText = text;
  msgboxState.type = type;
  msgboxState.wantInput = input;
  msgboxState.currYes = true;

  if (msgboxState.wantInput && GetMessageBoxInputType() == MsgBoxInputType.YesNo) {
    MessageBoxAppendYesNoMenuText();
  }

  msgboxState.width = min(/*304*/GetVirtualWidth()-16, (GRoot.TextWidth(msgboxState.text)+16)&~15);
  msgboxState.height = min(/*184*/GetVirtualHeight()-16, (GRoot.TextHeight(msgboxState.text)+16)&~15);
  msgboxState.x = (GetVirtualWidth()-msgboxState.width)/2;
  msgboxState.y = (GetVirtualHeight()-msgboxState.height)/2;

  if (type >= MB_ControlAll && type <= MB_ControlNonStrife) SetCvar('__ui_control_waiting', 1);

  CmdBuf_AddText("HideConsole\n");
}


//==========================================================================
//
//  MessageBoxDrawer
//
//==========================================================================
override void MessageBoxDrawer () {
  // horiz. & vertically centre string and print it
  if (msgboxState.active) {
    GRoot.FillRectWithFlatRepeat(msgboxState.x, msgboxState.y, msgboxState.width, msgboxState.height, msgboxState.flatName);
    DrawBorder(msgboxState.x, msgboxState.y, msgboxState.width, msgboxState.height);
    //GRoot.DrawRect(msgboxState.x, msgboxState.y, msgboxState.width, msgboxState.height, RGB(255, 0, 0));
    GRoot.SetFont('smallfont');
    GRoot.SetTextAlign(hcentre, vcentre);
    GRoot.DrawText(GetVirtualWidth()/2, GetVirtualHeight()/2, msgboxState.text);

    if (msgboxState.wantInput && GetMessageBoxInputType() == MsgBoxInputType.YesNo) {
    }
  }

  if (msgboxState.playAndQuit && !IsLocalSoundPlaying(msgboxState.soundName)) {
    CmdBuf_AddText("Quit\n");
  }
}


//==========================================================================
//
//  MessageBoxResponder
//
//==========================================================================
override bool MessageBoxResponder (event_t *event) {
  if (msgboxState.playAndQuit) return true;

  // take care of any messages that need input
  if (msgboxState.active && event.type == ev_keydown) {
    if (msgboxState.wantInput && GetMessageBoxInputType() == MsgBoxInputType.YesNo) {
      // menu selection
      switch (Widget.ConvertBoundKey(event.keycode)) {
        case K_UPARROW:
        case K_HOME:
          MessageBoxSetYesNoPos(true);
          return true;
        case K_DOWNARROW:
        case K_END:
          MessageBoxSetYesNoPos(false);
          return true;
        case K_ENTER:
        case K_SPACE:
          // menu selection
          event.keycode = (msgboxState.currYes ? K_y : K_n);
          break;
        // translate some keypresses to answers
        case K_t:
        case K_y:
          MessageBoxSetYesNoPos(true);
          event.keycode = K_y;
          break;
        case K_o:
        case K_n:
        case K_ESCAPE:
          MessageBoxSetYesNoPos(false);
          event.keycode = K_n;
          break;
        default:
          // eat other keys
          return true;
      }
    }

    msgboxState.active = false;
    switch (msgboxState.type) {
      case MB_None: break;
      case MB_Quit: QuitResponse(event->data1); break;
      case MB_ControlAll:
      case MB_ControlStrife:
      case MB_ControlNonStrife:
        SetCvar('__ui_control_waiting', 0);
        ControlResponse(event->data1, msgboxState.type);
        break;
      case MB_Shareware: SharewareResponse(event->data1); break;
      case MB_Nightmare: VerifyNightmare(event->data1); break;
      case MB_EndGame: EndGameResponse(event->data1); break;
    }

    //S_StartSound(sfx1_swtchx);
    return true;
  }

  return false;
}


//==========================================================================
//
//  MessageBoxActive
//
//==========================================================================
override bool MessageBoxActive () {
  return msgboxState.active;
}


//==========================================================================
//
//  ControlResponse
//
//==========================================================================
void ControlResponse (int key, int msgtype) {
  string kb_down;
  string kb_up;
  int key1;
  int key2;
  int strifeMode = 0;

  switch (msgtype) {
    case MB_ControlAll: strifeMode = 0; break;
    case MB_ControlStrife: strifeMode = 1; break;
    case MB_ControlNonStrife: strifeMode = -1; break;
    default: return;
  }

  if (key != K_ESCAPE) {
    kb_down = CurrentCtl.CommandOn;
    kb_up = CurrentCtl.CommandOff;
    // old keyconf can register binding like 'addmenukey "Reload" +d_reload'
    // there is prolly '-d_reload' too, so force it here
    if (kb_down && !kb_up && kb_down[0] == "+" && kb_down.strIndexOf(";") < 0) kb_up = "-"~kb_down[1..$];
    if (kb_up == " " || kb_up == ";") kb_up = "";
    int isActive;
    IN_GetBindingKeys(kb_down, &key1, &key2, strifeMode, CurrentCtl.ModSection, out isActive);
    if (ControlColumn == 0) {
      IN_SetBinding(key1, "", "", strifeMode, CurrentCtl.ModSection);
      IN_SetBinding(key, kb_down, kb_up, strifeMode, CurrentCtl.ModSection);
    }
    if (ControlColumn == 1) {
      IN_SetBinding(key2, "", "", strifeMode, CurrentCtl.ModSection);
      IN_SetBinding(key, kb_down, kb_up, strifeMode, CurrentCtl.ModSection);
    }
  }
}


//==========================================================================
//
//  VerifyNightmare
//
//  Realy nightmare skill?
//
//==========================================================================
void VerifyNightmare (int ch) {
  if (ch != K_y) return;
  NewGame(SkillToConfirm);
}


//==========================================================================
//
//  EndGameResponse
//
//==========================================================================
void EndGameResponse (int ch) {
  if (ch != K_y) return;
  CmdBuf_AddText("Disconnect\n");
}


void ShowQuitPrompt () {
}


void DrawBorder (int x, int y, int w, int h, optional int ybotofs) {
}


void QuitResponse (int key) {
}


void SharewareResponse (int key) {
}


//==========================================================================
//
//  AddNotifyMessage
//
//==========================================================================
override void AddNotifyMessage (string Str) {
  GSBar.AddNotifyMessage(Str);
}


//==========================================================================
//
//  AddCentreMessage
//
//==========================================================================
override void AddCentreMessage (string Msg) {
  GSBar.AddCentreMessage(Msg);
}


//==========================================================================
//
//  AddHudMessage
//
//==========================================================================
override void AddHudMessage (string Message, name Font, int Type, int Id, int Color,
  string ColorName, float x, float y, int HudWidth, int HudHeight,
  float HoldTime, float Time1, float Time2)
{
  //print("AddHudMessage: id=%s; msg=<%q>", Id, Message);
  GSBar.AddHudMessage(Message, Font, Type, Id, Color, ColorName, x, y,
    HudWidth, HudHeight, HoldTime, Time1, Time2);
}


//==========================================================================
//
//  SetPClass
//
//==========================================================================
void SetPClass (int PClass) {
  MenuPClass = PClass;
  SkillClassName = va("%n", class!PlayerPawn(Game.PlayerClasses[PClass]).default.SpawnClass);
  //print("EPISODES: %d", P_GetNumEpisodes());
  if (P_GetNumEpisodes() > 1) {
    PushMenuScreen(SpawnMenu(MenuScreenEpisode));
  } else {
    SetEpisode(P_GetEpisodeDef(0));
  }
}


//==========================================================================
//
//  SetEpisode
//
//==========================================================================
void SetEpisode (EpisodeDef *EDef) {
  MenuStartMap = EDef->Name;
  if (EDef->TeaserName && !IsMapPresent(EDef->Name)) MenuStartMap = EDef->TeaserName;
  if (EDef->bNoSkillMenu) {
    NewGame(2);
  } else {
    PushMenuScreen(SpawnMenu(MenuScreenSkill));
  }
}


//==========================================================================
//
//  NewGame
//
//==========================================================================
void NewGame (int SkillLevel) {
  SetCvar('Skill', SkillLevel);
  SetCvar('Class', MenuPClass);

  CmdBuf_AddText("Disconnect\n");
  CmdBuf_AddText("MaxPlayers 1\n");
  CmdBuf_AddText("Map \"%q\"\n", MenuStartMap);

  ForceMenuOff();
}


defaultproperties {
}
