//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class ClientGameShared : LineSpecialClientGame abstract;

enum {
  MB_None,
  MB_Quit,
  MB_Control,
  MB_Shareware,
  MB_Nightmare,
  MB_EndGame,
}

// for gzdoom
struct OptionValueDef {
  string caption;
  float value;
}

struct OptionValue {
  string Name;
  array!OptionValueDef list;
}

array!OptionValue optvals;


array!name savedChoices;
array!int savedChoicesIdx;

const int MAX_MENU_STACK = 64;

StatusBarShared GSBar;

array!MenuScreen menuStack;

MenuScreen CurrentMenuScreen;

MenuControlKey CurrentCtl;
int ControlColumn; // menu column for controls

int MenuPClass;
name MenuStartMap;
string SkillClassName;
int SkillToConfirm;


// message box
bool messageToPrint;
int msgBoxX;
int msgBoxY;
int msgBoxW;
int msgBoxH;
string messageString; // ...and here is the message string!
bool messageNeedsInput; // timed message = no input from user
int messageType;
name MsgBoxFlat;

name QuitSound;
bool WaitForQuit;

int BigSelectorXOffset;
int BigSelectorYOffset;
int BigSelectorAnimSpeed;
array!name BigSelectorAnimFrames;

name DefaultFinaleMusic;
name DefaultFinaleType;


array!MenuDefinition menudefs;


//==========================================================================
//
//  PostSpawn
//
//  called after the engine spawned the object
//
//==========================================================================
void PostSpawn () {
  LoadMenuDefs();
  LoadGZMenuDefs();
}


//==========================================================================
//
//  LoadMenuDefs
//
//==========================================================================
void LoadMenuDefs () {
  {
    auto par = MenuDefinition.openParser("uidef/menu_list.txt");
    scope(exit) delete par;
    par.Expect("menus");
    par.Expect("{");
    while (!par.Check("}")) {
      if (par.Check(",")) continue;
      par.ExpectString();
      string fname = va("uidef/%s", par.String);
      MenuDefinition mdef = MenuScreenTextDef.LoadMenu(fname);
      if (!mdef) continue;
      if (!mdef.menuName) { delete mdef; continue; }
      menudefs[$] = mdef;
    }
  }

  // load mod menus
  foreach (int lump; WadIterateNS(EWadNamespace.Global)) {
    if (W_LumpName(lump) == 'modmenu') {
      auto par = MenuDefinition.openParserFromLump(lump);
      scope(exit) delete par;
      while (par.Check("menudef")) {
        auto mdef = SpawnObject(MenuDefinition);
        mdef.parse(par);
        if (!mdef) continue;
        if (!mdef.menuName) { delete mdef; continue; }
        // try to extend menu
        if (mdef.extension) {
          MenuDefinition mtoext = none;
          foreach (MenuDefinition m; menudefs) {
            if (stricmp(m.menuName, mdef.menuName) == 0) {
              mtoext = m;
              break;
            }
          }
          if (mtoext) {
            // extend it
            auto modext = mtoext.findModSubMenuOption();
            foreach (MenuDefOptionBase opt; mdef.options) modext.options[$] = opt;
            mdef.options.clear();
            delete mdef;
            continue;
          }
        }
        // either no menu to extend found, or a brand new menu
        menudefs[$] = mdef;
      }
    }
  }
}


//==========================================================================
//
//  SkipGZIdiocity
//
//  section name skipped
//
//==========================================================================
void SkipGZIdiocity (ScriptsParser par) {
  if (!par.Check("{")) {
    par.ExpectString();
    par.Expect("{");
  }
  int level = 1;
  for (;;) {
    if (par.Check("{")) {
      ++level;
      continue;
    }
    if (par.Check("}")) {
      --level;
      if (level == 0) break;
      continue;
    }
    if (!par.GetString()) return;
  }
}


//==========================================================================
//
//  ParseGZOptionMenu
//
//==========================================================================
void ParseGZOptionMenu (ScriptsParser par, bool extend) {
  par.ExpectString();
  string mname = par.String.toLowerCase();
  // hack for idiotic mods that overrides the whole options menu
  bool isOptRedefine = (!extend && stricmp(mname, "OptionsMenu") == 0);
  if (isOptRedefine) extend = true;
  MenuDefinition mdef;
  int stidx = 0;
  MenuDefOptionModSubMenus suboption = none;
  if (extend) {
    foreach (auto md2; menudefs) {
      if (stricmp(string(md2.menuName), mname) == 0) {
        // i found her!
        mdef = md2;
        break;
      }
    }
    if (!mdef) {
      //par.ScriptError("cannot extend unknown menu '%s'", mname);
      print("GZ-MENUDEF ERROR: cannot extend unknown menu '%s'", mname);
    } else {
      stidx = mdef.options.length;
      suboption = mdef.findModSubMenuOption();
    }
  } else {
    mdef = SpawnObject(MenuDefinition);
    mdef.menuName = mname;
    mdef.gzMenu = true;
  }
  //print("MENUDEF: %soptions menu '%s'...", (extend ? "extending " : ""), mdef.menuName);
  par.Expect("{");
  while (!par.Check("}")) {
    if (par.Check("Title")) {
      par.ExpectString();
      if (mdef && !extend) mdef.title = par.String;
      continue;
    }
    auto opt = MenuDefOptionBase.parseGZ(par);
    if (!opt) continue;
    if (!mdef) { delete opt; continue; }
    if (suboption) {
      // hack for idiotic mods that overrides the whole options menu
      if (isOptRedefine) {
        // this should be submenu
        auto sub = MenuDefOptionSubMenu(opt);
        if (!sub) { delete opt; continue; }
        // check if it is known option
        if (stricmp(sub.subname, "CustomizeControls") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "MouseOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "JoystickOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "PlayerMenu") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "GameplayOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "CompatibilityOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "AutomapOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "HUDOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "MiscOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "SoundOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "VideoOptions") == 0) { delete opt; continue; }
        if (stricmp(sub.subname, "VideoModeMenu") == 0) { delete opt; continue; }
        sub.gzPostFilter = true;
        // other things will be postfiltered
      }
      suboption.options[$] = opt;
    } else {
      mdef.options[$] = opt;
    }
  }
  if (mdef) {
    MenuDefinition.filterOptionList(mdef.options, stidx);
    if (suboption) MenuDefinition.filterOptionList(suboption.options);
    if (!extend) menudefs[$] = mdef;
  }
  /*
  // hack for some idiotic mods
  if (!extend && mdef && stricmp(mdef.menuName, "KetchupOptionsGZDoom") == 0) {
    foreach (auto md2; menudefs) {
      if (stricmp(string(md2.menuName), "OptionsMenu") == 0) {
        print("GZ: hacking in ketchup options (%s)", mdef.title);
        // i found her!
        suboption = md2.findModSubMenuOption();
        auto optsub = SpawnObject(MenuDefOptionSubMenu);
        optsub.title = mdef.title;
        optsub.subname = mdef.menuName;
        suboption.options[$] = optsub;
      }
    }
  }
  */
}


//==========================================================================
//
//  LoadGZMenuDef
//
//  parse GZDoom menudef
//
//==========================================================================
void LoadGZMenuDef (ScriptsParser par) {
  for (;;) {
    if (par.Check("AddOptionMenu")) {
      ParseGZOptionMenu(par, extend:true);
    } else if (par.Check("OptionMenu")) {
      ParseGZOptionMenu(par, extend:false);
    } else if (par.Check("OptionValue")) {
      par.ExpectString();
      int f = 0;
      while (f < optvals.length) {
        if (stricmp(optvals[f].Name, par.String) == 0) {
          optvals[f].list.length = 0;
          optvals.remove(f);
        } else {
          ++f;
        }
      }
      optvals.length += 1;
      optvals[$-1].Name = par.String;
      par.Expect("{");
      while (!par.Check("}")) {
        par.ExpectFloat(withSign:true);
        float val = par.Float;
        par.Expect(",");
        par.ExpectString();
        string cap = par.String;
        optvals[$-1].list.length += 1;
        optvals[$-1].list[$-1].caption = cap;
        optvals[$-1].list[$-1].value = val;
      }
    } else {
      if (!par.GetString()) break;
      //par.ScriptError("unknown gz menudef command '%s'", par.String);
      print("GZMENU: skipping unimplemented section '%s'", par.String);
      SkipGZIdiocity(par);
    }
  }
}


//==========================================================================
//
//  LoadGZMenuDefs
//
//  parse GZDoom menudef
//
//==========================================================================
void LoadGZMenuDefs () {
  if (GetCvarB('_gz_skip_menudef')) return;
  foreach (int lump; WadIterateNS(EWadNamespace.Global)) {
    if (W_LumpName(lump) == 'menudef') {
      auto par = SpawnObject(ScriptsParser);
      scope(exit) delete par;
      par.OpenLumpIndex(lump);
      par.SetCMode(true);
      par.SetEscape(true);
      LoadGZMenuDef(par);
    }
  }
  // fix optionvalue forwards
  foreach (MenuDefinition mdef; menudefs) {
    mdef.fixGZOptionValues(optvals, delegate bool (string subname) {
      foreach (MenuDefinition m; menudefs) {
        if (m.gzMenu && stricmp(m.menuName, subname) == 0) return true;
      }
      return false;
    });
  }
}


//==========================================================================
//
//  SetCommonMenu
//
//==========================================================================
bool SetCommonMenu (string Name) {
  //if (!stricmp(Name, "Main")) { PushMenuScreen(SpawnMenu(MenuScreenMain)); return true; }
  if (!stricmp(Name, "Save")) { PushMenuScreen(SpawnMenu(MenuScreenSaveGame)); return true; }
  if (!stricmp(Name, "Load")) { PushMenuScreen(SpawnMenu(MenuScreenLoadGame)); return true; }
  //if (!stricmp(Name, "PSetup")) { PushMenuScreen(SpawnMenu(MenuScreenPlayerSetup)); return true; }
  if (!stricmp(Name, "Options") || !stricmp(Name, "OptionsMenu")) { PushMenuScreen(SpawnNamedMenu('OptionsMenu')); return true; }
  if (!stricmp(Name, "Controls")) { PushMenuScreen(SpawnMenu(MenuScreenControls)); return true; }
  if (!stricmp(Name, "Mouse")) { PushMenuScreen(SpawnNamedMenu('MouseOptions')); return true; }
  if (!stricmp(Name, "Resolution")) { PushMenuScreen(SpawnMenu(MenuScreenScreenResolution)); return true; }
  if (!stricmp(Name, "Video")) { PushMenuScreen(SpawnNamedMenu('VideoOptions')); return true; }
  if (!stricmp(Name, "Sound")) { PushMenuScreen(SpawnNamedMenu('SoundOptions')); return true; }
  //if (!stricmp(Name, "Help")) { PushMenuScreen(SpawnMenu(MenuScreenHelp)); return true; }
  //if (!stricmp(Name, "Quit")) { menu_quit(); return true; }
  //PushMenuScreen(SpawnMenu(MenuScreenMain));
  return false;
}


//==========================================================================
//
//  SpawnMenu
//
//==========================================================================
MenuScreen SpawnMenu (class!MenuScreen CID) {
  MenuScreen m = MenuScreen(GRoot.NewChild(CID));
  m.ClGame = self;
  m.CreateMenu();
  foreach (auto i, auto scc; savedChoices) {
    if (scc == GetClassName(CID)) {
      m.SetSavedChoice(savedChoicesIdx[i]);
      break;
    }
  }
  return m;
}


//==========================================================================
//
//  SpawnNamedMenuStr
//
//==========================================================================
MenuScreen SpawnNamedMenuStr (string menuName) {
  if (!menuName) {
    FatalError("Cannot spawn unnamed menu");
    return none;
  }

  MenuDefinition mdefmain = none;
  foreach (MenuDefinition mdef; menudefs) {
    if (stricmp(mdef.menuName, menuName) == 0) {
      mdefmain = mdef;
      break;
    }
  }
  if (!mdefmain) {
    FatalError("Menu '%n' not found (name)", menuName);
    return none;
  }

  // create menu
  auto m = MenuScreenTextDef(GRoot.NewChild(MenuScreenTextDef));
  m.ClGame = self;
  m.CreateMenuFromDef(mdefmain);
  m.FinishCreatingMenu();
  // set saved choice
  name mnm = name(mdefmain.menuName);
  foreach (auto i, auto scc; savedChoices) {
    if (scc == mnm) {
      m.SetSavedChoice(savedChoicesIdx[i]);
      break;
    }
  }

  return m;
}


//==========================================================================
//
//  SpawnNamedMenu
//
//==========================================================================
MenuScreen SpawnNamedMenu (name menuName) {
  return SpawnNamedMenuStr(string(menuName));
}


// ////////////////////////////////////////////////////////////////////////// //
// menu stack handling
// ////////////////////////////////////////////////////////////////////////// //

//==========================================================================
//
//  PushMenuScreen
//
//==========================================================================
void PushMenuScreen (MenuScreen menu) {
  // avoid stacking menus invoked by hotkeys
  foreach (auto i, auto msc; menuStack) {
    if (!msc) continue;
    if (menu isa MenuScreenTextDef) {
      if (msc !isa MenuScreenTextDef) continue;
      if (MenuScreenTextDef(msc).menuName != MenuScreenTextDef(menu).menuName) continue;
    } else {
      if (msc.Class != menu.Class) continue;
    }
    while (menuStack.length > i) {
      delete menuStack[$-1];
      menuStack.remove(menuStack.length-1);
    }
    CurrentMenuScreen = none;
    break;
  }

  if (menuStack.length >= MAX_MENU_STACK) FatalError("PushMenu: menu stack overflow");

  menuStack[$] = menu;

  SetCvar('ui_active', 1);
  if (!CurrentMenuScreen) {
    /*
    if (cl.paused) S_ResumeSound();
    C_ClearNotify();
    */
    CmdBuf_AddText("HideConsole\n");
    LocalSound(menu.ActivateSound);
    if (GetCvarB('ui_mouse')) GRoot.SetMouse(true);
  } else {
    CurrentMenuScreen.Hide();
  }

  CurrentMenuScreen = menu;
  CurrentMenuScreen.SetFocus();
}


//==========================================================================
//
//  SaveMenuChoice
//
//==========================================================================
void SaveMenuChoice (MenuScreen menu) {
  if (!menu) return;
  if (menu isa MenuScreenTextDef) {
    auto md = MenuScreenTextDef(menu);
    name menuName = md.menuName;
    if (!menuName) return; // just in case
    // save choice
    bool found = false;
    foreach (auto i, ref auto scc; savedChoices) {
      if (savedChoices[i] == menuName) {
        savedChoicesIdx[i] = menu.GetChoiceForSaving();
        found = true;
        break;
      }
    }
    // if not found, append it
    if (!found) {
      savedChoices[$] = menuName;
      savedChoicesIdx[$] = menu.GetChoiceForSaving();
    }
  } else {
    // save choice
    bool found = false;
    foreach (auto i, ref auto scc; savedChoices) {
      if (savedChoices[i] == GetClassName(menu.Class)) {
        savedChoicesIdx[i] = menu.GetChoiceForSaving();
        found = true;
        break;
      }
    }
    // if not found, append it
    if (!found) {
      savedChoices[$] = GetClassName(menu.Class);
      savedChoicesIdx[$] = menu.GetChoiceForSaving();
    }
  }
}


//==========================================================================
//
//  PopMenu
//
//==========================================================================
void PopMenu () {
  if (menuStack.length == 0) FatalError("PopMenu: menu stack underflow");
  MenuScreen menu = menuStack[$-1];
  menuStack.length -= 1;

  SaveMenuChoice(menu);

  if (menuStack.length) {
    if (menu) LocalSound(menu.DeactivateSound);
    CurrentMenuScreen = menuStack[$-1];
    CurrentMenuScreen.Show();
    CurrentMenuScreen.Raise();
    CurrentMenuScreen.SetFocus();
  } else {
    if (menu) LocalSound(menu.ClearMenusSound);
    CurrentMenuScreen = none;
    SetCvar('ui_active', 0);
    GRoot.SetMouse(false);
  }

  delete menu;
}


//==========================================================================
//
//  ForceMenuOff
//
//==========================================================================
void ForceMenuOff () {
  foreach (ref auto msc; menuStack) {
    SaveMenuChoice(msc);
    delete msc;
  }
  menuStack.clear();
  CurrentMenuScreen = none;
  SetCvar('ui_active', 0);
  GRoot.SetMouse(false);
}


//==========================================================================
//
//  MessageBoxStartMessage
//
//==========================================================================
void MessageBoxStartMessage (string text, int type, bool input) {
  float ui_msgxbox_wrap_trigger = GetCvarF('ui_msgxbox_wrap_trigger');
  float ui_msgxbox_wrap_width = GetCvarF('ui_msgxbox_wrap_width');

  if (ui_msgxbox_wrap_trigger > 0 && ui_msgxbox_wrap_width > 0) {
    // split too long text
    GRoot.SetFont('smallfont');
    msgBoxW = GRoot.TextWidth(text);
    //if (msgBoxW > GetVirtualWidth()-192) text = GRoot.SplitTextWithNewlines(text, /*GetVirtualWidth()-132*/304);
    if (float(msgBoxW)/float(GetVirtualWidth()) > ui_msgxbox_wrap_trigger) {
      int newwdt = int(float(GetVirtualWidth())*ui_msgxbox_wrap_width);
      //print("oldwdt=%s; oldtext=<%q>", msgBoxW, text);
      text = GRoot.SplitTextWithNewlines(text, newwdt, trimRight:true);
      //print("newwdt=%s; newtext=<%q>", newwdt, text);
    }
  }

  messageToPrint = true;
  messageString = text;
  messageType = type;
  messageNeedsInput = input;

  msgBoxW = min(/*304*/GetVirtualWidth()-16, (GRoot.TextWidth(messageString)+16)&~15);
  msgBoxH = min(/*184*/GetVirtualHeight()-16, (GRoot.TextHeight(messageString)+16)&~15);
  msgBoxX = (GetVirtualWidth()-msgBoxW)/2;
  msgBoxY = (GetVirtualHeight()-msgBoxH)/2;

  if (type == MB_Control) SetCvar('ui_control_waiting', 1);

  CmdBuf_AddText("HideConsole\n");
}


//==========================================================================
//
//  MessageBoxDrawer
//
//==========================================================================
override void MessageBoxDrawer () {
  // horiz. & vertically centre string and print it
  if (messageToPrint) {
    GRoot.FillRectWithFlat(msgBoxX, msgBoxY, msgBoxW, msgBoxH, MsgBoxFlat);
    DrawBorder(msgBoxX, msgBoxY, msgBoxW, msgBoxH);
    GRoot.SetFont('smallfont');
    GRoot.SetTextAlign(hcentre, vcentre);
    GRoot.DrawText(GetVirtualWidth()/2, GetVirtualHeight()/2, messageString);
  }

  if (WaitForQuit && !IsLocalSoundPlaying(QuitSound)) {
    CmdBuf_AddText("Quit\n");
  }
}


//==========================================================================
//
//  MessageBoxResponder
//
//==========================================================================
override bool MessageBoxResponder (event_t *event) {
  if (WaitForQuit) return true;

  // take care of any messages that need input
  if (messageToPrint && event.type == ev_keydown) {
    if (messageNeedsInput &&
        event.keycode != K_SPACE &&
        event.keycode != K_n &&
        event.keycode != K_y &&
        event.keycode != K_ESCAPE &&
        event.keycode != K_MOUSE1 && event.keycode != K_MOUSE2)
    {
      return true;
    }

    messageToPrint = false;
    switch (messageType) {
      case MB_None: break;
      case MB_Quit: QuitResponse(event->data1); break;
      case MB_Control: SetCvar('ui_control_waiting', 0); ControlResponse(event->data1); break;
      case MB_Shareware: SharewareResponse(event->data1); break;
      case MB_Nightmare: VerifyNightmare(event->data1); break;
      case MB_EndGame: EndGameResponse(event->data1); break;
    }

    //S_StartSound(sfx1_swtchx);
    return true;
  }

  return false;
}


//==========================================================================
//
//  MessageBoxActive
//
//==========================================================================
override bool MessageBoxActive () {
  return messageToPrint;
}


//==========================================================================
//
//  ControlResponse
//
//==========================================================================
void ControlResponse (int key) {
  string kb_down;
  string kb_up;
  int key1;
  int key2;

  if (key != K_ESCAPE) {
    kb_down = CurrentCtl.CommandOn;
    kb_up = CurrentCtl.CommandOff;
    IN_GetBindingKeys(kb_down, &key1, &key2);
    if (ControlColumn == 0) {
      IN_SetBinding(key1, "", "");
      IN_SetBinding(key, kb_down, kb_up);
    }
    if (ControlColumn == 1) {
      IN_SetBinding(key2, "", "");
      IN_SetBinding(key, kb_down, kb_up);
    }
  }
}


//==========================================================================
//
//  VerifyNightmare
//
//  Realy nightmare skill?
//
//==========================================================================
void VerifyNightmare (int ch) {
  if (ch != K_y && ch != K_t) return;
  NewGame(SkillToConfirm);
}


//==========================================================================
//
//  EndGameResponse
//
//==========================================================================
void EndGameResponse (int ch) {
  if (ch != K_y && ch != K_t) return;
  CmdBuf_AddText("Disconnect\n");
}


//==========================================================================
//
//  AddNotifyMessage
//
//==========================================================================
override void AddNotifyMessage (string Str) {
  GSBar.AddNotifyMessage(Str);
}


//==========================================================================
//
//  AddCentreMessage
//
//==========================================================================
override void AddCentreMessage (string Msg) {
  GSBar.AddCentreMessage(Msg);
}


//==========================================================================
//
//  AddHudMessage
//
//==========================================================================
override void AddHudMessage (string Message, name Font, int Type, int Id, int Colour,
  string ColourName, float x, float y, int HudWidth, int HudHeight,
  float HoldTime, float Time1, float Time2)
{
  //print("AddHudMessage: id=%s; msg=<%q>", Id, Message);
  GSBar.AddHudMessage(Message, Font, Type, Id, Colour, ColourName, x, y,
    HudWidth, HudHeight, HoldTime, Time1, Time2);
}


//==========================================================================
//
//  SetPClass
//
//==========================================================================
void SetPClass (int PClass) {
  MenuPClass = PClass;
  SkillClassName = va("%n", class!PlayerPawn(Game.PlayerClasses[PClass]).default.SpawnClass);
  //print("EPISODES: %d", P_GetNumEpisodes());
  if (P_GetNumEpisodes() > 1) {
    PushMenuScreen(SpawnMenu(MenuScreenEpisode));
  } else {
    SetEpisode(P_GetEpisodeDef(0));
  }
}


//==========================================================================
//
//  SetEpisode
//
//==========================================================================
void SetEpisode (EpisodeDef *EDef) {
  MenuStartMap = EDef->Name;
  if (EDef->TeaserName && !IsMapPresent(EDef->Name)) MenuStartMap = EDef->TeaserName;
  if (EDef->bNoSkillMenu) {
    NewGame(2);
  } else {
    PushMenuScreen(SpawnMenu(MenuScreenSkill));
  }
}


//==========================================================================
//
//  NewGame
//
//==========================================================================
void NewGame (int SkillLevel) {
  SetCvar('Skill', SkillLevel);
  SetCvar('Class', MenuPClass);

  CmdBuf_AddText("Disconnect\n");
  CmdBuf_AddText("MaxPlayers 1\n");
  CmdBuf_AddText("Map %n\n", MenuStartMap);

  ForceMenuOff();
}


void menu_quit () {
}


void DrawBorder (int x, int y, int w, int h) {
}


void QuitResponse (int key) {
}


void SharewareResponse (int key) {
}


defaultproperties {
}
