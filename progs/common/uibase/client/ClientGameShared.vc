//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
class ClientGameShared : LineSpecialClientGame
  abstract;


enum {
  MB_None,
  MB_Quit,
  MB_Control,
  MB_Shareware,
  MB_Nightmare,
  MB_EndGame,
}


array!name savedChoices;
array!int savedChoicesIdx;

const int MAX_MENU_STACK = 64;

StatusBarShared GSBar;

array!MenuScreen menu_stack;

MenuScreen CurrentMenuScreen;

MenuControlKey CurrentCtl;
int ControlColumn; // menu column for controls

int MenuPClass;
name MenuStartMap;
string SkillClassName;
int SkillToConfirm;


// message box
bool messageToPrint;
int msgBoxX;
int msgBoxY;
int msgBoxW;
int msgBoxH;
string messageString; // ...and here is the message string!
bool messageNeedsInput; // timed message = no input from user
int messageType;
name MsgBoxFlat;

name QuitSound;
bool WaitForQuit;

int BigSelectorXOffset;
int BigSelectorYOffset;
int BigSelectorAnimSpeed;
array!name BigSelectorAnimFrames;

name DefaultFinaleMusic;
name DefaultFinaleType;


//==========================================================================
//
//  SpawnMenu
//
//==========================================================================
final MenuScreen SpawnMenu (class!MenuScreen CID) {
  MenuScreen m = MenuScreen(GRoot.NewChild(CID));
  m.ClGame = self;
  m.CreateMenu();
  foreach (auto i, auto scc; savedChoices) {
    if (scc == GetClassName(CID)) {
      m.SetSavedChoice(savedChoicesIdx[i]);
      break;
    }
  }
  return m;
}


// ////////////////////////////////////////////////////////////////////////// //
// menu stack handling
// ////////////////////////////////////////////////////////////////////////// //

//==========================================================================
//
//  PushMenuScreen
//
//==========================================================================
final void PushMenuScreen (MenuScreen menu) {
  // avoid stacking menus invoked by hotkeys
  foreach (auto i, auto msc; menu_stack) {
    if (msc && msc.Class == menu.Class) {
      while (menu_stack.length > i) {
        delete menu_stack[$-1];
        menu_stack.remove(menu_stack.length-1);
      }
      CurrentMenuScreen = none;
      break;
    }
  }

  if (menu_stack.length >= MAX_MENU_STACK) FatalError("PushMenu: menu stack overflow");

  menu_stack[$] = menu;

  SetCvar('ui_active', 1);
  if (!CurrentMenuScreen) {
    /*
    if (cl.paused) S_ResumeSound();
    C_ClearNotify();
    */
    CmdBuf_AddText("HideConsole\n");
    LocalSound(menu.ActivateSound);
    if (GetCvarB('ui_mouse')) GRoot.SetMouse(true);
  } else {
    CurrentMenuScreen.Hide();
  }

  CurrentMenuScreen = menu;
  CurrentMenuScreen.SetFocus();
}


//==========================================================================
//
//  SaveMenuChoice
//
//==========================================================================
final void SaveMenuChoice (MenuScreen menu) {
  if (!menu) return;
  // save choice
  bool found = false;
  foreach (auto i, ref auto scc; savedChoices) {
    if (savedChoices[i] == GetClassName(menu.Class)) {
      savedChoicesIdx[i] = menu.GetChoiceForSaving();
      found = true;
      break;
    }
  }
  // if not found, append it
  if (!found) {
    savedChoices[$] = GetClassName(menu.Class);
    savedChoicesIdx[$] = menu.GetChoiceForSaving();
  }
}


//==========================================================================
//
//  PopMenu
//
//==========================================================================
final void PopMenu () {
  if (menu_stack.length == 0) FatalError("PopMenu: menu stack underflow");
  MenuScreen menu = menu_stack[$-1];
  menu_stack.length -= 1;

  SaveMenuChoice(menu);

  if (menu_stack.length) {
    if (menu) LocalSound(menu.DeactivateSound);
    CurrentMenuScreen = menu_stack[$-1];
    CurrentMenuScreen.Show();
    CurrentMenuScreen.Raise();
    CurrentMenuScreen.SetFocus();
  } else {
    if (menu) LocalSound(menu.ClearMenusSound);
    CurrentMenuScreen = none;
    SetCvar('ui_active', 0);
    GRoot.SetMouse(false);
  }

  delete menu;
}


//==========================================================================
//
//  ForceMenuOff
//
//==========================================================================
final void ForceMenuOff () {
  foreach (ref auto msc; menu_stack) {
    SaveMenuChoice(msc);
    delete msc;
  }
  menu_stack.clear();
  CurrentMenuScreen = none;
  SetCvar('ui_active', 0);
  GRoot.SetMouse(false);
}


//==========================================================================
//
//  MessageBoxStartMessage
//
//==========================================================================
final void MessageBoxStartMessage (string text, int type, bool input) {
  messageToPrint = true;
  messageString = text;
  messageType = type;
  messageNeedsInput = input;

  GRoot.SetFont('smallfont');
  msgBoxW = min(304, (GRoot.TextWidth(messageString)+16)&~15);
  msgBoxH = min(184, (GRoot.TextHeight(messageString)+16)&~15);
  msgBoxX = (640-msgBoxW)/2;
  msgBoxY = (480-msgBoxH)/2;

  CmdBuf_AddText("HideConsole\n");
}


//==========================================================================
//
//  MessageBoxDrawer
//
//==========================================================================
final override void MessageBoxDrawer () {
  // horiz. & vertically centre string and print it
  if (messageToPrint) {
    GRoot.FillRectWithFlat(msgBoxX, msgBoxY, msgBoxW, msgBoxH, MsgBoxFlat);
    DrawBorder(msgBoxX, msgBoxY, msgBoxW, msgBoxH);
    GRoot.SetFont('smallfont');
    GRoot.SetTextAlign(hcentre, vcentre);
    GRoot.DrawText(320, 240, messageString);
  }

  if (WaitForQuit && !IsLocalSoundPlaying(QuitSound)) {
    CmdBuf_AddText("Quit\n");
  }
}


//==========================================================================
//
//  MessageBoxResponder
//
//==========================================================================
final override bool MessageBoxResponder (event_t *event) {
  if (WaitForQuit) return true;

  // take care of any messages that need input
  if (messageToPrint && event.type == ev_keydown) {
    if (messageNeedsInput &&
        event.keycode != K_SPACE &&
        event.keycode != K_n &&
        event.keycode != K_y &&
        event.keycode != K_ESCAPE &&
        event.keycode != K_MOUSE1 && event.keycode != K_MOUSE2)
    {
      return true;
    }

    messageToPrint = false;
    switch (messageType) {
      case MB_None: break;
      case MB_Quit: QuitResponse(event->data1); break;
      case MB_Control: ControlResponse(event->data1); break;
      case MB_Shareware: SharewareResponse(event->data1); break;
      case MB_Nightmare: VerifyNightmare(event->data1); break;
      case MB_EndGame: EndGameResponse(event->data1); break;
    }

    //S_StartSound(sfx1_swtchx);
    return true;
  }

  return false;
}


//==========================================================================
//
//  MessageBoxActive
//
//==========================================================================
final override bool MessageBoxActive () {
  return messageToPrint;
}


//==========================================================================
//
//  ControlResponse
//
//==========================================================================
void ControlResponse (int key) {
  string kb_down;
  string kb_up;
  int key1;
  int key2;

  if (key != K_ESCAPE) {
    kb_down = CurrentCtl.CommandOn;
    kb_up = CurrentCtl.CommandOff;
    IN_GetBindingKeys(kb_down, &key1, &key2);
    if (ControlColumn == 0) {
      IN_SetBinding(key1, "", "");
      IN_SetBinding(key, kb_down, kb_up);
    }
    if (ControlColumn == 1) {
      IN_SetBinding(key2, "", "");
      IN_SetBinding(key, kb_down, kb_up);
    }
  }
}


//==========================================================================
//
//  VerifyNightmare
//
//  Realy mightmare skill?
//
//==========================================================================
final void VerifyNightmare (int ch) {
  if (ch != K_y && ch != K_t) return;
  NewGame(SkillToConfirm);
}


//==========================================================================
//
//  EndGameResponse
//
//==========================================================================
final void EndGameResponse (int ch) {
  if (ch != K_y && ch != K_t) return;
  CmdBuf_AddText("Disconnect\n");
}


//==========================================================================
//
//  AddNotifyMessage
//
//==========================================================================
override void AddNotifyMessage (string Str) {
  GSBar.AddNotifyMessage(Str);
}


//==========================================================================
//
//  AddCentreMessage
//
//==========================================================================
override void AddCentreMessage (string Msg) {
  GSBar.AddCentreMessage(Msg);
}


//==========================================================================
//
//  AddHudMessage
//
//==========================================================================
override void AddHudMessage (string Message, name Font, int Type, int Id, int Colour,
  string ColourName, float x, float y, int HudWidth, int HudHeight,
  float HoldTime, float Time1, float Time2)
{
  GSBar.AddHudMessage(Message, Font, Type, Id, Colour, ColourName, x, y,
    HudWidth, HudHeight, HoldTime, Time1, Time2);
}


//==========================================================================
//
//  SetPClass
//
//==========================================================================
final void SetPClass (int PClass) {
  MenuPClass = PClass;
  SkillClassName = va("%n", class!PlayerPawn(Game.PlayerClasses[PClass]).default.SpawnClass);
  print("EPISODES: %d", P_GetNumEpisodes());
  if (P_GetNumEpisodes() > 1) {
    PushMenuScreen(SpawnMenu(MenuScreenEpisode));
  } else {
    SetEpisode(P_GetEpisodeDef(0));
  }
}


//==========================================================================
//
//  SetEpisode
//
//==========================================================================
final void SetEpisode (EpisodeDef *EDef) {
  MenuStartMap = EDef->Name;
  if (EDef->TeaserName && !IsMapPresent(EDef->Name)) MenuStartMap = EDef->TeaserName;
  if (EDef->bNoSkillMenu) {
    NewGame(2);
  } else {
    PushMenuScreen(SpawnMenu(MenuScreenSkill));
  }
}


//==========================================================================
//
//  NewGame
//
//==========================================================================
final void NewGame (int SkillLevel) {
  SetCvar('Skill', SkillLevel);
  SetCvar('Class', MenuPClass);

  CmdBuf_AddText("Disconnect\n");
  CmdBuf_AddText("MaxPlayers 1\n");
  CmdBuf_AddText("Map %n\n", MenuStartMap);

  ForceMenuOff();
}


void menu_quit () {
}


void DrawBorder (int x, int y, int w, int h) {
}


void QuitResponse (int key) {
}


void SharewareResponse (int key) {
}


defaultproperties {
}
