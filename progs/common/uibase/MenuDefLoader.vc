//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 2018-2021 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************

//**************************************************************************
//
// MenuDefinition
//
//**************************************************************************
class MenuDefinition : Object;

string menuName;
name seltype = 'MenuSelector_SmallRight';
string title;
bool extension; // true: extend `menuName`
bool gzMenu; // this is gz menu, used for postfiltering

array!MenuDefOptionBase options;


/*
static final string readText (string fname) {
  auto fl = TextReader.Open(fname);
  if (!fl) return "";
  scope(exit) delete fl;
  if (fl.size > 1024*1024) return "" ;
  return fl.readBuf(fl.size, exact:true);
}
*/


//==========================================================================
//
//  str2bool
//
//==========================================================================
static final bool str2bool (string s) {
  return
    stricmp(s, "tan") == 0 ||
    stricmp(s, "on") == 0 ||
    stricmp(s, "true") == 0 ||
    stricmp(s, "yes") == 0 ||
    stricmp(s, "1") == 0;
}


//==========================================================================
//
//  openParser
//
//==========================================================================
static final ScriptsParser openParser (string fname) {
  auto par = SpawnObject(ScriptsParser);
  //par.OpenString('menudef', readText(fname));
  par.OpenLumpFullName(fname);
  par.SetCMode(true);
  par.SetEscape(true);
  return par;
}


//==========================================================================
//
//  openParserFromLump
//
//==========================================================================
static final ScriptsParser openParserFromLump (int lump) {
  auto par = SpawnObject(ScriptsParser);
  //par.OpenString('menudef', readText(fname));
  par.OpenLumpIndex(lump);
  par.SetCMode(true);
  par.SetEscape(true);
  return par;
}


//==========================================================================
//
//  findModSubMenuOption
//
//==========================================================================
MenuDefOptionModSubMenus findModSubMenuOption () {
  foreach (MenuDefOptionBase opt; options) {
    if (opt isa MenuDefOptionModSubMenus) return MenuDefOptionModSubMenus(opt);
  }
  // add one
  auto opt = SpawnObject(MenuDefOptionModSubMenus);
  options[$] = opt;
  return opt;
}


//==========================================================================
//
//  fixGZList
//
//  fix GZDoom-style menudefs
//
//==========================================================================
private final static void fixGZList (ref array!MenuDefOptionBase aoptions, ref array!(ClientGameShared::OptionValue) ovals,
                                     bool delegate (string subname) gzCheckSub)
{
  for (int f = 0; f < aoptions.length; ++f) {
    MenuDefOptionBase opt = aoptions[f];
    if (opt isa MenuDefOptionModSubMenus) {
      fixGZList(MenuDefOptionModSubMenus(opt).options, ovals, gzCheckSub);
    } else if (opt isa MenuDefOptionEnum) {
      auto eopt = MenuDefOptionEnum(opt);
      if (!eopt.gzOptValName) continue;
      foreach (ref auto oval; ovals) {
        if (stricmp(oval.Name, eopt.gzOptValName) == 0) {
          // i found her!
          foreach (ref auto v; oval.list) {
            eopt.list.length += 1;
            eopt.list[$-1].caption = TranslateString(v.caption);
            eopt.list[$-1].value = v.value;
          }
          eopt.gzOptValName = "";
          break;
        }
      }
      if (eopt.gzOptValName) FatalError("GZ option value '%s' not found", eopt.gzOptValName);
    } else {
      auto sub = MenuDefOptionSubMenu(opt);
      if (!sub || !sub.gzPostFilter) continue;
      if (gzCheckSub(sub.subname)) continue;
      print("removing unknown GZ-defined option in options menu: '%s'", sub.subname);
      delete aoptions[f];
      aoptions.remove(f);
      --f;
    }
  }
}


//==========================================================================
//
//  fixGZOptionValues
//
//==========================================================================
void fixGZOptionValues (ref array!(ClientGameShared::OptionValue) ovals, bool delegate (string subname) gzCheckSub) {
  fixGZList(options, ovals, gzCheckSub);
}


//==========================================================================
//
//  filterOptionList
//
//==========================================================================
static final void filterOptionList (ref array!MenuDefOptionBase aoptions, optional int stidx) {
  if (stidx < 0) stidx = 0;
  while (stidx < aoptions.length) {
    if (aoptions[stidx] !isa MenuDefOptionSubHeader) { ++stidx; continue; }
    if (stidx > 0 && aoptions[stidx-1] isa MenuDefOptionSubHeader && !aoptions[stidx-1].title) {
      delete aoptions[stidx-1];
      aoptions.remove(stidx-1);
      --stidx;
    } else {
      ++stidx;
    }
  }
}


//==========================================================================
//
//  parse
//
//  "menudef" eaten
//
//==========================================================================
void parse (ScriptsParser par) {
  par.ExpectIdentifier();
  menuName = par.String.toLowerCase();
  if (par.Check("extend")) extension = true;

  par.Expect("{");
  while (!par.Check("}")) {
    if (par.Check("selector")) {
      par.Expect("=");
      par.ExpectIdentifier();
      seltype = (stricmp(par.String, "none") == 0 ? '' : name(par.String));
      par.Expect(";");
      continue;
    }

    if (par.Check("title")) {
      par.Expect("=");
      par.ExpectString();
      title = par.String;
      par.Expect(";");
      continue;
    }

    if (par.Check("option")) {
      auto opt = MenuDefOptionBase.parse(par);
      if (opt) options[$] = opt;
      continue;
    }

    if (par.Check("header")) {
      auto hdr = SpawnObject(MenuDefOptionSubHeader);
      // condition?
      if (par.Check("[")) {
        //printdebug("HDR: condition (0)!");
        hdr.cond = MenuDefCondition.parse(par);
      }
      if (par.Check("{")) {
        while (!par.Check("}")) {
          if (!hdr.parseOne(par)) par.ScriptError("invalid menudef command '%s'", par.String);
        }
      } else {
        par.ExpectString();
        //printdebug("HDR: title=<%s>", par.String);
        string stitle = par.String;
        // condition?
        if (!hdr.cond && par.Check("[")) {
          //printdebug("HDR: condition (1)!");
          hdr.cond = MenuDefCondition.parse(par);
        }
        par.Expect(";");
        hdr.title = stitle;
      }
      options[$] = hdr;
      continue;
    }

    if (par.Check("modsubmenus")) {
      auto subplace = SpawnObject(MenuDefOptionModSubMenus);
      // condition?
      if (par.Check("[")) {
        subplace.cond = MenuDefCondition.parse(par);
      }
      par.Expect(";");
      options[$] = subplace;
      continue;
    }

    par.ScriptError("invalid menudef command '%s'", par.String);
  }
}



//**************************************************************************
//
// MenuDefOptionBase
//
//**************************************************************************
class MenuDefOptionBase : Object;

MenuDefCondition cond;
string title;
name cvar;
string help;
int textColor = CR_UNDEFINED;
int textColorFocus = CR_UNDEFINED;


//==========================================================================
//
//  Destroy
//
//==========================================================================
override void Destroy () {
  delete cond;
  ::Destroy();
}


//==========================================================================
//
//  CreateOption
//
//==========================================================================
MenuChoiceBase CreateOption (MenuScreen menu) {
  return none;
}


//==========================================================================
//
//  test
//
//==========================================================================
bool test () {
  if (!cond) return true;
  return cond.test();
}


//==========================================================================
//
//  parseTextColorName
//
//==========================================================================
final static int parseTextColorName (ScriptsParser par) {
       if (par.Check("undefined") || par.Check("default")) return CR_UNDEFINED;
  else if (par.Check("brick")) return CR_BRICK;
  else if (par.Check("tan")) return CR_TAN;
  else if (par.Check("gray") || par.Check("grey")) return CR_GRAY;
  else if (par.Check("green")) return CR_GREEN;
  else if (par.Check("brown")) return CR_BROWN;
  else if (par.Check("gold")) return CR_GOLD;
  else if (par.Check("red")) return CR_RED;
  else if (par.Check("blue")) return CR_BLUE;
  else if (par.Check("orange")) return CR_ORANGE;
  else if (par.Check("white")) return CR_WHITE;
  else if (par.Check("yellow")) return CR_YELLOW;
  else if (par.Check("untranslated")) return CR_UNTRANSLATED;
  else if (par.Check("black")) return CR_BLACK;
  else if (par.Check("lightblue")) return CR_LIGHTBLUE;
  else if (par.Check("cream")) return CR_CREAM;
  else if (par.Check("olive")) return CR_OLIVE;
  else if (par.Check("darkgreen")) return CR_DARKGREEN;
  else if (par.Check("darkred")) return CR_DARKRED;
  else if (par.Check("darkbrown")) return CR_DARKBROWN;
  else if (par.Check("purple")) return CR_PURPLE;
  else if (par.Check("darkgray") || par.Check("darkgrey")) return CR_DARKGRAY;
  else if (par.Check("cyan")) return CR_CYAN;
  else if (par.Check("ice")) return CR_ICE;
  else if (par.Check("fire")) return CR_FIRE;
  else if (par.Check("sapphire")) return CR_SAPPHIRE;
  else if (par.Check("teal")) return CR_TEAL;
  else par.ScriptError("invalid color name '%s'", par.String);
  return CR_UNDEFINED;
}


//==========================================================================
//
//  parse
//
//  "option" skipped
//
//==========================================================================
final static MenuDefOptionBase parse (ScriptsParser par) {
  MenuDefOptionBase res;
  par.SetCMode(true);
  par.SetEscape(true);
       if (par.Check("bool")) res = SpawnObject(MenuDefOptionBool);
  else if (par.Check("enum")) res = SpawnObject(MenuDefOptionEnum);
  else if (par.Check("slider")) res = SpawnObject(MenuDefOptionSlider);
  else if (par.Check("numeric")) res = SpawnObject(MenuDefOptionNumeric);
  else if (par.Check("submenu")) res = SpawnObject(MenuDefOptionSubMenu);
  else if (par.Check("submenubig") || par.Check("submenu_big")) res = SpawnObject(MenuDefOptionSubMenuBig);
  else if (par.Check("mod_controls")) res = SpawnObject(MenuDefOptionControls);
  else if (par.Check("console")) res = SpawnObject(MenuDefOptionConsole);
  else if (par.Check("concmd")) res = SpawnObject(MenuDefOptionConCmd);
  else if (par.Check("crosshair")) res = SpawnObject(MenuDefOptionCrosshair);
  else if (par.Check("bind")) res = SpawnObject(MenuDefOptionBind);
  else if (par.Check("render")) res = SpawnObject(MenuDefOptionRenderType);
  else if (par.Check("color")) res = SpawnObject(MenuDefOptionColor);
  else par.ScriptError("invalid option type '%s'", par.String);
  // condition?
  if (par.Check("[")) {
    res.cond = MenuDefCondition.parse(par);
  }
  par.Expect("{");
  while (!par.Check("}")) {
    if (par.Check(";")) continue;
    if (!res.parseOne(par)) par.ScriptError("invalid menu definition keyword '%s'", par.String);
  }
  return res;
}


//==========================================================================
//
//  MenuDefOptionBase
//
//  parse GZDoom-style menudef
//
//==========================================================================
final static MenuDefOptionBase parseGZ (ScriptsParser par/*, ref array!(ClientGameShared::OptionValue) ovals*/) {
  par.SetCMode(true);
  par.SetEscape(true);

  if (par.Check("StaticText")) {
    par.ExpectString();
    auto opt = SpawnObject(MenuDefOptionSubHeader);
    opt.title = par.String;
    while (opt.title && opt.title[$-1] <= 32) opt.title = opt.title[0..$-1];
    if (par.Check(",")) {
      // dunno, probably color or something
      par.GetString();
    }
    return opt;
  }

  if (par.Check("Submenu")) {
    // title
    par.ExpectString();
    string stitle = par.String;
    par.Expect(",");
    // submenu name
    par.ExpectString();
    string subname = par.String;
    //if (stricmp(subname, "OptionsMenu") == 0) subname = "Options";
    auto opt = SpawnObject(MenuDefOptionSubMenu);
    opt.title = stitle;
    opt.subname = subname;
    return opt;
  }

  //option "'Marine Helmet' Armor Bonus", "botoggle", "onoff"  [, "cvar-enable-check" [, Center]]
  if (par.Check("option")) {
    // title
    par.ExpectString();
    string stitle = par.String;
    par.Expect(",");
    // cvar
    par.ExpectString();
    name scvar = name(par.String);
    par.Expect(",");
    // type
    if (par.Check("onoff") || par.Check("yesno")) {
      auto opt = SpawnObject(MenuDefOptionBool);
      opt.title = stitle;
      opt.cvar = scvar;
      return opt;
    }
    // fuck
    if (par.Check("offon") || par.Check("noyes")) {
      auto opt = SpawnObject(MenuDefOptionBool);
      opt.title = stitle;
      opt.cvar = scvar;
      opt.inverted = true;
      return opt;
    }
    // this should be "OptionValue"
    par.ExpectString();
    auto opt = SpawnObject(MenuDefOptionEnum);
    opt.title = stitle;
    opt.cvar = scvar;
    opt.gzOptValName = par.String;
    if (par.Check(",")) par.ExpectString(); // cvar-enable
    if (par.Check(",")) par.ExpectString(); // center
    return opt;
    /*
    foreach (ref auto oval; ovals) {
      if (stricmp(oval.Name, par.String) == 0) {
        // i found her!
        if (par.Check(",")) par.ExpectString(); // cvar-enable
        if (par.Check(",")) par.ExpectString(); // center
        auto opt = SpawnObject(MenuDefOptionEnum);
        opt.title = stitle;
        opt.cvar = scvar;
        foreach (ref auto v; oval.list) {
          opt.list.length += 1;
          opt.list[$-1].caption = v.caption;
          opt.list[$-1].value = v.value;
        }
        return opt;
      }
    }
    //par.ScriptError("unknown GZDoom MenuDef OptionValue '%s'", par.String);
    print("MENUDEF: unknown GZDoom MenuDef OptionValue '%s'", par.String);
    return none;
    */
  }

  //Slider "<label>", "<CVAR>", <minimum>, <maximum>, <inc> [, decimal places]
  if (par.Check("Slider")) {
    // title
    par.ExpectString();
    string stitle = par.String;
    par.Expect(",");
    // cvar
    par.ExpectString();
    name scvar = name(par.String);
    par.Expect(",");
    // min, max, step
    par.ExpectFloat(withSign:true);
    float minv = par.Float;
    par.Expect(",");
    par.ExpectFloat(withSign:true);
    float maxv = par.Float;
    par.Expect(",");
    par.ExpectFloat(withSign:false);
    float step = par.Float;
    // skip decimals
    if (par.Check(",")) par.ExpectNumber();
    auto res = SpawnObject(MenuDefOptionSlider);
    res.title = stitle;
    res.step = step;
    res.minv = minv;
    res.maxv = maxv;
    res.cvar = scvar;
    return res;
  }

  //NumberField "<label>", "<CVAR>", <minimum>, <maximum>, <inc> [, decimal places]
  if (par.Check("NumberField")) {
    // title
    par.ExpectString();
    string stitle = par.String;
    par.Expect(",");
    // cvar
    par.ExpectString();
    name scvar = name(par.String);
    float minv = 0;
    float maxv = 100;
    float step = 1;
    if (par.Check(",")) {
      par.ExpectFloat(withSign:true);
      minv = par.Float;
      if (par.Check(",")) {
        par.ExpectFloat(withSign:true);
        maxv = par.Float;
        if (par.Check(",")) {
          par.ExpectFloat(withSign:false);
          step = par.Float;
          // skip decimals
          if (par.Check(",")) par.ExpectNumber();
        }
      }
    }
    auto res = SpawnObject(MenuDefOptionNumeric);
    res.title = stitle;
    res.step = step;
    res.minv = minv;
    res.maxv = maxv;
    res.cvar = scvar;
    return res;
  }

  par.ExpectString();
  print("MENUDEF: skipping gz command '%s'", par.String);
  auto oldNumSign = par.IsAllowNumSign();
  scope(exit) par.SetAllowNumSign(oldNumSign);
  par.SetAllowNumSign(true);
  for (;;) {
    par.ExpectString();
    //if (par.String == "-" || par.String == "+" || par.String == ".") par.ExpectString();
    if (!par.Check(",")) break;
  }
  //par.ScriptError("invalid gz command '%s'", par.String);
  return none;
}


//==========================================================================
//
//  parseOne
//
//==========================================================================
bool parseOne (ScriptsParser par) {
  if (par.Check("title")) {
    par.Expect("=");
    par.ExpectString();
    title = par.String;
    par.Expect(";");
    //writeln("TITLE: <", title, ">");
    return true;
  }

  if (par.Check("cvar")) {
    par.Expect("=");
    par.ExpectIdentifier();
    cvar = name(par.String);
    par.Expect(";");
    return true;
  }

  if (par.Check("help")) {
    par.Expect("=");
    while (!par.Check(";")) {
      if (par.Check("}") || par.Check("{") || par.Check("=")) par.ScriptError("you probably forgot semicolon for the `help` above");
      par.ExpectString();
      if (!par.Quoted && par.String == ",") continue;
      if (help) help ~= "\n";
      help ~= par.String;
    }
    return true;
  }

  if (par.Check("textcolor") || par.Check("text_color")) {
    par.Expect("=");
    textColor = parseTextColorName(par);
    par.Expect(";");
    return true;
  }

  if (par.Check("focuscolor") || par.Check("focus_color")) {
    par.Expect("=");
    textColorFocus = parseTextColorName(par);
    par.Expect(";");
    return true;
  }

  return false;
}



//**************************************************************************
//
// MenuDefOptionModSubMenus
//
//**************************************************************************
class MenuDefOptionModSubMenus : MenuDefOptionBase;

array!MenuDefOptionBase options;


defaultproperties {
  textColor = CR_ORANGE;
  textColorFocus = CR_ORANGE;
}



//**************************************************************************
//
// MenuDefOptionSubHeader
//
//**************************************************************************
class MenuDefOptionSubHeader : MenuDefOptionBase;

//==========================================================================
//
//  CreateOption
//
//==========================================================================
override MenuChoiceBase CreateOption (MenuScreen menu) {
  auto opt = MenuSmallTextButton(menu.GetItemContainer().NewChild(MenuSmallTextButton));
  opt.TextHAlign = hcenter;
  opt.TextVAlign = vbottom;
  opt.SetText(title);
  opt.Focusable = false;
  if (textColor != CR_UNDEFINED) opt.TextColor = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColorFocus = textColorFocus;
  //opt.Height = (title ? 12 : 10);
  if (title) opt.Height = opt.Height+(opt.Height <= 11 ? 2 : 4);
  return opt;
}


defaultproperties {
  textColor = /*CR_ORANGE*/CR_FIRE;
  textColorFocus = /*CR_ORANGE*/CR_FIRE;
}



//**************************************************************************
//
// MenuDefOptionBool
//
//**************************************************************************
class MenuDefOptionBool : MenuDefOptionBase;

bool inverted;


//==========================================================================
//
//  CreateOption
//
//==========================================================================
override MenuChoiceBase CreateOption (MenuScreen menu) {
  auto opt = MenuChoice_OnOff(menu.GetItemContainer().NewChild(MenuChoice_OnOff));
  opt.SetInverted(inverted);
  opt.SetText(title);
  if (textColor != CR_UNDEFINED) opt.TextColor = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColorFocus = textColorFocus;
  if (cvar) opt.SetSessionCvar(cvar);
  return opt;
}



//**************************************************************************
//
// MenuDefOptionEnum
//
//**************************************************************************
class MenuDefOptionEnum : MenuDefOptionBase;

array!(ClientGameShared::OptionValueDef) list;
string gzOptValName;
bool isSF2Selector;


//==========================================================================
//
//  parseOne
//
//==========================================================================
override bool parseOne (ScriptsParser par) {
  if (::parseOne(par)) {
    isSF2Selector = nameEquCI(cvar, 'snd_sf2_file_selector');
    return true;
  }

  isSF2Selector = nameEquCI(cvar, 'snd_sf2_file_selector');

  if (par.Check("list")) {
    if (par.Check("=")) {
      // there will be more
      par.Expect("text_colors");
      int val = 0;
      list.length += 1; list[$-1].caption = "Brick"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Tan"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Gray"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Green"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Brown"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Gold"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Red"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Blue"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Orange"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "White"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Yellow"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Normal"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Black"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Light Blue"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Cream"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Olive"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Dark Green"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Dark Red"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Dark Brown"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Purple"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Dark Gray"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Cyan"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Ice"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Fire"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Sapphire"; list[$-1].value = float(val++);
      list.length += 1; list[$-1].caption = "Teal"; list[$-1].value = float(val++);
    } else {
      par.Expect("{");
      int val = 0;
      while (!par.Check("}")) {
        par.ExpectString();
        list.length += 1;
        list[$-1].caption = par.String;
        if (par.Check("=")) {
          par.ExpectNumber(withSign:true);
          val = par.Number;
        }
        list[$-1].value = float(val++);
        while (par.Check(",")) {}
      }
    }
    return true;
  }

  return false;
}


//==========================================================================
//
//  CreateOption
//
//==========================================================================
override MenuChoiceBase CreateOption (MenuScreen menu) {
  auto opt = MenuChoiceEnum(menu.GetItemContainer().NewChild(MenuChoiceEnum));
  opt.SetText(title);
  if (textColor != CR_UNDEFINED) opt.TextColor = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColorFocus = textColorFocus;
  if (isSF2Selector) {
    int count = SF2_GetCount();
    if (count < 1) {
      opt.AddItem("<DEFAULT>", -1);
    } else {
      float vv = 0;
      string sf2fn = GetCvarS('snd_sf2_file');
      foreach (int idx; 0..count) {
        if (SF2_GetName(idx).strEqu(sf2fn)) {
          //printdebug("found soundfound #%s (%s)", idx, sf2fn);
          vv = idx;
        } else {
          //printdebug("...soundfound #%s (%s)", idx, SF2_GetName(idx));
        }
        opt.AddItem(SF2_GetShortName(idx), idx);
      }
      opt.SetInitialValue(vv);
      if (cvar) {
        if (!CvarExists(cvar)) {
          CreateCvarFloat(cvar, vv, "___saved_menu__value___", 0);
        } else {
          SetCvarF(cvar, vv);
        }
      }
      //printdebug("<<%s>>", cvar);
    }
    opt.ValueChanging = delegate bool (Object Sender, float NewValue) {
      int val = cast(int)NewValue;
      if (NewValue < 0) return false;
      int count = SF2_GetCount();
      if (NewValue >= count) return false;
      int oldval = cast(int)(MenuChoiceEnum(Sender).Value);

      //printdebug("oldval=%s; newval=%s", oldval, val);

      // save current preset
      string s;
      /*if (val != oldval)*/ {
        s ~= va("// %s\n", SF2_GetShortName(oldval));
        s ~= va("version = 1;\n"); // version
        s ~= va("snd_fluid_interp = %s;\n", GetCvarI('snd_fluid_interp'));
        s ~= va("snd_fluid_voices = %s;\n", GetCvarI('snd_fluid_voices'));
        s ~= va("snd_fluid_gain = %s;\n", GetCvarF('snd_fluid_gain'));
        s ~= va("snd_fluid_reverb = %s;\n", GetCvarI('snd_fluid_reverb'));
        s ~= va("snd_fluid_reverb_roomsize = %s;\n", GetCvarF('snd_fluid_reverb_roomsize'));
        s ~= va("snd_fluid_reverb_damping = %s;\n", GetCvarF('snd_fluid_reverb_damping'));
        s ~= va("snd_fluid_reverb_width = %s;\n", GetCvarF('snd_fluid_reverb_width'));
        s ~= va("snd_fluid_reverb_level = %s;\n", GetCvarF('snd_fluid_reverb_level'));
        s ~= va("snd_fluid_chorus = %s;\n", GetCvarI('snd_fluid_chorus'));
        s ~= va("snd_fluid_chorus_type = %s;\n", GetCvarI('snd_fluid_chorus_type'));
        s ~= va("snd_fluid_chorus_voices = %s;\n", GetCvarI('snd_fluid_chorus_voices'));
        s ~= va("snd_fluid_chorus_level = %s;\n", GetCvarF('snd_fluid_chorus_level'));
        s ~= va("snd_fluid_chorus_speed = %s;\n", GetCvarF('snd_fluid_chorus_speed'));
        s ~= va("snd_fluid_chorus_depth = %s;\n", GetCvarF('snd_fluid_chorus_depth'));
        //printdebug("OLD HASH: <%s>", SF2_GetHash(oldval));
        //printdebug("NEW HASH: <%s>", SF2_GetHash(val));
        FS_WriteFileContents(va("sf2_preset_%s.rc", SF2_GetHash(oldval)), s);
      }

      // load new preset
      s = FS_ReadFileContents(va("sf2_preset_%s.rc", SF2_GetHash(val)));
      if (s) {
        auto par = SpawnObject(ScriptsParser);
        scope(exit) delete par;
        par.OpenString('sf2preset', s);
        par.SetCMode(true);
        par.SetEscape(true);
        if (par.Check("version") && par.Check("=") && par.Check("1") && par.Check(";")) {
          while (par.GetString()) {
            string vname = par.String;
            if (!par.Check("=")) break;
            if (!par.GetString()) break;
            string vval = par.String;
            if (!par.Check(";")) break;
            //printdebug("PRESET: <%s>=<%s>", vname, vval);
            if (vname.strEquCI("snd_fluid_interp") ||
                vname.strEquCI("snd_fluid_voices") ||
                vname.strEquCI("snd_fluid_reverb") ||
                vname.strEquCI("snd_fluid_chorus") ||
                vname.strEquCI("snd_fluid_chorus_type") ||
                vname.strEquCI("snd_fluid_chorus_voices"))
            {
              int v = atoi(vval);
              //printdebug("  INT VAR! v=%s", v);
              SetCvarI(cast(name)vname, v);
              continue;
            }
            if (vname.strEquCI("snd_fluid_gain") ||
                vname.strEquCI("snd_fluid_reverb_roomsize") ||
                vname.strEquCI("snd_fluid_reverb_damping") ||
                vname.strEquCI("snd_fluid_reverb_width") ||
                vname.strEquCI("snd_fluid_reverb_level") ||
                vname.strEquCI("snd_fluid_chorus_level") ||
                vname.strEquCI("snd_fluid_chorus_speed") ||
                vname.strEquCI("snd_fluid_chorus_depth"))
            {
              float v = atof(vval);
              if (v.isFinite) {
                //printdebug("  FLOAT VAR! v=%s", v);
                SetCvarF(cast(name)vname, v);
              }
              continue;
            }
          }
        }
      }

      //printdebug("NEW SOUNDFONT: <%s>", SF2_GetName(val));
      SetCvarS('snd_sf2_file', SF2_GetName(val));

      return true;
    };
  } else {
    foreach (ref auto s; list) opt.AddItem(s.caption, s.value);
  }
  if (cvar) opt.SetSessionCvar(cvar);
  return opt;
}



//**************************************************************************
//
// MenuDefOptionRenderType
//
//**************************************************************************
class MenuDefOptionRenderType : MenuDefOptionBase;

//==========================================================================
//
//  parseOne
//
//==========================================================================
override bool parseOne (ScriptsParser par) {
  if (::parseOne(par)) return true;
  return false;
}


//==========================================================================
//
//  CreateOption
//
//==========================================================================
override MenuChoiceBase CreateOption (MenuScreen menu) {
  // if we have only one renderer available, there's no need to choose anything
  if (!R_SupportsShadowVolumeRendering() && !R_SupportsShadowMapRendering()) return none;
  auto opt = MenuChoiceEnum(menu.GetItemContainer().NewChild(MenuChoiceEnum));
  opt.SetText(title);
  if (textColor != CR_UNDEFINED) opt.TextColor = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColorFocus = textColorFocus;
  opt.AddItem("Select automatically", 0);
  opt.AddItem("Lightmaps (Quake-style)", 1);
  string nn;
       if (R_SupportsShadowVolumeRendering() && R_SupportsShadowMapRendering()) nn = "D3 Shadows / Shadowmaps";
  else if (R_SupportsShadowVolumeRendering()) nn = "Stencil Shadows (D3-style)";
  else nn = "Shadowmaps";
  opt.AddItem(nn, 2);
  if (cvar) opt.SetSessionCvar(cvar);
  return opt;
}



//**************************************************************************
//
// MenuDefOptionSlider
//
//**************************************************************************
class MenuDefOptionSlider : MenuDefOptionBase;

float step = 0.1;
float minv = 0.0;
float maxv = 1.0;
name maxcvar;


//==========================================================================
//
//  parseOne
//
//==========================================================================
override bool parseOne (ScriptsParser par) {
  if (::parseOne(par)) return true;

  if (par.Check("step")) {
    par.Expect("=");
    par.ExpectFloat();
    step = par.Float;
    par.Expect(";");
    return true;
  }

  if (par.Check("min")) {
    par.Expect("=");
    par.ExpectFloat(withSign:true);
    minv = par.Float;
    par.Expect(";");
    return true;
  }

  if (par.Check("max")) {
    par.Expect("=");
    if (par.Check("[")) {
      par.ExpectIdentifier();
      maxcvar = name(par.String);
      par.Expect("]");
      //writeln("MAXCVAR: <", maxcvar, ">");
    } else {
      par.ExpectFloat(withSign:true);
      maxv = par.Float;
      maxcvar = '';
    }
    par.Expect(";");
    return true;
  }

  return false;
}


//==========================================================================
//
//  CreateOption
//
//==========================================================================
override MenuChoiceBase CreateOption (MenuScreen menu) {
  auto opt = MenuChoiceSlider(menu.GetItemContainer().NewChild(MenuChoiceSlider));
  opt.SetText(title);
  if (textColor != CR_UNDEFINED) opt.TextColor = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColorFocus = textColorFocus;
  opt.ValueDelta = step;
  opt.MinValue = minv;
  if (maxcvar) opt.MaxValue = GetCvarF(maxcvar); else opt.MaxValue = maxv;
  if (cvar) opt.SetSessionCvar(cvar);
  return opt;
}



//**************************************************************************
//
// MenuDefOptionNumeric
//
//**************************************************************************
class MenuDefOptionNumeric : MenuDefOptionSlider;

//==========================================================================
//
//  CreateOption
//
//==========================================================================
override MenuChoiceBase CreateOption (MenuScreen menu) {
  auto opt = MenuChoiceNumeric(menu.GetItemContainer().NewChild(MenuChoiceNumeric));
  opt.SetText(title);
  if (textColor != CR_UNDEFINED) opt.TextColor = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColorFocus = textColorFocus;
  opt.ValueDelta = step;
  opt.MinValue = minv;
  if (maxcvar) opt.MaxValue = GetCvarF(maxcvar); else opt.MaxValue = maxv;
  if (cvar) opt.SetSessionCvar(cvar);
  //writeln("maxcvar=<", maxcvar, ">: ", opt.MaxValue);
  return opt;
}



//**************************************************************************
//
// MenuDefOptionSubMenu
//
//**************************************************************************
class MenuDefOptionSubMenu : MenuDefOptionBase;

class!MenuScreen smclass;
string subname;
bool gzPostFilter; // this is gz "OptionsMenu" submenu, postfilter it


//==========================================================================
//
//  parseOne
//
//==========================================================================
override bool parseOne (ScriptsParser par) {
  if (::parseOne(par)) return true;

  // temporary
  if (par.Check("smclass")) {
    par.Expect("=");
    par.ExpectIdentifier();
    smclass = class!MenuScreen(FindClass(name(par.String)));
    if (!smclass) par.ScriptError("invalid submenu class '%s'", par.String);
    par.Expect(";");
    subname = "";
    return true;
  }

  if (par.Check("submenu")) {
    par.Expect("=");
    par.ExpectString();
    subname = par.String;
    if (!subname) par.ScriptError("invalid submenu class '%s'", par.String);
    par.Expect(";");
    smclass = none;
    return true;
  }

  return false;
}


//==========================================================================
//
//  CreateOption
//
//==========================================================================
override MenuChoiceBase CreateOption (MenuScreen menu) {
  if (!smclass && !subname) return none;
  auto opt = MenuTextButton(menu.GetItemContainer().NewChild(MenuSmallTextButton));
  opt.SetText(title);
  if (textColor != CR_UNDEFINED) opt.TextColor = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColorFocus = textColorFocus;
  if (smclass) opt.SetSubMenuClass(smclass); else opt.SetSubMenuName(subname);
  return opt;
}



//**************************************************************************
//
// MenuDefOptionSubMenuBig
//
//**************************************************************************
class MenuDefOptionSubMenuBig : MenuDefOptionSubMenu;

//==========================================================================
//
//  CreateOption
//
//==========================================================================
override MenuChoiceBase CreateOption (MenuScreen menu) {
  if (!smclass && !subname) return none;
  auto opt = MenuTextButton(menu.GetItemContainer().NewChild(MenuBigTextButton));
  opt.SetText(title);
  if (textColor != CR_UNDEFINED) opt.TextColor = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColorFocus = textColorFocus;
  if (smclass) opt.SetSubMenuClass(smclass); else opt.SetSubMenuName(subname);
  return opt;
}



//**************************************************************************
//
// MenuDefOptionControls
//
//**************************************************************************
class MenuDefOptionControls : MenuDefOptionBase;

//==========================================================================
//
//  CreateOption
//
//==========================================================================
override MenuChoiceBase CreateOption (MenuScreen menu) {
  // add "Special Controls" for MODs if keyconf lump is present,
  // and it has an "addkeysection" command
  bool found = false;
  if (WadLumpPresent('keyconf')) {
    ScriptsParser kc = ScriptsParser(SpawnObject(ScriptsParser));
    scope(exit) delete kc;
    kc.OpenLumpName('keyconf');
    // lump is present, scan it until we find an 'addkeysection'
    while (!kc.AtEnd()) {
      if (kc.Check("addkeysection")) {
        kc.ExpectString();
        kc.ExpectString();
        found = true;
      }
      kc.GetString();
    }
  }
  if (!found) return none;

  // surely a MOD that contains KEYCONF bindings,
  // so we'll show the special controls option
  //CreateSubMenuText("Special Controls", MenuScreenSpecialControls);
  auto opt = MenuTextButton(menu.GetItemContainer().NewChild(MenuSmallTextButton));
  opt.SetText(title);
  opt.SetSubMenuClass(MenuScreenSpecialControls);
  if (textColor != CR_UNDEFINED) opt.TextColor = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColorFocus = textColorFocus;
  return opt;
}



//**************************************************************************
//
// MenuDefOptionConsole
//
//**************************************************************************
class MenuDefOptionConsole : MenuDefOptionBase;

//==========================================================================
//
//  CreateOption
//
//==========================================================================
override MenuChoiceBase CreateOption (MenuScreen menu) {
  auto opt = MenuTextButton(menu.GetItemContainer().NewChild(MenuSmallTextButton));
  opt.SetText(title);
  if (textColor != CR_UNDEFINED) opt.TextColor = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColorFocus = textColorFocus;
  opt.Activated = delegate void (Object Sender) { CmdBuf_AddText("ToggleConsole\n"); };
  return opt;
}



//**************************************************************************
//
// MenuDefOptionConCmd
//
//**************************************************************************
class MenuDefOptionConCmd : MenuDefOptionBase;

string concmd;


//==========================================================================
//
//  parseOne
//
//==========================================================================
override bool parseOne (ScriptsParser par) {
  if (::parseOne(par)) return true;

  if (par.Check("concmd")) {
    par.Expect("=");
    par.ExpectString();
    concmd = par.String;
    par.Expect(";");
    return true;
  }

  return false;
}


//==========================================================================
//
//  CreateOption
//
//==========================================================================
override MenuChoiceBase CreateOption (MenuScreen menu) {
  auto opt = MenuTextButton(menu.GetItemContainer().NewChild(MenuSmallTextButton));
  opt.SetText(title);
  opt.concmd = concmd;
  if (textColor != CR_UNDEFINED) opt.TextColor = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColorFocus = textColorFocus;
  opt.Activated = delegate void (Object Sender) {
    auto btn = MenuTextButton(Sender);
    if (btn && btn.concmd) {
      CmdBuf_AddText("%s\n", btn.concmd);
    }
  };
  return opt;
}



//**************************************************************************
//
// MenuDefOptionCrosshair
//
//**************************************************************************
class MenuDefOptionCrosshair : MenuDefOptionBase;

//==========================================================================
//
//  CreateOption
//
//==========================================================================
override MenuChoiceBase CreateOption (MenuScreen menu) {
  auto opt = MenuCrosshairChoice(menu.GetItemContainer().NewChild(MenuCrosshairChoice));
  opt.SetText(title);
  opt.cvar = cvar;
  if (textColor != CR_UNDEFINED) opt.TextColor = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColorFocus = textColorFocus;
  return opt;
}



//**************************************************************************
//
// MenuDefOptionBind
//
//**************************************************************************
class MenuDefOptionBind : MenuDefOptionBase;

bool button; // commandOn prepends with "+" and "-"
string commandOn;
string commandOff;

int strifeMode; // 0: don't care; -1: disabled in Strife; 1: enabled in Strife; -669: automap
/*
  option bind {
    title = "Show Weapons";
    button = ona;
    commandOn = "sb_show_weapons 1";
    commandOff = "sb_show_weapons 0";
    Strife = tan; // only for Strife
  }
*/

//==========================================================================
//
//  parseOne
//
//==========================================================================
override bool parseOne (ScriptsParser par) {
  if (::parseOne(par)) return true;

  if (par.Check("button")) {
    par.Expect("=");
    par.ExpectIdentifier();
    button = MenuDefinition.str2bool(par.String);
    par.Expect(";");
    return true;
  }

  if (par.Check("Strife")) {
    par.Expect("=");
    par.ExpectIdentifier();
    strifeMode = (MenuDefinition.str2bool(par.String) ? 1 : -1);
    par.Expect(";");
    return true;
  }

  if (par.Check("automap")) {
    par.Expect("=");
    par.ExpectIdentifier();
    if (MenuDefinition.str2bool(par.String)) strifeMode = -669;
    par.Expect(";");
    return true;
  }

  if (par.Check("command")) {
    par.Expect("=");
    par.ExpectString();
    commandOn = par.String;
    commandOff = "";
    par.Expect(";");
    return true;
  }

  if (par.Check("commandOn")) {
    par.Expect("=");
    par.ExpectString();
    commandOn = par.String;
    par.Expect(";");
    return true;
  }

  if (par.Check("commandOff")) {
    par.Expect("=");
    par.ExpectString();
    commandOff = par.String;
    par.Expect(";");
    return true;
  }

  return false;
}


//==========================================================================
//
//  CreateOption
//
//==========================================================================
override MenuChoiceBase CreateOption (MenuScreen menu) {
  auto newCtl = MenuControlKey(menu.GetItemContainer().NewChild(MenuControlKey));
  newCtl.Height = 10;
  newCtl.SetText(title);
  if (button) {
    newCtl.CommandOn = va("+%s", commandOn);
    newCtl.CommandOff = va("-%s", commandOn);
  } else {
    newCtl.CommandOn = commandOn;
    newCtl.CommandOff = commandOff;
  }
  newCtl.strifeMode = strifeMode;
  if (strifeMode != -669) {
         if (strifeMode < 0) newCtl.Disabled = IsStrife;
    else if (strifeMode > 0) newCtl.Disabled = !IsStrife;
  }
  return newCtl;
}


//**************************************************************************
//
// MenuDefOptionColor
//
//**************************************************************************
class MenuDefOptionColor : MenuDefOptionBase;

bool AllowDefaultColor;


//==========================================================================
//
//  parseOne
//
//==========================================================================
override bool parseOne (ScriptsParser par) {
  if (::parseOne(par)) return true;

  if (par.Check("allowdefault")) {
    par.Expect("=");
    par.ExpectString();
    if (par.String.strEquCI("true") ||
        par.String.strEquCI("tan"))
    {
      AllowDefaultColor = true;
    } else if (par.String.strEquCI("false") ||
               par.String.strEquCI("ona"))
    {
      AllowDefaultColor = false;
    } else {
      par.Error("boolean value expected");
    }
    par.Expect(";");
    return true;
  }

  return false;
}


//==========================================================================
//
//  CreateOption
//
//==========================================================================
override MenuChoiceBase CreateOption (MenuScreen menu) {
  auto opt = menu.GetItemContainer().NewChild(MenuChoiceColor);
  opt.SetText(title);
  if (textColor != CR_UNDEFINED) opt.TextColor = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColorFocus = textColorFocus;
  if (cvar) opt.SetSessionColorCvar(cvar);
  opt.AllowDefaultColor = AllowDefaultColor;
  return opt;
}
