//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
// ////////////////////////////////////////////////////////////////////////// //
class MenuDefConditionBase : Object;

string cond;
name cvar;
float fval;
string sval;
bool isfloat;


bool test () {
  if (!cvar || !CvarExists(cvar)) return false;
  if (isfloat) {
    float var = GetCvarF(cvar);
    if (cond == "=" || cond == "==") return (var == fval);
    if (cond == "!=" || cond == "<>") return (var != fval);
    if (cond == "<") return (var < fval);
    if (cond == "<=") return (var <= fval);
    if (cond == ">") return (var > fval);
    if (cond == ">=") return (var >= fval);
  } else {
    string var = GetCvarS(cvar);
    if (cond == "=" || cond == "==") return (var == sval);
    if (cond == "!=" || cond == "<>") return (var != sval);
    if (cond == "<") return (var < sval);
    if (cond == "<=") return (var <= sval);
    if (cond == ">") return (var > sval);
    if (cond == ">=") return (var >= sval);
  }
  return false;
}


// '[' eaten
void parse (ScriptsParser par) {
  par.ExpectIdentifier();
  cvar = name(par.String);
       if (par.Check("=") || par.Check("==")) cond = "==";
  else if (par.Check("!=")) cond = "!=";
  else if (par.Check("<")) cond = "<";
  else if (par.Check("<=")) cond = "<=";
  else if (par.Check(">")) cond = ">";
  else if (par.Check(">=")) cond = ">=";
  else par.ScriptError("invalid condition '%s'", par.String);
  if (par.CheckFloat(withSign:true)) {
    fval = par.Float;
    isfloat = true;
  } else {
    sval = par.String;
    isfloat = false;
  }
  par.Expect("]");
}


// ////////////////////////////////////////////////////////////////////////// //
class MenuDefinition : Object;

name menuName;
name seltype = 'MenuSelector_SmallRight';
string title;
//bool extension; // true: extend `menuName`

array!MenuDefOptionBase options;


/*
static final string readText (string fname) {
  auto fl = TextReader.Open(fname);
  if (!fl) return "";
  scope(exit) delete fl;
  if (fl.size > 1024*1024) return "" ;
  return fl.readBuf(fl.size, exact:true);
}
*/


static final ScriptsParser openParser (string fname) {
  auto par = SpawnObject(ScriptsParser);
  //par.OpenString('menudef', readText(fname));
  par.OpenLumpFullName(fname);
  par.SetCMode(true);
  par.SetEscape(true);
  return par;
}


void filterOptions (int stidx) {
  if (stidx < 0) stidx = 0;
  while (stidx < options.length) {
    if (options[stidx] !isa MenuDefOptionSubHeader) { ++stidx; continue; }
    if (stidx > 0 && options[stidx-1] isa MenuDefOptionSubHeader && !options[stidx-1].title) {
      delete options[stidx-1];
      options.remove(stidx-1);
      --stidx;
    } else {
      ++stidx;
    }
  }
}


// "menudef" eaten
void parse (ScriptsParser par) {
  par.ExpectIdentifier();
  menuName = name(par.String);
  par.Expect("{");
  while (!par.Check("}")) {
    if (par.Check("selector")) {
      par.Expect("=");
      par.ExpectIdentifier();
      seltype = name(par.String);
      par.Expect(";");
      continue;
    }

    if (par.Check("title")) {
      par.Expect("=");
      par.ExpectString();
      title = par.String;
      par.Expect(";");
      continue;
    }

    if (par.Check("option")) {
      auto opt = MenuDefOptionBase.parse(par);
      if (opt) options[$] = opt;
      continue;
    }

    if (par.Check("header")) {
      auto hdr = SpawnObject(MenuDefOptionSubHeader);
      if (par.Check("{")) {
        while (!par.Check("}")) {
          if (!hdr.parseOne(par)) par.ScriptError("invalid menudef command '%s'", par.String);
        }
      } else {
        par.ExpectString();
        string title = par.String;
        par.Expect(";");
        hdr.title = title;
      }
      options[$] = hdr;
      continue;
    }

    par.ScriptError("invalid menudef command '%s'", par.String);
  }
}


// ////////////////////////////////////////////////////////////////////////// //
class MenuDefOptionBase : Object;

MenuDefConditionBase cond;
string title;
name cvar;
string help;
int textColor = CR_UNDEFINED;
int textColorFocus = CR_UNDEFINED;


override void Destroy () {
  delete cond;
  ::Destroy();
}


MenuChoice CreateOption (MenuScreen menu) {
  return none;
}


bool test () {
  if (!cond) return true;
  return cond.test();
}


final static int parseTextColorName (ScriptsParser par) {
       if (par.Check("undefined") || par.Check("default")) return CR_UNDEFINED;
  else if (par.Check("brick")) return CR_BRICK;
  else if (par.Check("tan")) return CR_TAN;
  else if (par.Check("gray") || par.Check("grey")) return CR_GRAY;
  else if (par.Check("green")) return CR_GREEN;
  else if (par.Check("brown")) return CR_BROWN;
  else if (par.Check("gold")) return CR_GOLD;
  else if (par.Check("red")) return CR_RED;
  else if (par.Check("blue")) return CR_BLUE;
  else if (par.Check("orange")) return CR_ORANGE;
  else if (par.Check("white")) return CR_WHITE;
  else if (par.Check("yellow")) return CR_YELLOW;
  else if (par.Check("untranslated")) return CR_UNTRANSLATED;
  else if (par.Check("black")) return CR_BLACK;
  else if (par.Check("lightblue")) return CR_LIGHTBLUE;
  else if (par.Check("cream")) return CR_CREAM;
  else if (par.Check("olive")) return CR_OLIVE;
  else if (par.Check("darkgreen")) return CR_DARKGREEN;
  else if (par.Check("darkred")) return CR_DARKRED;
  else if (par.Check("darkbrown")) return CR_DARKBROWN;
  else if (par.Check("purple")) return CR_PURPLE;
  else if (par.Check("darkgray") || par.Check("darkgrey")) return CR_DARKGRAY;
  else par.ScriptError("invalid color name '%s'", par.String);
  return CR_UNDEFINED;
}


// "option" skipped
final static MenuDefOptionBase parse (ScriptsParser par) {
  MenuDefOptionBase res;
  par.SetCMode(true);
  par.SetEscape(true);
       if (par.Check("bool")) res = SpawnObject(MenuDefOptionBool);
  else if (par.Check("enum")) res = SpawnObject(MenuDefOptionEnum);
  else if (par.Check("slider")) res = SpawnObject(MenuDefOptionSlider);
  else if (par.Check("numeric")) res = SpawnObject(MenuDefOptionNumeric);
  else if (par.Check("submenu")) res = SpawnObject(MenuDefOptionSubMenu);
  else if (par.Check("submenubig") || par.Check("submenu_big")) res = SpawnObject(MenuDefOptionSubMenuBig);
  else if (par.Check("mod_controls")) res = SpawnObject(MenuDefOptionControls);
  else if (par.Check("console")) res = SpawnObject(MenuDefOptionConsole);
  else par.ScriptError("invalid option type '%s'", par.String);
  // condition?
  if (par.Check("[")) {
    res.cond = SpawnObject(MenuDefConditionBase);
    res.cond.parse(par);
  }
  par.Expect("{");
  while (!par.Check("}")) {
    if (par.Check(";")) continue;
    if (!res.parseOne(par)) par.ScriptError("invalid menu definition keyword '%s'", par.String);
  }
  return res;
}


// parse GZDoom-style menudef
final static MenuDefOptionBase parseGZ (ScriptsParser par, ref array!(ClientGameShared::OptionValue) ovals) {
  par.SetCMode(true);
  par.SetEscape(true);

  if (par.Check("StaticText")) {
    par.ExpectString();
    auto opt = SpawnObject(MenuDefOptionSubHeader);
    opt.title = par.String;
    while (opt.title && opt.title[$-1] <= 32) opt.title = opt.title[0..$-1];
    if (par.Check(",")) {
      // dunno, probably color or something
      par.GetString();
    }
    return opt;
  }

  if (par.Check("Submenu")) {
    // title
    par.ExpectString();
    string title = par.String;
    par.Expect(",");
    // submenu name
    par.ExpectString();
    string subname = par.String;
    //if (stricmp(subname, "OptionsMenu") == 0) subname = "Options";
    auto opt = SpawnObject(MenuDefOptionSubMenu);
    opt.title = title;
    opt.subname = subname;
    return opt;
  }

  //option "'Marine Helmet' Armor Bonus", "botoggle", "onoff"  [, "cvar-enable-check" [, Center]]
  if (par.Check("option")) {
    // title
    par.ExpectString();
    string title = par.String;
    par.Expect(",");
    // cvar
    par.ExpectString();
    name cvar = name(par.String);
    par.Expect(",");
    // type
    if (par.Check("onoff") || par.Check("yesno")) {
      auto opt = SpawnObject(MenuDefOptionBool);
      opt.title = title;
      opt.cvar = cvar;
      return opt;
    }
    // this should be "OptionValue"
    par.ExpectString();
    foreach (ref auto oval; ovals) {
      if (stricmp(oval.Name, par.String) == 0) {
        // i found her!
        if (par.Check(",")) par.ExpectString(); // cvar-enable
        if (par.Check(",")) par.ExpectString(); // center
        auto opt = SpawnObject(MenuDefOptionEnum);
        opt.title = title;
        opt.cvar = cvar;
        foreach (ref auto v; oval.list) {
          opt.list.length += 1;
          opt.list[$-1].caption = v.caption;
          opt.list[$-1].value = v.value;
        }
        return opt;
      }
    }
    //par.ScriptError("unknown GZDoom MenuDef OptionValue '%s'", par.String);
    print("MENUDEF: unknown GZDoom MenuDef OptionValue '%s'", par.String);
    return none;
  }

  //Slider "<label>", "<CVAR>", <minimum>, <maximum>, <inc> [, decimal places]
  if (par.Check("Slider")) {
    // title
    par.ExpectString();
    string title = par.String;
    par.Expect(",");
    // cvar
    par.ExpectString();
    name cvar = name(par.String);
    par.Expect(",");
    // min, max, step
    par.ExpectFloat(withSign:true);
    float minv = par.Float;
    par.Expect(",");
    par.ExpectFloat(withSign:true);
    float maxv = par.Float;
    par.Expect(",");
    par.ExpectFloat(withSign:false);
    float step = par.Float;
    // skip decimals
    if (par.Check(",")) par.ExpectNumber();
    auto res = SpawnObject(MenuDefOptionSlider);
    res.title = title;
    res.step = step;
    res.minv = minv;
    res.maxv = maxv;
    res.cvar = cvar;
    return res;
  }

  //NumberField "<label>", "<CVAR>", <minimum>, <maximum>, <inc> [, decimal places]
  if (par.Check("NumberField")) {
    // title
    par.ExpectString();
    string title = par.String;
    par.Expect(",");
    // cvar
    par.ExpectString();
    name cvar = name(par.String);
    float minv = 0;
    float maxv = 100;
    float step = 1;
    if (par.Check(",")) {
      par.ExpectFloat(withSign:true);
      minv = par.Float;
      if (par.Check(",")) {
        par.ExpectFloat(withSign:true);
        maxv = par.Float;
        if (par.Check(",")) {
          par.ExpectFloat(withSign:false);
          step = par.Float;
          // skip decimals
          if (par.Check(",")) par.ExpectNumber();
        }
      }
    }
    auto res = SpawnObject(MenuDefOptionNumeric);
    res.title = title;
    res.step = step;
    res.minv = minv;
    res.maxv = maxv;
    res.cvar = cvar;
    return res;
  }

  if (par.Check("Position")) {
    print("MENUDEF: skipped gz command '%s'", par.String);
    par.ExpectNumber(withSign:true);
    return none;
  }

  par.ScriptError("invalid gz command '%s'", par.String);
  return none;
}


bool parseOne (ScriptsParser par) {
  if (par.Check("title")) {
    par.Expect("=");
    par.ExpectString();
    title = par.String;
    par.Expect(";");
    //writeln("TITLE: <", title, ">");
    return true;
  }

  if (par.Check("cvar")) {
    par.Expect("=");
    par.ExpectIdentifier();
    cvar = name(par.String);
    par.Expect(";");
    return true;
  }

  if (par.Check("help")) {
    par.Expect("=");
    while (!par.Check(";")) {
      par.ExpectString();
      if (help) help ~= "\n";
      help ~= par.String;
    }
    return true;
  }

  if (par.Check("textcolor") || par.Check("text_color")) {
    par.Expect("=");
    textColor = parseTextColorName(par);
    par.Expect(";");
    return true;
  }

  if (par.Check("focuscolor") || par.Check("focus_color")) {
    par.Expect("=");
    textColorFocus = parseTextColorName(par);
    par.Expect(";");
    return true;
  }

  return false;
}


// ////////////////////////////////////////////////////////////////////////// //
class MenuDefOptionSubHeader : MenuDefOptionBase;

override MenuChoice CreateOption (MenuScreen menu) {
  auto opt = MenuSmallTextButton(menu.NewChild(MenuSmallTextButton));
  opt.TextHAlign = hcenter;
  opt.TextVAlign = vbottom;
  opt.Text = title;
  opt.Focusable = false;
  if (textColor != CR_UNDEFINED) opt.TextColour = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColourFocus = textColorFocus;
  opt.Height = (title ? 12 : 10);
  return opt;
}


defaultproperties {
  textColor = CR_ORANGE;
  textColorFocus = CR_ORANGE;
}


// ////////////////////////////////////////////////////////////////////////// //
class MenuDefOptionBool : MenuDefOptionBase;

override MenuChoice CreateOption (MenuScreen menu) {
  auto opt = MenuChoice_OnOff(menu.NewChild(MenuChoice_OnOff));
  opt.Text = title;
  if (textColor != CR_UNDEFINED) opt.TextNormalColor = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextFocusedColor = textColorFocus;
  if (cvar) opt.SetSessionCvar(cvar);
  return opt;
}


// ////////////////////////////////////////////////////////////////////////// //
class MenuDefOptionEnum : MenuDefOptionBase;

array!(ClientGameShared::OptionValueDef) list;


override bool parseOne (ScriptsParser par) {
  if (::parseOne(par)) return true;

  if (par.Check("list")) {
    par.Expect("{");
    int val = 0;
    while (!par.Check("}")) {
      par.ExpectString();
      list.length += 1;
      list[$-1].caption = par.String;
      list[$-1].value = float(val++);
      while (par.Check(",")) {}
    }
    return true;
  }

  return false;
}


override MenuChoice CreateOption (MenuScreen menu) {
  auto opt = MenuChoiceEnum(menu.NewChild(MenuChoiceEnum));
  opt.Text = title;
  if (textColor != CR_UNDEFINED) opt.TextColour = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColourFocus = textColorFocus;
  foreach (ref auto s; list) opt.AddItem(s.caption, s.value);
  if (cvar) opt.SetSessionCvar(cvar);
  return opt;
}


// ////////////////////////////////////////////////////////////////////////// //
class MenuDefOptionSlider : MenuDefOptionBase;

float step = 0.1;
float minv = 0.0;
float maxv = 1.0;
name maxcvar;


override bool parseOne (ScriptsParser par) {
  if (::parseOne(par)) return true;

  if (par.Check("step")) {
    par.Expect("=");
    par.ExpectFloat();
    step = par.Float;
    par.Expect(";");
    return true;
  }

  if (par.Check("min")) {
    par.Expect("=");
    par.ExpectFloat(withSign:true);
    minv = par.Float;
    par.Expect(";");
    return true;
  }

  if (par.Check("max")) {
    par.Expect("=");
    if (par.Check("[")) {
      par.ExpectIdentifier();
      maxcvar = name(par.String);
      par.Expect("]");
      //writeln("MAXCVAR: <", maxcvar, ">");
    } else {
      par.ExpectFloat(withSign:true);
      maxv = par.Float;
      maxcvar = '';
    }
    par.Expect(";");
    return true;
  }

  return false;
}


override MenuChoice CreateOption (MenuScreen menu) {
  auto opt = MenuChoiceSlider(menu.NewChild(MenuChoiceSlider));
  opt.Text = title;
  if (textColor != CR_UNDEFINED) opt.TextColour = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColourFocus = textColorFocus;
  opt.ValueDelta = step;
  opt.MinValue = minv;
  if (maxcvar) opt.MaxValue = GetCvarF(maxcvar); else opt.MaxValue = maxv;
  if (cvar) opt.SetSessionCvar(cvar);
  return opt;
}


// ////////////////////////////////////////////////////////////////////////// //
class MenuDefOptionNumeric : MenuDefOptionSlider;

override MenuChoice CreateOption (MenuScreen menu) {
  auto opt = MenuChoiceNumeric(menu.NewChild(MenuChoiceNumeric));
  opt.Text = title;
  if (textColor != CR_UNDEFINED) opt.TextColour = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColourFocus = textColorFocus;
  opt.ValueDelta = step;
  opt.MinValue = minv;
  if (maxcvar) opt.MaxValue = GetCvarF(maxcvar); else opt.MaxValue = maxv;
  if (cvar) opt.SetSessionCvar(cvar);
  //writeln("maxcvar=<", maxcvar, ">: ", opt.MaxValue);
  return opt;
}


// ////////////////////////////////////////////////////////////////////////// //
class MenuDefOptionSubMenu : MenuDefOptionBase;

class!MenuScreen smclass;
string subname;


override bool parseOne (ScriptsParser par) {
  if (::parseOne(par)) return true;

  // temporary
  if (par.Check("smclass")) {
    par.Expect("=");
    par.ExpectIdentifier();
    smclass = class!MenuScreen(FindClass(name(par.String)));
    if (!smclass) par.ScriptError("invalid submenu class '%s'", par.String);
    par.Expect(";");
    subname = "";
    return true;
  }

  if (par.Check("submenu")) {
    par.Expect("=");
    par.ExpectString();
    subname = par.String;
    if (!subname) par.ScriptError("invalid submenu class '%s'", par.String);
    par.Expect(";");
    smclass = none;
    return true;
  }

  return false;
}


override MenuChoice CreateOption (MenuScreen menu) {
  if (!smclass && !subname) return none;
  auto opt = MenuTextButton(menu.NewChild(MenuSmallTextButton));
  opt.Text = title;
  if (textColor != CR_UNDEFINED) opt.TextColour = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColourFocus = textColorFocus;
  if (smclass) opt.SetSubMenuClass(smclass); else opt.SetSubMenuName(subname);
  return opt;
}


// ////////////////////////////////////////////////////////////////////////// //
class MenuDefOptionSubMenuBig : MenuDefOptionSubMenu;


override MenuChoice CreateOption (MenuScreen menu) {
  if (!smclass && !subname) return none;
  auto opt = MenuTextButton(menu.NewChild(MenuBigTextButton));
  opt.Text = title;
  if (textColor != CR_UNDEFINED) opt.TextColour = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColourFocus = textColorFocus;
  if (smclass) opt.SetSubMenuClass(smclass); else opt.SetSubMenuName(subname);
  return opt;
}


// ////////////////////////////////////////////////////////////////////////// //
class MenuDefOptionControls : MenuDefOptionBase;


override MenuChoice CreateOption (MenuScreen menu) {
  // add "Special Controls" for MODs if keyconf lump is present,
  // and it has an "addkeysection" command
  bool found = false;
  if (WadLumpPresent('keyconf')) {
    ScriptsParser kc = ScriptsParser(SpawnObject(ScriptsParser));
    scope(exit) delete kc;
    kc.OpenLumpName('keyconf');
    // lump is present, scan it until we find an 'addkeysection'
    while (!kc.AtEnd()) {
      if (kc.Check("addkeysection")) {
        kc.ExpectString();
        kc.ExpectString();
        found = true;
      }
      kc.GetString();
    }
  }
  if (!found) return none;

  // surely a MOD that contains KEYCONF bindings,
  // so we'll show the special controls option
  //CreateSubMenuText("Special Controls", MenuScreenSpecialControls);
  auto opt = MenuTextButton(menu.NewChild(MenuSmallTextButton));
  opt.Text = title;
  opt.SetSubMenuClass(MenuScreenSpecialControls);
  if (textColor != CR_UNDEFINED) opt.TextColour = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColourFocus = textColorFocus;
  return opt;
}


// ////////////////////////////////////////////////////////////////////////// //
class MenuDefOptionConsole : MenuDefOptionBase;


override MenuChoice CreateOption (MenuScreen menu) {
  auto opt = MenuTextButton(menu.NewChild(MenuSmallTextButton));
  opt.Text = title;
  if (textColor != CR_UNDEFINED) opt.TextColour = textColor;
  if (textColorFocus != CR_UNDEFINED) opt.TextColourFocus = textColorFocus;
  opt.Activated = delegate void (Object Sender) { CmdBuf_AddText("ToggleConsole\n"); };
  return opt;
}
