//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
class MenuScreen : Widget;

ClientGameShared ClGame;

MenuTitleText titleItem;
array!MenuChoice Items;

bool MenuScrollable;
int OfsYPrev;
int CursorPos;
int CursorPrev;

int ChoicesStartX;
int ChoicesStartY;

class!MenuSelectorBase SelectorType;
MenuSelectorBase Selector;

string Title;
int TitleX;
int TitleY;

name ActivateSound;
name DeactivateSound;
name ClearMenusSound;

int currentY;


// ////////////////////////////////////////////////////////////////////////// //
void CreateMenu () {
  CreateTitle();
  DrawBackButton();
  currentY = ChoicesStartY;
  CreateChoices();
  CreateSelector();
  SetDefaultChoice();
}


override void OnChildAdded (Widget Child) {
  if (MenuChoice(Child) && !MenuChoice_BackButton(Child)) {
    if (Items.Num > 128) FatalError("Too many menu items");
    Items[Items.Length] = MenuChoice(Child);
  }
  ::OnChildAdded(Child);
}


void CreateTitle () {
  if (Title) {
    if (!titleItem) titleItem = MenuTitleText(NewChild(MenuTitleText));
    titleItem.Text = Title;
    titleItem.SetOrigin(TitleX, TitleY);
    //titleItem.FixSize();
  }
}


void ChangeTitle (string newtitle) {
  if (!titleItem) return; // no title, cannot insert it now
  if (!newtitle) newtitle = " "; //FIXME
  if (Title == newtitle) return;
  Title = newtitle;
  CreateTitle();
}


void DrawBackButton () {
  // draw the back button on the top left corner of the menu screen
  MenuChoice_BackButton BackButton = MenuChoice_BackButton(NewChild(MenuChoice_BackButton));
  BackButton.SetOrigin(Width-20, 1);
}


void CreateChoices () {
}


// should be called from `CreateChoices()` (and `currentY` must be set)
MenuChoice_OnOff CreateOnOffCvar (string text, name cvname) {
  auto onoff = MenuChoice_OnOff(NewChild(MenuChoice_OnOff));
  onoff.SetOrigin(ChoicesStartX, currentY);
  onoff.Text = text;
  onoff.SetSessionCvar(cvname);
  currentY += onoff.Height;
  return onoff;
}


// should be called from `CreateChoices()` (and `currentY` must be set)
MenuChoiceSlider CreateFloatSliderCvar (string text, name cvname, float delta, optional float min, optional float max) {
  auto slider = MenuChoiceSlider(NewChild(MenuChoiceSlider));
  slider.SetOrigin(ChoicesStartX, currentY);
  slider.Text = text;
  slider.cvarSession = cvname;
  slider.ValueDelta = delta;
  if (specified_min) slider.MinValue = min;
  if (specified_max) slider.MaxValue = max;
  slider.SetSessionCvar(cvname);
  currentY += slider.Height;
  return slider;
}


// should be called from `CreateChoices()` (and `currentY` must be set)
// default color: CR_OLIVE
MenuTextButton CreateChoiceTextLabel (string text, optional int color) {
  auto btn = MenuTextButton(NewChild(MenuSmallTextButton));
  btn.SetOrigin(ChoicesStartX, currentY);
  btn.Text = text;
  btn.Focusable = false;
  if (specified_color) {
    btn.TextColour = color;
    btn.TextColourFocus = color;
  } else {
    btn.TextColour = CR_OLIVE;
    btn.TextColourFocus = CR_OLIVE;
  }
  btn.Height = 10;
  currentY += btn.Height;
  return btn;
}


MenuTextButton CreateSubMenuText (string text, class!MenuScreen asubmenuClass) {
  auto btn = MenuTextButton(NewChild(MenuSmallTextButton));
  btn.SetOrigin(ChoicesStartX, currentY);
  btn.Text = text;
  btn.SetSubMenuClass(asubmenuClass);
  currentY += btn.Height;
  return btn;
}


MenuTextButton CreateSubMenuBigText (string text, class!MenuScreen asubmenuClass) {
  auto btn = MenuTextButton(NewChild(MenuBigTextButton));
  btn.SetOrigin(ChoicesStartX, currentY);
  btn.Text = text;
  btn.SetSubMenuClass(asubmenuClass);
  currentY += btn.Height;
  return btn;
}


void CreateSelector () {
  if (SelectorType) Selector = NewChild(SelectorType);
}


final int CalcTotalHeight () {
  int res = 0;
  for (int n = 0; n < Items.Length; ++n) {
    int e = Items[n].Y+Items[n].Height;
    if (res < e) res = e;
  }
  return res;
}


final int GetItemYS (int idx) {
  if (idx < 0) return 0;
  if (idx >= Items.Length) return CalcTotalHeight();
  return Items[idx].Y;
}


final int GetItemYE (int idx) {
  if (idx < 0) return 0;
  if (idx >= Items.Length) return CalcTotalHeight();
  return Items[idx].Y+Items[idx].Height;
}


final int GetItemYH (int idx) {
  if (idx < 0) return 0;
  if (idx >= Items.Length) return 0;
  return Items[idx].Height;
}


final void FixTopIndex () {
  if (Items.Num == 0) return;
  if (Items.Num == 1) { CursorPos = 0; ChildrenOfsY = 0; return; }
  if (!MenuScrollable) { ChildrenOfsY = 0; return; }
  if (CursorPos < 0) CursorPos = Items.Num-1; else if (CursorPos >= Items.Num) CursorPos = 0;
  int th = CalcTotalHeight();
  int ys = GetItemYS(CursorPos);
  int ye = GetItemYE(CursorPos);
  //print("Menu <%s>; ofs=%d; ys=%d; ye=%d; th=%d; height=%d", NameToStr(GetClassName(Class)), ChildrenOfsY, ys, ye, th, Height);
       if (ys+ChildrenOfsY < ChoicesStartY) ChildrenOfsY = -ys+ChoicesStartY;
  else if (ye+ChildrenOfsY > Height) ChildrenOfsY = -(ye-Height);
}


void CursorMoved () {
  if (Items.Num == 0) return;
  FixTopIndex();
  if ((CursorPrev == CursorPos && ChildrenOfsY == OfsYPrev) || MenuChoice_BackButton(Items[CursorPos])) return;
  if (CursorPos >= 0 && CursorPos < Items.Num) SetCurrentFocusChild(Items[CursorPos]);
  if (Selector) {
    Selector.SetOriginCentered(Items[CursorPos].X+Items[CursorPos].CursorXOffs, Items[CursorPos].Y+Items[CursorPos].CursorYOffs, Items[CursorPos].Height);
  }
  CursorPrev = CursorPos;
  OfsYPrev = ChildrenOfsY;
}


void SetDefaultChoice () {
  // default cursor position
  ChildrenOfsY = 0;
  OfsYPrev = 0;
  CursorPos = 0;
  CursorPrev = 0;

  // force first available item to have focus
  for (int i = 0; i < Items.Num; ++i) {
    if (Items[i].Focusable && Items[i].Enabled && !MenuChoice_BackButton(Items[i])) {
      CursorPrev = -1;
      CursorPos = i;
      CursorMoved();
      break;
    }
  }
}


int GetChoiceForSaving () {
  return (CursorPos+(-ChildrenOfsY)*10000);
}


// should be called after menu is fully created, and default choice set
void SetSavedChoice (int saval) {
  int idx = saval%10000;
  int top = saval/10000;
  if (idx < 0 || idx >= Items.Num || CursorPos == idx) return;
  if (Items[idx].Focusable && Items[idx].Enabled) {
    CursorPrev = -1;
    CursorPos = idx;
    ChildrenOfsY = -top;
    CursorMoved();
  }
}


void CyclePrevChoice () {
  if (Items.Num < 2) return;
  CursorPrev = CursorPos;
  do {
    if (!CursorPos) CursorPos = Items.Num-1; else --CursorPos;
  } while ((!Items[CursorPos].Focusable || !Items[CursorPos].Enabled) && !MenuChoice_BackButton(Items[CursorPos]) && CursorPrev != CursorPos);
  CursorMoved();
}


void CycleNextChoice () {
  if (Items.Num < 2) return;
  CursorPrev = CursorPos;
  do {
    if (CursorPos == Items.Num - 1) CursorPos = 0; else ++CursorPos;
  } while ((!Items[CursorPos].Focusable || !Items[CursorPos].Enabled) && !MenuChoice_BackButton(Items[CursorPos]) && CursorPrev != CursorPos);
  CursorMoved();
}


void DoHome () {
  if (Items.Num < 2) return;
  CursorPrev = CursorPos;
  for (CursorPos = 0; CursorPos < Items.Length; ++CursorPos) {
    if (Items[CursorPos].Focusable && Items[CursorPos].Enabled && !MenuChoice_BackButton(Items[CursorPos])) break;
  }
  CursorMoved();
}


void DoEnd () {
  if (Items.Num < 2) return;
  CursorPrev = CursorPos;
  for (CursorPos = Items.Length-1; CursorPos >= 0; --CursorPos) {
    if (Items[CursorPos].Focusable && Items[CursorPos].Enabled && !MenuChoice_BackButton(Items[CursorPos])) break;
  }
  CursorMoved();
}


override bool OnKeyDown (int key) {
  switch (key) {
    case K_UPARROW:
    case K_PAD8:
    case K_MWHEELUP:
      if (Items.Num > 1) {
        CyclePrevChoice();
        LocalSound('menu/cursor');
      }
      return true;

    case K_DOWNARROW:
    case K_PAD2:
    case K_MWHEELDOWN:
      if (Items.Num > 1) {
        CycleNextChoice();
        LocalSound('menu/cursor');
      }
      return true;

    case K_HOME:
    case K_PAD7:
      if (Items.Num > 1) {
        DoHome();
        LocalSound('menu/cursor');
      }
      return true;

    case K_END:
    case K_PAD1:
      if (Items.Num > 1) {
        DoEnd();
        LocalSound('menu/cursor');
      }
      return true;

    case K_ESCAPE:
    case K_MOUSE2:
      ClGame.PopMenu();
      return true;
  }
  return false;
}


// fade all the screen buffer, so that the menu is more readable,
// especially now that we use the small hudfont in the menus
override void OnDraw () {
  ShadeRect(0, 0, 640, 480, GetCvarF('menu_darkening'));
}


defaultproperties {
  X = 160;
  Y = 140;
  Width = 320;
  Height = 200;
  TitleX = 160;
  TitleY = 24;
  Focusable = true;
  MenuScrollable = false;

  ActivateSound = 'menu/activate';
  DeactivateSound = 'menu/backup';
  ClearMenusSound = 'menu/clear';
}
