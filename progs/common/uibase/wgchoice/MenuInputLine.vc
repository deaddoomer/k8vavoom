//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class MenuInputLine : MenuChoiceSlot;

bool bEnteringText;
string Text;
string Value;
string EnterText;

delegate void ValueChanged (Object Sender);


//==========================================================================
//
//  OnCreate
//
//==========================================================================
override void OnCreate () {
  ::OnCreate();
  InitSlot();
}


//==========================================================================
//
//  SetText
//
//==========================================================================
void SetText (string AText) {
  Text = TranslateString(AText);
}


//==========================================================================
//
//  DisableSlotRendering
//
//==========================================================================
void DisableSlotRendering () {
  if (DrawSlotPic) {
    DrawSlotPic = false;
    //Height = 20;
    auto oldFont = GetFont();
    scope(exit) SetFont(oldFont);
    SetFont('smallfont');
    Height = FontHeight()+TextHeightAdd;
    // hack for default doom font
    if (Height == 10 && TextHeightAdd == 2) Height = 11;
  }
}


//==========================================================================
//
//  MakeOneLineControl
//
//==========================================================================
void MakeOneLineControl () {
  DisableSlotRendering();
  Width = Parent.Width;
  auto par = FindParentWithClass(MenuScreen);
  if (par) {
    par.SetChoiceInitialSizePos(self);
    SetOrigin(0, par.GetCurrentY());
  }
  //CursorXOffs = -10;
}


//==========================================================================
//
//  OnValueChanged
//
//==========================================================================
void OnValueChanged () {
  if (ValueChanged) ValueChanged(self);
}


//==========================================================================
//
//  OnDraw
//
//==========================================================================
override void OnDraw () {
  DrawBackground();

  SetFont('smallfont');

  if (DrawSlotPic) {
    // editor with a slot
    SetTextAlign(hleft, vtop);
    DrawText(0, 0, Text, IsFocused ? CR_YELLOW : CR_WHITE);
    if (bEnteringText) {
      DrawSlot(12-(DrawSlotPic ? 0 : 7), EnterText, true);
    } else {
      DrawSlot(12-(DrawSlotPic ? 0 : 7), Value, false);
    }
  } else {
    // editor without a slot
    int ty = TextHeightAdd/2;
    SetTextAlign(hright, vtop);
    DrawText(CursorXOffs, ty, Text, (IsFocused ? CR_YELLOW : CR_WHITE));
    SetTextAlign(hleft, vtop);
    int xx = CursorXOffs+10;
    int inputWidth = Width-xx-3;
    ShadeRect(xx-1, ty, inputWidth, FontHeight(), GetCvarF('menu_darkening'));
    string text = (bEnteringText ? EnterText : Value);
    if (bEnteringText) {
      while (text && TextWidth(text)+CursorWidth() > inputWidth+2) text = text[1..$];
      DrawText(xx, ty, text);
      DrawCursor();
    } else {
      bool drawDot = false;
      if (TextWidth(text) > inputWidth) {
        while (text && TextWidth(text) > inputWidth) text = text[0..$-1];
        if (text) text = text[0..$-1];
        drawDot = true;
      }
      DrawText(xx, ty, text);
      if (drawDot) DrawText(xx+TextWidth(text), ty, ".", CR_FIRE);
    }
  }
}


//==========================================================================
//
//  OnEvent
//
//==========================================================================
override bool OnEvent (ref event_t evt) {
  // "on click"
  if (evt.bubbling && evt.type == ev_click && evt.dest == self) {
    switch (evt.keycode) {
      case K_MOUSE1:
        if (bEnteringText) {
          /*
          bEnteringText = false;
          Value = EnterText;
          OnValueChanged();
          */
        } else {
          // we are going to be intercepting all chars
          bEnteringText = true;
          EnterText = Value;
          LocalSound('menu/choose');
        }
        return true;
      case K_MOUSE2:
        if (IsFocused) {
          if (bEnteringText) {
            bEnteringText = false;
            EnterText = Value;
          }
          return true;
        }
        break;
    }
  }

  if (evt.bubbling && evt.type == ev_keydown) {
    if (bEnteringText) {
      if (evt.bCtrl) {
        switch (evt.keycode) {
          case K_y: // ^Y
          case K_DELETE: // ^DEL
            EnterText = "";
            return true;
        }
        return true;
      }
      switch (evt.keycode) {
        case K_ESCAPE:
        //case K_MOUSE2:
          bEnteringText = false;
          EnterText = Value;
          break;
        case K_ENTER:
        case K_PADENTER:
        //case K_MOUSE1:
          bEnteringText = false;
          Value = EnterText;
          OnValueChanged();
          break;
        case K_BACKSPACE:
          if (EnterText) EnterText = EnterText[0..$-1];
          break;
        default:
          if (EnterText.length < 30) {
            string cc = TranslateKey(evt.keycode);
            if (cc && cc[0] >= 32 && cc[0] < 128) {
              EnterText ~= cc;
            }
          }
          break;
      }
      return true;
    } else {
      // not entering text
      int key = ConvertBoundKey(evt.keycode);
      if (key == K_ENTER || key == K_PADENTER || /*key == K_MOUSE1 ||*/ key == K_JOY1) {
        // switch to text entering mode
        bEnteringText = true;
        EnterText = Value;
        LocalSound('menu/choose');
        return true;
      }
    }
  }
  return ::OnEvent(evt);
}


defaultproperties {
  Height = 30;
}
