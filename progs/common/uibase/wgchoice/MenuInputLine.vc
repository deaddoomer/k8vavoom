//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class MenuInputLine : MenuChoiceSlot;

bool bEnteringText;
string Text;
string Value;
string EnterText;

delegate void ValueChanged (Object Sender);


override void OnCreate () {
  ::OnCreate();
  InitSlot();
}


void DisableSlotRendering () {
  if (DrawSlotPic) {
    DrawSlotPic = false;
    //Height = 20;
    auto oldFont = GetFont();
    scope(exit) SetFont(oldFont);
    SetFont('smallfont');
    Height = FontHeight();
  }
}


void MakeOneLineControl () {
  DisableSlotRendering();
  Width = Parent.Width;
  if (MenuScreen(Parent)) {
    MenuScreen(Parent).SetChoiceInitialSizePos(self);
    SetOrigin(0, MenuScreen(Parent).currentY);
  }
  //CursorXOffs = -10;
}


void OnValueChanged () {
  if (ValueChanged) ValueChanged(self);
}


override void OnDraw () {
  DrawBackground();

  SetFont('smallfont');

  if (DrawSlotPic) {
    // editor with a slot
    SetTextAlign(hleft, vtop);
    DrawText(0, 0, Text, IsFocus() ? CR_YELLOW : CR_WHITE);
    if (bEnteringText) {
      DrawSlot(12-(DrawSlotPic ? 0 : 7), EnterText, true);
    } else {
      DrawSlot(12-(DrawSlotPic ? 0 : 7), Value, false);
    }
  } else {
    // editor without a slot
    SetTextAlign(hright, vtop);
    DrawText(CursorXOffs, 0, Text, (IsFocus() ? CR_YELLOW : CR_WHITE));
    SetTextAlign(hleft, vtop);
    int xx = CursorXOffs+10;
    int inputWidth = Width-xx-3;
    ShadeRect(xx-1, 0, inputWidth, Height, GetCvarF('menu_darkening'));
    string text = (bEnteringText ? EnterText : Value);
    if (bEnteringText) {
      while (text && TextWidth(text)+CursorWidth() > inputWidth+2) text = text[1..$];
      DrawText(xx, 0, text);
      DrawCursor();
    } else {
      bool drawDot = false;
      if (TextWidth(text) > inputWidth) {
        while (text && TextWidth(text) > inputWidth) text = text[0..$-1];
        if (text) text = text[0..$-1];
        drawDot = true;
      }
      DrawText(xx, 0, text);
      if (drawDot) DrawText(xx+TextWidth(text), 0, ".", CR_FIRE);
    }
  }
}


override bool OnEvent (ref event_t evt) {
  if (evt.bubbling && evt.type == ev_keydown) {
    if (bEnteringText) {
      if (evt.bCtrl) {
        switch (evt.keycode) {
          case K_y: // ^Y
          case K_DELETE: // ^DEL
            EnterText = "";
            return true;
        }
        return true;
      }
      switch (evt.keycode) {
        case K_ESCAPE:
        //case K_MOUSE2:
          bEnteringText = false;
          EnterText = Value;
          break;
        case K_ENTER:
        case K_PADENTER:
        //case K_MOUSE1:
          bEnteringText = false;
          Value = EnterText;
          OnValueChanged();
          break;
        case K_BACKSPACE:
          if (EnterText) EnterText = EnterText[0..$-1];
          break;
        default:
          if (EnterText.length < 30) {
            string cc = TranslateKey(evt.keycode);
            if (cc && cc[0] >= 32 && cc[0] < 128) {
              EnterText ~= cc;
            }
          }
          break;
      }
      return true;
    } else {
      // not entering text
      int key = ConvertBoundKey(evt.keycode);
      if (key == K_ENTER || key == K_PADENTER || /*key == K_MOUSE1 ||*/ key == K_JOY1) {
        // switch to text entering mode
        bEnteringText = true;
        EnterText = Value;
        LocalSound('menu/choose');
        return true;
      }
    }
  }
  return ::OnEvent(evt);
}


override void OnMouseClick (int X, int Y) {
  SetFocus();

  if (bEnteringText) {
    bEnteringText = false;
    Value = EnterText;
    OnValueChanged();
  }

  // we are going to be intercepting all chars
  bEnteringText = true;
  EnterText = Value;
  LocalSound('menu/choose');
}


override void OnRMouseClick (int X, int Y) {
  SetFocus();

  if (bEnteringText) {
    bEnteringText = false;
    EnterText = Value;
    return;
  }

  GetClGame().PopMenu();
}


defaultproperties {
  Height = 30;
}
