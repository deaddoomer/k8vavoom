//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class MenuSList : MenuChoice;

int Cursor;
slist_t *slist;
bool Master;


//==========================================================================
//
//  StartSearching
//
//==========================================================================
void StartSearching () {
  StartSearch(Master);
}


//==========================================================================
//
//  DrawTextBox
//
//==========================================================================
void DrawTextBox (string text) {
  // h/v center string and print it
#ifdef FOO_BOO
  int w = (TextWidth(text)+16)&~15;
  int h = (TextHeight(text)+16)&~15;
  if (w > 304) w = 304;
  if (h > 184) h = 184;

  SetTextAlign(hcenter, vcenter);

  int x = (GetVirtualWidth()-w)/2;
  int y = (GetVirtualHeight()-h)/2;

  FillRectWithFlatRepeat(x, y, w, h, GetClGame().msgboxState.flatName);
  GetClGame().DrawBorder(x, y, w, h);

  DrawText(GetVirtualWidth()/2, GetVirtualHeight(), text);
#else
  auto rootw = GetClGame().GRoot;

  rootw.SetTextAlign(hcenter, vcenter);
  rootw.SetFont('smallfont');

  int w = (rootw.TextWidth(text)+16)&~15;
  int h = (rootw.TextHeight(text)+16)&~15;
  //if (w > 304) w = 304;
  //if (h > 184) h = 184;

  int x = (rootw.Width-w)/2;
  int y = (rootw.Height-h)/2;

  rootw.FillRectWithFlatRepeat(x, y, w, h, GetClGame().msgboxState.flatName);
  GetClGame().DrawBorder(x, y, w, h);

  rootw.DrawText(rootw.Width/2, rootw.Height/2, text);
#endif
}


//==========================================================================
//
//  OnDraw
//
//==========================================================================
override void OnDraw () {
  Width = Parent.Width;
  Height = Parent.Height;

  //DrawBackground();

  slist = GetSlist();


  SetFont('smallfont');

  int maxmapwdt = 0;
  int maxplrwdt = TextWidth(va("9/9"));
  int maxaddrwdt = 0;
  foreach (auto ref nfo; slist->Cache) {
    maxmapwdt = max(maxmapwdt, TextWidth(nfo.Map));
    maxplrwdt = max(maxplrwdt, TextWidth(va("%d/%d", nfo.Users, nfo.MaxUsers)));
    maxaddrwdt = max(maxaddrwdt, TextWidth(nfo.CName));
  }

  // right-aligned
  int xposUsers = Width-8;
  // left-aligned
  int xposAddr = xposUsers-maxplrwdt-6-maxaddrwdt;
  int xposMap = xposAddr-6-maxmapwdt;

  //printdebug("====== count=%s ======", slist.Cache.length);
  foreach (int i; 0..slist->Cache.length) {
    //printdebug("  %s: name=<%s>; map=<%s>", i, slist.Cache[i].Name, slist.Cache[i].Map);
    int clr = (Cursor == i ? CR_WHITE : CR_RED);
    if (!slist->Cache[i].bGoodProtocol || !slist->Cache[i].bGoodWadList) clr = CR_BLACK;
    // draw server name
    SetTextAlign(hleft, vtop);
    DrawText(16, 32+10*i, slist->Cache[i].Name, clr);
    // draw server map
    SetTextAlign(hleft, vtop);
    DrawText(xposMap, 32+10*i, slist->Cache[i].Map, clr);
    // draw server user address
    DrawText(xposAddr, 32+10*i, slist->Cache[i].CName, clr);
    // draw users
    if (slist->Cache[i].MaxUsers) {
      SetTextAlign(hright, vtop);
      DrawText(Width-4, 32+10*i, va("%d/%d", slist->Cache[i].Users, slist->Cache[i].MaxUsers), clr);
    }
  }
  SetTextAlign(hleft, vtop);
  DrawText(8, 32+Cursor*10, ">", CR_YELLOW);

  if (slist->ReturnReason) DrawText(16, 116, slist->ReturnReason);

  if (slist->Cache.length && Cursor >= 0 && Cursor < slist->Cache.length) {
    int x = 8;
    int y = 32+HOSTCACHESIZE*10;
    foreach (int i; 0..slist->Cache[Cursor].WadFiles.length) {
      if (!slist->Cache[Cursor].WadFiles[i]) break;
      int w = TextWidth(slist->Cache[Cursor].WadFiles[i]);
      if (x+w > Width-8) {
        x = 8;
        y += FontHeight();
        //if (y > 190) break;
      }
      DrawText(x, y, slist->Cache[Cursor].WadFiles[i], CR_GRAY);
      x += w+8;
    }
  }

       if (slist->bInProgress) DrawTextBox("Searching...");
  else if (!slist->Cache.length) DrawTextBox("No servers found");
}


//==========================================================================
//
//  OnKeyDown
//
//==========================================================================
override bool OnKeyDown (int key) {
  slist = GetSlist();

  if (slist->bInProgress) return true;

  key = ConvertBoundKey(key);
  switch (key) {
    case K_DOWNARROW:
      if (slist->Cache.length) {
        if (++Cursor >= slist->Cache.length) Cursor = 0;
        LocalSound('menu/cursor');
      }
      return true;

    case K_UPARROW:
      if (slist->Cache.length) {
        if (--Cursor < 0) Cursor = slist->Cache.length-1;
        LocalSound('menu/cursor');
      }
      return true;

    case K_ENTER:
    case K_PADENTER:
      if (slist->Cache.length && Cursor >= 0 && Cursor < slist->Cache.length) {
        LocalSound('menu/choose');
        if (slist->Cache[Cursor].bGoodProtocol && slist->Cache[Cursor].bGoodWadList) {
          CmdBuf_AddText("connect \"%q\"\n", slist->Cache[Cursor].CName);
          GetClGame().ForceMenuOff();
        }
      }
      return true;

    case K_SPACE:
      Cursor = 0;
      StartSearch(Master);
      return true;
  }

  return false;
}


defaultproperties {
}
