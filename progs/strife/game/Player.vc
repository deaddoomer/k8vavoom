//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class Player : PlayerEx;

const float INFRATIME = 120.0;

const int INITIAL_HEALTH = 100;
const int INITIAL_AMMO   = 50;


//==========================================================================
//
//  ResetPlayerOnSpawn
//
//==========================================================================
override void ResetPlayerOnSpawn (optional bool keepPlayerState) {
  ::ResetPlayerOnSpawn(keepPlayerState!optional);
}


//==========================================================================
//
//  GetRebornHealth
//
//==========================================================================
override int GetRebornHealth () {
  return INITIAL_HEALTH;
}


//==========================================================================
//
//  GotAmmo
//
//==========================================================================
override void GotAmmo (Ammo NewAmmo) {
  // we were down to zero, so select a new weapon
  // preferences are not user selectable
  if (ReadyWeapon.bWimpyWeapon) {
    Weapon Best = BestWeapon(class!Ammo(NewAmmo.Class));
    if (Best && Best.SelectionOrder < ReadyWeapon.SelectionOrder) {
      PendingWeapon = Best;
    }
  }
}


//==========================================================================
//
//  PlayerImpulse
//
//==========================================================================
override void PlayerImpulse () {
  int impulse = Impulse;

  if (impulse == 11) { InventoryThrow(); Impulse = 0; return; }

  if (impulse >= 200 && impulse <= 205) {
    LineSpecialLevelInfo(Level).ConChoiceImpulse(impulse-200); // done in superhandler
    // check if the player is ending a conversation
    if (impulse == 200) {
      // give the player some time to avoid shooting if
      // ending the conversation with the mouse
      Buttons = 0;
    }
    Impulse = 0;
    return;
  }

  ::PlayerImpulse();
  Impulse = 0;
}


//==========================================================================
//
//  Cheat_Gimme
//
//==========================================================================
void Cheat_Gimme () {
  // backpack
  if (Cmd_CheckParm("Backpack")) {
    Inventory I = Level.Spawn(AmmoSatchel, default, default, default, false);
    I.bDropped = true;
    if (!I.TryPickup(EntityEx(MO))) I.Destroy();
    cprint("EXTRA AMMO");
  }

  // weapons
  if (Cmd_CheckParm("Weapons")) {
    class!Weapon WpnCls;
    foreach AllClasses(Weapon, WpnCls) {
      if (!FindClassState(WpnCls, 'Ready')) continue; // abstract base class
      if (WpnCls.default.bCheatNotWeapon) continue;
      Weapon Wpn = Level.Spawn(WpnCls, default, default, default, false);
      Wpn.AmmoGive1 = 0;
      Wpn.AmmoGive2 = 0;
      if (!Wpn.TryPickup(EntityEx(MO))) Wpn.Destroy();
    }
    cprint("ALL WEAPONS");
  }

  // ammo
  if (Cmd_CheckParm("Ammo")) {
    class!Inventory Cls;
    foreach AllClasses(Ammo, Cls) {
      // only direct descendants
      if (GetClassParent(Cls) != Ammo) continue;
      Inventory AmmoItem = EntityEx(MO).FindInventory(Cls);
      if (!AmmoItem) {
        AmmoItem = Level.Spawn(Cls, default, default, default, false);
        if (!AmmoItem.TryPickup(EntityEx(MO))) {
          AmmoItem.Destroy();
          AmmoItem = none;
        }
      }
      if (AmmoItem) AmmoItem.Amount = AmmoItem.MaxAmount;
    }
    cprint("FULL AMMO");
  }

  // keys
  if (Cmd_CheckParm("Keys")) {
    class!Inventory Cls;
    foreach AllClasses(Key, Cls) {
      if (!FindClassState(Cls, 'Spawn')) continue; // abstract class
      EntityEx(MO).GiveInventoryType(Cls);
    }
    cprint("ALL KEYS");
  }

  // health
  if (Cmd_CheckParm("Health")) {
    Health = MAXHEALTH+Stamina;
    MO.Health = MAXHEALTH+Stamina;
    cprint("FULL HEALTH");
  }

  // comm unit
  if (Cmd_CheckParm("CommUnit")) {
    EntityEx(MO).GiveInventoryType(Communicator);
    cprint("YOU GOT IT");
  }

  // sigil piece
  if (Cmd_CheckParm("Sigil")) {
    Sigil S = Level.Spawn(Sigil, default, default, default, false);
    if (!S.SpecialDropAction(none)) S.Destroy();
    cprint("SIGIL PIECE");
  }

  // quest items.
  foreach (auto i; 0..31) {
    if (Cmd_CheckParm(va("Quest%d", i+1))) {
      EntityEx(MO).GiveInventoryType(class!Inventory(FindClass(name(va("QuestItem%d", i)))));
      cprint("YOU GOT IT");
    }
  }

  // gold
  if (Cmd_CheckParm("Gold")) {
    Inventory GoldItem = EntityEx(MO).FindInventory(Coin);
    if (!GoldItem) {
      GoldItem = Level.Spawn(Coin, default, default, default, false);
      if (!GoldItem.TryPickup(EntityEx(MO))) {
        GoldItem.Destroy();
        GoldItem = none;
      }
    }
    if (GoldItem) GoldItem.Amount = GoldItem.MaxAmount;
    cprint("GOT GOLD");
  }
}


//==========================================================================
//
//  StartDeathSlideShow
//
//==========================================================================
override void StartDeathSlideShow () {
  ClientFinaleType(1);
  Level.Completed(-1, -1, 0);
}


//==========================================================================
//
//  KilledActor
//
//==========================================================================
override void KilledActor (EntityEx Victim) {
  // check for frag changes
  if (Victim.bIsPlayer) {
    if (MO == Victim) {
      --Frags;
    } else {
      ++Frags;
    }
  }
}


//===========================================================================
//
//  GetSigilPieces
//
//===========================================================================
override int GetSigilPieces () {
  Sigil S = Sigil(EntityEx(MO).FindInventory(Sigil));
  if (S) return S.NumPieces;
  return 0;
}


defaultproperties {
  bInventoryAlwaysOpen = true;
  InvSize = 5;
}
