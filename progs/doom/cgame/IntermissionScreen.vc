//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class IntermissionScreen : Widget;

// intermission states
enum {
  IMS_Stats,
  IMS_NextLoc,
  IMS_NoState,
  IMS_Text,
  IMS_Done,
};

ClientGameBase ClGame;

// global locations
const int WI_SPACINGY = 33;
const int WI_TITLEY   = 12;

// singple-player stuff
const int SP_STATSX = 210;
const int SP_STATSY = 190;

const int SP_TIMEX = 176;
const int SP_TIMEY = 308;

const int SP_PARX = 376;
const int SP_PARY = 308;

// net game stuff
const int NG_STATSY = 210;
const int NG_STATSX = (172+32/2);

const int NG_SPACINGX = 64;

// deathmatch stuff
const int DM_MATRIXX = 202;
const int DM_MATRIXY = 208;

const int DM_TOTALSX = 329;
const int DM_DEATHSX = 429;

const int DM_SPACINGX = 40;

// in seconds
const float SHOWNEXTLOCDELAY = 4.0;

// different between registered DOOM (1994) and Ultimate DOOM - Final edition (retail, 1995?)
const int NUMEPISODES = 3;
const int NUMMAPS     = 9;

const float TEXTSPEED = 0.1;
const float TEXTWAIT  = 7.0;

int LeaveTitlePic;
int EnterTitlePic;

int interstate;

// used for timing of background animation
float btime;

int sp_state;
int ng_state;
int dm_state;

int TotalKills;
int TotalItems;
int TotalSecret;

int cnt_kills[MAXPLAYERS];
int cnt_items[MAXPLAYERS];
int cnt_secret[MAXPLAYERS];
int cnt_time;
float cnt_pause;
int cnt_frags[MAXPLAYERS];

int dm_Frags[MAXPLAYERS];
int dm_Deaths[MAXPLAYERS];

// face background, your face, your dead face
int p[MAXPLAYERS];

int star;
int star_width;

int bstar;

// used for general timing
float cnt;

int im_episode;
int im_map;
int im_nextepisode;
int im_nextmap;


IntermissionBackground Background;

int oldParentWidth = -1;
int oldParentHeight = -1;
float oldParentScaleX = -1;
float oldParentScaleY = -1;


final int ConvertX (int x) { return int(float(Width)*x/640.0); }
final int ConvertY (int y) { return int(float(Height)*y/480.0); }


//==========================================================================
//
//  checkForDoom2
//
//==========================================================================
final bool checkForDoom2 () {
  bool isDoom2 = IsAnyDoom2;
  if (isDoom2) {
    string xmap = string(ClGame.im.LeaveMap);
    if (xmap.length == 4 && (xmap[0] == "e" || xmap[0] == "E") && (xmap[2] == "m" || xmap[2] == "M")) {
      isDoom2 = false;
      //print("MSG: forcing Doom1 (leavemap=%s)", xmap);
    }
  }
  if (isDoom2) {
    string xmap = string(ClGame.im.EnterMap);
    if (xmap.length == 4 && (xmap[0] == "e" || xmap[0] == "E") && (xmap[2] == "m" || xmap[2] == "M")) {
      isDoom2 = false;
      //print("MSG: forcing Doom1 (entermap=%s)", xmap);
    }
  }
  return isDoom2;
}


//==========================================================================
//
//  FixWidgetSize
//
//==========================================================================
void FixWidgetSize () {
  auto par = Parent;

  if (oldParentWidth == -1) {
    oldParentWidth = par.Width;
    oldParentHeight = par.Height;
    oldParentScaleX = par.ScaleX;
    oldParentScaleY = par.ScaleY;
  }

  if (par && (Width != par.Width || Height != par.Height)) {
    SetSize(par.Width, par.Height);
    //print("size=(%s,%s); scale=(%s,%s); scrsize=(%s,%s)", Width, Height, ScaleX, ScaleY, GetVirtualWidth(), GetVirtualHeight());
    //print("  real=(%s,%s); rsc=(%s,%s)", GetRealScreenWidth(), GetRealScreenHeight(), float(GetRealScreenWidth())/float(GetVirtualWidth()), float(GetRealScreenHeight())/float(GetVirtualHeight()));
  }
}


//==========================================================================
//
//  RestoreWidgetSize
//
//==========================================================================
void RestoreWidgetSize () {
  if (oldParentWidth != -1) {
    auto par = Parent;

    par.Width = oldParentWidth;
    par.Height = oldParentHeight;
    par.ScaleX = oldParentScaleX;
    par.ScaleY = oldParentScaleY;

    oldParentWidth = -1;
    oldParentHeight = -1;
    oldParentScaleX = -1;
    oldParentScaleY = -1;
  }
}


//==========================================================================
//
//  Start
//
//==========================================================================
void Start () {
  FixWidgetSize();

  StopAllSounds();
  ClGame.skipintermission = false;
  cnt = 0.0;
  btime = 0.0;

  if (!Background && !ClGame.cl.Level.bNoIntermission) {
    Background = NewChild(IntermissionBackground);
    Background.ScaleX = float(Width)/float(Background.Width);
    Background.ScaleY = float(Height)/float(Background.Height);
  }

  if (ClGame.cl.Level.bNoIntermission && Background) {
    delete Background; // remove it
    //Background.Clean();
    //print("********* NO INTERMISSION! leavemap=%s; entermap=%s", ClGame.im.LeaveMap, ClGame.im.EnterMap);
  }

  scope(exit) {
    if (ClGame.cl.Level.bNoIntermission && Background) {
      delete Background; // remove it
      interstate = IMS_Done;
    }
  }

  if (!checkForDoom2()) {
    FindEpisodeAndMap(ClGame.im.LeaveMap, &im_episode, &im_map);
    FindEpisodeAndMap(ClGame.im.EnterMap, &im_nextepisode, &im_nextmap);
  }

  IM_InitAnimatedBack();

  TotalKills = ClGame.cl.Level.TotalKills;
  TotalItems = ClGame.cl.Level.TotalItems;
  TotalSecret = ClGame.cl.Level.TotalSecret;

  if (!TotalKills) TotalKills = 1;
  if (!TotalItems) TotalItems = 1;
  if (!TotalSecret) TotalSecret = 1;

       if (ClGame.deathmatch) IM_InitDeathmatchStats();
  else if (ClGame.maxclients > 1) IM_InitCooperativeStats();
  else IM_InitSingleStats();

  if (interstate == IMS_Stats) {
    IM_LoadData();

    // intermission music
    if (ClGame.im.InterMusic) {
      CmdBuf_AddText(va("music loop %n\n", ClGame.im.InterMusic));
    }
    else {
#ifdef FIXME
      if (checkForDoom2()) {
        S_StartSong("D_DM2INT", P_GetCDIntermissionTrack(), true);
      } else {
        S_StartSong("D_INTER", P_GetCDIntermissionTrack(), true);
      }
#else
      if (checkForDoom2()) {
        CmdBuf_AddText("music loop D_DM2INT\n");
      } else {
        CmdBuf_AddText("music loop D_INTER\n");
      }
#endif
    }
  } else {
    IM_InitText();
  }
}


//==========================================================================
//
//  FindEpisodeAndMap
//
//==========================================================================
void FindEpisodeAndMap (name Name, int *epi, int *map) {
  foreach (auto e; 1..4) {
    foreach (auto m; 1..10) {
      if (Name == name(va("e%dm%d", e, m))) {
        *epi = e;
        *map = m;
        return;
      }
    }
  }
  *epi = 4;
  *map = 1;
}


//==========================================================================
//
//  Tick
//
//  Updates stuff each frame
//
//==========================================================================
override void Tick (float DeltaTime) {
  FixWidgetSize();
  // counter for general background animation
  btime += DeltaTime;
  switch (interstate) {
    case IMS_Stats:
           if (ClGame.deathmatch) IM_UpdateDeathmatchStats(DeltaTime);
      else if (ClGame.maxclients > 1) IM_UpdateCooperativeStats(DeltaTime);
      else IM_UpdateSingleStats(DeltaTime);
      break;
    case IMS_NextLoc:
      if (!checkForDoom2()) IM_UpdateNextLoc(DeltaTime);
      break;
    case IMS_NoState:
      IM_UpdateNoState(DeltaTime);
      break;
    case IMS_Text:
      IM_UpdateText(DeltaTime);
      break;
    case IMS_Done:
      break;
  }
}


//==========================================================================
//
//  OnPostDraw
//
//==========================================================================
override void OnPostDraw () {
  SetFont('bigfont');
  switch (interstate) {
    case IMS_Stats:
           if (ClGame.deathmatch) IM_DrawDeathmatchStats();
      else if (ClGame.maxclients > 1) IM_DrawCooperativeStats();
      else IM_DrawSingleStats();
      break;
    case IMS_NextLoc:
      if (!checkForDoom2()) IM_DrawNextLoc();
      break;
    case IMS_NoState:
      IM_DrawNoState();
      break;
    case IMS_Text:
      IM_DrawText();
      break;
    case IMS_Done:
      break;
  }
}


//**************************************************************************
//**
//**    Animated background
//**
//**************************************************************************

//==========================================================================
//
//  IM_InitAnimatedBack
//
//==========================================================================
void IM_InitAnimatedBack () {
  if (ClGame.cl.Level.bNoIntermission) {
    if (Background) Background.Clean();
    return;
  }
  if (!Background) return;

  /*
  print("IM_InitAnimatedBack: interstate=%d; exitpic=%n; enterpic=%n", interstate, ClGame.im.ExitPic, ClGame.im.EnterPic);
  print("  LeaveMap=%n; LeaveCluster=%d; LeaveName=%s; LeaveTitlePatch=%n; ExitPic=%n", ClGame.im.LeaveMap, ClGame.im.LeaveCluster, ClGame.im.LeaveName, ClGame.im.LeaveTitlePatch, ClGame.im.ExitPic);
  print("  EnterMap=%n; EnterCluster=%d; EnterName=%s; EnterTitlePatch=%n; EnterPic=%n", ClGame.im.EnterMap, ClGame.im.EnterCluster, ClGame.im.EnterName, ClGame.im.EnterTitlePatch, ClGame.im.EnterPic);
  print("  InterMusic=%n", ClGame.im.InterMusic);
  print("  Text=%s", ClGame.im.Text);
  print("  TextFlat=%n; TextPic=%n; TextMusic=%n; bTextIsLump=%d", ClGame.im.TextFlat, ClGame.im.TextPic, ClGame.im.TextMusic, ClGame.im.bTextIsLump);
  */

  name BgPic = (interstate ? ClGame.im.ExitPic : ClGame.im.EnterPic);
  //print("  BgPic0: %n (present=%d); im_episode=%d; isdoom2=%s", BgPic, WadLumpPresent(BgPic), im_episode, (IsAnyDoom2 ? "tan" : "ona"));
  if (!BgPic) {
    if (checkForDoom2()) {
      BgPic = 'interpic';
    } else {
      if (im_episode > 3) {
        BgPic = 'interpic';
      } else {
        BgPic = name(va("$in_epi%d", im_episode));
      }
    }
    //print("  BgPic1: %n (present=%d)", BgPic, WadLumpPresent(BgPic));
  }
  Background.Init(BgPic, interstate ?
    IntermissionBackground::STATE_NextLoc :
    IntermissionBackground::STATE_Default, ClientGameShared(ClGame));
}


//==========================================================================
//
//  IM_LoadData
//
//==========================================================================
void IM_LoadData () {
  picinfo_t info;

  if (ClGame.im.LeaveTitlePatch) LeaveTitlePic = R_RegisterPic(ClGame.im.LeaveTitlePatch);
  if (ClGame.im.EnterTitlePatch) EnterTitlePic = R_RegisterPic(ClGame.im.EnterTitlePatch);

  if (ClGame.maxclients > 1 || ClGame.deathmatch) {
    // face backgrounds
    //for (i = 0; i < MAXPLAYERS; i++)
    foreach (auto i; 0..4) p[i] = R_RegisterPic(name(va("stpb%i", i)));

    // your face
    star = R_RegisterPic('stfst01');
    R_GetPicInfo(star, &info);
    star_width = info.width;

    // dead face
    bstar = R_RegisterPic('stfdead0');
  }
}


//==========================================================================
//
//  IM_UnloadData
//
//==========================================================================
void IM_UnloadData () {
}


//==========================================================================
//
//  IM_DrawLF
//
//  Draws "<Levelname> Finished!"
//
//==========================================================================
void IM_DrawLF () {
  picinfo_t info;
  int y = WI_TITLEY;

  // draw <LevelName>
  if (ClGame.im.LeaveTitlePatch) {
    R_GetPicInfo(LeaveTitlePic, &info);
    DrawPic(ConvertX(640/2)-info.width/2, y, LeaveTitlePic);
    y += info.height+TextHeight("DUMMY")/4;
  } else {
    SetTextAlign(hcentre, vtop);
    DrawText(ConvertX(640/2), y, ClGame.im.LeaveName);
    y += (5*TextHeight("DUMMY"))/4;
  }

  // draw "Finished!"
  SetTextAlign(hcentre, vtop);
  DrawText(ConvertX(640/2), y, "finished");
}


//==========================================================================
//
//  IM_DrawEL
//
//  Draws "Entering <LevelName>"
//
//==========================================================================
void IM_DrawEL () {
  picinfo_t info;
  int y = WI_TITLEY;

  // draw "Entering"
  SetTextAlign(hcentre, vtop);
  DrawText(ConvertX(640/2), y, "entering");

  // draw level
  y += (5*TextHeight("DUMMY"))/4;
  if (ClGame.im.EnterTitlePatch) {
    R_GetPicInfo(EnterTitlePic, &info);
    DrawPic(ConvertX(640/2)-info.width/2, y, EnterTitlePic);
  } else {
    DrawText(ConvertX(640/2), y, ClGame.im.EnterName);
  }
}


//==========================================================================
//
//  IM_DrawPercent
//
//==========================================================================
void IM_DrawPercent (int x, int y, int p) {
  if (p < 0) return;
  SetTextAlign(hright, vtop);
  DrawText(x, y, va("%d%%", p));
}


//==========================================================================
//
//  IM_DrawTime
//
//  Display level completion time and par, or "sucks" message if overflow.
//
//==========================================================================
void IM_DrawTime (int x, int y, int t, string BaseText, bool sucks) {
  if (t < 0) return;

  SetTextAlign(hleft, vtop);

  string Text;
  if (!sucks || !ClGame.cl.Level.SuckTime || t < ClGame.cl.Level.SuckTime*60*60) {
    Text = BaseText;
    if (t >= 60*60) {
      Text ~= va("%d:", t/(60*60));
      if ((t/60)%60 < 10) {
        Text ~= va("0%d", (t/60)%60);
      } else {
        Text ~= va("%d", (t/60)%60);
      }
    } else {
      Text ~= va("%d", t/60);
    }
    if (t%60 < 10) {
      Text ~= va(":0%d", t%60);
    } else {
      Text ~= va(":%d", t%60);
    }
  } else {
    // "sucks"
    Text = BaseText~"sucks";
  }
  DrawText(x, y, Text);
}


//==========================================================================
//
//  IM_InitSingleStats
//
//==========================================================================
void IM_InitSingleStats () {
  interstate = IMS_Stats;
  ClGame.skipintermission = false;
  sp_state = 1;
  cnt_kills[0] = -1;
  cnt_items[0] = -1;
  cnt_secret[0] = -1;
  cnt_time = -1;
  cnt_pause = 1.0;
  if (ClGame.cl.Level.bNoIntermission) {
    //interstate = IMS_NoState;
    ClGame.skipintermission = false;
    CmdBuf_AddText("TeleportNewMap\n");
    interstate = IMS_Done;
    //Background.State = IntermissionBackground::STATE_Done;
    if (Background) Background.Clean(); // don't draw it at all
  }
}


//==========================================================================
//
//  IM_DrawSingleStats
//
//==========================================================================
void IM_DrawSingleStats () {
  // line height
  int lh = (3*TextHeight("DUMMY"))/2;

  IM_DrawLF();

  SetTextAlign(hleft, vtop);

  DrawText(SP_STATSX, SP_STATSY, "kills");
  DrawText(SP_STATSX, SP_STATSY+lh, "items");
  DrawText(SP_STATSX, SP_STATSY+2*lh, "scrt");

  if (sp_state < 2 || ClGame.cl.Level.TotalKills > 0) {
    IM_DrawPercent(ConvertX(640-SP_STATSX), SP_STATSY, cnt_kills[0]);
  } else {
    DrawText(ConvertX(640-SP_STATSX), SP_STATSY, "all");
  }
  if (sp_state < 4 || ClGame.cl.Level.TotalItems > 0) {
    IM_DrawPercent(ConvertX(640-SP_STATSX), SP_STATSY+lh, cnt_items[0]);
  } else {
    DrawText(ConvertX(640-SP_STATSX), SP_STATSY+lh, "all");
  }
  if (sp_state < 6 || ClGame.cl.Level.TotalSecret > 0) {
    IM_DrawPercent(ConvertX(640-SP_STATSX), SP_STATSY+2*lh, cnt_secret[0]);
  } else {
    DrawText(ConvertX(640-SP_STATSX), SP_STATSY+2*lh, "all");
  }
  IM_DrawTime(ConvertX(SP_TIMEX), SP_TIMEY, cnt_time, "time: ", true);
  if (cnt_time >= 0 && ClGame.cl.Level.ParTime) {
    IM_DrawTime(ConvertX(SP_PARX), SP_PARY, ClGame.cl.Level.ParTime, "par: ", false);
  }
}


//==========================================================================
//
//  IM_UpdateSingleStats
//
//==========================================================================
void IM_UpdateSingleStats (float DeltaTime) {
  if (ClGame.skipintermission && sp_state != 10) {
    ClGame.skipintermission = false;
    cnt_kills[0] = (ClGame.cl.KillCount*100)/TotalKills;
    cnt_items[0] = (ClGame.cl.ItemCount*100)/TotalItems;
    cnt_secret[0] = (ClGame.cl.SecretCount*100)/TotalSecret;
    cnt_time = int(ClGame.GLevel.LevelInfo.CompletitionTime);
    LocalSound('weapons/rocklx');
    sp_state = 10;
  }

  if (sp_state == 2) {
    cnt_kills[0] += 2;

    if (!(int(btime*35.0)&3)) LocalSound('weapons/pistol');

    if (cnt_kills[0] >= (ClGame.cl.KillCount*100)/TotalKills) {
      cnt_kills[0] = (ClGame.cl.KillCount*100)/TotalKills;
      LocalSound('weapons/rocklx');
      ++sp_state;
    }
  } else if (sp_state == 4) {
    cnt_items[0] += 2;

    if (!(int(btime*35.0)&3)) LocalSound('weapons/pistol');

    if (cnt_items[0] >= (ClGame.cl.ItemCount*100)/TotalItems) {
      cnt_items[0] = (ClGame.cl.ItemCount*100)/TotalItems;
      LocalSound('weapons/rocklx');
      ++sp_state;
    }
  } else if (sp_state == 6) {
    cnt_secret[0] += 2;

    if (!(int(btime*35.0)&3)) LocalSound('weapons/pistol');

    if (cnt_secret[0] >= (ClGame.cl.SecretCount*100)/TotalSecret) {
      cnt_secret[0] = (ClGame.cl.SecretCount*100)/TotalSecret;
      LocalSound('weapons/rocklx');
      ++sp_state;
    }
  } else if (sp_state == 8) {
    if (!(int(btime*35.0)&3)) LocalSound('weapons/pistol');

    cnt_time += 3;

    if (cnt_time >= int(ClGame.GLevel.LevelInfo.CompletitionTime)) {
      cnt_time = int(ClGame.GLevel.LevelInfo.CompletitionTime);
      LocalSound('weapons/rocklx');
      ++sp_state;
    }
  } else if (sp_state == 10) {
    if (ClGame.skipintermission) {
      LocalSound('weapons/shotgr');
      if (checkForDoom2()) {
        IM_InitNoState();
      } else {
        IM_InitNextLoc();
      }
    }
  } else if (sp_state&1) {
    cnt_pause -= DeltaTime;
    if (cnt_pause <= 0.0) {
      ++sp_state;
      cnt_pause = 1.0;
    }
  }
}


//==========================================================================
//
//  IM_InitCooperativeStats
//
//==========================================================================
void IM_InitCooperativeStats () {
  interstate = IMS_Stats;
  ClGame.skipintermission = false;
  ng_state = 1;
  cnt_pause = 1.0;
  foreach (auto i; 0..MAXPLAYERS) {
    cnt_kills[i] = 0;
    cnt_items[i] = 0;
    cnt_secret[i] = 0;
    cnt_frags[i] = 0;
  }
  if (ClGame.cl.Level.bNoIntermission) {
    interstate = IMS_NoState;
    ClGame.skipintermission = false;
    CmdBuf_AddText("TeleportNewMap\n");
    interstate = IMS_Done;
    //Background.State = IntermissionBackground::STATE_Done;
    if (Background) Background.Clean(); // don't draw it at all
  }
}


//==========================================================================
//
//  IM_DrawCooperativeStats
//
//==========================================================================
void IM_DrawCooperativeStats () {
  int i;
  int x;
  int y;
  int pwidth;
  picinfo_t info;
  PlayerReplicationInfo RepInfo;

  pwidth = TextWidth("%");

  IM_DrawLF();

  SetTextAlign(hright, vtop);
  // draw stat titles (top line)
  DrawText(ConvertX(NG_STATSX+NG_SPACINGX), NG_STATSY, "kills");
  DrawText(ConvertX(NG_STATSX+2*NG_SPACINGX), NG_STATSY, "items");
  DrawText(ConvertX(NG_STATSX+3*NG_SPACINGX), NG_STATSY, "scrt");
  DrawText(ConvertX(NG_STATSX+4*NG_SPACINGX), NG_STATSY, "frgs");

  // draw stats
  y = NG_STATSY+TextHeight("kills");

  foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo) {
    i = RepInfo.PlayerNum;
    x = NG_STATSX;
    R_GetPicInfo(p[i], &info);
    DrawPic(ConvertX(x)-info.width, y, p[i]);

    if (i == ClGame.cl.ClientNum) DrawPic(ConvertX(x)-info.width, y, star);

    x += NG_SPACINGX;
    IM_DrawPercent(ConvertX(x)-pwidth, y+10, cnt_kills[i]);
    x += NG_SPACINGX;
    IM_DrawPercent(ConvertX(x)-pwidth, y+10, cnt_items[i]);
    x += NG_SPACINGX;
    IM_DrawPercent(ConvertX(x)-pwidth, y+10, cnt_secret[i]);
    x += NG_SPACINGX;

    SetTextAlign(hright, vtop);
    DrawText(ConvertX(x), y+10, va("%d", cnt_frags[i]));

    y += WI_SPACINGY;
  }
}


//==========================================================================
//
//  IM_UpdateCooperativeStats
//
//==========================================================================
void IM_UpdateCooperativeStats (float DeltaTime) {
  int fsum;
  PlayerReplicationInfo RepInfo;

  bool stillticking;

  if (ClGame.skipintermission && ng_state != 10) {
    ClGame.skipintermission = false;
    foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo) {
      cnt_kills[RepInfo.PlayerNum] = (RepInfo.KillCount*100)/TotalKills;
      cnt_items[RepInfo.PlayerNum] = (RepInfo.ItemCount*100)/TotalItems;
      cnt_secret[RepInfo.PlayerNum] = (RepInfo.SecretCount*100)/TotalSecret;
      cnt_frags[RepInfo.PlayerNum] = RepInfo.Frags;
    }
    LocalSound('weapons/rocklx');
    ng_state = 10;
  }

  if (ng_state == 2) {
    if (!(int(btime*35.0)&3)) LocalSound('weapons/pistol');

    stillticking = false;

    foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo) {
      cnt_kills[RepInfo.PlayerNum] += 2;
      if (cnt_kills[RepInfo.PlayerNum] >= (RepInfo.KillCount*100)/TotalKills) {
        cnt_kills[RepInfo.PlayerNum] = (RepInfo.KillCount*100)/TotalKills;
      } else {
        stillticking = true;
      }
    }

    if (!stillticking) {
      LocalSound('weapons/rocklx');
      ++ng_state;
    }
  } else if (ng_state == 4) {
    if (!(int(btime*35.0)&3)) LocalSound('weapons/pistol');

    stillticking = false;

    foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo) {
      cnt_items[RepInfo.PlayerNum] += 2;
      if (cnt_items[RepInfo.PlayerNum] >= (RepInfo.ItemCount*100)/TotalItems) {
        cnt_items[RepInfo.PlayerNum] = (RepInfo.ItemCount*100)/TotalItems;
      } else {
        stillticking = true;
      }
    }
    if (!stillticking) {
      LocalSound('weapons/rocklx');
      ++ng_state;
    }
  } else if (ng_state == 6) {
    if (!(int(btime*35.0)&3)) LocalSound('weapons/pistol');

    stillticking = false;

    foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo) {
      cnt_secret[RepInfo.PlayerNum] += 2;
      if (cnt_secret[RepInfo.PlayerNum] >= RepInfo.SecretCount*100/TotalSecret) {
        cnt_secret[RepInfo.PlayerNum] = RepInfo.SecretCount*100/TotalSecret;
      } else {
        stillticking = true;
      }
    }

    if (!stillticking) {
      LocalSound('weapons/rocklx');
      ++ng_state;
    }
  } else if (ng_state == 8) {
    if (!(int(btime*35.0)&3)) LocalSound('weapons/pistol');

    stillticking = false;

    foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo) {
      cnt_frags[RepInfo.PlayerNum] += 1;
      if (cnt_frags[RepInfo.PlayerNum] >= RepInfo.Frags) {
        cnt_frags[RepInfo.PlayerNum] = RepInfo.Frags;
      } else {
        stillticking = true;
      }
    }

    if (!stillticking) {
      LocalSound('*death');
      ++ng_state;
    }
  } else if (ng_state == 10) {
    if (ClGame.skipintermission) {
      LocalSound('weapons/shotgr');
      if (checkForDoom2()) {
        IM_InitNoState();
      } else {
        IM_InitNextLoc();
      }
    }
  } else if (ng_state&1) {
    cnt_pause -= DeltaTime;
    if (cnt_pause <= 0.0) {
      ++ng_state;
      cnt_pause = 1.0;
    }
  }
}


//==========================================================================
//
//  IM_InitDeathmatchStats
//
//==========================================================================
void IM_InitDeathmatchStats () {
  int i;
  int j;
  PlayerReplicationInfo RepInfo;

  interstate = IMS_Stats;
  ClGame.skipintermission = false;
  dm_state = 1;

  cnt_pause = 1.0;

  foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo) {
    i = RepInfo.PlayerNum;
    dm_Frags[i] = 0;
    dm_Deaths[i] = 0;
  }
}


//==========================================================================
//
//  IM_DrawDeathmatchStats
//
//==========================================================================
void IM_DrawDeathmatchStats () {
  int y;
  picinfo_t info;
  PlayerReplicationInfo RepInfo;

  IM_DrawLF();

  SetTextAlign(hcentre, vtop);
  // draw stat titles (top line)
  DrawText(ConvertX(DM_TOTALSX), DM_MATRIXY-WI_SPACINGY, "FRAGS");
  DrawText(ConvertX(DM_DEATHSX), DM_MATRIXY-WI_SPACINGY, "DEATHS");

  // draw stats
  y = DM_MATRIXY;

  foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo) {
    if (RepInfo.PlayerNum == ClGame.cl.ClientNum) {
      R_GetPicInfo(star, &info);
      DrawPic(ConvertX(DM_MATRIXX)-info.width-5, y-8, star);
    }
    SetTextAlign(hleft, vtop);
    SetFont('smallfont');
    DrawText(ConvertX(DM_MATRIXX), y+5, RepInfo.PlayerName);
    SetTextAlign(hright, vtop);
    SetFont('bigfont');
    DrawText(ConvertX(DM_TOTALSX), y, va("%d", dm_Frags[RepInfo.PlayerNum]));
    DrawText(ConvertX(DM_DEATHSX), y, va("%d", dm_Deaths[RepInfo.PlayerNum]));
    y += 24;
  }
}


//==========================================================================
//
//  IM_UpdateDeathmatchStats
//
//==========================================================================
void IM_UpdateDeathmatchStats (float DeltaTime) {
  int i;

  bool stillticking;
  PlayerReplicationInfo RepInfo;

  if (ClGame.skipintermission && dm_state != 4) {
    ClGame.skipintermission = false;
    foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo) {
      dm_Frags[RepInfo.PlayerNum] = RepInfo.Frags;
      dm_Deaths[RepInfo.PlayerNum] = RepInfo.Deaths;
    }
    LocalSound('weapons/rocklx');
    dm_state = 4;
  }

  if (dm_state == 2) {
    if (!(int(btime*35.0)&3)) LocalSound('weapons/pistol');

    stillticking = false;

    foreach ClGame.GLevel.LevelInfo.AllThinkers(PlayerReplicationInfo, RepInfo) {
      i = RepInfo.PlayerNum;
      if (dm_Frags[i] != RepInfo.Frags) {
        if (RepInfo.Frags < 0) dm_Frags[i]--; else dm_Frags[i]++;
        stillticking = true;
      }
      if (dm_Deaths[i] != RepInfo.Deaths) {
        if (RepInfo.Deaths < 0) dm_Deaths[i]--; else dm_Deaths[i]++;
        stillticking = true;
      }
    }
    if (!stillticking) {
      LocalSound('weapons/rocklx');
      ++dm_state;
    }
  } else if (dm_state == 4) {
    if (ClGame.skipintermission) {
      LocalSound('misc/gibbed');
      if (checkForDoom2()) {
        IM_InitNoState();
      } else {
        IM_InitNextLoc();
      }
    }
  } else if (dm_state&1) {
    cnt_pause -= DeltaTime;
    if (cnt_pause <= 0.0) {
      ++dm_state;
      cnt_pause = 1.0;
    }
  }
}


//==========================================================================
//
//  IM_InitNextLoc
//
//==========================================================================
void IM_InitNextLoc () {
  interstate = IMS_NextLoc;
  ClGame.skipintermission = false;
  cnt = SHOWNEXTLOCDELAY;
  IM_InitAnimatedBack();
}


//==========================================================================
//
//  IM_DrawNextLoc
//
//==========================================================================
void IM_DrawNextLoc () {
  // draws which level you are entering
  IM_DrawEL();
}


//==========================================================================
//
//  IM_UpdateNextLoc
//
//==========================================================================
void IM_UpdateNextLoc (float DeltaTime) {
  cnt -= DeltaTime;
  if (cnt <= 0.0 || ClGame.skipintermission) IM_InitNoState();
}


//==========================================================================
//
//  IM_InitNoState
//
//==========================================================================
void IM_InitNoState () {
  interstate = IMS_NoState;
  ClGame.skipintermission = false;
  cnt = 0.3;
}


//==========================================================================
//
//  IM_DrawNoState
//
//==========================================================================
void IM_DrawNoState () {
  if (checkForDoom2()) {
    // draws which level you are entering
    if (ClGame.im.LeaveMap != 'map30') IM_DrawEL();
  } else {
    IM_DrawNextLoc();
  }
}


//==========================================================================
//
//  IM_UpdateNoState
//
//==========================================================================
void IM_UpdateNoState (float DeltaTime) {
  cnt -= DeltaTime;
  if (cnt <= 0.0) {
    IM_UnloadData();
    IM_InitText();
  }
}


//==========================================================================
//
//
//
//==========================================================================

// specifies current state
float intertime;

float HubCount;
string HubText;

name TextFlat;
int TextPic;

bool imDrawWholeText;
int hubTextHeight;
int hubTextWidth;


//==========================================================================
//
//  IM_InitText
//
//==========================================================================
void IM_InitText () {
  imDrawWholeText = false;

  if (ClGame.deathmatch || !ClGame.im.Text) {
    CmdBuf_AddText("TeleportNewMap\n");
    interstate = IMS_Done;
    if (Background) Background.State = IntermissionBackground::STATE_Done;
    return;
  }

  if (ClGame.im.bTextIsLump) {
    HubText = LoadTextLump(name(ClGame.im.Text));
  } else {
    HubText = ClGame.im.Text;
  }
  HubCount = float(HubText.length)*TEXTSPEED+TEXTWAIT;

  hubTextHeight = -1; // later

  TextFlat = '';
  TextPic = 0;
  if (ClGame.im.TextPic) {
    TextPic = R_RegisterPic(ClGame.im.TextPic);
  } else if (ClGame.im.TextFlat) {
    TextFlat = ClGame.im.TextFlat;
  }

  interstate = IMS_Text;
  intertime = 0.0;

  if (ClGame.im.TextMusic) {
    CmdBuf_AddText(va("music loop %n\n", ClGame.im.TextMusic));
  } else {
    if (checkForDoom2()) {
#ifdef FIXME
      S_StartSong("d_read_m", P_GetCDEnd1Track(), true);
#else
      CmdBuf_AddText("music loop d_read_m\n");
#endif
    } else {
#ifdef FIXME
      S_StartSong("D_VICTOR", P_GetCDEnd1Track(), true);
#else
      CmdBuf_AddText("music loop D_VICTOR\n");
#endif
    }
  }
}


final int IM_GetCurrTextLength () {
  if (imDrawWholeText) return HubText.length;
  return clamp(int((intertime-0.3)/TEXTSPEED), 0, HubText.length);
}


//==========================================================================
//
//  IM_DrawText
//
//==========================================================================
void IM_DrawText () {
  SetSize(GetVirtualWidth(), GetVirtualHeight());
  // erase the entire screen to a tiled background
       if (TextPic) DrawFullScreenPic(TextPic);
  else if (TextFlat) FillRectWithFlat(0, 0, GetVirtualWidth(), GetVirtualHeight(), TextFlat);
  else R_FillRect(0, 0, GetVirtualWidth(), GetVirtualHeight(), 0);

  // draw some of the text onto the screen
  //int count = clamp(int((intertime-0.3)/TEXTSPEED), 0, HubText.length);
  int count = IM_GetCurrTextLength();

  SetFont('smallfont');
  SetTextAlign(hleft, vtop);
  if (hubTextHeight < 0) {
    hubTextHeight = max(8, TextHeight(HubText));
    hubTextWidth = max(8, TextWidth(HubText));
    //writeln(HubText);
    //writeln("text size: ", hubTextWidth, "x", hubTextHeight);
  }
  DrawText((GetVirtualWidth()-hubTextWidth)/2, (GetVirtualHeight()-hubTextHeight)/2, HubText[0..count]);
}


//==========================================================================
//
//  IM_UpdateText
//
//==========================================================================
void IM_UpdateText (float DeltaTime) {
  intertime += DeltaTime;
  if (ClGame.skipintermission && !imDrawWholeText && IM_GetCurrTextLength() < HubText.length) {
    imDrawWholeText = true;
    ClGame.skipintermission = false;
    return;
  }
  if (ClGame.skipintermission || intertime > HubCount) {
    ClGame.skipintermission = false;
    CmdBuf_AddText("TeleportNewMap\n");
    interstate = IMS_Done;
    if (Background) Background.State = IntermissionBackground::STATE_Done;
  }
}


//==========================================================================
//
//  OnVisibilityChanged
//
//==========================================================================
override void OnVisibilityChanged (bool bNewVisibility) {
  bTickEnabled = bNewVisibility;
  if (Background) Background.bTickEnabled = bNewVisibility;
  if (bNewVisibility) FixWidgetSize(); else RestoreWidgetSize();
}


defaultproperties {
  bTickEnabled = true;
  Focusable = true;
  Width = 640;
  Height = 480;
}
