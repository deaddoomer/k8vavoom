//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//
//  common Object things, shared between VaVoom and vccrun
//
//==========================================================================
// [internal] fields won't be touched by initialization (and other object copying duties)
// don't use the following fields
native readonly private transient [internal] void *__CxxVTable;
native readonly private transient [internal] void *__VTable;
native readonly private transient [internal] int __ObjectIndex;
native readonly protected transient [internal] int __ObjectUniqueId;
native readonly private transient [internal] int __ObjectFlags;
// object class
native readonly transient [internal] class Class;

native void Destroy ();
native final bool IsA (name CheckName);
native final bool IsDestroyed (); // checks "delayed destroy" flag
native static final void GC_CollectGarbage (optional bool destroyDelayed);
native static final int GC_AliveObjects { get; }
native static final int GC_LastCollectedObjects { get; }
native static final float GC_LastCollectDuration { get; } // in seconds
native static final float GC_LastCollectTime { get; } // in seconds
native static final bool GC_MessagesAllowed { get; set; }

#include "RTTI.vc"


//**************************************************************************
// not needed anymore (you can use `int.min` and `int.max`)
const int MININT = 0x80000000;
const int MAXINT = 0x7fffffff;


//==========================================================================
//
//  3D math - vectors and planes
//
//==========================================================================
vector TVec {
  float x;
  float y;
  float z;
};


vector TAVec {
  float pitch;
  float yaw;
  float roll;
};


struct TPlane {
  TVec normal;
  float dist;
  /*
  int __type;
  int __signbits;
  int __reserved1;
  int __reserved2;
  */
};


//**************************************************************************
// Keys and buttons
enum {
  K_ESCAPE = 27,
  K_ENTER = 13,
  K_TAB = 9,
  K_BACKSPACE = 8,

  K_SPACE = 32,

  K_N0 = 48, K_N1, K_N2, K_N3, K_N4, K_N5, K_N6, K_N7, K_N8, K_N9,

  K_a = 97, K_b, K_c, K_d, K_e, K_f,  K_g, K_h, K_i, K_j, K_k, K_l,
  K_m, K_n, K_o, K_p, K_q, K_r, K_s, K_t, K_u, K_v, K_w, K_x, K_y, K_z,

  K_FIRST_CONTROL_KEYCODE = 0x80,

  K_UPARROW = 0x80, K_LEFTARROW, K_RIGHTARROW, K_DOWNARROW,
  K_INSERT, K_DELETE, K_HOME, K_END, K_PAGEUP, K_PAGEDOWN,

  K_PAD0, K_PAD1, K_PAD2, K_PAD3, K_PAD4, K_PAD5, K_PAD6, K_PAD7, K_PAD8, K_PAD9,

  K_NUMLOCK,
  K_PADDIVIDE, K_PADMULTIPLE,
  K_PADMINUS, K_PADPLUS,
  K_PADENTER, K_PADDOT,

  K_CAPSLOCK,
  K_BACKQUOTE,

  K_F1, K_F2, K_F3, K_F4, K_F5, K_F6, K_F7, K_F8, K_F9, K_F10, K_F11, K_F12,

  K_LSHIFT, K_RSHIFT,
  K_LCTRL, K_RCTRL,
  K_LALT, K_RALT,

  K_LWIN, K_RWIN,
  K_MENU,

  K_PRINTSCRN,
  K_SCROLLLOCK,
  K_PAUSE,

  K_MOUSE1, K_MOUSE2, K_MOUSE3, K_MOUSE4, K_MOUSE5,
  K_MOUSE6, K_MOUSE7, K_MOUSE8, K_MOUSE9,
  K_MWHEELUP, K_MWHEELDOWN,

  K_JOY1, K_JOY2, K_JOY3, K_JOY4, K_JOY5, K_JOY6, K_JOY7, K_JOY8, K_JOY9,
  K_JOY10, K_JOY11, K_JOY12, K_JOY13, K_JOY14, K_JOY15, K_JOY16,

  K_MOUSE_FIRST = K_MOUSE1,
  K_MOUSE_LAST = K_MWHEELDOWN,

  K_MOUSE_BUTTON_FIRST = K_MOUSE1,
  K_MOUSE_BUTTON_LAST = K_MOUSE9,

  K_JOY_FIRST = K_JOY1,
  K_JOY_LAST = K_JOY16,
};


// [input] event types
enum {
  ev_keydown,
  ev_keyup,
  ev_mouse,
  ev_joystick,
  // extended events
  ev_uimouse,
  ev_winfocus, // data1: focused
  // only for vccrun
  ev_timer, // data1: timer id
  ev_closequery,
  // socket library
  ev_socket, // see below
  // for neoUI library
  ev_neoui = 69,
  ev_user = 666,
};


// all events except `evsock_sqempty` and `evsock_error` must be either eaten, or cancelled, or
// socked will be destroyed
enum {
  evsock_connected,
  evsock_disconnected, // autodestruct
  evsock_cantconnect, // autodestruct
  evsock_gotdata, // received some data
  evsock_sqempty, // sent queue is empty (generated when all queued data was sent)
  evsock_gotclient, // new connection comes for listening sockets
  evsock_error, // some error occured, socket will be destroyed after dispatching this message
  evsock_timeout, // timeout, socket will be destroyed after dispatching this message
}

/*
  ev_socket event:
    data1: subevent type
    data2: socket id
    data3: socketid for "gotclient"

  if you will not "eat" "gotdata" event, socket will be closed
  if you will not send data or ping socket, nothing will happen until timeout

  if you will not accept "gotclient" event, client socket will be closed
 */


// event structure
struct event_t {
  int type;  // event type
  int data1; // keys / mouse / joystick buttons
  int data2; // mouse / joystick x move
  int data3; // mouse / joystick y move
  //int flags; // EFlag.XXX bitset
  bool eaten;
  bool cancelled;
  bool bubbling;
  bool deleteObj; // new UI dispatcher should delete `obj`
  // for new UI
  Object obj; // usually `none`, can be used as event source
  Object dest; // usually `none`, used as "destination widget" in UI system
  // for key
  alias keycode = data1;
  // for ev_mouse
  alias dx = data2;
  alias dy = data3;
  // for ev_uimouse
  alias x = data2;
  alias y = data3;
  // for focus
  alias focused = data1;
  // for timer
  alias timerid = data1;
  // for socket
  alias sockev = data1;
  alias sockid = data2;
  alias sockdata = data3;
  // modifiers/buttons state
  // modifiers state changed *after* processing an even
  // i.e. if `K_?CTRL` is pressed, the flag will be set after calling `onEvent()`,
  // and if `K_?CTRL` is released, the flag will be reset after calling `onEvent()`
  bool bCtrl; // any
  bool bAlt; // any
  bool bShift; // any
  bool bHyper; // any
  bool bLMB;
  bool bMMB;
  bool bRMB;
  bool bCtrlLeft;
  bool bAltLeft;
  bool bShiftLeft;
  bool bCtrlRight;
  bool bAltRight;
  bool bShiftRight;
};

bitenum ModMask {
  Empty = none,
  Ctrl,
  Alt,
  Shift,
  Hyper,
  LMB,
  MMB,
  RMB,
  CtrlLeft,
  AltLeft,
  ShiftLeft,
  CtrlRight,
  AltRight,
  ShiftRight,
}

static final ModMask eventBuildModMask (const ref event_t evt) {
  ModMask res = ModMask.Empty;
  if (evt.bCtrl) res |= ModMask.Ctrl;
  if (evt.bAlt) res |= ModMask.Alt;
  if (evt.bShift) res |= ModMask.Shift;
  if (evt.bHyper) res |= ModMask.Hyper;
  if (evt.bLMB) res |= ModMask.LMB;
  if (evt.bMMB) res |= ModMask.MMB;
  if (evt.bRMB) res |= ModMask.RMB;
  if (evt.bCtrlLeft) res |= ModMask.CtrlLeft;
  if (evt.bAltLeft) res |= ModMask.AltLeft;
  if (evt.bShiftLeft) res |= ModMask.ShiftLeft;
  if (evt.bCtrlRight) res |= ModMask.CtrlRight;
  if (evt.bAltRight) res |= ModMask.AltRight;
  if (evt.bShiftRight) res |= ModMask.ShiftRight;
  return res;
}

native static final string GetInputKeyStrName (int kcode);
native static final int GetInputKeyCode (string kname);


// returns `false` if queue is full
// add event to the bottom of the current queue
// it is unspecified if posted event will be processed in the current
// frame, or in the next one
native static final bool PostEvent (const ref event_t ev);

// returns `false` if queue is full
// add event to the top of the current queue
// it is unspecified if posted event will be processed in the current
// frame, or in the next one
native static final bool InsertEvent (const ref event_t ev);

// check if event queue has any unprocessed events
// returns number of events in queue or 0
// it is unspecified if unprocessed events will be processed in the current
// frame, or in the next one
native static final int CountQueuedEvents ();

// peek event from queue
// event with index 0 is the top one
native static final bool PeekEvent (int idx, out event_t ev);

// get top event from queue
// returns `false` if there are no more events
native static final bool GetEvent (out event_t ev);

// returns maximum size of event queue
// note that event queue may be longer that the returned value
native static final int GetEventQueueSize ();


//==========================================================================
//
//              COMMON BUILTINS
//
//==========================================================================

// ////////////////////////////////////////////////////////////////////////// //
// error functions

// shutdown client and server, go to title
native static final void Error (string format, ...) [printf,1];
// abort with error
native static final void FatalError (string format, ...) [printf,1];


// ////////////////////////////////////////////////////////////////////////// //
// math functions (angles are in degrees)

native static final int round (float v) [builtin RoundF2I];
native static final float fround (float v) [builtin RoundF2F];
native static final int trunc (float v) [builtin TruncF2I];
native static final float ftrunc (float v) [builtin TruncF2F];
native static final float fceil (float v) [builtin FloatCeil];
native static final float ffloor (float v) [builtin FloatFloor];
//native static final float frac (float v) [builtin FloatFrac];
//native static final float fint (float v) [builtin FloatInt];

// linear interpolation between `a` and `b`; `delta` should be in [0..1]
native static final float flerp (float a, float b, float delta) [builtin FloatLerp];
// this will round the result
native static final int lerp (int a, int b, float delta) [builtin IntLerp];

// `smoothstep` performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1
// results are undefined if edge0  edge1
native static final float smoothstep (float edge0, float edge1, float x) [builtin FloatSmoothStep];
native static final float smoothstepPerlin (float edge0, float edge1, float x) [builtin FloatSmoothStepPerlin];

native static final float AngleMod360 (float angle); // normalises angle in range 0..360
native static final float AngleMod180 (float angle); // normalises angle in range -180..180
native static final float deg2rad (float angle) [builtin DegToRad]; // degrees --> radians
native static final float rad2deg (float angle) [builtin RadToDeg]; // radians -> degrees
native static final int abs (int val) [builtin IntAbs]; // absolute value
native static final float fabs (float val) [builtin FloatAbs]; // absolute value
native static final int sign (int val) [builtin IntSign]; // sign (-1, 0, 1)
native static final float fsign (float val) [builtin FloatSign]; // sign (-1, 0, 1)
native static final int Min (int v1, int v2) [builtin IntMin]; // minimal value
native static final int min (int v1, int v2) [builtin IntMin]; // minimal value
native static final float FMin (float v1, float v2) [builtin FloatMin]; // minimal value
native static final float fmin (float v1, float v2) [builtin FloatMin]; // minimal value
native static final int Max (int v1, int v2) [builtin IntMax]; // maximal value
native static final int max (int v1, int v2) [builtin IntMax]; // maximal value
native static final float FMax (float v1, float v2) [builtin FloatMax]; // maximal value
native static final float fmax (float v1, float v2) [builtin FloatMax]; // maximal value
native static final int Clamp (int Val, int Min, int Max) [builtin IntClamp]; // clamped value
native static final int clamp (int Val, int Min, int Max) [builtin IntClamp]; // clamped value
native static final float FClamp (float Val, float Min, float Max) [builtin FloatClamp]; // clamped value
native static final float fclamp (float Val, float Min, float Max) [builtin FloatClamp]; // clamped value
native static final TVec vclamp (const TVec v, const float Min, const float Max) [builtin VectorClamp]; // clamped value
native static final float sin (float angle) [builtin Sin]; // sine
native static final float cos (float angle) [builtin Cos]; // cosine
native static final void sincos (float angle, out float sin, out float cos) [builtin SinCos];
native static final float tan (float angle) [builtin Tan]; // tangent
native static final float asin (float x) [builtin ASin]; // arcsine
native static final float acos (float x) [builtin ACos]; // arccosine
native static final float atan (float slope) [builtin ATan]; // arctangent
native static final float atan2 (float y, float x) [builtin ATan2]; // arctangent
native static final float sqrt (float x) [builtin Sqrt]; // square root
native static final float length (const TVec vec) [builtin VecLength]; // vector length
native static final float lengthSquared (const TVec vec) [builtin VecLengthSquared]; // vector length
alias Length = length;
alias LengthSquared = lengthSquared;
// vector length without z component
native static final float length2D (const TVec vec) [builtin VecLength2D];
native static final float length2DSquared (const TVec vec) [builtin VecLength2DSquared];
alias Length2D = length2D;
alias length2d = length2D;
alias Length2DSquared = length2DSquared;
alias length2dSquared = length2DSquared;
// normalises vector
native static final TVec normalise (const TVec vec) [builtin VecNormalize];
alias Normalise = normalise;
alias Normalize = normalise;
alias normalize = normalise;
// normalises 2d vector (ignores z)
native static final TVec normalise2D (const TVec vec) [builtin VecNormalize2D];
alias Normalise2D = normalise2D;
alias normalise2d = normalise2D;
// dot product
native static final float dot (const TVec v1, const TVec v2) [builtin VecDot];
alias DotProduct = dot;
// dot product of 2d vector (ignores z)
native static final float dot2d (const TVec v1, const TVec v2) [builtin VecDot2D];
alias DotProduct2D = dot2d;
alias dot2D = dot2d;
// cross product (perpendicular vector)
native static final TVec cross (const TVec v1, const TVec v2) [builtin VecCross];
alias CrossProduct = cross;
// 2d cross product (signed magnitude, z, as x and y are effectively zero in 2d)
native static final float cross2d (const TVec v1, const TVec v2) [builtin VecCross2D];
alias CrossProduct2D = cross2d;
alias cross2D = cross2d;
// creates vectors for given angle vector
native static final void AngleVectors (const TAVec angles, out TVec forward, optional out TVec right, optional out TVec up);
// simplified version of AngleVectors, creates only forward vector (this is slightly faster)
native static final void AngleVector (const TAVec angles, out TVec forward);
// create angle vector for a vector
native static final void VectorAngles (const TVec vec, out TAVec angles);
native static final float VectorAngleYaw (const TVec vec);
native static final float VectorAnglePitch (const TVec vec);
native static final TVec AngleYawVector (const float yaw);
// get z of point with given x and y coords (don't try to use it on a vertical plane)
native static final float GetPlanePointZ (const ref TPlane plane, const TVec point);
native static final float GetPlanePointZRev (const ref TPlane plane, const TVec point);
// returns side 0 (front), or 1 (back)
native static final int PointOnPlaneSide (const TVec point, const ref TPlane plane);
// returns side 0 (front), 1 (back), or 2 (on)
native static final int PointOnPlaneSide2 (const TVec point, const ref TPlane plane);
// rotates a direction vector
native static final TVec RotateDirectionVector (const TVec vec, const TAVec rot);
// rotates vector around Z axis
native static final void VectorRotateAroundZ (ref TVec vec, float angle);
// rotates vector around another vector
native static final TVec RotateVectorAroundVector (const TVec Vector, const TVec Axis, float angle);
// use on `sec_plane_t` to check if the plane is non-sloped
native static final bool IsPlainFloor (const ref TPlane plane); // valid only for floors
native static final bool IsPlainCeiling (const ref TPlane plane); // valid only for ceilings
native static final bool IsSlopedFlat (const ref TPlane plane);
native static final bool IsVerticalPlane (const ref TPlane plane);

native static final TVec RayLineIntersection2D (const TVec rayO, const TVec rayE, const TVec vv1, const TVec vv2);
native static final TVec RayLineIntersection2DDir (const TVec rayO, const TVec rayDir, const TVec vv1, const TVec vv2);

//TODO: move to native code?
bool LinesCross (TVec lav1, TVec lav2, TVec lbv1, TVec lbv2, optional out TVec crosspt) {
  float x11 = lav1.x, y11 = lav1.y;
  float x12 = lav2.x, y12 = lav2.y;
  float x21 = lbv1.x, y21 = lbv1.y;
  float x22 = lbv2.x, y22 = lbv2.y;
  float maxx1 = fmax(x11, x12), maxy1 = fmax(y11, y12);
  float minx1 = fmin(x11, x12), miny1 = fmin(y11, y12);
  float maxx2 = fmax(x21, x22), maxy2 = fmax(y21, y22);
  float minx2 = fmin(x21, x22), miny2 = fmin(y21, y22);

  if (minx1 > maxx2 || maxx1 < minx2 || miny1 > maxy2 || maxy1 < miny2) return false;

  float dx1 = x12-x11, dy1 = y12-y11; // first line projection to x & y axes
  float dx2 = x22-x21, dy2 = y22-y21; // second line projection to x & y axes
  float dxx = x11-x21, dyy = y11-y21;

  float mul;
  float div = (dy2*dx1-dx2*dy1);
  if (div == 0.0) return false; // parallel lines
  if (div > 0.0) {
    mul = (dx1*dyy-dy1*dxx);
    if (mul < 0.0 || mul > div) return false; // first line crossing out of limits
    mul = (dx2*dyy-dy2*dxx);
    if (mul < 0.0 || mul > div) return false; // second line crossing out of limits
  }

  mul = -(dx1*dyy-dy1*dxx);
  if (mul < 0.0 || mul > -div) return false; // first line crossing out of limits
  mul = -(dx2*dyy-dy2*dxx);
  if (mul < 0.0 || mul > -div) return false; // second line crossing out of limits

  if (specified_crosspt) {
    float factor = (dx2*dyy-dy2*dxx)/div;
    crosspt = vector(x11+factor*(x21-x11), y11+factor*(y21-y11));
  }

  return true;
}

// ////////////////////////////////////////////////////////////////////////// //
// plane functions
//TODO: move to native code?

// initialises vertical plane from point and direction
static final void PlaneForPointDir (out TPlane plane, TVec point, TVec dir) {
  dir.z = 0;
  if (!dir) FatalError("oops");
  plane.normal = vector(dir.y, -dir.x).normalise2D;
  plane.dist = DotProduct(point, plane.normal);
}

// initialises vertical plane from point and direction
static final void PlaneForPointNormal (out TPlane plane, TVec point, TVec norm, optional bool normNormalised) {
  norm.z = 0;
  if (!norm) FatalError("oops");
  plane.normal = (normNormalised ? norm : vector(norm.x, norm.y).normalise2D);
  plane.dist = DotProduct(point, plane.normal);
}

// initialises vertical plane from two points
static final void PlaneForLine (out TPlane plane, TVec pointA, TVec pointB) {
  PlaneForPointDir(out plane, pointA, pointB-pointA);
}

// returns the point where the line p0-p1 intersects this plane
static final float PlaneLineIntersect (const ref TPlane plane, TVec p0, TVec p1) {
  auto difv = p1-p0;
  float dd = -plane.normal.dot(difv);
  if (!dd) return -666;
  //return (plane.normal.dot(p0)-plane.dist)/dd;
  return (p0.dot(plane.normal)-plane.dist)/dd;
}

static final TVec PlaneProject (const ref TPlane plane, TVec v) {
  return v-(v-plane.normal*plane.dist).dot(plane.normal)*plane.normal;
}


// ////////////////////////////////////////////////////////////////////////// //
// returns number of planes created (0 for point)
// max result is six planes: two for line, two+two axial bevels
struct LinePlanes {
  TPlane[6] planes;
  int count;
}

static final void buildLinePlanes (out LinePlanes lpl, TVec a, TVec b) {
  a.z = 0;
  b.z = 0;
  if (a == b) {
    // point, create four axial planes to represent it as a box
    lpl.planes[0].normal = vector( 0, -1); lpl.planes[0].dist = -a.y; // top
    lpl.planes[1].normal = vector( 0,  1); lpl.planes[1].dist = a.y; // bottom
    lpl.planes[2].normal = vector(-1,  0); lpl.planes[2].dist = -a.x; // left
    lpl.planes[3].normal = vector( 1,  0); lpl.planes[3].dist = a.x; // right
    lpl.count = 4; // four planes created
    return;
  }
  // horizontal line?
  if (a.y == b.y) {
    lpl.planes[0].normal = vector( 0, -1); lpl.planes[0].dist = -a.y; // top
    lpl.planes[1].normal = vector( 0,  1); lpl.planes[1].dist = a.y; // bottom
    lpl.planes[2].normal = vector(-1,  0); lpl.planes[2].dist = -fmin(a.x, b.x); // left
    lpl.planes[3].normal = vector( 1,  0); lpl.planes[3].dist = fmax(a.x, b.x); // right
    lpl.count = 4; // four planes created
    return;
  }
  // vertical line?
  if (a.x == b.x) {
    lpl.planes[0].normal = vector(-1,  0); lpl.planes[0].dist = -a.x; // left
    lpl.planes[1].normal = vector( 1,  0); lpl.planes[1].dist = a.x; // right
    lpl.planes[2].normal = vector( 0, -1); lpl.planes[2].dist = -fmin(a.y, b.y); // top
    lpl.planes[3].normal = vector( 0,  1); lpl.planes[3].dist = fmax(a.y, b.y); // bottom
    lpl.count = 4; // four planes created
    return;
  }
  // ok, not an ortho-axis line, create line planes the old way
  // two line planes
  PlaneForLine(out lpl.planes[0], a, b);
  PlaneForLine(out lpl.planes[1], b, a);
  // caps
  lpl.planes[2].normal = vector(-1,  0); lpl.planes[2].dist = -fmin(a.x, b.x); // left
  lpl.planes[3].normal = vector( 1,  0); lpl.planes[3].dist = fmax(a.x, b.x); // right
  lpl.planes[4].normal = vector( 0, -1); lpl.planes[4].dist = -fmin(a.y, b.y); // top
  lpl.planes[5].normal = vector( 0,  1); lpl.planes[5].dist = fmax(a.y, b.y); // bottom
  lpl.count = 6; // six planes created
}


// ////////////////////////////////////////////////////////////////////////// //
const float CLIP_EPSILON = 0.125f;

enum HitType {
  HT_None,
  HT_Point,
  // sides
  HT_Top,
  HT_Bottom,
  HT_Left,
  HT_Right,
}

// returns collision time, -1 if started inside, exactly 1 if no collision
// in both such cases, `hitNormal` is undefined, as we have no hit plane
// the moving thing is AABB
// returns contact point in `contactPoint`
// actually, `contactPoint` has little sense for non-point hits, and is somewhat arbitrary
static final float sweepLineAABB (TVec lineA, TVec lineB, TVec vstart, TVec vend, TVec bmin, TVec bmax,
                                  optional out TPlane hitPlane, optional out TVec contactPoint, optional out HitType hitType)
{
  LinePlanes linePlanes;
  buildLinePlanes(out linePlanes, lineA, lineB);

  hitType = HitType.HT_None;

  float ifrac = -1.0f;
  float ofrac = 1.0f;

  bool startsOut = false;
  //bool endsOut = false;
  int phit = -1;
  bool lastContactWasPoint = false;

  foreach (auto pidx; 0..linePlanes.count) {
    TPlane *plane = &linePlanes.planes[pidx];
    // box
    TVec offset = vector((plane.normal.x < 0 ? bmax.x : bmin.x), (plane.normal.y < 0 ? bmax.y : bmin.y), (plane.normal.z < 0 ? bmax.z : bmin.z));
    // adjust the plane distance apropriately for mins/maxs
    float dist = plane.dist-DotProduct(offset, plane.normal);
    float idist = DotProduct(vstart, plane.normal)-dist;
    float odist = DotProduct(vend, plane.normal)-dist;

    if (idist <= 0 && odist <= 0) continue; // doesn't cross this plane, don't bother

    if (idist > 0) {
      startsOut = true;
      // if completely in front of face, no intersection with the entire brush
      if (odist >= CLIP_EPSILON || odist >= idist) return 1.0f;
    }
    //if (odist > 0) endsOut = true;

    // crosses plane
    if (idist > odist) {
      // line is entering into the brush
      float fr = fmax(0.0f, (idist-CLIP_EPSILON)/(idist-odist));
      if (fr > ifrac) {
        ifrac = fr;
        phit = pidx;
        lastContactWasPoint = (plane.normal.x && plane.normal.y);
      } else if (!lastContactWasPoint && fr == ifrac && plane.normal.x && plane.normal.y) {
        // prefer point contacts (rare case, but why not?)
        lastContactWasPoint = true;
        phit = pidx;
      }
    } else {
      // line is leaving the brush
      float fr = fmin(1.0f, (idist+CLIP_EPSILON)/(idist-odist));
      if (fr < ofrac) ofrac = fr;
    }
  }

  // all planes have been checked, and the trace was not completely outside the brush
  if (!startsOut) {
    // original point was inside brush
    return -1.0f;
  }

  if (ifrac < ofrac) {
    if (ifrac > -1) {
      ifrac = fclamp(ifrac, 0.0f, 1.0f);
      if (ifrac == 0 || ifrac == 1) return ifrac; // just in case
      hitPlane = linePlanes.planes[phit];
      // check what kind of hit this is
      if (!hitPlane.normal.y) {
        // left or right side of the box
        hitType = (hitPlane.normal.x < 0 ? HitType.HT_Right : HitType.HT_Left);
        contactPoint =
          lineA.x < lineB.x ?
            (hitType == HitType.HT_Right ? lineA : lineB) :
            (hitType == HitType.HT_Right ? lineB : lineA);
      } else if (!hitPlane.normal.x) {
        // top or down side of the box
        hitType = (hitPlane.normal.y < 0 ? HitType.HT_Bottom : HitType.HT_Top);
        contactPoint =
          lineA.y < lineB.y ?
            (hitType == HitType.HT_Bottom ? lineA : lineB) :
            (hitType == HitType.HT_Bottom ? lineB : lineA);
      } else {
        // point hit
        hitType = HitType.HT_Point;
        contactPoint = vector((hitPlane.normal.x < 0 ? bmax.x : bmin.x), (hitPlane.normal.y < 0 ? bmax.y : bmin.y), bmin.z);
        contactPoint += vstart+(vend-vstart)*ifrac;
      }
      return ifrac;
    }
  }

  return 1.0;
}


// ////////////////////////////////////////////////////////////////////////// //
// random numbers

// floating random number 0.0 ... 0.999999
native static final float Random ();
// floating random number 0.0 ... 1.0
native static final float FRandomFull ();
// floating random number [minv..maxv] (inclusive)
native static final float FRandomBetween (float minv, float maxv);
// integer random number 0 .. 255
native static final int P_Random ();
// generates a random seen in range [1..0xffff_ffff]
native static final int GenRandomSeedU32 ();

// http://burtleburtle.net/bob/rand/smallprng.html
struct BJPRNGCtx {
  int a, b, c, d;
}

native static final void bjprngSeed (out BJPRNGCtx ctx, int aseed);
// full 32-bit value (so it can be negative)
native static final int bjprngNext (ref BJPRNGCtx ctx);
// [0..1) (WARNING! not really uniform!)
native static final float bjprngNextFloat (ref BJPRNGCtx ctx);



// ////////////////////////////////////////////////////////////////////////// //
// string functions

// string length (utf8-aware)
native static final int strlenutf8 (string s);
// compare strings
native static final int strcmp (string s1, string s2);
// compare strings ingnoring case
native static final int stricmp (string s1, string s2);
// compare names ingnoring case
native static final int nameicmp (name s1, name s2);
// compare string and name ingnoring case
native static final int namestricmp (name s1, string s2);
// convert string to lowercase
native static final string strlwr (string s);
// convert string to uppercase
native static final string strupr (string s);
// gets a substring (utf8-aware)
native static final string substrutf8 (string Str, int Start, int Len);
// creates one-char non-utf8 string from the given char code&0xff; 0 is allowed
native static final string strFromChar (int ch);
// creates one-char utf8 string from the given char code (or empty string if char code is invalid); 0 is allowed
native static final string strFromCharUtf8 (int ch);
// gets a substring (not utf8-aware)
native static final string strmid (string Str, int Start, optional int Len);
// gets left part of a string (not utf8-aware)
native static final string strleft (string Str, int len);
// gets right part of a string (not utf8-aware)
native static final string strright (string Str, int len);
// gets right part of a string (not utf8-aware); default ch is space
native static final string strrepeat (int len, optional int ch);
// creates string from a number
native static final string strFromInt (int v);
// creates string from a number
native static final string strFromFloat (float v);
// do glob matching (knows '*' and '?')
native static final bool globmatch (const string str, const string pat, optional bool caseSensitive/*=true*/);
// returns 0-based index or -1
// negative startpos means offset from string end; startpos doesn't affect result
native static final int strIndexOf (const string str, const string pat, optional int startpos, optional bool caseSensitive/*=true*/);
// returns 0-based index or -1
// negative startpos means offset from string end; startpos doesn't affect result
native static final int strLastIndexOf (const string str, const string pat, optional int startpos, optional bool caseSensitive/*=true*/);

// does varargs print into a temporary buffer
native static final string va (string format, ...) [printf,1];

// converts string to integer
native static final int atoi (string str, optional out bool err);
// converts string to float
native static final float atof (string str, optional out bool err);

// checks if string starts with given string
native static final bool StrStartsWith (string Str, string Check, optional bool caseSensitive/*=true*/);
alias strStartsWith = StrStartsWith;
// checks if string ends with given string
native static final bool StrEndsWith (string Str, string Check, optional bool caseSensitive/*=true*/);
alias strEndsWith = StrEndsWith;
// replaces substrings with another string
native static final string StrReplace (string Str, string Search, string Replacement);
alias strReplace = StrReplace;


// ////////////////////////////////////////////////////////////////////////// //
//  Printing to console

// print to console
native static final void print (string format, ...) [printf,1];
// print to console only when developer == 1
native static final void dprint (string format, ...) [printf,1];
// print warning to console
native static final void printwarn (string format, ...) [printf,1];


// ////////////////////////////////////////////////////////////////////////// //
// type conversions

// converts name to internal index (as name is just an int internally)
native static final int NameToIIndex (name Name) [builtin NameToIIndex];


// ////////////////////////////////////////////////////////////////////////// //
// class methods

native static final class FindClass (name Name);
native static final class FindClassNoCase (name Name);
native static final class FindClassLowerCase (name Name);
native static final bool ClassIsChildOf (class SomeClass, class BaseClass);
native static final name GetClassName (class C);
native static final class GetClassParent (class C);
native static final class GetClassReplacement (class C);
native static final spawner class GetCompatibleClassReplacement (class CType, class C); // returns `none` if replacement is not compatible with `CType`
native static final class GetClassReplacee (class C);
native static final state FindClassState (class C, name StateName, optional name SubLabel, optional bool exact);
native static final int GetClassNumOwnedStates (class C);
native static final state GetClassFirstState (class C);
native static final name GetClassGameObjName (class C);

// ////////////////////////////////////////////////////////////////////////// //
// state methods

enum StateTicKind {
  Normal,
  Random, // random(Arg1, Arg2)
}

native static final bool StateIsInRange (state State, state Start, state End, int MaxDepth);
native static final bool StateIsInSequence (state State, state Start);
native static final name GetStateSpriteName (state State);
native static final int GetStateSpriteFrame (state State);
native static final int GetStateSpriteFrameWidth (state State);
native static final int GetStateSpriteFrameHeight (state State);
native static final void GetStateSpriteFrameSize (state State, out int w, out int h);
native static final float GetStateDuration (state State);
native static final state GetStatePlus (state S, int Offset, optional bool IgnoreJump);
native static final state GetNextState (state State);
native static final state GetNextStateInProg (state State);
native static final bool StateHasAction (state State);
native static final void CallStateAction (Object actobj, state State);
native static final int GetStateSpriteFrameOfsX (state State);
native static final int GetStateSpriteFrameOfsY (state State);
native static final void GetStateSpriteFrameOffset (state State, out int dx, out int dy);
native static final int GetStateMisc1 (state State);
native static final int GetStateMisc2 (state State);
native static final void SetStateMisc1 (state State, int v);
native static final void SetStateMisc2 (state State, int v);
native static final StateTicKind GetStateTicKind (state State);
native static final int GetStateArgN (state State, int argn); // argn is zero-based
native static final void SetStateArgN (state State, int argn, int v); // argn is zero-based
native static final int GetStateFRN (state State);
native static final void SetStateFRN (state State, int v);


// ////////////////////////////////////////////////////////////////////////// //
// iterators

native static final iterator AllObjects (class BaseClass, out Object Obj);
native static final iterator AllClasses (class BaseClass, out class Class);
native static final iterator AllClassStates (class BaseClass, out state State);


// ////////////////////////////////////////////////////////////////////////// //
// misc

// default `skipReplacement` is:
//   `true` for VaVoom and VCC
//   `false` for vccrun
native static final spawner Object SpawnObject (class cid, optional bool skipReplacement);


//==========================================================================
//
//  date/time utils
//
//==========================================================================
struct TTimeVal {
  int secs; // actually, unsigned
  int usecs;
  // for 2030+
  int secshi;
}

struct TDateTime {
  int sec; // [0..60] (yes, *sometimes* it can be 60)
  int min; // [0..59]
  int hour; // [0..23]
  int month; // [0..11]
  int year; // normal value, i.e. 2042 for 2042
  int mday; // [1..31] -- day of the month
  //
  int wday; // [0..6] -- day of the week (0 is sunday)
  int yday; // [0..365] -- day of the year
  int isdst; // is daylight saving time?
}

native static final bool GetTimeOfDay (out TTimeVal tv);
native static final bool DecodeTimeVal (out TDateTime tm, const ref TTimeVal tv);

// see mktime(3)
// `wday`, `yday`, and `isdst` are set on success; `isdst` is used if `usedist` is `true`
native static final bool EncodeTimeVal (out TTimeVal tv, ref TDateTime tm, optional bool usedst);


//==========================================================================
//
//              MISC BUILTINS
//
//==========================================================================
//native final static class FindPkgMObjId (int id, optional name pkgname);
//native final static class FindPkgScriptId (int id, optional name pkgname);
native final static class FindClassByGameObjName (name aname, optional name pkgname);


// ////////////////////////////////////////////////////////////////////////// //
// cvar functions

bitenum {
  CVAR_ARCHIVE, // set to cause it to be saved to config file
  CVAR_USERINFO, // added to userinfo  when changed
  CVAR_SERVERINFO, // added to serverinfo when changed
  CVAR_INIT,  // don't allow change from console at all, but can be set from the command line
  CVAR_LATCH, // save changes until server restart
  CVAR_ROM, // display only, cannot be set by user at all
  CVAR_CHEAT, // can not be changed if cheats are disabled
  CVAR_MODIFIED, // set each time the cvar is changed
  CVAR_FROMMOD, // came from cvarinfo
}

enum {
  CVAR_PREINIT = 0x4000, // CLI change for this cvar should be processed before initializing main game
  CVAR_AlwaysArchive = 0x8000, // always write to config
}

native static final bool CvarExists (name Name); // is cvar exists?
native static final int CvarGetFlags (name Name); // -1: no such var
native static final string GetCvarHelp (name Name); // get cvar help text
native static final void CreateCvar (name Name, string defaultValue, string helpText, optional int flags); // create a new cvar
native static final int GetCvar (name Name); // read int value
native static final void SetCvar (name Name, int value); // set cvar int value
alias GetCvarI = GetCvar; // read int value
alias SetCvarI = SetCvar; // set cvar int value
native static final float GetCvarF (name Name); // read float value
native static final void SetCvarF (name Name, float value); // set cvar float value
native static final string GetCvarS (name Name); // read string value
native static final void SetCvarS (name Name, string value); // set cvar string value
native static final bool GetCvarB (name Name); // read boolean value
native static final void SetCvarB (name Name, bool value); // set cvar boolean value
native static final void CvarUnlatchAll (); // NOOP in network game (so can be called safely)


// ////////////////////////////////////////////////////////////////////////// //
// temporary name set functions
// used to prevent warning spam

// returns `false` if element wasn't in set
native static final bool SetNamePutElement (name setName, name value);
native static final bool SetNameCheckElement (name setName, name value);
