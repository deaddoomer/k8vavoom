//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************
//
//  common Object things, shared between VaVoom and vccrun
//
//==========================================================================

native readonly private transient void *CxxVTable;
native readonly private transient void *VTable;
native readonly private transient int ObjectIndex;
native readonly private transient int ObjectFlags;
native readonly transient class Class;

native void Destroy ();
native final bool IsA (name CheckName);
native final bool IsDestroyed ();
native static final void CollectGarbage (optional bool destroyDelayed);
native static final bool GCMessagesAllowed { get; set; }

native final bool HasFieldByName (name fldname);
native final int GetIntFieldByName (name fldname, optional bool default_value);


//**************************************************************************

const int MININT = 0x80000000;
const int MAXINT = 0x7fffffff;


//==========================================================================
//
//  3D math - vectors and planes
//
//==========================================================================
vector TVec {
  float x;
  float y;
  float z;
};


vector TAVec {
  float pitch;
  float yaw;
  float roll;
};


struct TPlane {
  TVec normal;
  float dist;
  int __type;
  int __signbits;
  int __reserved1;
  int __reserved2;
};


//**************************************************************************
// Keys and buttons
enum {
  K_ESCAPE = 27,
  K_ENTER = 13,
  K_TAB = 9,
  K_BACKSPACE = 8,

  K_SPACE = 32,

  K_N0 = 48, K_N1, K_N2, K_N3, K_N4, K_N5, K_N6, K_N7, K_N8, K_N9,

  K_a = 97, K_b, K_c, K_d, K_e, K_f,  K_g, K_h, K_i, K_j, K_k, K_l,
  K_m, K_n, K_o, K_p, K_q, K_r, K_s, K_t, K_u, K_v, K_w, K_x, K_y, K_z,

  K_FIRST_CONTROL_KEYCODE = 0x80,

  K_UPARROW = 0x80, K_LEFTARROW, K_RIGHTARROW, K_DOWNARROW,
  K_INSERT, K_DELETE, K_HOME, K_END, K_PAGEUP, K_PAGEDOWN,

  K_PAD0, K_PAD1, K_PAD2, K_PAD3, K_PAD4, K_PAD5, K_PAD6, K_PAD7, K_PAD8, K_PAD9,

  K_NUMLOCK,
  K_PADDIVIDE, K_PADMULTIPLE,
  K_PADMINUS, K_PADPLUS,
  K_PADENTER, K_PADDOT,

  K_CAPSLOCK,
  K_BACKQUOTE,

  K_F1, K_F2, K_F3, K_F4, K_F5, K_F6, K_F7, K_F8, K_F9, K_F10, K_F11, K_F12,

  K_LSHIFT, K_RSHIFT,
  K_LCTRL, K_RCTRL,
  K_LALT, K_RALT,

  K_LWIN, K_RWIN,
  K_MENU,

  K_PRINTSCRN,
  K_SCROLLLOCK,
  K_PAUSE,

  K_MOUSE1, K_MOUSE2, K_MOUSE3, K_MOUSE4, K_MOUSE5,
  K_MOUSE6, K_MOUSE7, K_MOUSE8, K_MOUSE9,
  K_MWHEELUP, K_MWHEELDOWN,

  K_JOY1, K_JOY2, K_JOY3, K_JOY4, K_JOY5, K_JOY6, K_JOY7, K_JOY8, K_JOY9,
  K_JOY10, K_JOY11, K_JOY12, K_JOY13, K_JOY14, K_JOY15, K_JOY16,

  K_MOUSE_FIRST = K_MOUSE1,
  K_MOUSE_LAST = K_MWHEELDOWN,

  K_MOUSE_BUTTON_FIRST = K_MOUSE1,
  K_MOUSE_BUTTON_LAST = K_MOUSE9,

  K_JOY_FIRST = K_JOY1,
  K_JOY_LAST = K_JOY16,
};


// [Input] event types.
enum {
  ev_keydown,
  ev_keyup,
  ev_mouse, // for vcc_run: data2/data3 are coords, otherwise deltas
  ev_joystick,
  // extended events for vcc_run
  ev_winfocus, // data1: focused
  ev_timer, // data1: timer id
  ev_closequery,
};


// Event structure.
struct event_t {
  int type;  // event type
  int data1; // keys / mouse / joystick buttons
  int data2; // mouse / joystick x move
  int data3; // mouse / joystick y move
  // for key
  alias keycode = data1;
  // for mouse
  alias x = data2;
  alias y = data3;
  // for focus
  alias focused = data1;
  // for timer
  alias timerid = data1;
#ifdef VCC_STANDALONE_EXECUTOR
  // modifiers/buttons state
  // modifiers state changed *after* processing an even
  // i.e. if `K_?CTRL` is pressed, the flag will be set after calling `onEvent()`,
  // and if `K_?CTRL` is released, the flag will be reset after calling `onEvent()`
  bool bCtrl;
  bool bAlt;
  bool bShift;
  bool bHyper; // not used yet
  bool bLMB;
  bool bMMB;
  bool bRMB;
#endif
};

#ifdef VCC_STANDALONE_EXECUTOR
bitenum ModMask {
  Empty = none,
  Ctrl,
  Alt,
  Shift,
  Hyper,
  LMB,
  MMB,
  RMB,
}

static final ModMask buildModMask (const ref event_t evt) {
  ModMask res = ModMask.Empty;
  if (evt.bCtrl) res |= ModMask.Ctrl;
  if (evt.bAlt) res |= ModMask.Alt;
  if (evt.bShift) res |= ModMask.Shift;
  if (evt.bHyper) res |= ModMask.Hyper;
  if (evt.bLMB) res |= ModMask.LMB;
  if (evt.bMMB) res |= ModMask.MMB;
  if (evt.bRMB) res |= ModMask.RMB;
  return res;
}
#endif


static native final string GetInputKeyStrName (int kcode);
static native final int GetInputKeyCode (string kname);


//==========================================================================
//
//              COMMON BUILTINS
//
//==========================================================================

// ////////////////////////////////////////////////////////////////////////// //
// error functions

// shut down client and server, go to title
native static final void Error (string format, ...) [printf,1];
// exit programm with error
native static final void FatalError (string format, ...) [printf,1];


// ////////////////////////////////////////////////////////////////////////// //
// math functions (angles are in degrees)

native static final int round (float v) [builtin RoundF2I];
native static final float fround (float v) [builtin RoundF2F];
native static final int trunc (float v) [builtin TruncF2I];
native static final float ftrunc (float v) [builtin TruncF2F];
native static final float ceil (float v) [builtin FloatCeil];
native static final float floor (float v) [builtin FloatFloor];
//native static final float frac (float v) [builtin FloatFrac];
//native static final float fint (float v) [builtin FloatInt];

// linear interpolation between `a` and `b`; `delta` should be in [0..1]
native static final float flerp (float a, float b, float delta) [builtin FloatLerp];
// this will round the result
native static final int lerp (int a, int b, float delta) [builtin IntLerp];

// `smoothstep` performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1
// results are undefined if edge0  edge1
native static final float smoothstep (float edge0, float edge1, float x) [builtin FloatSmoothStep];
native static final float smoothstepPerlin (float edge0, float edge1, float x) [builtin FloatSmoothStepPerlin];

native static final float AngleMod360 (float angle); // normalises angle in range 0..360
native static final float AngleMod180 (float angle); // normalises angle in range -180..180
native static final float deg2rad (float angle) [builtin DegToRad]; // degrees --> radians
native static final float rad2deg (float angle) [builtin RadToDeg]; // radians -> degrees
native static final int abs (int val) [builtin IntAbs]; // absolute value
native static final float fabs (float val) [builtin FloatAbs]; // absolute value
native static final int sign (int val) [builtin IntSign]; // sign (-1, 0, 1)
native static final float fsign (float val) [builtin FloatSign]; // sign (-1, 0, 1)
native static final int Min (int v1, int v2) [builtin IntMin]; // minimal value
native static final int min (int v1, int v2) [builtin IntMin]; // minimal value
native static final float FMin (float v1, float v2) [builtin FloatMin]; // minimal value
native static final float fmin (float v1, float v2) [builtin FloatMin]; // minimal value
native static final int Max (int v1, int v2) [builtin IntMax]; // maximal value
native static final int max (int v1, int v2) [builtin IntMax]; // maximal value
native static final float FMax (float v1, float v2) [builtin FloatMax]; // maximal value
native static final float fmax (float v1, float v2) [builtin FloatMax]; // maximal value
native static final int Clamp (int Val, int Min, int Max) [builtin IntClamp]; // clamped value
native static final int clamp (int Val, int Min, int Max) [builtin IntClamp]; // clamped value
native static final float FClamp (float Val, float Min, float Max) [builtin FloatClamp]; // clamped value
native static final float fclamp (float Val, float Min, float Max) [builtin FloatClamp]; // clamped value
native static final float sin (float angle) [builtin Sin]; // sine
native static final float cos (float angle) [builtin Cos]; // cosine
native static final float tan (float angle) [builtin Tan]; // tangent
native static final float asin (float x) [builtin ASin]; // arcsine
native static final float acos (float x) [builtin ACos]; // arccosine
native static final float atan (float slope) [builtin ATan]; // arctangent
native static final float atan2 (float y, float x) [builtin ATan2]; // arctangent
native static final float sqrt (float x) [builtin Sqrt]; // square root
native static final float length (const TVec vec) [builtin VecLength]; // vector length
alias Length = length;
// vector length without z component
native static final float length2D (const TVec vec) [builtin VecLength2D];
alias Length2D = length2D;
alias length2d = length2D;
// normalises vector
native static final TVec normalise (const TVec vec) [builtin VecNormalize];
alias Normalise = normalise;
alias Normalize = normalise;
alias normalize = normalise;
// normalises 2d vector (ignores z)
native static final TVec normalise2D (const TVec vec) [builtin VecNormalize2D];
alias Normalise2D = normalise2D;
alias normalise2d = normalise2D;
// dot product
native static final float dot (const TVec v1, const TVec v2) [builtin VecDot];
alias DotProduct = dot;
// dot product of 2d vector (ignores z)
native static final float dot2d (const TVec v1, const TVec v2) [builtin VecDot2D];
alias DotProduct2D = dot2d;
alias dot2D = dot2d;
// cross product (perpendicular vector)
native static final TVec cross (const TVec v1, const TVec v2) [builtin VecCross];
alias CrossProduct = cross;
// 2d cross product (signed magnitude, z, as x and y are effectively zero in 2d)
native static final float cross2d (const TVec v1, const TVec v2) [builtin VecCross2D];
alias CrossProduct2D = cross2d;
alias cross2D = cross2d;
// creates vectors for given angle vector
native static final void AngleVectors (const ref TAVec angles, out TVec forward, out TVec right, out TVec up);
// simplified version of AngleVectors, creates only forward vector
native static final void AngleVector (const ref TAVec angles, out TVec forward);
// create angle vector for a vector
native static final void VectorAngles (const ref TVec vec, out TAVec angles);
// get z of point with given x and y coords (don't try to use it on a vertical plane)
native static final float GetPlanePointZ (const ref TPlane plane, const TVec point);
// returns side 0 (front) or 1 (back)
native static final int PointOnPlaneSide (const TVec point, const TPlane *plane);
// rotates a direction vector
native static final TVec RotateDirectionVector (const TVec vec, const TAVec rot);
// rotates vector around Z axis
native static final void VectorRotateAroundZ (ref TVec vec, float angle);
// rotates vector around another vector
native static final TVec RotateVectorAroundVector (const TVec Vector, const TVec Axis, float angle);
// use on `sec_plane_t` to check if the plane is non-sloped
native static final bool IsPlainFloor (const ref TPlane plane); // valid only for floors
native static final bool IsPlainCeiling (const ref TPlane plane); // valid only for ceilings
native static final bool IsSlopedFlat (const ref TPlane plane);

//==========================================================================
//
//  RayLineIntersection
//
//==========================================================================
static final TVec RayLineIntersection (TVec rayO, TVec rayE, TVec vv1, TVec vv2) {
  TVec rayDir = rayE-rayO;
  rayDir.z = 0; // not interested
  //rayDir = Normalise(rayDir);
  float den = (vv2.y-vv1.y)*rayDir.x-(vv2.x-vv1.x)*rayDir.y;
  if (fabs(den) < 0.01) return rayO;
  float e = rayO.y-vv1.y;
  float f = rayO.x-vv1.x;
  float invden = 1.0/den;
  float ua = ((vv2.x-vv1.x)*e-(vv2.y-vv1.y)*f)*invden;
  if (ua >= 0 && ua <= 1) {
    float ub = (rayDir.x*e-rayDir.y*f)*invden;
    if (ua != 0 || ub != 0) {
      TVec res;
      res.x = rayO.x+ua*rayDir.x;
      res.y = rayO.y+ua*rayDir.y;
      res.z = rayO.z;
      return res;
    }
  }
  return rayO;
}




// ////////////////////////////////////////////////////////////////////////// //
// random numbers

// floating random number 0.0 ... 0.999999
native static final float Random ();
// floating random number 0.0 ... 1.0
native static final float FRandomFull ();
// integer random number 0 .. 255
native static final int P_Random ();
// generates a random seen in range [1..0xffff_ffff]
native static final int GenRandomSeedU32 ();

// http://burtleburtle.net/bob/rand/smallprng.html
struct BJPRNGCtx {
  int a, b, c, d;
}

native static final void bjprngSeed (out BJPRNGCtx ctx, int aseed);
// full 32-bit value (so it can be negative)
native static final int bjprngNext (ref BJPRNGCtx ctx);
// [0..1) (WARNING! not really uniform!)
native static final float bjprngNextFloat (ref BJPRNGCtx ctx);



// ////////////////////////////////////////////////////////////////////////// //
// string functions

// string length (utf8-aware)
native static final int strlen (string s);
// compare strings
native static final int strcmp (string s1, string s2);
// compare strings ingnoring case
native static final int stricmp (string s1, string s2);
// append string to string
native static final string strcat (string s1, string s2);
// convert string to lowercase
native static final string strlwr (string s);
// convert string to uppercase
native static final string strupr (string s);
// gets a substring (utf8-aware)
native static final string substr (string Str, int Start, int Len);
// creates one-char non-utf8 string from the given char code&0xff; 0 is allowed
native static final string strFromChar (int ch);
// creates one-char utf8 string from the given char code (or empty string if char code is invalid); 0 is allowed
native static final string strFromCharUtf8 (int ch);
// gets a substring (not utf8-aware)
native static final string strmid (string Str, int Start, optional int Len);
// gets left part of a string (not utf8-aware)
native static final string strleft (string Str, int len);
// gets right part of a string (not utf8-aware)
native static final string strright (string Str, int len);
// gets right part of a string (not utf8-aware); default ch is space
native static final string strrepeat (int len, optional int ch);
// creates string from a number
native static final string strFromInt (int v);
// creates string from a number
native static final string strFromFloat (float v);
// do glob matching (knows '*' and '?')
native static final bool globmatch (const string pat, const string str, optional bool caseSensitive/*=true*/);

// does varargs print into a temporary buffer
native static final string va (string format, ...) [printf,1];

// converts string to integer
native static final int atoi (string str);
// converts string to float
native static final float atof (string str);

// checks if string starts with given string
native static final bool StrStartsWith (string Str, string Check);
alias strStartsWith = StrStartsWith;
// checks if string ends with given string
native static final bool StrEndsWith (string Str, string Check);
alias strEndsWith = StrEndsWith;
// replaces substrings with another string
native static final string StrReplace (string Str, string Search, string Replacement);
alias strReplace = StrReplace;


// ////////////////////////////////////////////////////////////////////////// //
//  Printing to console

// print to console
native static final void print (string format, ...) [printf,1];
// print to console only when developer == 1
native static final void dprint (string format, ...) [printf,1];


// ////////////////////////////////////////////////////////////////////////// //
// type conversions

// float -> int (use `int(val)` instead)
native static final int ftoi (float f);
// int -> float (use `float(val)` instead)
native static final float itof (int f);
// converts string to name (use `string(val)` instead)
native static final name StrToName (string Str);
// converts name to string (use `name(val)` instead)
native static final string NameToStr (name Name);
// converts name to int (as name is just an int internally)
native static final int NameToInt (name Name) [builtin NameToInt];


// ////////////////////////////////////////////////////////////////////////// //
// class methods

native static final class FindClass (name Name);
native static final class FindClassNoCase (name Name);
native static final class FindClassLowerCase (name Name);
native static final bool ClassIsChildOf (class SomeClass, class BaseClass);
native static final name GetClassName (class C);
native static final class GetClassParent (class C);
native static final spawner class GetClassReplacement (class C); // fake return type
native static final class GetClassReplacee (class C);
native static final state FindClassState (class C, name StateName);
native static final int GetClassNumOwnedStates (class C);
native static final state GetClassFirstState (class C);
native static final name GetClassGameObjName (class C);

// ////////////////////////////////////////////////////////////////////////// //
// state methods

enum StateTicKind {
  Normal,
  Random, // random(Arg1, Arg2)
}

native static final bool StateIsInRange (state State, state Start, state End, int MaxDepth);
native static final bool StateIsInSequence (state State, state Start);
native static final name GetStateSpriteName (state State);
native static final int GetStateSpriteFrame (state State);
native static final int GetStateSpriteFrameWidth (state State);
native static final int GetStateSpriteFrameHeight (state State);
native static final void GetStateSpriteFrameSize (state State, out int w, out int h);
native static final float GetStateDuration (state State);
native static final state GetStatePlus (state S, int Offset, optional bool IgnoreJump);
native static final state GetNextState (state State);
native static final state GetNextStateInProg (state State);
native static final bool StateHasAction (state State);
native static final void CallStateAction (Object actobj, state State);
native static final int GetStateSpriteFrameOfsX (state State);
native static final int GetStateSpriteFrameOfsY (state State);
native static final void GetStateSpriteFrameOffset (state State, out int dx, out int dy);
native static final int GetStateMisc1 (state State);
native static final int GetStateMisc2 (state State);
native static final void SetStateMisc1 (state State, int v);
native static final void SetStateMisc2 (state State, int v);
native static final StateTicKind GetStateTicKind (state State);
native static final int GetStateArgN (state State, int argn); // argn is zero-based
native static final void SetStateArgN (state State, int argn, int v); // argn is zero-based
native static final int GetStateFRN (state State);
native static final void SetStateFRN (state State, int v);


// ////////////////////////////////////////////////////////////////////////// //
// iterators

native static final iterator AllObjects (class BaseClass, out Object Obj);
native static final iterator AllClasses (class BaseClass, out class Class);
native static final iterator AllClassStates (class BaseClass, out state State);


// ////////////////////////////////////////////////////////////////////////// //
// misc

// default `skipReplacement` is:
//   `true` for VaVoom and VCC
//   `false` for vccrun
native static final spawner Object SpawnObject (class cid, optional bool skipReplacement);


//==========================================================================
//
//  date/time utils
//
//==========================================================================
struct TTimeVal {
  int secs; // actually, unsigned
  int usecs;
  // for 2030+
  int secshi;
}

struct TDateTime {
  int sec; // [0..60] (yes, *sometimes* it can be 60)
  int min; // [0..59]
  int hour; // [0..23]
  int month; // [0..11]
  int year; // normal value, i.e. 2042 for 2042
  int mday; // [1..31] -- day of the month
  //
  int wday; // [0..6] -- day of the week (0 is sunday)
  int yday; // [0..365] -- day of the year
  int isdst; // is daylight saving time?
}

native static final bool GetTimeOfDay (out TTimeVal tv);
native static final bool DecodeTimeVal (out TDateTime tm, const ref TTimeVal tv);

// see mktime(3)
// `wday`, `yday`, and `isdst` are set on success; `isdst` is used if `usedist` is `true`
native static final bool EncodeTimeVal (out TTimeVal tv, ref TDateTime tm, optional bool usedst);


//==========================================================================
//
//              MISC BUILTINS
//
//==========================================================================
//native final static class FindPkgMObjId (int id, optional name pkgname);
//native final static class FindPkgScriptId (int id, optional name pkgname);
native final static class FindClassByGameObjName (name aname, optional name pkgname);


// ////////////////////////////////////////////////////////////////////////// //
// cvar functions

bitenum {
  CVAR_ARCHIVE, // set to cause it to be saved to config file
  CVAR_USERINFO, // added to userinfo  when changed
  CVAR_SERVERINFO, // added to serverinfo when changed
  CVAR_INIT,  // don't allow change from console at all, but can be set from the command line
  CVAR_LATCH, // save changes until server restart
  CVAR_ROM, // display only, cannot be set by user at all
  CVAR_CHEAT, // can not be changed if cheats are disabled
  CVAR_MODIFIED, // set each time the cvar is changed
  CVAR_FROMMOD, // came from cvarinfo
};

native static final bool CvarExists (name Name); // is cvar exists?
native static final int CvarGetFlags (name Name); // -1: no such var
native static final string GetCvarHelp (name Name); // get cvar help text
native static final void CreateCvar (name Name, string defaultValue, string helpText, optional int flags); // create a new cvar
native static final int GetCvar (name Name); // read int value
native static final void SetCvar (name Name, int value); // set cvar int value
alias GetCvarI = GetCvar; // read int value
alias SetCvarI = SetCvar; // set cvar int value
native static final float GetCvarF (name Name); // read float value
native static final void SetCvarF (name Name, float value); // set cvar float value
native static final string GetCvarS (name Name); // read string value
native static final void SetCvarS (name Name, string value); // set cvar string value
native static final bool GetCvarB (name Name); // read boolean value
native static final void SetCvarB (name Name, bool value); // set cvar boolean value
