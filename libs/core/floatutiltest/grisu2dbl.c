/* Fast and accurate double to string conversion based on Florian Loitsch's
 * Grisu-algorithm ( http://florian.loitsch.com/publications/dtoa-pldi2010.pdf ).
 * based on the code from https://github.com/night-shift/fpconv
 */
/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

//#include "grisu2dbl.h"

#define npowers      87
#define steppowers   8
#define firstpower  -348 /* 10 ^ -348 */

#define expmax  -32
#define expmin  -60


typedef struct Fp {
  uint64_t frac;
  int exp;
} Fp;


static Fp multiply (const Fp *a, const Fp *b) {
  const uint64_t lomask = 0x00000000FFFFFFFF;

  const uint64_t ah_bl = (a->frac>>32)*(b->frac&lomask);
  const uint64_t al_bh = (a->frac&lomask)*(b->frac>>32);
  const uint64_t al_bl = (a->frac&lomask)*(b->frac&lomask);
  const uint64_t ah_bh = (a->frac>>32)*(b->frac>>32);

  uint64_t tmp = (ah_bl&lomask)+(al_bh&lomask)+(al_bl>>32);
  /* round up */
  tmp += 1U<<31;

  Fp fp = {
    ah_bh+(ah_bl>>32)+(al_bh>>32)+(tmp>>32),
    a->exp+b->exp+64
  };

  return fp;
}


static const Fp powers_ten[] = {
  { 18054884314459144840U, -1220 }, { 13451937075301367670U, -1193 },
  { 10022474136428063862U, -1166 }, { 14934650266808366570U, -1140 },
  { 11127181549972568877U, -1113 }, { 16580792590934885855U, -1087 },
  { 12353653155963782858U, -1060 }, { 18408377700990114895U, -1034 },
  { 13715310171984221708U, -1007 }, { 10218702384817765436U, -980 },
  { 15227053142812498563U, -954 },  { 11345038669416679861U, -927 },
  { 16905424996341287883U, -901 },  { 12595523146049147757U, -874 },
  { 9384396036005875287U,  -847 },  { 13983839803942852151U, -821 },
  { 10418772551374772303U, -794 },  { 15525180923007089351U, -768 },
  { 11567161174868858868U, -741 },  { 17236413322193710309U, -715 },
  { 12842128665889583758U, -688 },  { 9568131466127621947U,  -661 },
  { 14257626930069360058U, -635 },  { 10622759856335341974U, -608 },
  { 15829145694278690180U, -582 },  { 11793632577567316726U, -555 },
  { 17573882009934360870U, -529 },  { 13093562431584567480U, -502 },
  { 9755464219737475723U,  -475 },  { 14536774485912137811U, -449 },
  { 10830740992659433045U, -422 },  { 16139061738043178685U, -396 },
  { 12024538023802026127U, -369 },  { 17917957937422433684U, -343 },
  { 13349918974505688015U, -316 },  { 9946464728195732843U,  -289 },
  { 14821387422376473014U, -263 },  { 11042794154864902060U, -236 },
  { 16455045573212060422U, -210 },  { 12259964326927110867U, -183 },
  { 18268770466636286478U, -157 },  { 13611294676837538539U, -130 },
  { 10141204801825835212U, -103 },  { 15111572745182864684U, -77 },
  { 11258999068426240000U, -50 },   { 16777216000000000000U, -24 },
  { 12500000000000000000U,   3 },   { 9313225746154785156U,   30 },
  { 13877787807814456755U,  56 },   { 10339757656912845936U,  83 },
  { 15407439555097886824U, 109 },   { 11479437019748901445U, 136 },
  { 17105694144590052135U, 162 },   { 12744735289059618216U, 189 },
  { 9495567745759798747U,  216 },   { 14149498560666738074U, 242 },
  { 10542197943230523224U, 269 },   { 15709099088952724970U, 295 },
  { 11704190886730495818U, 322 },   { 17440603504673385349U, 348 },
  { 12994262207056124023U, 375 },   { 9681479787123295682U,  402 },
  { 14426529090290212157U, 428 },   { 10748601772107342003U, 455 },
  { 16016664761464807395U, 481 },   { 11933345169920330789U, 508 },
  { 17782069995880619868U, 534 },   { 13248674568444952270U, 561 },
  { 9871031767461413346U,  588 },   { 14708983551653345445U, 614 },
  { 10959046745042015199U, 641 },   { 16330252207878254650U, 667 },
  { 12166986024289022870U, 694 },   { 18130221999122236476U, 720 },
  { 13508068024458167312U, 747 },   { 10064294952495520794U, 774 },
  { 14996968138956309548U, 800 },   { 11173611982879273257U, 827 },
  { 16649979327439178909U, 853 },   { 12405201291620119593U, 880 },
  { 9242595204427927429U,  907 },   { 13772540099066387757U, 933 },
  { 10261342003245940623U, 960 },   { 15290591125556738113U, 986 },
  { 11392378155556871081U, 1013 },  { 16975966327722178521U, 1039 },
  { 12648080533535911531U, 1066 }
};

static const double one_log_ten = 0.30102999566398114;

static Fp find_cachedpow10 (int exp, int *k) {
  // `one_log_ten` was here
  const int approx = -(exp+npowers)*one_log_ten;
  int idx = (approx-firstpower)/steppowers;
  for (;;) {
    const int current = exp+powers_ten[idx].exp+64;
    if (current < expmin) { ++idx; continue; }
    if (current > expmax) { --idx; continue; }
    *k = (firstpower+idx*steppowers);
    return powers_ten[idx];
  }
}


#define dbl_bitsize    (64)
#define dbl_fracmask   (0x000FFFFFFFFFFFFFU)
#define dbl_expmask    (0x7FF0000000000000U)
#define dbl_expshift   (52)
#define dbl_hiddenbit  (0x0010000000000000U)
#define dbl_signmask   (0x8000000000000000U)
#define dbl_expbias    (1023+dbl_expshift)

#define flt_bitsize    (32)
#define flt_fracmask   (0x007fffffu)
#define flt_expmask    (0x7F800000U)
#define flt_expshift   (23)
#define flt_hiddenbit  (0x00800000U)
#define flt_signmask   (0x80000000U)
#define flt_expbias    (127+flt_expshift)


#define absv(n)     ((n) < 0 ? -(n) : (n))
#define minv(a, b)  ((a) < (b) ? (a) : (b))

static const uint64_t tens[] = {
  10000000000000000000U, 1000000000000000000U, 100000000000000000U,
  10000000000000000U, 1000000000000000U, 100000000000000U,
  10000000000000U, 1000000000000U, 100000000000U,
  10000000000U, 1000000000U, 100000000U,
  10000000U, 1000000U, 100000U,
  10000U, 1000U, 100U,
  10U, 1U
};


static inline uint32_t get_fbits (const float f) {
  const union {
    float flt;
    uint32_t i;
  } flt_bits = { f };
  return flt_bits.i;
}


static Fp build_fp_flt (const float f) {
  const uint32_t bits = get_fbits(f);

  Fp fp;
  fp.frac = bits&flt_fracmask;
  fp.exp = (bits&flt_expmask)>>flt_expshift;

  if (fp.exp) {
    fp.frac += flt_hiddenbit;
    fp.exp -= flt_expbias;
  } else {
    fp.exp = -flt_expbias+1;
  }

  return fp;
}


static void normalize_flt (Fp *fp) {
  while ((fp->frac&flt_hiddenbit) == 0) {
    fp->frac <<= 1;
    --fp->exp;
  }
  const int shift = flt_bitsize-flt_expshift-1;
  fp->frac <<= shift;
  fp->exp -= shift;
}


static void get_normalized_boundaries_flt (const Fp *fp, Fp *lower, Fp *upper) {
  upper->frac = (fp->frac<<1)+1;
  upper->exp  = fp->exp-1;

  while ((upper->frac&(flt_hiddenbit<<1)) == 0) {
    upper->frac <<= 1;
    --upper->exp;
  }

  const int u_shift = flt_bitsize-flt_expshift-2;
  upper->frac <<= u_shift;
  upper->exp = upper->exp-u_shift;

  const int l_shift = (fp->frac == flt_hiddenbit ? 2 : 1);
  lower->frac = (fp->frac<<l_shift)-1;
  lower->exp = fp->exp-l_shift;

  lower->frac <<= lower->exp-upper->exp;
  lower->exp = upper->exp;
}


static inline uint64_t get_dbits (const double d) {
  const union {
    double dbl;
    uint64_t i;
  } dbl_bits = { d };
  return dbl_bits.i;
}


static Fp build_fp_dbl (const double d) {
  const uint64_t bits = get_dbits(d);

  Fp fp;
  fp.frac = bits&dbl_fracmask;
  fp.exp = (bits&dbl_expmask)>>dbl_expshift;

  if (fp.exp) {
    fp.frac += dbl_hiddenbit;
    fp.exp -= dbl_expbias;
  } else {
    fp.exp = -dbl_expbias+1;
  }

  return fp;
}


static void normalize_dbl (Fp *fp) {
  while ((fp->frac&dbl_hiddenbit) == 0) {
    fp->frac <<= 1;
    --fp->exp;
  }
  const int shift = dbl_bitsize-dbl_expshift-1;
  fp->frac <<= shift;
  fp->exp -= shift;
}


static void get_normalized_boundaries_dbl (const Fp *fp, Fp *lower, Fp *upper) {
  upper->frac = (fp->frac<<1)+1;
  upper->exp  = fp->exp-1;

  while ((upper->frac&(dbl_hiddenbit<<1)) == 0) {
    upper->frac <<= 1;
    --upper->exp;
  }

  const int u_shift = dbl_bitsize-dbl_expshift-2;
  upper->frac <<= u_shift;
  upper->exp = upper->exp-u_shift;

  const int l_shift = (fp->frac == dbl_hiddenbit ? 2 : 1);
  lower->frac = (fp->frac<<l_shift)-1;
  lower->exp = fp->exp-l_shift;

  lower->frac <<= lower->exp-upper->exp;
  lower->exp = upper->exp;
}


static void round_digit (char *digits, int ndigits, uint64_t delta, uint64_t rem, uint64_t kappa, uint64_t frac) {
  while (rem < frac && delta-rem >= kappa && (rem+kappa < frac || frac-rem > rem+kappa-frac)) {
    --digits[ndigits-1];
    rem += kappa;
  }
}


static int generate_digits (const Fp *fp, Fp *upper, Fp *lower, char *digits, int *K) {
  uint64_t wfrac = upper->frac-fp->frac;
  uint64_t delta = upper->frac-lower->frac;

  Fp one;
  one.frac = 1ULL<<-upper->exp;
  one.exp  = upper->exp;

  uint64_t part1 = upper->frac>>-one.exp;
  uint64_t part2 = upper->frac&(one.frac-1);

  int idx = 0, kappa = 10;
  const uint64_t *divp;
  /* 1000000000 */
  for (divp = tens+10; kappa > 0; ++divp) {
    const uint64_t div = *divp;
    const unsigned digit = part1/div;

    if (digit || idx) digits[idx++] = digit+'0';

    part1 -= digit*div;
    --kappa;

    const uint64_t tmp = (part1 <<-one.exp)+part2;
    if (tmp <= delta) {
      *K += kappa;
      round_digit(digits, idx, delta, tmp, div<<-one.exp, wfrac);
      return idx;
    }
  }

  /* 10 */
  const uint64_t *unit = tens+18;
  for (;;) {
    part2 *= 10;
    delta *= 10;
    --kappa;

    const unsigned digit = part2>>-one.exp;
    if (digit || idx) digits[idx++] = digit+'0';

    part2 &= one.frac-1;
    if (part2 < delta) {
      *K += kappa;
      round_digit(digits, idx, delta, part2, one.frac, wfrac*(*unit));
      return idx;
    }

    --unit;
  }
}


static int grisu2_common (Fp *w, Fp *lower, Fp *upper, char *digits, int *K) {
  int k;
  Fp cp = find_cachedpow10(upper->exp, &k);

  *w = multiply(w, &cp);
  *upper = multiply(upper, &cp);
  *lower = multiply(lower, &cp);

  ++lower->frac;
  --upper->frac;

  *K = -k;

  return generate_digits(w, upper, lower, digits, K);
}


static int grisu2_dbl (const double d, char *digits, int *K) {
  Fp w = build_fp_dbl(d);
  Fp lower, upper;
  get_normalized_boundaries_dbl(&w, &lower, &upper);
  normalize_dbl(&w);
  return grisu2_common(&w, &lower, &upper, digits, K);
}


static int grisu2_flt (const float d, char *digits, int *K) {
  Fp w = build_fp_flt(d);
  Fp lower, upper;
  get_normalized_boundaries_flt(&w, &lower, &upper);
  normalize_flt(&w);
  return grisu2_common(&w, &lower, &upper, digits, K);
}


static int emit_digits (char *digits, int ndigits, char *dest, int K, bool neg) {
  int exp = absv(K+ndigits-1);

  /* write plain integer */
  if (K >= 0 && exp < ndigits+7) {
    memcpy(dest, digits, ndigits);
    memset(dest+ndigits, '0', K);
    return ndigits+K;
  }

  /* write decimal w/o scientific notation */
  if (K < 0 && (K > -7 || exp < 4)) {
    int offset = ndigits-absv(K);
    /* fp < 1.0 -> write leading zero */
    if (offset <= 0) {
      offset = -offset;
      dest[0] = '0';
      dest[1] = '.';
      memset(dest+2, '0', offset);
      memcpy(dest+offset+2, digits, ndigits);
      return ndigits+2+offset;
    } else {
      /* fp > 1.0 */
      memcpy(dest, digits, offset);
      dest[offset] = '.';
      memcpy(dest+offset+1, digits+offset, ndigits-offset);
      return ndigits+1;
    }
  }

  /* write decimal w/ scientific notation */
  ndigits = minv(ndigits, 18-neg);

  int idx = 0;
  dest[idx++] = digits[0];

  if (ndigits > 1) {
    dest[idx++] = '.';
    memcpy(dest+idx, digits+1, ndigits-1);
    idx += ndigits-1;
  }

  dest[idx++] = 'e';

  const char sign = (K+ndigits-1 < 0 ? '-' : '+');
  dest[idx++] = sign;

  int cent = 0;

  if (exp > 99) {
    cent = exp/100;
    dest[idx++] = cent+'0';
    exp -= cent*100;
  }
  if (exp > 9) {
    int dec = exp/10;
    dest[idx++] = dec+'0';
    exp -= dec*10;
  } else if (cent) {
    dest[idx++] = '0';
  }

  dest[idx++] = exp%10+'0';

  return idx;
}


int grisu2_dtoa (const double d, char dest[25]) {
  if (d == 0.0) {
    dest[0] = '0';
    dest[1] = 0;
    return 1;
  }

  const uint64_t bits = get_dbits(d);
  const bool neg = !!(bits&dbl_signmask);;

  if ((bits&dbl_expmask) == dbl_expmask) {
    // not a finite number
    if (bits&dbl_fracmask) {
      dest[0] = 'N';
      dest[1] = 'a';
      dest[2] = 'N';
      dest[3] = 0;
      return 3;
    }
    dest[0] = (neg ? '-' : '+');
    dest[1] = 'I';
    dest[2] = 'n';
    dest[3] = 'f';
    dest[4] = 0;
    return 4;
  }

  int str_len = 0;
  if (neg) dest[str_len++] = '-';

  char digits[18];
  int K = 0;
  const int ndigits = grisu2_dbl(d, digits, &K);

  str_len += emit_digits(digits, ndigits, dest+str_len, K, neg);
  dest[str_len] = 0;

  return str_len;
}


int grisu2_ftoa (const float f, char dest[25]) {
  if (f == 0.0f) {
    dest[0] = '0';
    dest[1] = 0;
    return 1;
  }

  const uint32_t bits = get_fbits(f);
  const bool neg = !!(get_fbits(f)&flt_signmask);

  if ((bits&flt_expmask) == flt_expmask) {
    // not a finite number
    if (bits&flt_fracmask) {
      dest[0] = 'N';
      dest[1] = 'a';
      dest[2] = 'N';
      dest[3] = 0;
      return 3;
    }
    dest[0] = (neg ? '-' : '+');
    dest[1] = 'I';
    dest[2] = 'n';
    dest[3] = 'f';
    dest[4] = 0;
    return 4;
  }

  int str_len = 0;
  if (neg) dest[str_len++] = '-';

  char digits[18];
  int K = 0;
  const int ndigits = grisu2_flt(f, digits, &K);

  str_len += emit_digits(digits, ndigits, dest+str_len, K, neg);
  dest[str_len] = 0;

  return str_len;
}
