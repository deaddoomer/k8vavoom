diff -puEZBbw -r _pt/alloc-posix.c _curr/alloc-posix.c
--- _pt/alloc-posix.c	2019-10-13 08:38:59.000000000 +0300
+++ _curr/alloc-posix.c	2020-01-12 11:41:54.000000000 +0200
@@ -107,7 +107,7 @@ unsigned char* mi_mbsdup(const unsigned
 int mi_dupenv_s(char** buf, size_t* size, const char* name) mi_attr_noexcept {
   if (buf==NULL || name==NULL) return EINVAL;
   if (size != NULL) *size = 0;
-  #pragma warning(suppress:4996)
+  //k8:fuck you, m$vc:#pragma warning(suppress:4996)
   char* p = getenv(name);
   if (p==NULL) {
     *buf = NULL;
@@ -128,7 +128,7 @@ int mi_wdupenv_s(unsigned short** buf, s
   *buf = NULL;
   return EINVAL;
 #else
-  #pragma warning(suppress:4996)
+  //k8:fuck you, m$vc:#pragma warning(suppress:4996)
   unsigned short* p = (unsigned short*)_wgetenv((const wchar_t*)name);
   if (p==NULL) {
     *buf = NULL;
diff -puEZBbw -r _pt/alloc.c _curr/alloc.c
--- _pt/alloc.c	2020-01-12 11:36:57.000000000 +0200
+++ _curr/alloc.c	2020-01-12 11:45:54.000000000 +0200
@@ -11,9 +11,11 @@ terms of the MIT license. A copy of the
 #include <string.h>  // memset, memcpy, strlen
 #include <stdlib.h>  // malloc, exit
 
+/*k8: no overrides
 #define MI_IN_ALLOC_C
 #include "alloc-override.c"
 #undef MI_IN_ALLOC_C
+*/
 
 // ------------------------------------------------------
 // Allocation
@@ -624,7 +626,8 @@ with a C++ compiler we can implement thi
 use a C compiler we cannot throw a `bad_alloc` exception
 but we call `exit` instead (i.e. not returning).
 -------------------------------------------------------*/
-
+#if 0
+//k8: get lost, i'm not using overrides
 #ifdef __cplusplus
 #include <new>
 static bool mi_try_new_handler(bool nothrow) {
@@ -705,3 +708,4 @@ void* mi_new_aligned_nothrow(size_t n, s
   while (p == NULL && mi_try_new_handler(true));
   return p;
 }
+#endif
diff -puEZBbw -r _pt/init.c _curr/init.c
--- _pt/init.c	2020-01-12 11:36:57.000000000 +0200
+++ _curr/init.c	2020-01-12 12:03:33.000000000 +0200
@@ -308,6 +308,14 @@ static void _mi_thread_done(mi_heap_t* d
   #pragma message("define a way to call mi_thread_done when a thread is done")
 #endif
 
+//k8:mingw fix
+#if defined(_WIN32) && !defined(MI_SHARED_LIB)
+__declspec(dllimport) DWORD WINAPI FlsAlloc (PFLS_CALLBACK_FUNCTION lpCallback);
+//__declspec(dllimport) PVOID WINAPI FlsGetValue (DWORD dwFlsIndex);
+__declspec(dllimport) WINBOOL WINAPI FlsSetValue (DWORD dwFlsIndex, PVOID lpFlsData);
+//__declspec(dllimport) WINBOOL WINAPI FlsFree (DWORD dwFlsIndex);
+#endif
+
 // Set up handlers so `mi_thread_done` is called automatically
 static void mi_process_setup_auto_thread_done(void) {
   static bool tls_initialized = false; // fine if it races
@@ -512,6 +520,12 @@ static void mi_process_done(void) {
     return TRUE;
   }
 
+#elif defined(__GNUC__) || defined(__clang__)
+  // GCC,Clang: use the constructor attribute
+  static void __attribute__((constructor)) _mi_process_init(void) {
+    mi_process_load();
+  }
+
 #elif defined(__cplusplus)
   // C++: use static initialization to detect process start
   static bool _mi_process_init(void) {
@@ -520,12 +534,6 @@ static void mi_process_done(void) {
   }
   static bool mi_initialized = _mi_process_init();
 
-#elif defined(__GNUC__) || defined(__clang__)
-  // GCC,Clang: use the constructor attribute
-  static void __attribute__((constructor)) _mi_process_init(void) {
-    mi_process_load();
-  }
-
 #elif defined(_MSC_VER)
   // MSVC: use data section magic for static libraries
   // See <https://www.codeguru.com/cpp/misc/misc/applicationcontrol/article.php/c6945/Running-Code-Before-and-After-Main.htm>
diff -puEZBbw -r _pt/mimalloc-types.h _curr/mimalloc-types.h
--- _pt/mimalloc-types.h	2020-01-12 11:36:57.000000000 +0200
+++ _curr/mimalloc-types.h	2020-01-12 12:15:24.000000000 +0200
@@ -10,14 +10,16 @@ terms of the MIT license. A copy of the
 
 #include <stddef.h>   // ptrdiff_t
 #include <stdint.h>   // uintptr_t, uint16_t, etc
-#include <mimalloc-atomic.h>  // _Atomic
+#include "mimalloc-atomic.h"  // _Atomic
 
 // ------------------------------------------------------
 // Variants
 // ------------------------------------------------------
 
 // Define NDEBUG in the release version to disable assertions.
-// #define NDEBUG
+#ifndef NDEBUG
+# define NDEBUG
+#endif
 
 // Define MI_STAT as 1 to maintain statistics; set it to 2 to have detailed statistics (but costs some performance).
 // #define MI_STAT 1
diff -puEZBbw -r _pt/mimalloc.h _curr/mimalloc.h
--- _pt/mimalloc.h	2020-01-12 11:36:57.000000000 +0200
+++ _curr/mimalloc.h	2020-01-12 12:13:04.000000000 +0200
@@ -10,6 +10,26 @@ terms of the MIT license. A copy of the
 
 #define MI_MALLOC_VERSION 120   // major + 2 digits minor
 
+#if defined(_MSC_VER)
+# error "k8: m$vc support in mi-malloc is intentionally broken."
+#endif
+
+//k8: defaults
+// just in case, it is not used
+#define MI_STATIC_LIB
+#ifdef MI_SHARED_LIB
+# error "don't do this!"
+#endif
+
+#if defined(MI_SECURE) || (MI_SECURE != 0)
+# error "don't do this!"
+#endif
+
+#ifdef MI_DEBUG
+# undef MI_DEBUG
+#endif
+#define MI_DEBUG 0
+
 // ------------------------------------------------------
 // Compiler specific attributes
 // ------------------------------------------------------
diff -puEZBbw -r _pt/options.c _curr/options.c
--- _pt/options.c	2020-01-12 11:36:57.000000000 +0200
+++ _curr/options.c	2020-01-12 11:48:50.000000000 +0200
@@ -58,7 +58,8 @@ static mi_option_desc_t options[_mi_opti
   // the following options are experimental and not all combinations make sense.
   { 1, UNINIT, MI_OPTION(eager_commit) },        // note: needs to be on when eager_region_commit is enabled
   #ifdef _WIN32   // and BSD?
-  { 0, UNINIT, MI_OPTION(eager_region_commit) }, // don't commit too eagerly on windows (just for looks...)
+  //k8: fuck off, i don't care how it looks in shitdows shitmanager
+  { 1, UNINIT, MI_OPTION(eager_region_commit) }, // don't commit too eagerly on windows (just for looks...)
   #else
   { 1, UNINIT, MI_OPTION(eager_region_commit) },
   #endif
@@ -202,7 +203,7 @@ static void mi_out_buf_stderr(const char
 
 // Should be atomic but gives errors on many platforms as generally we cannot cast a function pointer to a uintptr_t.
 // For now, don't register output from multiple threads.
-#pragma warning(suppress:4180)
+//k8:fuck you, m$vc:#pragma warning(suppress:4180)
 static mi_output_fun* volatile mi_out_default; // = NULL
 
 static mi_output_fun* mi_out_get_default(void) {
@@ -320,13 +321,13 @@ mi_attr_noreturn void _mi_fatal_error(co
 
 static void mi_strlcpy(char* dest, const char* src, size_t dest_size) {
   dest[0] = 0;
-  #pragma warning(suppress:4996)
+  //k8:fuck you, m$vc:#pragma warning(suppress:4996)
   strncpy(dest, src, dest_size - 1);
   dest[dest_size - 1] = 0;
 }
 
 static void mi_strlcat(char* dest, const char* src, size_t dest_size) {
-  #pragma warning(suppress:4996)
+  //k8:fuck you, m$vc:#pragma warning(suppress:4996)
   strncat(dest, src, dest_size - 1);
   dest[dest_size - 1] = 0;
 }
diff -puEZBbw -r _pt/os.c _curr/os.c
--- _pt/os.c	2020-01-12 11:36:57.000000000 +0200
+++ _curr/os.c	2020-01-12 12:00:50.000000000 +0200
@@ -55,7 +55,7 @@ static void* mi_align_down_ptr(void* p,
 static size_t os_page_size = 4096;
 
 // minimal allocation granularity
-static size_t os_alloc_granularity = 4096;
+static __attribute__((unused)) size_t os_alloc_granularity = 4096;
 
 // if non-zero, use large page allocation
 static size_t large_os_page_size = 0;
@@ -96,6 +96,7 @@ size_t _mi_os_good_alloc_size(size_t siz
 #include <winternl.h>
 typedef PVOID    (__stdcall *PVirtualAlloc2)(HANDLE, PVOID, SIZE_T, ULONG, ULONG, /* MEM_EXTENDED_PARAMETER* */ void*, ULONG);
 typedef NTSTATUS (__stdcall *PNtAllocateVirtualMemoryEx)(HANDLE, PVOID*, SIZE_T*, ULONG, ULONG, /* MEM_EXTENDED_PARAMETER* */ PVOID, ULONG);
+/*k8:fuck you, shitdoze!
 static PVirtualAlloc2 pVirtualAlloc2 = NULL;
 static PNtAllocateVirtualMemoryEx pNtAllocateVirtualMemoryEx = NULL;
 
@@ -133,6 +134,7 @@ static bool mi_win_enable_large_os_pages
   }
   return (ok!=0);
 }
+*/
 
 void _mi_os_init(void) {
   // get the page size
@@ -141,6 +143,7 @@ void _mi_os_init(void) {
   if (si.dwPageSize > 0) os_page_size = si.dwPageSize;
   if (si.dwAllocationGranularity > 0) os_alloc_granularity = si.dwAllocationGranularity;
   // get the VirtualAlloc2 function
+  /*k8:fuck you, shitdoze:
   HINSTANCE  hDll;
   hDll = LoadLibrary(TEXT("kernelbase.dll"));
   if (hDll != NULL) {
@@ -157,6 +160,7 @@ void _mi_os_init(void) {
   if (mi_option_is_enabled(mi_option_large_os_pages) || mi_option_is_enabled(mi_option_reserve_huge_os_pages)) {
     mi_win_enable_large_os_pages();
   }
+  */
 }
 #elif defined(__wasi__)
 void _mi_os_init() {
@@ -194,7 +198,7 @@ static bool mi_os_mem_free(void* addr, s
   if (was_committed) _mi_stat_decrease(&stats->committed, size); 
   _mi_stat_decrease(&stats->reserved, size);
   if (err) {
-#pragma warning(suppress:4996)
+//k8:fuck you, m$vc:#pragma warning(suppress:4996)
     _mi_warning_message("munmap failed: %s, addr 0x%8li, size %lu\n", strerror(errno), (size_t)addr, size);
     return false;
   }
@@ -203,7 +207,7 @@ static bool mi_os_mem_free(void* addr, s
   }
 }
 
-static void* mi_os_get_aligned_hint(size_t try_alignment, size_t size);
+static __attribute__((unused)) void* mi_os_get_aligned_hint(size_t try_alignment, size_t size);
 
 #ifdef _WIN32
 static void* mi_win_virtual_allocx(void* addr, size_t size, size_t try_alignment, DWORD flags) {
@@ -422,7 +426,7 @@ static void* mi_unix_mmap(void* addr, si
 static volatile _Atomic(intptr_t) aligned_base;
 
 // Return a 4MiB aligned address that is probably available
-static void* mi_os_get_aligned_hint(size_t try_alignment, size_t size) {
+static __attribute__((unused)) void* mi_os_get_aligned_hint(size_t try_alignment, size_t size) {
   if (try_alignment == 0 || try_alignment > MI_SEGMENT_SIZE) return NULL;
   if ((size%MI_SEGMENT_SIZE) != 0) return NULL;
   intptr_t hint = mi_atomic_add(&aligned_base, size);
diff -puEZBbw -r _pt/stats.c _curr/stats.c
--- _pt/stats.c	2020-01-12 11:36:57.000000000 +0200
+++ _curr/stats.c	2020-01-12 11:51:50.000000000 +0200
@@ -392,7 +392,7 @@ double _mi_clock_end(double start) {
 #if defined(_WIN32)
 #include <windows.h>
 #include <psapi.h>
-#pragma comment(lib,"psapi.lib")
+/*k8:fuck you, m$vc:#pragma comment(lib,"psapi.lib")
 
 static double filetime_secs(const FILETIME* ftime) {
   ULARGE_INTEGER i;
@@ -401,7 +401,9 @@ static double filetime_secs(const FILETI
   double secs = (double)(i.QuadPart) * 1.0e-7; // FILETIME is in 100 nano seconds
   return secs;
 }
+*/
 static void mi_process_info(double* utime, double* stime, size_t* peak_rss, size_t* page_faults, size_t* page_reclaim, size_t* peak_commit) {
+/*k8:fuck you, m$vc:
   FILETIME ct;
   FILETIME ut;
   FILETIME st;
@@ -416,6 +418,13 @@ static void mi_process_info(double* utim
   *page_faults = (size_t)info.PageFaultCount;
   *peak_commit = (size_t)info.PeakPagefileUsage;
   *page_reclaim = 0;
+*/
+  *utime = 0;
+  *stime = 0;
+  *peak_rss = 0;
+  *page_faults = 0;
+  *page_reclaim = 0;
+  *peak_commit = 0;
 }
 
 #elif defined(__unix__) || defined(__unix) || defined(unix) || (defined(__APPLE__) && defined(__MACH__))
